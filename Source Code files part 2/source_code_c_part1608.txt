          pCall->Packet.CallId = NewCallId;

            // Our call ID is a function of the serial number (initially random)
            // and the DeviceId.  This is so we can (CallId&0xfff) on incoming packets
            // and instantly have the proper id.

            pPacket->CallId = htons(pCall->Packet.CallId);
            pPacket->SerialNumber = htons(pCall->SerialNumber);
            pPacket->MinimumBPS = htonl(300);
            pPacket->MaximumBPS = htonl(100000000);
            pPacket->BearerType = htonl(BEARER_ANALOG|BEARER_DIGITAL);  // Either
            pPacket->FramingType = htonl(FRAMING_ASYNC|FRAMING_SYNC);  // Either
            pPacket->RecvWindowSize = htons(PPTP_RECV_WINDOW); // ToDo: make configurable
            pPacket->ProcessingDelay = 0;
            pPacket->PhoneNumberLength = htons((USHORT)strlen(pCall->CallerId));
            strcpy(pPacket->PhoneNumber, pCall->CallerId);
            // ToDo: subaddress

            NdisReleaseSpinLock(&pCall->Lock);

            CtlSend(pCall->pCtl, pPacket); // ToDo: return value
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallEventOutboundTunnelEstablished\n")));
    return NDIS_STATUS_SUCCESS;
}



NDIS_STATUS
CallReceiveDatagramCallback(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)pContext;
    PTA_IP_ADDRESS pIpAddress = (PTA_IP_ADDRESS)pAddress;
    PCALL_SESSION pCall = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PIP4_HEADER pIp = (PIP4_HEADER)pBuffer;
    PGRE_HEADER pGre = (PGRE_HEADER)(pIp + 1);
    PVOID pPayload;
    LONG GreLength, PayloadLength;
    BOOLEAN ReturnBufferNow = TRUE;
    PDGRAM_CONTEXT pDgContext = ALIGN_UP_POINTER(pBuffer+ulLength, ULONG_PTR);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallReceiveDatagramCallback\n")));

    ASSERT(sizeof(IP4_HEADER)==20);

    DEBUGMEM(DBG_PACKET, pBuffer, ulLength, 1);

    NdisInterlockedIncrement(&Counters.PacketsReceived);
    // First line of defense against bad packets.

    if (pIp->HeaderLength*4!=sizeof(IP4_HEADER) ||
        pIp->Version!=4 ||
        pIp->Protocol!=PptpProtocolNumber ||
        ulLength<sizeof(IP4_HEADER)+sizeof(GRE_HEADER)+sizeof(ULONG) ||
        pIpAddress->TAAddressCount!=1 ||
        pIpAddress->Address[0].AddressLength!=TDI_ADDRESS_LENGTH_IP ||
        pIpAddress->Address[0].AddressType!=TDI_ADDRESS_TYPE_IP)
    {
        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: IP header invalid\n")));
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }

    GreLength = sizeof(GRE_HEADER) +
                (pGre->SequenceNumberPresent ? sizeof(ULONG) : 0) +
                (pGre->AckSequenceNumberPresent ? sizeof(ULONG) : 0);

    pPayload = (PUCHAR)pGre + GreLength;
    PayloadLength = (signed)ulLength - sizeof(IP4_HEADER) - GreLength;

    if (htons(pGre->KeyLength)>PayloadLength ||
        pGre->StrictSourceRoutePresent ||
        pGre->RecursionControl ||
        !pGre->KeyPresent ||
        pGre->RoutingPresent ||
        pGre->ChecksumPresent ||
        pGre->Version!=1 ||
        pGre->Flags ||
        pGre->ProtocolType!=GRE_PROTOCOL_TYPE_NS)
    {
        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: GRE header invalid\n")));
        DEBUGMEM(DBG_PACKET, pGre, GreLength, 1);
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }
    else
    {
        // Just in case the datagram is longer than necessary, take only what
        // the GRE header indicates.
        PayloadLength = htons(pGre->KeyLength);
    }

    // Demultiplex the packet
    pCall = CallGetCall(pAdapter, CallIdToDeviceId(htons(pGre->KeyCallId)));

    if (!IS_CALL(pCall))
    {
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }

    if(!PptpValidateAddress || pIpAddress->Address[0].Address[0].in_addr == pCall->Remote.Address.Address[0].Address[0].in_addr)
    {
        pDgContext->pBuffer = pBuffer;
        pDgContext->pGreHeader = pGre;
        pDgContext->hCtdi = pAdapter->hCtdiDg;
    
        NdisAcquireSpinLock(&pCall->Lock);
        pCall->UseUdp = FALSE;
        NdisReleaseSpinLock(&pCall->Lock);
    
        if (CallQueueReceivePacket(pCall, pDgContext)==NDIS_STATUS_SUCCESS)
        {
            REFERENCE_OBJECT(pCall);
            ReturnBufferNow = FALSE;
        }
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
    }

crdcDone:
    if (ReturnBufferNow)
    {
        (void)
        CtdiReceiveComplete(pAdapter->hCtdiDg, pBuffer);
    }
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        NdisInterlockedIncrement(&Counters.PacketsRejected);
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallReceiveDatagramCallback %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CallReceiveUdpCallback(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)pContext;
    PTA_IP_ADDRESS pIpAddress = (PTA_IP_ADDRESS)pAddress;
    PCALL_SESSION pCall = NULL;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PGRE_HEADER pGre = (PGRE_HEADER)pBuffer;
    PVOID pPayload;
    LONG GreLength, PayloadLength;
    BOOLEAN ReturnBufferNow = TRUE;
    PDGRAM_CONTEXT pDgContext = ALIGN_UP_POINTER(pBuffer+ulLength, ULONG_PTR);
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallReceiveDatagramCallback\n")));

    DEBUGMEM(DBG_PACKET, pBuffer, ulLength, 1);

    NdisInterlockedIncrement(&Counters.PacketsReceived);
    // First line of defense against bad packets.

    if (pIpAddress->Address[0].Address[0].sin_port!=ntohs(PptpProtocolNumber) ||
        ulLength<sizeof(GRE_HEADER)+sizeof(ULONG) ||
        pIpAddress->TAAddressCount!=1 ||
        pIpAddress->Address[0].AddressLength!=TDI_ADDRESS_LENGTH_IP ||
        pIpAddress->Address[0].AddressType!=TDI_ADDRESS_TYPE_IP)
    {
        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: GRE header invalid\n")));
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }

    GreLength = sizeof(GRE_HEADER) +
                (pGre->SequenceNumberPresent ? sizeof(ULONG) : 0) +
                (pGre->AckSequenceNumberPresent ? sizeof(ULONG) : 0);

    pPayload = (PUCHAR)pGre + GreLength;
    PayloadLength = (signed)ulLength - GreLength;

    if (htons(pGre->KeyLength)>PayloadLength ||
        pGre->StrictSourceRoutePresent ||
        pGre->RecursionControl ||
        !pGre->KeyPresent ||
        pGre->RoutingPresent ||
        pGre->ChecksumPresent ||
        pGre->Version!=1 ||
        pGre->Flags ||
        pGre->ProtocolType!=GRE_PROTOCOL_TYPE_NS)
    {
        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: GRE header invalid\n")));
        DEBUGMEM(DBG_PACKET, pGre, GreLength, 1);
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }
    else
    {
        // Just in case the datagram is longer than necessary, take only what
        // the GRE header indicates.
        PayloadLength = htons(pGre->KeyLength);
    }

    // Demultiplex the packet
    pCall = CallGetCall(pAdapter, CallIdToDeviceId(htons(pGre->KeyCallId)));

    if (!IS_CALL(pCall))
    {
        Status = NDIS_STATUS_FAILURE;
        goto crdcDone;
    }

    pDgContext->pBuffer = pBuffer;
    pDgContext->pGreHeader = pGre;
    pDgContext->hCtdi = pAdapter->hCtdiUdp;

    NdisAcquireSpinLock(&pCall->Lock);
    pCall->UseUdp = TRUE;
    NdisReleaseSpinLock(&pCall->Lock);

    if (CallQueueReceivePacket(pCall, pDgContext)==NDIS_STATUS_SUCCESS)
    {
        REFERENCE_OBJECT(pCall);
        ReturnBufferNow = FALSE;
    }

crdcDone:
    if (ReturnBufferNow)
    {
        (void)
        CtdiReceiveComplete(pAdapter->hCtdiUdp, pBuffer);
    }
    if (Status!=NDIS_STATUS_SUCCESS)
    {
        NdisInterlockedIncrement(&Counters.PacketsRejected);
        // ToDo: cleanup?
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallReceiveDatagramCallback %08x\n"), Status));
    return Status;
}

BOOLEAN
CallConnectToCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl,
    IN BOOLEAN CallLocked
    )
{
    BOOLEAN Connected = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallConnectCtl\n")));
    if (!CallLocked)
    {
        NdisAcquireSpinLock(&pCall->Lock);
    }
    ASSERT_LOCK_HELD(&pCall->Lock);
    NdisAcquireSpinLock(&pCall->pAdapter->Lock);
    if (!pCall->pCtl)
    {
        pCall->pCtl = pCtl;
        InsertTailList(&pCtl->CallList, &pCall->ListEntry);
        Connected = TRUE;
        REFERENCE_OBJECT(pCtl); // Pair in CallDisconnectFromCtl
    }
    NdisReleaseSpinLock(&pCall->pAdapter->Lock);
    if (!CallLocked)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallConnectCtl %d\n"), Connected));
    return Connected;
}

VOID
CallDisconnectFromCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl
    )
{
    BOOLEAN Deref = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallDisconnectFromCtl\n")));
    NdisAcquireSpinLock(&pCall->Lock);
    NdisAcquireSpinLock(&pCall->pAdapter->Lock);
    ASSERT(pCall->pCtl==pCtl);
    if (pCall->pCtl==pCtl)
    {
        pCall->pCtl = NULL;
        RemoveEntryList(&pCall->ListEntry);
        Deref = TRUE;
    }
    NdisReleaseSpinLock(&pCall->pAdapter->Lock);
    NdisReleaseSpinLock(&pCall->Lock);
    if (Deref)
    {
        DEREFERENCE_OBJECT(pCtl);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallDisconnectFromCtl\n")));
}


NDIS_STATUS
CallSetLinkInfo(
    PPPTP_ADAPTER pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pRequest
    )
{
    PCALL_SESSION pCall;
    PCONTROL_TUNNEL pCtl;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPPTP_SET_LINK_INFO_PACKET pPacket;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallSetLinkInfo\n")));

    // Verify the ID
    pCall = CallGetCall(pAdapter, LinkHandleToId(pRequest->NdisLinkHandle));

    if (!pCall)
    {
        Status = NDIS_STATUS_FAILURE;
        goto csliDone;
    }

    ASSERT(IS_CALL(pCall));
    NdisAcquireSpinLock(&pCall->Lock);
    pCall->WanLinkInfo = *pRequest;
#if 0
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.MaxSendFrameSize);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.MaxRecvFrameSize);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.HeaderPadding);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.TailPadding);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.SendACCM);
    DBG_X(DBG_NDIS, pCall->WanLinkInfo.RecvACCM);
#endif

    pCtl = pCall->pCtl;
    NdisReleaseSpinLock(&pCall->Lock);

    // Report the new ACCMs to the peer.
    pPacket = CtlAllocPacket(pCtl, SET_LINK_INFO);
    if (!pPacket)
    {
        Status = NDIS_STATUS_RESOURCES;
    }
    else
    {
        pPacket->PeerCallId = ntohs(pCall->Remote.CallId);
        pPacket->SendAccm = ntohl(pCall->WanLinkInfo.SendACCM);
        pPacket->RecvAccm = ntohl(pCall->WanLinkInfo.RecvACCM);
        Status = CtlSend(pCtl, pPacket);
    }

csliDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallSetLinkInfo %08x\n"), Status));
    return Status;
}

VOID
CallSetState(
    IN PCALL_SESSION pCall,
    IN CALL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    )
{
    ULONG OldLineCallState = CallGetLineCallState(pCall->State);
    ULONG NewLineCallState = CallGetLineCallState(State);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallSetState %d\n"), State));

    if (State!=pCall->State)
    {
        LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"Call(%d) state change.  Old:%d  New:%d\n"),
                              LOGHDR(26, pCall->Remote.Address.Address[0].Address[0].in_addr),
                              pCall->DeviceId, pCall->State, State));
    }
    ASSERT(IS_CALL(pCall));
    if (!Locked)
    {
        NdisAcquireSpinLock(&pCall->Lock);
    }
    ASSERT_LOCK_HELD(&pCall->Lock);
    pCall->State = State;
    if (!Locked)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }
    if (OldLineCallState!=NewLineCallState &&
        pCall->hTapiCall)
    {
        NDIS_TAPI_EVENT TapiEvent;

        DEBUGMSG(DBG_TAPI|DBG_NDIS, (DTEXT("PPTP: Indicating new LINE_CALLSTATE %x\n"), NewLineCallState));

#if SINGLE_LINE
        TapiEvent.htLine = pCall->pAdapter->Tapi.hTapiLine;
#else
        TapiEvent.htLine = pCall->hTapiLine;
#endif
        TapiEvent.htCall = pCall->hTapiCall;
        TapiEvent.ulMsg = LINE_CALLSTATE;
        TapiEvent.ulParam1 = NewLineCallState;
        TapiEvent.ulParam2 = StateParam;
        TapiEvent.ulParam3 = LINEMEDIAMODE_DIGITALDATA;  // ToDo: is this required?

        if (Locked)
        {
            NdisReleaseSpinLock(&pCall->Lock);
        }
        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_TAPI_INDICATION,
                            &TapiEvent,
                            sizeof(TapiEvent));
        if (Locked)
        {
            NdisAcquireSpinLock(&pCall->Lock);
        }

    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallSetState\n")));
}

GRE_HEADER DefaultGreHeader = {
    0,                          // Recursion control
    0,                          // Strict source route present
    0,                          // Sequence Number present
    1,                          // Key present
    0,                          // Routing present
    0,                          // Checksum present
    1,                          // Version
    0,                          // Flags
    0,                          // Ack present
    GRE_PROTOCOL_TYPE_NS
};

VOID
CallpSendCompleteDeferred(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCALL_SESSION pCall = pWorkItem->Context;
    PNDIS_WAN_PACKET pPacket = pWorkItem->pBuffer;
    NDIS_STATUS Result = pWorkItem->Length;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpSendCompleteDeferred\n")));
    NdisMWanSendComplete(pCall->pAdapter->hMiniportAdapter,
                         pPacket,
                         Result);
    DEREFERENCE_OBJECT(pCall);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpSendCompleteDeferred\n")));
}

VOID
CallpSendComplete(
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PUCHAR                      pBuffer,
    IN      NDIS_STATUS                 Result
    )
{
    PCALL_SESSION pCall = pContext;
    PNDIS_WAN_PACKET pPacket = pDatagramContext;

    DEBUGMSG(DBG_FUNC|DBG_TX, (DTEXT("+CallpSendComplete pCall=%x, pPacket=%x, Result=%x\n"), pCall, pPacket, Result));

    ASSERT(IS_CALL(pCall));
    if (Result!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Failed to send datagram %08x\n"), Result));
        NdisInterlockedIncrement(&Counters.PacketsSentError);
    }

    if (pPacket==&pCall->Ack.Packet)
    {
        NdisAcquireSpinLock(&pCall->Lock);
        pCall->Ack.PacketQueued = FALSE;
        NdisReleaseSpinLock(&pCall->Lock);
    }
    else
    {
        // When we complet packets immediately, we can get into trouble if a
        // packet has recursed.  We need a way to short-circuit a recursing
        // completion so we don't blow the stack.
        // We store a count of times we've completed a packet in the same
        // context and defer to a thread after a certain number of trips through.

        if ((NdisInterlockedIncrement(&pCall->SendCompleteRecursion)<PptpSendRecursionLimit) ||
            ScheduleWorkItem(CallpSendCompleteDeferred, pCall, pPacket, Result)!=NDIS_STATUS_SUCCESS)
        {
            NdisMWanSendComplete(pCall->pAdapter->hMiniportAdapter,
                                 pPacket,
                                 Result);
            DEREFERENCE_OBJECT(pCall);
        }
        NdisInterlockedDecrement(&pCall->SendCompleteRecursion);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpSendComplete\n")));
}

#define TRANSMIT_SEND_SEQ 1
#define TRANSMIT_SEND_ACK 2
#define TRANSMIT_MASK 0x3

ULONG GreSize[4] = {
    sizeof(GRE_HEADER),
    sizeof(GRE_HEADER) + sizeof(ULONG),
    sizeof(GRE_HEADER) + sizeof(ULONG),
    sizeof(GRE_HEADER) + sizeof(ULONG) * 2
};

NDIS_STATUS
CallTransmitPacket(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pPacket,
    ULONG               Flags,
    ULONG               SequenceNumber,
    ULONG               Ack
    )
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ULONG Length;
    PULONG pSequence, pAck;
    PGRE_HEADER pGreHeader;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallTransmitPacket\n")));

    if (!IS_CALL(pCall) || pCall->State!=STATE_CALL_ESTABLISHED)
    {
        goto ctpDone;
    }
    Length = GreSize[Flags&TRANSMIT_MASK];
    pGreHeader = (PGRE_HEADER) (pPacket->CurrentBuffer - Length);
    pSequence = pAck = (PULONG)(pGreHeader + 1);

    *pGreHeader = DefaultGreHeader;

    if (Flags&TRANSMIT_SEND_SEQ)
    {
        pGreHeader->SequenceNumberPresent = 1;
        *pSequence = htonl(SequenceNumber);
        pAck++;
    }
    pGreHeader->KeyLength = htons((USHORT)pPacket->CurrentLength);
    pGreHeader->KeyCallId = htons(pCall->Remote.CallId);
    if (Flags&TRANSMIT_SEND_ACK)
    {
        pGreHeader->AckSequenceNumberPresent = 1;
        *pAck = htonl(Ack);
    }

    Status = CtdiSendDatagram((pCall->UseUdp ? pCall->pAdapter->hCtdiUdp : pCall->pAdapter->hCtdiDg),
                              CallpSendComplete,
                              pCall,
                              pPacket,
                              (PTRANSPORT_ADDRESS)&pCall->Remote.Address,
                              (PVOID)pGreHeader,
                              pPacket->CurrentLength + Length);

    NdisInterlockedIncrement(&Counters.PacketsSent);

ctpDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CallTransmitPacket %08x\n"), Status));
    return Status;
}

VOID
CallProcessRxPackets(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
    ULONG_PTR ReceiveMax = 100;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallProcessRxPackets\n")));

    ASSERT(IS_CALL(pCall));

    NdisAcquireSpinLock(&pCall->Lock);

    // First send up any received packets.
    while (ReceiveMax-- && !IsListEmpty(&pCall->RxPacketList))
    {
        PDGRAM_CONTEXT pDgram;
        PLIST_ENTRY pListEntry = RemoveHeadList(&pCall->RxPacketList);
        pCall->RxPacketsPending--;
        pDgram = CONTAINING_RECORD(pListEntry,
                                   DGRAM_CONTEXT,
                                   ListEntry);
        if (pCall->State==STATE_CALL_ESTABLISHED &&
            htons(pDgram->pGreHeader->KeyCallId)==pCall->Packet.CallId &&
            IS_LINE_UP(pCall))
        {
            LONG GreLength, PayloadLength;
            PVOID pPayload;
            BOOLEAN SetAckTimer = FALSE;
            ULONG Sequence;

            if (pDgram->pGreHeader->SequenceNumberPresent)
            {
                // Call is still in good state, indicate the packet.
                Sequence = htonl(GreSequence(pDgram->pGreHeader));

                pCall->Remote.SequenceNumber = Sequence + 1;

                if (IsListEmpty(&pCall->TxPacketList) && !pCall->Ack.PacketQueued && pDgram->pGreHeader->KeyLength)
                {
                    // We only ack if there aren't already other transmits sent, and this
                    // isn't an ack-only packet.
                    SetAckTimer = pCall->Ack.PacketQueued = TRUE;
                }
            }
            if (!PptpEchoAlways)
            {
                pCall->pCtl->Echo.Needed = FALSE;
            }
            NdisReleaseSpinLock(&pCall->Lock);
            if (SetAckTimer)
            {
                NdisMSetTimer(&pCall->Ack.Timer, 100);
            }
            GreLength = sizeof(GRE_HEADER) +
                        (pDgram->pGreHeader->SequenceNumberPresent ? sizeof(ULONG) : 0) +
                        (pDgram->pGreHeader->AckSequenceNumberPresent ? sizeof(ULONG) : 0);

            pPayload = (PUCHAR)pDgram->pGreHeader + GreLength;
            PayloadLength = htons(pDgram->pGreHeader->KeyLength);
            if (PayloadLength && pDgram->pGreHeader->SequenceNumberPresent)
            {
                NdisMWanIndicateReceive(&Status,
                                        pCall->pAdapter->hMiniportAdapter,
                                        pCall->NdisLinkContext,
                                        pPayload,
                                        PayloadLength);
                if (Status==NDIS_STATUS_SUCCESS)
                {
                    NdisMWanIndicateReceiveComplete(pCall->pAdapter->hMiniportAdapter,
                                                    pCall->NdisLinkContext);
                }
            }
            NdisAcquireSpinLock(&pCall->Lock);
        }
        else if (pCall->State!=STATE_CALL_ESTABLISHED || !IS_LINE_UP(pCall))
        {
            // If this call is being torn down, we want to put priority on
            // clearing out any packets left over.  It should go fast since
            // we're not indicating them up.
            ReceiveMax = 100;
        }
        DEREFERENCE_OBJECT(pCall);
        (void)CtdiReceiveComplete(pDgram->hCtdi, pDgram->pBuffer);
    }

    if (IsListEmpty(&pCall->RxPacketList))
    {
        pCall->Receiving = FALSE;
    }
    else
    {
        PptpQueueDpc(&pCall->ReceiveDpc);
    }

    NdisReleaseSpinLock(&pCall->Lock);

    DEREFERENCE_OBJECT(pCall);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallProcessRxPackets\n")));
}

BOOLEAN
CallProcessPackets(
    PCALL_SESSION   pCall,
    ULONG           TransferMax
    )
{
    LIST_ENTRY LocalList;
    BOOLEAN MorePacketsToTransfer = FALSE;
    ULONG TransmitFlags = 0;
    NDIS_STATUS Status;
    ULONG Ack, Seq;
    ULONG ReceiveMax = TransferMax;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallProcessPackets\n")));

    ASSERT(sizeof(GRE_HEADER)==8);
    ASSERT(IS_CALL(pCall));

    REFERENCE_OBJECT(pCall);
    InitializeListHead(&LocalList);
    NdisAcquireSpinLock(&pCall->Lock);

    Seq = pCall->Packet.SequenceNumber;

    while (TransferMax-- && !IsListEmpty(&pCall->TxPacketList))
    {
        PLIST_ENTRY pListEntry = RemoveHeadList(&pCall->TxPacketList);
        InsertTailList(&LocalList, pListEntry);
        if (CONTAINING_RECORD(pListEntry,
                              NDIS_WAN_PACKET,
                              WanPacketQueue)!=&pCall->Ack.Packet)
        {
            pCall->Packet.SequenceNumber++;
        }
    }
    if (!IsListEmpty(&pCall->TxPacketList) || !IsListEmpty(&pCall->RxPacketList))
    {
        MorePacketsToTransfer = TRUE;
    }
    else
    {
        pCall->Transferring = FALSE;
    }
    if (!IsListEmpty(&LocalList) &&
        pCall->Packet.AckNumber!=pCall->Remote.SequenceNumber)
    {
        TransmitFlags |= TRANSMIT_SEND_ACK;
        pCall->Packet.AckNumber = pCall->Remote.SequenceNumber;
        // Ack tracks the Remote.SequenceNumber, which is actually the
        // sequence of the NEXT packet, so we need to translate when
        // we prepare to send an ack.
        Ack = pCall->Remote.SequenceNumber - 1;
    }

    NdisReleaseSpinLock(&pCall->Lock);

    while (!IsListEmpty(&LocalList))
    {
        PNDIS_WAN_PACKET pPacket;
        PLIST_ENTRY pListEntry = RemoveHeadList(&LocalList);

        pPacket = CONTAINING_RECORD(pListEntry,
                                    NDIS_WAN_PACKET,
                                    WanPacketQueue);

        if (pPacket!=&pCall->Ack.Packet || TransmitFlags&TRANSMIT_SEND_ACK)
        {
            if (pPacket==&pCall->Ack.Packet)
            {
                TransmitFlags &= ~TRANSMIT_SEND_SEQ;
            }
            else
            {
                TransmitFlags |= TRANSMIT_SEND_SEQ;
                Seq++;
            }
            Status = CallTransmitPacket(pCall, pPacket, TransmitFlags, Seq-1, Ack);

            if (Status!=NDIS_STATUS_PENDING && pPacket!=&pCall->Ack.Packet)
            {
                if (pPacket==&pCall->Ack.Packet)
                {
                    NdisAcquireSpinLock(&pCall->Lock);
                    pCall->Ack.PacketQueued = FALSE;
                    NdisReleaseSpinLock(&pCall->Lock);
                }
                else
                {
                    // We didn't send the packet, so tell NDIS we're done with it.
                    NdisMWanSendComplete(pCall->pAdapter->hMiniportAdapter,
                                         pPacket,
                                         NDIS_STATUS_SUCCESS);  // so I lied.  Sue me.
                    DEREFERENCE_OBJECT(pCall);
                }
            }
        }
        else
        {
            // it was the ack-only packet, and we already sent an ack.

            NdisAcquireSpinLock(&pCall->Lock);
            pCall->Ack.PacketQueued = FALSE;
            NdisReleaseSpinLock(&pCall->Lock);
        }

        TransmitFlags &= ~TRANSMIT_SEND_ACK;
    }
    DEREFERENCE_OBJECT(pCall);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallProcessPackets %d\n"), MorePacketsToTransfer));
    return MorePacketsToTransfer;
}

VOID
CallpAckTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpAckTimeout\n")));


    if (IS_CALL(pCall))
    {
        if (pCall->State!=STATE_CALL_ESTABLISHED ||
            CallQueueTransmitPacket(pCall, &pCall->Ack.Packet)!=NDIS_STATUS_PENDING)
        {
            NdisAcquireSpinLock(&pCall->Lock);
            pCall->Ack.PacketQueued = FALSE;
            NdisReleaseSpinLock(&pCall->Lock);
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpAckTimeout\n")));
}

VOID
CallpDialTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpDialTimeout\n")));

    LOGMSG(FLL_USER, (DTEXT(LOGHDRS"Call(%d) timed out in dialing state\n"),
                      LOGHDR(4, pCall->Remote.Address.Address[0].Address[0].in_addr),
                      pCall->DeviceId));

    ASSERT(IS_CALL(pCall));
    if (pCall->State==STATE_CALL_DIALING)
    {
        CallCleanup(pCall, UNLOCKED);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpDialTimeout\n")));
}

VOID
CallpCloseTimeout(
    IN PVOID SystemSpecific1,
    IN PVOID Context,
    IN PVOID SystemSpecific2,
    IN PVOID SystemSpecific3
    )
{
    PCALL_SESSION pCall = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpCloseTimeout\n")));

    ASSERT(IS_CALL(pCall));
    pCall->Close.Expedited = TRUE;
    CallCleanup(pCall, UNLOCKED);
    // ToDo: check for failure.

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpCloseTimeout\n")));
}

VOID CallpFinalDeref(PCALL_SESSION pCall)
{
    DEBUGMSG(DBG_FUNC|DBG_CALL, (DTEXT("+CallpFinalDeref\n")));
}

VOID CallpCleanupLooseEnds(PPPTP_ADAPTER pAdapter)
{
    ULONG i;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallpCleanupLooseEnds\n")));

    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
        PCALL_SESSION pCall = pAdapter->pCallArray[i];
        if (IS_CALL(pCall))
        {
            NdisAcquireSpinLock(&pCall->Lock);
            if (IS_CALL(pCall) && pCall->State==STATE_CALL_CLEANUP)
            {
                CallCleanup(pCall, LOCKED);
            }
            NdisReleaseSpinLock(&pCall->Lock);
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CallpCleanupLooseEnds\n")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\debug.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DEBUG.H - debugging macros, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/2/1998
*
*****************************************************************************/
#ifndef DEBUG_H
#define DEBUG_H

#include "dbgapi.h"

// Compile time debug flags

#ifndef MEM_CHECKING
#if DBG
#define MEM_CHECKING 1
#else
#define MEM_CHECKING 0
#endif
#endif

#ifndef LIST_CHECKING
#if DBG
#define LIST_CHECKING 1
#else
#define LIST_CHECKING 0
#endif
#endif

#ifndef LOCK_CHECKING
#define LOCK_CHECKING 0
#endif

#define DBG_ERR(Status)   (((Status)!=NDIS_STATUS_SUCCESS && (Status)!=NDIS_STATUS_PENDING)? DBG_ERROR : 0)

#define DBG_ERROR       DEBUGZONE(0)
#define DBG_WARN        DEBUGZONE(1)
#define DBG_FUNC        DEBUGZONE(2)
#define DBG_INIT        DEBUGZONE(3)

#define DBG_TX          DEBUGZONE(4)
#define DBG_RX          DEBUGZONE(5)
#define DBG_TDI         DEBUGZONE(6)
#define DBG_TUNNEL      DEBUGZONE(7)

#define DBG_CALL        DEBUGZONE(8)
#define DBG_PACKET      DEBUGZONE(9)
#define DBG_NDIS        DEBUGZONE(10)
#define DBG_TAPI        DEBUGZONE(11)

#define DBG_THREAD      DEBUGZONE(12)
#define DBG_POOL        DEBUGZONE(13)
#define DBG_REF         DEBUGZONE(14)
#define DBG_LOG         DEBUGZONE(15)


#define DBG_X(dbgs, x)  DEBUGMSG(dbgs, (DTEXT(#x"==0x%x\n"), (x)))
#define DBG_D(dbgs, d)  DEBUGMSG(dbgs, (DTEXT(#d"==%d\n"), (d)))
#define DBG_S(dbgs, s)  DEBUGMSG(dbgs, (DTEXT(#s"==\"%hs\"\n"), (s)))

#if LOCK_CHECKING
typedef struct MY_SPIN_LOCK {
    NDIS_SPIN_LOCK;
    CHAR File[12];
    ULONG Line;
} MY_SPIN_LOCK, *PMY_SPIN_LOCK;
VOID FASTCALL _MyAcquireSpinLock(PMY_SPIN_LOCK pLock, PUCHAR file, UINT line);
#define MyAcquireSpinLock(Lock) _MyAcquireSpinLock((Lock), __FILE__, __LINE__)
#define MyReleaseSpinLock(Lock) NdisReleaseSpinLock((PNDIS_SPIN_LOCK)(Lock))
#else
typedef NDIS_SPIN_LOCK MY_SPIN_LOCK, *PMY_SPIN_LOCK;
#define MyAcquireSpinLock NdisAcquireSpinLock
#define MyReleaseSpinLock NdisReleaseSpinLock
#endif

#if MEM_CHECKING
#define MyMemAlloc(size, tag) _MyMemAlloc((size), (tag), __FILE__,__LINE__)
PVOID _MyMemAlloc(UINT, ULONG, PUCHAR, UINT);
VOID InitMemory();
VOID DeinitMemory();
#else
#define InitMemory()
#define DeinitMemory()
PVOID
MyMemAlloc(UINT size, ULONG tag);
#endif

VOID
MyMemFree(
    PVOID memptr,
    UINT size);


#if LIST_CHECKING
PLIST_ENTRY FASTCALL MyInterlockedInsertHeadList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock);
PLIST_ENTRY FASTCALL MyInterlockedInsertTailList(PLIST_ENTRY Head, PLIST_ENTRY Entry, PNDIS_SPIN_LOCK SpinLock);
PLIST_ENTRY FASTCALL MyInterlockedRemoveHeadList(PLIST_ENTRY Head, PNDIS_SPIN_LOCK SpinLock);
VOID FASTCALL CheckList(PLIST_ENTRY ListHead);
#define CheckedRemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_Entry;\
    CheckList(Entry);\
    _EX_Entry = (Entry);\
    _EX_Flink = _EX_Entry->Flink;\
    _EX_Blink = _EX_Entry->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    _EX_Entry->Flink = _EX_Entry->Blink = NULL; \
    }
#ifdef RemoveEntryList
#undef RemoveEntryList
#endif
#define RemoveEntryList CheckedRemoveEntryList

#define CheckedInsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    CheckList(ListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    CheckList(ListHead);\
    }
#ifdef InsertHeadList
#undef InsertHeadList
#endif
#define InsertHeadList CheckedInsertHeadList

#define CheckedInsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    CheckList(ListHead);\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    CheckList(ListHead);\
    }
#ifdef InsertTailList
#undef InsertTailList
#endif
#define InsertTailList CheckedInsertTailList

#define CheckedRemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    if(!IsListEmpty(ListHead)){ \
        RemoveEntryList((ListHead)->Flink);\
        CheckList(ListHead);\
    }
#ifdef RemoveHeadList
#undef RemoveHeadList
#endif
#define RemoveHeadList CheckedRemoveHeadList

#define CheckedRemoveTailList(ListHead) \
    (ListHead)->Blink;\
    if(!IsListEmpty(ListHead)){ \
        RemoveEntryList((ListHead)->Blink);\
        CheckList(ListHead);\
    }
#ifdef RemoveTailList
#undef RemoveTailList
#endif
#define RemoveTailList CheckedRemoveTailList

#else // ! LIST_CHECKING
#define CheckList(h)
#define MyInterlockedInsertHeadList NdisInterlockedInsertHeadList
#define MyInterlockedInsertTailList NdisInterlockedInsertTailList
#define MyInterlockedRemoveHeadList NdisInterlockedRemoveHeadList
#endif

#define MyInterlockedRemoveEntryList(Entry, Lock)       \
    {                                                   \
        NdisAcquireSpinLock(Lock);                      \
        RemoveEntryList(Entry);                         \
        NdisReleaseSpinLock(Lock);                      \
    }

#if DBG
   struct PPTP_ADAPTER * gAdapter;
#endif

#if DBG
    char *ControlStateToString(ULONG State);
    char *CallStateToString(ULONG State);
#endif

#endif //DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\filelog.h ===
/*****************************************************************************
*
*   Copyright (c) 1999 Microsoft Corporation
*
*   FILELOG.H - File Logging
*
*   Author:     Jeff spencer
*
*   Created:    2/19/1999
*
*****************************************************************************/

VOID __cdecl OsFileLogInit();
VOID __cdecl OsFileLogOpen();
VOID __cdecl OsLogPrintf(char *pszFmt, ... );
VOID __cdecl OsFileLogClose(void);
VOID __cdecl OsFileLogFlush(void);
VOID __cdecl OsFileLogShutdown(void);

// File Logging Levels
#define FLL_OFF      0
#define FLL_USER     1  // Simple logging useful for product support people
#define FLL_DETAILED 2  // Detailed logging helpful for debugging

#define LOGMSG(level,format)  \
    if( FileLogLevel>=(level)){   \
        LARGE_INTEGER Time;                               \
        NdisGetCurrentSystemTime(&Time);                   \
        OsLogPrintf format;      \
    }

//#define LOGHDRS    ":::%d:%08x:%08x:%d.%d.%d.%d:"

//#define LOGHDR(id, ip) (id), Time.HighPart, Time.LowPart, IPADDR(ip)

extern ULONG FileLogLevel;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\raspptp.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   RASPPTP.C - RASPPTP driver main module (DriverEntry, etc.)
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    );

#pragma NDIS_INIT_FUNCTION(DriverEntry)

NDIS_HANDLE ghNdisWrapper;
PDRIVER_OBJECT gDriverObject;
COUNTERS Counters;

ULONG AbortLoad = FALSE;
ULONG FileLogLevel = FLL_OFF;   // Default to file logging level off

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT pDriverObject,
    IN PUNICODE_STRING pRegistryPath
    )
{
    NDIS_MINIPORT_CHARACTERISTICS Characteristics;
    NDIS_STATUS Status;

    DEFAULT_DEBUG_OPTIONS(
                          DBG_ERROR |
                          DBG_WARN |
                          //DBG_FUNC |
                          DBG_INIT |
                          //DBG_TX |
                          //DBG_RX |
                          DBG_TDI |
                          DBG_TUNNEL |
                          DBG_CALL |
                          DBG_NDIS |
                          DBG_TAPI |
                          //DBG_THREAD |
                          //DBG_POOL |
                          //DBG_REF |
                          //DBG_LOG |
                          0
                          );

    DEBUGMSG(DBG_INIT|DBG_FUNC, (DTEXT("+DriverEntry\n")));

    // Provide an easy way to avoid loading.
    if (AbortLoad)
    {
        return STATUS_CANCELLED;
    }

    gDriverObject = pDriverObject;

    // Standard NDIS initiailization:
    //      InitializeWrapper
    //      Fill in the characteristics
    //      Register the miniport

    NdisMInitializeWrapper(&ghNdisWrapper,
                           pDriverObject,
                           pRegistryPath,
                           NULL
                           );

    NdisZeroMemory(&Characteristics, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

    Characteristics.MajorNdisVersion        = NDIS_MAJOR_VERSION;
    Characteristics.MinorNdisVersion        = NDIS_MINOR_VERSION;

    Characteristics.Reserved                = NDIS_USE_WAN_WRAPPER;
    Characteristics.InitializeHandler       = MiniportInitialize;
    Characteristics.HaltHandler             = MiniportHalt;
    Characteristics.ResetHandler            = MiniportReset;
    Characteristics.QueryInformationHandler = MiniportQueryInformation;
    Characteristics.SetInformationHandler   = MiniportSetInformation;
    Characteristics.WanSendHandler          = MiniportWanSend;
    // ToDo: Characteristics.ReturnPacketHandler     = MpReturnPacket;

    Status = NdisMRegisterMiniport(ghNdisWrapper,
                                   &Characteristics,
                                   sizeof(Characteristics));

    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP: NdisMRegisterMiniport failed %x\n"), Status));
        NdisTerminateWrapper(ghNdisWrapper, NULL);
        return STATUS_UNSUCCESSFUL;
    }

    DEBUGMSG(DBG_INIT|DBG_FUNC, (DTEXT("-DriverEntry\n")));
    return STATUS_SUCCESS;
}


VOID
AdapterCleanup(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       pContext,
    IN  PVOID       SystemSpecific2,
    IN  PVOID       SystemSpecific3
    )
{
    PPPTP_ADAPTER pAdapter = pContext;
    extern VOID CtlpCleanupLooseEnds(PPPTP_ADAPTER pAdapter);
    extern VOID CallpCleanupLooseEnds(PPPTP_ADAPTER pAdapter);
    extern VOID CtdiCleanupLooseEnds(VOID);
    DEBUGMSG(DBG_FUNC, (DTEXT("+AdapterCleanup\n")));

    CtdiCleanupLooseEnds();
    CtlpCleanupLooseEnds(pAdapter);
    CallpCleanupLooseEnds(pAdapter);

    DEBUGMSG(DBG_FUNC, (DTEXT("-AdapterCleanup\n")));
}
PPPTP_ADAPTER
AdapterAlloc(NDIS_HANDLE NdisAdapterHandle)
{
    PPPTP_ADAPTER pAdapter;
    NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
    UINT i;

    DEBUGMSG(DBG_FUNC, (DTEXT("+AdapterAlloc\n")));

    pAdapter = MyMemAlloc(sizeof(PPTP_ADAPTER), TAG_PPTP_ADAPTER);
    if (!pAdapter)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-AdapterAlloc NULL\n")));
        return NULL;
    }

    NdisZeroMemory(pAdapter, sizeof(PPTP_ADAPTER));

    pAdapter->hMiniportAdapter = NdisAdapterHandle;
    NdisAllocateSpinLock(&pAdapter->Lock);

    // Fill the NDIS_WAN_INFO structure.

    pAdapter->Info.MaxFrameSize     = 1400;
    pAdapter->Info.MaxTransmit      = PptpMaxTransmit;
    pAdapter->Info.HeaderPadding    = sizeof(GRE_HEADER) + sizeof(ULONG)*2
                                      + sizeof(IP4_HEADER) + sizeof(UDP_HEADER);
    pAdapter->Info.TailPadding      = 0;
    pAdapter->Info.Endpoints        = PptpWanEndpoints;
    pAdapter->Info.MemoryFlags      = 0;
    pAdapter->Info.HighestAcceptableAddress = HighestAcceptableAddress;
    pAdapter->Info.FramingBits      = PPP_FRAMING |
                                      PPP_COMPRESS_ADDRESS_CONTROL |
                                      PPP_COMPRESS_PROTOCOL_FIELD |
                                      TAPI_PROVIDER;
    pAdapter->Info.DesiredACCM      = 0;

    pAdapter->pCallArray = MyMemAlloc(sizeof(PCALL_SESSION)*pAdapter->Info.Endpoints, TAG_PPTP_CALL_LIST);
    if (!pAdapter->pCallArray)
    {
        AdapterFree(pAdapter);
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-AdapterAlloc Call NULL\n")));
        return NULL;
    }
    NdisZeroMemory(pAdapter->pCallArray, sizeof(PCALL_SESSION)*pAdapter->Info.Endpoints);

    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
        // Allocate the call on TapiOpen
        //pAdapter->pCallArray[i] = CallAlloc(pAdapter);
        pAdapter->pCallArray[i] = NULL;
    }

    NdisInitializeListHead(&pAdapter->ControlTunnelList);

    NdisMInitializeTimer(&pAdapter->CleanupTimer,
                         pAdapter->hMiniportAdapter,
                         AdapterCleanup,
                         pAdapter);
    NdisMSetPeriodicTimer(&pAdapter->CleanupTimer, 60000); // 60 second intervals

#if DBG
    gAdapter = pAdapter;
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("-AdapterAlloc %08x\n"), pAdapter));
    return pAdapter;
}

VOID
AdapterFree(PPPTP_ADAPTER pAdapter)
{
    ULONG i;
    BOOLEAN NotUsed;
    if (!pAdapter)
    {
        return;
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("+AdapterFree\n")));
    NdisMCancelTimer(&pAdapter->CleanupTimer, &NotUsed);
    ASSERT(IsListEmpty(&pAdapter->ControlTunnelList));
    if (pAdapter->pCallArray)
    {
        for (i=0; i<pAdapter->Info.Endpoints; i++)
        {
            CallFree(pAdapter->pCallArray[i]);
        }
        MyMemFree(pAdapter->pCallArray, sizeof(PCALL_SESSION)*pAdapter->Info.Endpoints);
    }
    NdisFreeSpinLock(&pAdapter->Lock);
    MyMemFree(pAdapter, sizeof(PPTP_ADAPTER));

#if DBG
    gAdapter = NULL;
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("-AdapterFree\n")));
}

PLIST_ENTRY FASTCALL
EnumListEntry(
    IN PLIST_ENTRY pHead,
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    )
{
    PLIST_ENTRY pEntry = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+EnumListEntry\n")));

    ASSERT(pEnum->Signature==ENUM_SIGNATURE);

    if (pLock)
    {
        NdisAcquireSpinLock(pLock);
    }
    do
    {
        if (pEnum->ListEntry.Flink==NULL)
        {
            // First call
            if (!IsListEmpty(pHead))
            {
                pEntry = pHead->Flink;
                InsertHeadList(pEntry, &pEnum->ListEntry);
            }
        }
        else
        {
            if (pEnum->ListEntry.Flink!=pHead)
            {
                pEntry = pEnum->ListEntry.Flink;
                RemoveEntryList(&pEnum->ListEntry);
                InsertHeadList(pEntry, &pEnum->ListEntry);
            }
            else
            {
                RemoveEntryList(&pEnum->ListEntry);
                pEnum->ListEntry.Flink = pEnum->ListEntry.Blink = NULL;
                pEntry = NULL;
            }
        }
    } while ( pEntry &&
              ((PENUM_CONTEXT)pEntry)->Signature==ENUM_SIGNATURE );
    if (pLock)
    {
        NdisReleaseSpinLock(pLock);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-EnumListEntry %08x\n"), pEntry));
    return pEntry;
}

VOID
EnumComplete(
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+EnumComplete\n")));
    if (pEnum->ListEntry.Flink)
    {
        if (pLock)
        {
            NdisAcquireSpinLock(pLock);
        }
        RemoveEntryList(&pEnum->ListEntry);
        pEnum->ListEntry.Flink = pEnum->ListEntry.Blink = NULL;
        if (pLock)
        {
            NdisReleaseSpinLock(pLock);
        }
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-EnumComplete\n")));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\raspptp.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   RASPPTP.H - RASPPTP includes, defines, structures and prototypes
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#ifndef RASPPTP_H
#define RASPPTP_H

#ifndef SINGLE_LINE
#define SINGLE_LINE 1
#endif

#include "osinc.h"

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

#include "debug.h"
#include "protocol.h"
#include "ctdi.h"
#include "filelog.h"

//
// NDIS version compatibility in OSINC.H
//

// TAPI version compatibility

#define TAPI_EXT_VERSION            0x00010000

// Registry values
extern ULONG PptpMaxTransmit;
extern ULONG PptpWanEndpoints;
extern ULONG PptpEchoTimeout;
extern BOOLEAN PptpEchoAlways;
extern USHORT PptpControlPort;
extern USHORT PptpProtocolNumber;
extern USHORT PptpUdpPort;
extern ULONG PptpTunnelConfig;
extern LONG PptpSendRecursionLimit;
extern ULONG PptpValidateAddress;
#define PPTP_SEND_RECURSION_LIMIT_DEFAULT 5

#define CONFIG_INITIATE_UDP         BIT(0)
#define CONFIG_ACCEPT_UDP           BIT(1)
#define CONFIG_DONT_ACCEPT_GRE      BIT(2)

typedef struct {
    ULONG   Address;
    ULONG   Mask;
} CLIENT_ADDRESS, *PCLIENT_ADDRESS;

extern ULONG NumClientAddresses;
extern PCLIENT_ADDRESS ClientList;
extern BOOLEAN PptpAuthenticateIncomingCalls;
extern ULONG CtdiTcpDisconnectTimeout;
extern ULONG CtdiTcpConnectTimeout;

#define TAPI_MAX_LINE_ADDRESS_LENGTH 32
#define TAPI_ADDR_PER_LINE          1
#define TAPI_ADDRESSID              0
#define TAPI_DEVICECLASS_NAME       "tapi/line"
#define TAPI_DEVICECLASS_ID         1
#define NDIS_DEVICECLASS_NAME       "ndis"
#define NDIS_DEVICECLASS_ID         2

#define PPTP_CLOSE_TIMEOUT          1000 // ms

#define MAX_TARGET_ADDRESSES        16

#define CALL_STATES_MASK            (LINECALLSTATE_UNKNOWN |        \
                                     LINECALLSTATE_IDLE |           \
                                     LINECALLSTATE_OFFERING |       \
                                     LINECALLSTATE_DIALING |        \
                                     LINECALLSTATE_PROCEEDING |     \
                                     LINECALLSTATE_CONNECTED |      \
                                     LINECALLSTATE_DISCONNECTED)

// Memory allocation tags
#define TAG(v)  ((((v)&0xff)<<24) | (((v)&0xff00)<<8) | (((v)&0xff0000)>>8) | (((v)&0xff000000)>>24))
#define TAG_PPTP_ADAPTER        TAG('PTPa')
#define TAG_PPTP_TUNNEL         TAG('PTPT')
#define TAG_PPTP_TIMEOUT        TAG('PTPt')
#define TAG_PPTP_CALL           TAG('PTPC')
#define TAG_PPTP_CALL_LIST      TAG('PTPc')
#define TAG_PPTP_ADDR_LIST      TAG('PTPL')
#define TAG_CTDI_DATA           TAG('PTCD')
#define TAG_CTDI_L_CONNECT      TAG('PTCL')
#define TAG_CTDI_CONNECT_INFO   TAG('PTCN')
#define TAG_CTDI_DGRAM          TAG('PTCG')
#define TAG_CTDI_ROUTE          TAG('PTCR')
#define TAG_CTDI_IRP            TAG('PTCI')
#define TAG_CTDI_MESSAGE        TAG('PTCM')
#define TAG_CTL_PACKET          TAG('PTTP')
#define TAG_CTL_CONNINFO        TAG('PTTI')
#define TAG_WORK_ITEM           TAG('PTWI')
#define TAG_THREAD              TAG('PTTH')


#define BIT(b)   (1<<(b))

#define LOCKED TRUE
#define UNLOCKED FALSE

/* Types and structs -------------------------------------------------------*/

typedef void (*FREEFUNC)(PVOID);
typedef struct {
    LONG                Count;
    FREEFUNC            FreeFunction;
} REFERENCE_COUNT;

#define INIT_REFERENCE_OBJECT(o,freefunc)                   \
    {                                                       \
        (o)->Reference.FreeFunction = (freefunc);           \
        (o)->Reference.Count = 1;                           \
        DEBUGMSG(DBG_REF, (DTEXT("INIT REF   (%08x, %d) %s\n"), (o), (o)->Reference.Count, #o)); \
    }

#define REFERENCE_OBJECT(o)                                                         \
    {                                                                               \
        NdisInterlockedIncrement(&(o)->Reference.Count);                            \
        DEBUGMSG(DBG_REF, (DTEXT("REFERENCE  (%08x, %d) %s %d\n"), (o), (o)->Reference.Count, #o, __LINE__)); \
    }

#define DEREFERENCE_OBJECT(o)                                                                   \
    {                                                                                           \
        ULONG Ref = NdisInterlockedDecrement(&(o)->Reference.Count);                            \
        DEBUGMSG(DBG_REF, (DTEXT("DEREFERENCE(%08x, %d) %s %d\n"), (o), (o)->Reference.Count, #o, __LINE__));   \
        if (Ref==0)                                                                             \
        {                                                                                       \
            ASSERT((o)->Reference.FreeFunction);                                                \
            DEBUGMSG(DBG_REF, (DTEXT("Last reference released, freeing %08x\n"), (o)));         \
            (o)->Reference.FreeFunction(o);                                                     \
        }                                                                                       \
    }

#define REFERENCE_COUNT(o) ((o)->Reference.Count)

#define IS_CALL(call) ((call) && (call)->Signature==TAG_PPTP_CALL)
#define IS_CTL(ctl)  ((ctl) && (ctl)->Signature==TAG_PPTP_TUNNEL)
#define IS_LINE_UP(call) (!((call)->Close.Checklist&CALL_CLOSE_LINE_DOWN))

// If you change this enum then be sure to change ControlStateToString() also.
typedef enum {
    STATE_CTL_INVALID = 0,
    STATE_CTL_LISTEN,
    STATE_CTL_DIALING,
    STATE_CTL_WAIT_REQUEST,
    STATE_CTL_WAIT_REPLY,
    STATE_CTL_ESTABLISHED,
    STATE_CTL_WAIT_STOP,
    STATE_CTL_CLEANUP,
    NUM_CONTROL_STATES
} CONTROL_STATE;

// If you change this enum then be sure to change CallStateToString() also.
typedef enum {
    STATE_CALL_INVALID = 0,
    STATE_CALL_CLOSED,
    STATE_CALL_IDLE,
    STATE_CALL_OFFHOOK,
    STATE_CALL_OFFERING,
    STATE_CALL_PAC_OFFERING,
    STATE_CALL_PAC_WAIT,
    STATE_CALL_DIALING,
    STATE_CALL_PROCEEDING,
    STATE_CALL_ESTABLISHED,
    STATE_CALL_WAIT_DISCONNECT,
    STATE_CALL_CLEANUP,
    NUM_CALL_STATES
} CALL_STATE;

typedef struct PPTP_ADAPTER *PPPTP_ADAPTER;

typedef struct CONTROL_TUNNEL {
    LIST_ENTRY          ListEntry;
    // Used to attach this control connection to the miniport context.

    REFERENCE_COUNT     Reference;
    // Not protected by spinlock

    ULONG               Signature;
    // PTPT

    PPPTP_ADAPTER       pAdapter;
    // The associated adapter

    CONTROL_STATE       State;
    // State of this control connection

    LIST_ENTRY          CallList;
    // List of calls supported by this control connection.
    // Protected by adapter lock

    BOOLEAN             Inbound;
    // Indicates whether this tunnel originated here or elsewhere

    UCHAR               Padding[sizeof(ULONG_PTR)];
    // We pad to protect the portions of the struct protected by different locks
    // from alpha alignment problems.

    // ^^^^^^ Protected by Adapter->Lock^^^^^^^^
    //===================================================================
    NDIS_SPIN_LOCK      Lock;
    // vvvvvv Protected by Ctl->Lock vvvvvvvvvvv

    BOOLEAN             Cleanup;
    // True means a cleanup has been scheduled or is active.

    LIST_ENTRY          MessageList;
    // Each entry represents a pptp message that has been sent and
    // is awaiting a response or at least waiting to be acknowledged
    // by the transport

    HANDLE              hCtdiEndpoint;
    // Handle for the tunnel local endpoint.  The connection must be closed first.

    HANDLE              hCtdi;
    // Handle for control tunnel TCP connection.

    UCHAR               PartialPacketBuffer[MAX_CONTROL_PACKET_LENGTH];
    ULONG               BytesInPartialBuffer;
    // TCP data received that does not constitute a full packet.

    struct {
        TA_IP_ADDRESS   Address;
        ULONG           Version;
        ULONG           Framing;
        ULONG           Bearer;
        UCHAR           HostName[MAX_HOSTNAME_LENGTH];
        UCHAR           Vendor[MAX_VENDOR_LENGTH];
    } Remote;
    // Information provided by the remote.

    PULONG              PptpMessageLength;
    // Points to an array of precalculated packet lengths, based on version

    struct {
        NDIS_MINIPORT_TIMER Timer;
        ULONG           Identifier;
        BOOLEAN         Needed;

        #define         PPTP_ECHO_TIMEOUT_DEFAULT   60

    } Echo;

    #define             PPTP_MESSAGE_TIMEOUT_DEFAULT 30

    NDIS_MINIPORT_TIMER WaitTimeout;
    NDIS_MINIPORT_TIMER StopTimeout;

    ULONG               Speed;
    // Contains line speed of this connect in BPS

} CONTROL_TUNNEL, *PCONTROL_TUNNEL;

typedef struct CALL_SESSION {
    LIST_ENTRY          ListEntry;
    // Used to attach a call session to a control connection

    ULONG               Signature;
    // PTPC

    PPPTP_ADAPTER       pAdapter;
    // The associated adapter

    LIST_ENTRY          TxListEntry;
    // If we have packets to send, this connects us to the queue of the transmitting thread.

    PCONTROL_TUNNEL     pCtl;
    // Pointer to this call's control connection.

    UCHAR               Padding[sizeof(ULONG_PTR)];
    // We pad to protect the portions of the struct protected by different locks
    // from alpha alignment problems.

    // ^^^^^^^^^^ Protected by Adapter->Lock ^^^^^^^^^^^^^^
    // ============================================================================

    REFERENCE_COUNT     Reference;
    // Not protected by spinlock

    NDIS_SPIN_LOCK      Lock;
    // vvvvvvvvvv Protected by Call->Lock vvvvvvvvvvvvvvvvv

    CALL_STATE          State;
    // State of this call.

    LIST_ENTRY          TxPacketList;
    // Context for each send currently pending

    LIST_ENTRY          RxPacketList;
    // Context for each datagram received but not processed

    ULONG_PTR           RxPacketsPending;
    // Count of RxPackets in RxPacketList

    BOOLEAN             Inbound;
    // TRUE indicates call did not originate here

    BOOLEAN             Open;
    // Open has been called, but not close

    BOOLEAN             Transferring;
    // TRUE means we are on the queue to transmit or receive packets.

    BOOLEAN             UseUdp;
    // Datagrams will be sent via UDP.

    HTAPI_LINE          hTapiLine;
    // Tapi's handle to the line device, for status callbacks

    HTAPI_CALL          hTapiCall;
    // Tapi's handle to the specific call

    ULONG_PTR           DeviceId;
    // The ID of this call, also used as the htCall parameter in TapiEvents

    USHORT              SerialNumber;
    // Unique for this call

    NDIS_HANDLE         NdisLinkContext;
    // Ndis's handle, used in MiniportReceive, etc.

    NDIS_WAN_SET_LINK_INFO WanLinkInfo;

    struct {
        ULONG               SequenceNumber;
        // Last received GRE sequence number

        ULONG               AckNumber;
        // Last received GRE Ack number

        TA_IP_ADDRESS       Address;
        // Remote address for datagrams

        ULONG               TxAccm;
        ULONG               RxAccm;
        // PPP configuration

        USHORT              CallId;
        // Peer ID as used in GRE packet

    } Remote;

    struct {

        USHORT              CallId;
        // My ID as used in GRE packet

        ULONG               SequenceNumber;
        // Next GRE Sequence number to send

        ULONG               AckNumber;
        // Last sent GRE Ack number

    } Packet;
    // Struct for items used in creating/processing packets

    ULONG               MediaModeMask;
    // Indicates what types of Tapi calls we accept,
    // set by OID_TAPI_SET_DEFAULT_MEDIA_DETECTION

    ULONG_PTR           LineStateMask;
    // This is the list of line states tapi is interested in.
    // set by OID_TAPI_SET_STATUS_MESSAGES

    UCHAR               CallerId[MAX_PHONE_NUMBER_LENGTH];
    // This is the remote phone number or IP if we recieved the call,
    // and the IP or phone number we dialed if we placed the call.

    struct {
        NDIS_MINIPORT_TIMER Timer;
        BOOLEAN             Expedited;
        BOOLEAN             Scheduled;
        ULONG               Checklist;

        #define             CALL_CLOSE_CLEANUP_STATE    BIT(0)
        #define             CALL_CLOSE_LINE_DOWN        BIT(1)
        #define             CALL_CLOSE_DROP             BIT(2)
        #define             CALL_CLOSE_DROP_COMPLETE    BIT(3)
        #define             CALL_CLOSE_DISCONNECT       BIT(4)
        #define             CALL_CLOSE_CLOSE_CALL       BIT(5)
        #define             CALL_CLOSE_CLOSE_LINE       BIT(6)
        #define             CALL_CLOSE_RESET            BIT(7)

        #define             CALL_CLOSE_COMPLETE \
                                (CALL_CLOSE_CLEANUP_STATE  |\
                                 CALL_CLOSE_DROP           |\
                                 CALL_CLOSE_DROP_COMPLETE  |\
                                 CALL_CLOSE_DISCONNECT     |\
                                 CALL_CLOSE_CLOSE_CALL     |\
                                 CALL_CLOSE_LINE_DOWN      |\
                                 CALL_CLOSE_CLOSE_LINE     |\
                                 CALL_CLOSE_RESET)

    } Close;

    ULONG               Speed;
    // Connection speed

    struct {
        NDIS_MINIPORT_TIMER Timer;
        BOOLEAN             PacketQueued;
        ULONG_PTR           Padding;
        NDIS_WAN_PACKET     Packet;
        ULONG_PTR           Padding2;
        UCHAR               PacketBuffer[sizeof(GRE_HEADER)+sizeof(ULONG)*2];
        ULONG_PTR           Padding3;
        // When we want to send just an ack, we actually create a packet of
        // 0 bytes out of this buffer and pass it down.  This buffer is touched
        // out of our control, so we pad it to protect us from alpha alignment
        // problems.
    } Ack;

    UCHAR               LineAddress[TAPI_MAX_LINE_ADDRESS_LENGTH];

    LONG                SendCompleteRecursion;

    NDIS_MINIPORT_TIMER DialTimer;

    PPTP_DPC            ReceiveDpc;
    BOOLEAN             Receiving;

    struct {
        BOOLEAN         Cleanup;
        UCHAR           CleanupReason[80];
        CALL_STATE      FinalState;
        NDIS_STATUS     FinalError;
        ULONG           Event;

        #define         CALL_EVENT_TAPI_ANSWER          BIT(0)
        #define         CALL_EVENT_TAPI_CLOSE_CALL      BIT(1)
        #define         CALL_EVENT_TAPI_DROP            BIT(2)
        #define         CALL_EVENT_TAPI_LINE_UP         BIT(3)
        #define         CALL_EVENT_TAPI_LINE_DOWN       BIT(4)
        #define         CALL_EVENT_TAPI_GET_CALL_INFO   BIT(5)
        #define         CALL_EVENT_TAPI_MAKE_CALL       BIT(6)
        #define         CALL_EVENT_PPTP_CLEAR_REQUEST   BIT(7)
        #define         CALL_EVENT_PPTP_DISCONNECT      BIT(8)
        #define         CALL_EVENT_PPTP_OUT_REQUEST     BIT(9)
        #define         CALL_EVENT_PPTP_OUT_REPLY       BIT(10)
        #define         CALL_EVENT_TCP_DISCONNECT       BIT(11)
        #define         CALL_EVENT_TCP_NO_ANSWER        BIT(12)
        #define         CALL_EVENT_TUNNEL_ESTABLISHED   BIT(13)
    } History;

} CALL_SESSION, *PCALL_SESSION;

typedef struct PPTP_ADAPTER {
    NDIS_HANDLE     hMiniportAdapter;
    // NDIS context

    NDIS_SPIN_LOCK  Lock;

    REFERENCE_COUNT Reference;

    PCALL_SESSION  *pCallArray;
    // Array of all call sessions.
    // Size of array is MaxOutboundCalls+MaxInboundCalls

    LIST_ENTRY      ControlTunnelList;
    // List of all active control connections.

    HANDLE          hCtdiListen;
    // This is the one listening handle

    HANDLE          hCtdiDg;
    // Ctdi handle for PPTP datagram sends/recvs

    HANDLE          hCtdiUdp;
    // Ctdi handle for PPTP datagram sends/recvs

    NDIS_WAN_INFO   Info;
    // NdisWan related info
    // Info.Endpoint should equal MaxOutboundCalls+MaxInboundCalls

    struct {
        ULONG           DeviceIdBase;
#if SINGLE_LINE
        ULONG_PTR       LineStateMask;
        // This is the list of line states tapi is interested in.
        // set by OID_TAPI_SET_STATUS_MESSAGES

        BOOLEAN         Open;

        HTAPI_LINE      hTapiLine;
        // Tapi's handle to the line device, for status callbacks

        ULONG           NumActiveCalls;
#endif
    } Tapi;
    // Struct to track Tapi specific info.

    NDIS_MINIPORT_TIMER CleanupTimer;

} PPTP_ADAPTER, *PPPTP_ADAPTER;

typedef struct {
    ULONG               InboundConnectAttempts;
    ULONG               InboundConnectComplete;
    ULONG               OutboundConnectAttempts;
    ULONG               OutboundConnectComplete;
    ULONG               TunnelsMade;
    ULONG               TunnelsAccepted;
    ULONG               CallsMade;
    ULONG               CallsAccepted;
    ULONG               PacketsSent;
    ULONG               PacketsSentError;
    ULONG               PacketsReceived;
    ULONG               PacketsRejected;
    ULONG               PacketsMissed;
    NDIS_SPIN_LOCK      Lock;
} COUNTERS;

typedef struct {
    LIST_ENTRY          ListEntry;
    PVOID               pBuffer;
    PGRE_HEADER         pGreHeader;
    HANDLE              hCtdi;
} DGRAM_CONTEXT, *PDGRAM_CONTEXT;

extern PPPTP_ADAPTER pgAdapter;

extern COUNTERS Counters;

/* Prototypes --------------------------------------------------------------*/

PPPTP_ADAPTER
AdapterAlloc(NDIS_HANDLE NdisAdapterHandle);

VOID
AdapterFree(PPPTP_ADAPTER pAdapter);

PCALL_SESSION
CallAlloc(PPPTP_ADAPTER pAdapter);

VOID
CallAssignSerialNumber(PCALL_SESSION pCall);

VOID
CallCleanup(
    PCALL_SESSION pCall,
    BOOLEAN Locked
    );

VOID
CallDetachFromAdapter(PCALL_SESSION pCall);

PCALL_SESSION
CallFindAndLock(
    IN PPPTP_ADAPTER        pAdapter,
    IN CALL_STATE           State,
    IN ULONG                Flags
    );
#define FIND_INCOMING   BIT(0)
#define FIND_OUTGOING   BIT(1)

VOID
CallFree(PCALL_SESSION pCall);

NDIS_STATUS
CallEventCallClearRequest(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_CLEAR_REQUEST_PACKET *pPacket,
    PCONTROL_TUNNEL pCtl
    );

NDIS_STATUS
CallEventCallDisconnectNotify(
    PCALL_SESSION                       pCall,
    UNALIGNED PPTP_CALL_DISCONNECT_NOTIFY_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallInConnect(
    IN PCALL_SESSION        pCall,
    IN UNALIGNED PPTP_CALL_IN_CONNECT_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallInRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_IN_REQUEST_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallOutReply(
    IN PCALL_SESSION                pCall,
    IN UNALIGNED PPTP_CALL_OUT_REPLY_PACKET *pPacket
    );

NDIS_STATUS
CallEventCallOutRequest(
    IN PPPTP_ADAPTER        pAdapter,
    IN PCONTROL_TUNNEL      pCtl,
    IN UNALIGNED PPTP_CALL_OUT_REQUEST_PACKET *pPacket
    );

NDIS_STATUS
CallEventDisconnect(
    PCALL_SESSION                       pCall
    );

NDIS_STATUS
CallEventConnectFailure(
    PCALL_SESSION                       pCall,
    NDIS_STATUS                         FailureReason
    );

NDIS_STATUS
CallEventOutboundTunnelEstablished(
    IN PCALL_SESSION        pCall,
    IN NDIS_STATUS          EventStatus
    );

PCALL_SESSION FASTCALL
CallGetCall(
    IN PPPTP_ADAPTER pAdapter,
    IN ULONG_PTR ulDeviceId
    );

BOOLEAN FASTCALL
CallIsValidCall(
    IN PPPTP_ADAPTER pAdapter,
    IN ULONG_PTR ulDeviceId
    );

#define DeviceIdToIndex(pAdapter, id) ((id)-(pAdapter)->Tapi.DeviceIdBase)

#define CallGetLineCallState(State)  (((ULONG)(State)<NUM_CALL_STATES) ? CallStateToLineCallStateMap[State] : LINECALLSTATE_UNKNOWN)

extern ULONG CallStateToLineCallStateMap[];

#define CALL_ID_INDEX_BITS          14
#define CallIdToDeviceId(CallId)  ((CallId)&((1<<CALL_ID_INDEX_BITS)-1))
#define GreCallIdToId(id) ((ULONG)(id)&((1<<CALL_ID_INDEX_BITS)-1))

NDIS_STATUS
CallReceiveDatagramCallback(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

NDIS_STATUS
CallReceiveUdpCallback(
    IN      PVOID                       pContext,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    );

NDIS_STATUS
CallQueueReceivePacket(
    PCALL_SESSION       pCall,
    PDGRAM_CONTEXT      pDgContext
    );

NDIS_STATUS
CallQueueTransmitPacket(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pWanPacket
    );
// CallQueueTransmitPacket is OS-specific and not found in COMMON directory

BOOLEAN
CallConnectToCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl,
    IN BOOLEAN CallLocked
    );

VOID
CallDisconnectFromCtl(
    IN PCALL_SESSION pCall,
    IN PCONTROL_TUNNEL pCtl
    );

NDIS_STATUS
CallSetLinkInfo(
    PPPTP_ADAPTER pAdapter,
    IN PNDIS_WAN_SET_LINK_INFO pRequest
    );

VOID
CallSetState(
    IN PCALL_SESSION pCall,
    IN CALL_STATE State,
    IN ULONG_PTR StateParam,
    IN BOOLEAN Locked
    );

BOOLEAN
CallProcessPackets(
    PCALL_SESSION   pCall,
    ULONG           TransferMax
    );

PCONTROL_TUNNEL
CtlAlloc(
    PPPTP_ADAPTER pAdapter
    );

PVOID
CtlAllocPacket(
    PCONTROL_TUNNEL pCtl,
    PPTP_MESSAGE_TYPE Message
    );

VOID
CtlFree(PCONTROL_TUNNEL pCtl);

VOID
CtlFreePacket(
    PCONTROL_TUNNEL pCtl,
    PVOID pPacket
    );

NDIS_STATUS
CtlListen(
    IN PPPTP_ADAPTER pAdapter
    );

VOID
CtlCleanup(
    PCONTROL_TUNNEL pCtl,
    BOOLEAN Locked
    );

NDIS_STATUS
CtlConnectCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PCALL_SESSION pCall,
    IN PTA_IP_ADDRESS pTargetAddress
    );

NDIS_STATUS
CtlDisconnectCall(
    IN PCALL_SESSION pCall
    );

NDIS_STATUS
CtlSend(
    IN PCONTROL_TUNNEL pCtl,
    IN PVOID pPacketBuffer
    );

VOID 
CtlpCleanupCtls(
    PPPTP_ADAPTER pAdapter
    );


VOID
DeinitThreading();

VOID
FreeWorkItem(
    PPPTP_WORK_ITEM pItem
    );

VOID
InitCallLayer();

NDIS_STATUS
InitThreading(
    IN NDIS_HANDLE hMiniportAdapter
    );

VOID
IpAddressToString(
    IN ULONG ulIpAddress,
    OUT CHAR* pszIpAddress );

VOID
MiniportHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
MiniportInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT        SelectedMediumIndex,
    IN  PNDIS_MEDIUM MediumArray,
    IN  UINT         MediumArraySize,
    IN  NDIS_HANDLE  NdisAdapterHandle,
    IN  NDIS_HANDLE  WrapperConfigurationContext
    );

NDIS_STATUS
MiniportQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    );

NDIS_STATUS
MiniportReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    );

NDIS_STATUS
MiniportSetInformation(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_OID Oid,
   IN PVOID InformationBuffer,
   IN ULONG InformationBufferLength,
   OUT PULONG BytesRead,
   OUT PULONG BytesNeeded
   );

NDIS_STATUS
MiniportWanSend(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_HANDLE NdisLinkHandle,
   IN PNDIS_WAN_PACKET WanPacket
   );


VOID
OsGetTapiLineAddress(ULONG Index, PUCHAR s, ULONG Length);

VOID
OsReadConfig(
    NDIS_HANDLE hConfig
    );

NDIS_STATUS
OsSpecificTapiGetDevCaps(
    ULONG_PTR ulDeviceId,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    );

extern BOOLEAN PptpInitialized;

NDIS_STATUS
PptpInitialize(
    PPPTP_ADAPTER pAdapter
    );

NDIS_STATUS
ScheduleWorkItem(
    WORK_PROC         Callback,
    PVOID             Context,
    PVOID             InfoBuf,
    ULONG             InfoBufLen
    );

PUCHAR
StringToIpAddress(
    IN PUCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    );

PWCHAR
StringToIpAddressW(
    IN PWCHAR pszIpAddress,
    IN OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pValidAddress
    );

NDIS_STATUS
TapiAnswer(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    );

NDIS_STATUS
TapiClose(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE pRequest
    );

NDIS_STATUS
TapiCloseCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL pRequest
    );

NDIS_STATUS
TapiDrop(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_DROP pRequest
    );

NDIS_STATUS
TapiGetAddressCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    );

NDIS_STATUS
TapiGetAddressStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_STATUS pExtIdQuery
    );

NDIS_STATUS
TapiGetCallInfo(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_INFO pRequest,
    IN OUT PULONG pRequiredLength
    );

NDIS_STATUS
TapiGetCallStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_STATUS pRequest
    );

NDIS_STATUS
TapiGetDevCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    );

NDIS_STATUS
TapiGetExtensionId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_EXTENSION_ID pExtIdQuery
    );

NDIS_STATUS
TapiGetId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ID pRequest
    );

#define TapiLineHandleToId(h)  ((h)&0x7fffffff)
#define TapiIdToLineHandle(id) ((id)|0x80000000)
#define LinkHandleToId(h)  ((ULONG_PTR)(((ULONG_PTR)(h))&0x7fffffff))
#define DeviceIdToLinkHandle(id) ((id)|0x80000000)

VOID
TapiLineDown(
    PCALL_SESSION pCall
    );

VOID
TapiLineUp(
    PCALL_SESSION pCall
    );

NDIS_STATUS
TapiMakeCall(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_MAKE_CALL pRequest
    );

NDIS_STATUS
TapiNegotiateExtVersion(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_NEGOTIATE_EXT_VERSION pExtVersion
    );

NDIS_STATUS
TapiOpen(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_OPEN pRequest
    );

NDIS_STATUS
TapiProviderInitialize(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_INITIALIZE pInitData
    );

NDIS_STATUS
TapiProviderShutdown(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest
    );

NDIS_STATUS
TapiSetDefaultMediaDetection(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    );

NDIS_STATUS
TapiSetStatusMessages(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    );

// Enum

#define ENUM_SIGNATURE TAG('ENUM')

typedef struct {
    LIST_ENTRY  ListEntry;
    ULONG       Signature;
} ENUM_CONTEXT, *PENUM_CONTEXT;

#define InitEnumContext(e)                                  \
    {                                                           \
        (e)->ListEntry.Flink = (e)->ListEntry.Blink = NULL;     \
        (e)->Signature = ENUM_SIGNATURE;                        \
    }

PLIST_ENTRY FASTCALL
EnumListEntry(
    IN PLIST_ENTRY pHead,
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    );

VOID
EnumComplete(
    IN PENUM_CONTEXT pEnum,
    IN PNDIS_SPIN_LOCK pLock
    );

int
axtol(
    LPSTR psz,
    ULONG *pResult
);

#endif // RASPPTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\miniport.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   MINIPORT.C - NDIS support for PPTP
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/28/1998
*
*****************************************************************************/

#include "raspptp.h"

PPPTP_ADAPTER pgAdapter = NULL;

NDIS_OID SupportedOids[] = {
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_LINK_SPEED,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_OK,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_ID,
    OID_GEN_XMIT_ERROR,
    OID_GEN_XMIT_OK,

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ENABLE_WAKE_UP,

    OID_TAPI_CLOSE,
    OID_TAPI_DROP,
    OID_TAPI_GET_ADDRESS_CAPS,
    OID_TAPI_GET_CALL_INFO,
    OID_TAPI_GET_CALL_STATUS,
    OID_TAPI_GET_DEV_CAPS,
    OID_TAPI_GET_EXTENSION_ID,
    OID_TAPI_MAKE_CALL,
    OID_TAPI_NEGOTIATE_EXT_VERSION,
    OID_TAPI_OPEN,
    OID_TAPI_PROVIDER_INITIALIZE,

    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_GET_BRIDGE_INFO,
    OID_WAN_GET_COMP_INFO,
    OID_WAN_GET_INFO,
    OID_WAN_GET_LINK_INFO,
    OID_WAN_GET_STATS_INFO,
    OID_WAN_HEADER_FORMAT,
    OID_WAN_LINE_COUNT,
    OID_WAN_MEDIUM_SUBTYPE,
    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_PROTOCOL_TYPE,
    OID_WAN_QUALITY_OF_SERVICE,
    OID_WAN_SET_BRIDGE_INFO,
    OID_WAN_SET_COMP_INFO,
    OID_WAN_SET_LINK_INFO
};

#if DBG
PUCHAR
GetOidString(
    NDIS_OID Oid
    )
{
    PUCHAR OidName = NULL;
    #define OID_CASE(oid) case (oid): OidName = #oid; break
    switch (Oid)
    {
        OID_CASE(OID_GEN_CURRENT_LOOKAHEAD);
        OID_CASE(OID_GEN_DRIVER_VERSION);
        OID_CASE(OID_GEN_HARDWARE_STATUS);
        OID_CASE(OID_GEN_LINK_SPEED);
        OID_CASE(OID_GEN_MAC_OPTIONS);
        OID_CASE(OID_GEN_MAXIMUM_LOOKAHEAD);
        OID_CASE(OID_GEN_MAXIMUM_FRAME_SIZE);
        OID_CASE(OID_GEN_MAXIMUM_TOTAL_SIZE);
        OID_CASE(OID_GEN_MEDIA_CONNECT_STATUS);
        OID_CASE(OID_GEN_MEDIA_SUPPORTED);
        OID_CASE(OID_GEN_MEDIA_IN_USE);
        OID_CASE(OID_GEN_RECEIVE_BLOCK_SIZE);
        OID_CASE(OID_GEN_RECEIVE_BUFFER_SPACE);
        OID_CASE(OID_GEN_SUPPORTED_GUIDS);
        OID_CASE(OID_GEN_SUPPORTED_LIST);
        OID_CASE(OID_GEN_TRANSMIT_BLOCK_SIZE);
        OID_CASE(OID_GEN_TRANSMIT_BUFFER_SPACE);
        OID_CASE(OID_GEN_VENDOR_DESCRIPTION);
        OID_CASE(OID_GEN_VENDOR_ID);
        OID_CASE(OID_PNP_CAPABILITIES);
        OID_CASE(OID_PNP_SET_POWER);
        OID_CASE(OID_PNP_QUERY_POWER);
        OID_CASE(OID_PNP_ENABLE_WAKE_UP);
        OID_CASE(OID_TAPI_ACCEPT);
        OID_CASE(OID_TAPI_ANSWER);
        OID_CASE(OID_TAPI_CLOSE);
        OID_CASE(OID_TAPI_CLOSE_CALL);
        OID_CASE(OID_TAPI_CONDITIONAL_MEDIA_DETECTION);
        OID_CASE(OID_TAPI_CONFIG_DIALOG);
        OID_CASE(OID_TAPI_DEV_SPECIFIC);
        OID_CASE(OID_TAPI_DIAL);
        OID_CASE(OID_TAPI_DROP);
        OID_CASE(OID_TAPI_GET_ADDRESS_CAPS);
        OID_CASE(OID_TAPI_GET_ADDRESS_ID);
        OID_CASE(OID_TAPI_GET_ADDRESS_STATUS);
        OID_CASE(OID_TAPI_GET_CALL_ADDRESS_ID);
        OID_CASE(OID_TAPI_GET_CALL_INFO);
        OID_CASE(OID_TAPI_GET_CALL_STATUS);
        OID_CASE(OID_TAPI_GET_DEV_CAPS);
        OID_CASE(OID_TAPI_GET_DEV_CONFIG);
        OID_CASE(OID_TAPI_GET_EXTENSION_ID);
        OID_CASE(OID_TAPI_GET_ID);
        OID_CASE(OID_TAPI_GET_LINE_DEV_STATUS);
        OID_CASE(OID_TAPI_MAKE_CALL);
        OID_CASE(OID_TAPI_NEGOTIATE_EXT_VERSION);
        OID_CASE(OID_TAPI_OPEN);
        OID_CASE(OID_TAPI_PROVIDER_INITIALIZE);
        OID_CASE(OID_TAPI_PROVIDER_SHUTDOWN);
        OID_CASE(OID_TAPI_SECURE_CALL);
        OID_CASE(OID_TAPI_SELECT_EXT_VERSION);
        OID_CASE(OID_TAPI_SEND_USER_USER_INFO);
        OID_CASE(OID_TAPI_SET_APP_SPECIFIC);
        OID_CASE(OID_TAPI_SET_CALL_PARAMS);
        OID_CASE(OID_TAPI_SET_DEFAULT_MEDIA_DETECTION);
        OID_CASE(OID_TAPI_SET_DEV_CONFIG);
        OID_CASE(OID_TAPI_SET_MEDIA_MODE);
        OID_CASE(OID_TAPI_SET_STATUS_MESSAGES);
        OID_CASE(OID_WAN_CURRENT_ADDRESS);
        OID_CASE(OID_WAN_GET_BRIDGE_INFO);
        OID_CASE(OID_WAN_GET_COMP_INFO);
        OID_CASE(OID_WAN_GET_INFO);
        OID_CASE(OID_WAN_GET_LINK_INFO);
        OID_CASE(OID_WAN_GET_STATS_INFO);
        OID_CASE(OID_WAN_HEADER_FORMAT);
        OID_CASE(OID_WAN_LINE_COUNT);
        OID_CASE(OID_WAN_MEDIUM_SUBTYPE);
        OID_CASE(OID_WAN_PERMANENT_ADDRESS);
        OID_CASE(OID_WAN_PROTOCOL_TYPE);
        OID_CASE(OID_WAN_QUALITY_OF_SERVICE);
        OID_CASE(OID_WAN_SET_BRIDGE_INFO);
        OID_CASE(OID_WAN_SET_COMP_INFO);
        OID_CASE(OID_WAN_SET_LINK_INFO);
        default:
            OidName = "Unknown OID";
            break;
    }
    return OidName;
}
#endif

STATIC NDIS_STATUS
MpReadConfig(
    NDIS_HANDLE WrapperConfigurationContext
    )
{
    NDIS_STATUS Status, ReturnStatus = NDIS_STATUS_SUCCESS;
    PNDIS_CONFIGURATION_PARAMETER Value;
    NDIS_HANDLE hConfig;

    NdisOpenConfiguration(&ReturnStatus, &hConfig, WrapperConfigurationContext);

    if (ReturnStatus==NDIS_STATUS_SUCCESS)
    {
        OsReadConfig(hConfig);
        NdisCloseConfiguration(hConfig);
    }
    return ReturnStatus;
}



NDIS_STATUS
MiniportInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT        SelectedMediumIndex,
    IN  PNDIS_MEDIUM MediumArray,
    IN  UINT         MediumArraySize,
    IN  NDIS_HANDLE  NdisAdapterHandle,
    IN  NDIS_HANDLE  WrapperConfigurationContext
    )
{
    ULONG i;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PPPTP_ADAPTER pAdapter = NULL;

    DbgMsgInit();
    InitMemory();
    MpReadConfig(WrapperConfigurationContext);
    Status = InitThreading( NdisAdapterHandle );
    InitCallLayer();
    DEBUGMSG(DBG_FUNC, (DTEXT("+MiniportInitialize\n")));

    // Find our medium

    for (i=0; i<MediumArraySize; i++)
    {
        if (MediumArray[i]==NdisMediumWan)
        {
            break;
        }
    }

    // Did we find a medium?
    if (i<MediumArraySize)
    {
        *SelectedMediumIndex = i;
    }
    else
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PPTP-ERROR: Medium not found\n")));

        Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
        goto miDone;
    }

    ASSERT(!pgAdapter);
    pgAdapter = pAdapter = AdapterAlloc(NdisAdapterHandle);

    if (pAdapter==NULL)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto miDone;
    }

    NdisMSetAttributesEx(NdisAdapterHandle,
                         (NDIS_HANDLE)pAdapter,
                         0,
                         NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
                         NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                         NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND |
                         NDIS_ATTRIBUTE_DESERIALIZE,
                         NdisInterfaceInternal
                         );

    NdisZeroMemory(&Counters, sizeof(Counters));
    NdisAllocateSpinLock(&Counters.Lock);
    OsFileLogInit();
miDone:

    if (Status!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("-MiniportInitialize returning failure %x\n"), Status));

        if (pAdapter)
        {
            AdapterFree(pAdapter);
            pgAdapter = NULL;
        }
        DeinitThreading();
        DeinitMemory();
        DbgMsgUninit();
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-MiniportInitialize\n")));
    return Status;
}

VOID
MiniportHalt(
    IN NDIS_HANDLE MiniportAdapterContext
    )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    ULONG i;
    DEBUGMSG(DBG_FUNC, (DTEXT("+MiniportHalt\n")));

    // There are several ways the driver can be brought down.  Check for
    // lingering calls.
    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
        PCALL_SESSION pCall = pAdapter->pCallArray[i];

        if (IS_CALL(pCall))
        {
            NdisAcquireSpinLock(&pCall->Lock);
            if (IS_CALL(pCall) && pCall->State>STATE_CALL_IDLE && pCall->State<STATE_CALL_CLEANUP)
            {
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, LOCKED);
                CallDetachFromAdapter(pCall);
                CallCleanup(pCall, LOCKED);
            }
            NdisReleaseSpinLock(&pCall->Lock);

        }
    }

    PptpAuthenticateIncomingCalls = FALSE;
    if (ClientList)
    {
        MyMemFree(ClientList, sizeof(CLIENT_ADDRESS)*NumClientAddresses);
        ClientList = NULL;
    }
    NumClientAddresses = 0;

    if (pAdapter->hCtdiDg)
    {
        CtdiClose(pAdapter->hCtdiDg);
        pAdapter->hCtdiDg = NULL;
    }

    if (pAdapter->hCtdiUdp)
    {
        CtdiClose(pAdapter->hCtdiUdp);
        pAdapter->hCtdiUdp = NULL;
    }

    if (pAdapter->hCtdiListen)
    {
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
    }

    for (i=0; i<10; i++)
    {
        if (IsListEmpty(&pAdapter->ControlTunnelList))
        {
            break;
        }
        // Give the Ctl and Tdi layers a chance to clean up.
        NdisMSleep(50*1000);
    }

    OsFileLogShutdown();
    CtdiShutdown();
    AdapterFree(pAdapter);
    pgAdapter = NULL;

    NdisFreeSpinLock(&Counters.Lock);

    DeinitThreading();
    DeinitMemory();
    DbgMsgUninit();
    DEBUGMSG(DBG_FUNC, (DTEXT("-MiniportHalt\n")));
}

NDIS_STATUS
MiniportReset(
    OUT PBOOLEAN    AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext
    )
{
    ASSERTMSG(0,(DTEXT("MiniportReset not implemented")));
    return (NDIS_STATUS_FAILURE);
}

#ifndef WIN95_BUILD // ToDo: Win98PNP
NDIS_PNP_CAPABILITIES PnpCaps =
{
    0, // Flags
    {
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified
    }
};
#endif

// CHECK_TAPI_SIZE forces the internal tapi size values to conform to the size
// passed in the MiniportQueryInformation call
#define CHECK_TAPI_SIZE(ptr, size, type1, struct2) \
        (((size)>=sizeof(type1)) &&                \
        ((((type1 *)(ptr))->struct2.ulTotalSize)=(size)-FIELD_OFFSET(type1, struct2)))

#define TAPI_USED_SIZE(ptr, type1, struct2) \
        (((type1 *)(ptr))->struct2.ulUsedSize+FIELD_OFFSET(type1, struct2))

#define TAPI_NEEDED_SIZE(ptr, type1, struct2) \
        (((type1 *)(ptr))->struct2.ulNeededSize+FIELD_OFFSET(type1, struct2))

// Repeated code, make a macro
#define HANDLE_TAPI_OID(type1, struct2, TapiFunc)                       \
        {                                                               \
            DoCopy = FALSE;                                             \
            if (CHECK_TAPI_SIZE(InformationBuffer,                      \
                                InformationBufferLength,                \
                                type1,                                  \
                                struct2))                               \
            {                                                           \
                Status = TapiFunc(pAdapter, InformationBuffer);         \
                UsedLength = TAPI_USED_SIZE(InformationBuffer,          \
                                            type1,                      \
                                            struct2);                   \
                NeededLength = TAPI_NEEDED_SIZE(InformationBuffer,      \
                                                type1,                  \
                                                struct2);               \
                if (NeededLength>UsedLength)                            \
                {                                                       \
                    PartialReturn = TRUE;                               \
                }                                                       \
            }                                                           \
            else                                                        \
            {                                                           \
                UsedLength = sizeof(type1);                             \
            }                                                           \
        }

NDIS_STATUS
MiniportQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded
    )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG_PTR GenericUlong = 0;
    PVOID SourceBuffer = (PVOID) &GenericUlong;
    ULONG UsedLength = sizeof(ULONG);
    ULONG NeededLength = 0;        // Used when returning part of all required info
    BOOLEAN DoCopy = TRUE;
    BOOLEAN PartialReturn = FALSE;

    UCHAR PptpWanAddress[6] = {'P','P','T','P','0','0'};  // This is the address returned by OID_WAN_*_ADDRESS.

    DEBUGMSG(DBG_FUNC|DBG_NDIS, (DTEXT("+MiniportQueryInformation Oid==0x%08X %hs\n"),
                                 Oid, GetOidString(Oid)));

    switch (Oid)
    {
        case OID_GEN_MAC_OPTIONS:
        {
            // Believe these to be pretty much ignored.
            GenericUlong = NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                           NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
            break;
        }
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            GenericUlong = PPTP_MAX_LOOKAHEAD;
            break;
        }
        case OID_GEN_SUPPORTED_LIST:
        {
            SourceBuffer = (PVOID) SupportedOids;
            UsedLength = sizeof(SupportedOids);
            break;
        }

        case OID_GEN_RCV_ERROR:
        {
            GenericUlong = Counters.PacketsRejected + Counters.PacketsMissed;
            break;
        }

        case OID_GEN_RCV_OK:
        {
            GenericUlong = Counters.PacketsReceived;
            break;
        }

        case OID_GEN_XMIT_ERROR:
        {
            GenericUlong = Counters.PacketsSentError;
            break;
        }

        case OID_GEN_XMIT_OK:
        {
            GenericUlong = Counters.PacketsSent - Counters.PacketsSentError;
            break;
        }

        case OID_TAPI_GET_ADDRESS_CAPS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_ADDRESS_CAPS,
                            LineAddressCaps,
                            TapiGetAddressCaps);
            break;
        }

        case OID_TAPI_GET_CALL_INFO:
        {
            // If the buffer isn't large enough at all, the size of all the
            // data including strings is returned. If the buffer is big enough
            // for the data structure but not the strings, then only the data
            // structure is returned.

            // Get the length needed, including strings
            NeededLength = 0;
            Status = TapiGetCallInfo(pAdapter, InformationBuffer, &NeededLength);
            UsedLength = NeededLength;
            if( Status == NDIS_STATUS_SUCCESS )
            {
                if (sizeof(NDIS_TAPI_GET_CALL_INFO)<=InformationBufferLength)
                {
                    if( NeededLength > InformationBufferLength )
                    {
                        UsedLength = sizeof(NDIS_TAPI_GET_CALL_INFO);
                        PartialReturn = TRUE;
                    }else{
                        // Used=Needed = the entire thing inluding strings
                    }

                    Status = TapiGetCallInfo(pAdapter,
                                             InformationBuffer,
                                             NULL);
                    // NULL in the second call makes it fill in the structure,
                    // which it doesn't do on the first call.
                }
            }
            DoCopy = FALSE;
            break;
        }

        case OID_TAPI_GET_CALL_STATUS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_CALL_STATUS,
                            LineCallStatus,
                            TapiGetCallStatus);
            break;
        }

        case OID_TAPI_GET_DEV_CAPS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_DEV_CAPS,
                            LineDevCaps,
                            TapiGetDevCaps);
            if (NeededLength < TAPI_DEV_CAPS_SIZE)
            {
                NeededLength = TAPI_DEV_CAPS_SIZE;
            }
            break;
        }

        case OID_TAPI_GET_ID:
        {

            if(CHECK_TAPI_SIZE(InformationBuffer,
                    InformationBufferLength,
                    NDIS_TAPI_GET_ID,
                    DeviceID))
            {
                if(InformationBufferLength <
                ((NDIS_TAPI_GET_ID *) InformationBuffer)->ulDeviceClassOffset
                + ((NDIS_TAPI_GET_ID *) InformationBuffer)->ulDeviceClassSize)
                {
                    UsedLength = sizeof(NDIS_TAPI_GET_ID);
                    break;
                }
                
                HANDLE_TAPI_OID(NDIS_TAPI_GET_ID,
                                DeviceID,
                                TapiGetId);
            }
            
            break;
        }

        case OID_TAPI_GET_ADDRESS_STATUS:
        {
            HANDLE_TAPI_OID(NDIS_TAPI_GET_ADDRESS_STATUS,
                            LineAddressStatus,
                            TapiGetAddressStatus);
            break;
        }

        case OID_TAPI_GET_EXTENSION_ID:
        {
            UsedLength = sizeof(NDIS_TAPI_GET_EXTENSION_ID);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiGetExtensionId(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_MAKE_CALL:
        {
            PNDIS_TAPI_MAKE_CALL pRequest = (PNDIS_TAPI_MAKE_CALL)InformationBuffer;
            UsedLength = sizeof(NDIS_TAPI_MAKE_CALL);

            if (UsedLength<=InformationBufferLength)
            {
                if (pRequest->ulDestAddressSize)
                {
                    if (pRequest->ulDestAddressOffset<sizeof(NDIS_TAPI_MAKE_CALL))
                    {
                        // Bogus offset
                        DBG_D(DBG_ERROR, pRequest->ulDestAddressOffset);
                        Status = NDIS_STATUS_FAILURE;
                    }
                    UsedLength = pRequest->ulDestAddressSize + pRequest->ulDestAddressOffset;
                }
                if (Status == NDIS_STATUS_SUCCESS && UsedLength<=InformationBufferLength)
                {
                    DoCopy = FALSE;
                    Status = TapiMakeCall(pAdapter, InformationBuffer);
                }

            }
            break;
        }

        case OID_TAPI_NEGOTIATE_EXT_VERSION:
        {
            UsedLength = sizeof(NDIS_TAPI_NEGOTIATE_EXT_VERSION);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiNegotiateExtVersion(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_OPEN:
        {
            UsedLength = sizeof(NDIS_TAPI_OPEN);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiOpen(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_PROVIDER_INITIALIZE:
        {
            UsedLength = sizeof(NDIS_TAPI_PROVIDER_INITIALIZE);
            if (UsedLength<=InformationBufferLength)
            {
                DoCopy = FALSE;
                Status = TapiProviderInitialize(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_WAN_GET_INFO:
        {
            SourceBuffer = &pAdapter->Info;
            UsedLength = sizeof(pAdapter->Info);
            break;
        }
        case OID_WAN_MEDIUM_SUBTYPE:
        {
            GenericUlong = OS_SPECIFIC_NDIS_WAN_MEDIUM_TYPE;
            break;
        }
        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_PERMANENT_ADDRESS:
        {
            SourceBuffer = PptpWanAddress;
            UsedLength = sizeof(PptpWanAddress);
            break;
        }

#ifndef WIN95_BUILD // ToDo: Win98PNP
        case OID_PNP_CAPABILITIES:
        {
            SourceBuffer = &PnpCaps;
            UsedLength = sizeof(PnpCaps);
            break;
        }
#endif
        case OID_PNP_SET_POWER:
            // Just success
            break;

        case OID_PNP_QUERY_POWER:
            // Just success
            break;

        case OID_PNP_ENABLE_WAKE_UP:
            // Just success
            break;


        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_ID:

        case OID_WAN_GET_BRIDGE_INFO:
        case OID_WAN_GET_LINK_INFO:
        case OID_WAN_GET_STATS_INFO:
        case OID_WAN_HEADER_FORMAT:
        case OID_WAN_LINE_COUNT:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_SET_BRIDGE_INFO:
        case OID_WAN_SET_COMP_INFO:
        case OID_WAN_SET_LINK_INFO:
            DEBUGMSG(DBG_ERROR, (DTEXT("OID Not Implemented %hs\n"), GetOidString(Oid)));
        case OID_WAN_GET_COMP_INFO:  // never supported
        default:
        {
            UsedLength = NeededLength = 0;
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
    }

    if (!PartialReturn)
    {
        NeededLength = UsedLength;
    }

    if (Status == NDIS_STATUS_SUCCESS)
    {
        if (InformationBufferLength < UsedLength)
        {
            Status = NDIS_STATUS_INVALID_LENGTH;
            *BytesNeeded = UsedLength;
        }
        else
        {
            *BytesNeeded = NeededLength;
            *BytesWritten = UsedLength;
            if (DoCopy)
            {
                NdisMoveMemory(InformationBuffer, SourceBuffer, UsedLength);
            }
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-MiniportQueryInformation %08X\n"), Status));
    return Status;
}

NDIS_STATUS
MiniportSetInformation(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_OID Oid,
   IN PVOID InformationBuffer,
   IN ULONG InformationBufferLength,
   OUT PULONG BytesRead,
   OUT PULONG BytesNeeded
   )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG_PTR GenericUlong = 0;
    ULONG UsedLength = sizeof(ULONG);

    DEBUGMSG(DBG_FUNC|DBG_NDIS, (DTEXT("+MiniportSetInformation Oid==0x%08X %hs\n"),
                                 Oid, GetOidString(Oid)));

    switch (Oid)
    {
        case OID_TAPI_ANSWER:
        {
            UsedLength = sizeof(NDIS_TAPI_ANSWER);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiAnswer(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_CLOSE:
        {
            UsedLength = sizeof(NDIS_TAPI_CLOSE);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiClose(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_CLOSE_CALL:
        {
            UsedLength = sizeof(NDIS_TAPI_CLOSE_CALL);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiCloseCall(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_DROP:
        {
            UsedLength = sizeof(NDIS_TAPI_DROP);
            if (UsedLength<=InformationBufferLength)
            {
                // We don't use the UserUserInfo
                Status = TapiDrop(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_PROVIDER_SHUTDOWN:
        {
            UsedLength = sizeof(NDIS_TAPI_PROVIDER_SHUTDOWN);
            if (UsedLength<=InformationBufferLength)
            {
                // We don't use the UserUserInfo
                Status = TapiProviderShutdown(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_SET_DEFAULT_MEDIA_DETECTION:
        {
            UsedLength = sizeof(NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiSetDefaultMediaDetection(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_TAPI_SET_STATUS_MESSAGES:
        {
            UsedLength = sizeof(NDIS_TAPI_SET_STATUS_MESSAGES);
            if (UsedLength<=InformationBufferLength)
            {
                Status = TapiSetStatusMessages(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_WAN_SET_LINK_INFO:
        {
            UsedLength = sizeof(NDIS_WAN_SET_LINK_INFO);
            if (UsedLength<=InformationBufferLength)
            {
                Status = CallSetLinkInfo(pAdapter, InformationBuffer);
            }
            break;
        }

        case OID_PNP_SET_POWER:
        case OID_PNP_ENABLE_WAKE_UP:
            UsedLength = 0;
            // Success
            break;

        default:
            DEBUGMSG(DBG_ERROR, (DTEXT("SetInformation OID Not Implemented %hs\n"), GetOidString(Oid)));
            // No break
        case OID_TAPI_ACCEPT:
            Status = NDIS_STATUS_INVALID_OID;
            break;
    }

    *BytesNeeded = UsedLength;
    if (Status==NDIS_STATUS_SUCCESS)
    {
        if (UsedLength>InformationBufferLength)
        {
            *BytesRead = 0;
            Status = NDIS_STATUS_INVALID_LENGTH;
        }
        else
        {
            *BytesRead = UsedLength;
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-MiniportSetInformation %08X\n"), Status));
    return Status;
}

NDIS_STATUS
MiniportWanSend(
   IN NDIS_HANDLE MiniportAdapterContext,
   IN NDIS_HANDLE NdisLinkHandle,
   IN PNDIS_WAN_PACKET WanPacket
   )
{
    PPPTP_ADAPTER pAdapter = (PPPTP_ADAPTER)MiniportAdapterContext;
    PCALL_SESSION pCall;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+MiniportWanSend NdisLinkHandle=%x, WanPacket=%x\n"),
                NdisLinkHandle, WanPacket));

    pCall = CallGetCall(pAdapter, LinkHandleToId(NdisLinkHandle));
    if (!IS_CALL(pCall) || pCall->State!=STATE_CALL_ESTABLISHED)
    {
        // Just say success, don't send.
        goto mwsDone;
    }

    DEBUGMSG(DBG_TX, (DTEXT("TxPacket: %08x  Call: %08x\n"), WanPacket, pCall));

    Status = CallQueueTransmitPacket(pCall, WanPacket);

    if (Status==NDIS_STATUS_PENDING)
    {
        REFERENCE_OBJECT(pCall);
    }

mwsDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-MiniportWanSend %08x\n"), Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\protocol.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   PROTOCOL.H - PPTP and GRE Protocol data types and constants
*
*   Author:     Stan Adermann (stana)
*
*   Created:    7/23/1998
*
*****************************************************************************/

#ifndef PROTOCOL_H
#define PROTOCOL_H

/* IP ----------------------------------------------------------------------*/

typedef struct {
    UCHAR           HeaderLength                : 4;
    UCHAR           Version                     : 4;
    UCHAR           TypeOfService;
    USHORT          TotalLength;
    USHORT          Identification;
    USHORT          FlagsAndFragmentOffset;
    UCHAR           TimeToLive;
    UCHAR           Protocol;
    USHORT          Checksum;
    ULONG           SourceIp;
    ULONG           DestinationIp;
} IP4_HEADER, *PIP4_HEADER;

typedef struct {
    USHORT          SourcePort;
    USHORT          DestinationPort;
    USHORT          Length;
    USHORT          Checksum;
} UDP_HEADER, *PUDP_HEADER;

/* GRE ---------------------------------------------------------------------*/

typedef struct {
    UCHAR           RecursionControl            : 3;
    UCHAR           StrictSourceRoutePresent    : 1;
    UCHAR           SequenceNumberPresent       : 1;
    UCHAR           KeyPresent                  : 1;
    UCHAR           RoutingPresent              : 1;
    UCHAR           ChecksumPresent             : 1;
    UCHAR           Version                     : 3;
    UCHAR           Flags                       : 4;
    UCHAR           AckSequenceNumberPresent    : 1;

    USHORT          ProtocolType;

#define     GRE_PROTOCOL_TYPE           0x880B
#define     GRE_PROTOCOL_TYPE_NS        0x0B88

    USHORT          KeyLength;
    USHORT          KeyCallId;
} GRE_HEADER, *PGRE_HEADER;

#define GreSequence(g) (*(PULONG)(((PUCHAR)(g)) + sizeof(GRE_HEADER)))
#define GreAckSequence(g)                                                       \
    ((g)->SequenceNumberPresent ?                                               \
        (*(PULONG)(((PUCHAR)(g)) + sizeof(GRE_HEADER) + sizeof(ULONG))) :       \
        GreSequence(g))

/* PPTP --------------------------------------------------------------------*/

#define PPTP_TCP_PORT                           1723
#define PPTP_IP_GRE_PROTOCOL                    47
#define PPTP_PROTOCOL_VERSION_1_00              0x100
#define PPTP_PROTOCOL_SECURE_VERSION            0x200
#define PPTP_MAGIC_COOKIE                       0x1A2B3C4D

#define INADDR_NONE                             0xffffffff

#define MAX_HOSTNAME_LENGTH                     64
#define MAX_VENDOR_LENGTH                       64
#define MAX_PHONE_NUMBER_LENGTH                 64
#define MAX_SUBADDRESS_LENGTH                   64
#define MAX_CALL_STATS_LENGTH                   128

#define PPTP_MAX_PACKET_SIZE                    1532
#define PPTP_MAX_LOOKAHEAD                      PPTP_MAX_PACKET_SIZE
#define PPTP_MAX_TRANSMIT                       32
#define PPTP_MAX_RECEIVE_SIZE                   (1614+20+12+8) // To allow for PPP padding, etc.

#define PPTP_RECV_WINDOW                        64

#define PPTP_STATUS_SUCCESS                     0
#define PPTP_STATUS_NOT_CONNECTED               1
#define PPTP_STATUS_BAD_FORMAT                  2
#define PPTP_STATUS_BAD_VALUE                   3
#define PPTP_STATUS_INSUFFICIENT_RESOURCES      4
#define PPTP_STATUS_BAD_CALL_ID                 5
#define PPTP_STATUS_PAC_ERROR                   6


typedef enum {
    PPTP_CONTROL_MESSAGE = 1
} PPTP_PACKET_TYPE;

typedef enum {
    CONTROL_START_REQUEST = 1,
    CONTROL_START_REPLY,
    CONTROL_STOP_REQUEST,
    CONTROL_STOP_REPLY,
    CONTROL_ECHO_REQUEST,
    CONTROL_ECHO_REPLY,

    CALL_OUT_REQUEST,
    CALL_OUT_REPLY,
    CALL_IN_REQUEST,
    CALL_IN_REPLY,
    CALL_IN_CONNECTED,
    CALL_CLEAR_REQUEST,
    CALL_DISCONNECT_NOTIFY,

    WAN_ERROR_NOTIFY,

    SET_LINK_INFO,

    NUM_MESSAGE_TYPES
} PPTP_MESSAGE_TYPE;

typedef struct {
    USHORT          Length;
    USHORT          PacketType;
    ULONG           Cookie;
    USHORT          MessageType;
    USHORT          Reserved0;
} PPTP_HEADER, *PPPTP_HEADER;

typedef struct {
    PPTP_HEADER;
    USHORT          Version;

    union {
        USHORT          Reserved1;
        struct {
            UCHAR           ResultCode;

                #define     RESULT_CONTROL_START_SUCCESS               1
                #define     RESULT_CONTROL_START_ERROR                 2
                #define     RESULT_CONTROL_START_ALREADY_CONNECTED     3
                #define     RESULT_CONTROL_START_UNAUTHORIZED          4
                #define     RESULT_CONTROL_START_VERSION_NOT_SUPPORTED 5

            UCHAR           ErrorCode;
        };
    };

    ULONG           FramingCapabilities;

        #define     FRAMING_ASYNC   BIT(0)
        #define     FRAMING_SYNC    BIT(1)

    ULONG           BearerCapabilities;

        #define     BEARER_ANALOG   BIT(0)
        #define     BEARER_DIGITAL  BIT(1)

    USHORT          MaxChannels;
    USHORT          FirmwareRevision;

    UCHAR           HostName[MAX_HOSTNAME_LENGTH];
    UCHAR           Vendor[MAX_VENDOR_LENGTH];
} PPTP_CONTROL_START_PACKET, *PPPTP_CONTROL_START_PACKET;

typedef struct {
    PPTP_HEADER;

    union {
        struct {
            UCHAR   Reason;

                #define     CONTROL_STOP_GENERAL                1
                #define     CONTROL_STOP_VERSION                2
                #define     CONTROL_STOP_LOCAL                  3

            UCHAR   Reserved1;
        };
        struct {
            UCHAR   ResultCode;

                #define     RESULT_CONTROL_STOP_SUCCESS                1
                #define     RESULT_CONTROL_STOP_ERROR                  2

            UCHAR   ErrorCode;
        };
    };

    USHORT Reserved2;
} PPTP_CONTROL_STOP_PACKET, *PPPTP_CONTROL_STOP_PACKET;

typedef struct {
    PPTP_HEADER;
    ULONG           Identifier;
} PPTP_CONTROL_ECHO_REQUEST_PACKET, *PPPTP_CONTROL_ECHO_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    ULONG           Identifier;
    UCHAR           ResultCode;

        #define     RESULT_CONTROL_ECHO_SUCCESS    1
        #define     RESULT_CONTROL_ECHO_FAILURE    2

    UCHAR           ErrorCode;
    USHORT          Reserved1;
} PPTP_CONTROL_ECHO_REPLY_PACKET, *PPPTP_CONTROL_ECHO_REPLY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          SerialNumber;
    ULONG           MinimumBPS;
    ULONG           MaximumBPS;
    ULONG           BearerType;
    ULONG           FramingType;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    USHORT          PhoneNumberLength;
    USHORT          Reserved1;
    UCHAR           PhoneNumber[MAX_PHONE_NUMBER_LENGTH];
    UCHAR           Subaddress[MAX_SUBADDRESS_LENGTH];
} PPTP_CALL_OUT_REQUEST_PACKET, *PPPTP_CALL_OUT_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          PeerCallId;
    UCHAR           ResultCode;

        #define     RESULT_CALL_OUT_CONNECTED      1
        #define     RESULT_CALL_OUT_ERROR          2
        #define     RESULT_CALL_OUT_NO_CARRIER     3
        #define     RESULT_CALL_OUT_BUSY           4
        #define     RESULT_CALL_OUT_NO_DIAL_TONE   5
        #define     RESULT_CALL_OUT_TIMEOUT        6
        #define     RESULT_CALL_OUT_REFUSED        7

    UCHAR           ErrorCode;
    USHORT          CauseCode;
    ULONG           ConnectSpeed;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    ULONG           PhysicalChannelId;
} PPTP_CALL_OUT_REPLY_PACKET, *PPPTP_CALL_OUT_REPLY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          SerialNumber;
    ULONG           BearerType;
    ULONG           PhysicalChannelId;
    USHORT          DialedNumberLength;
    USHORT          DialingNumberLength;
    UCHAR           DialedNumber[MAX_PHONE_NUMBER_LENGTH];
    UCHAR           DialingNumber[MAX_PHONE_NUMBER_LENGTH];
    UCHAR           Subaddress[MAX_SUBADDRESS_LENGTH];
} PPTP_CALL_IN_REQUEST_PACKET, *PPPTP_CALL_IN_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          PeerCallId;
    UCHAR           ResultCode;

        #define     RESULT_CALL_IN_CONNECTED       1
        #define     RESULT_CALL_IN_ERROR           2
        #define     RESULT_CALL_IN_REFUSED         3

    UCHAR           ErrorCode;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    USHORT          Reserved1;
} PPTP_CALL_IN_REPLY_PACKET, *PPPTP_CALL_IN_REPLY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          PeerCallId;
    USHORT          Reserved1;
    ULONG           ConnectSpeed;
    USHORT          RecvWindowSize;
    USHORT          ProcessingDelay;
    ULONG           FramingType;
} PPTP_CALL_IN_CONNECT_PACKET, *PPPTP_CALL_IN_CONNECT_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    USHORT          Reserved1;
} PPTP_CALL_CLEAR_REQUEST_PACKET, *PPPTP_CALL_CLEAR_REQUEST_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          CallId;
    UCHAR           ResultCode;

        #define     RESULT_CALL_DISCONNECT_LOST_CARRIER    1
        #define     RESULT_CALL_DISCONNECT_ERROR           2
        #define     RESULT_CALL_DISCONNECT_ADMIN           3
        #define     RESULT_CALL_DISCONNECT_REQUEST         4

    UCHAR           ErrorCode;
    USHORT          CauseCode;
    USHORT          Reserved1;
    UCHAR           CallStatistics[MAX_CALL_STATS_LENGTH];
} PPTP_CALL_DISCONNECT_NOTIFY_PACKET, *PPPTP_CALL_DISCONNECT_NOTIFY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          PeerCallId;
    USHORT          Reserved1;
    ULONG           CrcErrors;
    ULONG           FramingErrors;
    ULONG           HardwareOverruns;
    ULONG           BufferOverruns;
    ULONG           TimeoutErrors;
    ULONG           AlignmentErrors;
} PPTP_WAN_ERROR_NOTIFY_PACKET, *PPPTP_WAN_ERROR_NOTIFY_PACKET;

typedef struct {
    PPTP_HEADER;
    USHORT          PeerCallId;
    USHORT          Reserved1;
    ULONG           SendAccm;
    ULONG           RecvAccm;
} PPTP_SET_LINK_INFO_PACKET, *PPPTP_SET_LINK_INFO_PACKET;

#define MAX_CONTROL_PACKET_LENGTH sizeof(PPTP_CALL_IN_REQUEST_PACKET)

#endif //PROTOCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\common\tapi.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   TAPI.C - TAPI handling functions
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/17/1998
*
*****************************************************************************/

#include "raspptp.h"

NDIS_STATUS
TapiAnswer(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_ANSWER pRequest
    )
{
    PCALL_SESSION pCall = NULL;
    PCONTROL_TUNNEL pCtl;
    BOOLEAN LockHeld = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiAnswer\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiAnswer NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pCall = CallGetCall(pAdapter, pRequest->hdCall);
    
    // Verify the ID
    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiAnswer NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        Status = NDIS_STATUS_TAPI_INVALCALLHANDLE;
        goto taDone;
    }

    NdisAcquireSpinLock(&pCall->Lock);
    LockHeld = TRUE;
    pCtl = pCall->pCtl;

    if (!pCtl)
    {
        DEBUGMSG(DBG_WARN, (DTEXT("No control tunnel in TapiAnswer\n")));
        Status = NDIS_STATUS_FAILURE;
    }
    else if (pCall->State==STATE_CALL_OFFERING)
    {
        USHORT NewCallId;
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_OUT_REPLY);

        CallAssignSerialNumber(pCall);
        NewCallId = (USHORT)((pCall->SerialNumber << CALL_ID_INDEX_BITS) + pCall->DeviceId);
        if (pCall->Packet.CallId == NewCallId)
        {
            // Don't allow a line to have the same CallId twice in a row.
            NewCallId += (1<<CALL_ID_INDEX_BITS);
        }
        pCall->Packet.CallId = NewCallId;

        if (!pReply)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            pCall->Close.Checklist &= ~(CALL_CLOSE_DROP|
                                        CALL_CLOSE_DROP_COMPLETE|
                                        CALL_CLOSE_CLEANUP_STATE|
                                        CALL_CLOSE_CLOSE_CALL);
            CallSetState(pCall, STATE_CALL_ESTABLISHED, 0, LOCKED);

            pCall->Speed = pCtl->Speed;
            // pCtl is safe to touch because it can't be released from the call
            // without the call spinlock.

            NdisReleaseSpinLock(&pCall->Lock);
            LockHeld = FALSE;

            pReply->PeerCallId = htons(pCall->Remote.CallId);
            pReply->CallId = htons(pCall->Packet.CallId);
            pReply->ResultCode = RESULT_CALL_OUT_CONNECTED;
            pReply->RecvWindowSize = PPTP_RECV_WINDOW;
            pReply->ConnectSpeed = pCall->Speed;
            pReply->ProcessingDelay = 0;
            pReply->PhysicalChannelId = 0;
            Status = CtlSend(pCtl, pReply);
            if (Status!=NDIS_STATUS_SUCCESS)
            {
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, UNLOCKED);
                CallCleanup(pCall, UNLOCKED);
            }
        }
    }
    else if (pCall->State==STATE_CALL_PAC_OFFERING)
    {
        USHORT NewCallId;
        PPTP_CALL_OUT_REPLY_PACKET *pReply = CtlAllocPacket(pCtl, CALL_IN_REPLY);

        CallAssignSerialNumber(pCall);
        NewCallId = (USHORT)((pCall->SerialNumber << CALL_ID_INDEX_BITS) + pCall->DeviceId);
        if (pCall->Packet.CallId == NewCallId)
        {
            // Don't allow a line to have the same CallId twice in a row.
            NewCallId += (1<<CALL_ID_INDEX_BITS);
        }
        pCall->Packet.CallId = NewCallId;

        if (!pReply)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            pCall->Close.Checklist &= ~(CALL_CLOSE_DROP|
                                        CALL_CLOSE_DROP_COMPLETE|
                                        CALL_CLOSE_CLEANUP_STATE|
                                        CALL_CLOSE_CLOSE_CALL);
            CallSetState(pCall, STATE_CALL_PAC_WAIT, 0, LOCKED);
            NdisReleaseSpinLock(&pCall->Lock);
            LockHeld = FALSE;
            //TapiLineUp(pCall);

            pReply->PeerCallId = htons(pCall->Remote.CallId);
            pReply->CallId = htons(pCall->Packet.CallId);
            pReply->ResultCode = RESULT_CALL_IN_CONNECTED;
            pReply->RecvWindowSize = PPTP_RECV_WINDOW;
            pReply->ProcessingDelay = 0;
            Status = CtlSend(pCtl, pReply);
            if (Status!=NDIS_STATUS_SUCCESS)
            {
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, UNLOCKED);
                CallCleanup(pCall, UNLOCKED);
            }
        }
    }
    else
    {
        DEBUGMSG(DBG_WARN, (DTEXT("Wrong state for TapiAnswer %d\n"), pCall->State));
        Status = NDIS_STATUS_FAILURE;
    }

taDone:
    if (LockHeld)
    {
        NdisReleaseSpinLock(&pCall->Lock);
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-TapiAnswer %08x\n"), Status));
    return Status;
}

NDIS_STATUS
TapiClose(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE pRequest
    )
{
    PCALL_SESSION pCall;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiClose\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiClose NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

#if SINGLE_LINE
    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiClose NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    NdisAcquireSpinLock(&pAdapter->Lock);
    pAdapter->Tapi.Open = FALSE;
    pAdapter->Tapi.hTapiLine = 0;
    NdisReleaseSpinLock(&pAdapter->Lock);
    if (pAdapter->hCtdiListen)
    {
        // We have to pend this request until the listen endpoint is closed
        CtdiSetRequestPending(pAdapter->hCtdiListen);
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
        Status = NDIS_STATUS_PENDING;
    }

#else
    pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiClose NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    NdisAcquireSpinLock(&pCall->Lock);

    pCall->Close.Checklist |= CALL_CLOSE_CLOSE_LINE;
    if (!(pCall->Close.Checklist&CALL_CLOSE_DROP))
    {
        pCall->Close.Checklist |= (CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE);
    }
    pCall->Open = FALSE;
    pCall->hTapiLine = 0;
    //pCall->DeviceId = 0;

    CallDetachFromAdapter(pCall);
    CallCleanup(pCall, LOCKED);
    NdisReleaseSpinLock(&pCall->Lock);
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiClose\n")));
    return Status;
}

NDIS_STATUS
TapiCloseCall(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_CLOSE_CALL pRequest
    )
{
    PCALL_SESSION pCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiCloseCall\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiCloseCall NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiAnswer NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        goto tccDone;
    }

    NdisAcquireSpinLock(&pCall->Lock);
    pCall->Close.Checklist |= CALL_CLOSE_CLOSE_CALL;
    pCall->hTapiCall = 0;
    CallCleanup(pCall, LOCKED);
    NdisReleaseSpinLock(&pCall->Lock);


tccDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiCloseCall\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiDrop(
    IN PPPTP_ADAPTER pAdapter,
    IN PNDIS_TAPI_DROP pRequest
    )
{
    PCALL_SESSION pCall;
    PCONTROL_TUNNEL pCtl;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    BOOLEAN CleanupNow = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiDrop\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiDrop NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiDrop NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"TapiDrop:%d\n"),
                          LOGHDR(27, pCall->Remote.Address.Address[0].Address[0].in_addr),
                          pCall->DeviceId));
    NdisAcquireSpinLock(&pCall->Lock);

    //ASSERT(!(pCall->Close.Checklist&CALL_CLOSE_DROP));

    pCtl = pCall->pCtl;

    if (pCall->State==STATE_CALL_ESTABLISHED)
    {
        PPPTP_CALL_CLEAR_REQUEST_PACKET pPacket = CtlAllocPacket(pCtl, CALL_CLEAR_REQUEST);

        if (!pPacket)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            CallSetState(pCall, STATE_CALL_WAIT_DISCONNECT, 0, LOCKED);
            pPacket->CallId = htons(pCall->Packet.CallId);

            NdisReleaseSpinLock(&pCall->Lock);
            Status = CtlSend(pCtl, pPacket);
            if (Status==NDIS_STATUS_SUCCESS)
            {
                Status = NDIS_STATUS_PENDING;
            }
            if (Status==NDIS_STATUS_PENDING)
            {
                NdisMSetTimer(&pCall->Close.Timer, PPTP_CLOSE_TIMEOUT);
            }
            NdisAcquireSpinLock(&pCall->Lock);
        }
    }
    else if (pCall->State!=STATE_CALL_CLEANUP)
    {
        CallSetState(pCall, STATE_CALL_CLEANUP, 0, LOCKED);
        CleanupNow = TRUE;
    }

    pCall->Close.Checklist |= CALL_CLOSE_DROP;
    if (Status==NDIS_STATUS_PENDING)
    {
        pCall->Close.Checklist &= ~CALL_CLOSE_DROP_COMPLETE;
    }
    else
    {
        pCall->Close.Checklist |= CALL_CLOSE_DROP_COMPLETE;
    }
    if (CleanupNow)
    {
        CallCleanup(pCall, LOCKED);
    }
    NdisReleaseSpinLock(&pCall->Lock);

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-TapiDrop %08x\n"), Status));
    return Status;
}

NDIS_STATUS
TapiGetAddressCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_CAPS pRequest
    )
{
    BOOLEAN ValidCall;
    CHAR LineAddress[TAPI_MAX_LINE_ADDRESS_LENGTH];
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetAddressCaps\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    ValidCall = CallIsValidCall(pAdapter, pRequest->ulDeviceID);

    if (!ValidCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_NODRIVER\n")));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    if (pRequest->ulAddressID >= TAPI_ADDR_PER_LINE)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_INVALADDRESSID\n")));
        return NDIS_STATUS_TAPI_INVALADDRESSID;

    }

    if (pRequest->ulExtVersion!=0 &&
        pRequest->ulExtVersion!=TAPI_EXT_VERSION)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION\n")));
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    pRequest->LineAddressCaps.ulDialToneModes     = LINEDIALTONEMODE_NORMAL;
    pRequest->LineAddressCaps.ulSpecialInfo       = LINESPECIALINFO_UNAVAIL;

    pRequest->LineAddressCaps.ulDisconnectModes   = LINEDISCONNECTMODE_NORMAL |
                                                    LINEDISCONNECTMODE_UNKNOWN |
                                                    LINEDISCONNECTMODE_BUSY |
                                                    LINEDISCONNECTMODE_NOANSWER;

#if SINGLE_LINE
    pRequest->LineAddressCaps.ulMaxNumActiveCalls = pAdapter->Info.Endpoints;
#else
    pRequest->LineAddressCaps.ulMaxNumActiveCalls = 1;
#endif
    pRequest->LineAddressCaps.ulMaxNumTransConf   = 1;
    pRequest->LineAddressCaps.ulAddrCapFlags      = LINEADDRCAPFLAGS_DIALED;

    pRequest->LineAddressCaps.ulCallFeatures      = LINECALLFEATURE_ACCEPT |
                                                    LINECALLFEATURE_ANSWER |
                                                    LINECALLFEATURE_COMPLETECALL |
                                                    LINECALLFEATURE_DIAL |
                                                    LINECALLFEATURE_DROP;

    pRequest->LineAddressCaps.ulLineDeviceID      = pRequest->ulDeviceID;
    pRequest->LineAddressCaps.ulAddressSharing    = LINEADDRESSSHARING_PRIVATE;
    pRequest->LineAddressCaps.ulAddressStates     = 0;

    // List of all possible call states.

    pRequest->LineAddressCaps.ulCallStates        = LINECALLSTATE_IDLE |
                                                    LINECALLSTATE_OFFERING |
                                                    LINECALLSTATE_DIALING |
                                                    LINECALLSTATE_PROCEEDING |
                                                    LINECALLSTATE_CONNECTED |
                                                    LINECALLSTATE_DISCONNECTED;

    OsGetTapiLineAddress(DeviceIdToIndex(pAdapter, pRequest->ulDeviceID),
                         LineAddress,
                         sizeof(LineAddress));

    pRequest->LineAddressCaps.ulNeededSize = sizeof(pRequest->LineAddressCaps) +
                                             strlen(LineAddress) + 1;

    if (pRequest->LineAddressCaps.ulTotalSize<pRequest->LineAddressCaps.ulNeededSize)
    {
        pRequest->LineAddressCaps.ulUsedSize = 0;
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressCaps NDIS_STATUS_INVALID_LENGTH\n")));
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineAddressCaps.ulAddressSize = strlen(LineAddress) + 1;
    pRequest->LineAddressCaps.ulAddressOffset = sizeof(pRequest->LineAddressCaps);
    strcpy((PUCHAR)((&pRequest->LineAddressCaps) + 1), LineAddress);

    pRequest->LineAddressCaps.ulUsedSize = pRequest->LineAddressCaps.ulNeededSize;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetAddressCaps\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiGetAddressStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ADDRESS_STATUS pRequest
    )
{
    PCALL_SESSION pCall = NULL;
    BOOLEAN fReady;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetAddressStatus\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetAddressStatus NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    
    DEBUGMSG(DBG_TAPI, (DTEXT("TapiGetAddressStatus: hdLine=%Xh, ulAddressID=%d\n"),
               pRequest->hdLine, pRequest->ulAddressID));


    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetAddressStatus NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    if (pRequest->ulAddressID >= TAPI_ADDR_PER_LINE)
    {
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetAddressStatus NDIS_STATUS_TAPI_INVALADDRESSID\n")));
        return NDIS_STATUS_TAPI_INVALADDRESSID;
    }

#if SINGLE_LINE
    pCall = CallGetCall(pAdapter, 0);
#else
    pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));
#endif
    if( pCall==NULL || (pCall->State == STATE_CALL_IDLE) ){
        fReady = TRUE;
    }else{
        fReady = FALSE;
    }

    pRequest->LineAddressStatus.ulNeededSize =
    pRequest->LineAddressStatus.ulUsedSize = sizeof(pRequest->LineAddressStatus);

    pRequest->LineAddressStatus.ulNumInUse = fReady ? 0 : 1;
    pRequest->LineAddressStatus.ulNumActiveCalls = fReady ? 0 : 1;
    pRequest->LineAddressStatus.ulAddressFeatures = fReady ? LINEADDRFEATURE_MAKECALL : 0;
    pRequest->LineAddressStatus.ulNumRingsNoAnswer = 999;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetAddressStatus\n")));
    return NDIS_STATUS_SUCCESS;

}


NDIS_STATUS
TapiGetCallInfo(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_INFO pRequest,
    IN OUT PULONG pRequiredLength
    )
{
    PCALL_SESSION pCall;
    LINE_CALL_INFO *pLineCallInfo = NULL;
    ULONG CallerIdLength;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetCallInfo\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetCallInfo NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    pLineCallInfo = &pRequest->LineCallInfo;

    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallInfo NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        DEBUGMSG(DBG_FUNC | DBG_WARN, (DTEXT("-TapiGetCallInfo NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    CallerIdLength = strlen(pCall->CallerId);
    if( CallerIdLength ){
        CallerIdLength += 1; // Add one for null terminator
    }
    if( pRequiredLength ){
        // Note: This returns NDIS struct size not LineCallInfo Size
        *pRequiredLength = sizeof(NDIS_TAPI_GET_CALL_INFO) + CallerIdLength;
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallInfo NDIS_STATUS_SUCCESS - Returning Length Only Len=0x%X\n"), *pRequiredLength));
        return NDIS_STATUS_SUCCESS;
    }

    pLineCallInfo->ulNeededSize = sizeof(pRequest->LineCallInfo) + CallerIdLength;

    if( pLineCallInfo->ulTotalSize < sizeof(pRequest->LineCallInfo) ){
        pLineCallInfo->ulUsedSize = 0;
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallInfo NDIS_STATUS_INVALID_LENGTH\n")));
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pLineCallInfo->ulUsedSize = sizeof(pRequest->LineCallInfo);

    pLineCallInfo->hLine = (ULONG)pCall->DeviceId;
    pLineCallInfo->ulLineDeviceID = (ULONG)pCall->DeviceId;
    pLineCallInfo->ulAddressID = TAPI_ADDRESSID;

    pLineCallInfo->ulBearerMode = LINEBEARERMODE_DATA;
    pLineCallInfo->ulRate = pCall->Speed;
    pLineCallInfo->ulMediaMode = pCall->MediaModeMask;

    pLineCallInfo->ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    pLineCallInfo->ulCallStates = CALL_STATES_MASK;

    pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCallerIDSize = 0;
    pLineCallInfo->ulCalledIDOffset = 0;
    pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_UNAVAIL;
    pLineCallInfo->ulCalledIDSize = 0;

    if( CallerIdLength ){
        if (pLineCallInfo->ulTotalSize >= pLineCallInfo->ulNeededSize)
        {
            PUCHAR pCallerId = (PUCHAR)(pLineCallInfo + 1);

            strcpy(pCallerId, pCall->CallerId);
            if (pCall->Inbound)
            {
                pLineCallInfo->ulCallerIDFlags = LINECALLPARTYID_ADDRESS;
                pLineCallInfo->ulCallerIDSize = CallerIdLength;
                pLineCallInfo->ulCallerIDOffset = sizeof(LINE_CALL_INFO);
            }
            else
            {
                pLineCallInfo->ulCalledIDFlags = LINECALLPARTYID_ADDRESS;
                pLineCallInfo->ulCalledIDSize = CallerIdLength;
                pLineCallInfo->ulCalledIDOffset = sizeof(LINE_CALL_INFO);
            }

            pLineCallInfo->ulUsedSize = pLineCallInfo->ulNeededSize;

        }else{
            DEBUGMSG(DBG_FUNC|DBG_WARN, (DTEXT("-TapiGetCallInfo NDIS_STATUS_SUCCESS without CallerID string\n")));
            return NDIS_STATUS_SUCCESS;
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallInfo\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiGetCallStatus(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_CALL_STATUS pRequest
    )
{
    PCALL_SESSION pCall;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetCallStatus\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetCallStatus NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallStatus NDIS_STATUS_TAPI_INVALCALLHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALCALLHANDLE;
    }

    pRequest->LineCallStatus.ulNeededSize =
        pRequest->LineCallStatus.ulUsedSize = sizeof(LINE_CALL_STATUS);

    pRequest->LineCallStatus.ulCallFeatures = LINECALLFEATURE_ANSWER | LINECALLFEATURE_DROP;
    pRequest->LineCallStatus.ulCallPrivilege = LINECALLPRIVILEGE_OWNER;
    pRequest->LineCallStatus.ulCallState = CallGetLineCallState(pCall->State);

    DBG_X(DBG_TAPI, pRequest->LineCallStatus.ulCallState);

    switch (pRequest->LineCallStatus.ulCallState)
    {
        case LINECALLSTATE_DIALTONE:
            pRequest->LineCallStatus.ulCallStateMode = LINEDIALTONEMODE_NORMAL;
            break;
        case LINECALLSTATE_BUSY:
            pRequest->LineCallStatus.ulCallStateMode = LINEBUSYMODE_STATION;
            break;
        case LINECALLSTATE_DISCONNECTED:
            pRequest->LineCallStatus.ulCallStateMode = LINEDISCONNECTMODE_UNKNOWN;
            break;
        default:
            break;
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetCallStatus\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiGetDevCaps(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    )
{
    BOOLEAN ValidCall;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetDevCaps\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetDevCaps NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    ValidCall = CallIsValidCall(pAdapter, pRequest->ulDeviceID);

    if (!ValidCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetDevCaps NDIS_STATUS_TAPI_NODRIVER\n")));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    if (pRequest->LineDevCaps.ulTotalSize<sizeof(pRequest->LineDevCaps))
    {
        pRequest->LineDevCaps.ulUsedSize = 0;
        DEBUGMSG(DBG_FUNC|DBG_ERROR, (DTEXT("-TapiGetDevCaps NDIS_STATUS_INVALID_LENGTH\n")));
        return NDIS_STATUS_INVALID_LENGTH;
    }

    pRequest->LineDevCaps.ulUsedSize = sizeof(pRequest->LineDevCaps);

    pRequest->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID |
                                           LINEADDRESSMODE_DIALABLEADDR;
    pRequest->LineDevCaps.ulNumAddresses = 1;
    pRequest->LineDevCaps.ulBearerModes  = LINEBEARERMODE_DATA;

    pRequest->LineDevCaps.ulDevCapFlags  = LINEDEVCAPFLAGS_CLOSEDROP;
#if SINGLE_LINE
    pRequest->LineDevCaps.ulMaxNumActiveCalls = pAdapter->Info.Endpoints;
#else
    pRequest->LineDevCaps.ulMaxNumActiveCalls = 1;
#endif
    pRequest->LineDevCaps.ulAnswerMode   = LINEANSWERMODE_DROP;
    pRequest->LineDevCaps.ulRingModes    = 1;

    pRequest->LineDevCaps.ulPermanentLineID = pRequest->ulDeviceID + 1;
    pRequest->LineDevCaps.ulMaxRate      = 0;
    pRequest->LineDevCaps.ulMediaModes   = LINEMEDIAMODE_DIGITALDATA;

    Status = OsSpecificTapiGetDevCaps( pRequest->ulDeviceID, pRequest );

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetDevCaps\n")));
    return Status;
}





NDIS_STATUS
TapiGetExtensionId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_EXTENSION_ID pRequest
    )
{
    BOOLEAN ValidCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetExtensionId\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetExtensionId NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
    ValidCall = CallIsValidCall(pAdapter, pRequest->ulDeviceID);
    if (!ValidCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetExtensionId NDIS_STATUS_TAPI_NODRIVER\n")));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

    // No extensions supported.
    pRequest->LineExtensionID.ulExtensionID0 = 0;
    pRequest->LineExtensionID.ulExtensionID1 = 0;
    pRequest->LineExtensionID.ulExtensionID2 = 0;
    pRequest->LineExtensionID.ulExtensionID3 = 0;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetExtensionId\n")));
    return NDIS_STATUS_SUCCESS;
}

#define PPTP_DEVICE_TYPE_STR "PPTP"

NDIS_STATUS
TapiGetId(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_GET_ID pRequest
    )
{
    PCALL_SESSION pCall;
    ULONG_PTR DeviceID;
    BOOLEAN IsNdisClass = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiGetId\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Make sure this is a tapi or ndis request.
    if (_strnicmp((PCHAR) pRequest + pRequest->ulDeviceClassOffset,
                  NDIS_DEVICECLASS_NAME, pRequest->ulDeviceClassSize) == 0)
    {
        IsNdisClass = TRUE;
    }
    else if (_strnicmp((PCHAR) pRequest + pRequest->ulDeviceClassOffset,
                  TAPI_DEVICECLASS_NAME, pRequest->ulDeviceClassSize) != 0)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALDEVICECLASS\n")));
        return NDIS_STATUS_TAPI_INVALDEVICECLASS;
    }

    DBG_D(DBG_TAPI, pRequest->ulSelect);

#if DBG    

    if(pRequest->ulDeviceClassSize != 0)
    {
        DBG_S(DBG_TAPI, (PCHAR) pRequest + pRequest->ulDeviceClassOffset);
    }
    
#endif    

    switch (pRequest->ulSelect) {
        case LINECALLSELECT_LINE:
#if SINGLE_LINE
            if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }
            DeviceID = 0;
#else
            pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));

            if (pCall == NULL)
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }
            DeviceID = pCall->DeviceId;
#endif

            break;

        case LINECALLSELECT_ADDRESS:
#if SINGLE_LINE
            if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }
            if (pRequest->ulAddressID >= TAPI_ADDR_PER_LINE)
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALADDRESSID\n")));
                return NDIS_STATUS_TAPI_INVALADDRESSID;
            }
            DeviceID = 0;
#else
            pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));

            if (pCall == NULL)
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }

            if (pRequest->ulAddressID >= TAPI_ADDR_PER_LINE)
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALADDRESSID\n")));
                return NDIS_STATUS_TAPI_INVALADDRESSID;
            }
            DeviceID = pCall->DeviceId;
#endif
            break;

        case LINECALLSELECT_CALL:
            pCall = CallGetCall(pAdapter, pRequest->hdCall);

            if (pCall == NULL)
            {
                DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
                return NDIS_STATUS_TAPI_INVALLINEHANDLE;
            }
            TapiLineUp(pCall);

            DeviceID = (ULONG_PTR)pCall->NdisLinkContext;

            break;

        default:
            DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetId NDIS_STATUS_FAILURE ulSelect=%d\n"), pRequest->ulSelect));
            return (NDIS_STATUS_FAILURE);

    }

    // Default to the minimum amount of data we will return.
    pRequest->DeviceID.ulUsedSize = sizeof(VAR_STRING);

    if( IsNdisClass ){
        // The format of the DeviceID for the "ndis" class is:
        struct _NDIS_CLASS {
            ULONG_PTR   hDevice;
            CHAR        szDeviceType[1];
        } *pNDISClass;

        pRequest->DeviceID.ulNeededSize =sizeof(VAR_STRING) + sizeof(PVOID) + 
            sizeof(DeviceID) + sizeof(PPTP_DEVICE_TYPE_STR);

        if (pRequest->DeviceID.ulTotalSize >= pRequest->DeviceID.ulNeededSize)
        {
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;
            pRequest->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
            pRequest->DeviceID.ulStringSize   = sizeof(DeviceID) + sizeof(PPTP_DEVICE_TYPE_STR);

            pNDISClass = (struct _NDIS_CLASS *)
                ((PUCHAR)((&pRequest->DeviceID) + 1) + sizeof(PVOID));

            (ULONG_PTR)pNDISClass &=
                ~((ULONG_PTR)sizeof(PVOID) - 1);

            pRequest->DeviceID.ulStringOffset = (ULONG)
                ((PUCHAR)pNDISClass - (PUCHAR)(&pRequest->DeviceID));

            pNDISClass->hDevice = DeviceID;

            DBG_X(DBG_TAPI, pNDISClass->hDevice);
            NdisMoveMemory(pNDISClass->szDeviceType, PPTP_DEVICE_TYPE_STR, sizeof(PPTP_DEVICE_TYPE_STR));
        }

    }else{
        // Now we need to adjust the variable field to place the device ID.

        pRequest->DeviceID.ulNeededSize = sizeof(VAR_STRING) + sizeof(DeviceID);
        if (pRequest->DeviceID.ulTotalSize >= pRequest->DeviceID.ulNeededSize)
        {
            pRequest->DeviceID.ulUsedSize = pRequest->DeviceID.ulNeededSize;
            pRequest->DeviceID.ulStringFormat = STRINGFORMAT_BINARY;
            pRequest->DeviceID.ulStringSize   = sizeof(DeviceID);
            pRequest->DeviceID.ulStringOffset = sizeof(VAR_STRING);

            *(PULONG_PTR)((&pRequest->DeviceID) + 1) = DeviceID;
        }
    }

    //DEBUGMEM(DBG_TAPI, &pRequest->DeviceID, pRequest->DeviceID.ulUsedSize, 1);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiGetId\n")));
    return NDIS_STATUS_SUCCESS;
}

VOID
TapiLineDown(
    PCALL_SESSION pCall
    )
{
    NDIS_MAC_LINE_DOWN LineDownInfo;
    DEBUGMSG(DBG_FUNC|DBG_CALL|DBG_TAPI, (DTEXT("+TapiLineDown %08x\n"), pCall->NdisLinkContext));

    if (pCall->NdisLinkContext)
    {
        LineDownInfo.NdisLinkContext = pCall->NdisLinkContext;

        LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"TapiLineDown:%d\n"),
                              LOGHDR(28, pCall->Remote.Address.Address[0].Address[0].in_addr),
                              pCall->DeviceId));
        /*
        * Indicate the event to the WAN wrapper.
        */
        NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                            NDIS_STATUS_WAN_LINE_DOWN,
                            &LineDownInfo,
                            sizeof(LineDownInfo));
        pCall->NdisLinkContext = NULL;
    }
    else
    {
        LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"TapiLineDown:%d - No NdisLinkContext\n"),
                              LOGHDR(28, pCall->Remote.Address.Address[0].Address[0].in_addr),
                              pCall->DeviceId));
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiLineDown\n")));
}

VOID
TapiLineUp(
    PCALL_SESSION pCall
    )
{
    NDIS_MAC_LINE_UP LineUpInfo;

    DEBUGMSG(DBG_FUNC|DBG_CALL|DBG_TAPI, (DTEXT("+TapiLineUp %08x\n"), pCall));

    NdisAcquireSpinLock(&pCall->Lock);
    pCall->Close.Checklist &= ~CALL_CLOSE_LINE_DOWN;
    NdisReleaseSpinLock(&pCall->Lock);
    /*
    * Initialize the LINE_UP event packet.
    */
    LineUpInfo.LinkSpeed = pCall->Speed / 100;
    LineUpInfo.Quality             = NdisWanErrorControl;
    LineUpInfo.SendWindow          = 0;

    // Jeff says Win98 needs the DeviceID as the connection wrapper ID, but
    // TonyBe says NT needs an absolutely unique ID, which hTapiCall is.
    // hTapiCall is probably more correct according to Tapi rules, but we make
    // allowances.

    LineUpInfo.ConnectionWrapperID = OS_CONNECTION_WRAPPER_ID;
    LineUpInfo.NdisLinkHandle      = (NDIS_HANDLE) DeviceIdToLinkHandle(pCall->DeviceId);
    LineUpInfo.NdisLinkContext     = pCall->NdisLinkContext;

    LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"TapiLineUp:%d\n"),
                          LOGHDR(27, pCall->Remote.Address.Address[0].Address[0].in_addr),
                          pCall->DeviceId));
    /*
    * Indicate the event to the WAN wrapper.
    */
    NdisMIndicateStatus(pCall->pAdapter->hMiniportAdapter,
                        NDIS_STATUS_WAN_LINE_UP,
                        &LineUpInfo,
                        sizeof(LineUpInfo));

    NdisAcquireSpinLock(&pCall->Lock);
    pCall->NdisLinkContext = LineUpInfo.NdisLinkContext;
    NdisReleaseSpinLock(&pCall->Lock);
    DBG_X(DBG_TAPI, LineUpInfo.NdisLinkContext);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiLineUp\n")));
}

typedef struct {
    TA_IP_ADDRESS   TargetAddress[MAX_TARGET_ADDRESSES];
    ULONG           NumAddresses;
    ULONG           CurrentAddress;
} MAKE_CALL_CONTEXT, *PMAKE_CALL_CONTEXT;

VOID
TapipParseIpAddresses(
    IN OUT  PUCHAR *ppAddressList,
    IN      ULONG   ListLength,
    IN OUT  PTA_IP_ADDRESS TargetAddress,
    IN OUT  PULONG  pulCountAddresses
    )
{
    BOOLEAN ValidAddress;
    ULONG NumTargetAddresses = 0;
    PUCHAR pAddressList, pEndAddressList;
    ULONG MaxTargetAddresses = *pulCountAddresses;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipParseAddresses\n")));

    // TAPI gives us an address of the following forms:
    //
    // [ IP Address ... IP Address ] [ Phone Number ]
    //
    // It begins with a list of addresses to try, and an optional phone number
    // if the remote device is an access concentrator.

    NdisZeroMemory(TargetAddress, sizeof(TargetAddress));

    pAddressList = *ppAddressList;
    pEndAddressList = pAddressList + ListLength;

    // ToDo: we expect NULL terminated.  Is ok?

    // On Win98 an error may be passed rather than an address
    // In which cast the form is "E=XXXXXXX" where XXXXXXXX is a hexidecimal error code
    if( *pAddressList == 'E' && *(pAddressList+1) == '=' ){
        ULONG Err;
    
        // An Error code has been passed down to us from name resolution rather
        // than an IP address. Parse the error code and pass it along.
        if( !axtol( pAddressList + 2, &Err )){  // Get the error code from the string
            Err = (ULONG)-1L;
        }

        NumTargetAddresses = 1;
        TargetAddress->TAAddressCount = 0xffffffff;   // Magic cookie to indicate error code
        TargetAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        TargetAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        TargetAddress->Address[0].Address[0].sin_port = 0;
        TargetAddress->Address[0].Address[0].in_addr = Err;

        pAddressList = pAddressList + strlen(pAddressList);

        LOGMSG( FLL_USER,(DTEXT("An error occured while resolving the VPN name and an\n")));
        LOGMSG( FLL_USER,(DTEXT("    error number was passed to PPTP instead of an address\n")));
        LOGMSG( FLL_USER,(DTEXT("    The error number passed is %u(0x%x)\n"), Err, Err ));
        DEBUGMSG( DBG_ERROR,(DTEXT("TapiMakeCall was passed error 0x%x\n"), Err ));
//      Reason = PptpTapiMapError(Err);   // &&&&
//      DBG_ERROR( "Reporting disconnect for reason 0x%X\n", Reason );
    }else{

        ValidAddress = TRUE;
        while (ValidAddress && pAddressList<pEndAddressList)
        {
            pAddressList = StringToIpAddress(pAddressList,
                                         &TargetAddress[NumTargetAddresses],
                                         &ValidAddress);

            if (ValidAddress)
            {
                if (++NumTargetAddresses==MaxTargetAddresses)
                {
                    // We've hit the limit of what we'll take.  Throw the rest.
                    while (ValidAddress && pAddressList<pEndAddressList)
                    {
                        TA_IP_ADDRESS ThrowAway;
                        pAddressList = StringToIpAddress(pAddressList,
                                                         &ThrowAway,
                                                         &ValidAddress);
                    }
                }
            }
        }
    }
    *pulCountAddresses = NumTargetAddresses;
    *ppAddressList = pAddressList;

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipParseAddresses\n")));
}

VOID
TapipMakeCallCallback(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PCALL_SESSION pCall;
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    PNDIS_TAPI_MAKE_CALL pRequest = pWorkItem->pBuffer;
    NDIS_STATUS Status;
    PUCHAR pAddressList;
    ULONG NumAddresses;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipMakeCallCallback\n")));

#if SINGLE_LINE
    pCall = CallGetCall(pAdapter, pRequest->hdCall);

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapipMakeCallCallback NDIS_STATUS_TAPI_INUSE\n")));
        NdisMSetInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_TAPI_INUSE);
        return;
    }
#else
    pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapipMakeCallCallback NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        NdisMSetInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_TAPI_INVALLINEHANDLE);
        return;
    }
#endif

    DEBUGMEM(DBG_TAPI,
             (PUCHAR)pRequest + pRequest->ulDestAddressOffset,
             pRequest->ulDestAddressSize,
             1);

    NdisAcquireSpinLock(&pCall->Lock);

    CallSetState(pCall, STATE_CALL_DIALING, 0, LOCKED);
    NdisMSetTimer(&pCall->DialTimer, 60*1000);

    pCall->UseUdp = (PptpTunnelConfig&CONFIG_INITIATE_UDP) ? TRUE : FALSE;
    pAddressList = (PUCHAR)pRequest + pRequest->ulDestAddressOffset;
    NumAddresses = 1;
    TapipParseIpAddresses(&pAddressList,
                          pRequest->ulDestAddressSize,
                          &pCall->Remote.Address,
                          &NumAddresses);
    // We've got the addresses.  Now nab the phone #
    {
        ULONG Digits = 0;
        while (*pAddressList && (*pAddressList==' ' || *pAddressList=='\t'))
        {
            pAddressList++;
        }
        while (*pAddressList &&
               Digits<MAX_PHONE_NUMBER_LENGTH-1)
        {
            pCall->CallerId[Digits++] = *pAddressList++;
        }
        pCall->CallerId[Digits] = '\0';
#if 0
        // This apparently breaks Alcatel
        if (!Digits)
        {
            IpAddressToString(htonl(pCall->Remote.Address.Address[0].Address[0].in_addr), pCall->CallerId);
        }
#endif
        DEBUGMSG(DBG_CALL, (DTEXT("Dialing %hs\n"), pCall->CallerId));
    }

    // ToDo: try all of the addresses.

    pCall->Close.Checklist &= ~(CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE|CALL_CLOSE_CLOSE_CALL);
    pCall->Close.Checklist &= ~(CALL_CLOSE_DISCONNECT|CALL_CLOSE_CLEANUP_STATE);

    NdisReleaseSpinLock(&pCall->Lock);

    Status = CtlConnectCall(pAdapter, pCall, &pCall->Remote.Address);
    NdisAcquireSpinLock(&pCall->Lock);
    if (Status==NDIS_STATUS_PENDING)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    else if (Status!=NDIS_STATUS_SUCCESS)
    {
        // We weren't successful, so we won't be getting these calls from tapi
        pCall->Close.Checklist |= (CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE|CALL_CLOSE_CLOSE_CALL);
    }
    pCall->Remote.Address.Address[0].Address[0].sin_port = htons(PptpUdpPort);
    NdisReleaseSpinLock(&pCall->Lock);
    NdisMSetInformationComplete(pAdapter->hMiniportAdapter, Status);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipMakeCallCallback\n")));
}

NDIS_STATUS
TapiMakeCall(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_MAKE_CALL pRequest
    )
{
    PCALL_SESSION pCall;
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiMakeCall\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

#if SINGLE_LINE
    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    pCall = CallFindAndLock(pAdapter, STATE_CALL_IDLE, FIND_OUTGOING);

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INUSE\n")));
        return NDIS_STATUS_TAPI_INUSE;
    }
#else
    pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    NdisAcquireSpinLock(&pCall->Lock);
#endif

    if (pCall->State != STATE_CALL_IDLE)
    {
        NdisReleaseSpinLock(&pCall->Lock);
        DEBUGMSG(DBG_ERROR, (DTEXT("-TapiMakeCall NDIS_STATUS_TAPI_INUSE\n")));
        return NDIS_STATUS_TAPI_INUSE;
    }

    // Save the handle tapi provides
    pCall->hTapiCall = pRequest->htCall;

    // our handle for tapi to this call is the device id
    pRequest->hdCall = pCall->DeviceId;

    CallSetState(pCall, STATE_CALL_OFFHOOK, 0, LOCKED);

    NdisReleaseSpinLock(&pCall->Lock);

    if (pRequest->ulDestAddressSize)
    {
        // Schedule a work item so we can issue a CtlCreateCall at passive level.
        Status = ScheduleWorkItem(TapipMakeCallCallback,
                                  pAdapter,
                                  pRequest,
                                  0);

        if (Status==NDIS_STATUS_SUCCESS)
        {
            // Keep the pRequest around until the callback.
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_UNKNOWN, UNLOCKED);
            CallCleanup(pCall, UNLOCKED);
        }

        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiMakeCall %08x\n"), Status));
        return Status;
    }

    pCall->Close.Checklist &= ~(CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE|CALL_CLOSE_CLOSE_CALL);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiMakeCall\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
TapiNegotiateExtVersion(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_NEGOTIATE_EXT_VERSION pRequest
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiNegotiateExtVersion Low=%08x Hi=%08x\n"),
                        pRequest ? pRequest->ulLowVersion : 0, pRequest ? pRequest->ulHighVersion : 0));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiNegotiateExtVersion NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if (pRequest->ulLowVersion < TAPI_EXT_VERSION ||
        pRequest->ulHighVersion > TAPI_EXT_VERSION)
    {
        return NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiNegotiateExtVersion\n")));
    return NDIS_STATUS_SUCCESS;
}

VOID
TapipPassiveOpen(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipPassiveOpen\n")));

    // We only come here if PptpInitialized = FALSE;
    // It's a mechanism to defer opening tcp handles until tcp is
    // actually available, as it may not always be during startup/setup
    PptpInitialize(pAdapter);

    NdisMSetInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipPassiveOpen\n")));
}

NDIS_STATUS
TapiOpen(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_OPEN pRequest
    )
{
    PCALL_SESSION pCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiOpen\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiOpen NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    if (!CallIsValidCall(pAdapter, pRequest->ulDeviceID))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiGetDevCaps NDIS_STATUS_TAPI_NODRIVER\n")));
        return NDIS_STATUS_TAPI_NODRIVER;
    }

#if SINGLE_LINE
    NdisAcquireSpinLock(&pAdapter->Lock);

    if (pAdapter->Tapi.Open)
    {
        NdisReleaseSpinLock(&pAdapter->Lock);
        return NDIS_STATUS_TAPI_ALLOCATED;
    }

    pAdapter->Tapi.Open = TRUE;
    pAdapter->Tapi.hTapiLine = pRequest->htLine;

    pRequest->hdLine = TapiIdToLineHandle(pRequest->ulDeviceID);

    NdisReleaseSpinLock(&pAdapter->Lock);
#else
    NdisAcquireSpinLock(&pAdapter->Lock);
    if (pAdapter->pCallArray[DeviceIdToIndex(pAdapter, pRequest->ulDeviceID)]==NULL)
    {
        pAdapter->pCallArray[DeviceIdToIndex(pAdapter, pRequest->ulDeviceID)] = pCall = CallAlloc(pAdapter);
    }
    NdisReleaseSpinLock(&pAdapter->Lock);

    if (!pCall)
    {
        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiOpen NDIS_STATUS_RESOURCES\n")));
        return NDIS_STATUS_RESOURCES;
    }

    NdisAcquireSpinLock(&pCall->Lock);

    if (pCall->State!=STATE_CALL_CLOSED)
    {
        NdisReleaseSpinLock(&pCall->Lock);

        DEBUGMSG(DBG_FUNC, (DTEXT("-TapiOpen NDIS_STATUS_TAPI_ALLOCATED\n")));
        return NDIS_STATUS_TAPI_ALLOCATED;
    }

    pCall->hTapiLine = pRequest->htLine;

    pCall->DeviceId = pRequest->ulDeviceID;

    pRequest->hdLine = TapiIdToLineHandle(pRequest->ulDeviceID);

    pCall->Open = TRUE;

    CallSetState(pCall, STATE_CALL_IDLE, 0, LOCKED);
    NdisReleaseSpinLock(&pCall->Lock);
#endif

    if (!PptpInitialized)
    {
        if (ScheduleWorkItem(TapipPassiveOpen, pAdapter, NULL, 0)==NDIS_STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_FUNC, (DTEXT("-TapiOpen PENDING\n")));
            return NDIS_STATUS_PENDING;
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiOpen\n")));
    return NDIS_STATUS_SUCCESS;
}

VOID
TapipPassiveProviderInitialize(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipPassiveProviderInitialize\n")));

    // We initialize this here because TCP may not be available in MiniportInitialize
    // We don't uninit until MiniportHalt.  CtdiInitialize will just return quietly
    // if it's already initialized, so we can come through here several times
    // safely.

    PptpInitialize(pAdapter); // Ignore the return status.

    NdisMSetInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipPassiveProviderInitialize\n")));
}

NDIS_STATUS
TapiProviderInitialize(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_INITIALIZE pRequest
    )
{
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiProviderInitialize\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiProviderInitialize NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    pAdapter->Tapi.DeviceIdBase = pRequest->ulDeviceIDBase;
#if SINGLE_LINE
    pRequest->ulNumLineDevs = 1;
#else
    pRequest->ulNumLineDevs = pAdapter->Info.Endpoints;
#endif
    DEBUGMSG(DBG_TAPI, (DTEXT("TapiProviderInitialize: ulNumLineDevices=%d\n"), pRequest->ulNumLineDevs));

    pRequest->ulProviderID = (ULONG_PTR)pAdapter;

    Status = ScheduleWorkItem(TapipPassiveProviderInitialize, pAdapter, NULL, 0);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        // Keep the pRequest around until the callback.
        Status = NDIS_STATUS_PENDING;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiProviderInitialize %08x\n"), Status));
    return Status;
}

VOID
TapipPassiveProviderShutdown(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    ULONG i;
    DEBUGMSG(DBG_FUNC|DBG_TAPI, (DTEXT("+TapipPassiveProviderShutdown\n")));

#if SINGLE_LINE
    NdisAcquireSpinLock(&pAdapter->Lock);
    pAdapter->Tapi.Open = FALSE;
    pAdapter->Tapi.hTapiLine = 0;
    NdisReleaseSpinLock(&pAdapter->Lock);
#endif

    for (i=0; i<pAdapter->Info.Endpoints; i++)
    {
//        PCALL_SESSION pCall = CallGetCall(pAdapter, i);
        PCALL_SESSION pCall = pAdapter->pCallArray[i];

        if (IS_CALL(pCall))
        {
            NdisAcquireSpinLock(&pCall->Lock);
            if (IS_CALL(pCall) && pCall->State>STATE_CALL_IDLE && pCall->State<STATE_CALL_CLEANUP)
            {
                pCall->Open = FALSE;
                pCall->hTapiLine = 0;
                CallSetState(pCall, STATE_CALL_CLEANUP, LINEDISCONNECTMODE_NORMAL, LOCKED);
                CallDetachFromAdapter(pCall);
                pCall->Close.Checklist |= (CALL_CLOSE_DROP|CALL_CLOSE_DROP_COMPLETE|CALL_CLOSE_CLOSE_CALL);
                CallCleanup(pCall, LOCKED);
            }
            NdisReleaseSpinLock(&pCall->Lock);

        }
    }

    if (pAdapter->hCtdiDg)
    {
        CtdiClose(pAdapter->hCtdiDg);
        pAdapter->hCtdiDg = NULL;
    }

    if (pAdapter->hCtdiUdp)
    {
        CtdiClose(pAdapter->hCtdiUdp);
        pAdapter->hCtdiUdp = NULL;
    }

    if (pAdapter->hCtdiListen)
    {
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
    }

    NdisMSetInformationComplete(pAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipPassiveProviderShutdown\n")));
}


NDIS_STATUS
TapiProviderShutdown(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_PROVIDER_SHUTDOWN pRequest
    )
{
    NDIS_STATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiProviderShutdown\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiProviderShutdown NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }
    
    Status = ScheduleWorkItem(TapipPassiveProviderShutdown, pAdapter, NULL, 0);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        Status = NDIS_STATUS_PENDING;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-TapiProviderShutdown %08x\n"), Status));
    return Status;
}

VOID
TapipSetDefaultMediaDetectionCallback(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PPPTP_ADAPTER pAdapter = pWorkItem->Context;
    PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest = pWorkItem->pBuffer;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TapipSetDefaultMediaDetectionCallback\n")));

    if (pRequest->ulMediaModes&LINEMEDIAMODE_DIGITALDATA)
    {
        Status = CtlListen(pAdapter);
    }
    else if (pAdapter->hCtdiListen)
    {
        CtdiClose(pAdapter->hCtdiListen);
        pAdapter->hCtdiListen = NULL;
    }

    NdisMSetInformationComplete(pAdapter->hMiniportAdapter, Status);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapipSetDefaultMediaDetectionCallback\n")));
}

NDIS_STATUS
TapiSetDefaultMediaDetection(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION pRequest
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCALL_SESSION pCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiSetDefaultMediaDetection\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

    // Verify the ID
#if SINGLE_LINE
    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }
#else
    pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_NODRIVER\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }
#endif

    // This is the OID to make us start accepting calls.

    DEBUGMSG(DBG_TAPI, (DTEXT("MediaModes: %x\n"), pRequest->ulMediaModes));

    // Schedule a work item so we can issue a CtlListen at passive level.
    Status = ScheduleWorkItem(TapipSetDefaultMediaDetectionCallback,
                              pAdapter,
                              pRequest,
                              0);

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection %08x\n"), Status));
    return NDIS_STATUS_PENDING;
}

NDIS_STATUS
TapiSetStatusMessages(
    IN PPPTP_ADAPTER pAdapter,
    IN OUT PNDIS_TAPI_SET_STATUS_MESSAGES pRequest
    )
{
    PCALL_SESSION pCall;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TapiSetStatusMessages\n")));

    if ( pRequest == NULL || pAdapter == NULL )
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetStatusMessages NDIS_STATUS_TAPI_INVALPARAM\n")));
        return NDIS_STATUS_TAPI_INVALPARAM;
    }

#if SINGLE_LINE
    if (!CallIsValidCall(pAdapter, TapiLineHandleToId(pRequest->hdLine)))
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetDefaultMediaDetection NDIS_STATUS_TAPI_INVALLINEHANDLE\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    pAdapter->Tapi.LineStateMask = pRequest->ulLineStates;
#else
    // Verify the ID
    pCall = CallGetCall(pAdapter, TapiLineHandleToId(pRequest->hdLine));

    if (!pCall)
    {
        DEBUGMSG(DBG_ERROR|DBG_FUNC, (DTEXT("-TapiSetStatusMessages NDIS_STATUS_TAPI_NODRIVER\n")));
        return NDIS_STATUS_TAPI_INVALLINEHANDLE;
    }

    // This OID tells which status messages TAPI is interested in.
    NdisAcquireSpinLock(&pCall->Lock);
    pCall->LineStateMask = pRequest->ulLineStates;
    NdisReleaseSpinLock(&pCall->Lock);
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("-TapiSetStatusMessages\n")));
    return NDIS_STATUS_SUCCESS;
}

// Converts a hexedicimal string to an unsigned long
// How many times to I have to write this function in my life time?
// Returns TRUE if valid hexidecimal string
// Returns FALSE otherwise
// *pResult contains the result
int axtol( LPSTR psz, ULONG *pResult )
{
    ULONG l;
    int i;
    char *p;
    char ch;
    
    *pResult = 0xFFFFFFFF;
    l = 0;
    i = 0;  
    for( p = psz; *p != '\0'; p++){
        i++;                // Count the digits
        l = l << 4;
        ch = *p;
        if( ch >= '0' && ch <= '9' ){
            l = l + (ch - '0');
        }else if( ch >= 'a' && ch <= 'f'){
            l = l + (ch - 'a' + 10 );
        }else if( ch >= 'A' && *p <= 'F'){
            l = l + (ch - 'A' + 10 );
        }else{
            return( FALSE );
        }
    }       
            
    if(i > 8){          // Error on too long a string
        return( FALSE );
    }
    *pResult = l;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\nt\ctdios.h ===
/*******************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*    DESCRIPTION: CTDIOS.H - Commond TDI layer, for NT specific
*
*    AUTHOR: Stan Adermann (StanA)
*
*    DATE:9/29/1998
*
*******************************************************************/

#ifndef CTDIOS_H
#define CTDIOS_H

#include <tdi.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <ntddip.h>
#include <ntddtcp.h>

// Borrow some defines from WINSOCK.
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */

// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)


#endif // CTDIOS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\nt\ctdi.c ===
/*******************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*    DESCRIPTION: CTDI.C - Common TDI layer, for NT
*
*    AUTHOR: Stan Adermann (StanA)
*
*    DATE:9/29/1998
*
*******************************************************************/

/** include files **/

#include "raspptp.h"
#include "bpool.h"

#if VER_PRODUCTVERSION_W >= 0x0500
#define IP_ROUTE_REFCOUNT
#endif
/** local definitions **/

typedef enum {
    CTDI_REF_CONNECT = 0,
    CTDI_REF_ASSOADDR,
    CTDI_REF_SETEVENT,
    CTDI_REF_ADDRREF,
    CTDI_REF_LIST,
    CTDI_REF_REPLENISH,
    CTDI_REF_DISASSO,
    CTDI_REF_DISCONNECT,
    CTDI_REF_RECVDG,
    CTDI_REF_SEND,
    CTDI_REF_SENDDG,
    CTDI_REF_QUERY,
    CTDI_REF_INLISTEN,
    CTDI_REF_INITIAL,
    CTDI_REF_UNKNOWN,
    CTDI_REF_MAX
} CTDI_REF;

#if DBG
#define REFERENCE_OBJECT_EX(o, index)                                                       \
    {                                                                                       \
        NdisInterlockedIncrement(&(o)->arrRef[index]);                                      \
        REFERENCE_OBJECT(o);                                                                \
    }

#define DEREFERENCE_OBJECT_EX(o, index)                                                     \
    {                                                                                       \
        NdisInterlockedDecrement(&(o)->arrRef[index]);                                      \
        DEREFERENCE_OBJECT(o);                                                              \
    }

#define CTDI_F_BUILD_ASSOCADDR                  0x00000001
#define CTDI_F_ASSOCADDR_CALLBACK               0x00000002
#define CTDI_F_ACCEPT                           0x00000004
#define CTDI_F_CONNECTCOMP_CALLBACK             0x00000008

#define CTDI_F_DISCONNECT_CALLBACK              0x00000010
#define CTDI_F_DISCONNECT                       0x00000020
#define CTDI_F_BUILD_DISCONNECT_1               0x00000040
#define CTDI_F_BUILD_DISCONNECT_2               0x00000080

#define CTDI_F_DISCONNECTCOMP_CALLBACK          0x00000100
#define CTDI_F_DISCONNECT_CLEANUP               0x00000200

#define CTDI_F_BUILD_DISASSOC                   0x00001000
#define CTDI_F_DISASSOC_CALLBACK                0x00002000   

#else

#define REFERENCE_OBJECT_EX(o, index)                                                       \
    {                                                                                       \
        REFERENCE_OBJECT(o);                                                                \
    }

#define DEREFERENCE_OBJECT_EX(o, index)                                                     \
    {                                                                                       \
        DEREFERENCE_OBJECT(o);                                                              \
    }
#endif
    

#define CTDI_SIGNATURE      'IDTC'
#define NUM_TCP_LISTEN      5

#define CTDI_UNKNOWN            'NKNU'
#define CTDI_ENDPOINT           'PDNE'
#define CTDI_DATAGRAM           'MRGD'
#define CTDI_LISTEN             'TSIL'
#define CTDI_CONNECTION         'NNOC'

#define PROBE 0

#define IS_CTDI(c) ((c) && (c)->Signature==CTDI_SIGNATURE)

typedef struct CTDI_DATA * PCTDI_DATA;

typedef struct CTDI_DATA {
    LIST_ENTRY                      ListEntry;
    ULONG                           Signature;
    ULONG                           Type;
    REFERENCE_COUNT                 Reference;
    HANDLE                          hFile;
    PFILE_OBJECT                    pFileObject;
    NDIS_SPIN_LOCK                  Lock;
    BOOLEAN                         Closed;
    BOOLEAN                         CloseReqPending;

    CTDI_EVENT_CONNECT_QUERY        ConnectQueryCallback;
    CTDI_EVENT_CONNECT_COMPLETE     ConnectCompleteCallback;
    CTDI_EVENT_DISCONNECT           DisconnectCallback;
    CTDI_EVENT_RECEIVE              RecvCallback;
    PVOID                           RecvContext;
    CTDI_EVENT_RECEIVE_DATAGRAM     RecvDatagramCallback;
    CTDI_EVENT_SEND_COMPLETE        SendCompleteCallback;
    CTDI_EVENT_QUERY_COMPLETE       QueryCompleteCallback;
    CTDI_EVENT_SET_COMPLETE         SetCompleteCallback;

    union {
        struct {
            PVOID                   Context;
            LIST_ENTRY              ConnectList;
            ULONG                   NumConnection;
        } Listen;
        struct {
            PVOID                   Context;
            PCTDI_DATA              LocalEndpoint;
            PVOID                   ConnectInfo;
            TA_IP_ADDRESS           RemoteAddress;
            LIST_ENTRY              ListEntry;
            ULONG                   DisconnectCount;
            union {
                BOOLEAN             Disconnect;
                ULONG_PTR           Padding1;
            };
            union {
                BOOLEAN             Abort;
                ULONG_PTR           Padding2;
            };
        } Connection;
        struct {
            BUFFERPOOL              RxPool;
        } Datagram;
    };

#if DBG
    ULONG                           arrRef[16];
    ULONG                           DbgFlags;
    BOOLEAN                         bRef;
#endif

} CTDI_DATA, *PCTDI_DATA;

#if DBG
#define SET_DBGFLAG(_p, _f)  (_p)->DbgFlags |= (_f)
#else
#define SET_DBGFLAG(_p, _f)
#endif

typedef struct {
    PVOID                           Context;
    CTDI_EVENT_SEND_COMPLETE        pSendCompleteCallback;
} CTDI_SEND_CONTEXT, *PCTDI_SEND_CONTEXT;

typedef struct {
    PVOID                           Context;
    CTDI_EVENT_QUERY_COMPLETE       pQueryCompleteCallback;
} CTDI_QUERY_CONTEXT, *PCTDI_QUERY_CONTEXT;

typedef struct {
    PVOID                           Context;
    PVOID                           DatagramContext;
    CTDI_EVENT_SEND_COMPLETE        pSendCompleteCallback;
    TDI_CONNECTION_INFORMATION      TdiConnectionInfo;
    TA_IP_ADDRESS                   Ip;
} CTDI_SEND_DATAGRAM_CONTEXT, *PCTDI_SEND_DATAGRAM_CONTEXT;

#define BLOCKS_NEEDED_FOR_SIZE(BlockSize, Size) ((Size)/(BlockSize) + ((((Size)/(BlockSize))*(BlockSize) < (Size)) ? 1 : 0 ))

#define NUM_STACKS_FOR_CONTEXT(ContextSize) \
    BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), (ContextSize))

STATIC PVOID __inline
GetContextArea(
    PIRP pIrp,
    ULONG ContextSize
    )
{
#if 0
    ULONG i;
    for (i=0; i<BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize); i++)
        IoSetNextIrpStackLocation(pIrp);
#else
    ULONG NumStacks = BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize);
    pIrp->CurrentLocation -= (CHAR)NumStacks;
    pIrp->Tail.Overlay.CurrentStackLocation -= NumStacks;
#endif
    ASSERT(BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize)<=2);
    return IoGetCurrentIrpStackLocation(pIrp);
}

#define GET_CONTEXT(Irp, Context) (Context*)GetContextArea((Irp), sizeof(Context))

STATIC VOID __inline
ReleaseContextArea(
    PIRP pIrp,
    ULONG ContextSize
    )
{
    ULONG NumStacks = BLOCKS_NEEDED_FOR_SIZE(sizeof(IO_STACK_LOCATION), ContextSize) - 1;
    pIrp->CurrentLocation += (CHAR)NumStacks;
    pIrp->Tail.Overlay.CurrentStackLocation += NumStacks;
}

#define RELEASE_CONTEXT(Irp, Context) ReleaseContextArea((Irp), sizeof(Context))

typedef struct {
    LIST_ENTRY                      ListEntry;
    REFERENCE_COUNT                 Reference;
    ULONG                           IpAddress;
    BOOLEAN                         ExternalRoute;
} CTDI_ROUTE, *PCTDI_ROUTE;

typedef struct {
    LIST_ENTRY                      ListEntry;
    IPNotifyData                    Data;
} CTDI_ROUTE_NOTIFY, *PCTDI_ROUTE_NOTIFY;
/* default settings */

/** external functions **/

/** external data **/

/** public data **/

LIST_ENTRY CtdiList;
LIST_ENTRY CtdiFreeList;
LIST_ENTRY CtdiRouteList;
LIST_ENTRY CtdiRouteNotifyList;
NDIS_SPIN_LOCK  CtdiListLock;
HANDLE hTcp = 0;
PFILE_OBJECT pFileTcp = NULL;
HANDLE hIp = 0;
PFILE_OBJECT pFileIp = NULL;

ULONG CtdiTcpDisconnectTimeout = 30;  // Seconds
ULONG CtdiTcpConnectTimeout = 30;

/** private data **/
BOOLEAN fCtdiInitialized = FALSE;

CSHORT CtdiMdlFlags = 0;

/** private functions **/

NDIS_STATUS
CtdiAddHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    );

NDIS_STATUS
CtdiDeleteHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    );

STATIC VOID
CtdipIpRequestRoutingNotification(
    IN ULONG IpAddress
    );

STATIC VOID
CtdipCloseProtocol(
    HANDLE  hFile,
    PFILE_OBJECT pFileObject
    )
{
    NTSTATUS NtStatus;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipCloseProtocol\n")));

    ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);
    if (pFileObject)
    {
        ObDereferenceObject(pFileObject);
    }
    NtStatus = ZwClose(hFile);
    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("ZwClose(hFile) failed %08x\n"), NtStatus));
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipCloseProtocol\n")));
}

STATIC VOID
CtdipDataFreeWorker(
    IN      PPPTP_WORK_ITEM             pWorkItem
    )
{
    PCTDI_DATA pCtdi;
    NTSTATUS NtStatus;
    PLIST_ENTRY ListEntry;
    BOOLEAN FoundEntry = FALSE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDataFreeWorker\n")));

    while (ListEntry = MyInterlockedRemoveHeadList(&CtdiFreeList, &CtdiListLock))
    {
        pCtdi = CONTAINING_RECORD(ListEntry, CTDI_DATA, ListEntry);
        if (pCtdi->Type==CTDI_DATAGRAM)
        {
            FreeBufferPool(&pCtdi->Datagram.RxPool);
        }

        if (pCtdi->hFile)
        {
            CtdipCloseProtocol(pCtdi->hFile, pCtdi->pFileObject);
            pCtdi->pFileObject = NULL;
            pCtdi->hFile = NULL;
        }

        NdisFreeSpinLock(&pCtdi->Lock);
        pCtdi->Signature = 0;

        if(pCtdi->Type == CTDI_LISTEN)
        {
            if(pCtdi->CloseReqPending)
            {
                // TapiClose pended this request, complete it now
                DEBUGMSG(DBG_TDI, (DTEXT("Complete TapiClose request\n")));
                ASSERT(pgAdapter);
                NdisMSetInformationComplete(pgAdapter->hMiniportAdapter, NDIS_STATUS_SUCCESS);
            }
        }
        MyMemFree(pCtdi, sizeof(CTDI_DATA));
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDataFreeWorker\n")));
}

STATIC VOID
CtdipDataFree(
    PCTDI_DATA pCtdi
    )
// This should only be called by DEREFERENCE_OBJECT
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDataFree\n")));
    NdisAcquireSpinLock(&CtdiListLock);
    RemoveEntryList(&pCtdi->ListEntry);
    InsertTailList(&CtdiFreeList, &pCtdi->ListEntry);

#if DBG
    if(pCtdi->bRef)
    {
        ASSERT(pCtdi->DbgFlags & CTDI_F_DISASSOC_CALLBACK);
    }
#endif

    pCtdi->Signature = 0;
    NdisReleaseSpinLock(&CtdiListLock);
    ScheduleWorkItem(CtdipDataFreeWorker, NULL, NULL, 0);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDataFree\n")));
}

STATIC PCTDI_DATA
CtdipDataAlloc()
{
    PCTDI_DATA pCtdi;

    pCtdi = MyMemAlloc(sizeof(CTDI_DATA), TAG_CTDI_DATA);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDataAlloc\n")));

    if (pCtdi)
    {
        NdisZeroMemory(pCtdi, sizeof(CTDI_DATA));
        pCtdi->Signature = CTDI_SIGNATURE;
        pCtdi->Type = CTDI_UNKNOWN;
        INIT_REFERENCE_OBJECT(pCtdi, CtdipDataFree);  // pair in CtdiClose
        NdisAllocateSpinLock(&pCtdi->Lock);
        MyInterlockedInsertHeadList(&CtdiList, &pCtdi->ListEntry, &CtdiListLock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDataAlloc %08x\n"), pCtdi));
    return pCtdi;
}

STATIC NDIS_STATUS
CtdipIpQueryRouteTable(
    OUT IPRouteEntry **ppQueryBuffer,
    OUT PULONG pQuerySize,
    OUT PULONG pNumRoutes
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    ULONG NumRoutes = 20;
    ULONG QuerySize = 0;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryRoute;
    IPRouteEntry *pQueryBuffer = NULL;
    PIO_STACK_LOCATION IrpSp;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP pIrp;
    KEVENT  Event;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipIpQueryRouteTable\n")));

    if (!fCtdiInitialized)
    {
        Status = NDIS_STATUS_FAILURE;
        goto ciqrtDone;
    }

    // Query TCPfor the current routing table

    QueryRoute.ID.toi_entity.tei_entity = CL_NL_ENTITY;
    QueryRoute.ID.toi_entity.tei_instance = 0;
    QueryRoute.ID.toi_class = INFO_CLASS_PROTOCOL;
    QueryRoute.ID.toi_type = INFO_TYPE_PROVIDER;

    do
    {

        QuerySize = sizeof(IPRouteEntry) * NumRoutes;
        QueryRoute.ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
        NdisZeroMemory(&QueryRoute.Context, CONTEXT_SIZE);

        pQueryBuffer = MyMemAlloc(QuerySize, TAG_CTDI_ROUTE);
        if (!pQueryBuffer)
        {
            // ToDo: free the new pRoute
            Status = NDIS_STATUS_RESOURCES;
            goto ciqrtDone;
        }

        KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

        pIrp = IoBuildDeviceIoControlRequest(IOCTL_TCP_QUERY_INFORMATION_EX,
                                             pFileTcp->DeviceObject,
                                             &QueryRoute,
                                             sizeof(QueryRoute),
                                             pQueryBuffer,
                                             QuerySize,
                                             FALSE,
                                             &Event,
                                             &IoStatusBlock);

        if (!pIrp)
        {
            Status = NDIS_STATUS_RESOURCES;
            goto ciqrtDone;
        }

        IrpSp = IoGetNextIrpStackLocation(pIrp);
        IrpSp->FileObject = pFileTcp;

        Status = IoCallDriver(pFileTcp->DeviceObject, pIrp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            Status = IoStatusBlock.Status;
        }

        if (Status==STATUS_BUFFER_OVERFLOW)
        {
            // We have no idea of the size of the routing table and no good
            // way to find out, so we just loop, increasing our buffer until
            // we win or die
            MyMemFree(pQueryBuffer, QuerySize);
            pQueryBuffer = NULL;
            NumRoutes *= 2;
        }
        else if (Status!=STATUS_SUCCESS)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Failed to query complete routing table %08x\n"), Status));
            goto ciqrtDone;
        }

    } while ( Status==STATUS_BUFFER_OVERFLOW );

    NumRoutes = (ULONG)(IoStatusBlock.Information / sizeof(IPRouteEntry));

ciqrtDone:
    if (pQueryBuffer)
    {
        ASSERT(Status==NDIS_STATUS_SUCCESS);
        *ppQueryBuffer = pQueryBuffer;
        *pNumRoutes = NumRoutes;
        *pQuerySize = QuerySize;
    }
    else
    {
        ASSERT(Status!=NDIS_STATUS_SUCCESS);
        *ppQueryBuffer = NULL;
        *pNumRoutes = 0;
        *pQuerySize = 0;
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipIpQueryRouteTable\n")));
    return Status;
}

NTSTATUS
CtdipRouteChangeEvent(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NDIS_STATUS Status;
    PCTDI_ROUTE_NOTIFY pNotify = pContext;
    ENUM_CONTEXT Enum;
    PLIST_ENTRY pListEntry;
    PCTDI_DATA pCtdi;
    ULONG IpAddress = pNotify->Data.Add;
    KIRQL Irql;
    IPRouteEntry *pQueryBuffer = NULL;
    ULONG NumRoutes = 20;
    ULONG QuerySize = 0;
    ULONG i;
    BOOLEAN RouteWentAway = TRUE;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipRouteChangeEvent\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("Route change irp for %d.%d.%d.%d completed with status %08x\n"),
                       IPADDR(IpAddress), pIrp->IoStatus.Status));

    NdisAcquireSpinLock(&CtdiListLock);
    RemoveEntryList(&pNotify->ListEntry);
    NdisReleaseSpinLock(&CtdiListLock);

    if (!fCtdiInitialized)
    {
        goto crceDone;
    }
    if (pIrp->IoStatus.Status==STATUS_SUCCESS)
    {
        Status = CtdipIpQueryRouteTable(&pQueryBuffer, &QuerySize, &NumRoutes);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            goto crceDone;
        }

        for (i=0; i<NumRoutes; i++)
        {
            if (pQueryBuffer[i].ire_dest == IpAddress &&
                pQueryBuffer[i].ire_proto == IRE_PROTO_NETMGMT &&
                pQueryBuffer[i].ire_mask == 0xFFFFFFFF)
            {
                RouteWentAway = FALSE;
                break;
            }
        }
        MyMemFree(pQueryBuffer, QuerySize);

        if (RouteWentAway)
        {
            InitEnumContext(&Enum);
            while (pListEntry = EnumListEntry(&CtdiList, &Enum, &CtdiListLock))
            {
                pCtdi = CONTAINING_RECORD(pListEntry,
                                          CTDI_DATA,
                                          ListEntry);
                if (IS_CTDI(pCtdi) &&
                    pCtdi->Type==CTDI_CONNECTION &&
                    !pCtdi->Closed &&
                    pCtdi->Connection.RemoteAddress.Address[0].Address[0].in_addr==IpAddress &&
                    pCtdi->DisconnectCallback)
                {
                    DEBUGMSG(DBG_TDI, (DTEXT("Disconnecting Ctdi:%08x due to route change.\n"),
                                       pCtdi));
                    pCtdi->DisconnectCallback(pCtdi->Connection.Context, TRUE);
                }
            }
            EnumComplete(&Enum, &CtdiListLock);
        }
        else
        {
            CtdipIpRequestRoutingNotification(IpAddress);
        }
    }

crceDone:
    RELEASE_CONTEXT(pIrp, CTDI_ROUTE_NOTIFY);
    IoFreeIrp(pIrp);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipRouteChangeEvent\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC VOID
CtdipIpRequestRoutingNotification(
    IN ULONG IpAddress
    )
{
    PLIST_ENTRY pListEntry;
    PIRP pIrp = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PIO_STACK_LOCATION IrpSp;
    PCTDI_ROUTE_NOTIFY pNotify = NULL;
    BOOLEAN NotifyActive = FALSE;
    BOOLEAN LockHeld;

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipIpRequestRoutingNotification\n")));

    if (!fCtdiInitialized)
    {
        return;
    }
    NdisAcquireSpinLock(&CtdiListLock);
    LockHeld = TRUE;
    for (pListEntry = CtdiRouteNotifyList.Flink;
         pListEntry!=&CtdiRouteNotifyList;
         pListEntry = pListEntry->Flink)
    {
        pNotify = CONTAINING_RECORD(pListEntry,
                                   CTDI_ROUTE_NOTIFY,
                                   ListEntry);

        if (IpAddress==pNotify->Data.Add)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Routing notification already active on %d.%d.%d.%d\n"),
                               IPADDR(IpAddress)));
            NotifyActive = TRUE;
        }
    }
    if (!NotifyActive)
    {
        DEBUGMSG(DBG_TDI, (DTEXT("Requesting routing notification on %d.%d.%d.%d\n"),
                           IPADDR(IpAddress)));

        pIrp = IoAllocateIrp((CCHAR)(pFileIp->DeviceObject->StackSize +
                                     NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_ROUTE_NOTIFY))),
                             FALSE);

        if (!pIrp)
        {
            Status = NDIS_STATUS_RESOURCES;
            goto crrnDone;
        }

        pNotify = GET_CONTEXT(pIrp, CTDI_ROUTE_NOTIFY);

        //
        // Setup IRP stack location to forward IRP to IP
        // Must be METHOD_BUFFERED or we are not setting it up correctly
        //

        ASSERT ( (IOCTL_IP_RTCHANGE_NOTIFY_REQUEST & 0x03)==METHOD_BUFFERED );
        pIrp->AssociatedIrp.SystemBuffer = &pNotify->Data;

        IrpSp = IoGetNextIrpStackLocation(pIrp);
        IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        IrpSp->MinorFunction = 0;
        IrpSp->Flags = 0;
        IrpSp->Control = 0;
        IrpSp->FileObject = pFileIp;
        IrpSp->DeviceObject = pFileIp->DeviceObject;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(IPNotifyData);
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_IP_RTCHANGE_NOTIFY_REQUEST;
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        IoSetCompletionRoutine(pIrp, CtdipRouteChangeEvent, pNotify, TRUE, TRUE, TRUE);

        pNotify->Data.Version = 0;
        pNotify->Data.Add = IpAddress;

        InsertTailList(&CtdiRouteNotifyList, &pNotify->ListEntry);
        LockHeld = FALSE;
        NdisReleaseSpinLock(&CtdiListLock);
        (void)IoCallDriver(pFileIp->DeviceObject, pIrp);
        pIrp = NULL;
    }

crrnDone:
    if (LockHeld)
    {
        NdisReleaseSpinLock(&CtdiListLock);
    }
    if (pIrp)
    {
        IoFreeIrp(pIrp);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipIpRequestRoutingNotification\n")));
}

STATIC VOID
CtdipScheduleAddHostRoute(
    PPPTP_WORK_ITEM pWorkItem
    )
{
    PCTDI_DATA pCtdi = pWorkItem->Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipScheduleAddHostRoute\n")));

    CtdiAddHostRoute(&pCtdi->Connection.RemoteAddress);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipScheduleAddHostRoute\n")));
}

STATIC NTSTATUS
CtdipConnectCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    NDIS_STATUS NdisStatus;

    PTDI_CONNECTION_INFORMATION pRequestInfo = NULL; 
    PTA_IP_ADDRESS pRequestAddress = NULL; 
    PTDI_CONNECTION_INFORMATION pReturnInfo = NULL; 
    PTA_IP_ADDRESS pReturnAddress = NULL; 
    PBOOLEAN pInboundFlag = NULL; 
    
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipConnectCompleteCallback %08x\n"), pIrp->IoStatus.Status));

    SET_DBGFLAG(pCtdi, CTDI_F_CONNECTCOMP_CALLBACK);

    pRequestInfo = pCtdi->Connection.ConnectInfo;

    pRequestAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pRequestInfo + 1) + sizeof(PVOID));
    
    (ULONG_PTR)pRequestAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo = 
        (PTDI_CONNECTION_INFORMATION)
        ((PUCHAR)(pRequestAddress + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnInfo &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pReturnInfo + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pInboundFlag = (PBOOLEAN)(pReturnAddress + 1);

    // Connection complete.  Tell the client.
    if (pIrp->IoStatus.Status==STATUS_SUCCESS)
    {
        pCtdi->Connection.RemoteAddress = *pReturnAddress;
        ScheduleWorkItem(CtdipScheduleAddHostRoute, pCtdi, NULL, 0);

        if (*pInboundFlag)
        {
            NdisInterlockedIncrement(&Counters.InboundConnectComplete);
        }
        else
        {
            NdisInterlockedIncrement(&Counters.OutboundConnectComplete);
        }
    }

    MyMemFree(pRequestInfo,
             2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS)) + 
             sizeof(BOOLEAN) + 3*sizeof(PVOID) );
    
    pCtdi->Connection.ConnectInfo = NULL;

    if (pCtdi->ConnectCompleteCallback)
    {
        // Report status and give them the new handle if we succeeded.
        NdisStatus = pCtdi->ConnectCompleteCallback(pCtdi->Connection.Context,
                                                    (pIrp->IoStatus.Status ? 0 : (HANDLE)pCtdi),
                                                    pIrp->IoStatus.Status);
        if (NdisStatus!=NDIS_STATUS_SUCCESS || pIrp->IoStatus.Status!=STATUS_SUCCESS)
        {
            CtdiDisconnect(pCtdi, FALSE);
            CtdiClose(pCtdi);
        }
    }
    else
    {
        // We assume that if there's no ConnectCompleteCallback, that this is
        // probably a listen, we've already given the handle for this, and
        // we don't want to close it ourselves.  Instead, we'll do a disconnect
        // indication and allow the upper layer to clean up.
        if (pIrp->IoStatus.Status!=STATUS_SUCCESS &&
            !pCtdi->Closed &&
            pCtdi->DisconnectCallback)
        {
            pCtdi->DisconnectCallback(pCtdi->Connection.Context, TRUE);
        }
    }

    IoFreeIrp(pIrp);

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_CONNECT);  // Pair in CtdiConnect

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipConnectCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipAssociateAddressCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipAssociateAddressCallback\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("TDI_ASSOCIATE_ADDRESS Sts:%08x\n"), pIrp->IoStatus.Status));

    // ToDo: What cleanup do we need to do if this fails?

    SET_DBGFLAG(pConnect, CTDI_F_ASSOCADDR_CALLBACK);
    //ASSERT(NT_SUCCESS(pIrp->IoStatus.Status));

    IoFreeIrp(pIrp);
    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_ASSOADDR);  // Pair in CtdipAddListenConnection and also in CtdiConnect
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipAssociateAddressCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

// This function expects the CtdiListLock to be held.
PCTDI_ROUTE
CtdipFindRoute(
    ULONG           IpAddress
    )
{
    PCTDI_ROUTE pRoute = NULL;
    PLIST_ENTRY pListEntry;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipFindRoute\n")));

    for (pListEntry = CtdiRouteList.Flink;
         pListEntry != &CtdiRouteList;
         pListEntry = pListEntry->Flink)
    {
        pRoute = CONTAINING_RECORD(pListEntry,
                                   CTDI_ROUTE,
                                   ListEntry);
        if (pRoute->IpAddress==IpAddress)
        {
            // Found the route, return it.
            goto cfrDone;
        }
    }
    pRoute = NULL;

cfrDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipFindRoute %08x\n"), pRoute));
    return pRoute;
}

STATIC NTSTATUS
CtdipSetEventCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSetEventCallback\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("TDI_SET_EVENT_HANDLER Sts:%08x\n"), pIrp->IoStatus.Status));

    // ToDo: What cleanup do we need to do if this fails?

    IoFreeIrp(pIrp);
    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_SETEVENT);  // Pair in CtdipSetEventHandler
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipSetEventCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NDIS_STATUS
CtdipSetEventHandler(
    IN      PCTDI_DATA                  pCtdi,
    IN      ULONG                       ulEventType,
    IN      PVOID                       pEventHandler
    )
{
    PIRP pIrp;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSetEventHandler\n")));
    if (!IS_CTDI(pCtdi))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %08x\n"), pCtdi));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto cpsehDone;
    }

    // This should be the Address context ToDo: is this always true?

    pIrp = IoAllocateIrp(pCtdi->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto cpsehDone;
    }

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SETEVENT);  // Pair in CtdipSetEventCallback
    TdiBuildSetEventHandler(pIrp,
                            pCtdi->pFileObject->DeviceObject,
                            pCtdi->pFileObject,
                            CtdipSetEventCallback,
                            pCtdi,
                            ulEventType,
                            pEventHandler,
                            pCtdi);

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_SET_EVENT_HANDLER\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    ReturnStatus = STATUS_SUCCESS;

cpsehDone:
    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdipSetEventHandler\n")));
    return ReturnStatus;
}

STATIC NDIS_STATUS
CtdipAddListenConnection(
    IN      PCTDI_DATA                  pEndpoint
    )
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP pIrp;
    UNICODE_STRING DeviceName;

    UCHAR EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                   TDI_CONNECTION_CONTEXT_LENGTH +
                   sizeof(PVOID)];
    PFILE_FULL_EA_INFORMATION pEa = (PFILE_FULL_EA_INFORMATION)EaBuffer;
    PVOID UNALIGNED *ppContext;

    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    PCTDI_DATA pConnect = CtdipDataAlloc();

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipAddListenConnection\n")));


    if (!pConnect)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto calcDone;
    }

    pConnect->Type = CTDI_CONNECTION;
    pConnect->Connection.LocalEndpoint = pEndpoint;

    pConnect->RecvCallback = pEndpoint->RecvCallback;
    pConnect->DisconnectCallback = pEndpoint->DisconnectCallback;

    DeviceName.Length = sizeof(DD_TCP_DEVICE_NAME) - sizeof(WCHAR);
    DeviceName.Buffer = DD_TCP_DEVICE_NAME;

    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NdisZeroMemory(pEa, sizeof(EaBuffer));
    pEa->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    pEa->EaValueLength = sizeof(PVOID);
    NdisMoveMemory(pEa->EaName, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH);

    ppContext = (PVOID UNALIGNED*)
        (pEa->EaName + TDI_CONNECTION_CONTEXT_LENGTH + 1);

    *ppContext = pConnect;

    NdisZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    NtStatus =
        ZwCreateFile(&pConnect->hFile,                 /* FileHandle */
                     FILE_READ_DATA | FILE_WRITE_DATA, /* Desired Access */
                     &ObjectAttributes,                /* Object Attributes */
                     &IoStatusBlock,                   /* IO Status Block */
                     NULL,                             /* Allocation Size */
                     FILE_ATTRIBUTE_NORMAL,            /* File Attributes */
                     0,                                /* Share Access */
                     FILE_OPEN,                        /* Create Disposition */
                     0,                                /* Create Options */
                     pEa,                              /* EaBuffer */
                     sizeof(EaBuffer)                  /* EaLength */
                     );

    if (NtStatus!=STATUS_SUCCESS)
    {
        ReturnStatus = NtStatus;
        goto calcDone;
    }

    // Convert the address file handle to a FILE_OBJECT

    NtStatus =
        ObReferenceObjectByHandle(pConnect->hFile,            /* Handle */
                                  0,                          /* DesiredAccess */
                                  NULL,                       /* ObjectType */
                                  KernelMode,                 /* AccessMode */
                                  &pConnect->pFileObject,     /* Object */
                                  NULL                        /* HandleInfo */
                                  );


    if (NtStatus != STATUS_SUCCESS)
    {
        ReturnStatus = NtStatus;
        goto calcDone;
    }

    // Make an irp to associate the endpoint and connection.
    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto calcDone;
    }

    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_ASSOADDR);  // Pair in CtdipAssociateAddressCallback
    TdiBuildAssociateAddress(pIrp,
                             pConnect->pFileObject->DeviceObject,
                             pConnect->pFileObject,
                             CtdipAssociateAddressCallback,
                             pConnect,
                             pEndpoint->hFile);

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_ASSOCIATE_ADDRESS\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);

    // Associate address creates a reference from the connection to the endpoint.
    REFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_ADDRREF);  // Pair in CtdipDisassociateAddressCallback

    SET_DBGFLAG(pConnect, CTDI_F_BUILD_ASSOCADDR);  
#if DBG
    pConnect->bRef = TRUE;  
#endif

    // It's ready.  Put it on the list.
    REFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_LIST);  //Pair in CtdipConnectCallback
    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_LIST);   //Pair in CtdipConnectCallback
    MyInterlockedInsertTailList(&pEndpoint->Listen.ConnectList, &pConnect->Connection.ListEntry, &pEndpoint->Lock);

    NdisInterlockedIncrement(&pEndpoint->Listen.NumConnection);
    // This pConnect should now be an active TCP listen.
calcDone:
    if (!NT_SUCCESS(ReturnStatus))
    {
        if (pConnect)
        {
            // Any failure means no associate address.  don't disassociate.
            // It also means it's not attached to the listen.
            CtdiClose(pConnect);
        }
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdipAddListenConnection %08x\n"), ReturnStatus));
    return ReturnStatus;
}

STATIC VOID
CtdipReplenishListens(
    IN      PPPTP_WORK_ITEM             pWorkItem
    )
{
    PCTDI_DATA pEndpoint = pWorkItem->Context;
    ULONG i;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReplenishListens\n")));

    for (i=pEndpoint->Listen.NumConnection; i<NUM_TCP_LISTEN; i++)
    {
        CtdipAddListenConnection(pEndpoint);
    }

    DEREFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_REPLENISH); // Pair in CtdipConnectCallback
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReplenishListens\n")));
}

STATIC NTSTATUS
CtdipConnectCallback(
   IN PVOID TdiEventContext,
   IN LONG RemoteAddressLength,
   IN PVOID RemoteAddress,
   IN LONG UserDataLength,
   IN PVOID UserData,
   IN LONG OptionsLength,
   IN PVOID Options,
   OUT CONNECTION_CONTEXT *ConnectionContext,
   OUT PIRP *AcceptIrp
   )
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    NDIS_STATUS NdisStatus;
    PTRANSPORT_ADDRESS pAddress = (PTRANSPORT_ADDRESS)RemoteAddress;
    PCTDI_DATA pCtdi = (PCTDI_DATA)TdiEventContext;
    PCTDI_DATA pConnect = NULL;
    UINT i;
    PIRP pIrp = NULL;
    PTDI_CONNECTION_INFORMATION pRequestInfo = NULL;
    PTDI_CONNECTION_INFORMATION pReturnInfo = NULL;
    PTA_IP_ADDRESS pRemoteAddress;
    PVOID pNewContext;
    PLIST_ENTRY pListEntry = NULL;
    PBOOLEAN pInboundFlag;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipConnectCallback\n")));

    NdisInterlockedIncrement(&Counters.InboundConnectAttempts);

    if (RemoteAddressLength<sizeof(TA_IP_ADDRESS) ||
        !RemoteAddress ||
        pCtdi->Closed)
    {
        Status = STATUS_CONNECTION_REFUSED;
        goto cccDone;
    }

    ASSERT(UserDataLength==0);
    ASSERT(OptionsLength==0);


    // Do all the allocation we'll need at one shot.

    pIrp = IoAllocateIrp(pCtdi->pFileObject->DeviceObject->StackSize, FALSE);

    // No sign saying we can't allocate the request info, return info and address buffers
    // in one shot.
    pRequestInfo = MyMemAlloc(2*(sizeof(TDI_CONNECTION_INFORMATION)+
                                 sizeof(TA_IP_ADDRESS)) +
                              3*sizeof(PVOID) + sizeof(BOOLEAN),
                              TAG_CTDI_CONNECT_INFO);
    if (!pIrp || !pRequestInfo)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cccDone;
    }

    pListEntry = MyInterlockedRemoveHeadList(&pCtdi->Listen.ConnectList,
                                             &pCtdi->Lock);
    if (!pListEntry)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("No listen connections available.\n")));
        Status = STATUS_CONNECTION_REFUSED;

        REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_REPLENISH); // pair in CtdipReplenishListens
        if (ScheduleWorkItem(CtdipReplenishListens, pCtdi, NULL, 0)!=NDIS_STATUS_SUCCESS)
        {
            DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_REPLENISH); // pair for above if Schedule fails
        }
        goto cccDone;
    }
    NdisInterlockedDecrement(&pCtdi->Listen.NumConnection);

    pConnect = CONTAINING_RECORD(pListEntry,
                                 CTDI_DATA,
                                 Connection.ListEntry);

    // We have a double reference when an object is on the list of another object,
    // and we want to release them both when we remove the item from the list,
    // but in this case we also want to take a reference on the connection object,
    // so one of them cancels out.
    //REFERENCE_OBJECT(pConnect);  // Pair in CtdiDisconnect
    //DEREFERENCE_OBJECT(pConnect);   // Pair in CtdipAddListenConnection
    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_LIST);      // Pair in CtdipAddListenConnection

    if (!pCtdi->ConnectQueryCallback || pCtdi->Closed)
    {
        Status = STATUS_CONNECTION_REFUSED;
        goto cccDone;
    }
    NdisStatus = pCtdi->ConnectQueryCallback(pCtdi->Listen.Context,
                                             pAddress,
                                             pConnect,
                                             &pNewContext);
    if (NdisStatus!=NDIS_STATUS_SUCCESS)
    {
        Status = STATUS_CONNECTION_REFUSED;
        goto cccDone;
    }


    // We've got the go-ahead to accept this connection, at the TCP level.

    pConnect->Connection.ConnectInfo = pRequestInfo;
    pConnect->Connection.Context = pNewContext;
    pConnect->Connection.RemoteAddress = *(PTA_IP_ADDRESS)pAddress;

    NdisZeroMemory(pRequestInfo,
                   2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS))
                   + sizeof(BOOLEAN) + 3*sizeof(PVOID));

    pRequestInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress =
        (PTA_IP_ADDRESS)((PUCHAR)(pRequestInfo + 1) + sizeof(PVOID));
    
    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pRequestInfo->RemoteAddress = pRemoteAddress;

    *pRemoteAddress = *(PTA_IP_ADDRESS)pAddress;

    pReturnInfo = 
        (PTDI_CONNECTION_INFORMATION)
        ((PUCHAR)(pRemoteAddress + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnInfo &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pReturnInfo + 1) + sizeof(PVOID));

    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddress = pRemoteAddress;

    pInboundFlag = (PBOOLEAN)(pRemoteAddress + 1);
    *pInboundFlag = TRUE;

    // ToDo: the old PPTP driver filled in the ReturnInfo remote address.
    // 
    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    SET_DBGFLAG(pConnect, CTDI_F_ACCEPT);

    TdiBuildAccept(pIrp,
                   pConnect->pFileObject->DeviceObject,
                   pConnect->pFileObject,
                   CtdipConnectCompleteCallback,
                   pConnect,                // Context
                   pRequestInfo,
                   pReturnInfo);

    IoSetNextIrpStackLocation(pIrp);

    *ConnectionContext = pConnect;
    *AcceptIrp = pIrp;

    REFERENCE_OBJECT_EX(pConnect->Connection.LocalEndpoint, CTDI_REF_REPLENISH); // pair in CtdipReplenishListens
    if (ScheduleWorkItem(CtdipReplenishListens, pConnect->Connection.LocalEndpoint, NULL, 0)!=NDIS_STATUS_SUCCESS)
    {
        DEREFERENCE_OBJECT_EX(pConnect->Connection.LocalEndpoint, CTDI_REF_REPLENISH); // pair for above if Schedule fails
    }

cccDone:
    if (Status!=STATUS_MORE_PROCESSING_REQUIRED)
    {
        // We lose.  Clean up.
        if (pConnect)
        {
            // We haven't used this connection, so it is still valid.  return it
            // to the list, and reapply the references.
            REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_LIST);
            //REFERENCE_OBJECT(pConnect);
            MyInterlockedInsertTailList(&pCtdi->Listen.ConnectList,
                                        &pConnect->Connection.ListEntry,
                                        &pCtdi->Lock);
            NdisInterlockedIncrement(&pCtdi->Listen.NumConnection);
        }
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
        if (pRequestInfo)
        {
            MyMemFree(pRequestInfo,
                      2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS)));
        }
    }


    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdipConnectCallback %08x\n"), Status));
    return Status;
}

STATIC NTSTATUS
CtdipDisassociateAddressCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    PCTDI_DATA pEndpoint;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisassociateAddressCallback\n")));

    DEBUGMSG(DBG_TDI, (DTEXT("TDI_DISASSOCIATE_ADDRESS Sts:%08x\n"), pIrp->IoStatus.Status));

    // ToDo: What cleanup do we need to do if this fails?
    SET_DBGFLAG(pConnect, CTDI_F_DISASSOC_CALLBACK);

    IoFreeIrp(pIrp);
    pEndpoint = pConnect->Connection.LocalEndpoint;
    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISASSO);  // Pair in CtdipDisconnectCleanup
    DEREFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_ADDRREF);  // Pair in CtdipAddListenConnection and CtdiConnect
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisassociateAddressCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC VOID
CtdipDisconnectCleanup(
    IN PPPTP_WORK_ITEM pWorkItem
    )
{
    PCTDI_DATA pConnect = pWorkItem->Context;
    PIRP pIrp = NULL;
    NTSTATUS Status;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisconnectCleanup\n")));

    SET_DBGFLAG(pConnect, CTDI_F_DISCONNECT_CLEANUP);

    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        goto cdaDone;
    }

    // Normally we would reference pConnect for making an irp, but we already
    // have one for this work item, & we'll just keep it.

    SET_DBGFLAG(pConnect, CTDI_F_BUILD_DISASSOC);

    TdiBuildDisassociateAddress(pIrp,
                                pConnect->pFileObject->DeviceObject,
                                pConnect->pFileObject,
                                CtdipDisassociateAddressCallback,
                                pConnect);
    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_DISASSOCIATE_ADDRESS\n")));
    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISASSO);

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);

    CtdiDeleteHostRoute(&pConnect->Connection.RemoteAddress);

    if (!pConnect->Closed && pConnect->DisconnectCallback)
    {
        pConnect->DisconnectCallback(pConnect->Connection.Context,
                                     pConnect->Connection.Abort);
    }

    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair CtdipDisconnectCallback and CtdiDisconnect

cdaDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisconnectCleanup\n")));
}

STATIC NTSTATUS
CtdipDisconnectCompleteCallback(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PVOID Context
    )
{
    PCTDI_DATA pConnect = Context;
    PIO_STACK_LOCATION pIrpSp = IoGetNextIrpStackLocation(pIrp);
    PTDI_REQUEST_KERNEL pRequest = (PTDI_REQUEST_KERNEL)&pIrpSp->Parameters;
    BOOLEAN CleanupNow = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisconnectCompleteCallback %08x\n"), pIrp->IoStatus.Status));

    if (pRequest->RequestConnectionInformation)
    {
        // We don't do anything with this info yet
    }
    if (pRequest->ReturnConnectionInformation)
    {
        // We don't do anything with this info yet
    }
    if (pRequest->RequestSpecific)
    {
        // Allocated as part of irp, don't free it.
    }

    if (IS_CTDI(pConnect))
    {

        SET_DBGFLAG(pConnect, CTDI_F_DISCONNECTCOMP_CALLBACK);

        // Possible to do a release AND and abort, so we'll get called here twice.
        // We only want to cleanup once.
        NdisAcquireSpinLock(&pConnect->Lock);
        CleanupNow = ((--pConnect->Connection.DisconnectCount)==0) ? TRUE : FALSE;
        NdisReleaseSpinLock(&pConnect->Lock);

        if (!CleanupNow ||
            ScheduleWorkItem(CtdipDisconnectCleanup, pConnect, NULL, 0)!=NDIS_STATUS_SUCCESS)
        {
            DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair CtdipDisconnectCallback and CtdiDisconnect
        }
    }

    IoFreeIrp(pIrp);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisconnectCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipDisconnectCallback(
   IN PVOID TdiEventContext,
   IN CONNECTION_CONTEXT ConnectionContext,
   IN LONG DisconnectDataLength,
   IN PVOID DisconnectData,
   IN LONG DisconnectInformationLength,
   IN PVOID DisconnectInformation,
   IN ULONG DisconnectFlags
   )
{
    PCTDI_DATA pConnect = (PCTDI_DATA)ConnectionContext;
    PCTDI_DATA pEndpoint;
    PIRP pIrp = NULL;
    PTIME pTimeout = NULL;
    PTDI_CONNECTION_INFORMATION pConnectInfo = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDisconnectCallback\n")));

    SET_DBGFLAG(pConnect, CTDI_F_DISCONNECT_CALLBACK);

    if (DisconnectFlags==0)
    {
        DisconnectFlags = TDI_DISCONNECT_ABORT;
    }
    ASSERT(DisconnectFlags==TDI_DISCONNECT_RELEASE || DisconnectFlags==TDI_DISCONNECT_ABORT);

    NdisAcquireSpinLock(&pConnect->Lock);
    if (DisconnectFlags==TDI_DISCONNECT_ABORT)
    {
        BOOLEAN CleanupNow;

        pConnect->Connection.Disconnect = TRUE;
        pConnect->Connection.Abort = TRUE;
        CleanupNow = (pConnect->Connection.DisconnectCount==0) ? TRUE : FALSE;
        REFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair in
        NdisReleaseSpinLock(&pConnect->Lock);
        if (IS_CTDI(pConnect) && CleanupNow)
        {
            if (ScheduleWorkItem(CtdipDisconnectCleanup, pConnect, NULL, 0)!=NDIS_STATUS_SUCCESS)
            {
                // Schedule failed, deref now
                DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair above
            }
        }
        else
        {
            DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair above
        }
    }
    else
    {
        if (pConnect->Connection.Disconnect)
        {
            // We've already disconnected.  Ignore.
            NdisReleaseSpinLock(&pConnect->Lock);
        }
        else
        {
            pConnect->Connection.Disconnect = TRUE;
            pConnect->Connection.DisconnectCount++;

            REFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair in CtdipDisconnectCompleteCallback
            NdisReleaseSpinLock(&pConnect->Lock);

            pIrp = IoAllocateIrp((CCHAR)(pConnect->pFileObject->DeviceObject->StackSize +
                                         NUM_STACKS_FOR_CONTEXT(sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION))),
                                 FALSE);

            if (!pIrp)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_DISCONNECT);  // Pair above
                goto cdcDone;
            }

            pTimeout = (PTIME)GetContextArea(pIrp, sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION));
            pConnectInfo = (PTDI_CONNECTION_INFORMATION)(pTimeout + 1);

            pTimeout->LowPart = CtdiTcpDisconnectTimeout * -10000000L;
            pTimeout->HighPart = (pTimeout->LowPart) ? -1 : 0;

            // Responding to a controlled disconnect, we don't provide
            // TDI_CONNECTION_INFORMATION, but we request it from the peer.
            
            SET_DBGFLAG(pConnect, CTDI_F_BUILD_DISCONNECT_1);

            TdiBuildDisconnect(pIrp,
                               pConnect->pFileObject->DeviceObject,
                               pConnect->pFileObject,
                               CtdipDisconnectCompleteCallback,
                               pConnect,
                               pTimeout,
                               TDI_DISCONNECT_RELEASE,
                               NULL,
                               pConnectInfo);


            // Completion handler always called, don't care on return value.
            (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);
        }
    }

cdcDone:
    if (!NT_SUCCESS(Status))
    {
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDisconnectCallback\n")));
    return STATUS_SUCCESS;
}

STATIC NTSTATUS
CtdipOpenProtocol(
    IN      PUNICODE_STRING             pDeviceName,
    IN      PTRANSPORT_ADDRESS          pAddress,
    OUT     PHANDLE                     phFile,
    OUT     PFILE_OBJECT               *ppFileObject
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UCHAR EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                   TDI_TRANSPORT_ADDRESS_LENGTH +
                   sizeof(TA_IP_ADDRESS)];
    PFILE_FULL_EA_INFORMATION pEa = (PFILE_FULL_EA_INFORMATION)EaBuffer;
    TA_IP_ADDRESS UNALIGNED *pEaTaIp;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipOpenProtocol %wZ\n"), pDeviceName));

    *phFile = 0;
    *ppFileObject = NULL;

    InitializeObjectAttributes(&ObjectAttributes,
                               pDeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NdisZeroMemory(pEa, sizeof(EaBuffer));
    pEa->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    pEa->EaValueLength = sizeof(TA_IP_ADDRESS);
    NdisMoveMemory(pEa->EaName, TdiTransportAddress, TDI_TRANSPORT_ADDRESS_LENGTH);

    pEaTaIp = (TA_IP_ADDRESS UNALIGNED*)
        (pEa->EaName + TDI_TRANSPORT_ADDRESS_LENGTH + 1);

    *pEaTaIp = *(PTA_IP_ADDRESS)pAddress;

    DEBUGMSG(DBG_TDI, (DTEXT("Endpoint: sin_port = %Xh in_addr = %Xh\n"),
        pEaTaIp->Address[0].Address[0].sin_port,
        pEaTaIp->Address[0].Address[0].in_addr));

    NdisZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    NtStatus =
        ZwCreateFile(
        phFile,                           /* FileHandle */
        FILE_READ_DATA | FILE_WRITE_DATA, /* Desired Access */
        &ObjectAttributes,                /* Object Attributes */
        &IoStatusBlock,                   /* IO Status Block */
        NULL,                             /* Allocation Size */
        FILE_ATTRIBUTE_NORMAL,            /* File Attributes */
        0,                                /* Share Access */
        FILE_OPEN,                        /* Create Disposition */
        0,                                /* Create Options */
        pEa,                              /* EaBuffer */
        sizeof(EaBuffer)                  /* EaLength */
        );

    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("ZwCreateFile failed %08x\n"), NtStatus));
        goto copDone;
    }

    // Convert the address file handle to a FILE_OBJECT

    NtStatus =
        ObReferenceObjectByHandle(
            *phFile,                    /* Handle */
            0,                          /* DesiredAccess */
            NULL,                       /* ObjectType */
            KernelMode,                 /* AccessMode */
            ppFileObject,               /* Object */
            NULL                        /* HandleInfo */
            );

copDone:
    if (NtStatus!=STATUS_SUCCESS && *phFile)
    {
        ZwClose(*phFile);
        *phFile = 0;
        *ppFileObject = NULL;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(NtStatus), (DTEXT("-CtdipOpenProtocol %08x\n"), NtStatus));
    return NtStatus;
}

STATIC NTSTATUS
CtdipReceiveCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    PUCHAR pData;
    ULONG Length;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveCompleteCallback\n")));

    pData = MmGetMdlVirtualAddress(pIrp->MdlAddress);
    Length = MmGetMdlByteCount(pIrp->MdlAddress);
    if (pIrp->IoStatus.Status==STATUS_SUCCESS && pCtdi->RecvCallback && !pCtdi->Closed)
    {
        pCtdi->RecvCallback(pCtdi->Connection.Context, pData, Length);
    }

#if PROBE
    MmUnlockPages(pIrp->MdlAddress);
#endif
    IoFreeMdl(pIrp->MdlAddress);
    MyMemFree(pData, Length);
    IoFreeIrp(pIrp);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReceiveCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipReceiveCallback(
   IN PVOID TdiEventContext,
   IN CONNECTION_CONTEXT ConnectionContext,
   IN ULONG ReceiveFlags,
   IN ULONG BytesIndicated,
   IN ULONG BytesAvailable,
   OUT ULONG *BytesTaken,
   IN PVOID Tsdu,
   OUT PIRP *IoRequestPacket
   )
{
    PCTDI_DATA pCtdi = ConnectionContext;
    NTSTATUS NtStatus = STATUS_DATA_NOT_ACCEPTED;
    NDIS_STATUS Status;
    PUCHAR pBuffer;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveCallback\n")));

    if (pCtdi->RecvCallback && !pCtdi->Closed)
    {
        if (ReceiveFlags&TDI_RECEIVE_ENTIRE_MESSAGE ||
            BytesIndicated==BytesAvailable)
        {
            Status = pCtdi->RecvCallback(pCtdi->Connection.Context,
                                         Tsdu,
                                         BytesIndicated);
            // Data must be used in this call
            ASSERT(Status==NDIS_STATUS_SUCCESS);
            NtStatus = STATUS_SUCCESS;
            *BytesTaken = BytesIndicated;
        }
        else
        {
            // We need an irp to receive all the data.
            PIRP pIrp = IoAllocateIrp(pCtdi->pFileObject->DeviceObject->StackSize, FALSE);
            PUCHAR pBuffer = MyMemAlloc(BytesAvailable, TAG_CTDI_MESSAGE);
            PMDL pMdl = NULL;

            if (pBuffer && pIrp)
            {
                pMdl = IoAllocateMdl(pBuffer, BytesAvailable, FALSE, FALSE, pIrp);
                if (pMdl)
                {
#if PROBE
                    __try
                    {
                        MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        IoFreeMdl(pMdl);
                        pMdl = NULL;
                    }
#else
                    MmBuildMdlForNonPagedPool(pMdl);
#endif
                }
            }

            if (pMdl)
            {
                TdiBuildReceive(pIrp,
                                pCtdi->pFileObject->DeviceObject,
                                pCtdi->pFileObject,
                                CtdipReceiveCompleteCallback,
                                pCtdi,
                                pMdl,
                                0,
                                BytesAvailable);

                // We're not calling IoCallDriver, so we need to set the proper
                // stack location.
                IoSetNextIrpStackLocation(pIrp);

                *IoRequestPacket = pIrp;

                *BytesTaken = 0;
                NtStatus = STATUS_MORE_PROCESSING_REQUIRED;
            }
            else
            {
                // Some alloc failure occurred, free everything.
                NtStatus = STATUS_DATA_NOT_ACCEPTED;
                *BytesTaken = 0;
                if (pBuffer)
                {
                    MyMemFree(pBuffer, BytesAvailable);
                }
                if (pIrp)
                {
                    IoFreeIrp(pIrp);
                }
            }
        }
    }


    DEBUGMSG(DBG_FUNC|DBG_ERR(NtStatus), (DTEXT("-CtdipReceiveCallback %08x\n"), NtStatus));
    return NtStatus;
}

typedef struct {
    TA_IP_ADDRESS       SourceAddress;
    ULONG               Length;
    PVOID               pBuffer;
} RECV_DATAGRAM_CONTEXT, *PRECV_DATAGRAM_CONTEXT;

STATIC NTSTATUS
CtdipReceiveDatagramCompleteCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PRECV_DATAGRAM_CONTEXT pRecvContext;
    PCTDI_DATA pCtdi = Context;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PNDIS_BUFFER pNdisBuffer;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveDatagramCompleteCallback\n")));

    pRecvContext = (PRECV_DATAGRAM_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);

    pNdisBuffer = NdisBufferFromBuffer(pRecvContext->pBuffer);
    ASSERT(MmGetMdlVirtualAddress(pNdisBuffer)==pRecvContext->pBuffer);

    if (pCtdi->RecvDatagramCallback && !pCtdi->Closed && Status==NDIS_STATUS_SUCCESS)
    {
        // We took a reference for the buffer when we created the irp.
        (void)// ToDo: We don't care about the return value?
        pCtdi->RecvDatagramCallback(pCtdi->RecvContext,
                                    (PTRANSPORT_ADDRESS)&pRecvContext->SourceAddress,
                                    pRecvContext->pBuffer,
                                    pRecvContext->Length);

        // The above layer owns the buffer now.
    }
    else
    {
        FreeBufferToPool(&pCtdi->Datagram.RxPool, pRecvContext->pBuffer, TRUE);
        DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);
    }


    RELEASE_CONTEXT(pIrp, RECV_DATAGRAM_CONTEXT);
    IoFreeIrp(pIrp);


    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReceiveDatagramCompleteCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
CtdipReceiveDatagramCallback(
    IN PVOID TdiEventContext,
    IN LONG SourceAddressLength,
    IN PVOID SourceAddress,
    IN LONG OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG* BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP* IoRequestPacket )
{
    PUCHAR pBuffer = NULL;
    PNDIS_BUFFER pNdisBuffer;
    PCTDI_DATA pCtdi = TdiEventContext;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipReceiveDatagramCallback\n")));
    if (pCtdi->RecvDatagramCallback==NULL)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Datagram received, no handler registered.  Drop it\n")));
        goto crdcDone;
    }

    pBuffer = GetBufferFromPool(&pCtdi->Datagram.RxPool);
    if (!pBuffer)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("No buffers, dropping datagram\n")));
        goto crdcDone;
    }

    pNdisBuffer = NdisBufferFromBuffer(pBuffer);

    if (pCtdi->RecvDatagramCallback && !pCtdi->Closed)
    {
        if (BytesAvailable>PPTP_MAX_RECEIVE_SIZE)
        {
            DEBUGMSG(DBG_ERROR, (DTEXT("WAY too many bytes received. %d\n"), BytesAvailable));
            ASSERT(BytesAvailable<PPTP_MAX_RECEIVE_SIZE);
        }
        else if (ReceiveDatagramFlags&TDI_RECEIVE_ENTIRE_MESSAGE ||
                 BytesAvailable==BytesIndicated)
        {
            ULONG BytesCopied;

            // Let's just do a copy here.
            TdiCopyBufferToMdl(Tsdu,
                               0,
                               BytesIndicated,
                               pNdisBuffer,
                               0,
                               &BytesCopied);

            ASSERT(BytesCopied==BytesIndicated);

            REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);  // pair in CtdiReceiveComplete
            (void)// ToDo: We don't care about the return value?
            pCtdi->RecvDatagramCallback(pCtdi->RecvContext,
                                        SourceAddress,
                                        pBuffer,
                                        BytesIndicated);

            // We've handed the buffer to the layer above.  Clear the var so we don't
            // free it when we leave here.
            pBuffer = NULL;
            *BytesTaken = BytesIndicated;
        }
        else
        {
            PRECV_DATAGRAM_CONTEXT pContext;
            PIRP pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                              NUM_STACKS_FOR_CONTEXT(sizeof(RECV_DATAGRAM_CONTEXT))),
                                      FALSE);

            if (pIrp)
            {
                pContext = GET_CONTEXT(pIrp, RECV_DATAGRAM_CONTEXT);

                pContext->SourceAddress = *(PTA_IP_ADDRESS)SourceAddress;
                pContext->Length        = BytesAvailable;
                pContext->pBuffer       = pBuffer;

                TdiBuildReceiveDatagram(pIrp,
                                        pCtdi->pFileObject->DeviceObject,
                                        pCtdi->pFileObject,
                                        CtdipReceiveDatagramCompleteCallback,
                                        pCtdi,
                                        pNdisBuffer,
                                        PPTP_MAX_RECEIVE_SIZE,
                                        NULL,
                                        NULL,
                                        0);

                IoSetNextIrpStackLocation(pIrp);  // Required by TDI
                *BytesTaken = 0;
                *IoRequestPacket = pIrp;
                NtStatus = STATUS_MORE_PROCESSING_REQUIRED;
                pBuffer = NULL; // to keep us from freeing it here.
                REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);  // pair in CtdiReceiveComplete
            }
        }
    }
    else
    {
        NtStatus = STATUS_DATA_NOT_ACCEPTED;
    }

crdcDone:
    if (pBuffer)
    {
        FreeBufferToPool(&pCtdi->Datagram.RxPool, pBuffer, TRUE);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipReceiveDatagramCallback %08x\n"), NtStatus));
    return NtStatus;
}


STATIC NTSTATUS
CtdipSendCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    PVOID pData = NULL;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PCTDI_SEND_CONTEXT pSendContext;
    CTDI_EVENT_SEND_COMPLETE pSendCompleteCallback;
    PVOID CtdiContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSendCallback %08x\n"), Status));

    pSendContext = (PCTDI_SEND_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);
    CtdiContext = pSendContext->Context;
    pSendCompleteCallback = pSendContext->pSendCompleteCallback;

    // ToDo: take action if the irp returns failure.
    if (!pIrp->MdlAddress)
    {
        DEBUGMSG(DBG_WARN, (DTEXT("MdlAddress NULL\n")));
    }
    else
    {
        ASSERT(pIrp->MdlAddress->Next == NULL);
        pData = MmGetMdlVirtualAddress(pIrp->MdlAddress);
#if PROBE
        MmUnlockPages(pIrp->MdlAddress);
#endif
        IoFreeMdl(pIrp->MdlAddress);
    }
    RELEASE_CONTEXT(pIrp, CTDI_SEND_CONTEXT);
    IoFreeIrp(pIrp);

    pSendCompleteCallback(CtdiContext, NULL, pData, Status);

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SEND);  // Pair in CtdiSend
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipSendCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

STATIC NTSTATUS
CtdipSendDatagramCallback(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    PVOID pData = NULL;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PCTDI_SEND_DATAGRAM_CONTEXT pSendContext;
    CTDI_EVENT_SEND_COMPLETE pSendCompleteCallback;
    PVOID CtdiContext, DatagramContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipSendDatagramCallback %08x\n"), Status));

    pSendContext = (PCTDI_SEND_DATAGRAM_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);
    CtdiContext = pSendContext->Context;
    DatagramContext = pSendContext->DatagramContext;
    pSendCompleteCallback = pSendContext->pSendCompleteCallback;

    // ToDo: take action if the irp returns failure.
    if (!pIrp->MdlAddress)
    {
        DEBUGMSG(DBG_WARN, (DTEXT("MdlAddress NULL\n")));
    }
    else
    {
        ASSERT(pIrp->MdlAddress->Next == NULL);
        pData = MmGetMdlVirtualAddress(pIrp->MdlAddress);
#if PROBE
        MmUnlockPages(pIrp->MdlAddress);
#endif
        IoFreeMdl(pIrp->MdlAddress);
    }
    RELEASE_CONTEXT(pIrp, CTDI_SEND_DATAGRAM_CONTEXT);
    IoFreeIrp(pIrp);

    if (pSendCompleteCallback)
    {
        pSendCompleteCallback(CtdiContext, DatagramContext, pData, Status);
    }
    else
    {
        ASSERT(!"No SendCompleteHandler for datagram");
    }

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SENDDG);  // Pair in CtdiSendDatagram
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipSendDatagramCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

/** public functions **/

NDIS_STATUS
CtdiInitialize(
    IN      ULONG                       ulFlags
    )
{
    TA_IP_ADDRESS Local;
    UNICODE_STRING DeviceName;
    NTSTATUS Status = STATUS_SUCCESS;
    DEBUGMSG(DBG_FUNC|DBG_TDI, (DTEXT("+CtdiInitialize\n")));

    if( fCtdiInitialized ){
        goto ciDone;
    }

    InitializeListHead(&CtdiList);
    InitializeListHead(&CtdiFreeList);
    InitializeListHead(&CtdiRouteList);
    InitializeListHead(&CtdiRouteNotifyList);
    NdisAllocateSpinLock(&CtdiListLock);
    
    fCtdiInitialized = TRUE;

    if (ulFlags&CTDI_FLAG_NETWORK_HEADER)
    {
        CtdiMdlFlags |= MDL_NETWORK_HEADER;
    }

    if (ulFlags&CTDI_FLAG_ENABLE_ROUTING)
    {
        NdisZeroMemory(&Local, sizeof(Local));

        Local.TAAddressCount = 1;
        Local.Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
        Local.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
        Local.Address[0].Address[0].sin_port = 0;
        Local.Address[0].Address[0].in_addr = 0;

        RtlInitUnicodeString(&DeviceName, DD_TCP_DEVICE_NAME);

        Status = CtdipOpenProtocol(&DeviceName,
                                   (PTRANSPORT_ADDRESS)&Local,
                                   &hTcp,
                                   &pFileTcp);

        if (Status!=STATUS_SUCCESS)
        {
            goto ciDone;
        }
        RtlInitUnicodeString(&DeviceName, DD_IP_DEVICE_NAME);

        Status = CtdipOpenProtocol(&DeviceName,
                                   (PTRANSPORT_ADDRESS)&Local,
                                   &hIp,
                                   &pFileIp);

        if (Status!=STATUS_SUCCESS)
        {
            goto ciDone;
        }

    }

ciDone:
    if (Status!=STATUS_SUCCESS)
    {
        if (hTcp)
        {
            CtdipCloseProtocol(hTcp, pFileTcp);
            hTcp = 0;
            pFileTcp = NULL;
        }
        if (hIp)
        {
            CtdipCloseProtocol(hIp, pFileIp);
            hIp = 0;
            pFileIp = NULL;
        }
        NdisFreeSpinLock(&CtdiListLock);
        fCtdiInitialized = FALSE;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiInitialize %08x\n"), Status));
    return (NDIS_STATUS)Status;
}

VOID
CtdiShutdown(
    )
{
    HANDLE h;
    PFILE_OBJECT pFile;
    UINT i;

    DEBUGMSG(DBG_FUNC|DBG_TDI, (DTEXT("+CtdiShutdown\n")));
    if (fCtdiInitialized)
    {
        fCtdiInitialized = FALSE;
        NdisMSleep(30000);
        // Allow code using these handles on other processors to complete
        // before we close them.
        if (hIp || pFileIp)
        {
            h = hIp;
            hIp = 0;
            pFile = pFileIp;
            pFileIp = NULL;
            CtdipCloseProtocol(h, pFile);
        }
        if (hTcp || pFileTcp)
        {
            h = hTcp;
            hTcp = 0;
            pFile = pFileTcp;
            pFileTcp = NULL;
            CtdipCloseProtocol(h, pFile);
        }
        // Some irps seem very slow to be cancelled by TCP.
        for (i=0; i<300; i++)
        {
            if (IsListEmpty(&CtdiList) &&
                IsListEmpty(&CtdiRouteList) &&
                IsListEmpty(&CtdiRouteNotifyList) &&
                IsListEmpty(&CtdiFreeList))
            {
                break;
            }
            NdisMSleep(10000);
            // Small window to allow irps to complete after closing their handles.
        }
        ASSERT(IsListEmpty(&CtdiList));
        ASSERT(IsListEmpty(&CtdiRouteList));
        ASSERT(IsListEmpty(&CtdiRouteNotifyList));
        NdisFreeSpinLock(&CtdiListLock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiShutdown\n")));
}

NDIS_STATUS
CtdiClose(
    IN      HANDLE                      hCtdi
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    NTSTATUS Status;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiClose\n")));

    if (!IS_CTDI(pCtdi))
    {
        return NDIS_STATUS_SUCCESS;
    }

    NdisAcquireSpinLock(&pCtdi->Lock);
    if (!pCtdi->Closed)
    {
        pCtdi->Closed = TRUE;
        switch (pCtdi->Type)
        {
            case CTDI_ENDPOINT:
            {
                break;
            }
            case CTDI_CONNECTION:
            {
                ASSERT(!pCtdi->Connection.ConnectInfo);
                break;
            }
            case CTDI_LISTEN:
            {
                while (!IsListEmpty(&pCtdi->Listen.ConnectList))
                {
                    PLIST_ENTRY pListEntry;
                    PCTDI_DATA pConnect;
                    PIRP pIrp;
                    NDIS_STATUS Status;

                    pListEntry = RemoveHeadList(&pCtdi->Listen.ConnectList);
                    pConnect = CONTAINING_RECORD(pListEntry,
                                                 CTDI_DATA,
                                                 Connection.ListEntry);

                    NdisReleaseSpinLock(&pCtdi->Lock);

                    // these derefs are for the double references placed when these are placed on
                    // the list
                    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_LIST);
                    DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_LIST);

                    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
                    if (pIrp)
                    {
                        // Normally we would take a reference to pConnect for this irp, but
                        // these handles won't be getting a close from above, which means they
                        // are in need of one extra dereference.

                        SET_DBGFLAG(pConnect, CTDI_F_BUILD_DISASSOC);

                        TdiBuildDisassociateAddress(pIrp,
                                                    pConnect->pFileObject->DeviceObject,
                                                    pConnect->pFileObject,
                                                    CtdipDisassociateAddressCallback,
                                                    pConnect);
                        DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_DISASSOCIATE_ADDRESS\n")));

                        // Completion handler always called, don't care on return value.
                        (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);
                    }
                    else
                    {
                        DEREFERENCE_OBJECT_EX(pConnect, CTDI_REF_UNKNOWN);
                    }
                    NdisAcquireSpinLock(&pCtdi->Lock);

                }

                CtlpCleanupCtls(pgAdapter);

            }
            default:
                break;
        }
        NdisReleaseSpinLock(&pCtdi->Lock);
        DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_INITIAL);  // This derefs the initial reference
    }
    else
    {
        NdisReleaseSpinLock(&pCtdi->Lock);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiClose\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CtdiListen(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   NumListen,
    IN      CTDI_EVENT_CONNECT_QUERY    pConnectQueryHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    )
{
    UINT i;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    BOOLEAN Reference = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiListen\n")));

    if (!IS_CTDI(pCtdi))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %08x\n"), pCtdi));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto clDone;
    }

    NdisAcquireSpinLock(&pCtdi->Lock);

    pCtdi->Type = CTDI_LISTEN;
    pCtdi->Listen.Context = pContext;

    pCtdi->RecvCallback = pReceiveHandler;
    pCtdi->ConnectQueryCallback = pConnectQueryHandler;
    pCtdi->DisconnectCallback = pDisconnectHandler;

    InitializeListHead(&pCtdi->Listen.ConnectList);

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_INLISTEN);  // Pair in this func.
    Reference = TRUE;
    NdisReleaseSpinLock(&pCtdi->Lock);


    for (i=0; i<NumListen; i++)
    {
        ReturnStatus = CtdipAddListenConnection(pCtdi);
        if (ReturnStatus!=NDIS_STATUS_SUCCESS)
        {
            goto clDone;
        }
    }

    ReturnStatus = CtdipSetEventHandler(pCtdi,
                                        TDI_EVENT_CONNECT,
                                        CtdipConnectCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_CONNECT failed\n")));
        goto clDone;
    }

    ReturnStatus = CtdipSetEventHandler(pCtdi,
                                        TDI_EVENT_RECEIVE,
                                        CtdipReceiveCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_RECEIVE failed\n")));
        goto clDone;
    }

    ReturnStatus = CtdipSetEventHandler(pCtdi,
                                        TDI_EVENT_DISCONNECT,
                                        CtdipDisconnectCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_DISCONNECT failed\n")));
        goto clDone;
    }

clDone:
    if (Reference)
    {
        DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_INLISTEN);  // Pair in this func.
    }
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        // ToDo: cleanup on failure.
        // Figure out how to undo address association, if necessary.
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdiListen %08x\n"), ReturnStatus));
    return ReturnStatus;
}

NDIS_STATUS
CtdiConnect(
    IN      HANDLE                      hCtdi,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      CTDI_EVENT_CONNECT_COMPLETE pConnectCompleteHandler,
    IN      CTDI_EVENT_RECEIVE          pReceiveHandler,
    IN      CTDI_EVENT_DISCONNECT       pDisconnectHandler,
    IN      PVOID                       pContext
    )
{
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;
    PTIME pTimeout = NULL;
    PIRP pIrp;
    IO_STATUS_BLOCK IoStatusBlock;
    PCTDI_DATA pEndpoint = (PCTDI_DATA)hCtdi;
    PCTDI_DATA pConnect = NULL;
    PTDI_CONNECTION_INFORMATION pRequestInfo = NULL;
    PTDI_CONNECTION_INFORMATION pReturnInfo = NULL;
    PTA_IP_ADDRESS pRemoteAddress;
    PBOOLEAN pInboundFlag;
    BOOLEAN CloseConnection = FALSE;

    UCHAR EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
                   TDI_CONNECTION_CONTEXT_LENGTH +
                   sizeof(PVOID)];
    PFILE_FULL_EA_INFORMATION pEa = (PFILE_FULL_EA_INFORMATION)EaBuffer;
    PVOID *ppContext = (PVOID*)(pEa->EaName + TDI_CONNECTION_CONTEXT_LENGTH + 1);

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiConnect\n")));

    ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);

    if (!IS_CTDI(pEndpoint))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %08x\n"), pEndpoint));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto ccDone;
    }

    pConnect = CtdipDataAlloc();
    if (!pConnect)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto ccDone;
    }

    pConnect->Type = CTDI_CONNECTION;
    pConnect->Connection.Context = pContext;
    pConnect->Connection.LocalEndpoint = pEndpoint;
    pConnect->ConnectCompleteCallback = pConnectCompleteHandler;
    pConnect->RecvCallback = pReceiveHandler;
    pConnect->DisconnectCallback = pDisconnectHandler;

    DeviceName.Length = sizeof(DD_TCP_DEVICE_NAME) - sizeof(WCHAR);
    DeviceName.Buffer = DD_TCP_DEVICE_NAME;

    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NdisZeroMemory(pEa, sizeof(EaBuffer));
    pEa->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    pEa->EaValueLength = sizeof(PVOID);
    NdisMoveMemory(pEa->EaName, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH);

    *ppContext = pConnect;

    NdisZeroMemory(&IoStatusBlock, sizeof(IoStatusBlock));

    NtStatus =
        ZwCreateFile(&pConnect->hFile,                 /* FileHandle */
                     FILE_READ_DATA | FILE_WRITE_DATA, /* Desired Access */
                     &ObjectAttributes,                /* Object Attributes */
                     &IoStatusBlock,                   /* IO Status Block */
                     NULL,                             /* Allocation Size */
                     FILE_ATTRIBUTE_NORMAL,            /* File Attributes */
                     0,                                /* Share Access */
                     FILE_OPEN,                        /* Create Disposition */
                     0,                                /* Create Options */
                     pEa,                              /* EaBuffer */
                     sizeof(EaBuffer)                  /* EaLength */
                     );

    if (NtStatus!=STATUS_SUCCESS)
    {
        ReturnStatus = NtStatus;
        goto ccDone;
    }

    // Convert the address file handle to a FILE_OBJECT

    NtStatus =
        ObReferenceObjectByHandle(pConnect->hFile,            /* Handle */
                                  0,                          /* DesiredAccess */
                                  NULL,                       /* ObjectType */
                                  KernelMode,                 /* AccessMode */
                                  &pConnect->pFileObject,     /* Object */
                                  NULL                        /* HandleInfo */
                                  );


    if (NtStatus != STATUS_SUCCESS)
    {
        ReturnStatus = NtStatus;
        goto ccDone;
    }

    // Make an irp to associate the endpoint and connection.
    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);
    if (!pIrp)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto ccDone;
    }

    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_ASSOADDR);  // Pair in CtdipAssociateAddressCallback
    TdiBuildAssociateAddress(pIrp,
                             pConnect->pFileObject->DeviceObject,
                             pConnect->pFileObject,
                             CtdipAssociateAddressCallback,
                             pConnect,
                             pEndpoint->hFile);
    // Associate address creates a reference from the connection to the endpoint.
    REFERENCE_OBJECT_EX(pEndpoint, CTDI_REF_ADDRREF);  // Pair in CtdipDisassociateAddressCallback

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_ASSOCIATE_ADDRESS\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);


    ReturnStatus = CtdipSetEventHandler(pEndpoint,
                                        TDI_EVENT_RECEIVE,
                                        CtdipReceiveCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_RECEIVE failed\n")));
        goto ccDone;
    }

    ReturnStatus = CtdipSetEventHandler(pEndpoint,
                                        TDI_EVENT_DISCONNECT,
                                        CtdipDisconnectCallback);
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("CtdiSetEventHandler TDI_EVENT_DISCONNECT failed\n")));
        goto ccDone;
    }

    // Make an irp to establish the connection
    pIrp = IoAllocateIrp(pConnect->pFileObject->DeviceObject->StackSize, FALSE);

    // No sign saying we can't allocate the request info, return info and address buffers
    // in one shot.
    pRequestInfo = MyMemAlloc(2*(sizeof(TDI_CONNECTION_INFORMATION)+
                                 sizeof(TA_IP_ADDRESS)) +
                              3*sizeof(PVOID) + sizeof(BOOLEAN),
                              TAG_CTDI_CONNECT_INFO);

    if (!pIrp || !pRequestInfo)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;

        goto ccDone;
    }

    NdisZeroMemory(pRequestInfo,
                   2*(sizeof(TDI_CONNECTION_INFORMATION)+sizeof(TA_IP_ADDRESS))
                   + sizeof(BOOLEAN) + 3*sizeof(PVOID));

    pConnect->Connection.ConnectInfo = pRequestInfo;

    pRequestInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pRequestInfo + 1) + sizeof(PVOID));
    
    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pRequestInfo->RemoteAddress = pRemoteAddress;

    *pRemoteAddress = *(PTA_IP_ADDRESS)pAddress;

    pReturnInfo = 
        (PTDI_CONNECTION_INFORMATION)
        ((PUCHAR)(pRemoteAddress + 1) + sizeof(PVOID));

    (ULONG_PTR)pReturnInfo &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddressLength = sizeof(TA_IP_ADDRESS);

    pRemoteAddress = 
        (PTA_IP_ADDRESS)((PUCHAR)(pReturnInfo + 1) + sizeof(PVOID));

    (ULONG_PTR)pRemoteAddress &=
        ~((ULONG_PTR)sizeof(PVOID) - 1);

    pReturnInfo->RemoteAddress = pRemoteAddress;

    pInboundFlag = (PBOOLEAN)(pRemoteAddress + 1);
    *pInboundFlag = FALSE;

    pRemoteAddress->TAAddressCount = 1;
    pRemoteAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;
    pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;

    REFERENCE_OBJECT_EX(pConnect, CTDI_REF_CONNECT);  // Pair in CtdipConnectCompleteCallback
    TdiBuildConnect(pIrp,
                    pConnect->pFileObject->DeviceObject,
                    pConnect->pFileObject,
                    CtdipConnectCompleteCallback,
                    pConnect,
                    NULL,                   // ToDo: allow them to specify timeout
                    pRequestInfo,
                    pReturnInfo);

    DEBUGMSG(DBG_TDI, (DTEXT("IoCallDriver TDI_CONNECT\n")));

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pConnect->pFileObject->DeviceObject, pIrp);
    ReturnStatus = STATUS_PENDING;

    NdisInterlockedIncrement(&Counters.OutboundConnectAttempts);

ccDone:;
    if (!NT_SUCCESS(ReturnStatus) && pConnectCompleteHandler)
    {
        pConnectCompleteHandler(pContext, 0, ReturnStatus);
        ReturnStatus = NDIS_STATUS_PENDING;
        CtdiDisconnect(pConnect, TRUE);
        CtdiClose(pConnect);
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdiConnect %08x\n"), ReturnStatus));
    return ReturnStatus;
}

NDIS_STATUS
CtdiDisconnect(
    IN      HANDLE                      hCtdi,
    IN      BOOLEAN                     Abort
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    NDIS_STATUS Status;
    PIRP pIrp = NULL;
    PTIME pTimeout;
    PTDI_CONNECTION_INFORMATION pConnectInfo;
    BOOLEAN Disconnected = FALSE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiDisconnect\n")));

    if (!IS_CTDI(pCtdi))
    {
        Status = NDIS_STATUS_SUCCESS;
        goto cdDone;
    }

    SET_DBGFLAG(pCtdi, CTDI_F_DISCONNECT);

    NdisAcquireSpinLock(&pCtdi->Lock);
    if ((Abort && pCtdi->Connection.Abort) ||
        (!Abort && pCtdi->Connection.Disconnect))
    {
        // Already disconnecting, bail out.
        NdisReleaseSpinLock(&pCtdi->Lock);
        Status = NDIS_STATUS_SUCCESS;
        goto cdDone;
    }
    if (Abort)
    {
        pCtdi->Connection.Abort = TRUE;
    }
    pCtdi->Connection.Disconnect = TRUE;
    pCtdi->Connection.DisconnectCount++;
    if (pCtdi->pFileObject)
    {
        pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                     NUM_STACKS_FOR_CONTEXT(sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION))),
                             FALSE);
    }
    NdisReleaseSpinLock(&pCtdi->Lock);

    if (!pIrp)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cdDone;
    }

    pTimeout = (PTIME)GetContextArea(pIrp, sizeof(TIME)+sizeof(TDI_CONNECTION_INFORMATION));
    pConnectInfo = (PTDI_CONNECTION_INFORMATION)(pTimeout + 1);

    pTimeout->LowPart = CtdiTcpDisconnectTimeout * -10000000L;
    pTimeout->HighPart = (pTimeout->LowPart) ? -1 : 0;

    // Responding to a controlled disconnect, we don't provide
    // TDI_CONNECTION_INFORMATION, but we request it from the peer.

    SET_DBGFLAG(pCtdi, CTDI_F_BUILD_DISCONNECT_2);

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_DISCONNECT);  // Pair in CtdipDisconnectCompleteCallback
    TdiBuildDisconnect(pIrp,
                       pCtdi->pFileObject->DeviceObject,
                       pCtdi->pFileObject,
                       CtdipDisconnectCompleteCallback,
                       pCtdi,
                       pTimeout,
                       (Abort ? TDI_DISCONNECT_ABORT : TDI_DISCONNECT_RELEASE),
                       NULL,
                       pConnectInfo);


    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    Status = NDIS_STATUS_SUCCESS;

cdDone:
    if (!NT_SUCCESS(Status))
    {
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiDisconnect %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtdiReceiveComplete(
    IN      HANDLE                      hCtdi,
    IN      PUCHAR                      pBuffer
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiReceiveComplete\n")));
    FreeBufferToPool(&pCtdi->Datagram.RxPool, pBuffer, TRUE);
    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_RECVDG);  // Pair in CtdiReceiveComplete
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiReceiveComplete\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CtdiSend(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pvBuffer,
    IN      ULONG                       ulLength
    )
// We require that pBuffer not be temporary storage, as we will use it to send
// the data in an async call.
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    PUCHAR pBuffer = pvBuffer;
    PCTDI_SEND_CONTEXT pSendContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSend\n")));
    if (!IS_CTDI(pCtdi))
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Ctdi: Bad handle %08x\n"), pCtdi));
        Status = NDIS_STATUS_FAILURE;
        goto csDone;
    }

    // Allocate one extra stack location for context data.
    pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                 NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_SEND_CONTEXT))),
                         FALSE);

    pMdl = IoAllocateMdl(pBuffer,
                         ulLength,
                         FALSE,
                         FALSE,
                         pIrp);

    if (pMdl)
    {
#if PROBE
        __try
        {
            MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            IoFreeMdl(pMdl);
            pMdl = NULL;
        }
#else
        MmBuildMdlForNonPagedPool(pMdl);
#endif
    }

    if (!pIrp || !pMdl)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("Failed to allocate irp or mdl\n")));
        Status = NDIS_STATUS_RESOURCES;
        goto csDone;
    }

    // Get the first stack location for our own context use
    pSendContext = GET_CONTEXT(pIrp, CTDI_SEND_CONTEXT);

    pSendContext->Context = pContext;
    pSendContext->pSendCompleteCallback = pSendCompleteHandler;

    TdiBuildSend(pIrp,
                 pCtdi->pFileObject->DeviceObject,
                 pCtdi->pFileObject,
                 CtdipSendCallback,
                 pCtdi,
                 pMdl,
                 0,
                 ulLength);

    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SEND);  // pair in CtdipSendCallback

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    Status = STATUS_PENDING;
csDone:
    if (!NT_SUCCESS(Status) && pSendCompleteHandler)
    {
        pSendCompleteHandler(pContext, NULL, pBuffer, Status);
        Status = NDIS_STATUS_PENDING;
        if (pMdl)
        {
            IoFreeMdl(pMdl);
        }
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiSend %08x\n"), Status));
    return Status;
}

NDIS_STATUS
CtdiSendDatagram(
    IN      HANDLE                      hCtdi,
    IN      CTDI_EVENT_SEND_COMPLETE    pSendCompleteHandler,
    IN      PVOID                       pContext,
    IN      PVOID                       pDatagramContext,
    IN      PTRANSPORT_ADDRESS          pDestination,
    IN      PUCHAR                      pBuffer,
    IN      ULONG                       ulLength
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    CTDI_SEND_DATAGRAM_CONTEXT *pSendContext;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSendDatagram\n")));

    if (!IS_CTDI(pCtdi) || pCtdi->Closed)
    {
        Status = NDIS_STATUS_CLOSED;
        goto csdDone;
    }

    pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                 NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_SEND_DATAGRAM_CONTEXT))),
                         FALSE);
    ASSERT(pCtdi->pFileObject->DeviceObject->StackSize + NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_SEND_DATAGRAM_CONTEXT))<7);

    pMdl = IoAllocateMdl(pBuffer,
                         ulLength,
                         FALSE,
                         FALSE,
                         NULL);

    if (pMdl)
    {
#if PROBE
        __try
        {
            MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            IoFreeMdl(pMdl);
            pMdl = NULL;
        }
#else
        MmBuildMdlForNonPagedPool(pMdl);
#endif
    }

    if (!pIrp || !pMdl)
    {
        Status = NDIS_STATUS_RESOURCES;
        goto csdDone;
    }

    pMdl->MdlFlags |= CtdiMdlFlags;

    // Get the first stack location for our own context use
    pSendContext = GET_CONTEXT(pIrp, CTDI_SEND_DATAGRAM_CONTEXT);

    NdisZeroMemory(pSendContext, sizeof(CTDI_SEND_DATAGRAM_CONTEXT));

    pSendContext->pSendCompleteCallback = pSendCompleteHandler;
    pSendContext->Context = pContext;
    pSendContext->DatagramContext = pDatagramContext;

    pSendContext->TdiConnectionInfo.RemoteAddressLength = sizeof(pSendContext->Ip);
    pSendContext->TdiConnectionInfo.RemoteAddress = &pSendContext->Ip;

    pSendContext->Ip = *(PTA_IP_ADDRESS)pDestination;

    if (pSendContext->Ip.Address[0].AddressLength!=TDI_ADDRESS_LENGTH_IP ||
        pSendContext->Ip.Address[0].AddressType!=TDI_ADDRESS_TYPE_IP)
    {
        DEBUGMSG(DBG_WARN, (DTEXT("Misformed transmit address on %08x\n"), pCtdi));
    }

    TdiBuildSendDatagram(pIrp,
                         pCtdi->pFileObject->DeviceObject,
                         pCtdi->pFileObject,
                         CtdipSendDatagramCallback,
                         pCtdi,
                         pMdl,
                         ulLength,
                         &pSendContext->TdiConnectionInfo);


    REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_SENDDG);  // Pair in CtdipSendDatagramCallback

    // Completion handler always called, don't care on return value.
    (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);

    Status = STATUS_PENDING;
csdDone:
    if (!NT_SUCCESS(Status))
    {
        if (pSendCompleteHandler)
        {
            pSendCompleteHandler(pContext, pDatagramContext, pBuffer, Status);
            Status = NDIS_STATUS_PENDING;
        }
        if (pMdl)
        {
            IoFreeMdl(pMdl);
        }
        if (pIrp)
        {
            IoFreeIrp(pIrp);
        }
    }

    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiSendDatagram %08x\n"), Status));
    return Status;
}

STATIC VOID
CtdipDeleteHostRoute(
    PCTDI_ROUTE pRoute
    )
{
    PFILE_OBJECT pFileObject = pFileTcp;
    BOOLEAN NewRoute = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    IPRouteEntry *pQueryBuffer = NULL;
    IPRouteEntry *pNewRoute = NULL;
    IPRouteEntry BestRoute;
    BOOLEAN BestRouteFound = FALSE;
    PIRP pIrp;
    IO_STATUS_BLOCK IoStatusBlock;
    PIO_STACK_LOCATION IrpSp;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryRoute;
    TCP_REQUEST_SET_INFORMATION_EX *pSetRoute = NULL;
    ULONG NumRoutes = 20;
    ULONG Size = 0, QuerySize = 0;
    ULONG i;
    KEVENT  Event;
#ifdef IP_ROUTE_REFCOUNT
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE IpFileHandle = 0;
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipDeleteHostRoute\n")));

    if (!fCtdiInitialized)
    {
        Status = NDIS_STATUS_FAILURE;
        goto cdhrDone;
    }
    if (!pRoute->ExternalRoute)
    {
        // Query TCPfor the current routing table

        Status = CtdipIpQueryRouteTable(&pQueryBuffer, &QuerySize, &NumRoutes);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            goto cdhrDone;
        }

        BestRoute.ire_mask = 0;
        BestRoute.ire_metric1 = (ULONG)-1;

        for (i=0; i<NumRoutes; i++)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Route %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Mask %d.%d.%d.%d Metric %d Index %d\n"),
                               IPADDR(pQueryBuffer[i].ire_dest),
                               pQueryBuffer[i].ire_type,
                               IPADDR(pQueryBuffer[i].ire_nexthop),
                               IPADDR(pQueryBuffer[i].ire_mask),
                               pQueryBuffer[i].ire_metric1,
                               pQueryBuffer[i].ire_index));
            if (pQueryBuffer[i].ire_dest == pRoute->IpAddress &&
                pQueryBuffer[i].ire_proto == IRE_PROTO_NETMGMT)
            {
                BestRoute = pQueryBuffer[i];
                BestRouteFound = TRUE;
                break;
            }
        }

        // We've taken what we need from the route list.  Free it.

        MyMemFree(pQueryBuffer, QuerySize);
        pQueryBuffer = NULL;

        if (BestRouteFound)
        {

#ifdef IP_ROUTE_REFCOUNT
            Size = sizeof(IPRouteEntry);
            pNewRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            pSetRoute = (PVOID)pNewRoute;
            if (!pNewRoute)
            {
                Status = NDIS_STATUS_RESOURCES;
                goto cdhrDone;
            }
            NdisZeroMemory(pNewRoute, Size);
#else
            Size = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry);
            pSetRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            if (!pSetRoute)
            {
                Status = NDIS_STATUS_RESOURCES;
                goto cdhrDone;
            }

            NdisZeroMemory(pSetRoute, Size);

            pSetRoute->ID.toi_entity.tei_entity = CL_NL_ENTITY;
            pSetRoute->ID.toi_entity.tei_instance = 0;
            pSetRoute->ID.toi_class = INFO_CLASS_PROTOCOL;
            pSetRoute->ID.toi_type = INFO_TYPE_PROVIDER;
            pSetRoute->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            pSetRoute->BufferSize = sizeof(IPRouteEntry);

            pNewRoute = (IPRouteEntry*)&pSetRoute->Buffer[0];
#endif
            *pNewRoute = BestRoute;

            pNewRoute->ire_type = IRE_TYPE_INVALID;

            DEBUGMSG(DBG_TDI, (DTEXT("DeleteHostRoute %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Index %d\n"),
                               IPADDR(pNewRoute->ire_dest), pNewRoute->ire_type,
                               IPADDR(pNewRoute->ire_nexthop), pNewRoute->ire_index));

            KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

#ifdef IP_ROUTE_REFCOUNT
            pFileObject = pFileIp;

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_IP_SET_ROUTEWITHREF,
                pFileObject->DeviceObject,
                pNewRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#else
            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_TCP_SET_INFORMATION_EX,
                pFileObject->DeviceObject,
                pSetRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#endif
            if (pIrp == NULL) {
                goto cdhrDone;
            }

            IrpSp = IoGetNextIrpStackLocation(pIrp);
            IrpSp->FileObject = pFileObject;

            Status = IoCallDriver(pFileObject->DeviceObject, pIrp);

            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject(&Event, 
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                Status = IoStatusBlock.Status;

            }

            if (Status != STATUS_SUCCESS) {
                DEBUGMSG(DBG_TDI, (DTEXT("Create host route failed %08x\n"), Status));
                goto cdhrDone;
            }
        }
    }

cdhrDone:
    if (pRoute)
    {
        MyInterlockedRemoveEntryList(&pRoute->ListEntry, &CtdiListLock);
        MyMemFree(pRoute, sizeof(CTDI_ROUTE));
    }
    if (pSetRoute)
    {
        MyMemFree(pSetRoute, Size);
    }
    if (pQueryBuffer)
    {
        MyMemFree(pQueryBuffer, QuerySize);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipDeleteHostRoute\n")));
}

NDIS_STATUS
CtdiAddHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    )
{
    PFILE_OBJECT pFileObject = pFileTcp;
    PCTDI_ROUTE pRoute = NULL;
    BOOLEAN NewRoute = FALSE;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    IPRouteEntry *pQueryBuffer = NULL;
    IPRouteEntry *pNewRoute = NULL;
    IPRouteEntry BestRoute;
    BOOLEAN BestRouteFound = FALSE;
    PIRP pIrp = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    PIO_STACK_LOCATION IrpSp;
    TCP_REQUEST_QUERY_INFORMATION_EX QueryRoute;
    TCP_REQUEST_SET_INFORMATION_EX *pSetRoute = NULL;
    ULONG NumRoutes = 20;
    ULONG Size = 0, QuerySize = 0;
    ULONG i;
    KEVENT  Event;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiAddHostRoute %d.%d.%d.%d\n"),
                        IPADDR(pIpAddress->Address[0].Address[0].in_addr)));

    NdisAcquireSpinLock(&CtdiListLock);
    pRoute = CtdipFindRoute(pIpAddress->Address[0].Address[0].in_addr);
    if (pRoute)
    {
        REFERENCE_OBJECT(pRoute);  // Pair in CtdiDeleteHostRoute
    }
    else
    {
        NewRoute = TRUE;
        pRoute = MyMemAlloc(sizeof(CTDI_ROUTE), TAG_CTDI_ROUTE);
        if (!pRoute)
        {
            Status = NDIS_STATUS_RESOURCES;
            NdisReleaseSpinLock(&CtdiListLock);
            goto cahrDone;
        }
        NdisZeroMemory(pRoute, sizeof(CTDI_ROUTE));
        pRoute->IpAddress = pIpAddress->Address[0].Address[0].in_addr;
        INIT_REFERENCE_OBJECT(pRoute, CtdipDeleteHostRoute); // Pair in CtdiDeleteHostRoute
        InsertTailList(&CtdiRouteList, &pRoute->ListEntry);
    }
    NdisReleaseSpinLock(&CtdiListLock);

    if (NewRoute)
    {
        // Query TCPfor the current routing table

        Status = CtdipIpQueryRouteTable(&pQueryBuffer, &QuerySize, &NumRoutes);
        if (Status!=NDIS_STATUS_SUCCESS)
        {
            goto cahrDone;
        }


        BestRoute.ire_mask = 0;
        BestRoute.ire_metric1 = (ULONG)-1;

        for (i=0; i<NumRoutes; i++)
        {
            DEBUGMSG(DBG_TDI, (DTEXT("Route %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Mask %d.%d.%d.%d Metric %d Index %d\n"),
                               IPADDR(pQueryBuffer[i].ire_dest),
                               pQueryBuffer[i].ire_type,
                               IPADDR(pQueryBuffer[i].ire_nexthop),
                               IPADDR(pQueryBuffer[i].ire_mask),
                               pQueryBuffer[i].ire_metric1,
                               pQueryBuffer[i].ire_index));
            if (pQueryBuffer[i].ire_dest == (pIpAddress->Address[0].Address[0].in_addr &
                                             pQueryBuffer[i].ire_mask))
            {
                if ((BestRoute.ire_mask == pQueryBuffer[i].ire_mask &&
                     BestRoute.ire_metric1 > pQueryBuffer[i].ire_metric1) ||
                    ntohl(pQueryBuffer[i].ire_mask) > ntohl(BestRoute.ire_mask))
                {
                    BestRoute = pQueryBuffer[i];
                    BestRouteFound = TRUE;
                }
            }
        }

        // We've taken what we need from the route list.  Free it.

        MyMemFree(pQueryBuffer, QuerySize);
        pQueryBuffer = NULL;

        if (!BestRouteFound)
        {
            DEBUGMSG(DBG_WARN, (DTEXT("Add host route.  No route found\n")));
        }
        else
        {
            // If we're using the IP refcounts, always add and delete the route.
#ifndef IP_ROUTE_REFCOUNT
            if (BestRoute.ire_dest == pIpAddress->Address[0].Address[0].in_addr &&
                BestRoute.ire_mask == 0xFFFFFFFF) {
                //
                // A route already exists so don't add
                //
                pRoute->ExternalRoute = TRUE;
                Status = NDIS_STATUS_SUCCESS;
                goto cahrDone;
            }
#endif

#ifdef IP_ROUTE_REFCOUNT
            Size = sizeof(IPRouteEntry);
            pNewRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            pSetRoute = (PVOID)pNewRoute;
            if (!pNewRoute)
            {
                Status = NDIS_STATUS_RESOURCES;
                goto cahrDone;
            }
            NdisZeroMemory(pNewRoute, Size);
#else
            Size = sizeof(TCP_REQUEST_SET_INFORMATION_EX) + sizeof(IPRouteEntry);
            pSetRoute = MyMemAlloc(Size, TAG_CTDI_ROUTE);
            if (!pSetRoute)
            {
                Status = NDIS_STATUS_RESOURCES;
                goto cahrDone;
            }

            NdisZeroMemory(pSetRoute, Size);

            pSetRoute->ID.toi_entity.tei_entity = CL_NL_ENTITY;
            pSetRoute->ID.toi_entity.tei_instance = 0;
            pSetRoute->ID.toi_class = INFO_CLASS_PROTOCOL;
            pSetRoute->ID.toi_type = INFO_TYPE_PROVIDER;
            pSetRoute->ID.toi_id = IP_MIB_RTTABLE_ENTRY_ID;
            pSetRoute->BufferSize = sizeof(IPRouteEntry);

            pNewRoute = (IPRouteEntry*)&pSetRoute->Buffer[0];
#endif
            *pNewRoute = BestRoute;

            pNewRoute->ire_dest = pIpAddress->Address[0].Address[0].in_addr;
            pNewRoute->ire_mask = 0xFFFFFFFF;
            pNewRoute->ire_proto = IRE_PROTO_NETMGMT;

            // Check DIRECT/INDIRECT only if this is not a host route
            if(BestRoute.ire_mask != 0xFFFFFFFF)
            {
                if ((BestRoute.ire_mask & pIpAddress->Address[0].Address[0].in_addr) ==
                    (BestRoute.ire_mask & BestRoute.ire_nexthop))
                {
                    pNewRoute->ire_type = IRE_TYPE_DIRECT;
                }
                else
                {
                    pNewRoute->ire_type = IRE_TYPE_INDIRECT;
                }
            }

            DEBUGMSG(DBG_TDI, (DTEXT("AddHostRoute %d.%d.%d.%d Type %d NextHop %d.%d.%d.%d Index %d\n"),
                               IPADDR(pNewRoute->ire_dest), pNewRoute->ire_type,
                               IPADDR(pNewRoute->ire_nexthop), pNewRoute->ire_index));

            KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

#ifdef IP_ROUTE_REFCOUNT
            pFileObject = pFileIp;

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_IP_SET_ROUTEWITHREF,
                pFileObject->DeviceObject,
                pNewRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#else
            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_TCP_SET_INFORMATION_EX,
                pFileObject->DeviceObject,
                pSetRoute,
                Size,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatusBlock);
#endif
            if (pIrp == NULL) {
                goto cahrDone;
            }

            IrpSp = IoGetNextIrpStackLocation(pIrp);
            IrpSp->FileObject = pFileObject;

            Status = IoCallDriver(pFileObject->DeviceObject, pIrp);

            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject(&Event, 
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                Status = IoStatusBlock.Status;
            }

            if (Status != STATUS_SUCCESS) {
                DEBUGMSG(DBG_TDI, (DTEXT("Create host route failed %08x\n"), Status));
                goto cahrDone;
            }

            //CtdipIpRequestRoutingNotification(pIpAddress->Address[0].Address[0].in_addr);

            // The route's a keeper.  Set the var to null so we don't free it
            pRoute = NULL;
        }
    }

cahrDone:
    if (pRoute)
    {
        MyInterlockedRemoveEntryList(&pRoute->ListEntry, &CtdiListLock);
        MyMemFree(pRoute, sizeof(CTDI_ROUTE));
    }
    if (pSetRoute)
    {
        MyMemFree(pSetRoute, Size);
    }
    if (pQueryBuffer)
    {
        MyMemFree(pQueryBuffer, QuerySize);
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiAddHostRoute %08x\n"), Status));
    return Status;
}


NDIS_STATUS
CtdiDeleteHostRoute(
    IN      PTA_IP_ADDRESS              pIpAddress
    )
{
    PCTDI_ROUTE pRoute = NULL;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiDeleteHostRoute\n")));
    NdisAcquireSpinLock(&CtdiListLock);
    pRoute = CtdipFindRoute(pIpAddress->Address[0].Address[0].in_addr);
    NdisReleaseSpinLock(&CtdiListLock);
    if (pRoute)
    {
        DEREFERENCE_OBJECT(pRoute);  // Pair in CtdiAddHostRoute
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiDeleteHostRoute\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS
CtdiCreateEndpoint(
    OUT     PHANDLE                     phCtdi,
    IN      ULONG_PTR                   ulAddressFamily,
    IN      ULONG_PTR                   ulType,
    IN      PTRANSPORT_ADDRESS          pAddress,
    IN      ULONG_PTR                   ulRxPadding
    )
{
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NDIS_STATUS ReturnStatus = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PCTDI_DATA  pCtdi = NULL;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiCreateEndpoint\n")));
    DBG_D(DBG_TAPI, KeGetCurrentIrql());

    // Validate TDI initialized
    if ( !fCtdiInitialized ) {
        DEBUGMSG(DBG_ERROR | DBG_TDI, (DTEXT("CtdiCreateEndpoint: TDI interface hasn't been initialized!\n")));
        ReturnStatus = NDIS_STATUS_FAILURE;
        goto cceDone;
    }

    ASSERT(ulAddressFamily==AF_INET);
    if (ulAddressFamily!=AF_INET)
    {
        DEBUGMSG(DBG_ERROR|DBG_TDI, (DTEXT("unsupported family\n")));
        ReturnStatus = NDIS_STATUS_OPEN_FAILED;
        goto cceDone;
    }

    // Alloc our endpoint structure.
    pCtdi = CtdipDataAlloc();
    if (!pCtdi)
    {
        ReturnStatus = NDIS_STATUS_RESOURCES;
        goto cceDone;
    }

    pCtdi->Type = CTDI_ENDPOINT;

    switch (ulType)
    {
        case SOCK_RAW:
        {
            WCHAR DeviceNameBuffer[sizeof(DD_RAW_IP_DEVICE_NAME) + 16];
            WCHAR ProtocolNumberBuffer[8];
            UNICODE_STRING ProtocolNumber;
            TA_IP_ADDRESS TmpAddress = *(PTA_IP_ADDRESS)pAddress;

            pCtdi->Type = CTDI_DATAGRAM;

            InitBufferPool(&pCtdi->Datagram.RxPool,
                           ALIGN_UP(PPTP_MAX_RECEIVE_SIZE+ulRxPadding, ULONG_PTR),
                           0,                   // MaxBuffers, no limit
                           10,                  // Buffers per block
                           0,                   // Frees per collection
                           TRUE,                // These are MDLs
                           TAG_CTDI_DGRAM);

            NdisZeroMemory(DeviceNameBuffer, sizeof(DeviceNameBuffer));
            DeviceName.Buffer = DeviceNameBuffer;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Length = 0;

            RtlAppendUnicodeToString(&DeviceName, DD_RAW_IP_DEVICE_NAME);
            RtlAppendUnicodeToString(&DeviceName, L"\\");

            ProtocolNumber.Buffer = ProtocolNumberBuffer;
            ProtocolNumber.MaximumLength = sizeof(ProtocolNumberBuffer);
            ProtocolNumber.Length = 0;

            RtlIntegerToUnicodeString(((PTA_IP_ADDRESS)pAddress)->Address[0].Address[0].sin_port,
                                      10,
                                      &ProtocolNumber);
            RtlAppendUnicodeStringToString(&DeviceName, &ProtocolNumber);

            TmpAddress.Address[0].Address[0].sin_port = 0;
            TmpAddress.Address[0].Address[0].in_addr = 0;
            NdisZeroMemory(TmpAddress.Address[0].Address[0].sin_zero,
                           sizeof(TmpAddress.Address[0].Address[0].sin_zero));

            NtStatus = CtdipOpenProtocol(&DeviceName,
                                         pAddress,
                                         &pCtdi->hFile,
                                         &pCtdi->pFileObject);

            if (NtStatus!=STATUS_SUCCESS)
            {
                ReturnStatus = NtStatus;
                goto cceDone;
            }

            break;
        }
        case SOCK_DGRAM:  // for UDP
        {
            DeviceName.Length = sizeof(DD_UDP_DEVICE_NAME) - sizeof(WCHAR);
            DeviceName.Buffer = DD_UDP_DEVICE_NAME;

            pCtdi->Type = CTDI_DATAGRAM;

            InitBufferPool(&pCtdi->Datagram.RxPool,
                           ALIGN_UP(PPTP_MAX_RECEIVE_SIZE+ulRxPadding, ULONG_PTR),
                           0,                   // MaxBuffers, no limit
                           10,                  // Buffers per block
                           0,                   // Frees per collection
                           TRUE,                // These are MDLs
                           TAG_CTDI_DGRAM);

            NtStatus = CtdipOpenProtocol(&DeviceName,
                                         pAddress,
                                         &pCtdi->hFile,
                                         &pCtdi->pFileObject);

            if (NtStatus!=STATUS_SUCCESS)
            {
                ReturnStatus = NtStatus;
                goto cceDone;
            }

            break;
        }
        case SOCK_STREAM:
        {
            RtlInitUnicodeString(&DeviceName, DD_TCP_DEVICE_NAME);

            NtStatus = CtdipOpenProtocol(&DeviceName,
                                         pAddress,
                                         &pCtdi->hFile,
                                         &pCtdi->pFileObject);

            if (NtStatus!=STATUS_SUCCESS)
            {
                ReturnStatus = NtStatus;
                goto cceDone;
            }

            break;
        }
        default:
            DEBUGMSG(DBG_ERROR|DBG_TDI, (DTEXT("unsupported Type\n")));
            ReturnStatus = NDIS_STATUS_OPEN_FAILED;
            goto cceDone;
    }

cceDone:
    if (ReturnStatus!=NDIS_STATUS_SUCCESS)
    {
        if (pCtdi)
        {
            CtdipDataFree(pCtdi);
            pCtdi = NULL;
        }
    }

    // Return the CTDI_DATA as a handle.
    *phCtdi = (HANDLE)pCtdi;

    DEBUGMSG(DBG_FUNC|DBG_ERR(ReturnStatus), (DTEXT("-CtdiCreateEndpoint Sts:%08x hCtdi:%08x\n"), ReturnStatus, pCtdi));
    return ReturnStatus;
}

NDIS_STATUS
CtdiSetEventHandler(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulEventType,
    IN      PVOID                       pEventHandler,
    IN      PVOID                       pContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCTDI_DATA pCtdi = (PCTDI_DATA)hCtdi;
    PVOID PrivateCallback = NULL;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSetEventHandler Type:%d\n"), ulEventType));

    switch (ulEventType)
    {
        case TDI_EVENT_RECEIVE_DATAGRAM:
        {
            if (pCtdi->Type==CTDI_DATAGRAM)
            {
                PrivateCallback = CtdipReceiveDatagramCallback;
                pCtdi->RecvDatagramCallback = pEventHandler;
                pCtdi->RecvContext = pContext;
            }
            else
            {
                DEBUGMSG(DBG_ERROR, (DTEXT("Tried to register RecvDgram handler on wrong handle.\n")));
                Status = NDIS_STATUS_FAILURE;
            }
            break;
        }
        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    if (Status==NDIS_STATUS_SUCCESS && PrivateCallback!=NULL)
    {
        Status = CtdipSetEventHandler(pCtdi,
                                      ulEventType,
                                      PrivateCallback);
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSetEventHandler %08x\n"), Status));
    return Status;
}


NDIS_STATUS
CtdiSetInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG_PTR                   ulSetType,
    IN      PTDI_CONNECTION_INFORMATION pConnectionInformation,
    IN      CTDI_EVENT_SET_COMPLETE     pSetCompleteHandler,
    IN      PVOID                       pContext
    )
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiSetInformation\n")));
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiSetInformation\n")));
    return NDIS_STATUS_FAILURE;
}

STATIC NTSTATUS
CtdipQueryInformationCallback(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PVOID Context
    )
{
    PCTDI_DATA pCtdi = Context;
    NDIS_STATUS Status = (NDIS_STATUS)pIrp->IoStatus.Status;
    PCTDI_QUERY_CONTEXT pQuery;
    CTDI_EVENT_QUERY_COMPLETE pQueryCompleteCallback;
    PVOID CtdiContext;
    PVOID pBuffer;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdipQueryInformationCallback\n")));

    pQuery = (PCTDI_QUERY_CONTEXT)IoGetCurrentIrpStackLocation(pIrp);
    CtdiContext = pQuery->Context;
    pQueryCompleteCallback = pQuery->pQueryCompleteCallback;

    pBuffer = MmGetMdlVirtualAddress(pIrp->MdlAddress);
#if PROBE
    MmUnlockPages(pIrp->MdlAddress);
#endif
    IoFreeMdl(pIrp->MdlAddress);
    RELEASE_CONTEXT(pIrp, CTDI_QUERY_CONTEXT);
    IoFreeIrp(pIrp);

    pQueryCompleteCallback(CtdiContext, pBuffer, Status);

    DEREFERENCE_OBJECT_EX(pCtdi, CTDI_REF_QUERY);

    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdipQueryInformationCallback\n")));
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NDIS_STATUS
CtdiQueryInformation(
    IN      HANDLE                      hCtdi,
    IN      ULONG                       ulQueryType,
    IN OUT  PVOID                       pBuffer,
    IN      ULONG                       Length,
    IN      CTDI_EVENT_QUERY_COMPLETE   pQueryCompleteHandler,
    IN      PVOID                       pContext
    )
{
    PIRP pIrp = NULL;
    PMDL pMdl = NULL;
    PCTDI_DATA pCtdi = (PCTDI_DATA) hCtdi;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PCTDI_QUERY_CONTEXT pQuery;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiQueryInformation\n")));

    pIrp = IoAllocateIrp((CCHAR)(pCtdi->pFileObject->DeviceObject->StackSize +
                                 NUM_STACKS_FOR_CONTEXT(sizeof(CTDI_QUERY_CONTEXT))),
                         FALSE);
    if (pIrp)
    {
        pMdl = IoAllocateMdl(pBuffer, Length, FALSE, FALSE, pIrp);
        if (pMdl)
        {
#if PROBE
            __try
            {
                MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                IoFreeMdl(pMdl);
                pMdl = NULL;
                Status = NDIS_STATUS_RESOURCES;
            }
#else
            MmBuildMdlForNonPagedPool(pMdl);
#endif
        }
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    if (pMdl)
    {
        pQuery = GET_CONTEXT(pIrp, CTDI_QUERY_CONTEXT);
        pQuery->Context = pContext;
        pQuery->pQueryCompleteCallback = pQueryCompleteHandler;

        TdiBuildQueryInformation(pIrp,
                                 pCtdi->pFileObject->DeviceObject,
                                 pCtdi->pFileObject,
                                 CtdipQueryInformationCallback,
                                 pCtdi,
                                 ulQueryType,
                                 pMdl);
        REFERENCE_OBJECT_EX(pCtdi, CTDI_REF_QUERY);

        // Completion handler always called, don't care on return value.
        (void)IoCallDriver(pCtdi->pFileObject->DeviceObject, pIrp);
    }
    else
    {
        if (pIrp)
        {
            IoFreeIrp(pIrp);
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    if (pQueryCompleteHandler && !NT_SUCCESS(Status))
    {
        pQueryCompleteHandler(pContext, pBuffer, Status);
        Status = STATUS_PENDING;
    }
    DEBUGMSG(DBG_FUNC|DBG_ERR(Status), (DTEXT("-CtdiQueryInformation %08x\n"), Status));
    return Status;
}


VOID CtdiCleanupLooseEnds()
{
    PLIST_ENTRY ListEntry;

    if (!fCtdiInitialized)
    {
        return;
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("+CtdiCleanupLooseEnds\n")));

    if (!IsListEmpty(&CtdiFreeList))
    {
        ScheduleWorkItem(CtdipDataFreeWorker, NULL, NULL, 0);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CtdiCleanupLooseEnds\n")));
}

VOID CtdiSetRequestPending(
    IN      HANDLE                      hCtdi
    )
{
    PCTDI_DATA pCtdi = (PCTDI_DATA) hCtdi;
    pCtdi->CloseReqPending = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\nt\dbgapi.c ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DBGAPI.C - NT specific debugging macros, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/3/1998
*
*****************************************************************************/

#if DBG

#include "raspptp.h"
#include <ntddk.h>
#include <cxport.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "dbgapi.h"

#define UNICODE_STRING_CONST(x) {sizeof(L##x)-2, sizeof(L##x), L##x}

ULONG DbgSettings = 0;
ULONG DbgOutput = DBG_OUTPUT_BUFFER;

CHAR         DbgMsgs[DBG_MSG_CNT][MAX_MSG_LEN];
ULONG        First, Last;
CTETimer     DbgTimer;
BOOLEAN      TimerRunning;
CTELock      DbgLock;
PIRP         pDbgIrp;
UCHAR        *IrpBuf;
ULONG        IrpBufLen;
ULONG        IrpBufWritten;
UCHAR        CharTable[256];

VOID DbgTimerExp(CTEEvent *Event, void *Arg);

VOID
DbgMsgInit()
{
    ULONG i;

    pDbgIrp = NULL;
    First = 0;
    Last = 0;
    TimerRunning = FALSE;

    for (i=0; i<256; i++)
    {
        CharTable[i] = (UCHAR)((i>=' ') ? i : '.');
    }
    CharTable[0xfe] = '.'; // Debugger seems to get stuck when we print this.

    CTEInitLock(&DbgLock);

    CTEInitTimer(&DbgTimer);
}

VOID
DbgMsgUninit()
{
    CTELockHandle   LockHandle;
    KIRQL           Irql;

    CTEGetLock(&DbgLock, &LockHandle);

    if (pDbgIrp)
    {
        IoAcquireCancelSpinLock(&Irql);

        IoSetCancelRoutine(pDbgIrp, NULL);

        IoReleaseCancelSpinLock(Irql);

        pDbgIrp->IoStatus.Information = 0;
        pDbgIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

DbgPrint("Complete irp!\n");
        IoCompleteRequest(pDbgIrp, IO_NO_INCREMENT);

        pDbgIrp = NULL;
    }

    CTEFreeLock(&DbgLock, LockHandle);
}
VOID
DbgMsg(CHAR *Format, ...)
{
    va_list         Args;
    CTELockHandle   LockHandle;
    CHAR            Temp[MAX_MSG_LEN];

    va_start(Args, Format);

    vsprintf(Temp, Format, Args);

    if (DbgOutput & DBG_OUTPUT_DEBUGGER)
    {
        DbgPrint("RASPPTP: ");
        DbgPrint(Temp);
    }

    if (DbgOutput & DBG_OUTPUT_BUFFER)
    {
        CTEGetLock(&DbgLock, &LockHandle);

        strcpy(DbgMsgs[Last], Temp);

        Last++;

        if (Last == DBG_MSG_CNT)
            Last = 0;

        if (First == Last)
        {
            First++;
            if (First == DBG_MSG_CNT)
                First = 0;
        }

        if (pDbgIrp && !TimerRunning)
        {
            CTEStartTimer(&DbgTimer, DBG_TIMER_INTERVAL,
                      DbgTimerExp, NULL);
            TimerRunning = TRUE;
        }

        CTEFreeLock(&DbgLock, LockHandle);
    }

    va_end(Args);
}

NTSTATUS
FillDbgIrp(UCHAR Msg[])
{
    NTSTATUS Status = STATUS_PENDING;
    ULONG i;

    if ((IrpBufLen - IrpBufWritten) < MAX_MSG_LEN)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        Msg[MAX_MSG_LEN - 1] = 0; // just to be sure

        i = 0;

        while (1)
        {
            IrpBuf[IrpBufWritten++] = Msg[i];

            if (Msg[i] == 0)
                break;
            i++;
        }
    }

    return Status;
}

VOID CancelDbgIrp(
    PDEVICE_OBJECT DeviceObject,
    PIRP pIrp)
{
//    DbgPrint("CancelDbgIrp %x\n", pIrp);

    pDbgIrp = NULL;

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    pIrp->IoStatus.Status = STATUS_CANCELLED;
    pIrp->IoStatus.Information = 0;

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

NTSTATUS
DbgMsgIrp(
    PIRP                pIrp,
    PIO_STACK_LOCATION  pIrpSp)
{
    CTELockHandle   LockHandle;
    NTSTATUS        Status = STATUS_PENDING;

    if (pDbgIrp != NULL)
        return STATUS_DEVICE_BUSY;

    CTEGetLock(&DbgLock, &LockHandle);

    IrpBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    IrpBufWritten = 0;

    if (IrpBufLen < MAX_MSG_LEN)
    {
        CTEFreeLock(&DbgLock, LockHandle);
        return STATUS_BUFFER_OVERFLOW;
    }

    IrpBuf = pIrp->AssociatedIrp.SystemBuffer;

    while (First != Last)
    {
        Status = FillDbgIrp(DbgMsgs[First]);

        if (Status == STATUS_SUCCESS)
            break;

        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }


    if (Status == STATUS_SUCCESS)
    {
        pIrp->IoStatus.Information = IrpBufWritten;
    }
    else if (Status == STATUS_PENDING)
    {
        KIRQL           Irql;
        PDRIVER_CANCEL  PrevCancel;

        pDbgIrp = pIrp;

        IoMarkIrpPending(pIrp);

        IoAcquireCancelSpinLock(&Irql);

        PrevCancel = IoSetCancelRoutine(pIrp, CancelDbgIrp);

        CTEAssert(PrevCancel == NULL);

        IoReleaseCancelSpinLock(Irql);

        if (IrpBufWritten != 0)
        {
            CTEStartTimer(&DbgTimer, DBG_TIMER_INTERVAL,
                      DbgTimerExp, NULL);

            TimerRunning = TRUE;
        }
    }

    CTEFreeLock(&DbgLock, LockHandle);

    //DbgPrint("DbgIrp status %x, bw %d, irp %x\n", Status, IrpBufWritten, pIrp);
    return Status;
}

VOID
DbgTimerExp(CTEEvent *Event, void *Arg)
{
    CTELockHandle   LockHandle;
    PIRP            pIrp;
    KIRQL           Irql;

//DbgPrint("Texp\n");

    if (pDbgIrp == NULL)
    {
        DbgPrint("DbgIrp is null\n");
        return;
    }

    IoAcquireCancelSpinLock(&Irql);

    IoSetCancelRoutine(pDbgIrp, NULL);

    IoReleaseCancelSpinLock(Irql);

    if (pDbgIrp->Cancel)
    {
        DbgPrint("DbgIrp is being canceled\n");
        pDbgIrp = NULL;
        return;
    }


    CTEGetLock(&DbgLock, &LockHandle);

    TimerRunning = FALSE;

    while (First != Last)
    {
        if (FillDbgIrp(DbgMsgs[First]) == STATUS_SUCCESS)
            break;

        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }

    pIrp = pDbgIrp;

    pDbgIrp = NULL;

    CTEFreeLock(&DbgLock, LockHandle);

    pIrp->IoStatus.Information = IrpBufWritten;
    pIrp->IoStatus.Status = STATUS_SUCCESS;

  //  DbgPrint("Comp bw %d, irp %x\n", IrpBufWritten, pIrp);

    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
}

VOID DbgMemory(PVOID pMemory, ULONG Length, ULONG WordSize)
{
    ULONG i, j;
    UCHAR AsciiData[17];

    for (i=0; i<Length; )
    {
        DbgMsg("%08x: ", pMemory);
        for (j=0; j<16 && i+j<Length; j++)
        {
            AsciiData[j] = CharTable[((PUCHAR)pMemory)[j]];
        }
        AsciiData[j] = '\0';
        for (j=0; j<16; j+=WordSize, i+=WordSize)
        {
            if (i<Length)
            {
                switch (WordSize)
                {
                    case 1:
                        DbgMsg("%02x ", *(PUCHAR)pMemory);
                        break;
                    case 2:
                        DbgMsg("%04x ", *(PUSHORT)pMemory);
                        break;
                    case 4:
                        DbgMsg("%08x ", *(PULONG)pMemory);
                        break;
                }
            }
            else
            {
                DbgMsg("%*s ", WordSize*2, "");
            }
            pMemory = (PUCHAR)pMemory + WordSize;
        }
        DbgMsg("   %s\n", AsciiData);
    }
}

VOID DbgRegInit(PUNICODE_STRING pRegistryPath, ULONG DefaultDebug)
{
    struct {
        KEY_VALUE_PARTIAL_INFORMATION Value;
        ULONG_PTR Filler;
    } DwordValue;
    ULONG InformationLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hReg;
    NTSTATUS Status;
    UNICODE_STRING DbgSettingsString =  UNICODE_STRING_CONST("DbgSettings");
    UNICODE_STRING DbgOutputString =    UNICODE_STRING_CONST("DbgOutput");
    UNICODE_STRING PromptString =       UNICODE_STRING_CONST("Prompt");

    InitializeObjectAttributes(&ObjectAttributes,
                               pRegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwOpenKey(&hReg, MAXIMUM_ALLOWED, &ObjectAttributes);

    if (Status==STATUS_SUCCESS)
    {
        Status = ZwQueryValueKey(hReg,
                                 &DbgSettingsString,
                                 KeyValuePartialInformation,
                                 &DwordValue,
                                 sizeof(DwordValue),
                                 &InformationLength);
        if (Status==STATUS_SUCCESS)
        {
            DbgSettings = *(PULONG)DwordValue.Value.Data;
        }
        else
        {
            DbgSettings = DefaultDebug;
        }

        Status = ZwQueryValueKey(hReg,
                                 &DbgOutputString,
                                 KeyValuePartialInformation,
                                 &DwordValue,
                                 sizeof(DwordValue),
                                 &InformationLength);
        if (Status==STATUS_SUCCESS)
        {
            DbgOutput = *(PULONG)DwordValue.Value.Data;
        }

        Status = ZwQueryValueKey(hReg,
                                 &PromptString,
                                 KeyValuePartialInformation,
                                 &DwordValue,
                                 sizeof(DwordValue),
                                 &InformationLength);
        if (Status==STATUS_SUCCESS && DwordValue.Value.Data[0])
        {
            char Response[2];
            BOOLEAN ValidChar;
            extern ULONG AbortLoad;
            extern ULONG
            DbgPrompt(
                IN PCHAR Prompt,
                OUT PCHAR Response,
                IN ULONG MaximumResponseLength
                );
            do
            {
                ValidChar = TRUE;
                DbgPrompt("RASPPTP: Debugging: Full, Default, Minimal, Abort load, Break (FDMAB)? ",
                          Response, sizeof(Response));
                switch (Response[0])
                {
                    case 'A': case 'a':
                        AbortLoad = TRUE;
                        break;
                    case 'B': case 'b':
                        DbgBreakPoint();
                        break;
                    case 'M': case 'm':
                        DbgSettings = DBG_ERROR|DBG_WARN;
                        break;
                    case 'D': case 'd':
                        // Default already set.  Leave untouched.
                        break;
                    case 'F': case 'f':
                        DbgSettings  =
                            DBG_ERROR |
                            DBG_WARN |
                            DBG_FUNC |
                            DBG_INIT |
                            DBG_TX |
                            DBG_RX |
                            DBG_TDI |
                            DBG_TUNNEL |
                            DBG_CALL |
                            DBG_NDIS |
                            DBG_TAPI |
                            DBG_THREAD |
                            DBG_REF |
                            0;
                        break;
                    default:
                        ValidChar = FALSE;
                        break;
                }

            } while ( !ValidChar );
        }
        ZwClose(hReg);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\pptpkdx\pptpkdx.c ===
#define SRVDBG 1
#define SRVKD 1
#define NDIS40_MINIPORT 1
#define NDIS_MINIPORT_DRIVER 1
#define NT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <wdbgexts.h>
#include <stdlib.h>

#include <raspptp.h>
#include <bpool.h>

typedef struct CTDI_DATA *PCTDI_DATA;

typedef struct CTDI_DATA {
    LIST_ENTRY                      ListEntry;
    ULONG                           Signature;
    ULONG                           Type;
    REFERENCE_COUNT                 Reference;
    HANDLE                          hFile;
    PFILE_OBJECT                    pFileObject;
    NDIS_SPIN_LOCK                  Lock;
    BOOLEAN                         Closed;

    CTDI_EVENT_CONNECT_QUERY        ConnectQueryCallback;
    CTDI_EVENT_CONNECT_COMPLETE     ConnectCompleteCallback;
    CTDI_EVENT_DISCONNECT           DisconnectCallback;
    CTDI_EVENT_RECEIVE              RecvCallback;
    PVOID                           RecvContext;
    CTDI_EVENT_RECEIVE_DATAGRAM     RecvDatagramCallback;
    CTDI_EVENT_SEND_COMPLETE        SendCompleteCallback;
    CTDI_EVENT_QUERY_COMPLETE       QueryCompleteCallback;
    CTDI_EVENT_SET_COMPLETE         SetCompleteCallback;

    union {
        struct {
            PVOID                   Context;
            LIST_ENTRY              ConnectList;
            ULONG                   NumConnection;
        } Listen;
        struct {
            PVOID                   Context;
            PCTDI_DATA              LocalEndpoint;
            PVOID                   ConnectInfo;
            TA_IP_ADDRESS           RemoteAddress;
            LIST_ENTRY              ListEntry;
            ULONG                   DisconnectCount;
            union {
                BOOLEAN             Disconnect;
                ULONG_PTR           Padding1;
            };
            union {
                BOOLEAN             Abort;
                ULONG_PTR           Padding2;
            };
        } Connection;
        struct {
            BUFFERPOOL              RxPool;
        } Datagram;
    };
} CTDI_DATA, *PCTDI_DATA;

#define CTDI_UNKNOWN            'NKNU'
#define CTDI_ENDPOINT           'PDNE'
#define CTDI_DATAGRAM           'MRGD'
#define CTDI_LISTEN             'TSIL'
#define CTDI_CONNECTION         'NNOC'


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


typedef struct
{
    char    Name[16];
    int     Val;
} DBG_LEVEL;



/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG)((ULONG_PTR) pStr->Buffer),
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN DWORD_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN DWORD dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !GetData( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (DWORD_PTR)ListEntry.Flink == dwListHeadAddr || (DWORD_PTR)ListEntry.Flink == 0 )
            break;

        if( !GetData( &ListEntry, (DWORD_PTR)ListEntry.Flink, (ULONG)sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (DWORD_PTR)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (DWORD_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}



/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}


/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN DWORD_PTR dwAddress, IN LPSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static unsigned char *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

DECLARE_API( help )
{
    int i;

    dprintf("PPTP extenstions:\n");

    dprintf("   version\n");
    dprintf("   ctdi                        dump tdi handles\n");
    dprintf("   calls [start [end]]         dump call handles\n");
    dprintf("   ctls                        dump ctl handles\n");
    dprintf("   dbgmsgs                     dump debug log\n");
    dprintf("   mem                         dump allocations\n");
}

DECLARE_API( dbgmsgs )
{
    DWORD   p;
    DWORD   Last, First;
    char    DbgMsg[MAX_MSG_LEN];
    ULONG   Read;
    char    *DbgMsgs;

    if (!GetData(&Last,
                 GetExpression("raspptp!Last"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }


    if (!GetData(&First,
                 GetExpression("raspptp!First"),
                 sizeof(Last), "DWORD"))
    {
        dprintf("error\n");
        return;
    }



    DbgMsgs = (char *) GetExpression("raspptp!dbgmsgs");

    dprintf("\n\n");

    while (First != Last)
    {
       if (!GetString((DWORD_PTR) (DbgMsgs + First * MAX_MSG_LEN),
                  DbgMsg, MAX_MSG_LEN))
            break;
        /*
        ReadMemory((ULONG) (DbgMsgs + First * MAX_MSG_LEN),
                    DbgMsg, MAX_MSG_LEN, &Read); */
        dprintf("%s", DbgMsg);
        First++;
        if (First == DBG_MSG_CNT)
            First = 0;
    }
}

DECLARE_API( ctdi )
{
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG Count = 20;
    char argbuf[ MAX_PATH ];

    ListHead = (PLIST_ENTRY)GetExpression("raspptp!CtdiList");

    if (!GetData(&ListEntry,
                 (ULONG_PTR)ListHead,
                 sizeof(LIST_ENTRY),
                 "LIST_ENTRY"))
    {
        dprintf("error\n");
        return;
    }

    while (Count-- && ListHead!=ListEntry.Flink)
    {
        CTDI_DATA Ctdi;
        UCHAR TypeStr[sizeof(ULONG)+1];
        if (!GetData(&Ctdi,
                     (ULONG_PTR)ListEntry.Flink,
                     sizeof(CTDI_DATA),
                     "CTDI_DATA"))
        {
            dprintf("error\n");
            return;
        }
        memcpy(TypeStr, &Ctdi.Type, sizeof(ULONG));
        TypeStr[sizeof(ULONG)] = 0;

        dprintf("CTDI:%08x Sig:%08x  Type:%s  Refs:%d  Handle:%08x  FileObj:%08x  Closed:%d\n",
                ListEntry.Flink, Ctdi.Signature, TypeStr, Ctdi.Reference.Count, Ctdi.hFile, Ctdi.pFileObject, Ctdi.Closed);
        switch (Ctdi.Type)
        {
            case CTDI_CONNECTION:
                dprintf("      Context:%08x  Endpoint:%08x  Disconnect/Abort:%x/%x\n",
                        Ctdi.Connection.Context, Ctdi.Connection.LocalEndpoint,
                        Ctdi.Connection.Disconnect, Ctdi.Connection.Abort);
                break;
            case CTDI_LISTEN:
                dprintf("      Context:%08x  NumConn:%d\n",
                        Ctdi.Listen.Context, Ctdi.Listen.NumConnection);
                break;
            default:
                break;
        }
        ListEntry = Ctdi.ListEntry;
    }
}

typedef struct MEM_HDR {
    LIST_ENTRY  ListEntry;
    ULONG       Size;
    CHAR        File[12];
    ULONG       Line;
} MEM_HDR;

DECLARE_API( mem )
{
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    ULONG TotalMem = 0;
    char argbuf[ MAX_PATH ];

    ListHead = (PLIST_ENTRY)GetExpression("raspptp!leAlloc");

    if (!GetData(&ListEntry,
                 (ULONG_PTR)ListHead,
                 sizeof(LIST_ENTRY),
                 "LIST_ENTRY"))
    {
        dprintf("error\n");
        return;
    }

    while (ListHead!=ListEntry.Flink)
    {
        MEM_HDR Mem;
        UCHAR TypeStr[sizeof(ULONG)+1];
        if (!GetData(&Mem,
                     (ULONG_PTR)ListEntry.Flink,
                     sizeof(MEM_HDR),
                     "MEM_HDR"))
        {
            dprintf("error\n");
            return;
        }

        dprintf("MEM:%08x  Len:%5d  File:%-15s  Line:%d\n",
                ListEntry.Flink, Mem.Size, Mem.File, Mem.Line);
        TotalMem += Mem.Size;
        ListEntry = Mem.ListEntry;
    }
    dprintf("MEM: Total %d bytes\n", TotalMem);
}

PUCHAR CallState[] =
{
    "STATE_CALL_INVALID",
    "STATE_CALL_CLOSED",
    "STATE_CALL_IDLE",
    "STATE_CALL_OFFHOOK",
    "STATE_CALL_OFFERING",
    "STATE_CALL_PAC_OFFERING",
    "STATE_CALL_PAC_WAIT",
    "STATE_CALL_DIALING",
    "STATE_CALL_PROCEEDING",
    "STATE_CALL_ESTABLISHED",
    "STATE_CALL_WAIT_DISCONNECT",
    "STATE_CALL_CLEANUP"
};

DECLARE_API( calls )
{
    PPTP_ADAPTER Adapter;
    CALL_SESSION Call;
    ULONG_PTR pCall;
    ULONG_PTR gAdapter = GetExpression("raspptp!pgAdapter");
    ULONG i, StartCall=0, EndCall=0xffff;
    char argbuf[MAX_PATH];
    char arglist[2][MAX_PATH];

    if (args && *args)
    {
        char                   *p;

        strcpy(argbuf, args);

        i = 0;
        //parsing the arguments
        for (p = mystrtok( argbuf, " \t,;" );
         p && *p && i<2;
         p = mystrtok(NULL, " \t,;"))
        {
         strcpy(&arglist[i++][0],p);
        }
        if (i>0)
        {
            StartCall = EndCall = atoi(arglist[0]);
        }
        if (i>1)
        {
            EndCall = atoi(arglist[1]);
        }
    }

    if (!GetData(&gAdapter,
                 gAdapter,
                 sizeof(gAdapter),
                 "PPTP_ADAPTER*"))
    {
        dprintf("error\n");
        return;
    }
    if (!gAdapter)
    {
        dprintf("no adapter\n");
        return;
    }
    if (!GetData(&Adapter,
                 gAdapter,
                 sizeof(Adapter),
                 "PPTP_ADAPTER"))
    {
        dprintf("error\n");
        return;
    }

    dprintf("Adapter:%08x  %d calls\n", gAdapter, Adapter.Info.Endpoints);
    for (i=StartCall; i<Adapter.Info.Endpoints && i<=EndCall; i++)
    {
        if (!GetData(&pCall,
                     ((ULONG_PTR)Adapter.pCallArray)+i*sizeof(ULONG_PTR),
                     sizeof(pCall),
                     "CALL_SESSION*"))
        {
            dprintf("error\n");
            return;
        }
        if (pCall)
        {
            if (!GetData(&Call,
                         pCall,
                         sizeof(Call),
                         "CALL_SESSION"))
            {
                dprintf("error\n");
                return;
            }
            dprintf("Call %d:%08x  Ctl:%08x  State:%s  Inbound:%d  Open:%d\n",
                    i, pCall, Call.pCtl, CallState[Call.State], Call.Inbound, Call.Open);
            dprintf("        htLine:%08x  htCall:%08x  DeviceId:%d  SN:%d  Link:%08x\n",
                    Call.hTapiLine, Call.hTapiCall, Call.DeviceId,  Call.SerialNumber, Call.NdisLinkContext);
            dprintf("        Remote->ID:%04x  Seq:%08x  Ack:%08x  Addr:%08x\n",
                    Call.Remote.CallId,
                    Call.Remote.SequenceNumber,
                    Call.Remote.AckNumber,
                    Call.Remote.Address.Address[0].Address[0].in_addr);
            dprintf("        Packet->ID:%04x  Seq:%08x  Ack:%08x\n",
                    Call.Packet.CallId,
                    Call.Packet.SequenceNumber,
                    Call.Packet.AckNumber);
            dprintf("        Close->Expedited:%d  Checklist:%x\n",
                    Call.Close.Expedited, Call.Close.Checklist);
        }
        else
        {
            dprintf("Call %d:freed\n", i);
        }
    }
}

PUCHAR CtlState[] =
{
    "STATE_CTL_INVALID",
    "STATE_CTL_LISTEN",
    "STATE_CTL_DIALING",
    "STATE_CTL_WAIT_REQUEST",
    "STATE_CTL_WAIT_REPLY",
    "STATE_CTL_ESTABLISHED",
    "STATE_CTL_WAIT_STOP",
    "STATE_CTL_CLEANUP"
};

DECLARE_API( ctls )
{
    PPTP_ADAPTER Adapter;
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    char argbuf[ MAX_PATH ];
    ULONG_PTR gAdapter = GetExpression("raspptp!pgAdapter");

    if (!GetData(&gAdapter,
                 gAdapter,
                 sizeof(gAdapter),
                 "PPTP_ADAPTER*"))
    {
        dprintf("error\n");
        return;
    }
    if (!gAdapter)
    {
        dprintf("no adapter\n");
        return;
    }
    if (!GetData(&Adapter,
                 gAdapter,
                 sizeof(Adapter),
                 "PPTP_ADAPTER"))
    {
        dprintf("error\n");
        return;
    }

    ListHead = (PLIST_ENTRY)(((ULONG_PTR)&Adapter.ControlTunnelList) - ((ULONG_PTR)&Adapter) + gAdapter);
    ListEntry = Adapter.ControlTunnelList;

    while (ListHead!=ListEntry.Flink)
    {
        CONTROL_TUNNEL Ctl;
        if (!GetData(&Ctl,
                     (ULONG_PTR)ListEntry.Flink,
                     sizeof(CONTROL_TUNNEL),
                     "CONTROL_TUNNEL"))
        {
            dprintf("error\n");
            return;
        }

        dprintf("CTL:%08x  Sig:%08x  State:%s  Refs:%d  Cleanup:%x  Inbound:%d\n",
                ListEntry.Flink, Ctl.Signature, CtlState[Ctl.State], Ctl.Reference.Count, Ctl.Cleanup, Ctl.Inbound);
        ListEntry = Ctl.ListEntry;
    }
}

VOID
DumpIrpList(LIST_ENTRY *pIrpList)
{
    LIST_ENTRY          IrpList, *pListEntry, ListEntry;
    IRP                 *pIrp;

    if (!GetData(&IrpList,
                 (DWORD_PTR) pIrpList,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
    {
        return;
    }

    for (pListEntry = IrpList.Flink;
         pListEntry != pIrpList;
         pListEntry = ListEntry.Flink)
    {

        if (!GetData(&ListEntry,
                 (DWORD_PTR) pListEntry,
                 sizeof(LIST_ENTRY), "LIST_ENTRY"))
        {
            return;
        }

        pIrp = CONTAINING_RECORD(pListEntry, IRP, Tail.Overlay.ListEntry);

        dprintf("  %x\n", pIrp);
    }
}

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s SMB Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\nt\dbgapi.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   DBGAPI.H - NT specific debugging macros, etc.
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/3/1998
*
*****************************************************************************/
#ifndef DBGAPI_H
#define DBGAPI_H

#define DBG_MSG_CNT         512
#define MAX_MSG_LEN         128
#define DBG_TIMER_INTERVAL  400

extern ULONG DbgSettings;

#define DBG_OUTPUT_DEBUGGER     1
#define DBG_OUTPUT_BUFFER       2



#define DEBUGZONE(bit)    (1<<(bit))

#define DBG_BREAK       DEBUGZONE(31)

#if DBG

#define DEBUGMSG(dbgs,format)                               \
    if ((dbgs)&DbgSettings)                                 \
    {                                                       \
        DbgMsg format;                                      \
        if ((dbgs)&DbgSettings&DBG_BREAK)                   \
        {                                                   \
            DbgBreakPoint();                                \
        }                                                   \
    }

#define DEBUGMEM(dbgs, data, length, size)                  \
    if ((dbgs)&DbgSettings)                                 \
    {                                                       \
        DbgMemory((data), (length), (size));                \
    }


VOID        DbgMsgInit();
VOID        DbgMsgUninit();
VOID        DbgMsg(CHAR *Format, ...);
NTSTATUS    DbgMsgIrp(PIRP pIrp, PIO_STACK_LOCATION  pIrpSp);
VOID        DbgMemory(PVOID pMemory, ULONG Length, ULONG WordSize);
VOID        DbgRegInit(PUNICODE_STRING pRegistryPath, ULONG DefaultDebug);

#define DEFAULT_DEBUG_OPTIONS(x)        \
    {                                   \
        DbgRegInit(pRegistryPath, (x)); \
    }


#else

#define RETAILMSG(cond,printf_exp) 0
#define DEBUGMSG(cond,printf_exp) 0
#define DBGCHK(module,exp) 0
#define DEBUGCHK(exp) 0
#define DEBUGREGISTER(hMod) 0

#define DbgMsgInit()    0
#define DbgMsgUninit()  0
#define DEFAULT_DEBUG_OPTIONS(x)
#define DEBUGMEM(dbgs, data, length, size) 0

#endif

#define DTEXT

#endif //DBGAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\nt\osinc.h ===
/*****************************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*   OSINC.H - includes OS specific headers
*
*   Author:     Stan Adermann (stana)
*
*   Created:    9/2/1998
*
*****************************************************************************/

#ifndef OSINC_H
#define OSINC_H

#define BINARY_COMPATIBLE 0

#include <ntddk.h>

#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include <ntverp.h>

#define PPTP_VENDOR "Microsoft Windows NT"

#define PPTP_FIRMWARE_REVISION VER_PRODUCTBUILD

#define TAPI_LINE_NAME_STRING       "RAS VPN Line"
extern ANSI_STRING TapiLineName;
#define TAPI_PROVIDER_STRING        "VPN\0RASPPTP"
#define TAPI_DEV_CAPS_SIZE          (sizeof(TAPI_PROVIDER_STRING)+ \
                                     TapiLineName.Length + sizeof(UCHAR) * 6 +\
                                     sizeof(NDIS_TAPI_GET_DEV_CAPS))

#define TAPI_LINE_ADDR_STRING       "PPTP VPN"

#define OS_SPECIFIC_NDIS_WAN_MEDIUM_TYPE NdisWanMediumPPTP
// OS_CONNECTION_WRAPPER_ID should only be used in one location, TapiLineUp()
#define OS_CONNECTION_WRAPPER_ID ((NDIS_HANDLE) pCall->hTapiCall)

// Other OS's that don't risk blowing the stack or don't have this mechanism
// should just define this TRUE or FALSE.
#define OS_COMPLETE_SEND_NOW(Call)   (IoGetRemainingStackSize()>1024)


//
// NDIS version compatibility.
//

#define NDIS_MAJOR_VERSION 4
#define NDIS_MINOR_VERSION 0



#define OS_RANGE_CHECK_ENDPOINTS(ep)    \
    if ((unsigned)(ep)>(1<<CALL_ID_INDEX_BITS))            \
    {                                   \
        (ep) = (1<<CALL_ID_INDEX_BITS);                    \
    }
    // 4096 because we use 12 bits for the call id.

#define OS_RANGE_CHECK_MAX_TRANSMIT(mt) \
    if ((unsigned)(mt)<1) (mt) = 1;     \
    if ((unsigned)(mt)>1024) (mt) = 1024;

#define OS_DEFAULT_WAN_ENDPOINTS 5
#define OS_LISTENS_PENDING 5

#define LOGHDRS    ":::%d:%08x:%08x:%d.%d.%d.%d:"

#define LOGHDR(id, ip) (id), Time.HighPart, Time.LowPart, IPADDR(ip)


typedef VOID    (*WORK_PROC)(struct _PPTP_WORK_ITEM *);

typedef struct _PPTP_WORK_ITEM
{
    LIST_ENTRY          ListEntry;
    WORK_PROC           Callback;
    PVOID               Context;
    PVOID               pBuffer;
    ULONG               Length;
} PPTP_WORK_ITEM, *PPPTP_WORK_ITEM;

#ifndef PPTP_DPC_USES_NDIS
#define PPTP_DPC_USES_NDIS 0
#endif
#if PPTP_DPC_USES_NDIS

// WARNING:  There's a difference in behavior between NdisMSetTimer and
// KeInsertQueueDpc.  NdisMSetTimer resets the timer if it's already
// queued, KeInsertQueueDpc does not.
// We purposely wrote the code that uses these macros
// to be agnostic about this behavior.  Anyone using these macros should
// study how they are used here to avoid problems with them.

#define PPTP_DPC NDIS_MINIPORT_TIMER
#define PptpInitializeDpc(Dpc, hAdapter, DeferredRoutine, DeferredContext) \
        NdisMInitializeTimer((Dpc), (hAdapter), (PNDIS_TIMER_FUNCTION)(DeferredRoutine), (DeferredContext))
#define PptpQueueDpc(Dpc) NdisMSetTimer((Dpc), 1)
#define PptpCancelDpc(Dpc, pCancelled) NdisMCancelTimer((Dpc), (pCancelled))

#else

#define PPTP_DPC KDPC
#define PptpInitializeDpc(Dpc, AdapterHandle, DeferredRoutine, DeferredContext) \
        KeInitializeDpc((Dpc), (PKDEFERRED_ROUTINE)(DeferredRoutine), (DeferredContext))
#define PptpQueueDpc(Dpc) \
        {                                               \
            ASSERT(KeGetCurrentIrql()>=DISPATCH_LEVEL); \
            KeInsertQueueDpc((Dpc), NULL, NULL);        \
        }
#define PptpCancelDpc(Dpc, pCancelled) KeRemoveQueueDpc(Dpc)    \
        {                                                       \
            *(PBOOLEAN)(pCancelled) = KeRemoveQueueDpc(Dpc);    \
        }

#endif

typedef
VOID
(*PPPTP_DPC_FUNCTION) (
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   FunctionContext,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    );


#define ASSERT_LOCK_HELD(pNdisLock) ASSERT(KeNumberProcessors==1 || (pNdisLock)->SpinLock!=0)

#ifndef VER_PRODUCTVERSION_W
#error "No VER_PRODUCTVERSION_W"
#endif
#if VER_PRODUCTVERSION_W < 0x0400
#error "VER_PRODUCTVERSION_W < 0x0400"
#endif

#if VER_PRODUCTVERSION_W < 0x0500

// Recreate all the stuff in NT5 that didn't exist in NT4.

typedef ULONG ULONG_PTR, *PULONG_PTR;

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))
#endif

//
//  PnP and PM OIDs
//
#ifndef OID_PNP_CAPABILITIES
#define OID_PNP_CAPABILITIES                    0xFD010100
#endif
#ifndef OID_PNP_SET_POWER
#define OID_PNP_SET_POWER                       0xFD010101
#endif
#ifndef OID_PNP_QUERY_POWER
#define OID_PNP_QUERY_POWER                     0xFD010102
#endif
#ifndef OID_PNP_ADD_WAKE_UP_PATTERN
#define OID_PNP_ADD_WAKE_UP_PATTERN             0xFD010103
#endif
#ifndef OID_PNP_REMOVE_WAKE_UP_PATTERN
#define OID_PNP_REMOVE_WAKE_UP_PATTERN          0xFD010104
#endif
#ifndef OID_PNP_WAKE_UP_PATTERN_LIST
#define OID_PNP_WAKE_UP_PATTERN_LIST            0xFD010105
#endif
#ifndef OID_PNP_ENABLE_WAKE_UP
#define OID_PNP_ENABLE_WAKE_UP                  0xFD010106
#endif
#ifndef OID_GEN_SUPPORTED_GUIDS
#define OID_GEN_SUPPORTED_GUIDS                 0x00010117
#endif
#ifndef NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND
#define NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND       0 // So it can't mess up NDIS
#endif
typedef enum _NDIS_DEVICE_POWER_STATE
{
    NdisDeviceStateUnspecified = 0,
    NdisDeviceStateD0,
    NdisDeviceStateD1,
    NdisDeviceStateD2,
    NdisDeviceStateD3,
    NdisDeviceStateMaximum
} NDIS_DEVICE_POWER_STATE, *PNDIS_DEVICE_POWER_STATE;
typedef struct _NDIS_PM_WAKE_UP_CAPABILITIES
{
    NDIS_DEVICE_POWER_STATE MinMagicPacketWakeUp;
    NDIS_DEVICE_POWER_STATE MinPatternWakeUp;
    NDIS_DEVICE_POWER_STATE MinLinkChangeWakeUp;
} NDIS_PM_WAKE_UP_CAPABILITIES, *PNDIS_PM_WAKE_UP_CAPABILITIES;
typedef struct _NDIS_PNP_CAPABILITIES
{
    ULONG                           Flags;
    NDIS_PM_WAKE_UP_CAPABILITIES    WakeUpCapabilities;
} NDIS_PNP_CAPABILITIES, *PNDIS_PNP_CAPABILITIES;

#define NdisWanMediumPPTP NdisWanMediumSerial

#endif


#endif //OSINC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\bpool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.c
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool );

VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag )

    // Initialize caller's buffer pool control block 'pPool'.  'UlBufferSize'
    // is the size in bytes of an individual buffer.  'UlMaxBuffers' is the
    // maximum number of buffers allowed in the entire pool or 0 for
    // unlimited.  'UlBuffersPerBlock' is the number of buffers to include in
    // each block of buffers.  'UlFreesPerCollection' is the number of
    // FreeBufferToPool calls until the next garbage collect scan, or 0 for
    // default.  'FAssociateNdisBuffer' is set if an NDIS_BUFFER should be
    // allocated and associated with each individual buffer.  'UlTag' is the
    // memory identification tag to use when allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' buffer must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulBufferSize = ulBufferSize;
    pPool->ulMaxBuffers = ulMaxBuffers;
    pPool->ulBuffersPerBlock = ulBuffersPerBlock;
    pPool->ulFreesSinceCollection = 0;
    pPool->fAssociateNdisBuffer = fAssociateNdisBuffer;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 50 * pPool->ulBuffersPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitBp tag=$%08x buf=%d cnt=%d",
        pPool->ulTag, pPool->ulBufferSize, pPool->ulBuffersPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreeBuffers );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool )

    // Free up all resources allocated in buffer pool 'pPool'.  This is the
    // inverse of InitBufferPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreeBp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedBufferPoolBlocks( pPool );
        fSuccess = (pPool->ulCurBuffers == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool )

    // Returns the address of the useable memory in an individual buffer
    // allocated from the pool 'pPool'.  The pool is expanded, if necessary,
    // but caller should still check for NULL return since the pool may have
    // been at maximum size.
    //
{
    LIST_ENTRY* pLink;
    BUFFERHEAD* pHead;
    CHAR* pBuffer;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreeBuffers ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreeBuffers );
            pHead = CONTAINING_RECORD( pLink, BUFFERHEAD, linkFreeBuffers );
            --pHead->pBlock->ulFreeBuffers;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (pLink)
    {
        pBuffer = (CHAR* )(pHead + 1);
    }
    else
    {
        // The free list was empty.  Try to expand the pool.
        //
        pBuffer = AddBufferBlockToPool( pPool );
    }

    DBG_if (pBuffer)
    {
        pHead = (BUFFERHEAD* )(pBuffer - sizeof(BUFFERHEAD));
        TRACE( TL_N, TM_Pool, ( "GetBfp=$%p, %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers ) );
    }
    DBG_else
    {
        TRACE( TL_A, TM_Pool, ( "GetBfp failed?" ) );
    }

    return pBuffer;
}


VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pBuffer' to the pool of unused buffers 'pPool'.  'PBuffer'
    // must have been previously allocated with GetBufferFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddBufferToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;

    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool, ( "FreeBtoP($%0x) %d free",
            pBuffer, pHead->pBlock->ulFreeBuffers + 1 ) );
    }


    NdisAcquireSpinLock( &pPool->lock );
    {
        InsertHeadList( &pPool->listFreeBuffers, &pHead->linkFreeBuffers );
        ++pHead->pBlock->ulFreeBuffers;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedBufferPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    NdisReleaseSpinLock( &pPool->lock );
}


NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the NDIS_BUFFER associated with the buffer 'pBuffer' which was
    // obtained previously with GetBufferFromPool.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pNdisBuffer;
}


ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer )

    // Returns the original size of the buffer 'pBuffer' which was obtained
    // previously with GetBufferFromPool.  This is useful for undoing
    // NdisAdjustBufferLength.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->pPool->ulBufferSize;
}


NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer )

    // Returns the handle of the pool from which the NDIS_BUFFER associated
    // with the buffer 'pBuffer' was obtained.  Caller may use the handle to
    // pass to NdisCopyBuffer, one such use per buffer at a time.
    //
{
    BUFFERHEAD* pHead;

    pHead = ((BUFFERHEAD* )pBuffer) - 1;
    return pHead->pBlock->hNdisPool;
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

CHAR*
AddBufferBlockToPool(
    IN BUFFERPOOL* pPool )

    // Allocate a new buffer block and add it to the buffer pool 'pPool'.
    //
    // Returns the address of the usable memory of an individual buffer
    // allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    BUFFERBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    BOOLEAN fAssociateNdisBuffer;
    CHAR* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddBpBlock(%d+%d)",
        pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        // Save this for reference after the lock is released.
        //
        fAssociateNdisBuffer = pPool->fAssociateNdisBuffer;

        do
        {
            if (pPool->ulMaxBuffers
                && pPool->ulCurBuffers >= pPool->ulMaxBuffers)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Bp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of buffers
            // it will hold.
            //
            ulCount = pPool->ulBuffersPerBlock;
            if (pPool->ulMaxBuffers)
            {
                if (ulCount > pPool->ulMaxBuffers - pPool->ulCurBuffers)
                    ulCount = pPool->ulMaxBuffers - pPool->ulCurBuffers;
            }
            ulSize = sizeof(BUFFERBLOCKHEAD) +
                (ulCount * (sizeof(BUFFERHEAD) + pPool->ulBufferSize));

            // Allocate the contiguous memory block for the BUFFERBLOCK header
            // and the individual buffers.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc BB?" ) );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(BUFFERBLOCKHEAD) );

            if (fAssociateNdisBuffer)
            {
                // Allocate a pool of NDIS_BUFFER descriptors.
                //
                // Twice as many descriptors are allocated as buffers so
                // caller can use the PoolHandleForNdisCopyBufferFromBuffer
                // routine to obtain a pool handle to pass to the
                // NdisCopyBuffer used to trim the L2TP header from received
                // packets.  In the current NDIS implmentation on NT this does
                // nothing but return a NULL handle and STATUS_SUCCESS,
                // because NDIS_BUFFER's are just MDL's,
                // NdisAllocateBufferPool is basically a no-op, and for that
                // matter, NdisCopyBuffer doesn't really use the pool handle
                // it's passed.  It's cheap to stay strictly compliant here,
                // though, so we do that.
                //
                NdisAllocateBufferPool(
                    &status, &pNew->hNdisPool, ulCount * 2 );
                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocBp=$%p?", status ) );
                    break;
                }
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the buffers are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulBuffers = ulCount;
            pPool->ulCurBuffers += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            FREE_NONPAGED( pNew );
            if (pNew->hNdisPool)
            {
                NdisFreeBufferPool( pNew->hNdisPool );
            }
        }

        return NULL;
    }

    // Initialize each individual buffer slice and add it to the list of free
    // buffers.
    //
    {
        ULONG i;
        CHAR* pBuffer;
        BUFFERHEAD* pHead;

        pReturn = NULL;

        // For each slice of the block, where a slice consists of a BUFFERHEAD
        // and the buffer memory that immediately follows it...
        //
        for (i = 0, pHead = (BUFFERHEAD* )(pNew + 1);
             i < ulCount;
             ++i, pHead = (BUFFERHEAD* )
                      ((CHAR* )(pHead + 1) + pPool->ulBufferSize))
        {
            pBuffer = (CHAR* )(pHead + 1);

            InitializeListHead( &pHead->linkFreeBuffers );
            pHead->pBlock = pNew;
            pHead->pNdisBuffer = NULL;

            if (fAssociateNdisBuffer)
            {
                // Associate an NDIS_BUFFER descriptor from the pool we
                // allocated above.
                //
                NdisAllocateBuffer(
                    &status, &pHead->pNdisBuffer, pNew->hNdisPool,
                    pBuffer, pPool->ulBufferSize );

                if (status != NDIS_STATUS_SUCCESS)
                {
                    TRACE( TL_A, TM_Pool, ( "AllocB=$%p?", status ) );
                    continue;
                }
            }

            if (pReturn)
            {
                // Add the constructed buffer to the list of free buffers.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreeBufferToPool( pPool, pBuffer, FALSE );
            }
            else
            {
                // The first successfully constructed buffer is returned by
                // this routine.
                //
                pReturn = pBuffer;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedBufferPoolBlocks(
    IN BUFFERPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedBpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        BUFFERBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, BUFFERBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreeBuffers >= pBlock->ulBuffers)
        {

#if 1 // Assume all buffers are free at time of call.

            ULONG i;
            BUFFERHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            // Found a block with no buffers in use.  Walk the buffer block
            // removing each buffer from the pool's free list and freeing any
            // associated NDIS_BUFFER descriptor.
            //
            for (i = 0, pHead = (BUFFERHEAD* )(pBlock + 1);
                 i < pBlock->ulBuffers;
                 ++i, pHead = (BUFFERHEAD* )
                      (((CHAR* )(pHead + 1)) + pPool->ulBufferSize))
            {
                RemoveEntryList( &pHead->linkFreeBuffers );

                if (pHead->pNdisBuffer)
                {
                    NdisFreeBuffer( pHead->pNdisBuffer );
                }
            }

#else  // Assume some buffers may not be free at time of call.

            LIST_ENTRY* pLink2;

            // Found a block with no buffers in use.  Walk the pool's free
            // list looking for buffers from this block.
            //
            TRACE( TL_A, TM_Pool, ( "FreeBpBlock(%d-%d)",
                pPool->ulCurBuffers, pPool->ulBuffersPerBlock ) );

            pLink2 = pPool->listFreeBuffers.Flink;
            while (pLink2 != &pPool->listFreeBuffers)
            {
                LIST_ENTRY* pLink2Next;
                BUFFERHEAD* pHead;

                pLink2Next = pLink2->Flink;

                pHead = CONTAINING_RECORD( pLink2, BUFFERHEAD, linkFreeBuffers );
                if (pHead->pBlock == pBlock)
                {
                    // Found a buffer from the unused block.  Remove it.
                    //
                    RemoveEntryList( pLink2 );
                    --pBlock->ulFreeBuffers;

                    if (pHead->pNdisBuffer)
                    {
                        NdisFreeBuffer( pHead->pNdisBuffer );
                    }
                }

                pLink2 = pLink2Next;
            }

            ASSERT( pBlock->ulFreeBuffers == 0 );
#endif

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            pPool->ulCurBuffers -= pBlock->ulBuffers;

            if (pBlock->hNdisPool)
            {
                NdisFreeBufferPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspptp\nt\thread.c ===
/*******************************************************************
*
*   Copyright (c) 1998-1999 Microsoft Corporation
*
*    DESCRIPTION: THREAD.C - Thread handling routines, for NT
*                 Also implements work items.
*
*    AUTHOR: Stan Adermann (StanA)
*
*    DATE:10/20/1998
*
*******************************************************************/

#include "raspptp.h"
#include <stdarg.h>
#include <stdio.h>

extern struct PPTP_ADAPTER * pgAdapter;

#define TX_ON_THREAD        BIT(0)
#define TX_DEFAULT          BIT(31)

ULONG TransmitPath = TX_ON_THREAD;
BOOLEAN TransmitRealtime = FALSE;

ULONG BuildEnv = VER_PRODUCTVERSION_DW;

#define AFFINITY_MASK(n) ((ULONG_PTR)1 << (n))

// from NTHAL.H
extern KAFFINITY
KeSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    );

HANDLE          hPassiveThread = NULL;
KEVENT          EventPassiveThread;
KEVENT          EventKillThread;
LIST_ENTRY      WorkItemList;
NDIS_SPIN_LOCK  GlobalThreadLock;

typedef struct {
    LIST_ENTRY      TransmitList;
    // List of calls with packets to transmit.

    KEVENT          WorkEvent;
    // Signal to process packets.

    KEVENT          KillEvent;
    // Signal to die

    NDIS_SPIN_LOCK  Lock;
    // Lock for this structure

    HANDLE          hThread;
    // Thread with affinity to this processor.

    UINT            Number;
    // 0 based index of this processor
} PROCESSOR, *PPROCESSOR;

PPROCESSOR Processor = NULL;

BOOLEAN ThreadingInitialized = FALSE;

NDIS_STATUS
ScheduleWorkItem(
    WORK_PROC         Callback,
    PVOID             Context,
    PVOID             InfoBuf,
    ULONG             InfoBufLen)
{
    PPPTP_WORK_ITEM pWorkItem;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    DEBUGMSG(DBG_FUNC, (DTEXT("+ScheduleWorkItem\n")));

    ASSERT(ThreadingInitialized);
    pWorkItem = MyMemAlloc(sizeof(PPTP_WORK_ITEM), TAG_WORK_ITEM);

    if (pWorkItem != NULL)
    {
        pWorkItem->Context      = Context;
        pWorkItem->pBuffer      = InfoBuf;
        pWorkItem->Length       = InfoBufLen;

        /*
        ** This interface was designed to use NdisScheduleWorkItem(), which
        ** would be good except that we're really only supposed to use that
        ** interface during startup and shutdown, due to the limited pool of
        ** threads available to service NdisScheduleWorkItem().  Therefore,
        ** instead of scheduling real work items, we simulate them, and use
        ** our own thread to process the calls.  This also makes it easy to
        ** expand the size of our own thread pool, if we wish.
        **
        ** Our version is slightly different from actual NDIS_WORK_ITEMs,
        ** because that is an NDIS 5.0 structure, and we want people to
        ** (at least temporarily) build this with NDIS 4.0 headers.
        */

        pWorkItem->Callback = Callback;

        /*
        ** Our worker thread checks this list for new jobs, whenever its event
        ** is signalled.
        */

        MyInterlockedInsertTailList(&WorkItemList,
                                    &pWorkItem->ListEntry,
                                    &GlobalThreadLock);

        // Wake up our thread.

        KeSetEvent(&EventPassiveThread, 0, FALSE);
        Status = NDIS_STATUS_SUCCESS;
    }

    return Status;
}

VOID
FreeWorkItem(
    PPPTP_WORK_ITEM pItem
    )
{
    MyMemFree((PVOID)pItem, sizeof(PPTP_WORK_ITEM));
}


STATIC VOID
MainPassiveLevelThread(
    IN OUT PVOID Context
    )
{
    NDIS_STATUS Status;
    NTSTATUS    NtStatus;
    PLIST_ENTRY pListEntry;
    PKEVENT EventList[2];

    DEBUGMSG(DBG_FUNC, (DTEXT("+MainPassiveLevelThread\n")));

    //KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    EventList[0] = &EventPassiveThread;
    EventList[1] = &EventKillThread;

    for (;;)
    {
        //
        // The EventPassiveThread is an auto-clearing event, so
        // we don't need to reset the event.
        //

        NtStatus = KeWaitForMultipleObjects(2,
                                            EventList,
                                            WaitAny,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL,
                                            NULL);

        if (NtStatus==0) // The first event, for a work item, was signalled
        {
            while (pListEntry = MyInterlockedRemoveHeadList(&WorkItemList,
                                                            &GlobalThreadLock))
            {
                PPPTP_WORK_ITEM pWorkItem = CONTAINING_RECORD(pListEntry,
                                                              PPTP_WORK_ITEM,
                                                              ListEntry);

                ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);
                pWorkItem->Callback(pWorkItem);
                ASSERT(KeGetCurrentIrql()<DISPATCH_LEVEL);
                FreeWorkItem(pWorkItem);
            }
        }
        else
        {
            // A kill event was received.

            DEBUGMSG(DBG_THREAD, (DTEXT("Thread: HALT %08x\n"), NtStatus));

            // Free any pending requests

            while (pListEntry = MyInterlockedRemoveHeadList(&WorkItemList,
                                                            &GlobalThreadLock))
            {
                PPPTP_WORK_ITEM pWorkItem = CONTAINING_RECORD(pListEntry,
                                                              PPTP_WORK_ITEM,
                                                              ListEntry);

                DEBUGMSG(DBG_WARN, (DTEXT("Releasing work item %08x\n"), pWorkItem));
                FreeWorkItem(pWorkItem);
            }

            hPassiveThread = NULL;
            DEBUGMSG(DBG_FUNC, (DTEXT("PsTerminateSystemThread MainPassiveLevelThread\n")));
            PsTerminateSystemThread(STATUS_SUCCESS);

            break;
        }
    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-MainPassiveLevelThread\n")));
}

#if 0
extern NDIS_STATUS
CallTransmitPacket(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pPacket,
    BOOLEAN             SendAck,
    ULONG               Ack
    );


NDIS_STATUS
TransmitPacketNow(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pWanPacket
    )
{
    BOOLEAN NeedToSendAck;
    ULONG Ack = 0;
    NDIS_STATUS Status;
    DEBUGMSG(DBG_FUNC, (DTEXT("+TransmitPacketNow\n")));

    if (!IS_CALL(pCall) || pCall->State!=STATE_CALL_ESTABLISHED)
    {
        // Drop the packet.
        Status = NDIS_STATUS_SUCCESS;
        goto cqtpDone;
    }
    NdisAcquireSpinLock(&pCall->Lock);
    if (NeedToSendAck = (pCall->Packet.AckNumber!=pCall->Remote.SequenceNumber))
    {
        pCall->Packet.AckNumber = pCall->Remote.SequenceNumber;
        Ack = pCall->Packet.AckNumber - 1;
    }
    NdisReleaseSpinLock(&pCall->Lock);

    Status = CallTransmitPacket(pCall, pWanPacket, NeedToSendAck, Ack);
    // We can get a failure here, but since we're in the direct path from
    // MiniportWanSend, it's ok.  Just pass the status back and we're done.


cqtpDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-TransmitPacketNow\n")));
    return Status;
}
#endif

NDIS_STATUS
TransmitPacketOnThread(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pWanPacket
    )
{
    BOOLEAN StartTransferring = FALSE;
    ULONG_PTR ProcNum = 0;
    NDIS_STATUS Status = NDIS_STATUS_PENDING;

    DEBUGMSG(DBG_FUNC, (DTEXT("+TransmitPacketOnThread\n")));

    if (!IS_CALL(pCall) || pCall->State!=STATE_CALL_ESTABLISHED)
    {
        // Drop the packet.
        Status = NDIS_STATUS_SUCCESS;
        goto cqtpDone;
    }

    NdisAcquireSpinLock(&pCall->Lock);

    InsertTailList(&pCall->TxPacketList, &pWanPacket->WanPacketQueue);

    if (!pCall->Transferring)
    {
        StartTransferring = pCall->Transferring = TRUE;
        ProcNum = pCall->DeviceId % KeNumberProcessors;
        REFERENCE_OBJECT(pCall);
        MyInterlockedInsertTailList(&Processor[ProcNum].TransmitList,
                                    &pCall->TxListEntry,
                                    &Processor[ProcNum].Lock);
        KeSetEvent(&Processor[ProcNum].WorkEvent, 0, FALSE);
    }

    NdisReleaseSpinLock(&pCall->Lock);

cqtpDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-TransmitPacketOnThread\n")));
    return Status;
}

NDIS_STATUS
CallQueueTransmitPacket(
    PCALL_SESSION       pCall,
    PNDIS_WAN_PACKET    pWanPacket
    )
{
    NDIS_STATUS Status;
    DEBUGMSG(DBG_FUNC, (DTEXT("+CallQueueTransmitPacket\n")));
    if (TransmitPath&TX_ON_THREAD)
    {
        Status = TransmitPacketOnThread(pCall, pWanPacket);
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
        ASSERT(0);
    }
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallQueueTransmitPacket\n")));
    return Status;
}

NDIS_STATUS
CallQueueReceivePacket(
    PCALL_SESSION       pCall,
    PDGRAM_CONTEXT      pDgContext
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PGRE_HEADER pGre = pDgContext->pGreHeader;
    ULONG_PTR ProcNum = 0;

    DEBUGMSG(DBG_FUNC, (DTEXT("+CallQueueReceivePacket\n")));

    if(!pGre->SequenceNumberPresent)
    {
        return NDIS_STATUS_FAILURE;
    }

    NdisAcquireSpinLock(&pCall->Lock);
    if (pCall->RxPacketsPending > 256 ||
        htons(pGre->KeyCallId)!=pCall->Packet.CallId ||
        pCall->State!=STATE_CALL_ESTABLISHED ||
        !IS_LINE_UP(pCall))
    {
        DEBUGMSG(DBG_PACKET|DBG_RX, (DTEXT("Rx: GRE CallId invalid or call in wrong state\n")));
        Status = NDIS_STATUS_FAILURE;
        goto cqrpDone;
    }

    // The packet has passed all of our tests.

    if (IsListEmpty(&pCall->RxPacketList))
    {
        PULONG pSequence = (PULONG)(pGre + 1);
        ULONG Sequence = htonl(*pSequence);

        if (Sequence==1)
        {
            LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"Receiving GRE data:%d\n"),
                                  LOGHDR(29, pCall->Remote.Address.Address[0].Address[0].in_addr),
                                  pCall->DeviceId));
        }

        // We don't check the sequence # anymore, just put it on the queue
        InsertTailList(&pCall->RxPacketList, &pDgContext->ListEntry);
        pCall->RxPacketsPending++;
    }
    else
    {
        // There are packets already queued.  Put this one in order.

        PULONG pSequence = (PULONG)(pGre + 1);
        ULONG Sequence = htonl(*pSequence);

        if (Sequence==1)
        {
            LOGMSG(FLL_DETAILED, (DTEXT(LOGHDRS"Receiving GRE data:%d\n"),
                                  LOGHDR(29, pCall->Remote.Address.Address[0].Address[0].in_addr),
                                  pCall->DeviceId));
        }

        // We don't check the sequence # anymore, just put it on the queue in order
        {
            PLIST_ENTRY pListEntry;
            BOOLEAN OnList = FALSE;

            for (pListEntry = pCall->RxPacketList.Flink;
                 pListEntry != &pCall->RxPacketList;
                 pListEntry = pListEntry->Flink)
            {
                PDGRAM_CONTEXT pListDg = CONTAINING_RECORD(pListEntry,
                                                           DGRAM_CONTEXT,
                                                           ListEntry);

                if ((signed)htonl(GreSequence(pListDg->pGreHeader)) - (signed)Sequence > 0)
                {
                    // The one on the list is newer!  Put this one before it.
                    InsertTailList(&pListDg->ListEntry, &pDgContext->ListEntry);
                    pCall->RxPacketsPending++;
                    OnList = TRUE;
                    break;
                }
            }
            if (!OnList)
            {
                // There were no packets on this list with a greater sequence.
                // Put this at the end.
                InsertTailList(&pCall->RxPacketList, &pDgContext->ListEntry);
                pCall->RxPacketsPending++;
            }
        }

        // We don't really care about the ACK from the peer, so save some cycles here
        /*
        pSequence++; // point to the ack
        if (pGre->AckSequenceNumberPresent)
        {
            ULONG Ack = ntohl(*pSequence);
            if ((signed)Ack - (signed)pCall->Remote.AckNumber >= 0 &&
                (signed)pCall->Packet.SequenceNumber - (signed)Ack >= 0)
            {
                pCall->Remote.AckNumber = Ack;
            }
            else
            {
                DEBUGMSG(DBG_WARN, (DTEXT("Ack out of range, Ack:%x LastAck:%x, NextSeq:%x\n"),
                                    Ack, pCall->Remote.AckNumber, pCall->Packet.SequenceNumber));
            }
        }
        */
    }

    if (Status==NDIS_STATUS_SUCCESS && !pCall->Receiving)
    {
        pCall->Receiving = TRUE;
        REFERENCE_OBJECT(pCall);
#if 0
        ProcNum = pCall->DeviceId % KeNumberProcessors;
        MyInterlockedInsertTailList(&Processor[ProcNum].TransmitList,
                                    &pCall->TxListEntry,
                                    &Processor[ProcNum].Lock);
        KeSetEvent(&Processor[ProcNum].WorkEvent, 0, FALSE);
#else
        PptpQueueDpc(&pCall->ReceiveDpc);
#endif
    }

cqrpDone:
    NdisReleaseSpinLock(&pCall->Lock);
    DEBUGMSG(DBG_FUNC, (DTEXT("-CallQueueReceivePacket\n")));
    return Status;
}

STATIC VOID
PacketWorkingThread(
    IN OUT PVOID Context
    )
{
    NDIS_STATUS Status;
    NTSTATUS    NtStatus;
    PLIST_ENTRY pListEntry;
    PKEVENT EventList[2];
    PPROCESSOR pProcessor = Context;

    DEBUGMSG(DBG_FUNC, (DTEXT("+PacketWorkingThread\n")));

    if (TransmitRealtime)
    {
        KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);
    }

    KeSetAffinityThread(KeGetCurrentThread(), AFFINITY_MASK(pProcessor->Number));

    EventList[0] = &pProcessor->WorkEvent;
    EventList[1] = &pProcessor->KillEvent;

    for (;;)
    {
        //
        // The events are auto-clearing, so
        // we don't need to reset the event.
        //

        NtStatus = KeWaitForMultipleObjects(2,
                                            EventList,
                                            WaitAny,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            NULL,
                                            NULL);

        if (NtStatus==0) // The first event, for packet processing, was signalled
        {
            while (pListEntry = MyInterlockedRemoveHeadList(&pProcessor->TransmitList,
                                                            &pProcessor->Lock))
            {
                PCALL_SESSION pCall = CONTAINING_RECORD(pListEntry,
                                                        CALL_SESSION,
                                                        TxListEntry);
                ULONG PacketsToTransmit;

                if (IsListEmpty(&pProcessor->TransmitList))
                {
                    PacketsToTransmit = 0xffffffff;
                }
                else
                {
                    PacketsToTransmit = 10;
                }
                if (CallProcessPackets(pCall, PacketsToTransmit))
                {
                    MyInterlockedInsertTailList(&pProcessor->TransmitList,
                                                &pCall->TxListEntry,
                                                &pProcessor->Lock);
                }
                else
                {
                    DEREFERENCE_OBJECT(pCall); // Matches TransmitPacketOnThread
                }
            }
        }
        else
        {
            // A kill event was received.

            DEBUGMSG(DBG_THREAD, (DTEXT("Thread: HALT %08x\n"), NtStatus));

            // Free any pending requests

            // ToDo: write code here
            pProcessor->hThread = NULL;
            DEBUGMSG(DBG_FUNC, (DTEXT("PsTerminateSystemThread PacketWorkingThread\n")));
            PsTerminateSystemThread(STATUS_SUCCESS);

            break;
        }

    }

    DEBUGMSG(DBG_FUNC, (DTEXT("-PacketWorkingThread\n")));
}

NDIS_STATUS
InitThreading(
    NDIS_HANDLE hMiniportAdapter
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    NTSTATUS NtStatus;

    UNREFERENCED_PARAMETER(hMiniportAdapter);

    DEBUGMSG(DBG_FUNC, (DTEXT("+InitializeThreading\n")));

    if (ThreadingInitialized)
    {
       ASSERT(!"Threading initialized twice");
       goto itDone;
    }
    ThreadingInitialized = TRUE;

    NdisInitializeListHead(&WorkItemList);
    NdisAllocateSpinLock(&GlobalThreadLock);

    KeInitializeEvent(
                &EventPassiveThread,
                SynchronizationEvent, // auto-clearing event
                FALSE                 // event initially non-signalled
                );

    KeInitializeEvent(
                &EventKillThread,
                SynchronizationEvent, // auto-clearing event
                FALSE                 // event initially non-signalled
                );

    NtStatus = PsCreateSystemThread(&hPassiveThread,
                                    (ACCESS_MASK) 0L,
                                    NULL,
                                    NULL,
                                    NULL,
                                    MainPassiveLevelThread,
                                    NULL);
    if (NtStatus!=STATUS_SUCCESS)
    {
        DEBUGMSG(DBG_ERROR, (DTEXT("PsCreateSystemThread failed. %08x\n"), Status));
        Status = NDIS_STATUS_FAILURE;

        goto itDone;
    }

    DBG_D(DBG_THREAD, KeNumberProcessors);

#if 0
    if (KeNumberProcessors==1 && (TransmitPath&TX_DEFAULT))
    {
        // We've got one processor and the user hasn't requested a specific type
        // of transmission, so we'll opt to transmit immediately.
        TransmitPath &= ~TX_ON_THREAD;
    }
#endif

    if (TransmitPath&TX_ON_THREAD)
    {
        Processor = MyMemAlloc(sizeof(PROCESSOR)*KeNumberProcessors, TAG_THREAD);
        if (!Processor)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            ULONG i;
            NdisZeroMemory(Processor, sizeof(PROCESSOR)*KeNumberProcessors);

            for (i=0; i<(ULONG)KeNumberProcessors; i++)
            {
                NdisInitializeListHead(&Processor[i].TransmitList);
                NdisAllocateSpinLock(&Processor[i].Lock);

                KeInitializeEvent(
                            &Processor[i].WorkEvent,
                            SynchronizationEvent, // auto-clearing event
                            FALSE                 // event initially non-signalled
                            );

                KeInitializeEvent(
                            &Processor[i].KillEvent,
                            SynchronizationEvent, // auto-clearing event
                            FALSE                 // event initially non-signalled
                            );

                Processor[i].Number = i;

                // ToDo: we should create the thread when we really need it.
                NtStatus = PsCreateSystemThread(&Processor[i].hThread,
                                                (ACCESS_MASK) 0L,
                                                NULL,
                                                NULL,
                                                NULL,
                                                PacketWorkingThread,
                                                &Processor[i]);
                if (NtStatus!=STATUS_SUCCESS)
                {
                    DEBUGMSG(DBG_ERROR, (DTEXT("PsCreateSystemThread failed. %08x\n"), Status));
                    Status = NDIS_STATUS_FAILURE;

                    break;
                }
            }
        }
    }

itDone:
    DEBUGMSG(DBG_FUNC, (DTEXT("-InitializeThreading %08x\n"), Status));
    return Status;
}

VOID STATIC WaitForThreadToDieAndCloseIt(HANDLE hThread, PRKEVENT pKillEvent)
{
    PVOID pThread = NULL;
    NTSTATUS Status;
    
    DEBUGMSG(DBG_FUNC, (DTEXT("+WaitForThreadToDie\n")));

    if ( hThread != NULL && pKillEvent != NULL )
    {

        Status = ObReferenceObjectByHandle(hThread, 0, NULL, KernelMode, &pThread, NULL);
        if (Status==STATUS_SUCCESS)
        {
            KeSetEvent(pKillEvent, 0, FALSE);
    
            KeWaitForSingleObject(pThread, Executive, KernelMode, FALSE, NULL);
            ObDereferenceObject(pThread);
        }
        ZwClose(hThread);
    }
    
    DEBUGMSG(DBG_FUNC, (DTEXT("-WaitForThreadToDie\n")));
}

VOID
DeinitThreading()
{
    DEBUGMSG(DBG_FUNC, (DTEXT("+DeinitThreading\n")));
    
    ThreadingInitialized = FALSE;
    if ((TransmitPath&TX_ON_THREAD) && Processor!=NULL)
    {
        LONG i;

        for (i=0; i<KeNumberProcessors; i++)
        {
            WaitForThreadToDieAndCloseIt( Processor[i].hThread, 
                                          &Processor[i].KillEvent );
        }
        MyMemFree(Processor, sizeof(PROCESSOR)*KeNumberProcessors);
        Processor = NULL;
    }

    WaitForThreadToDieAndCloseIt( hPassiveThread, 
                                  &EventKillThread );

    DEBUGMSG(DBG_FUNC, (DTEXT("-DeinitThreading\n")));
}

UCHAR TapiLineNameBuffer[64] =  TAPI_LINE_NAME_STRING;
ANSI_STRING TapiLineName = {
    sizeof(TAPI_LINE_NAME_STRING),
    sizeof(TapiLineNameBuffer),
    TapiLineNameBuffer
};
typedef UCHAR TAPI_CHAR_TYPE;

ANSI_STRING TapiLineAddrList = { 0, 0, NULL };

#define READ_NDIS_REG_ULONG(hConfig, Var, Value) \
    {                                                                                   \
        PNDIS_CONFIGURATION_PARAMETER RegValue;                                         \
        NDIS_STATUS Status;                                                             \
        NDIS_STRING String = NDIS_STRING_CONST(Value);                                  \
                                                                                        \
        NdisReadConfiguration(&Status,                                                  \
                              &RegValue,                                                \
                              hConfig,                                                  \
                              &String,                                                  \
                              NdisParameterInteger);                                    \
        if (Status==NDIS_STATUS_SUCCESS)                                                \
        {                                                                               \
            (Var) = RegValue->ParameterData.IntegerData;                                \
            DEBUGMSG(DBG_INIT, (DTEXT(#Var"==%d\n"), (Var)));                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            DEBUGMSG(DBG_INIT, (DTEXT(Value", default==%d\n"), (Var)));\
        }                                                                               \
    }

#define READ_NDIS_REG_USHORT(hConfig, Var, Value) \
    {                                                                                   \
        PNDIS_CONFIGURATION_PARAMETER RegValue;                                         \
        NDIS_STATUS Status;                                                             \
        NDIS_STRING String = NDIS_STRING_CONST(Value);                                  \
                                                                                        \
        NdisReadConfiguration(&Status,                                                  \
                              &RegValue,                                                \
                              hConfig,                                                  \
                              &String,                                                  \
                              NdisParameterInteger);                                    \
        if (Status==NDIS_STATUS_SUCCESS)                                                \
        {                                                                               \
            (Var) = (USHORT)(RegValue->ParameterData.IntegerData&0xffff);               \
            DEBUGMSG(DBG_INIT, (DTEXT(#Var"==%d\n"), (Var)));                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            DEBUGMSG(DBG_INIT, (DTEXT(Value", default==%d\n"), (Var)));\
        }                                                                               \
    }

#define READ_NDIS_REG_BOOL(hConfig, Var, Value) \
    {                                                                                   \
        PNDIS_CONFIGURATION_PARAMETER RegValue;                                         \
        NDIS_STATUS Status;                                                             \
        NDIS_STRING String = NDIS_STRING_CONST(Value);                                  \
                                                                                        \
        NdisReadConfiguration(&Status,                                                  \
                              &RegValue,                                                \
                              hConfig,                                                  \
                              &String,                                                  \
                              NdisParameterInteger);                                    \
        if (Status==NDIS_STATUS_SUCCESS)                                                \
        {                                                                               \
            (Var) = RegValue->ParameterData.IntegerData ? TRUE : FALSE;                 \
            DEBUGMSG(DBG_INIT, (DTEXT(#Var"==%d\n"), (Var)));                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            DEBUGMSG(DBG_INIT, (DTEXT(Value", default==%d\n"), (Var)));\
        }                                                                               \
    }

VOID
OsReadConfig(
    NDIS_HANDLE hConfig
    )
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PNDIS_CONFIGURATION_PARAMETER Value;
#if 0
    NDIS_STRING TransmitPathString = NDIS_STRING_CONST("TransmitPath");
#endif
    NDIS_STRING TapiLineNameString = NDIS_STRING_CONST("TapiLineName");
#if VER_PRODUCTVERSION_W < 0x0500
    NDIS_STRING TapiLineAddrString = NDIS_STRING_CONST("AddressList");
#endif
    NDIS_STRING PeerClientIpAddressString = NDIS_STRING_CONST("ClientIpAddresses");
    NDIS_STRING PeerClientIpMaskString = NDIS_STRING_CONST("ClientIpMasks");
    DEBUGMSG(DBG_FUNC, (DTEXT("+OsReadConfig\n")));

#if 0
    READ_NDIS_REG_ULONG(hConfig, "TransmitPath", TransmitPath);
#endif
    READ_NDIS_REG_USHORT(hConfig, PptpControlPort,               "TcpPortNumber");
    READ_NDIS_REG_USHORT(hConfig, PptpUdpPort,                   "UdpPortNumber");
    READ_NDIS_REG_ULONG (hConfig, PptpWanEndpoints,              "MaxWanEndpoints");
    READ_NDIS_REG_ULONG (hConfig, PptpMaxTransmit,               "MaxTransmit");
    READ_NDIS_REG_ULONG (hConfig, PptpEchoTimeout,               "InactivityIdleSeconds");
    READ_NDIS_REG_BOOL  (hConfig, PptpEchoAlways,                "AlwaysEcho");
    READ_NDIS_REG_ULONG (hConfig, PptpTunnelConfig,              "TunnelConfig");
    READ_NDIS_REG_ULONG (hConfig, CtdiTcpDisconnectTimeout,      "TcpDisconnectTimeout");
    READ_NDIS_REG_ULONG (hConfig, CtdiTcpConnectTimeout,         "TcpConnectTimeout");
    READ_NDIS_REG_ULONG (hConfig, FileLogLevel,                  "Logging");
    READ_NDIS_REG_BOOL  (hConfig, TransmitRealtime,              "TransmitRealtime");
    READ_NDIS_REG_BOOL  (hConfig, PptpAuthenticateIncomingCalls, "AuthenticateIncomingCalls");
    READ_NDIS_REG_ULONG (hConfig, PptpValidateAddress,           "ValidateAddress");

    OS_RANGE_CHECK_ENDPOINTS(PptpWanEndpoints);
    OS_RANGE_CHECK_MAX_TRANSMIT(PptpMaxTransmit);

    if (PptpAuthenticateIncomingCalls)
    {
        NdisReadConfiguration(&Status,  // Not required value
                              &Value,
                              hConfig,
                              &PeerClientIpAddressString,
                              NdisParameterMultiString);
        if (Status==NDIS_STATUS_SUCCESS)
        {
            ULONG i, NumAddresses = 0;
            BOOLEAN InEntry = 0, ValidAddress;
            PWCHAR AddressList = Value->ParameterData.StringData.Buffer;
            TA_IP_ADDRESS Address;

            // Loop and count the addresses, so we can allocate proper size to hold them.
            for (i=0, InEntry=FALSE; i<(Value->ParameterData.StringData.Length/sizeof(WCHAR))-1; i++)
            {
                if (!InEntry)
                {
                    if (AddressList[i]!=L'\0')
                    {
                        InEntry = TRUE;
                        StringToIpAddressW(&AddressList[i],
                                           &Address,
                                           &ValidAddress);
                        if (ValidAddress)
                        {
                            NumAddresses++;
                        }
                    }
                }
                else
                {
                    if (AddressList[i]==L'\0')
                    {
                        InEntry = FALSE;
                    }
                }
            }
            NumClientAddresses = NumAddresses;
            if (NumClientAddresses)
            {
                ClientList = MyMemAlloc(sizeof(CLIENT_ADDRESS)*NumClientAddresses, TAG_PPTP_ADDR_LIST);
                if (ClientList)
                {
                    NumAddresses = 0;
                    for (i=0, InEntry=FALSE; i<(Value->ParameterData.StringData.Length/sizeof(WCHAR))-1; i++)
                    {
                        if (!InEntry)
                        {
                            if (AddressList[i]!=L'\0')
                            {
                                InEntry = TRUE;
                                if (NumAddresses<NumClientAddresses)
                                {
                                    StringToIpAddressW(&AddressList[i],
                                                       &Address,
                                                       &ValidAddress);
                                    if (ValidAddress)
                                    {
                                        ClientList[NumAddresses].Address = Address.Address[0].Address[0].in_addr;
                                        ClientList[NumAddresses].Mask = 0xFFFFFFFF;
                                        NumAddresses++;
                                    }
                                }
                            }
                        }
                        else
                        {
                            if (AddressList[i]==L'\0')
                            {
                                InEntry = FALSE;
                            }
                        }
                    }
                    NdisReadConfiguration(&Status,  // Not required value
                                          &Value,
                                          hConfig,
                                          &PeerClientIpMaskString,
                                          NdisParameterMultiString);
                    if (Status==NDIS_STATUS_SUCCESS)
                    {
                        AddressList = Value->ParameterData.StringData.Buffer;
                        NumAddresses = 0;
                        for (i=0, InEntry=FALSE;
                             i<(Value->ParameterData.StringData.Length/sizeof(WCHAR))-1 && NumAddresses<=NumClientAddresses;
                             i++)
                        {
                            if (!InEntry)
                            {
                                if (AddressList[i]!=L'\0')
                                {
                                    InEntry = TRUE;
                                    if (NumAddresses<NumClientAddresses)
                                    {
                                        StringToIpAddressW(&AddressList[i],
                                                           &Address,
                                                           &ValidAddress);
                                        if (ValidAddress)
                                        {
                                            ClientList[NumAddresses].Mask = Address.Address[0].Address[0].in_addr;
                                            NumAddresses++;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (AddressList[i]==L'\0')
                                {
                                    InEntry = FALSE;
                                }
                            }
                        }
                    }
                    for (i=0; i<NumClientAddresses; i++)
                    {
                        DEBUGMSG(DBG_INIT, (DTEXT("Client Address:%d.%d.%d.%d  Mask:%d.%d.%d.%d\n"),
                                            IPADDR(ClientList[i].Address), IPADDR(ClientList[i].Mask)));
                    }
                }
                else
                    PptpAuthenticateIncomingCalls = FALSE;
            }
            else
                PptpAuthenticateIncomingCalls = FALSE;
        }
    }

    NdisReadConfiguration(&Status,  // Not required value
                          &Value,
                          hConfig,
                          &TapiLineNameString,
                          NdisParameterString);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        RtlUnicodeStringToAnsiString(&TapiLineName, &Value->ParameterData.StringData, FALSE);
        *(TAPI_CHAR_TYPE*)(TapiLineName.Buffer+TapiLineName.MaximumLength-sizeof(TAPI_CHAR_TYPE)) = (TAPI_CHAR_TYPE)0;
    }

#if VER_PRODUCTVERSION_W < 0x0500
    NdisReadConfiguration(&Status,  // Not required value
                          &Value,
                          hConfig,
                          &TapiLineAddrString,
                          NdisParameterMultiString);
    if (Status==NDIS_STATUS_SUCCESS)
    {
        RtlInitAnsiString( &TapiLineAddrList, NULL );
        if (RtlUnicodeStringToAnsiString(&TapiLineAddrList, &Value->ParameterData.StringData, TRUE)==NDIS_STATUS_SUCCESS)
        {
            // NT4 doesn't have the same registry value to tell us how many lines to publish.
            // We work around that by counting the number of address strings here

            PUCHAR p = TapiLineAddrList.Buffer;

            DEBUGMEM(DBG_TAPI, TapiLineAddrList.Buffer, TapiLineAddrList.Length, 1);
            PptpWanEndpoints = 0;
            if (p)
            {
                // Count the valid MULTI_SZ entries.
                while (*p++)
                {
                    PptpWanEndpoints++;
                    while (*p++);  // This also skips the first NULL
                }
            }
            DBG_D(DBG_INIT, PptpWanEndpoints);
        }

    }
#endif

    DEBUGMSG(DBG_FUNC, (DTEXT("-OsReadConfig\n")));
}

VOID
OsGetTapiLineAddress(ULONG Index, PUCHAR s, ULONG Length)
{
#if VER_PRODUCTVERSION_W < 0x0500
    PUCHAR pAddr = TapiLineAddrList.Buffer;

    *s = 0;

    if (pAddr)
    {
        UINT i;

        for (i=0; i<Index; i++)
        {
            if (!*pAddr)
            {
                // No string at index
                return;
            }
            while (*pAddr) pAddr++;
            pAddr++;
        }
        strncpy(s, pAddr, Length);
        s[Length-1] = 0;
    }
#else // VER_PRODUCTVERSION_W >= 0x0500

    strncpy(s, TAPI_LINE_ADDR_STRING, Length);
    s[Length-1] = 0;
#endif
}

NDIS_STATUS
OsSpecificTapiGetDevCaps(
    ULONG_PTR ulDeviceId,
    IN OUT PNDIS_TAPI_GET_DEV_CAPS pRequest
    )
{
    PUCHAR pTmp, pTmp2;
    ULONG_PTR Index;

    DEBUGMSG(DBG_FUNC, (DTEXT("+OsSpecificTapiGetDevCaps\n")));

    // Convert to our internal index
    ulDeviceId -= pgAdapter->Tapi.DeviceIdBase;

    pRequest->LineDevCaps.ulStringFormat = STRINGFORMAT_ASCII;


    // The *6 at the end adds enough space for " 9999"
    pRequest->LineDevCaps.ulNeededSize   = sizeof(pRequest->LineDevCaps) +
                                           sizeof(TAPI_PROVIDER_STRING) +
                                           TapiLineName.Length +
                                           sizeof(TAPI_CHAR_TYPE) * 6;

    if (pRequest->LineDevCaps.ulTotalSize<pRequest->LineDevCaps.ulNeededSize)
    {
        DEBUGMSG(DBG_FUNC|DBG_WARN, (DTEXT("-TapiGetDevCaps NDIS_STATUS_SUCCESS without PROVIDER or LINE_NAME strings\n")));
        return NDIS_STATUS_SUCCESS;
    }

    // Tack the provider string to the end of the LineDevCaps structure.

    pRequest->LineDevCaps.ulProviderInfoSize = sizeof(TAPI_PROVIDER_STRING);
    pRequest->LineDevCaps.ulProviderInfoOffset = sizeof(pRequest->LineDevCaps);

    pTmp = ((PUCHAR)&pRequest->LineDevCaps) + sizeof(pRequest->LineDevCaps);
    NdisMoveMemory(pTmp, TAPI_PROVIDER_STRING, sizeof(TAPI_PROVIDER_STRING));

    pTmp += sizeof(TAPI_PROVIDER_STRING);

    // Tack on the LineName after the provider string.

    pRequest->LineDevCaps.ulLineNameSize = TapiLineName.Length + sizeof(TAPI_CHAR_TYPE);
    pRequest->LineDevCaps.ulLineNameOffset = pRequest->LineDevCaps.ulProviderInfoOffset +
                                             pRequest->LineDevCaps.ulProviderInfoSize;
    NdisMoveMemory(pTmp, TapiLineName.Buffer, TapiLineName.Length+sizeof(TAPI_CHAR_TYPE));

    while (*pTmp) pTmp++; // Find the NULL

    *pTmp++ = ' ';
    pRequest->LineDevCaps.ulLineNameSize++;

    // Put a number at the end of the string.

    if (ulDeviceId==0)
    {
        *pTmp++ = '0';
        *pTmp++ = '\0';
        pRequest->LineDevCaps.ulLineNameSize += 2;
    }
    else
    {
        Index = ulDeviceId;
        ASSERT(Index<100000);
        pTmp2 = pTmp;
        while (Index)
        {
            *pTmp2++ = (UCHAR)((Index%10) + '0');
            Index /= 10;
            pRequest->LineDevCaps.ulLineNameSize++;
        }
        *pTmp2-- = '\0'; // Null terminate and point to the last digit.
        pRequest->LineDevCaps.ulLineNameSize++;
        // We put the number in backwards, now reverse it.
        while (pTmp<pTmp2)
        {
            UCHAR t = *pTmp;
            *pTmp++ = *pTmp2;
            *pTmp2-- = t;
        }
    }

    pRequest->LineDevCaps.ulUsedSize     = pRequest->LineDevCaps.ulNeededSize;

    DEBUGMSG(DBG_FUNC, (DTEXT("-OsSpecificTapiGetDevCaps\n")));
    return NDIS_STATUS_SUCCESS;
}

NDIS_HANDLE LogHandle = 0;

VOID __cdecl OsFileLogInit()
{
    NDIS_STATUS Status =
    NdisMCreateLog(pgAdapter->hMiniportAdapter,
                   16384,
                   &LogHandle);

}

VOID __cdecl OsFileLogOpen()
{
}

VOID __cdecl OsLogPrintf(char *pszFmt, ... )
{
    va_list ArgList;
    CHAR Buf[512];
    ULONG Len;

    if (LogHandle)
    {
        va_start(ArgList, pszFmt);
        Len = vsprintf(Buf, pszFmt, ArgList);
        va_end(ArgList);
        NdisMWriteLogData(LogHandle, Buf, Len);
    }
}

VOID __cdecl OsFileLogClose(void)
{
}

VOID __cdecl OsFileLogShutdown(void)
{
    if (LogHandle)
    {
        NdisMCloseLog(LogHandle);
        LogHandle = 0;
    }
}

VOID __cdecl OsFileLogFlush(void)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\debug.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// debug.c
// DirectParallel WAN mini-port/call-manager driver
// Debug utilities and globals
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"

//-----------------------------------------------------------------------------
// Global data definitions
//-----------------------------------------------------------------------------

#ifdef TESTMODE
#pragma message( "TESTMODE defined, building private spew" )
#define DEFAULTTRACELEVEL TL_N
#define DEFAULTTRACEMASK  TM_Base
#else
#define DEFAULTTRACELEVEL TL_None
#define DEFAULTTRACEMASK  TM_Base
#endif

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' are
// displayed.  All messages from any (TM_*) set(s) present in 'g_ulTraceMask'
// are displayed.
//
ULONG g_ulTraceLevel = DEFAULTTRACELEVEL;
ULONG g_ulTraceMask = DEFAULTTRACEMASK;


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------


#if DBG
VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks )

    // Tries to detect corruption in list 'pList', printing verbose linkage
    // output if 'fShowLinks' is set.
    //
{
    LIST_ENTRY* pLink;
    ULONG ul;

    ul = 0;
    for (pLink = pList->Flink;
         pLink != pList;
         pLink = pLink->Flink)
    {
        if (fShowLinks)
        {
            DbgPrint( "RASPTI: CheckList($%p) Flink(%d)=$%p\n",
                pList, ul, pLink );
        }
        ++ul;
    }

    for (pLink = pList->Blink;
         pLink != pList;
         pLink = pLink->Blink)
    {
        if (fShowLinks)
        {
            DbgPrint( "RASPTI: CheckList($%p) Blink(%d)=$%p\n",
                pList, ul, pLink );
        }
        --ul;
    }

    if (ul)
    {
        DbgBreakPoint();
    }
}
#endif


#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "RASPTI: %p: ", p );
    else
        DbgPrint( "RASPTI: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\bpool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// bpool.h
// RAS L2TP WAN mini-port/call-manager driver
// Buffer pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _BPOOL_H_
#define _BPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Buffer pool control block.  A buffer pool prevents fragmentation of the
// non-paged memory pool by allocating the memory for a group of buffers in a
// single contiguous block.  At user's option, the buffer pool routines may
// allocate a pool of NDIS_BUFFER buffer descriptors and associate each with
// the memory buffers sliced from the contiguous block.  This allows the
// buffer to be reused while the virtual->physical memory mapping to be
// performed once.  All necessary pool growth and shrinkage is handled
// internally.
//
typedef struct
_BUFFERPOOL
{
    // Size in bytes of an individual buffer in the pool.
    //
    ULONG ulBufferSize;

    // The optimal number of buffers to allocate in each buffer block.
    //
    ULONG ulBuffersPerBlock;

    // Maximum number of individual buffers that may be allocated in the
    // entire pool or 0 for unlimited.
    //
    ULONG ulMaxBuffers;

    // Current number of individual buffers allocated in the entire pool.
    //
    ULONG ulCurBuffers;

    // Garbage collection occurs after this many calls to FreeBufferToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Indicates an NDIS_BUFFER is to be associated with each individual
    // buffer in the pool.
    //
    BOOLEAN fAssociateNdisBuffer;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of BUFFERBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free BUFFERHEADs.  Each BUFFERHEAD in
    // the list is ready to go, i.e. it preceeds it's already allocated memory
    // buffer and, if appropriate, has an NDIS_BUFFER associated with it.
    // Access to the list is protected by 'lock' in this structure.
    // Interlocked push/pop is not used because (a) the list of blocks and the
    // list of buffers must lock each other and (b) double links are necessary
    // for garbage collection.
    //
    LIST_ENTRY listFreeBuffers;

    // This lock protects this structure and both the list of blocks and the
    // list of buffers.
    //
    NDIS_SPIN_LOCK lock;
}
BUFFERPOOL;


// Header of a single block of buffers from a buffer pool.  The BUFFERHEAD of
// the first buffer immediately follows.
//
typedef struct
_BUFFERBLOCKHEAD
{
    // Link to the prev/next buffer block header in the buffer pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_BUFFER descriptors associated with
    // this block, or NULL if none.  (Note: With the current NT implementation
    // of NDIS_BUFFER as MDL this is always NULL).
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the buffer pool.
    //
    BUFFERPOOL* pPool;

    // Number of individual buffers in this block.
    //
    ULONG ulBuffers;

    // Number of individual buffers in this block on the free list.
    //
    ULONG ulFreeBuffers;
}
BUFFERBLOCKHEAD;


// Header of an individual buffer.  The buffer memory itself immediately
// follows.
//
typedef struct
_BUFFERHEAD
{
    // Links to prev/next buffer header in the buffer pool's free list.
    //
    LIST_ENTRY linkFreeBuffers;

    // Back link to owning buffer block header.
    //
    BUFFERBLOCKHEAD* pBlock;

    // NDIS buffer descriptor of this buffer.  This is NULL unless the pool is
    // initialized with the 'fAssociateNdisBuffer' option.
    //
    NDIS_BUFFER* pNdisBuffer;
}
BUFFERHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitBufferPool(
    OUT BUFFERPOOL* pPool,
    IN ULONG ulBufferSize,
    IN ULONG ulMaxBuffers,
    IN ULONG ulBuffersPerBlock,
    IN ULONG ulFreesPerCollection,
    IN BOOLEAN fAssociateNdisBuffer,
    IN ULONG ulTag );

BOOLEAN
FreeBufferPool(
    IN BUFFERPOOL* pPool );

CHAR*
GetBufferFromPool(
    IN BUFFERPOOL* pPool );

VOID
FreeBufferToPool(
    IN BUFFERPOOL* pPool,
    IN CHAR* pBuffer,
    IN BOOLEAN fGarbageCollection );

NDIS_BUFFER*
NdisBufferFromBuffer(
    IN CHAR* pBuffer );

ULONG
BufferSizeFromBuffer(
    IN CHAR* pBuffer );

NDIS_BUFFER*
PoolHandleForNdisCopyBufferFromBuffer(
    IN CHAR* pBuffer );


#endif // BPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\cm.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// cm.c
// RAS DirectParallel WAN mini-port/call-manager driver
// Call Manager routines
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"
#include "ptilink.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
CallSetupComplete(
    IN VCCB* pVc );

VOID
InactiveCallCleanUp(
    IN VCCB* pVc );

ULONG
LineIdAdd(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId );

ULONG
LineIdPortLookup(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId );

VOID
OpenAfPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiOpenPtiLink(
    IN VCCB* pVc,
    IN ULONG ParallelPortIndex);

NDIS_STATUS
PtiClosePtiLink(
    IN VCCB* pVc );

NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

VOID
QueryPtiPorts(
    IN ADAPTERCB* pAdapter );

VOID
SetupVcComplete(
    IN VCCB* pVc );

VOID
WriteEndpointsToRegistry(
    IN ULONG ulVcs );


//-----------------------------------------------------------------------------
// Call-manager handlers and completers
//-----------------------------------------------------------------------------

NDIS_STATUS
PtiCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext )

    // Standard 'CmOpenAfHandler' routine called by NDIS when the a client
    // requests to open an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hExistingAf;
    NDIS_STATUS status;

    TRACE( TL_I, TM_Cm,
        ( "PtiCmOpenAf: AF=$%p", AddressFamily->AddressFamily ) );

    pAdapter = (ADAPTERCB* )CallMgrBindingContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (AddressFamily->AddressFamily != CO_ADDRESS_FAMILY_TAPI_PROXY
        || AddressFamily->MajorVersion != NDIS_MajorVersion
        || AddressFamily->MinorVersion != NDIS_MinorVersion)
    {
        TRACE( TL_A, TM_Cm, ( "PtiCmOpenAf: Bad AF or NDIS version" ) );
        return NDIS_STATUS_BAD_VERSION;
    }

    // Save NDIS's AF handle in the adapter control block.  Interlock just in
    // case multiple clients attempt to open the AF, though don't expect this.
    //
    hExistingAf =
        InterlockedCompareExchangePointer(
            &pAdapter->NdisAfHandle, NdisAfHandle, NULL );
    if (hExistingAf)
    {
        // Our AF has already been opened and it doesn't make any sense to
        // accept another since there is no way to distinguish which should
        // receive incoming calls.
        //
        ASSERT( !"AF exists?" );
        return NDIS_STATUS_FAILURE;
    }

    ReferenceAdapter( pAdapter );
    ReferenceAf( pAdapter );

    // Since we support only a single address family, just return the adapter
    // as the address family context.
    //
    *CallMgrAfContext = CallMgrBindingContext;

    // If this is the first reference then schedule work to stall around
    // waiting for PARPORT to initialize the parallel ports.  Unfortunately,
    // according to Doug Fritz there is no way in the PnP model to know when
    // all ports that are coming have come.
    //
    TRACE( TL_I, TM_Cm, ( "PtiCmOpenAf sched delay" ) );
    status = ScheduleWork( pAdapter, OpenAfPassive, pAdapter );

    if (status != NDIS_STATUS_SUCCESS)
    {
        TRACE( TL_I, TM_Cm, ( "PtiCmOpenAf: Sched fail" ) );
        return status;
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmOpenAf: pend" ) );
    return NDIS_STATUS_PENDING;
}


VOID
OpenAfPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the Address Family open begun in
    // LcmCmOpenAf.
{
    ADAPTERCB* pAdapter;

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    if (pAdapter->lAfRef <= 1)
    {
        if (pAdapter->ulParportDelayMs > 0)
        {
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAF)" ) );
            NdisMSleep( pAdapter->ulParportDelayMs * 1000 );
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAF) done" ) );
        }

        // Count the actual number of VCs we must be able to provide and write
        // the result to the registry.
        //
        QueryPtiPorts( pAdapter );
        if (pAdapter->ulActualVcs == 0 && pAdapter->ulExtraParportDelayMs > 0)
        {
            // No ports were found,but a secondary wait is configured.  Wait,
            // then count the ports again.
            //
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAFx)" ) );
            NdisMSleep( pAdapter->ulExtraParportDelayMs * 1000 );
            TRACE( TL_I, TM_Cm, ( "NdisMSleep(openAFx) done" ) );

            QueryPtiPorts( pAdapter );
        }

        WriteEndpointsToRegistry( pAdapter->ulActualVcs );
    }

    TRACE( TL_I, TM_Cm, ( "NdisMCmOpenAddressFamilyComplete" ) );
    NdisMCmOpenAddressFamilyComplete(
        NDIS_STATUS_SUCCESS, pAdapter->NdisAfHandle, (NDIS_HANDLE )pAdapter );
    TRACE( TL_I, TM_Cm, ( "NdisMCmOpenAddressFamilyComplete done" ) );
}


NDIS_STATUS
PtiCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext )

    // Standard 'CmCreateVc' routine called by NDIS in response to a
    // client's request to create a virtual circuit.  This
    // call must return synchronously.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "PtiCmCreateVc" ) );

    pAdapter = (ADAPTERCB* )ProtocolAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        ASSERT( !"Alloc VC?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisZeroMemory( pVc, sizeof(*pVc) );

    // Set a marker for easier memory dump browsing.
    //
    pVc->ulTag = MTAG_VCCB;

    // Save a back pointer to the adapter for use in PtiCmDeleteVc later.
    //
    pVc->pAdapter = pAdapter;
    ReferenceAdapter( pAdapter );

    // Initialize the VC and call spinlock and send/receive lists.
    //
    NdisAllocateSpinLock( &pVc->lockV );
    NdisAllocateSpinLock( &pVc->lockCall );

    // Save the NDIS handle of this VC for use in indications to NDIS later.
    //
    pVc->NdisVcHandle = NdisVcHandle;

    // Initialize link capabilities to the defaults for the adapter, except
    // for the ACCM mask which defaults to "all stuffed" per PPP spec.  We
    // desire no stuffing so 0 what is in the adapter block, and passed up to
    // NDISWAN, but can't use that until/unless it's negotiated and passed
    // back down to us in an OID_WAN_CO_SET_LINK_INFO.
    //
    {
        NDIS_WAN_CO_INFO* pwci = &pAdapter->info;
        NDIS_WAN_CO_GET_LINK_INFO* pwcgli = &pVc->linkinfo;

        NdisZeroMemory( &pVc->linkinfo, sizeof(pVc->linkinfo) );
        pwcgli->MaxSendFrameSize = pwci->MaxFrameSize;
        pwcgli->MaxRecvFrameSize = pwci->MaxFrameSize;
        pwcgli->SendFramingBits = pwci->FramingBits;
        pwcgli->RecvFramingBits = pwci->FramingBits;
        pwcgli->SendACCM = (ULONG )-1;
        pwcgli->RecvACCM = (ULONG )-1;
    }

    // The VC control block's address is the VC context we return to NDIS.
    //
    *ProtocolVcContext = (NDIS_HANDLE )pVc;

    // Add a reference to the control block and the associated address family
    // that is removed by LmpCoDeleteVc.
    //
    ReferenceVc( pVc );
    ReferenceAf( pAdapter );

    TRACE( TL_V, TM_Mp, ( "PtiCmCreateVc: Exit: pVc=$%p", pVc ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext )

    // Standard 'CmDeleteVc' routine called by NDIS in response to a
    // client's request to delete a virtual circuit.  This
    // call must return synchronously.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "PtiCmDelVc: pVc=$%p", ProtocolVcContext ) );

    pVc = (VCCB* )ProtocolVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Remove the references added by PtiCmCreateVc.
    //
    DereferenceAf( pVc->pAdapter );
    DereferenceVc( pVc );

    TRACE( TL_V, TM_Cm, ( "PtiCmDelVc: Exit, pVc=$%p", pVc ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext )

    // Standard 'CmRegisterSapHandler' routine called by NDIS when the
    // client registers a service access point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    BOOLEAN fSapExists;
    BOOLEAN fBadSapPort;
    BOOLEAN fBadSapLength;
    CO_AF_TAPI_SAP* pSap;

    TRACE( TL_I, TM_Cm, ( "PtiCmRegSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;

    // Our SAP context is just the address of the owning adapter control
    // block.  Set it now before scheduling work as NDIS doesn't handle the
    // case of SAP completion correctly otherwise (though it should).
    //
    *CallMgrSapContext = (NDIS_HANDLE )pAdapter;

    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    fSapExists = FALSE;
    fBadSapLength = FALSE;
    fBadSapPort = FALSE;
    NdisAcquireSpinLock( &pAdapter->lockSap );
    do
    {
        ULONG ulSapPort;

        if (pAdapter->NdisSapHandle)
        {
            fSapExists = TRUE;
            break;
        }

        if (Sap->SapLength != sizeof(CO_AF_TAPI_SAP))
        {
            fBadSapLength = TRUE;
            break;
        }

        pSap = (CO_AF_TAPI_SAP* )&Sap->Sap[ 0 ];
        if (pSap->ulLineID >= pAdapter->ulActualVcs)
        {
            fBadSapPort = TRUE;
            break;
        }

        // Save NDIS's SAP handle in the adapter control block.  Extract
        // "listen" port from SAP parameters.
        //
        ulSapPort = LineIdPortLookup( pAdapter, pSap->ulLineID );
        if (ulSapPort >= NPORTS)
        {
            fBadSapPort = TRUE;
            break;
        }

        pAdapter->NdisSapHandle = NdisSapHandle;
        pAdapter->ulSapPort = ulSapPort;
    }
    while (FALSE);
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (fSapExists)
    {
        TRACE( TL_A, TM_Cm, ( "SAP exists?" ) );
        return NDIS_STATUS_SAP_IN_USE;
    }

    if (fBadSapLength)
    {
        ASSERT( !"Bad SAP length?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    if (fBadSapPort)
    {
        ASSERT( !"Bad SAP port?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // Allocate and zero a VC control block, then make any non-zero
    // initializations.
    //
    pVc = ALLOC_VCCB( pAdapter );
    if (!pVc)
    {
        ASSERT( !"Alloc VC?" );
        return NDIS_STATUS_RESOURCES;
    }
    NdisZeroMemory( pVc, sizeof(*pVc) );
    ReferenceVc( pVc );
    pVc->ulTag = MTAG_VCCB;
    pVc->pAdapter = pAdapter;
    ReferenceAdapter( pAdapter );

    // Now we have a temporary "Vc" to listen on ... save it
    //
    pAdapter->pListenVc = pVc;

    // PtiOpen must be called at PASSIVE IRQL so schedule an APC to do it.
    //
    status = ScheduleWork( pAdapter, RegisterSapPassive, pAdapter );
    if (status != NDIS_STATUS_SUCCESS)
    {
        DereferenceVc( pAdapter->pListenVc );
        pAdapter->pListenVc = NULL;

        NdisAcquireSpinLock( &pAdapter->lockSap );
        {
            pAdapter->NdisSapHandle = NULL;
            pAdapter->ulSapPort = 0;
        }
        NdisReleaseSpinLock( &pAdapter->lockSap );

        return status;
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmRegSap: Exit: pListenVc=$%p", pVc ) );
    return NDIS_STATUS_PENDING;
}


VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC procedure to complete the registering of a SAP begun in
    // PtiCmRegisterSap.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hSap;

    TRACE( TL_N, TM_Cm, ( "RegSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Start listening ...
    //
    TRACE( TL_I, TM_Cm,
        ( "PtiCmRegSap: New SAP, Port=$%x", pAdapter->ulSapPort ) );
    status = PtiOpenPtiLink( pAdapter->pListenVc, pAdapter->ulSapPort );

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        hSap = pAdapter->NdisSapHandle;

        if (NT_SUCCESS( status ))
        {
            // Mark the SAP active allowing references to be taken, and take
            // the initial reference for SAP registry, plus those for address
            // family and adapter.
            //
            SetFlags( &pAdapter->ulFlags, ACBF_SapActive );
            ASSERT( pAdapter->lSapRef == 0 );
            TRACE( TL_N, TM_Ref, ( "RefSap-ish to 1" ) );
            pAdapter->lSapRef = 1;
            ReferenceAdapter( pAdapter );
            ReferenceAf( pAdapter );
        }
        else
        {
            // Failed to get TDI set up, so NULL the SAP handle in the adapter
            // control block.
            //
            TRACE( TL_A, TM_Cm,
                 ( "PtiCmRegSap: Error: Open failed: status=$%x", status ) );

            DereferenceVc( pAdapter->pListenVc );
            pAdapter->pListenVc = NULL;
            pAdapter->NdisSapHandle = NULL;
            pAdapter->ulSapPort = 0;
            status = NDIS_STATUS_FAILURE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (status != STATUS_SUCCESS)
    {
        // Remove the NdisSapHandle reference since we NULLed it above while
        // locks were held.
        //
        DereferenceAdapter( pAdapter );
    }

    // Remove the reference for scheduled work.  Must occur before telling
    // NDIS because it could call Halt and unload the driver before we ever
    // get control again resulting in a C4 bugcheck.  (Yes, this actually
    // happened)
    //
    DereferenceAdapter( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp=$%08x", status ) );
    NdisMCmRegisterSapComplete( status, hSap, (NDIS_HANDLE )pAdapter );
    TRACE( TL_I, TM_Cm, ( "NdisMCmRegSapComp done" ) );
}


NDIS_STATUS
PtiCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext )

    // Standard 'CmDeregisterSapHandler' routine called by NDIS when the a
    // client has requested to de-register a service access point.  See DDK
    // doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "PtiCmDeregSap" ) );

    pAdapter = (ADAPTERCB* )CallMgrSapContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            ASSERT( pAdapter->NdisSapHandle );
            ClearFlags( &pAdapter->ulFlags, ACBF_SapActive );
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ASSERT( !"No SAP active?" );
            status = NDIS_STATUS_FAILURE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (status == NDIS_STATUS_PENDING)
    {
        // Remove the reference for SAP registry.  Eventually, the SAP
        // references will fall to 0 and DereferenceSap will call
        // DeregisterSapWork to complete the de-registry.
        //
        DereferenceSap( pAdapter );
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmDeregSap=$%x", status ) );
    return status;
}


VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the de-registering of a SAP begun in
    // PtiCmDeregisterSap.
    //
{
    ADAPTERCB* pAdapter;
    NDIS_HANDLE hOldSap;
    VCCB* pVc;

    TRACE( TL_I, TM_Cm, ( "DeregSapPassive" ) );

    // Unpack context information then free the work item.
    //
    pAdapter = (ADAPTERCB* )pContext;
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Stop receiving datagrams (at least on behalf of this SAP) and
    // deregister the SAP.
    //
    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        pVc = pAdapter->pListenVc;
        pAdapter->pListenVc = NULL;
        hOldSap = pAdapter->NdisSapHandle;
        pAdapter->NdisSapHandle = NULL;
        pAdapter->ulSapPort = 0;
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (pVc)
    {
        TRACE( TL_I, TM_Cm,
            ( "PtiCmDeregSapPassive: Closing link for Dereg SAP" ) );
        PtiClosePtiLink( pVc );
        DereferenceVc( pVc );
    }
    else
    {
        TRACE( TL_A, TM_Cm, ( "PtiCmDeregSapPassive: !pListenVc?" ) );
    }

    // Remove the adapter references for the NdisSapHandle and for scheduled
    // work.  Remove the address family reference for the NdisSapHandle.  Do
    // all this before telling NDIS the deregister is complete as it may call
    // Halt and unload the driver before we run again, giving C4 bugcheck.
    //
    DereferenceAdapter( pAdapter );
    DereferenceAdapter( pAdapter );
    DereferenceAf( pAdapter );

    // Report result to client.
    //
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp" ) );
    NdisMCmDeregisterSapComplete( NDIS_STATUS_SUCCESS, hOldSap );
    TRACE( TL_I, TM_Cm, ( "NdisMCmDeregSapComp done" ) );
}


NDIS_STATUS
PtiCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext )

    // Standard 'CmMakeCallHandler' routine called by NDIS when the a client
    // has requested to connect to a remote end-point.  See DDK doc.
    //
{
    NDIS_STATUS status;
    CO_SPECIFIC_PARAMETERS* pMSpecifics;
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    ULONG ulIpAddress;

    TRACE( TL_I, TM_Cm, ( "PtiCmMakeCall" ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    ReferenceVc( pVc );
    pAdapter = pVc->pAdapter;

    // PTI has no concept of point-to-multi-point "parties".
    //
    if (CallMgrPartyContext)
    {
        *CallMgrPartyContext = NULL;
    }

    // Validate call parameters.
    //
    do
    {
        // PTI provides switched VCs only.
        //
        if (CallParameters->Flags &
                (PERMANENT_VC | BROADCAST_VC | MULTIPOINT_VC))
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        // Make sure caller provided the TAPI call parameters we expect.
        // Currently, the only parameter in the TAPI call parameters actually
        // used is the 'ulLineID' identifying the LPTx port.  No validating of
        // the LINE_CALL_PARAMS is done at all as we choose not to be picky
        // about arguments we intend to ignore.
        //
        if (!CallParameters->MediaParameters)
        {
            status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        pMSpecifics = &CallParameters->MediaParameters->MediaSpecific;
        if (pMSpecifics->Length < sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS))
        {
            status = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        pTmParams = (CO_AF_TAPI_MAKE_CALL_PARAMETERS* )&pMSpecifics->Parameters;
        if (pTmParams->ulLineID >= pAdapter->ulActualVcs)
        {
            status = NDIS_STATUS_INVALID_DATA;
            break;
        }

        status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        DereferenceVc( pVc );
        return status;
    }

    // Simultaneous MakeCalls on the same VC is a client error, but it's easy
    // to guard against so do that here.
    //
    if (InterlockedCompareExchangePointer(
        &pVc->pMakeCall, CallParameters, NULL ))
    {
        ASSERT( !"Double MakeCall?" );
        DereferenceVc( pVc );
        return NDIS_STATUS_CALL_ACTIVE;
    }

    pVc->pTmParams = pTmParams;

    // Mark that the call is in a state where close requests can be accepted,
    // but incoming packets should not trigger a new incoming call.  Mark the
    // call that an open is pending.
    //
    SetFlags( &pVc->ulFlags,
        (VCBF_ClientOpenPending
         | VCBF_CallClosableByClient
         | VCBF_CallClosableByPeer
         | VCBF_CallInProgress) );

    status = ScheduleWork( pAdapter, MakeCallPassive, pVc );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"SchedWork?" );
        CallCleanUp( pVc );
        DereferenceVc( pVc );
        return status;
    }

    // The VC reference will be removed by MakeCallPassive.
    //
    TRACE( TL_V, TM_Cm, ( "PtiCmMakeCall pending" ) );
    return NDIS_STATUS_PENDING;
}


VOID
MakeCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the call initiation begun in
    // LcmCmMakeCall.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NTSTATUS PtiLinkStatus;
    ULONG PortIndex;

    TRACE( TL_I, TM_Cm, ( "MakeCallPassive" ) );

    // Unpack context information then free the work item.
    //
    pVc = (VCCB* )pContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );
    pAdapter = pVc->pAdapter;
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    // Make the call...
    //
    TRACE( TL_N, TM_Cm,
         ( "PtiCmMakeCall: Make Call on TAPI Line Id $%x ...",
           pVc->pTmParams->ulLineID ) );

    // Map TAPI Line Id to Port Index
    //
    PortIndex = LineIdPortLookup( pAdapter, pVc->pTmParams->ulLineID );

    if ( PortIndex > NPORTS )
    {
        TRACE( TL_A, TM_Cm,
             ( "PtiCmMakeCall: Cannot find Port for Line Id",
               pVc->pTmParams->ulLineID ) );

        pVc->status = NDIS_STATUS_TAPI_INVALLINEHANDLE;
        return;
    }

    TRACE( TL_N, TM_Cm,
         ( "PtiCmMakeCall: Making Call on Port $%x ...",
           PortIndex ) );

    PtiLinkStatus = PtiOpenPtiLink( pVc, PortIndex );

    if (ReferenceSap( pAdapter ))
    {
        // Listen VC mechanism-dependent.
        //
        SetFlags( &pAdapter->pListenVc->ulFlags, VCBF_CallInProgress );
        DereferenceSap( pAdapter );
    }

    if (IsWin9xPeer( pVc ))
    {
        SendClientString( pVc->PtiExtension );
    }

    pVc->status = PtiLinkStatus;
    CompleteVc( pVc );

    DereferenceVc( pVc );

    // Remove the reference for scheduled work.
    //
    DereferenceAdapter( pAdapter );

    TRACE( TL_V, TM_Cm,
        ( "PtiCmMakeCall: Exit: Link Status=$%x", PtiLinkStatus ) );
}


NDIS_STATUS
PtiCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size )

    // Standard 'CmCloseCallHandler' routine called by NDIS when the a client
    // has requested to tear down a call.  See DDK doc.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    ULONG ulFlags;
    BOOLEAN fCallClosable;

    TRACE( TL_I, TM_Cm, ( "PtiCmCloseCall: pVc=$%p", CallMgrVcContext ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    ReferenceVc( pVc );

    status = NDIS_STATUS_SUCCESS;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockV );
    {
        ulFlags = ReadFlags( &pVc->ulFlags );

        if (ulFlags & VCBF_CallClosableByClient)
        {
            fCallClosable = TRUE;

            // Accepting this close makes the call no longer closable by
            // client or peer.  Any peer operation that was pending is
            // cleared, and a client close becomes pending.  It is possible to
            // have both a client open and close pending at the same time.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient
                 | VCBF_CallClosableByPeer
                 | VCBF_PeerClosePending
                 | VCBF_PeerOpenPending) );
            SetFlags( &pVc->ulFlags, VCBF_ClientClosePending );

            // If a client open is pending, it fails.
            //
            if (ulFlags & VCBF_ClientOpenPending)
            {
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
            }
        }
        else
        {
            TRACE( TL_A, TM_Cm, ( "Call not closable" ) );
            fCallClosable = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockV );

    if (fCallClosable)
    {
        // Close the call, being graceful if possible.
        //
        status = ScheduleWork( pAdapter, CloseCallPassive, pVc );
    }

    if (status != NDIS_STATUS_SUCCESS)
    {
        DereferenceVc( pVc );
        return status;
    }

    TRACE( TL_V, TM_Cm, ( "PtiCmCloseCall: Exit: Pending" ) );
    return NDIS_STATUS_PENDING;
}



VOID
PtiCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmIncomingCallCompleteHandler' routine called by NDIS when
    // a client has responded to the call-managers's previously dispatched
    // incoming call.  See DDK doc.
    //
{
    VCCB* pVc;

    TRACE( TL_I, TM_Cm,
        ( "PtiCmInCallComp, pVc=$%p, Status=$%08x",
        CallMgrVcContext, Status ) );

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return;
    }

    ReferenceVc( pVc );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        pVc->status = Status;

        // Turn off the "call NdisMCmDispatchIncomingCloseCall if peer
        // terminates the call" flag.  It was turned on even though peer
        // pended, per JameelH.
        //
        ClearFlags( &pVc->ulFlags, VCBF_VcDispatched );
    }

    SetupVcComplete( pVc );

    DereferenceVc( pVc );

    TRACE( TL_V, TM_Cm, ( "PtiCmInCallComp: Exit" ) );
}


VOID
PtiCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmActivateVcCompleteHandler' routine called by NDIS when the
    // mini-port has completed the call-manager's previous request to activate
    // a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"PtiCmActVcComp?" );
}


VOID
PtiCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext )

    // Standard 'CmDeactivateVcCompleteHandler' routine called by NDIS when
    // the mini-port has completed the call-manager's previous request to
    // de-activate a virtual circuit.  See DDK doc.
    //
{
    ASSERT( !"PtiCmDeactVcComp?" );
}


NDIS_STATUS
PtiCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters )

    // Standard 'CmModifyQoSCallHandler' routine called by NDIS when a client
    // requests a modification in the quality of service provided by the
    // virtual circuit.  See DDK doc.
    //
{
    TRACE( TL_N, TM_Cm, ( "PtiCmModQoS" ) );

    // There is no useful concept of quality of service for DirectParallel.
    //
    return NDIS_STATUS_NOT_SUPPORTED;
}


NDIS_STATUS
PtiCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'CmRequestHandler' routine called by NDIS in response to a
    // client's request for information from the mini-port.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_I, TM_Cm, ( "PtiCmReq" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )CallMgrVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryCmInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            TRACE( TL_A, TM_Cm,
               ( "CmSetOID=%d?", NdisRequest->DATA.SET_INFORMATION.Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Cm, ( "CmType=%d?", NdisRequest->RequestType ) );
            break;
        }
    }

    return status;
}


//-----------------------------------------------------------------------------
// Call utility routines (almost alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------


NDIS_STATUS
PtiOpenPtiLink(
    IN VCCB* pVc,
    IN ULONG ulPort)

    // Opens the PTILINK device
    //
    // IMPORTANT: Must only be called at PASSIVE IRQL.
    //
{
    UNICODE_STRING      name, prefix, digits;
    WCHAR               nameBuffer[40], digitsBuffer[10];
    NTSTATUS            ntStatus;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     iosb;
    LONG                lRef;
    ADAPTERCB*          pAdapter;

    TRACE( TL_N, TM_Cm, ( "PtiOpenPtiLink: Port=$%x", ulPort ) );

    if ( pVc->ulTag != MTAG_VCCB )
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    pAdapter = pVc->pAdapter;

    // If PtiLink[ulPort] is already open, do nothing
    //   It may have already been opened by SAP actions

    if ( pAdapter->hPtiLinkTable[ulPort] == 0 )
    {
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Making name for Port=$%x", ulPort ) );

        // convert integer port number into unicode string
        //
        RtlZeroMemory( digitsBuffer, sizeof(digitsBuffer) );
        digits.Length = 0;
        digits.MaximumLength = 20;
        digits.Buffer = digitsBuffer;
        ntStatus = RtlIntegerToUnicodeString( ulPort + 1, 10, &digits );

        if ( !NT_SUCCESS(ntStatus) )
        {
            TRACE( TL_A, TM_Cm, ( "PtiOpenPtiLink: Port=$%x invalid?", ulPort ) );
            return NDIS_STATUS_INVALID_DATA;
        }

        RtlZeroMemory( nameBuffer, sizeof(nameBuffer) );
        name.Length = 0;
        name.MaximumLength = 80;
        name.Buffer = nameBuffer;
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Name should be NULL: %wZ", &name ) );

        RtlInitUnicodeString( &prefix, L"\\DosDevices\\PTILINK" );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Prefix part        : %wZ", &prefix ) );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Digits part        : %wZ", &digits ) );

        RtlAppendUnicodeStringToString( &name, &prefix );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Name with prefix   : %wZ", &name ) );

        RtlAppendUnicodeStringToString( &name, &digits );
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Name with digits   : %wZ", &name ) );

        InitializeObjectAttributes(
            &oa, &name, OBJ_CASE_INSENSITIVE, NULL, NULL );

        // Open the link device
        //
        TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Opening %wZ", &name ) );

        ntStatus = ZwCreateFile(
                        &pVc->hPtiLink,             // pointer to desired handle
                        FILE_READ_DATA | FILE_WRITE_DATA,
                        &oa,
                        &iosb,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        0,
                        FILE_OPEN,
                        0,
                        NULL,
                        0 );

        if ( !NT_SUCCESS( ntStatus ) )
        {
            TRACE( TL_A, TM_Cm, ( "PtiOpenPtiLink: %wZ Open Failure = $%x",
                                    &name, ntStatus ) );
            return NDIS_STATUS_RESOURCES;
        }

        // save a copy of the PtiLink handle in ADAPTERCB
        //
        pAdapter->hPtiLinkTable[ulPort] = pVc->hPtiLink;
        TRACE( TL_N, TM_Cm, ( "PtiOpenPtilink: h=$%p",
            pAdapter->hPtiLinkTable[ulPort] ) );

        RtlInitUnicodeString( &name, NULL );
    }

    // Init the PtiLink API ... getting the extension pointers
    //
    pVc->ulVcParallelPort = ulPort;
    ntStatus = PtiInitialize( ulPort,
                              &pVc->Extension,
                              &pVc->PtiExtension);          // get PTILINKx extension
                                                            //  also fires ECPdetect
                                                            //  and enables port IRQ

    TRACE( TL_V, TM_Cm, ( "PtiOpenPtilink: PtiLink Init: Ext=$%p, PtiExt=$%p",
                           pVc->Extension,
                           pVc->PtiExtension ) );

    if ( (pVc->Extension == NULL) || (pVc->PtiExtension == NULL) )
    {
        TRACE( TL_A, TM_Cm, (
            "PtiOpenPtiLink: Null Pointer Detected: Ext=$%p, PtiExt=$%p",
                pVc->Extension,
                pVc->PtiExtension ) );

        return NDIS_STATUS_RESOURCES;
    }

    if ( !NT_SUCCESS( ntStatus ) )
    {
        TRACE( TL_V, TM_Cm, ( "PtiInitialize Failure = $%08x", ntStatus ) );
        return NDIS_STATUS_RESOURCES;
    }

    // Register our callbacks with PtiLink
    //
    TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: RegCb pV=$%p", pVc ) );
    PtiRegisterCallbacks(pVc->Extension,                    // the PTILINKx extension
                         PtiCbGetReadBuffer,                // our get buffer routine
                         PtiRx,                             // our receive complete routine
                         PtiCbLinkEventHandler,             // our link event handler
                         pVc);                              // our context

    // Zero the counters
    //
    pVc->ulTotalPackets = 0;

    TRACE( TL_V, TM_Cm, ( "PtiOpenPtiLink: Exit" ) );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiClosePtiLink(
    IN VCCB* pVc )

    // Closes the PTILINK device
    //
    // IMPORTANT: This routine must only be called at PASSIVE IRQL.
    //
{
    NTSTATUS ntStatus;
    ADAPTERCB* pAdapter;

    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }
    pAdapter = pVc->pAdapter;

    TRACE( TL_N, TM_Cm, ( "PtiClosePtiLink: pVc=$%p, Port$%x, h=$%p",
        pVc, pVc->ulVcParallelPort,
        pAdapter->hPtiLinkTable[ pVc->ulVcParallelPort ] ));

    // dispose of the connection
    //
    ntStatus = ZwClose( pAdapter->hPtiLinkTable[ pVc->ulVcParallelPort ] );
    pVc->hPtiLink = NULL;
    pAdapter->hPtiLinkTable[ pVc->ulVcParallelPort ] = NULL;
    pVc->ulVcParallelPort = 0;

    if (ReferenceSap( pAdapter ))
    {
        pAdapter->pListenVc->hPtiLink = NULL;
        DereferenceSap( pAdapter );
    }

    if ( !NT_SUCCESS( ntStatus ) )
    {
        // close failed
        TRACE( TL_V, TM_Cm,
            ( "PtiClosePtiLink: Error: CloseFailure=$%08x", ntStatus ) );
        return ntStatus;
    }

    TRACE( TL_V, TM_Cm, ( "PtiClosePtiLink: Exit" ) );
    return NDIS_STATUS_SUCCESS;
}


VOID
CallCleanUp(
    IN VCCB* pVc )

    // De-associates the VC from the tunnel, preparing for and de-activating
    // the call.
    //
{
    NDIS_STATUS status;
    ULONG ulFlags;

    ulFlags = ReadFlags( &pVc->ulFlags );

    TRACE( TL_A, TM_Cm,
         ( "CallCleanUp: pVc=$%p, fActivated=%x",
            pVc,
            ulFlags & VCBF_VcActivated ) );

    ASSERT( pVc->ulTag == MTAG_VCCB );

    // Client initiated close completed.
    //
    if (ulFlags & VCBF_VcActivated)
    {
        TRACE( TL_I, TM_Recv, ( "NdisMCmDeactVc" ) );
        status = NdisMCmDeactivateVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Recv, ( "NdisMCmDeactVc=$%x", status ) );
        ASSERT( status == NDIS_STATUS_SUCCESS );

        ClearFlags( &pVc->ulFlags, VCBF_VcActivated );
        DereferenceCall( pVc );

        // The above actions lead to the call reference eventually going to 0,
        // at which time clean up resumes in DereferenceCall.
        //
    }
    else
    {
        InactiveCallCleanUp( pVc );
    }
}


VOID
CallSetupComplete(
    IN VCCB* pVc )

    // Clean up 'pVc' allocations used only at call setup.
    //
{
    if (InterlockedExchangePointer( &pVc->pMakeCall, NULL ))
    {
        ASSERT( pVc->pTmParams );
        pVc->pTmParams = NULL;
    }

    if (pVc->pInCall)
    {
        FREE_NONPAGED( pVc->pInCall );
        pVc->pInCall = NULL;
        pVc->pTiParams = NULL;
    }
}


VOID
CallTransitionComplete(
    IN VCCB* pVc )

    // Sets 'pVc's state to it's idle state and sets up for reporting the
    // result to the client after the lock is released.
    //
    // IMPORTANT: Caller must hold 'pVc->lockV'.
    //
{
    ULONG ulFlags;

    ulFlags = ReadFlags( &pVc->ulFlags );
    if (!(ulFlags & VCBM_Pending))
    {
        if (ulFlags & VCBF_CallClosableByPeer)
        {
            // Nothing else was pending and the call is closable so either
            // peer initiated a close or some fatal error occurred which will
            // be cleaned up as if peer initiated a close.
            //
            ASSERT( pVc->status != NDIS_STATUS_SUCCESS );
            SetFlags( &pVc->ulFlags, VCBF_PeerClosePending );
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
        else
        {
            // Nothing was pending and the call's not closable, so there's no
            // action required for this transition.
            //
            TRACE( TL_A, TM_Fsm, ( "Call not closable" ) );
            return;
        }
    }
    else if (ulFlags & VCBF_ClientOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending client open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from both client and peer.
            //
            ClearFlags( &pVc->ulFlags,
                (VCBF_CallClosableByClient | VCBF_CallClosableByPeer ));
        }
    }
    else if (ulFlags & VCBF_PeerOpenPending)
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // A pending peer open just failed and will bring down the call.
            // From this point on we will fail new attempts to close the call
            // from the peer.  Client closes must be accepted because of the
            // way CoNDIS loops dispatched close calls back to the CM's close
            // handler.
            //
            ClearFlags( &pVc->ulFlags, VCBF_CallClosableByPeer );
        }
    }
}


VOID
CloseCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext )

    // An NDIS_PROC routine to complete the call close begun in
    // LcmCmCloseCall.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NTSTATUS PtiLinkStatus;

    // Unpack context information then free the work item.
    //
    pVc = (VCCB* )pContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );
    pAdapter = pVc->pAdapter;
    FREE_NDIS_WORK_ITEM( pAdapter, pWork );

    TRACE( TL_I, TM_Cm, ( "CloseCallPassive: Closing link for Close Call" ) );
    PtiClosePtiLink( pVc );
    if (ReferenceSap( pAdapter ))
    {
        TRACE( TL_N, TM_Cm, ( "CloseCall: reOpening link, SAP exists" ) );
        PtiOpenPtiLink( pAdapter->pListenVc, pAdapter->ulSapPort );
        DereferenceSap( pAdapter );
    }

    NdisAcquireSpinLock( &pVc->lockV );
    {
        CallTransitionComplete( pVc );
    }
    NdisReleaseSpinLock( &pVc->lockV );

    CompleteVc( pVc );

    // Remove the reference added by PtiCmCloseCall.
    //
    DereferenceVc( pVc );

    // Remove the reference for scheduled work.
    //
    DereferenceAdapter( pAdapter );
    TRACE( TL_V, TM_Cm, ( "CloseCall: Exit" ) );
}


VOID
CompleteVc(
    IN VCCB* pVc )

    // Complete the pending operation for a specific VC
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    ULONG ulFlags;

    pAdapter = pVc->pAdapter;

    TRACE( TL_V, TM_Recv, ( "CompleteVc: pVc=$%p", pVc ) );

    NdisAcquireSpinLock( &pVc->lockV );
    {
        // Note the pending flags then clear them, to ensure that all
        // pending operations are completed exactly once.  This is
        // necessary since ClientOpen and ClientClose events may be
        // pending simultaneously.  (Thanks a lot NDIS guys).
        //
        ulFlags = ReadFlags( &pVc->ulFlags );
        ClearFlags( &pVc->ulFlags, VCBM_Pending );

        // Convert client close pending to client close completion,
        // for reference later when call references reach zero.  The
        // flag determines if NdisMCmCloseCallComplete must be called.
        //
        if (ulFlags & VCBF_ClientClosePending)
        {
            SetFlags( &pVc->ulFlags, VCBF_ClientCloseCompletion );
        }
    }
    NdisReleaseSpinLock( &pVc->lockV );

    if (ulFlags & VCBF_PeerOpenPending)
    {
        TRACE( TL_N, TM_Recv,
            ( "CompleteVc: PeerOpen complete, Status=$%x", pVc->status ) );

        if (pVc->status == NDIS_STATUS_SUCCESS)
        {
            // Peer initiated call succeeded.
            //
            ASSERT( ulFlags & VCBF_VcDispatched );
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispCallConn" ) );
            NdisMCmDispatchCallConnected( pVc->NdisVcHandle );
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispCallConn done" ) );

            CallSetupComplete( pVc );
        }
        else
        {
            // Peer initiated call failed.
            //
            if (ulFlags & VCBF_VcDispatched)
            {
                ClearFlags( &pVc->ulFlags, VCBF_VcDispatched );

                TRACE( TL_I, TM_Recv,
                    ( "CompleteVc: NdisMCmDispInCloseCall: status=$%x", pVc->status ) );
                NdisMCmDispatchIncomingCloseCall(
                    pVc->status, pVc->NdisVcHandle, NULL, 0 );
                TRACE( TL_I, TM_Recv,
                    ( "CompleteVc: NdisMCmDispInCloseCall done" ) );

                // Client will call NdisClCloseCall which will get our
                // PtiCloseCall handler called to clean up call setup,
                // de-activate and delete the VC, as necessary.
                //
            }
            else
            {
                // Return the VC to "just created" state.
                //
                CallCleanUp( pVc );
            }
        }
    }
    else if (ulFlags & VCBF_ClientOpenPending)
    {

        TRACE( TL_N, TM_Recv,
            ( "CompleteVc: ClientOpen complete: status=$%x", pVc->status ) );

        // Pick the call parameters out of the VC block now.  See non-success
        // case below.
        //

        //
        // Set our flowspec params based on the actual
        // connection speed
        //
        {
            CO_CALL_PARAMETERS* pCp;
            CO_CALL_MANAGER_PARAMETERS* pCmp;
            LINE_CALL_INFO* pLci;
            CO_MEDIA_PARAMETERS* pMp;
            CO_AF_TAPI_MAKE_CALL_PARAMETERS* pTi;
            LINE_CALL_PARAMS* pLcp;

            ASSERT( pVc->pMakeCall );

            pCp = pVc->pMakeCall;
            pCmp = pCp->CallMgrParameters;

            //
            // Might want to make this report the actual
            // connection speed in the future
            //
            pCmp->Transmit.TokenRate =
            pCmp->Transmit.PeakBandwidth =
            pCmp->Receive.TokenRate =
            pCmp->Receive.PeakBandwidth = PTI_LanBps/8;

            pMp = pCp->MediaParameters;

            pTi = (CO_AF_TAPI_MAKE_CALL_PARAMETERS*)
                &pMp->MediaSpecific.Parameters[0];

            pLcp = (LINE_CALL_PARAMS*)
                ((ULONG_PTR)pTi->LineCallParams.Offset +
                 (ULONG_PTR)pTi);

            //
            // Might want to make this report the actual
            // connection speed in the future
            //
            pLcp->ulMinRate =
            pLcp->ulMaxRate = PTI_LanBps/8;

        }

        if (pVc->status == NDIS_STATUS_SUCCESS)
        {
            // Client initiated open, i.e. MakeCall, succeeded.
            //
            // Activating the VC is a CoNDIS preliminary to reporting the
            // MakeCall complete.  For L2TP, all it does is get the NDIS
            // state flags set correctly.
            //
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmActivateVc" ) );
            ASSERT( pVc->pMakeCall );
            status = NdisMCmActivateVc(
                pVc->NdisVcHandle, pVc->pMakeCall );
            TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmActivateVc: status=$%x", status ) );
            ASSERT( status == NDIS_STATUS_SUCCESS );

            SetFlags( &pVc->ulFlags, VCBF_VcActivated );
            ReferenceCall( pVc );
        }
        else
        {
            // Clean up the call parameters before calling MakeCallComplete
            // because they must not be referenced after that call.
            //
            CallSetupComplete( pVc );
        }

        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmMakeCallComp, status=$%x",
            pVc->status ) );
        NdisMCmMakeCallComplete(
            pVc->status, pVc->NdisVcHandle, NULL, NULL, pVc->pMakeCall );
        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmMakeCallComp done" ) );

        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            // Return the VC to "just created" state.
            //
            InactiveCallCleanUp( pVc );
        }
    }
    else if (ulFlags & VCBF_PeerClosePending )
    {
        TRACE( TL_N, TM_Recv, ( "CompleteVc: PeerClose complete, status=$%x", pVc->status ) );

        // Peer initiated close completed.
        //
        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispInCloseCall, status=$%x",
            pVc->status ) );
        NdisMCmDispatchIncomingCloseCall(
            pVc->status, pVc->NdisVcHandle, NULL, 0 );
        TRACE( TL_I, TM_Recv, ( "CompleteVc: NdisMCmDispInCloseCall done" ) );

        // Client will call NdisClCloseCall while processing the above
        // which will get our PtiCloseCall handler called to de-activate
        // and delete the VC, as necessary.
        //
    }
    else if (ulFlags & VCBF_ClientClosePending)
    {
        // This section eventually runs for all successful unclosed
        // calls, whether peer or client initiated or closed.
        //
        TRACE( TL_N, TM_Recv,
            ( "CompleteVc: ClientClose complete, status=$%x", pVc->status ) );

        // Deactivate the VC and return all sent packets to the client above.
        // These events will eventually lead to the call being dereferenced to
        // zero, at which time the close is completed, and if peer initiated,
        // the VC is deleted.
        //
        // Note: When MakeCall is cancelled by a Close request, these actions
        //       occur during the InactiveCallCleanUp in the ClientOpenPending
        //       completion code handling, rather than the CallCleanUp (which
        //       leads to InactiveCallCleanUp) here.  In this case, this block
        //       does NOT run even though the ClientClosePending flag is set.
        //       Consider this before adding code here.
        //
        CallCleanUp( pVc );
    }

    TRACE( TL_N, TM_Recv,( "CompleteVc: Exit" ) );
}


VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the address family of adapter control block
    // 'pAdapter', and when frees the block when the last reference is
    // removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "DerefAf to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        HANDLE h;

        // Remove the reference for the NdisAfHandle.  Must do this *before*
        // telling NDIS the close succeeded as it may Halt and unload the
        // driver before we run again here, giving C4 bugcheck.
        //
        h = pAdapter->NdisAfHandle;
        InterlockedExchangePointer( &pAdapter->NdisAfHandle, NULL );
        DereferenceAdapter( pAdapter );

        // Tell NDIS it's close is complete.
        //
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp" ) );
        NdisMCmCloseAddressFamilyComplete( NDIS_STATUS_SUCCESS, h );
        TRACE( TL_I, TM_Cm, ( "NdisMCmCloseAfComp done" ) );
    }
}


VOID
DereferenceCall(
    IN VCCB* pVc )

    // Removes a reference from the call active on 'pVc', invoking call clean
    // up when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    pAdapter = pVc->pAdapter;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        lRef = --pVc->lCallRef;
        TRACE( TL_N, TM_Ref, ( "DerefCall to %d", pVc->lCallRef ) );
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    if (lRef == 0)
    {
        CallCleanUp( pVc );
    }
}


VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the SAP active on 'pAdapter', invoking
    // Deregiter SAP completion handling when the value reaches zero.
    //
{
    LONG lRef;
    NDIS_STATUS status;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        lRef = --pAdapter->lSapRef;
        TRACE( TL_N, TM_Ref, ( "DerefSap to %d", pAdapter->lSapRef ) );
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    if (lRef == 0)
    {
        status = ScheduleWork( pAdapter, DeregisterSapPassive, pAdapter );
        ASSERT( status == NDIS_STATUS_SUCCESS );
    }
}


VOID
InactiveCallCleanUp(
    IN VCCB* pVc )

    // Cleans up a deactivated call.  To clean up a call that might be active,
    // use CallCleanUp instead.  Returns the VC to "just created" state, in
    // case client decides to make another call without deleting the VC.
    //
{
    ULONG ulFlags;
    BOOLEAN fVcCreated;
    ADAPTERCB* pAdapter;
    LIST_ENTRY* pLink;

    TRACE( TL_N, TM_Cm, ( "InactiveCallCleanUp, pVc=$%p", pVc ) );

    pAdapter = pVc->pAdapter;

    // Release any call parameter allocations and disable receives.
    //
    CallSetupComplete( pVc );
    ClearFlags( &pVc->ulFlags, VCBF_CallInProgress );

    ulFlags = ReadFlags( &pVc->ulFlags );

#if 0
    if (ulFlags & VCBF_PeerInitiatedCall)
    {
        DereferenceSap( pAdapter );
    }
#endif

    // Return the VC to "just created" state.
    //
    ClearFlags( &pVc->ulFlags, 0xFFFFFFFF );
    pVc->status = NDIS_STATUS_SUCCESS;
    pVc->usResult = 0;
    pVc->usError = 0;
    pVc->ulConnectBps = 0;

    if (ulFlags & VCBF_ClientCloseCompletion)
    {
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp(OK)" ) );
        NdisMCmCloseCallComplete(
            NDIS_STATUS_SUCCESS, pVc->NdisVcHandle, NULL );
        TRACE( TL_I, TM_Recv, ( "NdisMCmCloseCallComp done" ) );

        // Careful, if this was a client created VC, client may have deleted
        // it, so 'pVc' must not be referenced hereafter in that case.
        //
    }

    // When peer initiates the call, we create the VC and so delete it
    // here.  Otherwise, client created it and we leave it to him to
    // delete it when he's ready.
    //
    if (ulFlags & VCBF_VcCreated)
    {
        NDIS_STATUS status;

        TRACE( TL_I, TM_Recv, ( "InactiveCallCleanUp: NdisMCmDelVc" ) );
        status = NdisMCmDeleteVc( pVc->NdisVcHandle );
        TRACE( TL_I, TM_Recv, ( "InactiveCallCleanUp: NdisMCmDelVc: status=$%x", status ) );
        ASSERT( status == NDIS_STATUS_SUCCESS );
        PtiCmDeleteVc( pVc );

        // Careful, 'pVc' has been deleted and must not be referenced
        // hereafter.
        //
    }
}

#if 0
ULONG
LineIdAdd(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId )

    // Insert the LineId in the first available slot in ulLineIds
    // Return the port index associated with the new LineId,
    //   or an invalid port index if the LineId cannot be added
    //
{
    ULONG   ulPortIndex;

    for (ulPortIndex = 0; ulPortIndex < NPORTS; ulPortIndex++)
    {
        // If the port exists and has no assigned LineId
        //
        if ( ( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_PortExists ) &&
             !( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_LineIdValid))
        {
            // assign the TAPI Line Id to this port
            // and return the port index
            //
            pAdapter->ulLineIds[ulPortIndex] = LineId;
            pAdapter->ulPtiLinkState[ulPortIndex] |= PLSF_LineIdValid;
            break;
        }
    }

    return ulPortIndex;
}
#endif

ULONG
LineIdPortLookup(
    IN ADAPTERCB* pAdapter,
    IN ULONG LineId )

    // Find the LineId in ulLineIds
    // Return the port index associated with the LineId,
    //   or an invalid port index if the LineId cannot be found
    //
{
    ULONG   ulPortIndex;

    for (ulPortIndex = 0; ulPortIndex < NPORTS; ulPortIndex++)
    {
        // If the port exists and
        //
        if ( ( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_PortExists ) &&
             ( pAdapter->ulPtiLinkState[ulPortIndex] & PLSF_LineIdValid) &&
             ( LineId == pAdapter->ulLineIds[ulPortIndex] ))
        {
            // return the port index
            //
            break;
        }
    }

    return ulPortIndex;
}


NDIS_STATUS
QueryCmInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle Call Manager QueryInformation requests.  Arguments are as for
    // the standard NDIS 'MiniportQueryInformation' handler except this
    // routine does not count on being serialized with respect to other
    // requests.
    //
{
    #define PTI_PORT_NAME_LEN 4

    typedef struct
    PTI_CO_TAPI_LINE_CAPS
    {
        CO_TAPI_LINE_CAPS caps;
        WCHAR achLineName[ MAXLPTXNAME + 1 ];
    }
    PTI_CO_TAPI_LINE_CAPS;

    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;
    ULONG extension;
    ULONG ulPortIndex;
    CO_TAPI_CM_CAPS cmcaps;
    PTI_CO_TAPI_LINE_CAPS pticaps;
    CO_TAPI_ADDRESS_CAPS addrcaps;
    CO_TAPI_CALL_DIAGNOSTICS diags;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_CO_TAPI_CM_CAPS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_CM_CAPS)" ) );

            NdisZeroMemory( &cmcaps, sizeof(cmcaps) );

            // Assumes that the LINE and ADDRESS CAPS OIDs will be requested
            // after this one.  TAPI LineIDs are associated with LPTx ports at
            // that time.  This should be OK since named ports cannot
            // reasonably be chosen based on an arbitrary LineID.
            //
            cmcaps.ulCoTapiVersion = CO_TAPI_VERSION;
            cmcaps.ulNumLines = pAdapter->ulActualVcs;
            cmcaps.ulFlags = CO_TAPI_FLAG_PER_LINE_CAPS;
            pInfo = &cmcaps;
            ulInfoLen = sizeof(cmcaps);
            break;
        }

        case OID_CO_TAPI_LINE_CAPS:
        {
            CO_TAPI_LINE_CAPS* pInCaps;
            LINE_DEV_CAPS* pldc;
            ULONG ulPortForLineId;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_LINE_CAPS)" ) );

            if (InformationBufferLength < sizeof(PTI_CO_TAPI_LINE_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_LINE_CAPS* )InformationBuffer;

            NdisZeroMemory( &pticaps, sizeof(pticaps) );
            pldc = &pticaps.caps.LineDevCaps;

            // get the LineId from the incoming pInCaps (CO_TAPI_LINE_CAPS)
            //
            pticaps.caps.ulLineID = pInCaps->ulLineID;

            // Find the LineId in the ulLineIds table (Replaces LineIdAdd as
            // part of the STATIC LINEID workaround)
            //
            ulPortForLineId =
                LineIdPortLookup( pAdapter, pticaps.caps.ulLineID );

            if ( ulPortForLineId >= NPORTS )
            {
                status = NDIS_STATUS_TAPI_INVALLINEHANDLE;
                ulInfoLen = 0;
                break;
            }

            pldc->ulTotalSize = pInCaps->LineDevCaps.ulTotalSize;
            pldc->ulNeededSize = (ULONG )
                ((CHAR* )(&pticaps + 1) - (CHAR* )(&pticaps.caps.LineDevCaps));
            pldc->ulUsedSize = pldc->ulNeededSize;

            // pldc->ulProviderInfoSize = 0;
            // pldc->ulProviderInfoOffset = 0;
            // pldc->ulSwitchInfoSize = 0;
            // pldc->ulSwitchInfoOffset = 0;

            pldc->ulPermanentLineID = pticaps.caps.ulLineID;

            StrCpyW( pticaps.achLineName,
                pAdapter->szPortName[ ulPortForLineId ] );
            pldc->ulLineNameSize =
                StrLenW( pticaps.achLineName ) * sizeof(WCHAR);
            pldc->ulLineNameOffset = (ULONG )
                ((CHAR* )pticaps.achLineName - (CHAR* )pldc);

            pldc->ulStringFormat = STRINGFORMAT_ASCII;

            // pldc->ulAddressModes = 0;

            pldc->ulNumAddresses = 1;
            pldc->ulBearerModes = LINEBEARERMODE_DATA;
            pldc->ulMaxRate = PTI_LanBps;
            pldc->ulMediaModes = LINEMEDIAMODE_UNKNOWN | LINEMEDIAMODE_DIGITALDATA;

            // pldc->ulGenerateToneModes = 0;
            // pldc->ulGenerateToneMaxNumFreq = 0;
            // pldc->ulGenerateDigitModes = 0;
            // pldc->ulMonitorToneMaxNumFreq = 0;
            // pldc->ulMonitorToneMaxNumEntries = 0;
            // pldc->ulMonitorDigitModes = 0;
            // pldc->ulGatherDigitsMinTimeout = 0;
            // pldc->ulGatherDigitsMaxTimeout = 0;
            // pldc->ulMedCtlDigitMaxListSize = 0;
            // pldc->ulMedCtlMediaMaxListSize = 0;
            // pldc->ulMedCtlToneMaxListSize = 0;
            // pldc->ulMedCtlCallStateMaxListSize = 0;
            // pldc->ulDevCapFlags = 0;

            pldc->ulMaxNumActiveCalls = 1;

            // pldc->ulAnswerMode = 0;
            // pldc->ulRingModes = 0;
            // pldc->ulLineStates = 0;
            // pldc->ulUUIAcceptSize = 0;
            // pldc->ulUUIAnswerSize = 0;
            // pldc->ulUUIMakeCallSize = 0;
            // pldc->ulUUIDropSize = 0;
            // pldc->ulUUISendUserUserInfoSize = 0;
            // pldc->ulUUICallInfoSize = 0;
            // pldc->MinDialParams = 0;
            // pldc->MaxDialParams = 0;
            // pldc->DefaultDialParams = 0;
            // pldc->ulNumTerminals = 0;
            // pldc->ulTerminalCapsSize = 0;
            // pldc->ulTerminalCapsOffset = 0;
            // pldc->ulTerminalTextEntrySize = 0;
            // pldc->ulTerminalTextSize = 0;
            // pldc->ulTerminalTextOffset = 0;
            // pldc->ulDevSpecificSize = 0;
            // pldc->ulDevSpecificOffset = 0;
            // pldc->ulLineFeatures;
            // pldc->ulSettableDevStatus;
            // pldc->ulDeviceClassesSize;
            // pldc->ulDeviceClassesOffset;
            // pldc->PermanentLineGuid;

            pldc->ulAddressTypes = LINEADDRESSTYPE_IPADDRESS;

            // pldc->ProtocolGuid;
            // pldc->ulAvailableTracking;

            pInfo = &pticaps;
            ulInfoLen = sizeof(pticaps);
            break;
        }

        case OID_CO_TAPI_ADDRESS_CAPS:
        {
            CO_TAPI_ADDRESS_CAPS* pInCaps;
            LINE_ADDRESS_CAPS* plac;

            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_ADDRESS_CAPS)" ) );

            if (InformationBufferLength < sizeof(CO_TAPI_ADDRESS_CAPS))
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            ASSERT( InformationBuffer );
            pInCaps = (CO_TAPI_ADDRESS_CAPS* )InformationBuffer;

            NdisZeroMemory( &addrcaps, sizeof(addrcaps) );

            addrcaps.ulLineID = pInCaps->ulLineID;
            addrcaps.ulAddressID = pInCaps->ulAddressID;

            plac = &addrcaps.LineAddressCaps;

            plac->ulTotalSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulNeededSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulUsedSize = sizeof(LINE_ADDRESS_CAPS);
            plac->ulLineDeviceID = addrcaps.ulLineID;
            // plac->ulAddressSize = 0;
            // plac->ulAddressOffset = 0;
            // plac->ulDevSpecificSize = 0;
            // plac->ulDevSpecificOffset = 0;
            // plac->ulAddressSharing = 0;
            // plac->ulAddressStates = 0;
            // plac->ulCallInfoStates = 0;
            // plac->ulCallerIDFlags = 0;
            // plac->ulCalledIDFlags = 0;
            // plac->ulConnectedIDFlags = 0;
            // plac->ulRedirectionIDFlags = 0;
            // plac->ulRedirectingIDFlags = 0;
            // plac->ulCallStates = 0;
            // plac->ulDialToneModes = 0;
            // plac->ulBusyModes = 0;
            // plac->ulSpecialInfo = 0;
            // plac->ulDisconnectModes = 0;

            plac->ulMaxNumActiveCalls = 1;

            // plac->ulMaxNumOnHoldCalls = 0;
            // plac->ulMaxNumOnHoldPendingCalls = 0;
            // plac->ulMaxNumConference = 0;
            // plac->ulMaxNumTransConf = 0;
            // plac->ulAddrCapFlags = 0;
            // plac->ulCallFeatures = 0;
            // plac->ulRemoveFromConfCaps = 0;
            // plac->ulRemoveFromConfState = 0;
            // plac->ulTransferModes = 0;
            // plac->ulParkModes = 0;
            // plac->ulForwardModes = 0;
            // plac->ulMaxForwardEntries = 0;
            // plac->ulMaxSpecificEntries = 0;
            // plac->ulMinFwdNumRings = 0;
            // plac->ulMaxFwdNumRings = 0;
            // plac->ulMaxCallCompletions = 0;
            // plac->ulCallCompletionConds = 0;
            // plac->ulCallCompletionModes = 0;
            // plac->ulNumCompletionMessages = 0;
            // plac->ulCompletionMsgTextEntrySize = 0;
            // plac->ulCompletionMsgTextSize = 0;
            // plac->ulCompletionMsgTextOffset = 0;

            pInfo = &addrcaps;
            ulInfoLen = sizeof(addrcaps);
            break;
        }

        case OID_CO_TAPI_GET_CALL_DIAGNOSTICS:
        {
            TRACE( TL_N, TM_Cm, ( "QCm(OID_CO_TAPI_GET_CALL_DIAGS)" ) );

            if (!pVc)
            {
                status = NDIS_STATUS_INVALID_DATA;
                ulInfoLen = 0;
                break;
            }

            NdisZeroMemory( &diags, sizeof(diags) );

            diags.ulOrigin =
                (ReadFlags( &pVc->ulFlags ) & VCBF_PeerInitiatedCall)
                    ? LINECALLORIGIN_EXTERNAL
                    : LINECALLORIGIN_OUTBOUND;
            diags.ulReason = LINECALLREASON_DIRECT;

            pInfo = &diags;
            ulInfoLen = sizeof(diags);
            break;
        }

        default:
        {
            TRACE( TL_A, TM_Cm, ( "QCm-OID=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
QueryPtiPorts(
    IN ADAPTERCB* pAdapter )

    // Query which PTI ports are available and fill in the count and status of
    // each in the adapter context block 'pAdapter'.
    //
{
    ULONG ulPortIndex;
    ULONG ulLineId;
    PTI_EXTENSION* pPtiExtension;
    NTSTATUS statusDevice;

    // Ask PtiLink which devices exist.
    //
    pAdapter->ulActualVcs = 0;
    ulLineId = 0;
    for (ulPortIndex = 0; ulPortIndex < NPORTS; ++ulPortIndex)
    {
        TRACE( TL_V, TM_Mp,
             ( "PtiQueryDeviceStatus(%d)", ulPortIndex ) );

        statusDevice = PtiQueryDeviceStatus(
            ulPortIndex, pAdapter->szPortName[ ulPortIndex ] );
        if (NT_SUCCESS( statusDevice ))
        {
            // An actual parallel port device object exists for this
            // logical port.  Increment the available VCs and set
            // ulPtiLinkState which will be used in the CAPS OIDs to
            // associate a TAPI LineId.
            //
            pAdapter->ulActualVcs++;
            pAdapter->ulPtiLinkState[ulPortIndex] = PLSF_PortExists;
            pAdapter->ulLineIds[ ulPortIndex ] = ulLineId;
            ++ulLineId;
            pAdapter->ulPtiLinkState[ ulPortIndex ] |= PLSF_LineIdValid;
        }

        TRACE( TL_N, TM_Mp,
             ( "PtiQueryDeviceStatus(%d), status=$%x, port=%S",
                ulPortIndex,
                statusDevice,
                pAdapter->szPortName[ ulPortIndex ] ) );
    }
}


VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the address family of adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lAfRef );

    TRACE( TL_N, TM_Ref, ( "RefAf to %d", lRef ) );
}


BOOLEAN
ReferenceCall(
    IN VCCB* pVc )

    // Returns true if a reference is added to the active call on VC control
    // block, 'pVc', or false if no reference was added because no call is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pVc->lockCall );
    {
        if (ReadFlags( &pVc->ulFlags ) & VCBF_VcActivated)
        {
            fActive = TRUE;
            ++pVc->lCallRef;
            TRACE( TL_N, TM_Ref, ( "RefCall to %d", pVc->lCallRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefCall denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pVc->lockCall );

    return fActive;
}


BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter )

    // Returns true if a reference is added to the active SAP on adapter
    // 'pAdapter', or false if no reference was added because no SAP is
    // active.
    //
{
    BOOLEAN fActive;

    NdisAcquireSpinLock( &pAdapter->lockSap );
    {
        if (ReadFlags( &pAdapter->ulFlags ) & ACBF_SapActive)
        {
            fActive = TRUE;
            ++pAdapter->lSapRef;
            TRACE( TL_N, TM_Ref, ( "RefSap to %d", pAdapter->lSapRef ) );
        }
        else
        {
            TRACE( TL_N, TM_Ref, ( "RefSap denied" ) );
            fActive = FALSE;
        }
    }
    NdisReleaseSpinLock( &pAdapter->lockSap );

    return fActive;
}


VOID
SetupVcAsynchronously(
    IN ADAPTERCB* pAdapter )

    // Called by ReceiveControl to set up a VC for the incoming call
    // using the necessary asynchronous CoNdis calls.
    //
{
    NDIS_STATUS status;
    VCCB* pVc;
    NDIS_HANDLE NdisVcHandle;
    ULONG ulMask;

    TRACE( TL_V, TM_Misc, ( "SetupVcAsync" ) );

    // Call our own CreateVc handler directly to allocate and
    // initialize the incoming call's VC.
    //
    status = PtiCmCreateVc( pAdapter, NULL, &pVc );
    TRACE( TL_V, TM_Misc, ( "SetupVcAsync: PtiCmCreateVc: Vc Created: pVc=$%p", pVc ) );

    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"CreateVc?" );

        // ??? Add code to intiate protocol to terminate link

        return;
    }

    // Allocate an "incoming call setup" context and initialize it from the
    // receive buffer information arguments.
    //
    {
        CHAR* pCallParamBuf;
        ULONG ulCallParamLength;
        CO_CALL_PARAMETERS* pCp;
        CO_CALL_MANAGER_PARAMETERS* pCmp;
        CO_MEDIA_PARAMETERS* pMp;
        CO_AF_TAPI_INCOMING_CALL_PARAMETERS* pTi;
        LINE_CALL_INFO* pLci;

        ulCallParamLength =
            sizeof(CO_CALL_PARAMETERS)
            + sizeof(CO_CALL_MANAGER_PARAMETERS)
            + sizeof(CO_MEDIA_PARAMETERS)
            + sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
            + sizeof(LINE_CALL_INFO);

        pCallParamBuf = ALLOC_NONPAGED( ulCallParamLength, MTAG_INCALLBUF );
        if (!pCallParamBuf)
        {
            ASSERT( !"Alloc pCpBuf?" );
            PtiCmDeleteVc( pVc );
            return;
        }

        NdisZeroMemory( pCallParamBuf, ulCallParamLength );

        pCp = (CO_CALL_PARAMETERS* )pCallParamBuf;
        pCmp = (CO_CALL_MANAGER_PARAMETERS* )(pCp + 1);
        pCp->CallMgrParameters = pCmp;

        //
        // Might want to make this report the actual
        // connection speed in the future
        //
        pCmp->Transmit.TokenRate =
        pCmp->Transmit.PeakBandwidth =
        pCmp->Receive.TokenRate =
        pCmp->Receive.PeakBandwidth = PTI_LanBps/8;

        pMp = (CO_MEDIA_PARAMETERS* )(pCmp + 1);
        pCp->MediaParameters = pMp;
        pMp->ReceiveSizeHint = PTI_MaxFrameSize;
        pMp->MediaSpecific.Length =
            sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
            + sizeof(LINE_CALL_INFO);
        pTi = (CO_AF_TAPI_INCOMING_CALL_PARAMETERS* )
            pMp->MediaSpecific.Parameters;
        pTi->ulLineID = pAdapter->ulSapPort;
        pTi->ulAddressID = CO_TAPI_ADDRESS_ID_UNSPECIFIED;
        pTi->ulFlags = CO_TAPI_FLAG_INCOMING_CALL;
        pTi->LineCallInfo.Length = sizeof(LINE_CALL_INFO);
        pTi->LineCallInfo.MaximumLength = sizeof(LINE_CALL_INFO);
        pTi->LineCallInfo.Offset = sizeof(pTi->LineCallInfo);
        pLci = (LINE_CALL_INFO* )(pTi + 1);
        pLci->ulTotalSize = sizeof(LINE_CALL_INFO);
        pLci->ulNeededSize = sizeof(LINE_CALL_INFO);
        pLci->ulUsedSize = sizeof(LINE_CALL_INFO);
        pLci->ulLineDeviceID = pTi->ulLineID;
        pLci->ulBearerMode = LINEBEARERMODE_DATA;
        pLci->ulMediaMode = LINEMEDIAMODE_DIGITALDATA;

        //
        // Might want to make this report the actual
        // connection speed in the future
        //
        pLci->ulRate = PTI_LanBps;

        pVc->pTiParams = pTi;
        pVc->pInCall = pCp;

    }

    // Mark the call as initiated by the peer so we know which notifications
    // to give when the result is known.
    //
    ulMask = (VCBF_PeerInitiatedCall | VCBF_PeerOpenPending);

    SetFlags( &pVc->ulFlags, ulMask );

    ASSERT( !(ReadFlags( &pVc->ulFlags ) & VCBM_VcState) );

    // Check if the request has a chance of succeeding before getting the
    // client involved.
    //
    if (!pAdapter->NdisAfHandle || !pAdapter->NdisSapHandle)
    {
        TRACE( TL_A, TM_Misc, ( "No AF or SAP" ) );
        pVc->status = NDIS_STATUS_INVALID_SAP;
        SetupVcComplete( pVc );
        return;
    }

    // Tell NDIS to notify the client of the new VC and give us it's handle.
    //
    TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: NdisMCmCreateVc: pVc=$%p", pVc ) );
    status = NdisMCmCreateVc(
        pAdapter->MiniportAdapterHandle,
        pAdapter->NdisAfHandle,
        pVc,
        &pVc->NdisVcHandle );
    TRACE( TL_I, TM_Recv,
         ( "SetupVcAsynch: NdisMCmCreateVc: Get VcHandle: pVc=$%p VcHandle=$%p, status=$%x",
            pVc,
            pVc->NdisVcHandle,
            status ) );

    if (status != NDIS_STATUS_SUCCESS)
    {
        pVc->status = status;
        SetupVcComplete( pVc );
        return;
    }
    SetFlags( &pVc->ulFlags, VCBF_VcCreated );

    // Tell NDIS the VC is active.
    //
    TRACE( TL_I, TM_Recv,
        ( "SetupVcAsynch: NdisMCmActivateVc, VcHandle=$%p",
        pVc->NdisVcHandle) );
    status = NdisMCmActivateVc(
        pVc->NdisVcHandle, pVc->pInCall );
    TRACE( TL_I, TM_Recv,
        ( "SetupVcAsynch: NdisMCmActivateVc: status=$%x", status ) );

    if (status != NDIS_STATUS_SUCCESS )
    {
        pVc->status = status;
        TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: Error: NoAccept" ) );
        SetupVcComplete( pVc );
        return;
    }

    //  Activate the call
    //
    SetFlags( &pVc->ulFlags,
        (VCBF_VcActivated
         | VCBF_CallClosableByClient
         | VCBF_CallClosableByPeer) );
    ReferenceCall( pVc );
    if (!ReferenceSap( pAdapter ))
    {
        pVc->status = NDIS_STATUS_INVALID_SAP;
        TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: Error: NoSap" ) );
        SetupVcComplete( pVc );
        return;
    }

    // Tell NDIS to tell the client about the call.  The dispatched flag is
    // set here rather in the completion because, according to JameelH, it is
    // valid to call NdisMCmDispatchIncomingCloseCall even if client pends on
    // the dispatch.
    //
    TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: NdisMCmDispInCall" ) );
    status = NdisMCmDispatchIncomingCall(
        pAdapter->NdisSapHandle,
        pVc->NdisVcHandle,
        pVc->pInCall );
    TRACE( TL_I, TM_Recv,
        ( "SetupVcAsynch: NdisMCmDispInCall: status=$%x", status ) );

    DereferenceSap( pAdapter );

    if (status != NDIS_STATUS_PENDING)
    {
        PtiCmIncomingCallComplete( status, pVc, pVc->pInCall );
    }
    SetFlags( &pVc->ulFlags, VCBF_VcDispatched );

    // Next stop is our PtiIncomingCallComplete handler which will call
    // SetupVcComplete with clients reported status.
    //
    TRACE( TL_I, TM_Recv, ( "SetupVcAsynch: Exit" ) );
}


VOID
SetupVcComplete(
    IN VCCB* pVc )

    // Called when the asynchronous incoming call VC setup result is known.
    // 'pVc' is the non-NULL set up VC, with 'status' field indicating the
    // status thus far.
    //
{
    NDIS_STATUS status;
    NTSTATUS ntStatus;
    BOOLEAN fCallerFreesBuffer;
    LIST_ENTRY list;
    CHAR* pBuffer;
    ADAPTERCB* pAdapter;


    TRACE( TL_N, TM_Cm, ( "SetupVcComp: pVc=%p, Port=$%x, status=$%x",
                            pVc, pVc->ulVcParallelPort, pVc->status ) );

    pAdapter = pVc->pAdapter;

    do
    {
        if (pVc->status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Initialize the PtiLink API getting the extension pointers.  Get
        // PTILINKx extension also fires ECPdetect and enables port IRQ.
        //
        ntStatus = PtiInitialize( pAdapter->ulSapPort,
                                  &pVc->Extension,
                                  &pVc->PtiExtension);

        TRACE( TL_V, TM_Cm, ( "SetupVcComp: PtiLink Init: Ext=$%p, PtiExt=$%p",
                               pVc->Extension,
                               pVc->PtiExtension ) );

        if ( (pVc->Extension == NULL) ||
             (pVc->PtiExtension == NULL) )
        {
            pVc->status = NDIS_STATUS_FAILURE;
            TRACE( TL_V, TM_Cm, ( "SetupVcComplete: Error: PtiInitialize Returned NULL Pointer", ntStatus ) );
            break;
        }

        if ( !NT_SUCCESS( ntStatus ) )
        {
            pVc->status = NDIS_STATUS_FAILURE;
            TRACE( TL_V, TM_Cm, ( "SetupVcComplete: Error: PtiInitialize=%x", ntStatus ) );
            break;
        }

        SetFlags( &pVc->ulFlags, VCBF_CallInProgress );
        pVc->ulVcParallelPort = pAdapter->ulSapPort;

        // now "privatize" the PtiLink Api ... making it's upper edge link to us
        //   this may have been done before
        //   in this case, we are associating a new Vc context with receives
        //
        TRACE( TL_V, TM_Cm, ( "SetupVcComplete: RegCb pV=$%p", pVc ) );
        PtiRegisterCallbacks(pVc->Extension,                    // the PTILINKx extension
                             PtiCbGetReadBuffer,                // our get buffer routine
                             PtiRx,                             // our receive complete routine
                             PtiCbLinkEventHandler,             // our link event handler
                             pVc);                              // our context
    }
    while (FALSE);

    // With no locks held, perform and VC completion processing including
    // indications to client.
    //
    CompleteVc( pVc );

    TRACE( TL_V, TM_Misc, ( "SetupVcComp: Exit" ) );

}


VOID
WriteEndpointsToRegistry(
    IN ULONG ulVcs )

    // Set the value of the "WanEndpoints", "MinWanEndpoints", and
    // "MaxWanEndpoints" registry values to the 'ulVcs' value.
    //
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objattr;
    UNICODE_STRING uni;
    HANDLE hNet;
    HANDLE hAdapter;
    ULONG i;
    WCHAR szPath[ 256 ];

    #define PSZ_NetAdapters L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"

    TRACE( TL_I, TM_Cm, ( "WriteEndpointsToRegistry(%d)", ulVcs ) );

    hNet = NULL;
    hAdapter = NULL;

    do
    {
        // Get a handle to the network adapters registry key.
        //
        StrCpyW( szPath, PSZ_NetAdapters );
        RtlInitUnicodeString( &uni, szPath );
        InitializeObjectAttributes(
            &objattr, &uni, OBJ_CASE_INSENSITIVE, NULL, NULL );

        status = ZwOpenKey(
            &hNet,
            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
            &objattr );
        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm, ( "ZwOpenKey(net)=$%08x?", status ) );
            break;
        }

        // Walk the adapter subkeys looking for the RASPTI adapter.
        //
        for (i = 0; ; ++i)
        {
            CHAR szBuf[ 512 ];
            KEY_BASIC_INFORMATION* pKey;
            KEY_VALUE_PARTIAL_INFORMATION* pValue;
            WCHAR* pch;
            ULONG ulSize;

            // Find the name of the next adapter subkey.
            //
            status = ZwEnumerateKey(
                hNet, i, KeyBasicInformation,
                szBuf, sizeof(szBuf), &ulSize );
            if (status != STATUS_SUCCESS)
            {
                DBG_if (status != STATUS_NO_MORE_ENTRIES)
                {
                    TRACE( TL_A, TM_Cm, ( "ZwEnumKey=$%08x?", status ) );
                }
                break;
            }

            // Open the adapter subkey.
            //
            pKey = (KEY_BASIC_INFORMATION* )szBuf;
            StrCpyW( szPath, PSZ_NetAdapters );
            pch = &szPath[ StrLenW( szPath ) ];
            *pch = L'\\';
            ++pch;
            NdisMoveMemory( pch, pKey->Name, pKey->NameLength );
            pch += pKey->NameLength / sizeof(WCHAR);
            *pch = L'\0';
            RtlInitUnicodeString( &uni, szPath );

            InitializeObjectAttributes(
                &objattr, &uni, OBJ_CASE_INSENSITIVE, NULL, NULL );

            status = ZwOpenKey(
                &hAdapter,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &objattr );
            if (status != STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Cm, ( "ZwOpenKey(adapter)=$%08x?", status ) );
                break;
            }

            // Query the "ComponentID" value.
            //
            RtlInitUnicodeString( &uni, L"ComponentId" );
            status = ZwQueryValueKey(
                hAdapter, &uni, KeyValuePartialInformation,
                szBuf, sizeof(szBuf), &ulSize );

            if (status != STATUS_SUCCESS)
            {
                ZwClose( hAdapter );
                hAdapter = NULL;
                TRACE( TL_A, TM_Cm, ( "ZwQValueKey=$%08x?", status ) );
                continue;
            }

            pValue = (KEY_VALUE_PARTIAL_INFORMATION* )szBuf;
            if (pValue->Type != REG_SZ
                || StrCmpW( (WCHAR* )pValue->Data, L"ms_ptiminiport" ) != 0)
            {
                ZwClose( hAdapter );
                hAdapter = NULL;
                continue;
            }

            // Found it. 'HAdapter' contains it's adapter key handle.
            //
            TRACE( TL_I, TM_Cm, ( "PTI adapter key found" ) );
            break;
        }

        if (status != STATUS_SUCCESS)
        {
            break;
        }

        // Write the "actual VC" count to the 3 endpoint registry values.
        //
        RtlInitUnicodeString( &uni, L"WanEndpoints" );
        status = ZwSetValueKey(
            hAdapter, &uni, 0, REG_DWORD, &ulVcs, sizeof(ulVcs) );
        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm,
                ( "ZwSetValueKey(WE)=$%08x?", status ) );
        }

        RtlInitUnicodeString( &uni, L"MinWanEndpoints" );
        status = ZwSetValueKey(
            hAdapter, &uni, 0, REG_DWORD, &ulVcs, sizeof(ulVcs) );
        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm,
                ( "ZwSetValueKey(MinWE)=$%08x?", status ) );
        }

        RtlInitUnicodeString( &uni, L"MaxWanEndpoints" );
        status = ZwSetValueKey(
            hAdapter, &uni, 0, REG_DWORD, &ulVcs, sizeof(ulVcs) );
        if (status != STATUS_SUCCESS)
        {
            TRACE( TL_A, TM_Cm,
                ( "ZwSetValueKey(MaxWE)=$%08x?", status ) );
        }
    }
    while (FALSE);

    if (hAdapter)
    {
        ZwClose( hAdapter );
    }

    if (hNet)
    {
        ZwClose( hNet );
    }
}


NDIS_STATUS
PtiCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext )

    // Standard 'CmCloseAfHandler' routine called by NDIS when a client
    // requests to close an address family.  See DDK doc.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_I, TM_Cm, ( "PtiCmCloseAf" ) );

    pAdapter = (ADAPTERCB* )CallMgrAfContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    // This dereference will eventually lead to us calling
    // NdisMCmCloseAfComplete.
    //
    DereferenceAf( pAdapter );

    TRACE( TL_V, TM_Cm, ( "PtiCmCloseAf: Exit" ) );
    return NDIS_STATUS_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\ppool.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.c
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management routines
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool );

VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool );


//-----------------------------------------------------------------------------
// Interface routines
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag )

    // Initialize caller's packet pool control block 'pPool'.
    // 'UlProtocolReservedLength' is the size in bytes of the
    // 'ProtocolReserved' array of each individual packet.  'UlMaxPackets' is
    // the maximum number of packets allowed in the entire pool, or 0 for
    // unlimited.  'UlPacketsPerBlock' is the number of packets to include in
    // each block of packets.  'UlFreesPerCollection' is the number of
    // FreePacketToPool calls until the next garbage collect scan, or 0 for
    // default.  'UlTag' is the memory identification tag to use when
    // allocating blocks.
    //
    // IMPORTANT: Caller's 'pPool' packet must be protected from multiple
    //            access during this call.
    //
{
    pPool->ulProtocolReservedLength = ulProtocolReservedLength;
    pPool->ulPacketsPerBlock = ulPacketsPerBlock;
    pPool->ulMaxPackets = ulMaxPackets;
    pPool->ulFreesSinceCollection = 0;
    pPool->ulTag = ulTag;

    if (ulFreesPerCollection)
    {
        pPool->ulFreesPerCollection = ulFreesPerCollection;
    }
    else
    {
        // Calculate default garbage collection trigger.  Don't want to be too
        // aggressive here.
        //
        pPool->ulFreesPerCollection = 50 * pPool->ulPacketsPerBlock;
    }

    TRACE( TL_N, TM_Pool, ( "InitPp tag=$%08x pr=%d cnt=%d",
        pPool->ulTag,
        pPool->ulProtocolReservedLength,
        pPool->ulPacketsPerBlock ) );

    InitializeListHead( &pPool->listBlocks );
    InitializeListHead( &pPool->listFreePackets );
    NdisAllocateSpinLock( &pPool->lock );
}


BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool )

    // Free up all resources allocated in packet pool 'pPool'.  This is the
    // inverse of InitPacketPool.
    //
    // Returns true if successful, false if any of the pool could not be freed
    // due to outstanding packets.
    //
{
    BOOLEAN fSuccess;

    TRACE( TL_N, TM_Pool, ( "FreePp" ) );

    NdisAcquireSpinLock( &pPool->lock );
    {
        FreeUnusedPacketPoolBlocks( pPool );
        fSuccess = (pPool->ulCurPackets == 0);
    }
    NdisReleaseSpinLock( &pPool->lock );

    return fSuccess;
}


NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead )

    // Returns the address of the NDIS_PACKET descriptor allocated from the
    // pool 'pPool'.  The pool is expanded, if necessary, but caller should
    // still check for NULL return since the pool may have been at maximum
    // size.  'PpHead' is the "cookie" that is used to return the packet to
    // the pool (see FreePacketToPool).  Caller would normally stash this
    // value in the appropriate 'reserved' areas of the packet for retrieval
    // later.
    //
{
    LIST_ENTRY* pLink;
    PACKETHEAD* pHead;
    NDIS_PACKET* pPacket;

    NdisAcquireSpinLock( &pPool->lock );
    {
        if (IsListEmpty( &pPool->listFreePackets ))
        {
            pLink = NULL;
        }
        else
        {
            pLink = RemoveHeadList( &pPool->listFreePackets );
            pHead = CONTAINING_RECORD( pLink, PACKETHEAD, linkFreePackets );
            --pHead->pBlock->ulFreePackets;
        }
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!pLink)
    {
        // The free list was empty.  Try to expand the pool.
        //
        pHead = AddPacketBlockToPool( pPool );
        if (!pHead)
        {
            TRACE( TL_A, TM_Pool, ( "GetPfP failed?" ) );
            return NULL;
        }
    }

    TRACE( TL_N, TM_Pool,
        ( "GetPfP=$%p/h=$%p, %d free",
        pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );

    *ppHead = pHead;
    return pHead->pNdisPacket;
}


VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection )

    // Returns 'pPacket' to the pool of unused packets 'pPool'.  'PPacket'
    // must have been previously allocated with GetPacketFromPool.
    // 'FGarbageCollection' is set when the free should be considered for
    // purposes of garbage collection.  This is used by the AddPacketToPool
    // routine to avoid counting the initial "add" frees.  Normal callers
    // should set this flag.
    //
{
    DBG_if (fGarbageCollection)
    {
        TRACE( TL_N, TM_Pool,
            ( "FreePtoP($%p,h=$%p) %d free",
            pHead->pNdisPacket, pHead, pHead->pBlock->ulFreePackets ) );
    }

    NdisAcquireSpinLock( &pPool->lock );
    {
        InsertHeadList( &pPool->listFreePackets, &pHead->linkFreePackets );
        ++pHead->pBlock->ulFreePackets;

        if (fGarbageCollection)
        {
            ++pPool->ulFreesSinceCollection;

            if (pPool->ulFreesSinceCollection >= pPool->ulFreesPerCollection)
            {
                // Time to collect garbage, i.e. free any blocks in the pool
                // not in use.
                //
                FreeUnusedPacketPoolBlocks( pPool );
                pPool->ulFreesSinceCollection = 0;
            }
        }
    }
    NdisReleaseSpinLock( &pPool->lock );
}


//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

PACKETHEAD*
AddPacketBlockToPool(
    IN PACKETPOOL* pPool )

    // Allocate a new packet block and add it to the packet pool 'pPool'.
    //
    // Returns the PACKETHEAD allocated from the pool or NULL if none.
    //
{
    NDIS_STATUS status;
    PACKETBLOCKHEAD* pNew;
    ULONG ulSize;
    ULONG ulCount;
    BOOLEAN fOk;
    PACKETHEAD* pReturn;

    TRACE( TL_A, TM_Pool, ( "AddPpBlock(%d+%d)",
        pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

    fOk = FALSE;
    pNew = NULL;

    NdisAcquireSpinLock( &pPool->lock );
    {
        do
        {
            if (pPool->ulMaxPackets
                && pPool->ulCurPackets >= pPool->ulMaxPackets)
            {
                // No can do.  The pool's already at maximum size.
                //
                TRACE( TL_A, TM_Pool, ( "Pp maxed?" ) );
                break;
            }

            // Calculate the contiguous block's size and the number of packets
            // it will hold.
            //
            ulCount = pPool->ulPacketsPerBlock;
            if (pPool->ulMaxPackets)
            {
                if (ulCount > pPool->ulMaxPackets - pPool->ulCurPackets)
                    ulCount = pPool->ulMaxPackets - pPool->ulCurPackets;
            }
            ulSize = sizeof(PACKETBLOCKHEAD) + (ulCount * sizeof(PACKETHEAD));

            // Allocate the contiguous memory block for the PACKETBLOCK header
            // and the individual PACKETHEADs.
            //
            pNew = ALLOC_NONPAGED( ulSize, pPool->ulTag );
            if (!pNew)
            {
                TRACE( TL_A, TM_Pool, ( "Alloc PB?") );
                break;
            }

            /* Zero only the block header portion.
            */
            NdisZeroMemory( pNew, sizeof(PACKETBLOCKHEAD) );

            // Allocate a pool of NDIS_PACKET descriptors.
            //
            NdisAllocatePacketPool(
                &status,
                &pNew->hNdisPool,
                ulCount,
                pPool->ulProtocolReservedLength );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocPp=$%p?", status ) );
                break;
            }

            // Fill in the back pointer to the pool.
            //
            pNew->pPool = pPool;

            // Link the new block.  At this point, all the packets are
            // effectively "in use".  They are made available in the loop
            // below.
            //
            pNew->ulPackets = ulCount;
            pPool->ulCurPackets += ulCount;
            InsertHeadList( &pPool->listBlocks, &pNew->linkBlocks );

            fOk = TRUE;
        }
        while (FALSE);
    }
    NdisReleaseSpinLock( &pPool->lock );

    if (!fOk)
    {
        // Bailing, undo whatever succeeded.
        //
        if (pNew)
        {
            FREE_NONPAGED( pNew );
            if (pNew->hNdisPool)
            {
                NdisFreePacketPool( pNew->hNdisPool );
            }
        }

        return NULL;
    }

    // Initialize each individual packet header and add it to the list of free
    // packets.
    //
    {
        ULONG i;
        PACKETHEAD* pHead;

        pReturn = NULL;

        // For each PACKETHEAD of the block...
        //
        for (i = 0, pHead = (PACKETHEAD* )(pNew + 1);
             i < ulCount;
             ++i, ++pHead)
        {
            InitializeListHead( &pHead->linkFreePackets );
            pHead->pBlock = pNew;
            pHead->pNdisPacket = NULL;

            // Associate an NDIS_PACKET descriptor from the pool we
            // allocated above.
            //
            NdisAllocatePacket( &status, &pHead->pNdisPacket, pNew->hNdisPool );

            if (status != NDIS_STATUS_SUCCESS)
            {
                TRACE( TL_A, TM_Pool, ( "AllocP=$%p?", status ) );
                continue;
            }

            if (pReturn)
            {
                // Add the constructed packet to the list of free packets.
                // The 'FALSE' tells the garbage collection algorithm the
                // operation is an "add" rather than a "release" and should be
                // ignored.
                //
                FreePacketToPool( pPool, pHead, FALSE );
            }
            else
            {
                // The first successfully constructed packet is returned by
                // this routine.
                //
                pReturn = pHead;
            }
        }
    }

    return pReturn;
}


VOID
FreeUnusedPacketPoolBlocks(
    IN PACKETPOOL* pPool )

    // Check if any of the blocks in pool 'pPool' are not in use, and if so,
    // free them.
    //
    // IMPORTANT: Caller must hold the pool lock.
    //
    // NOTE: The MSDN doc says that no locks may be held while calling
    // NdisFreePacketXxx, but according to JameelH that is incorrect.
    //
{
    LIST_ENTRY* pLink;

    TRACE( TL_A, TM_Pool, ( "FreeUnusedPpBlocks" ) );

    // For each block in the pool...
    //
    pLink = pPool->listBlocks.Flink;
    while (pLink != &pPool->listBlocks)
    {
        LIST_ENTRY* pLinkNext;
        PACKETBLOCKHEAD* pBlock;

        pLinkNext = pLink->Flink;

        pBlock = CONTAINING_RECORD( pLink, PACKETBLOCKHEAD, linkBlocks );
        if (pBlock->ulFreePackets >= pBlock->ulPackets)
        {

#if 1 // Assume all buffers are free at time of call.

            ULONG i;
            PACKETHEAD* pHead;

            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            // Found a block with no packets in use.  Walk the packet block
            // removing each packet from the pool's free list and freeing any
            // associated NDIS_PACKET descriptor.
            //
            for (i = 0, pHead = (PACKETHEAD* )(pBlock + 1);
                 i < pBlock->ulPackets;
                 ++i, ++pHead)
            {
                RemoveEntryList( &pHead->linkFreePackets );

                if (pHead->pNdisPacket)
                {
                    NdisFreePacket( pHead->pNdisPacket );
                }
            }

#else  // Assume some buffers may not be free at time of call.

            LIST_ENTRY* pLink2;

            // Found a block with no packets in use.  Walk the pool's free
            // list looking for buffers from this block.
            //
            TRACE( TL_A, TM_Pool, ( "FreePpBlock(%d-%d)",
                pPool->ulCurPackets, pPool->ulPacketsPerBlock ) );

            pLink2 = pPool->listFreePackets.Flink;
            while (pLink2 != &pPool->listFreePackets)
            {
                LIST_ENTRY* pLink2Next;
                PACKETHEAD* pHead;

                pLink2Next = pLink2->Flink;

                pHead = CONTAINING_RECORD( pLink2, PACKETHEAD, linkFreePackets );
                if (pHead->pBlock == pBlock)
                {
                    // Found a packet from the unused block.  Remove it.
                    //
                    RemoveEntryList( pLink2 );
                    --pBlock->ulFreePackets;

                    if (pHead->pNdisPacket)
                    {
                        NdisFreePacket( pHead->pNdisPacket );
                    }
                }
            }

            ASSERT( pBlock->ulFreePackets == 0 );
#endif

            // Remove and release the unused block.
            //
            RemoveEntryList( pLink );
            pPool->ulCurPackets -= pBlock->ulPackets;

            if (pBlock->hNdisPool)
            {
                NdisFreePacketPool( pBlock->hNdisPool );
            }

            FREE_NONPAGED( pBlock );
        }

        pLink = pLinkNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\main.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// main.c
// RAS DirectParallel mini-port/call-manager driver
// Main routine (DriverEntry) and global data definitions
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath );

// Mark routine to be unloaded after initialization.
//
#pragma NDIS_INIT_FUNCTION(DriverEntry)


//-----------------------------------------------------------------------------
// Routines
//-----------------------------------------------------------------------------

NDIS_STATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath )

    // Standard 'DriverEntry' driver initialization entrypoint called by the
    // I/0 system at IRQL PASSIVE_LEVEL before any other call to the driver.
    //
    // On NT, 'DriverObject' is the driver object created by the I/0 system
    // and 'RegistryPath' specifies where driver specific parameters are
    // stored.  These arguments are opaque to this driver (and should remain
    // so for portability) which only forwards them to the NDIS wrapper.
    //
    // Returns the value returned by NdisMRegisterMiniport, per the doc on
    // "DriverEntry of NDIS Miniport Drivers".
    //
{
    NDIS_STATUS status;
    NDIS_MINIPORT_CHARACTERISTICS nmc;
    NDIS_HANDLE NdisWrapperHandle;

    TRACE( TL_N, TM_Init, ( "DriverEntry" ) );

#ifdef TESTMODE
    TRACE( TL_N, TM_Init, ( "DriverEntry: g_ulTraceLevel = $%x", &g_ulTraceLevel ) );
    TRACE( TL_N, TM_Init, ( "DriverEntry: g_ulTraceMask  = $%x", &g_ulTraceMask ) );
#endif


    // Register  this driver with the NDIS wrapper.  This call must occur
    // before any other NdisXxx calls.
    //
    NdisMInitializeWrapper(
        &NdisWrapperHandle, DriverObject, RegistryPath, NULL );

    // Set up the mini-port characteristics table that tells NDIS how to call
    // our mini-port.
    //
    NdisZeroMemory( &nmc, sizeof(nmc) );

    nmc.MajorNdisVersion = NDIS_MajorVersion;
    nmc.MinorNdisVersion = NDIS_MinorVersion;
    nmc.Reserved = NDIS_USE_WAN_WRAPPER;
    // no CheckForHangHandler
    // no DisableInterruptHandler
    // no EnableInterruptHandler
    nmc.HaltHandler = PtiHalt;
    // no HandleInterruptHandler
    nmc.InitializeHandler = PtiInit;
    // no ISRHandler
    // no QueryInformationHandler (see CoRequestHandler)
    nmc.ResetHandler = PtiReset;
    // no SendHandler (see CoSendPacketsHandler)
    // no WanSendHandler (see CoSendPacketsHandler)
    // no SetInformationHandler (see CoRequestHandler)
    // no TransferDataHandler
    // no WanTransferDataHandler
    nmc.ReturnPacketHandler = PtiReturnPacket;
    // no SendPacketsHandler (see CoSendPacketsHandler)
    // no AllocateCompleteHandler
    // no CoCreateVcHandler
    // no CoDeleteVcHandler
    nmc.CoActivateVcHandler = PtiCoActivateVc;
    nmc.CoDeactivateVcHandler = PtiCoDeactivateVc;
    nmc.CoSendPacketsHandler = PtiCoSendPackets;
    nmc.CoRequestHandler = PtiCoRequest;

    // Register this driver as the DirectParallel mini-port.  This will result in NDIS
    // calling back at PtiInit
    //
    TRACE( TL_V, TM_Init, ( "NdisMRegMp" ) );
    status = NdisMRegisterMiniport( NdisWrapperHandle, &nmc, sizeof(nmc) );
    TRACE( TL_A, TM_Init, ( "NdisMRegMp=$%x", status ) );

    if (status != NDIS_STATUS_SUCCESS)
    {
        NdisTerminateWrapper( NdisWrapperHandle, NULL );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\ppool.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// ppool.h
// RAS L2TP WAN mini-port/call-manager driver
// Packet pool management header
//
// 01/07/97 Steve Cobb, adapted from Gurdeep's WANARP code.


#ifndef _PPOOL_H_
#define _PPOOL_H_


//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

// Packet pool control block.  A packet pool encapsulates an NDIS packet pool
// handling all pool growth and shrinkage internally.
//
typedef struct
_PACKETPOOL
{
    // Size in bytes of the ProtocolReserved array for each packet in the
    // pool.
    //
    ULONG ulProtocolReservedLength;

    // The optimal number of packets to allocate in each packet block.
    //
    ULONG ulPacketsPerBlock;

    // Maximum number of individual packets that may be allocated in the
    // entire pool, or 0 for unlimited.
    //
    ULONG ulMaxPackets;

    // Current number of individual packets allocated in the entire pool.
    //
    ULONG ulCurPackets;

    // Garbage collection occurs after this many calls to FreePacketToPool.
    //
    ULONG ulFreesPerCollection;

    // Number of calls to FreeBufferToPool since a garbage collection.
    //
    ULONG ulFreesSinceCollection;

    // Memory identification tag for allocated blocks.
    //
    ULONG ulTag;

    // Head of the double linked list of PACKETBLOCKHEADs.  Access to the list
    // is protected with 'lock' in this structure.
    //
    LIST_ENTRY listBlocks;

    // Head of the double linked list of free PACKETHEADs.  Each PACKETHEAD in
    // the list is ready to go, i.e. it already has an NDIS_PACKET associated
    // with it.  Access to the list is prototected by 'lock' in this
    // structure.  Interlocked push/pop is not used because (a) the list of
    // blocks and this list must lock each other and (b) double links are
    // necessary for garbage collection.
    //
    LIST_ENTRY listFreePackets;

    // This lock protects this structure and both the list of blocks and the
    // list of packets.
    //
    NDIS_SPIN_LOCK lock;
}
PACKETPOOL;


// Header of a single block of packets from a packet pool.  The PACKETHEAD of
// the first buffer immediately follows.
//
typedef struct
_PACKETBLOCKHEAD
{
    // Links to the prev/next packet block header in the packet pool's list.
    //
    LIST_ENTRY linkBlocks;

    // NDIS's handle of the pool of NDIS_PACKET descriptors associated with
    // this block, or NULL if none.
    //
    NDIS_HANDLE hNdisPool;

    // Back pointer to the packet pool.
    //
    PACKETPOOL* pPool;

    // Number of individual packets in this block.
    //
    ULONG ulPackets;

    // Number of individual packets in this block on the free list.
    //
    ULONG ulFreePackets;
}
PACKETBLOCKHEAD;


// Control information for an individual packet.  For the packet pool, this
// "header" does not actually preceed anything, but this keeps the terminology
// consistent with the very similar buffer pool routines.
//
typedef struct
_PACKETHEAD
{
    // Link to next packet header in the packet pool's free list.
    //
    LIST_ENTRY linkFreePackets;

    // Back link to owning packet block header.
    //
    PACKETBLOCKHEAD* pBlock;

    // NDIS packet descriptor of this buffer.
    //
    NDIS_PACKET* pNdisPacket;
}
PACKETHEAD;


//-----------------------------------------------------------------------------
// Interface prototypes and inline definitions
//-----------------------------------------------------------------------------

VOID
InitPacketPool(
    OUT PACKETPOOL* pPool,
    IN ULONG ulProtocolReservedLength,
    IN ULONG ulMaxPackets,
    IN ULONG ulPacketsPerBlock,
    IN ULONG ulFreesPerCollection,
    IN ULONG ulTag );

BOOLEAN
FreePacketPool(
    IN PACKETPOOL* pPool );

NDIS_PACKET*
GetPacketFromPool(
    IN PACKETPOOL* pPool,
    OUT PACKETHEAD** ppHead );

VOID
FreePacketToPool(
    IN PACKETPOOL* pPool,
    IN PACKETHEAD* pHead,
    IN BOOLEAN fGarbageCollection );

PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead );

__inline
PACKETPOOL*
PacketPoolFromPacketHead(
    IN PACKETHEAD* pHead )

    // Returns the address of the pool, given 'pHead', the address of a
    // PACKETHEAD like the one returned from GetPacketFromPool.
    //
{
    return pHead->pBlock->pPool;
}


#endif // PPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\mp.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// mp.c
// RAS DirectParallel WAN mini-port/call-manager driver
// Mini-port routines
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.


#include "ptiwan.h"
#include "ptilink.h"

// The adapter control block address is recorded in this global as a debugging
// aid.  This global must not be read by any code.
//
ADAPTERCB* g_pDebugAdapter;

// Default settings for the NDIS_WAN_CO_INFO capabilities of an adapter.
//
static NDIS_WAN_CO_INFO g_infoDefaults =
{
    PTI_MaxFrameSize,                   // MaxFrameSize
    1,                                  // MaxSendWindow (placeholder)
    PPP_FRAMING                         // FramingBits
        | PPP_COMPRESS_ADDRESS_CONTROL
        | PPP_COMPRESS_PROTOCOL_FIELD,
    0,                                  // DesiredACCM
};

// String constants for Win9x UNIMODEM emulation
//
CHAR g_szClient[] = "CLIENT";
#define CLIENTLEN 6
CHAR g_szClientServer[] = "CLIENTSERVER";
#define CLIENTSERVERLEN 12

// Async framing definitions.
//
#define PPPFLAGBYTE 0x7E
#define PPPESCBYTE  0x7D

#if DBG
BOOLEAN g_fAssumeWin9x = FALSE;
BOOLEAN g_fNoAccmFastPath = FALSE;
#endif

NDIS_PNP_CAPABILITIES PnpCaps =
{
    0, // Flags
    {
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified,
        NdisDeviceStateUnspecified
    }
};

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
AsyncFromHdlcFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen,
    IN ULONG ulAccmMask );

USHORT
CalculatePppFcs(
    IN UCHAR* pBuf,
    IN ULONG ulBufLen );

VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter );

NDIS_STATUS
RegistrySettings(
    IN OUT ADAPTERCB* pAdapter,
    IN NDIS_HANDLE WrapperConfigurationContext );

BOOLEAN
HdlcFromAsyncFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen );

NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pLink,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );


//-----------------------------------------------------------------------------
// Mini-port handlers
//-----------------------------------------------------------------------------

NDIS_STATUS
PtiInit(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext )

    // Standard 'MiniportInitialize' routine called by NDIS to initialize a
    // new WAN adapter.  See DDK doc.  The driver will receive no requests
    // until this initialization has completed.
    //
{
    NDIS_STATUS status;
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Init, ( "PtiInit" ) );

#ifdef TESTMODE
    DbgBreakPoint();
#endif

    status = *OpenErrorStatus = NDIS_STATUS_SUCCESS;

    // Find the medium index in the array of media, looking for the only one
    // we support, 'NdisMediumCoWan'.
    //
    {
        UINT i;

        for (i = 0; i < MediumArraySize; ++i)
        {
            if (MediumArray[ i ] == NdisMediumCoWan)
            {
                break;
            }
        }

        if (i >= MediumArraySize)
        {
            TRACE( TL_A, TM_Init, ( "medium?" ) );
            return NDIS_STATUS_FAILURE;
        }

        *SelectedMediumIndex = i;
    }

    // Allocate and zero a control block for the new adapter.
    //
    pAdapter = ALLOC_NONPAGED( sizeof(*pAdapter), MTAG_ADAPTERCB );
    TRACE( TL_N, TM_Init, ( "PtiInit: pAdapter=$%p", pAdapter ) );
    if (!pAdapter)
    {
        return NDIS_STATUS_RESOURCES;
    }
    NdisZeroMemory( pAdapter, sizeof(*pAdapter) );

    // The adapter control block address is recorded in 'g_pDebugAdapter' as a
    // debugging aid only.  This global is not to be read by any code.
    //
    g_pDebugAdapter = pAdapter;

    // Set a marker for easier memory dump browsing and future assertions.
    //
    pAdapter->ulTag = MTAG_ADAPTERCB;

    // Save the NDIS handle associated with this adapter for use in future
    // NdixXxx calls.
    //
    pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;

    // Copy defaults NDISWAN information.  Some of these are updated below.
    //
    NdisMoveMemory( &pAdapter->info, &g_infoDefaults, sizeof(pAdapter->info) );

    do
    {
        // Read/write this adapter's registry settings.
        //
        status = RegistrySettings(
            pAdapter,
            WrapperConfigurationContext );

        if (status != NDIS_STATUS_SUCCESS)
        {
            // Set 'usMaxVcs' to 0 as an indication to FreeAdapter that the
            // lookaside lists and pools were not initialized.
            //
            pAdapter->usMaxVcs = 0;
            break;
        }

        // Initialize lookaside lists, buffer pools, and packet pool.  On NT,
        // lookaside depths are optimized by the system based on usage
        // regardless of the depth set, but choose something reasonable
        // anyway.
        //
        {
            NdisInitializeNPagedLookasideList(
                &pAdapter->llistWorkItems,
                NULL, NULL, 0,
                sizeof(NDIS_WORK_ITEM),
                MTAG_WORKITEM,
                4 );

            NdisInitializeNPagedLookasideList(
                &pAdapter->llistVcs,
                NULL, NULL, 0,
                sizeof(VCCB),
                MTAG_VCCB,
                4 );

            InitBufferPool(
                &pAdapter->poolFrameBuffers,
                PTI_FrameBufferSize,
                0, 10, 0,
                TRUE, MTAG_FBUFPOOL );

            InitPacketPool(
                &pAdapter->poolPackets,
                0, 0, 10, 0,
                MTAG_PACKETPOOL );
        }

        // Inform NDIS of the attributes of our adapter.  Set the
        // 'MiniportAdapterContext' returned to us by NDIS when it calls our
        // handlers to the address of our adapter control block.  Turn off
        // hardware oriented timeouts.
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE)pAdapter,
            (UINT)-1,
            NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
                | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
            NdisInterfaceInternal );

        // Register the address family of our call manager with NDIS for the
        // newly bound adapter.  We use the mini-port form of
        // RegisterAddressFamily instead of the protocol form, though that
        // would also work.  With the protocol form, our internal call manager
        // would have to go thru NDIS to talk to the mini-port instead of just
        // calling directly.  Since the DirectParallel call manager is not
        // useful with anything but the DirectParallel mini-port, this would be a waste.
        // The mini-port form also causes the call manager VC context to
        // automatically map to the mini-port VC context, which is exactly
        // what we want.
        //
        // NDIS notifies all call manager clients of the new family we
        // register.  The TAPI proxy is the only client expected to be
        // interested.  NDISWAN will receive the notification, but ignore it
        // and wait for the TAPI proxy to notify it of the proxied version.
        //
        {
            NDIS_CALL_MANAGER_CHARACTERISTICS ncmc;
            CO_ADDRESS_FAMILY family;

            NdisZeroMemory( &family, sizeof(family) );
            family.MajorVersion = NDIS_MajorVersion;
            family.MinorVersion = NDIS_MinorVersion;
            family.AddressFamily = CO_ADDRESS_FAMILY_TAPI_PROXY;

            NdisZeroMemory( &ncmc, sizeof(ncmc) );
            ncmc.MajorVersion = NDIS_MajorVersion;
            ncmc.MinorVersion = NDIS_MinorVersion;
            ncmc.CmCreateVcHandler = PtiCmCreateVc;
            ncmc.CmDeleteVcHandler = PtiCmDeleteVc;
            ncmc.CmOpenAfHandler = PtiCmOpenAf;
            ncmc.CmCloseAfHandler = PtiCmCloseAf;
            ncmc.CmRegisterSapHandler = PtiCmRegisterSap;
            ncmc.CmDeregisterSapHandler = PtiCmDeregisterSap;
            ncmc.CmMakeCallHandler = PtiCmMakeCall;
            ncmc.CmCloseCallHandler = PtiCmCloseCall;
            ncmc.CmIncomingCallCompleteHandler = PtiCmIncomingCallComplete;
            // no CmAddPartyHandler
            // no CmDropPartyHandler
            ncmc.CmActivateVcCompleteHandler = PtiCmActivateVcComplete;
            ncmc.CmDeactivateVcCompleteHandler = PtiCmDeactivateVcComplete;
            ncmc.CmModifyCallQoSHandler = PtiCmModifyCallQoS;
            ncmc.CmRequestHandler = PtiCmRequest;

            TRACE( TL_I, TM_Mp, ( "PtiInit: NdisMCmRegAf" ) );
            status = NdisMCmRegisterAddressFamily(
                MiniportAdapterHandle, &family, &ncmc, sizeof(ncmc) );
            TRACE( TL_I, TM_Mp, ( "PtiInit: NdisMCmRegAf=$%x", status ) );
        }
    }
    while (FALSE);

    if (status == NDIS_STATUS_SUCCESS)
    {
        // Add a reference that will eventually be removed by an NDIS call to
        // the LmpHalt handler.
        //
        ReferenceAdapter( pAdapter );
    }
    else
    {
        // Failed, so undo whatever portion succeeded.
        //
        if (pAdapter)
        {
            FreeAdapter( pAdapter );
        }
    }

    TRACE( TL_V, TM_Init, ( "PtiInit: Exit: status=$%x", status ) );
    return status;
}


VOID
PtiHalt(
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportHalt' routine called by NDIS to deallocate all
    // resources attached to the adapter.  NDIS does not make any other calls
    // for this mini-port adapter during or after this call.  NDIS will not
    // call this routine when packets indicated as received have not been
    // returned, or when any VC is created and known to NDIS.  Runs at PASSIVE
    // IRQL.
    //
{
    ADAPTERCB* pAdapter;

    TRACE( TL_N, TM_Mp, ( "PtiHalt" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return;
    }

    DereferenceAdapter( pAdapter );

    TRACE( TL_V, TM_Mp, ( "PtiHalt: Exit" ) );
}


NDIS_STATUS
PtiReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext )

    // Standard 'MiniportReset' routine called by NDIS to reset the driver's
    // software state.
    //
{
    TRACE( TL_N, TM_Mp, ( "PtiReset" ) );
    return NDIS_STATUS_NOT_RESETTABLE;
}


VOID
PtiReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet )

    // Standard 'MiniportReturnPacket' routine called by NDIS when a packet
    // used to indicate a receive has been released by the driver above.
    //
{
    VCCB* pVc;
    CHAR* pBuffer;
    ADAPTERCB* pAdapter;
    NDIS_BUFFER* pTrimmedBuffer;
    PACKETHEAD* pHead;
    PACKETPOOL* pPool;

    TRACE( TL_V, TM_Recv, ( "PtiReturnPacket" ) );

    // Unpack the context information we stashed earlier.
    //
    pHead = *((PACKETHEAD** )(&Packet->MiniportReserved[ 0 ]));
    pBuffer = *((CHAR** )(&Packet->MiniportReserved[ sizeof(VOID*) ]));

    // Find the adapter from the PACKETHEAD address.
    //
    pPool = PacketPoolFromPacketHead( pHead );
    pAdapter = CONTAINING_RECORD( pPool, ADAPTERCB, poolPackets );
    ASSERT( pAdapter->ulTag == MTAG_ADAPTERCB );

    // Free the descriptor created by NdisCopyBuffer.
    //
    NdisUnchainBufferAtFront( Packet, &pTrimmedBuffer );
    if (pTrimmedBuffer)
    {
        NdisFreeBuffer( pTrimmedBuffer );
    }

    // Free the buffer and packet back to the pools.
    //
    FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
    FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );

    TRACE( TL_V, TM_Recv, ( "PtiReturnPacket: Exit" ) );
}


NDIS_STATUS
PtiCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters )

    // Standard 'MiniportCoActivateVc' routine called by NDIS in response to a
    // protocol's request to activate a virtual circuit.
    //
{
    ASSERT( !"PtiCoActVc?" );
    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
PtiCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext )

    // Standard 'MiniportCoDeactivateVc' routine called by NDIS in response to
    // a protocol's request to de-activate a virtual circuit.
    //
{
    ASSERT( !"PtiCoDeactVc?" );
    return NDIS_STATUS_SUCCESS;
}


VOID
PtiCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets )

    // Standard 'MiniportCoSendPackets' routine called by NDIS in response to
    // a protocol's request to send packets on a virtual circuit.
    //
{
    UINT i;
    NDIS_STATUS status;
    NDIS_PACKET** ppPacket;
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    ULONG ulLength;
    NDIS_PACKET* pPacket;
    PNDIS_BUFFER pBuffer;
    PVOID pFrameVirtualAddress;
    KIRQL oldIrql;


    TRACE( TL_V, TM_Send,
        ( "PtiCoSendPackets: pVc=$%p, nPackets=$%x",
        MiniportVcContext, NumberOfPackets ) );

    pVc = (VCCB* )MiniportVcContext;
    ASSERT( pVc->ulTag == MTAG_VCCB );
    pAdapter = pVc->pAdapter;

    ReferenceVc( pVc );

    for (i = 0, ppPacket = PacketArray;
         i < NumberOfPackets;
         ++i, ++ppPacket)
    {
        NDIS_PACKET* pPacket = *ppPacket;

        if (ReferenceCall( pVc ))
        {
            // Send the packet and call NdisMCoSendComplete to notify caller
            //
            NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_PENDING );

            // Request the first buffer descriptor
            //
            NdisQueryPacket( pPacket, NULL, NULL, &pBuffer, NULL );

            // While pBuffer <> NULL
            do
            {
                UCHAR* pAsyncBuf;
                ULONG ulAsyncLen;

                //   request buffer address and length
                //
                NdisQueryBuffer( pBuffer,
                                 &pFrameVirtualAddress,
                                 &ulLength );

                if (IsWin9xPeer( pVc ))
                {
                    pAsyncBuf = (UCHAR* )
                        GetBufferFromPool( &pAdapter->poolFrameBuffers );

                    if (!pAsyncBuf)
                    {
                        status = NDIS_STATUS_FAILURE;
                        TRACE( TL_A, TM_Send, ( "PtiSP: !pAsyncBuf" ) );
                        break;
                    }

                    AsyncFromHdlcFraming(
                        pFrameVirtualAddress, ulLength,
                        pAsyncBuf, &ulAsyncLen,
                        pVc->linkinfo.SendACCM );

                    pFrameVirtualAddress = pAsyncBuf;
                    ulLength = ulAsyncLen;
                }
                else
                {
                    pAsyncBuf = NULL;
                }

                //   send the buffer
                //
                KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
                status = (NDIS_STATUS) PtiWrite( pVc->PtiExtension,
                                                 pFrameVirtualAddress,
                                                 ulLength,
                                                 PID_STANDARD );
                KeLowerIrql(oldIrql);

                TRACE( TL_N, TM_Send,
                     ( "PtiCoSendPackets=%x: $%x bytes", status, ulLength ) );

#ifdef TESTMODE
                if ( g_ulTraceMask & TM_Data )
                {
                    if (pFrameVirtualAddress != NULL) {
                        Dump( pFrameVirtualAddress, ulLength, 0, TRUE );
                    }
                }
#endif
                if (pAsyncBuf)
                {
                    FreeBufferToPool(
                        &pAdapter->poolFrameBuffers, pAsyncBuf, TRUE );
                }

                if (!NT_SUCCESS(status)){
                    break;
                }

                //   get next pBuffer
                //
                NdisGetNextBuffer( pBuffer, &pBuffer );

                // With current NDISWAN behavior only one NDIS_BUFFER will
                // ever be received.  If multiples are received, we need to
                // coalesce the chained buffers into an input buffer for the
                // call to AsyncFromHdlcFraming above.  For that matter, this
                // would send partial PPP frames, which, it seems to me, would
                // be discarded as fragments on the other end.  Tony, am I
                // wrong?  To avoid a useless copy, we will skip that for now,
                // but acknowledge here that the current code is not strictly
                // correct.  (SLC)
                //
                ASSERT( !pBuffer );
            }
            while ( pBuffer != NULL );

            NDIS_SET_PACKET_STATUS( pPacket, status );
            TRACE( TL_V, TM_Send,
                ( "PtiCoSendPackets: NdisMCoSendComp: status=$%x", status ) );
            NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
            TRACE( TL_V, TM_Send,
                ( "PtiCoSendPackets: NdisMCoSendComp done" ) );
            
            pVc->ulTotalPackets++;
            DereferenceCall( pVc );
        }
        else
        {
            TRACE( TL_A, TM_Send, ( "Send to inactive call ignored" ) );
            NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_FAILURE );
            NdisMCoSendComplete( status, pVc->NdisVcHandle, pPacket );
        }
    }

    DereferenceVc( pVc );
    TRACE( TL_V, TM_Send, ( "PtiCoSendPackets: Exit" ) );
}


NDIS_STATUS
PtiCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest )

    // Standard 'MiniportCoRequestHandler' routine called by NDIS in response
    // to a protocol's request information from the mini-port.  Unlike the
    // Query/SetInformation handlers that this routine obsoletes, requests are
    // not serialized.
    //
{
    ADAPTERCB* pAdapter;
    VCCB* pVc;
    NDIS_STATUS status;

    TRACE( TL_N, TM_Mp, ( "PtiCoReq" ) );

    pAdapter = (ADAPTERCB* )MiniportAdapterContext;
    if (pAdapter->ulTag != MTAG_ADAPTERCB)
    {
        ASSERT( !"Atag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    pVc = (VCCB* )MiniportVcContext;
    if (pVc && pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NDIS_STATUS_INVALID_DATA;
    }

    switch (NdisRequest->RequestType)
    {
        case NdisRequestQueryInformation:
        {
            status = QueryInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.QUERY_INFORMATION.Oid,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded );
            break;
        }

        case NdisRequestSetInformation:
        {
            status = SetInformation(
                pAdapter,
                pVc,
                NdisRequest->DATA.SET_INFORMATION.Oid,
                NdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                NdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                &NdisRequest->DATA.SET_INFORMATION.BytesRead,
                &NdisRequest->DATA.SET_INFORMATION.BytesNeeded );
            break;
        }

        default:
        {
            status = NDIS_STATUS_NOT_SUPPORTED;
            TRACE( TL_A, TM_Mp, ( "PtiCoReq: type=%d unsupported", NdisRequest->RequestType ) );
            break;
        }
    }

    TRACE( TL_V, TM_Mp, ( "PtiCoReq: Exit: $%x", status ) );
    return status;
}


//-----------------------------------------------------------------------------
// Callback routines ... called by the PtiLink layer below
//-----------------------------------------------------------------------------


PVOID
PtiCbGetReadBuffer(
    IN  PVOID   Context,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext )

    // PtiLink is requesting a read buffer, get one and return it
    // This is a the start of a receive event ...
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    PCHAR pBuffer;  

    TRACE( TL_V, TM_Spec, ( "PtiCbGetReadBuffer: pVc=$%p", Context ) );

    pVc = (VCCB* )Context;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return NULL;
    }

    pAdapter = pVc->pAdapter;

    // the pVc is our context for use of this buffer
    //
    *RequestContext = pVc;

    // Give caller the length of this buffer
    //
    *BufferSize = PTI_FrameBufferSize;

    // ask for a buffer, caller must check for NULL
    //
    pBuffer = GetBufferFromPool( &pAdapter->poolFrameBuffers );

    TRACE( TL_V, TM_Spec,
        ( "PtiCbGetReadBuffer: Exit: Issuing pBuffer=$%p", pBuffer ) );

    // return the buffer to the caller
    // this is a raw system va
    //
    return pBuffer;
}


VOID
PtiRx(
    IN  PVOID       Context,
    IN  PVOID       pBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       ulLength,
    IN  PVOID       RequestContext )

    // Ptilink has completed a read, i.e., receive complete
    //   buffer now belongs to this layer
    //
    //  Context --  is the pVC
    //
    //  pBuffer --  is the pointer to buffer previously allocated
    //              to the PtiLink driver via the PtiCbGetReadBuffer function
    //
    //  Status  --  one of: NT_SUCCESS      = good packet received
    //                      DATA_OVERRUN    = header failure
    //                      BUFFER_TOO_SMALL= pBuffer is too small to receive packet
    //
    //  ulLength -  packet length
    //
    //  RequestContext -- don't care
    //
    // General Note: PtiLink below us sends and receives link manangement
    // packets using the Our and His structures ... link management packets to
    // not flow through here.  Link events are announced to us via our
    // registered callback (PtiCbLinkEventHandler) below.  We have nothing to
    // do with Tx/Rx of link pkts.
    //
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;
    NDIS_STATUS status;
    NDIS_STATUS writestatus;
    NDIS_PACKET* pPacket;
    NDIS_BUFFER* pNdisBuffer;
    PACKETHEAD* pHead;
    ULONGLONG ullTimeReceived;
    KIRQL oldIrql;
    UCHAR* pHdlcBuf;
    ULONG ulHdlcLen;
    UCHAR* pTmp;

    TRACE( TL_N, TM_Recv, ( "PtiRx=%x: bytes=$%x", Status, ulLength ) );
    TRACE( TL_V, TM_Recv, ( "PtiRx=%x, pVc=$%p, pBuf=$%p, bytes=$%x",
           Status, Context, pBuffer, ulLength ) );

    pVc = (VCCB* )Context;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return;
    }
    ReferenceVc( pVc );

    pAdapter = pVc->pAdapter;

    // NOT A REAL DATA PACKET
    //   return any buffers used for non-data or losing reads
    //
    if ( !NT_SUCCESS( Status ) ){
        TRACE( TL_A, TM_Pool, ( "PtiRx: Status != SUCCESS, freeing buffer", Status ) );

        if ( pBuffer != NULL ) {
            FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
        }

        DereferenceVc( pVc );
        return;
    }

#ifdef TESTMODE
    if ( g_ulTraceMask & TM_Data )
    {
        if (pBuffer != NULL) {
            Dump( pBuffer, ulLength, 0, TRUE );
        }
    }
#endif

    // INCOMING CALL ... NO VC EXISTS YET for this incoming data packet
    //
    if (ReferenceSap( pAdapter ))
    {
        if (!(ReadFlags( &pAdapter->pListenVc->ulFlags ) & VCBF_CallInProgress))
        {
            // Setting in Listen VC here.
            //
            SetFlags( &pAdapter->pListenVc->ulFlags, VCBF_CallInProgress );

            // This is the start of an incoming call which may also start via
            //   LINK_OPEN event to PtiCbLinkEventHandler
            //
            // Ignore this packet and proceed to dispatch an incoming call
            //
            TRACE( TL_V, TM_Recv, ( "PtiRx: Incoming call", Status ) );

            // Free the buffer associated with this read ... we throw away the
            // data thus losing one packet off the front of an attempt to
            // connect, unless the LPKT_OPEN function beats us (a LPKT_OPEN
            // notification occurs before first data packet is received ... it
            // could happen either way.)
            //
            if (pBuffer != NULL ) {
                FreeBufferToPool( &pAdapter->poolFrameBuffers, pBuffer, TRUE );
            }

            // set up a VC for the incoming call
            //
            SetupVcAsynchronously( pAdapter );
            DereferenceVc( pVc );
            DereferenceSap( pAdapter );
            return;
        }

        DereferenceSap( pAdapter );
    }

    // NOW HAVE A REAL DATA PACKET

    if (ReferenceCall( pVc ))
    {
        do
        {
            if (IsWin9xPeer( pVc ))
            {
                if (pVc->ulTotalPackets < 4)
                {
                    // If packet matches "CLIENT", we emit one saying
                    // "CLIENTSERVER"
                    //
                    // If packet matches "CLIENTSERVER", throw it away
                    //
                    // This hack emulates the Win9x UNIMODEM behavior which is
                    // required to allow Win9x systems to connect to us.
                    //
                    // Also, it appears that sending the "CLIENT" packet up
                    // the stack causes RasTapi to disconnect us immediately.
                    // It wants to see PPP?
                    //

                    if ( StrCmp(
                             pBuffer, g_szClientServer, CLIENTSERVERLEN ) == 0 )
                    {
                        // throw away packets containing "CLIENTSERVER"
                        //
                        FreeBufferToPool(
                            &pAdapter->poolFrameBuffers, pBuffer, TRUE );
                        TRACE( TL_V, TM_Recv,
                            ( "PtiRx: CLIENTSERVER ignored", Status ) );
                        pVc->ulTotalPackets++;
                        break;
                    }
                    else if ( StrCmp(
                                 pBuffer, g_szClient, CLIENTLEN ) == 0 )
                    {
                        // when we see "CLIENT", throw away and respond
                        // "CLIENTSERVER".
                        //
                        TRACE( TL_V, TM_Recv, ( "PtiRx: See CLIENT", Status ) );

                        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
                        writestatus = (NDIS_STATUS) PtiWrite(
                            pVc->PtiExtension,
                            g_szClientServer,
                            CLIENTSERVERLEN,
                            PID_STANDARD );
                        KeLowerIrql(oldIrql);

                        FreeBufferToPool(
                            &pAdapter->poolFrameBuffers, pBuffer, TRUE );
                        TRACE( TL_V, TM_Recv,
                            ( "PtiRx: CLIENTSERVER sent", Status ) );
                        pVc->ulTotalPackets++;
                        break;
                    }
                }

                // Un-byte-stuff the received buffer into a second buffer,
                // then swap it with the received buffer.
                //
                pHdlcBuf = (UCHAR* )
                    GetBufferFromPool( &pAdapter->poolFrameBuffers );
                if (!pHdlcBuf)
                {
                    FreeBufferToPool(
                        &pAdapter->poolFrameBuffers, pBuffer, TRUE );
                    TRACE( TL_A, TM_Recv, ( "PtiRx: !Alloc HDLC" ) );
                    break;
                }

                HdlcFromAsyncFraming(
                    pBuffer, ulLength, pHdlcBuf, &ulHdlcLen );

                pTmp = pBuffer;
                pBuffer = pHdlcBuf;
                ulLength = ulHdlcLen;
                FreeBufferToPool( &pAdapter->poolFrameBuffers, pTmp, TRUE );
            }

            // Note the time if client's call parameters indicated interest in
            // time received.
            //
            if (ReadFlags( &pVc->ulFlags ) & VCBF_IndicateTimeReceived)
            {
                NdisGetCurrentSystemTime( (LARGE_INTEGER* )&ullTimeReceived );
            }
            else
            {
                ullTimeReceived = 0;
            }

            TRACE( TL_V, TM_Recv,
                ( "PtiRx: Rx Packet: nBytes=$%x", ulLength ) );

            // Get a packet from the packet pool
            //
            pPacket = GetPacketFromPool( &pAdapter->poolPackets, &pHead );
            if (!pPacket)
            {
                // Packet descriptor pool is maxed.
                //
                ASSERT( !"GetPfP?" );
                break;
            }

            // Hook the NDIS_BUFFER to the packet.  The "copy" here refers to
            // descriptor information only.  The packet data is not copied.
            //
            NdisCopyBuffer(
                &status,
                &pNdisBuffer,
                PoolHandleForNdisCopyBufferFromBuffer( pBuffer ),
                NdisBufferFromBuffer( pBuffer ),
                0,
                ulLength );

            if (status != STATUS_SUCCESS)
            {
                // Can't get a MDL which likely means the system is toast.
                //
                FreePacketToPool( &pAdapter->poolPackets, pHead, TRUE );
                TRACE( TL_A, TM_Recv, ( "NdisCopyBuffer=%08x?", status ) );
                break;
            }

            NdisChainBufferAtFront( pPacket, pNdisBuffer );

            // Stash the time the packet was received in the packet.
            //
            NDIS_SET_PACKET_TIME_RECEIVED( pPacket, ullTimeReceived );

            // Pre-set the packet to success, since a random value of
            // NDIS_STATUS_RESOURCES would prevent our ReturnPackets handler
            // from getting called.
            //
            NDIS_SET_PACKET_STATUS( pPacket, NDIS_STATUS_SUCCESS );

            // Stash our context information with the packet for clean-up use
            // in PtiReturnPacket, then indicate the packet to NDISWAN.
            //
            *((PACKETHEAD** )(&pPacket->MiniportReserved[ 0 ])) = pHead;
            *((CHAR** )(&pPacket->MiniportReserved[ sizeof(VOID*) ])) = pBuffer;

            TRACE( TL_V, TM_Recv,
                ( "PtiRx: NdisMCoIndRecPkt: hVc=$%p, pPacket=$%p, len=$%x",
                pVc->NdisVcHandle, pPacket, ulLength ) );

            NdisMCoIndicateReceivePacket( pVc->NdisVcHandle, &pPacket, 1 );

            TRACE( TL_V, TM_Recv, ( "PtiRx: NdisMCoIndRecPkt done" ) );

            // Tell NDIS our "receive process" is complete.  Since we deal
            // with one packet at a time and NDISWAN does also, this doesn't
            // accomplish anything, but the consensus is it's bad form to omit
            // it.
            //
            TRACE( TL_V, TM_Recv, ( "PtiRx: NdisMCoRecComp" ) );
            NdisMCoReceiveComplete( pAdapter->MiniportAdapterHandle );
            TRACE( TL_V, TM_Recv, ( "PtiRx: NdisMCoRecComp done" ) );
            pVc->ulTotalPackets++;
        }
        while (FALSE);

        DereferenceCall( pVc );
    }
    else
    {
        TRACE( TL_A, TM_Recv, ( "Receive on inactive call ignored" ) );
    }

    DereferenceVc( pVc );
    return;
}


VOID
PtiCbLinkEventHandler(
    IN  PVOID       Context,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData )

    // Ptilink is reporting a link management event (Link up or down)
    //
{
    VCCB* pVc;
    ADAPTERCB* pAdapter;

    pVc = (VCCB* )Context;
    if (pVc->ulTag != MTAG_VCCB)
    {
        ASSERT( !"Vtag?" );
        return;
    }

    pAdapter = pVc->pAdapter;

    switch (PtiLinkEventId)
    {
        case PTILINK_LINK_UP:
        {
            TRACE( TL_A, TM_Cm, ( "LinkEvent: LINK UP, pVc=$%p", pVc ) );

            // peer is initiating a call (also happens in PtiRx)
            //
            break;
        }

        case PTILINK_LINK_DOWN:
        {
            TRACE( TL_A, TM_Cm, ( "LinkEvent: LINK DOWN, pVc=$%p", pVc ) );

            // peer is closing a call
            //
            if (pVc == pAdapter->pListenVc)
            {
                TRACE( TL_A, TM_Cm,
                    ( "LinkEvent: LINK DOWN on ListenVc ignored" ) );
                break;
            }

            NdisAcquireSpinLock( &pVc->lockV );
            {
                pVc->status = NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL;
                CallTransitionComplete( pVc );
            }
            NdisReleaseSpinLock( &pVc->lockV );

            TRACE( TL_A, TM_Cm, ( "LinkEvent: LINK DOWN causing disconnect" ) );

            CompleteVc( pVc );
            break;
        }

        default:
        {
            TRACE( TL_A, TM_Cm,
                ( "LinkEvent: Bad LinkEvent = %d", PtiLinkEventId ) );
            break;
        }
    }
}


//-----------------------------------------------------------------------------
// Mini-port utility routines (alphabetically)
// Some are used externally
//-----------------------------------------------------------------------------

VOID
AsyncFromHdlcFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen,
    IN ULONG ulAccmMask )

    // Make a copy of PPP HDLC framed data buffer 'pInBuf' of length
    // 'ulInBufLen' bytes in caller's 'pOutBuf' buffer, converting to
    // byte-stuffed asynchronous PPP framed format in the process.
    // 'POutBufLen' is the length in bytes of the returned output buffer.  Due
    // to the byte stuffing, caller must allow for up to twice the length of
    // 'pInfBuf'.  'UlAccmMask' is the bitmask of characters to be byte
    // stuffed.
    //
    // With current implementation, user must allow 2 extra bytes at the end
    // of the input buffer for stashing the FCS during byte-stuffing.
    //
    // This routine is adapted from the ASYNCMAC AssemblePppFrame routine, as
    // is the following description, which in turn was lifted from RFC 1331
    // (May 1992).  The PPP frame NDISWAN passes us for sends is the data from
    // the Address field through the Information field inclusive, without any
    // byte stuffing, of course.
    //
    // Asynchronously framed PPP packet:
    //
    //  +----------+----------+----------+----------+------------...
    //  |   Flag   | Address  | Control  | Protocol | Information
    //  | 01111110 | 11111111 | 00000011 | 16 bits  |      *
    //  +----------+----------+----------+----------+------------...
    //  ...---+----------+----------+-----------------
    //      |   FCS    |   Flag   | Inter-frame Fill
    //      | 16 bits  | 01111110 | or next Address
    //  ...---+----------+----------+-----------------
    //
    // Frame Check Sequence (FCS) Field
    //
    //   The Frame Check Sequence field is normally 16 bits (two octets).  The
    //   use of other FCS lengths may be defined at a later time, or by prior
    //   agreement.
    //
    //   The FCS field is calculated over all bits of the Address, Control,
    //   Protocol and Information fields not including any start and stop bits
    //   (asynchronous) and any bits (synchronous) or octets (asynchronous)
    //   inserted for transparency.  This does not include the Flag Sequences
    //   or the FCS field itself.  The FCS is transmitted with the coefficient
    //   of the highest term first.
    //
    //      Note: When octets are received which are flagged in the Async-
    //      Control-Character-Map, they are discarded before calculating the
    //      FCS.  See the description in Appendix A.
    //
    //      On asynchronous links, a character stuffing procedure is used.
    //      The Control Escape octet is defined as binary 01111101
    //      (hexadecimal 0x7d) where the bit positions are numbered 87654321
    //      (not 76543210, BEWARE).
    //
    //      After FCS computation, the transmitter examines the entire frame
    //      between the two Flag Sequences.  Each Flag Sequence, Control
    //      Escape octet and octet with value less than hexadecimal 0x20 which
    //      is flagged in the Remote Async-Control-Character-Map is replaced
    //      by a two octet sequence consisting of the Control Escape octet and
    //      the original octet with bit 6 complemented (i.e., exclusive-or'd
    //      with hexadecimal 0x20).
    //
    //      Prior to FCS computation, the receiver examines the entire frame
    //      between the two Flag Sequences.  Each octet with value less than
    //      hexadecimal 0x20 is checked.  If it is flagged in the Local
    //      Async-Control-Character-Map, it is simply removed (it may have
    //      been inserted by intervening data communications equipment).  For
    //      each Control Escape octet, that octet is also removed, but bit 6
    //      of the following octet is complemented.  A Control Escape octet
    //      immediately preceding the closing Flag Sequence indicates an
    //      invalid frame.
    //
    //         Note: The inclusion of all octets less than hexadecimal 0x20
    //         allows all ASCII control characters [10] excluding DEL (Delete)
    //         to be transparently communicated through almost all known data
    //         communications equipment.
    //
    //
    //      The transmitter may also send octets with value in the range 0x40
    //      through 0xff (except 0x5e) in Control Escape format.  Since these
    //      octet values are not negotiable, this does not solve the problem
    //      of receivers which cannot handle all non-control characters.
    //      Also, since the technique does not affect the 8th bit, this does
    //      not solve problems for communications links that can send only 7-
    //      bit characters.
    //
    //      A few examples may make this more clear.  Packet data is
    //      transmitted on the link as follows:
    //
    //         0x7e is encoded as 0x7d, 0x5e.
    //         0x7d is encoded as 0x7d, 0x5d.
    //
    //         0x01 is encoded as 0x7d, 0x21.
    //
    //      Some modems with software flow control may intercept outgoing DC1
    //      and DC3 ignoring the 8th (parity) bit.  This data would be
    //      transmitted on the link as follows:
    //
    //         0x11 is encoded as 0x7d, 0x31.
    //         0x13 is encoded as 0x7d, 0x33.
    //         0x91 is encoded as 0x7d, 0xb1.
    //         0x93 is encoded as 0x7d, 0xb3.
    //
{
    USHORT usFcs;
    UCHAR* pIn;
    UCHAR* pOut;
    ULONG ulInBytesLeft;

    pIn = pInBuf;
    ulInBytesLeft = ulInBufLen;
    pOut = pOutBuf;

    // Calculate the frame check sequence on the data.
    //
    TRACE( TL_I, TM_Data, ( "AfromH (send) dump:" ) );
    DUMPB( TL_I, TM_Data, pInBuf, ulInBufLen );
    usFcs = CalculatePppFcs( pInBuf, ulInBufLen );
    usFcs ^= 0xFFFF;

    // Add the calculated FCS.  Added to the input buffer for convenience as
    // it must be byte-stuffed along with the other data, though this uglies
    // the interface a bit.
    //
    pIn[ ulInBytesLeft ] = (UCHAR )usFcs;
    ++ulInBytesLeft;
    pIn[ ulInBytesLeft ] = (UCHAR )(usFcs >> 8);
    ++ulInBytesLeft;

    // Add the initial flag byte.
    //
    *pOut = PPPFLAGBYTE;
    ++pOut;

    // Because an empty control character mask is common, an optimized loop is
    // provided in that case.
    //
    if (ulAccmMask
#ifdef TESTMODE
        || g_fNoAccmFastPath
#endif
       )
    {
        // Have bitmask...slower path.
        //
        while (ulInBytesLeft--)
        {
            UCHAR uch;

            uch = *pIn;
            ++pIn;

            if (((uch < 0x20) && ((1 << uch) & ulAccmMask))
                || (uch == PPPESCBYTE) || (uch == PPPFLAGBYTE))
            {
                // Byte stuff the character.
                //
                *pOut = PPPESCBYTE;
                ++pOut;
                *pOut = uch ^ 0x20;
                ++pOut;
            }
            else
            {
                // Copy the character as is.
                //
                *pOut = uch;
                ++pOut;
            }
        }
    }
    else
    {
        // No bitmask...fast path.
        //
        while (ulInBytesLeft--)
        {
            UCHAR uch;

            uch = *pIn;
            ++pIn;

            if ((uch == PPPESCBYTE) || (uch == PPPFLAGBYTE))
            {
                // Byte stuff the character.
                //
                *pOut = PPPESCBYTE;
                ++pOut;
                *pOut = uch ^ 0x20;
                ++pOut;
            }
            else
            {
                // Copy the character as is.
                //
                *pOut = uch;
                ++pOut;
            }
        }
    }

    // Add the trailing flag byte.
    //
    *pOut = PPPFLAGBYTE;
    ++pOut;

    // Calculate length of output.
    //
    *pulOutBufLen = (ULONG )(pOut - pOutBuf);
}


USHORT
CalculatePppFcs(
    IN UCHAR* pBuf,
    IN ULONG ulBufLen )

    // Return the PPP Frame Check Sequence on 'ulBufLen' bytes starting at
    // 'pBuf'.
    //
    // (Taken from ASYNCMAC)
    //
{
    static USHORT ausFcsTable[ 256 ] =
    {
        0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
        0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
        0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
        0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
        0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
        0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
        0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
        0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
        0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
        0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
        0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
        0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
        0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
        0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
        0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
        0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
        0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
        0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
        0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
        0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
        0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
        0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
        0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
        0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
        0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
        0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
        0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
        0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
        0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
        0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
        0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
        0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
    };

    register USHORT usFcs;

    usFcs = 0xFFFF;
    while (ulBufLen--)
    {
        usFcs = (usFcs >> 8) ^ ausFcsTable[ (usFcs ^ (USHORT )*pBuf) & 0xFF ];
        ++pBuf;
    }

    return usFcs;
}


VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Removes a reference from the adapter control block 'pAdapter', and when
    // frees the adapter resources when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefA to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        FreeAdapter( pAdapter );
    }
}


VOID
DereferenceVc(
    IN VCCB* pVc )

    // Removes a reference to the VC control block 'pVc', and when frees the
    // block when the last reference is removed.
    //
{
    LONG lRef;

    lRef = NdisInterlockedDecrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "DerefVc to %d", lRef ) );
    ASSERT( lRef >= 0 );

    if (lRef == 0)
    {
        ADAPTERCB* pAdapter;

        // now for an interesting bit ...
        //
        // if we have a listenVc allocated, then revert to using that
        //
        pAdapter = pVc->pAdapter;
        if (pAdapter->ulTag != MTAG_ADAPTERCB)
        {
            ASSERT( !"Atag?" );
            return;
        }

        if (pAdapter->pListenVc && pAdapter->pListenVc->hPtiLink)
        {
            TRACE( TL_V, TM_Mp,
                ( "DerefVc: Reverting to pVc=$%p", pAdapter->pListenVc ) );

            ClearFlags( &pAdapter->pListenVc->ulFlags, VCBF_CallInProgress );

            // reregister using the listen Vc
            //
            TRACE( TL_V, TM_Mp, ( "DerefVc: RegCb pLV=$%p",
                pAdapter->pListenVc ) );
            PtiRegisterCallbacks(pAdapter->pListenVc->Extension,    // the PTILINKx extension
                                 PtiCbGetReadBuffer,                // our get buffer routine
                                 PtiRx,                             // our receive complete routine
                                 PtiCbLinkEventHandler,             // our link event handler
                                 pAdapter->pListenVc);              // our new context
        }

        // Can make these assumptions because NDIS will not call the delete-VC
        // handler while the VC is active.  All the nasty VC clean up occurs
        // before the VC is deactivated and the call closed.
        //
        pVc->ulTag = MTAG_FREED;
        FREE_VCCB( pAdapter, pVc );
        DereferenceAdapter( pAdapter );
        TRACE( TL_I, TM_Mp, ( "pVc=$%p freed", pVc ) );
    }
}


VOID
FreeAdapter(
    IN ADAPTERCB* pAdapter )

    // Frees all resources allocated for adapter 'pAdapter', including
    // 'pAdapter' itself.
    //
{
    BOOLEAN fSuccess;

    // Setting 'usMaxVcs' to 0 is PtiInitialize's way of telling us that the
    // lookaside lists and pools were not initialized.
    //
    if (pAdapter->usMaxVcs)
    {
        NdisDeleteNPagedLookasideList( &pAdapter->llistWorkItems );
        NdisDeleteNPagedLookasideList( &pAdapter->llistVcs );
    }

    TRACE( TL_V, TM_Mp, ( "FreeAdapter" ) );

    pAdapter->ulTag = MTAG_FREED;
    FREE_NONPAGED( pAdapter );
}


NDIS_STATUS
RegistrySettings(
    IN OUT ADAPTERCB* pAdapter,
    IN NDIS_HANDLE WrapperConfigurationContext )

    // Read this mini-port's registry settings into 'pAdapter' fields.  Also
    // writes registry values read by RASTAPI, overriding SETUPs.
    // 'WrapperConfigurationContext' is the handle to passed to
    // MiniportInitialize.
    //
{
    NDIS_STATUS status;
    NDIS_HANDLE hCfg;
    NDIS_CONFIGURATION_PARAMETER* pncp;

    NdisOpenConfiguration( &status, &hCfg, WrapperConfigurationContext );
    if (status != NDIS_STATUS_SUCCESS)
    {
        return status;
    }

    do
    {
        // The delay in milliseconds to wait for PARPORT to initialize all the
        // parallel ports.  With PnP there is no deterministic time at which
        // to do this.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ParportDelayMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );

            if (status == NDIS_STATUS_SUCCESS)
            {
                pAdapter->ulParportDelayMs = pncp->ParameterData.IntegerData;
            }
            else
            {
                // Default is 3 seconds.
                //
                pAdapter->ulParportDelayMs = 3000;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // The secondary delay in milliseconds to wait for PARPORT to
        // initialize all the parallel ports, if there are no ports after the
        // initial delay above.
        //
        {
            NDIS_STRING nstr = NDIS_STRING_CONST( "ExtraParportDelayMs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );

            if (status == NDIS_STATUS_SUCCESS)
            {
                pAdapter->ulExtraParportDelayMs =
                    pncp->ParameterData.IntegerData;
            }
            else
            {
                // Default is 30 seconds.
                //
                pAdapter->ulExtraParportDelayMs = 30000;
                status = NDIS_STATUS_SUCCESS;
            }
        }

        // The number of VCs we must be able to provide.
        //
        {
#if 0
            NDIS_STRING nstr = NDIS_STRING_CONST( "MaxVcs" );

            NdisReadConfiguration(
                &status, &pncp, hCfg, &nstr, NdisParameterInteger );

            if (status == NDIS_STATUS_SUCCESS)
            {
                pAdapter->usMaxVcs = (USHORT )pncp->ParameterData.IntegerData;

                // Make sure it's a valid value.
                //
                if (pAdapter->usMaxVcs < 1)
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    break;
                }
            }
            else
            {
                pAdapter->usMaxVcs = 1;
                status = NDIS_STATUS_SUCCESS;
            }
#else
            // Registry value is currently ignored, and hard-coded maximum
            // used.
            //
            pAdapter->usMaxVcs = NPORTS;
#endif
        }
    }
    while (FALSE);

    NdisCloseConfiguration( hCfg );

    TRACE( TL_N, TM_Init,
        ( "Reg: vcs=%d ppd=%d",
        (UINT )pAdapter->usMaxVcs,
        (UINT )pAdapter->ulParportDelayMs ) );

    return status;
}


BOOLEAN
HdlcFromAsyncFraming(
    IN UCHAR* pInBuf,
    IN ULONG ulInBufLen,
    OUT UCHAR* pOutBuf,
    OUT ULONG* pulOutBufLen )

    // Make a copy of asynchronously framed PPP data buffer 'pInBuf' of length
    // 'ulInBufLen' bytes in caller's 'pOutBuf' buffer, converting to PPP HDLC
    // framed format in the process.  'POutBufLen' is the length in bytes of
    // the returned output buffer.  Caller must allow for up to the length of
    // 'pInBuf' in 'pOutBuf'.
    //
    // Returns true if the packet is valid, false if corrupt.
    //
    // Adapted from ASYNCMAC's AsyncPPPCompletionRoutine.
    //
{
    UCHAR* pIn;
    UCHAR* pInEnd;
    UCHAR* pOut;
    USHORT usFcs;

    if (ulInBufLen < 5)
    {
        // Expecting at least 2 flag bytes, 1 data byte, and the FCS.
        //
        TRACE( TL_A, TM_Mp, ( "HfA: frame too short=%d", ulInBufLen ) );
        return FALSE;
    }

    if (pInBuf[ 0 ] != PPPFLAGBYTE)
    {
        TRACE( TL_A, TM_Mp, ( "HfA: No head flag" ) );
        return FALSE;
    }

    if (pInBuf[ ulInBufLen - 1 ] != PPPFLAGBYTE)
    {
        TRACE( TL_A, TM_Mp, ( "HfA: No tail flag" ) );
        return FALSE;
    }

    pIn = pInBuf + 1;
    pInEnd = pInBuf + ulInBufLen - 1;
    pOut = pOutBuf;

    while (pIn < pInEnd)
    {
        if (*pIn == PPPESCBYTE)
        {
            ++pIn;
            *pOut = *pIn ^ 0x20;
        }
        else
        {
            *pOut = *pIn;
        }

        ++pOut;
        ++pIn;
    }

    *pulOutBufLen = (ULONG )(pOut - pOutBuf - 2);

    {
        USHORT usCalcFcs;

        usFcs = (USHORT )(pOut[ -2 ]) + (USHORT )(pOut[ -1 ] << 8);
        usFcs ^= 0xFFFF;

        TRACE( TL_I, TM_Data, ( "HfromA (recv) dump:" ) );
        DUMPB( TL_I, TM_Data, pOutBuf, *pulOutBufLen );
        usCalcFcs = CalculatePppFcs( pOutBuf, *pulOutBufLen );
        if (usFcs != usCalcFcs)
        {
            TRACE( TL_A, TM_Mp, (
                "HfA: FCS mismatch, R=$%04x C=$%04x, L=%d",
                (INT )usFcs, (INT )usCalcFcs, *pulOutBufLen ) );
            return FALSE;
        }
#if 0
#ifdef TESTMODE
        else
        {
            TRACE( TL_A, TM_Mp, (
                "HfA: Good FCS, R=$%04x C=$%04x, L=%d",
                (INT )usFcs, (INT )usCalcFcs, *pulOutBufLen ) );
        }
#endif
#endif

    }

    return TRUE;
}


BOOLEAN
IsWin9xPeer(
    IN VCCB* pVc )

    // Returns true if the link level has determined that the VC's peer is a
    // Win9x box, false otherwise.
    //
{
    ULONG Platform;
    PPTI_EXTENSION pPtiExtension;

#ifdef TESTMODE
    if (g_fAssumeWin9x)
    {
        return TRUE;
    }
#endif

    pPtiExtension = (PPTI_EXTENSION )pVc->PtiExtension;

    // try to check the validity of the PtiExtension pointer
    //
    if ( pPtiExtension == NULL )
    {
        TRACE( TL_A, TM_Recv, ( "PtiRx: pPtiExtension is NULL!" ) );
        return FALSE;
    }

    Platform = (ULONG) pPtiExtension->His.VerPlat;

    TRACE( TL_V, TM_Recv, ( "IsWin9xPeer: far platform=$%x", Platform ) );

    if (Platform == PLAT_WIN9X)
    {
        // Win9x -- we reformat the asynch framing used by Win9x DCC
        // and also play the CLIENT->CLIENTSERVER game
        //
        return TRUE;
    }

    // WinNT (or DOS maybe)
    //
    return FALSE;
}


NDIS_STATUS
QueryInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded )

    // Handle QueryInformation requests.  Arguments are as for the standard
    // NDIS 'MiniportQueryInformation' handler except this routine does not
    // count on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;
    ULONG ulInfo;
    VOID* pInfo;
    ULONG ulInfoLen;

    status = NDIS_STATUS_SUCCESS;

    // The cases in this switch statement find or create a buffer containing
    // the requested information and point 'pInfo' at it, noting it's length
    // in 'ulInfoLen'.  Since many of the OIDs return a ULONG, a 'ulInfo'
    // buffer is set up as the default.
    //
    ulInfo = 0;
    pInfo = &ulInfo;
    ulInfoLen = sizeof(ulInfo);

    switch (Oid)
    {
        case OID_GEN_MAXIMUM_LOOKAHEAD:
        {
            // Report the maximum number of bytes we can always provide as
            // lookahead data on receive indications.  We always indicate full
            // packets so this is the same as the receive block size.  And
            // since we always allocate enough for a full packet, the receive
            // block size is the same as the frame size.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAXIMUM_LOOKAHEAD)" ) );
            ulInfo = PTI_MaxFrameSize;
            break;
        }

        case OID_GEN_MAC_OPTIONS:
        {
            // Report a bitmask defining optional properties of the driver.
            //
            // NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA promises that our receive
            // buffer is not on a device-specific card.
            //
            // NDIS_MAC_OPTION_TRANSFERS_NOT_PEND promises we won't return
            // NDIS_STATUS_PENDING from our TransferData handler which is true
            // since we don't have one.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_MAC_OPTIONS)" ) );
            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
                     | NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
            break;
        }

        case OID_WAN_MEDIUM_SUBTYPE:
        {
            // Report the media subtype we support.  NDISWAN may use this in
            // the future (doesn't now) to provide framing differences for
            // different media.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_MEDIUM_SUBTYPE)" ) );
            ulInfo = NdisWanMediumParallel;
            break;
        }

        case OID_WAN_CO_GET_INFO:
        {
            // Report the capabilities of the adapter.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_INFO)" ) );
            pInfo = &pAdapter->info;
            ulInfoLen = sizeof(NDIS_WAN_CO_INFO);
            break;
        }

        case OID_WAN_CO_GET_LINK_INFO:
        {
            // Report the current state of the link.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_LINK_INFO)" ) );

            if (!pVc)
                return NDIS_STATUS_INVALID_DATA;
            pInfo = &pVc->linkinfo;
            ulInfoLen = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
            break;
        }

        case OID_WAN_CO_GET_COMP_INFO:
        {
            // Report the type of compression we provide, which is none.
            //
            TRACE( TL_N, TM_Mp, ( "QInfo(OID_WAN_CO_GET_COMP_INFO)" ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }

        case OID_WAN_CO_GET_STATS_INFO:
        {
            // Because DirectParallel doesn't do compression, NDISWAN will use
            // it's own statistics and not query ours.
            //
            ASSERT( !"OID_WAN_CO_GET_STATS_INFO?" );
            status = NDIS_STATUS_NOT_SUPPORTED;
            ulInfoLen = 0;
            break;
        }

        case OID_GEN_SUPPORTED_LIST:
        {
            static ULONG aulSupportedOids[] = {
                OID_GEN_SUPPORTED_LIST,
                OID_GEN_MAXIMUM_LOOKAHEAD,
                OID_GEN_MAC_OPTIONS,
                OID_WAN_MEDIUM_SUBTYPE,
                OID_WAN_CO_GET_INFO,
                OID_WAN_CO_GET_LINK_INFO,
                OID_WAN_CO_SET_LINK_INFO,
                OID_CO_TAPI_CM_CAPS,
                OID_CO_TAPI_LINE_CAPS,
                OID_CO_TAPI_ADDRESS_CAPS,
                OID_CO_TAPI_GET_CALL_DIAGNOSTICS
            };

            TRACE( TL_N, TM_Mp, ( "QInfo(OID_GEN_SUPPORTED_LIST)" ) );
            pInfo = aulSupportedOids;
            ulInfoLen = sizeof(aulSupportedOids);
            break;
        }

        case OID_PNP_CAPABILITIES:
        {
            pInfo = &PnpCaps;
            ulInfoLen = sizeof(PnpCaps);
            break;
        }

        case OID_PNP_SET_POWER:
            break;
        case OID_PNP_QUERY_POWER:
            break;
        case OID_PNP_ENABLE_WAKE_UP:
            break;

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_HARDWARE_STATUS:
        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MEDIA_IN_USE:
        case OID_GEN_MAXIMUM_FRAME_SIZE:
        case OID_GEN_LINK_SPEED:
        case OID_GEN_TRANSMIT_BUFFER_SPACE:
        case OID_GEN_RECEIVE_BUFFER_SPACE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
        case OID_GEN_VENDOR_ID:
        case OID_GEN_VENDOR_DESCRIPTION:
        case OID_GEN_VENDOR_DRIVER_VERSION:
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_DRIVER_VERSION:
        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_MAC_OPTIONS:
        case OID_GEN_MEDIA_CONNECT_STATUS:
        case OID_GEN_MAXIMUM_SEND_PACKETS:
        case OID_WAN_PERMANENT_ADDRESS:
        case OID_WAN_CURRENT_ADDRESS:
        case OID_WAN_QUALITY_OF_SERVICE:
        case OID_WAN_LINE_COUNT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "QueryInfo: Oid=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;         // JAY per SLC
            ulInfoLen = 0;
            break;
        }
    }

    if (ulInfoLen > InformationBufferLength)
    {
        // Caller's buffer is too small.  Tell him what he needs.
        //
        *BytesNeeded = ulInfoLen;
        status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        // Copy the found result to caller's buffer.
        //
        if (ulInfoLen > 0)
        {
            NdisMoveMemory( InformationBuffer, pInfo, ulInfoLen );
            DUMPDW( TL_N, TM_Mp, pInfo, ulInfoLen );
        }

        *BytesNeeded = *BytesWritten = ulInfoLen;
    }

    return status;
}


VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter )

    // Adds areference to the adapter block, 'pAdapter'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pAdapter->lRef );

    TRACE( TL_N, TM_Ref, ( "RefA to %d", lRef ) );
}


VOID
ReferenceVc(
    IN VCCB* pVc )

    // Adds a reference to the VC control block 'pVc'.
    //
{
    LONG lRef;

    lRef = NdisInterlockedIncrement( &pVc->lRef );

    TRACE( TL_N, TM_Ref, ( "RefVc to %d", lRef ) );
}


VOID
SendClientString(
    IN PVOID pPtiExtension )

    // Send "CLIENT" so Win9x, which views us as a NULL modem, is happy.
    //
{
    KIRQL oldIrql;

    KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
    PtiWrite( pPtiExtension, g_szClient, CLIENTLEN, PID_STANDARD );
    KeLowerIrql(oldIrql);
}


NDIS_STATUS
SetInformation(
    IN ADAPTERCB* pAdapter,
    IN VCCB* pVc,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded )

    // Handle SetInformation requests.  Arguments are as for the standard NDIS
    // 'MiniportQueryInformation' handler except this routine does not count
    // on being serialized with respect to other requests.
    //
{
    NDIS_STATUS status;

    status = NDIS_STATUS_SUCCESS;

    switch (Oid)
    {
        case OID_WAN_CO_SET_LINK_INFO:
        {
            // Read new link state settings.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_LINK_INFO)" ) );
            if (InformationBufferLength < sizeof(NDIS_WAN_CO_SET_LINK_INFO))
            {
                status = NDIS_STATUS_INVALID_LENGTH;
                *BytesRead = 0;
            }
            else
            {
                if (!pVc)
                {
                    return NDIS_STATUS_INVALID_DATA;
                }

                ASSERT( sizeof(pVc->linkinfo)
                    == sizeof(NDIS_WAN_CO_SET_LINK_INFO) );

                NdisMoveMemory( &pVc->linkinfo, InformationBuffer,
                    sizeof(pVc->linkinfo) );
                DUMPB( TL_N, TM_Mp, &pVc->linkinfo, sizeof(pVc->linkinfo) );

                *BytesRead = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
            }

            *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
        }
        break;

        case OID_WAN_CO_SET_COMP_INFO:
        {
            // DirectParallel doesn't provide compression.
            //
            TRACE( TL_N, TM_Mp, ( "SInfo(OID_WAN_CO_SET_COMP_INFO)" ) );
            status = NDIS_STATUS_NOT_SUPPORTED;
            *BytesRead = *BytesNeeded = 0;
            break;
        }

#if 0
        // These OIDs are mandatory according to current doc, but since
        // NDISWAN never requests them they are omitted.
        //
        case OID_GEN_CURRENT_PACKET_FILTER:
        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_PROTOCOL_OPTIONS:
        case OID_WAN_PROTOCOL_TYPE:
        case OID_WAN_HEADER_FORMAT:
#endif
        default:
        {
            TRACE( TL_A, TM_Mp, ( "SetInfo: Oid=$%08x?", Oid ) );
            status = NDIS_STATUS_NOT_SUPPORTED;                 // JAY per SLC
            *BytesRead = *BytesNeeded = 0;
            break;
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\ptilink.h ===
/*++

Copyright (c) 1995  Microsoft Corporation
Copyright (c) 1997  Parallel Technologies, Inc.  All Rights Reserved.

Module Name:

    ptilink.h

Abstract:

    This file defines the interface for the Parallel Technologies
    DirectParallel IO driver.

    This driver doubles as an NT device driver and an export library.

Author:

    Norbert P. Kusters  4-Jan-1995
    Jay Lowe, Parallel Technologies, Inc.

Revision History:

--*/

#ifndef _PTILINK_
#define _PTILINK_

#define NPORTS  3                           // number of PTILINKx devices to make
#define MAXLPTXNAME 99

typedef struct _PTI_EXTENSION PTI_EXTENSION;

//
// This structure contains configuration data, much of which
// is read from the registry.
//
typedef struct _PAR_REG_DATA {
    ULONG           PollInterval;
    ULONG           TraceLevel;
    ULONG           TraceMask;
    ULONG           IoWait;
    ULONG           SyncWait;
} PAR_REG_DATA,*PPAR_REG_DATA;

//
//  Client callbacks from PtiLink
//

// Ptilink requests a read buffer from the upward client

typedef
PVOID
(*GET_READ_BUFFER_ROUTINE)(
    IN  PVOID   ParentContext,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext
    );

// Ptilink returns a completed read buffer to the upward client

typedef
VOID
(*COMPLETE_READ_BUFFER_ROUTINE)(
    IN  PVOID       ParentContext,
    IN  PVOID       ReadBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       BytesTransfered,
    IN  PVOID       RequestContext
    );

// PtiLink notifies upward client of a link event

typedef
VOID
(*NOTIFY_LINK_EVENT)(
    IN  PVOID       ParentContext,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData
    );

// PtilinkEventIds

#define PTILINK_LINK_UP     2           // link has been established
                                        //   a LINK_OPEN or dataframe
                                        //   was received on SHUT link
                                        //   i.e., link is starting

#define PTILINK_LINK_DOWN   4           // link has been terminated
                                        //   peer has issued a LINK_SHUT
                                        //   and is departing

//
//  Device driver routines ... are of the form ParXXXXXX
//

BOOLEAN
ParInterruptService(
    IN      PKINTERRUPT Interrupt,
    IN OUT  PVOID       Extension
    );

VOID
ParDpcForIsr(
    IN  PKDPC           Dpc,
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Extension
    );

VOID
ParDeferredPortCheck(
    IN  PVOID   Extension
    );

VOID
ParAllocTimerDpc(
    IN  PKDPC   Dpc,
    IN  PVOID   Extension,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
    );

NTSTATUS
ParCreate(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParClose(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParRead(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

PVOID
ParGetReadBuffer(
    IN  PVOID   ParentContext,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext
    );

VOID
ParCompleteReadBuffer(
    IN  PVOID       ParentContext,
    IN  PVOID       ReadBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       BytesTransfered,
    IN  PVOID       RequestContext
    );

VOID
ParLinkEventNotification(
    IN  PVOID       ParentContext,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData
    );

NTSTATUS
ParWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

NTSTATUS
ParCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    );

VOID
ParUnload(
    IN  PDRIVER_OBJECT  DriverObject
    );


//
//  Link Level Routines ... are of the form PtiXXXXXX
//

NTSTATUS
PtiInitialize(
    IN  ULONG   PortId,
    OUT PVOID   pExtension,
    OUT PVOID   pPtiExtension
    );

//
// a word about registering callbacks: Par (the device driver level)
// registers callbacks to itself at ParCreate time.  If you are using
// the Ptilink service API in a non-irp fashion, you need to open the
// Ptilink device, and then re-register your own callbacks, which
// effectively disconnects the Par device driver level - it will be
// reconnected, of course, at the next ParCreate.
//
// So the sequence to use the PtiLink API without IRP's is:
//
//      ZwCreateFile("\\\\.\\PTILINKx", ...)
//          at this time, Ptilink attempts tp make a link on LPTx
//          the ParCreate hooks up interrupts, calls PtiInit, etc
//          the only Ptilink stuff exposed to you are the callbacks
//
//      PtiRegisterCallbacks(...your handlers here...)
//          you are overriding the inherent callbacks of the Par level
//
//      PtiWrite(...)
//      ...
//      ... etc, etc ...
//      ...
//
//      ZwClose()
//

#ifndef PID_STANDARD
#define PID_STANDARD 0x13
#endif
#ifndef PID_LINK
#define PID_LINK 0x11
#endif

NTSTATUS
PtiQueryDeviceStatus(
    IN ULONG PortId,      // parallel port number (0..2)
    OUT WCHAR* szPortName  // Buffer of at least LPTXMAXNAME + 1 bytes
    );

NTSTATUS
PtiRegisterCallbacks(
    IN  PVOID                           Extension,
    IN  GET_READ_BUFFER_ROUTINE         GetReadBuffer,
    IN  COMPLETE_READ_BUFFER_ROUTINE    CompleteReadBuffer,
    IN  NOTIFY_LINK_EVENT               LinkEventNotification,
    IN  PVOID                           ParentContext
    );

VOID
PtiCleanup(
    IN  PVOID   PtiExtension
    );

NTSTATUS
PtiWrite(
    IN  PVOID   PtiExtension,
    IN  PVOID   Buffer,
    IN  ULONG   BufferSize,
    IN  UCHAR   Pid
    );

BOOLEAN
PtiIsReadPending(
    IN  PVOID   PtiExtension
    );

VOID
PtiRead(
    IN  PVOID   PtiExtension
    );

ULONG
PtiQueryMaxReadSize(
    );

VOID
PtiPortNameFromPortId(
    IN ULONG PortId,
    OUT CHAR* szPortName
    );

//************************************************************************
//*  Platform Id Codes                                                   *
//************************************************************************

#define PLAT_WIN9X      0               // Win95 and Win98
#define PLAT_DOS        1               // Dos
#define PLAT_NT         2               // WinNT v4 and v5

//************************************************************************
//*  LinkInformation Structure                                           *
//************************************************************************
//
// LinkInformation - Link Management Information
//
// This structure contains information which is exchanged by the Nodes
// within Link Management Packets
//
// This structure must be maintained in parallel with it's twin in PTI.INC
//
// All changes must be backward compatible with all previous driver versions

#define LINKINFOSIZE 45*4           // explicitly define expected size

typedef struct _LINK_INFORMATION {
    UCHAR   LinkFunction;           // 1] Current/Last Link Function
    UCHAR   res1;
    UCHAR   res2;
    UCHAR   res3;

    UCHAR   VerPlat;                // 2] Platform ID byte (see PLAT_XXXX)
    UCHAR   VerReserved;            // reserved
    UCHAR   VerMajor;               // Link Major version
    UCHAR   VerMinor;               // Link Minor version

    UCHAR   IOMode;                 // 3] Current IO transfer mode
    UCHAR   CableType;              // Detected cable type
    UCHAR   PortType;               // Physical parallel port type
    UCHAR   Station;                // Address of this station

    USHORT  FIFOlen;                // 4] ECP FIFO length, if ECP port
    USHORT  FIFOwidth;              //    ECP FIFO width, if ECP port

    ULONG   CPUType;                // 5] CPU type
    ULONG   CPUSpeed;               // 6] CPU speed rating
    ULONG   RxBufSize;              // 7] Rx buffer size
    ULONG   NominalSpd;             // 8] Estimated speed rating
    ULONG   ActualSpd;              // 9] Actual performance to date

    ULONG   PpIOWait;               // 10] default IO wait time
    ULONG   PpLongWait;             // 11] default synchronization wait time
    ULONG   PpShortWait;            // 12] default synchronization wait time

    ULONG   LastLinkTime;           // 13] time of last link receive activity
    ULONG   CableTestTime;          // 14] time of last cable detect
                                    // These times are not used on NT because
                                    // NT times are 64 bits ... see NT time below

    // some basic counters

    ULONG   RxAttempts;             // 15] Number of Ints w/ real RATTNs
    ULONG   RxPackets;              // 16] Number of good received packets
    ULONG   TxAttempts;             // 17] Number of TxPackets attempted
    ULONG   TxPackets;              // 18] Number of successful TxPackets
    ULONG   GoodPackets;            // 19] Number of successful recent Txs / Rxs
    ULONG   HwIRQs;                 // 20] Number of real hardware IRQs

    // Main Error Counter Group

    ULONG   TxHdrDataErrors;        // 21] data error during header
    ULONG   RxHdrDataErrors;        // 22] data error during header
    ULONG   TxHdrSyncErrors;        // 23] sync error during header
    ULONG   RxHdrSyncErrors;        // 24] sync error during header
    ULONG   TxSyncErrors;           // 25] sync error during packet
    ULONG   RxSyncErrors;           // 26] sync error during packet

    // Tx Details Group

    ULONG   TxTimeoutErrors1;       // 27] timeouts in Tx IO code
    ULONG   TxTimeoutErrors2;       // 28] timeouts in Tx IO code
    ULONG   TxTimeoutErrors3;       // 29] timeouts in Tx IO code
    ULONG   TxTimeoutErrors4;       // 30] timeouts in Tx IO code
    ULONG   TxTimeoutErrors5;       // 31] timeouts in Tx IO code
    ULONG   TxCollision;            // 32] Collision in Tx IO code

    // Rx Details Group

    ULONG   RxTimeoutErrors1;       // 33] timeouts in Rx IO code
    ULONG   RxTimeoutErrors2;       // 34] timeouts in Rx IO code
    ULONG   RxTimeoutErrors3;       // 35] timeouts in Rx IO code
    ULONG   RxTimeoutErrors4;       // 36] timeouts in Rx IO code
    ULONG   RxTimeoutErrors5;       // 37] timeouts in Rx IO code
    ULONG   RxTooBigErrors;         // 38] Rx packet too big or won't fit

    // Misc Error Details Group

    ULONG   CableDetects;           // 39] Attempts to detect type of cable
    ULONG   TxRetries;              // 40] Tx Retry attempts
    ULONG   TxRxPreempts;           // 41] Tx Receive preemptions
    ULONG   InternalErrors;         // 42] Internal screwups
    ULONG   ReservedError;          // 43]

    // NT Specific Group

    TIME    LastPacketTime;         // 45] time of last good TX or Rx

} LINK_INFORMATION, *PLINK_INFORMATION;


//
//  This structure is filled in by ECP detection at PtiInitialize time
//

typedef struct _PTI_ECP_INFORMATION {
    BOOLEAN         IsEcpPort;              // Is this an ECP port?
    ULONG           FifoWidth;              // Number of bytes in a PWord.
    ULONG           FifoDepth;              // Number of PWords in FIFO.
} PTI_ECP_INFORMATION, *PPTI_ECP_INFORMATION;

//
// The internal structure for the 'PtiExtension'.
//

typedef struct _PTI_EXTENSION {

    //
    // Base I/O address for parallel port.
    //

    PUCHAR Port;
    PUCHAR wPortECR;        // ECR register if obtained from ParPort
    PUCHAR wPortDFIFO;      // Data FIFO register if obtained from ParPort

    //
    // The link state
    //

    ULONG LinkState;

    //
    // TRUE if we are polling
    //

    BOOLEAN Polling;

    // "mutex" on the line
    // InterlockedCompareExchange64 to TRUE when using wire, FALSE when done
    //
    ULONG Busy;

    //
    // This structure holds the PTI-derived ECP port information.
    //

    PTI_ECP_INFORMATION EcpInfo;

    // Time of last good packet Tx or Rx
    //
    TIME LastGoodPacket;

    // Time of last pass through WatchDog
    //
    TIME LastDogTime;

    //
    // Functions for getting and completing read buffers.
    //

    GET_READ_BUFFER_ROUTINE GetReadBuffer;
    COMPLETE_READ_BUFFER_ROUTINE CompleteReadBuffer;
    NOTIFY_LINK_EVENT LinkEventNotify;
    PVOID ParentContext;

    //
    // Our and His Link Information.
    //

    LINK_INFORMATION Our;
    LINK_INFORMATION His;

} PTI_EXTENSION, *PPTI_EXTENSION;

#endif // _PTILINK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\ptiwan.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// ptiwan.h
// RAS DirectParallel WAN mini-port/call-manager driver
// Main private header (precompiled)
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.
//
//
// About naming:
//
// This driver contains code for both the DirectParallel mini-port and call
// manager.  All handler routines exported to NDIS are prefixed with either
// 'Pti' for the mini-port handlers or 'PtiCm' for the call manager handlers.
//
//
// About locks:
//
// Data structures that may change during simultaneous requests to different
// processors in a multi-processor system must be protected with spin-locks or
// accessed only with interlocked routines.  Where locking is required to
// access a data field in this header, the comment for that field indicates
// same.  A CoNDIS client is a trusted kernel mode component and presumed to
// follow the documented call sequences of CoNDIS.  Some access conflicts that
// might be caused by goofy clients are not checked, though the easy ones are.
// Cases where multiple clients might conflict are protected even though, for
// now, the TAPI proxy is expected to be the only client.
//

#ifndef _PTIWAN_H_
#define _PTIWAN_H_

#include <ntddk.h>
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
//#include <ndisadd.h>        // Temporary
#include <debug.h>
#include <bpool.h>
#include <ppool.h>
#include <ptilink.h>        // PTILINK device (lower edge)


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// The NDIS version we report when registering mini-port and address family.
//
#define NDIS_MajorVersion 5
#define NDIS_MinorVersion 0

// Frame and buffer sizes.  The "plus 2 times 2" is necessary to account for
// the byte-stuffing that is necessary for Win9x legacy reasons.  See the
// HdlcFromAsyncFraming and AsyncFromHdlcFraming routines.
//
#define PTI_MaxFrameSize    1500
#define PTI_FrameBufferSize (((PTI_MaxFrameSize + 2) * 2) + 32)

// Default reported speed of a DirectParallel in bits/second.
// ??? dynamically report line speed
//
#define PTI_LanBps 4000000                  // 100K Bytes/sec typical 4BIT
                                            // 500K Bytes/sec typical enhanced

//-----------------------------------------------------------------------------
// Data types
//-----------------------------------------------------------------------------

// Forward declarations.
//
typedef struct _VCCB VCCB;

// Adapter control block defining the state of a single DirectParallel
// connection.  The DirectParallel driver may support simultaneous connections
// over multiple LPT ports on the same machine
//
// ??? Do we support multiple LPT connections on one machine
// ??? Need to check PTILINK, here in PTIWAN we will allow them
//
// ADAPTERCBs are allocated in MiniportInitialize and deallocated in
// MiniportHalt.
//
typedef struct
_ADAPTERCB
{
    // Set to MTAG_ADAPTERCB for easy identification in memory dumps and use
    // in assertions.
    //
    ULONG ulTag;

    // Reference count on this control block.  The reference pairs are:
    //
    // (a) A reference is added when the MiniportAdapterHandle field is set,
    //     i.e. when LmpInitialize succeeds and cleared when the LmpHalt
    //     handler is called.  The adapter block is actually passed to NDIS
    //     before it's known if LmpInitialize will succeed but according to
    //     ArvindM NDIS will not call halt unless it succeeds.
    //
    // (b) A reference is added when the NdisAfHandle field is set and removed
    //     when it is cleared.
    //
    // (c) A reference is added when the NdisSapHandle field is set and
    //     removed when it is cleared.
    //
    // (d) A reference is added for the VCCB's back pointer and removed when
    //     the VCCB is freed.
    //
    // (e) A reference is added when an NDIS_WORK_ITEM is scheduled and
    //     removed when it has completed.
    //
    // Access is via ReferenceAdapter and DereferenceAdapter only.
    //
    LONG lRef;

    // ACBF_* bit flags indicating various options.  Access restrictions are
    // indicated for each individual flag.
    //
    // ACBF_SapActive: Set when the NdisSapHandle may be used with incoming
    //     calls.  Access is protected by 'lockSap'.
    //
    ULONG ulFlags;
        #define ACBF_SapActive 0x00000001

    // Our framing and bearer capablities bit masks as passed in StartCcReq.
    //
    ULONG ulFramingCaps;
    ULONG ulBearerCaps;

    // Milliseconds to delay OpenAf to give PARPORT a chance to initialize all
    // the parallel ports, and the secondary delay to perform only if no
    // parallel ports are enumerated after the first wait.
    //
    ULONG ulParportDelayMs;
    ULONG ulExtraParportDelayMs;

    // Got to keep handles on all open PtiLink ports to prevent reopen
    //  due to bizarrely involuted CoNdis sequences re Saps and Vcs
    //
    HANDLE hPtiLinkTable[NPORTS];

    // Table of TAPI Line Ids by port
    //
    ULONG ulLineIds[NPORTS];

    // Table of PtiLink interface status bit flags by port
    //
    ULONG ulPtiLinkState[NPORTS];
        #define PLSF_PortExists  0x00000001
        #define PLSF_LineIdValid 0x00000002

    // Parallel port name.  Valid only when port exists.
    //
    WCHAR szPortName[ NPORTS ][ MAXLPTXNAME + 1 ];

    // VC TABLE --------------------------------------------------------------

    // The maximum number of simultaneous VCs.  The value is read from the
    // registry during initialization.
    //
    // ??? This is currently used as the maximum LPT port index in validation,
    // though this may need to change if PTILINK can return a disjoint set of
    // LPT ports
    //
    USHORT usMaxVcs;

    // The actual number of devices for Vcs available to RasPti via PtiLink
    // Determined at OID_CO_TAPI_CM_CAPS time using PtiQueryDeviceStatus
    //
    ULONG ulActualVcs;

    // Table of Temporary Listening VCCBs, one for each possible port.
    //   We open PtiLink for listening at RegisterSap time, and we
    //   don't have a Vc then.  So, at RegisterSap time, we'll make a
    //   VCCB, put a pointer to it here, and use it to listen on.

    VCCB* pListenVc;

    // RESOURCE POOLS --------------------------------------------------------

    // Lookaside list of NDIS_WORK_ITEM scheduling descriptors with extra
    // context space used by all tunnels and VCs attached to the adapter.
    //
    NPAGED_LOOKASIDE_LIST llistWorkItems;

    // Lookaside list of VCCBs from which the control blocks dynamically
    // attached to '*ppVcs' are allocated.
    //
    NPAGED_LOOKASIDE_LIST llistVcs;

    // Pool of full frame buffers with pre-attached NDIS_BUFFER descriptors.
    // The pool is accessed via the interface defined in bpool.h, which
    // handles all locking internally.
    //
    BUFFERPOOL poolFrameBuffers;
    PNDIS_HANDLE phBufferPool;

    // Pool of NDIS_PACKET descriptors used in indication of received frames.
    // The pool is accessed via the interface defined in ppool.h, which
    // handles all locking internally.
    //
    PACKETPOOL poolPackets;
    PNDIS_HANDLE phPacketPool;

    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this mini-port adapter passed to us in
    // MiniportInitialize.  This is passed back to various NdisXxx calls.
    //
    NDIS_HANDLE MiniportAdapterHandle;

    // NDIS's handle for our SAP as passed to our CmRegisterSapHandler or NULL
    // if none.  Only one SAP handle is supported because (a) the TAPI proxy's
    // is expected to be the only one, and (b) there are no PTI SAP properties
    // that would ever lead us to direct a call to a second SAP anyway.  Any
    // client's attempt to register a second SAP will fail.  A value of NULL
    // indicates no SAP handle is currently registered.  Access is via
    // Interlocked routines.
    //
    NDIS_HANDLE NdisSapHandle;

    // NDIS's handle for our Address Family as passed to our CmOpenAfHandler
    // or NULL if none.  Only one is supported.  See NdisSapHandle above.
    // Access is via Interlocked routines.
    //
    NDIS_HANDLE NdisAfHandle;

    // Reference count on the NdisAfHandle.  The reference pairs are:
    //
    // (a) A reference is added when the address family is opened and removed
    //     when it is closed.
    //
    // (b) A reference is added when a SAP is registered on the address family
    //     and removed when it is deregistered.
    //
    // (c) A reference is added when a VC is created on the address family and
    //     removed when it is deleted.
    //
    // Access is via ReferenceAf and DereferenceAf only.
    //
    LONG lAfRef;

    // Reference count on the NdisSapHandle.  The reference pairs are:
    //
    // (a) A reference is added when the SAP is registered and removed when it
    //     is de-registered.
    //
    // (b) A reference is added when a tunnels TCBF_SapReferenced flag is set
    //     and removed when the flag is cleared before the tunnel control
    //     block is freed.
    //
    // (c) A reference is always added before accesses ADAPTERCB.pListenVc and
    //     removed afterward.
    //
    // Access is via ReferenceSap and DereferenceSap only, excepting initial
    // reference by RegisterSapPassive.  Access is protected by 'lockSap'.
    //
    LONG lSapRef;

    // 0-based port index of the port to listen on.  Valid only when
    // 'NdisSapHandle' is non-NULL.
    //
    // ??? Is listening on only 1 port at a time a problem?
    //
    ULONG ulSapPort;

    // This lock protects the 'lSapRef' and 'NdisSapHandle' fields.
    //
    NDIS_SPIN_LOCK lockSap;
    // This adapter's capabilities as returned to callers on
    // OID_WAN_CO_GET_INFO.  These capabilities are also used as defaults for
    // the corresponding VCCB.linkinfo settings during MiniportCoCreateVc.
    //
    NDIS_WAN_CO_INFO info;
}
ADAPTERCB;

// Virtual circuit control block defining the state of a single PTI VC, i.e.
// one line device endpoint and the call, if any, active on it.  A VC is never
// used for incoming and outgoing calls simultaneously.  A single NDIS VC maps
// to one of these.
//
typedef struct
_VCCB
{
    // Set to MTAG_VCCB for easy identification in memory dumps and use in
    // assertions.
    //
    ULONG ulTag;

    // Reference count on this VC control block.  The reference pairs are:
    //
    // (a) PtiCoCreateVc adds a reference that is removed by PtiCoDeleteVc.
    //     This covers all clients that learn of the VCCB via NDIS.
    //
    // (b) All PtiCmXxx handlers take a reference on entry that is released
    //     before exit.
    //
    // (c) For the "listen" VC, a reference is taken when a SAP is registered
    //     and removed when the SAP is deregistered.
    //
    // The field is accessed only by the ReferenceVc and DereferenceVc
    // routines, which protect with Interlocked routines.
    //
    LONG lRef;

    // Back pointer to owning adapter's control block.
    //
    ADAPTERCB* pAdapter;

    // This lock protects VCCB payload send and receive paths as noted in
    // other field descriptions.  In cases where both 'lockV' and
    // 'pTunnel->lockT' are required 'lockT' must be obtained first.
    //
    NDIS_SPIN_LOCK lockV;

    // Lower edge API stuff --------------------------------------------------

    // file handle on the PTILINKx device, <>0 means we have device open
    HANDLE hPtiLink;

    // Parallel Port Index (0=LPT1) in use for this VC
    ULONG ulVcParallelPort;

    // pointer to device extension for the PTILINKx device
    PVOID Extension;

    // pointer to the PTILINK internal extension within the device extension
    //   this is a bit hacky, but it appears too complex to include the
    //   internal PtiLink structures (PtiStruc.h) here
    //   so we'll have PtiInitialize return pointers to both
    PVOID PtiExtension;


    // CALL SETUP ------------------------------------------------------------

    // Our unique call identifier sent back to us by peer in the L2TP header.
    // The value is a 1-based index into the 'ADAPTERCB.ppVcs' array.
    //
    USHORT usCallId;

    // VCBF_* bit flags indicating various options and states.  Access is via
    // the interlocked ReadFlags/SetFlags/ClearFlags routines.
    //
    // VCBF_IndicateReceivedTime: Set if MakeCall caller sets the
    //     MediaParameters.Flags RECEIVE_TIME_INDICATION flag requesting the
    //     TimeReceived field of the NDIS packet be filled with a timestamp.
    //
    // VCBF_CallClosableByClient: Set when a call is in a state where
    //     PtiCmCloseCall requests to initiate clean-up should be accepted.
    //     This may be set when VCBF_CallClosableByPeer is not, which means we
    //     have indicated an incoming close to client and are waiting for him
    //     to do a client close in response (in that weird CoNDIS way).  The
    //     flag is protected by 'lockV'.
    //
    // VCBF_CallClosableByPeer: Set when the call is in a state where an idle
    //     transition without operations pending should be mapped to a
    //     PeerClose event.  This will never be set when
    //     VCBF_CallClosableByClient is not.  The flag is protected by
    //     'lockV'.
    //
    // VCBF_PeerInitiatedCall: Set when an the active call was initiated by
    //     the peer, clear if it was initiated by the client.
    //
    // VCBF_VcCreated: Set when the VC has been created successfully.  This is
    //     the "creation" that occurs with the client, not the mini-port.
    // VCBF_VcActivated: Set when the VC has been activated successfully.
    // VCBF_VcDispatched: Set when the VC has dispatched an incoming call to
    //     the client.
    // VCBM_VcState: Bit mask that includes each of the 3 NDIS state flags.
    //
    // The pending bits below are mutually exclusive, and so require lock
    // protection by 'lockV':
    //
    // VCBF_PeerOpenPending: Set when peer attempts to establish a call, and
    //     the result is not yet known.
    // VCBF_ClientOpenPending: Set when client attempts to establish a call,
    //     and the result is not yet known.
    // VCBF_PeerClosePending: Set when peer attempts to close an established
    //     call and the result is not yet known.  Access is protected by
    //     'lockV'.
    // VCBF_ClientClosePending: Set when client attempts to close an
    //     established call and the result is not yet known.  Access is
    //     protected by 'lockV'.
    // VCBLM_Pending: Bit mask that includes each of the 4 pending flags.
    //
    // VCBF_ClientCloseCompletion: Set when client close completion is in
    //     progress.
    // VCBF_CallInProgress: Set when incoming packets should not trigger the
    //     setup of a new incoming call.
    //
    ULONG ulFlags;
        #define VCBF_IndicateTimeReceived  0x00000001
        #define VCBF_CallClosableByClient  0x00000002
        #define VCBF_CallClosableByPeer    0x00000004
        #define VCBF_IncomingFsm           0x00000010
        #define VCBF_PeerInitiatedCall     0x00000020
        #define VCBF_Sequencing            0x00000040
        #define VCBF_VcCreated             0x00000100
        #define VCBF_VcActivated           0x00000200
        #define VCBF_VcDispatched          0x00000400
        #define VCBM_VcState               0x00000700
        #define VCBF_VcCloseDispatched     0x00000800
        #define VCBF_PeerOpenPending       0x00001000
        #define VCBF_ClientOpenPending     0x00002000
        #define VCBF_PeerClosePending      0x00004000
        #define VCBF_ClientClosePending    0x00008000
        #define VCBM_Pending               0x0000F000
        #define VCBF_ClientCloseCompletion 0x00010000
        #define VCBF_CallInProgress        0x00020000

    // Reference count on the active call.  References may only be added when
    // the VCCB_VcActivated flag is set, and this is enforced by
    // ReferenceCall.  The reference pairs are:
    //
    // (a) A reference is added when a VC is activated and removed when it is
    //     de-activated.
    //
    // (b) A reference is added when the send handler accepts a packet and
    //     released by the send complete routine.
    //
    // (c) A reference is added before entering PtiRx and removed on exit from
    //     same.
    //
    // The field is accessed only by the ReferenceCall and DereferenceCall
    // routines, which protect the field with 'lockCall'.
    //
    LONG lCallRef;
    NDIS_SPIN_LOCK lockCall;

    // This is set to the result to be reported to client and is meaningful
    // only when the VC is on the tunnels list of completing VCs.
    //
    NDIS_STATUS status;

    // Address of the call parameters block passed up in
    // NdisMCmDispatchIncomingCall, or NULL if none.
    //
    CO_CALL_PARAMETERS* pInCall;

    // Shortcut address of the TAPI-specific call parameters in the 'pInCall'
    // incoming call buffer.  Valid only when 'pInCall' is valid, i.e.
    // non-NULL.
    //
    CO_AF_TAPI_INCOMING_CALL_PARAMETERS* pTiParams;

    // Address of the call parameters passed down in CmMakeCall.  This field
    // will only be valid until the NdisMCmMakeCallComplete notification for
    // the associated call is made, at which time it is reset to NULL.  Access
    // is via Interlocked routines.
    //
    CO_CALL_PARAMETERS* pMakeCall;

    // Shortcut address of the TAPI-specific call parameters in the
    // 'pMakeCall' outgoing call buffer.  Valid only when 'pMakeCall' is
    // valid, i.e. non-NULL.
    //
    CO_AF_TAPI_MAKE_CALL_PARAMETERS UNALIGNED* pTmParams;

    // The result and error to report in the coming incoming/outgoing call
    // reply message.
    //
    USHORT usResult;
    USHORT usError;

    // The connect speed in bits/second.  This is the value reported to
    // NDISWAN.
    //
    ULONG ulConnectBps;

    // Number of packets across the link since PtiOpenPtiLink
    //
    ULONG ulTotalPackets;

    // SEND STATE ------------------------------------------------------------

    // Next Sent, the sequence number of next payload packet transmitted on
    // this call.  The field is initialized to 0 and incremented after
    // assignment to an outgoing packet, excepting retransmissions.  Access is
    // protected by 'lockV'.
    //
    USHORT usNs;

    // Double-linked list of outstanding sends, i.e. PAYLOADSENTs sorted by
    // the 'usNs' field with lower values near the head.  Access is protected
    // by 'lockV'.
    //
    LIST_ENTRY listSendsOut;

    // The number of sent but unacknowledged packets that may be outstanding.
    // This value is adjusted dynamically.  Per the draft/RFC, when
    // 'ulAcksSinceSendTimeout' reaches the current setting, the window is
    // increased by one.  When a send timeout expires the window is reduced by
    // half.  The actual send window throttling is done by NDISWAN, based on
    // our indications of the changing window size.  Access is protected by
    // 'lockV'.
    //
    ULONG ulSendWindow;

    // The maximum value of 'ulSendWindow'.  Peer chooses this value during
    // call setup.
    //
    ULONG ulMaxSendWindow;

    // The number of packets acknowledged since the last timeout.  The value
    // is reset when a timeout occurs or the send window is adjusted upward.
    // See 'ulSendWindow'.  Access is protected by 'lockV'.
    //
    ULONG ulAcksSinceSendTimeout;

    // The estimated round trip time in milliseconds.  This is the RTT value
    // from Appendix A of the draft/RFC.  The value is adjusted as each
    // acknowledge is received.  It is initialized to the Packet Processing
    // Delay reported by peer.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    ULONG ulRoundTripMs;

    // The estimated mean deviation in milliseconds, an approximation of the
    // standard deviation.  This is the DEV value from Appendix A of the
    // draft/RFC.  The value is adjusted as each acknowledge is received.  It
    // is initially 0.  See 'ulSendTimeoutMs'.  Access is protected by
    // 'lockV'.
    //
    LONG lDeviationMs;

    // Milliseconds before it is assumed a sent packet will never be
    // acknowledged.  This is the ATO value from Appendix A of the draft/RFC.
    // This value is adjusted as each acknowledge is received, with a maximum
    // of 'ADAPTERCB.ulMaxSendTimeoutMs'.  Access is protected by 'lockV'.
    //
    ULONG ulSendTimeoutMs;

    // The timer event descriptor scheduled to occur when it is time to stop
    // waiting for an outgoing send on which to piggyback an acknowledge.
    // This will be NULL when no delayed acknowledge is pending.  Per the
    // draft/RFC, the timeout used is 1/4 of the 'ulSendTimeoutMs'.  Access is
    // protected by 'lockV'.
    //
//  TIMERQITEM* pTqiDelayedAck;


    // RECEIVE STATE ---------------------------------------------------------

    // Next Received, the sequence number one higher than that of the last
    // payload packet received on this call or 0 if none.  Access is protected
    // by 'lockV'.
    //
    USHORT usNr;

    // Double-linked list of out-of-order receives, i.e. PAYLOADRECEIVEs
    // sorted by the 'usNs' field with lower values near the head.  The
    // maximum queue length is 'ADAPTERCB.sMaxOutOfOrder'.  Access is
    // protected by 'lockV'.
    //
    LIST_ENTRY listOutOfOrder;

    // The timer event descriptor scheduled to occur when it is time to assume
    // peer's current 'Next Received' packet has been lost, and "receive" the
    // first packet in 'listOutOfOrder'.  This will be NULL when
    // 'listOutOfOrder' is empty.  Access is protected by 'lockV'.
    //
//  TIMERQITEM* pTqiAssumeLost;

    // NDIS BOOKKEEPING ------------------------------------------------------

    // NDIS's handle for this VC passed to us in MiniportCoCreateVcHandler.
    // This is passed back to NDIS in various NdisXxx calls.
    //
    NDIS_HANDLE NdisVcHandle;

    // Configuration settings returned to callers on OID_WAN_CO_GET_INFO and
    // modified by callers on OID_WAN_CO_SET_INFO.  Older NDISWAN references to
    // "LINK" map straight to "VC" in the NDIS 5.0 world.  Access is not
    // protected because each ULONG in the structure is independent so no
    // incoherency can result from multiple access.
    //
    NDIS_WAN_CO_GET_LINK_INFO linkinfo;
}
VCCB;



//-----------------------------------------------------------------------------
// Macros/inlines
//-----------------------------------------------------------------------------

// These basics are not in the DDK headers for some reason.
//
#define min( a, b ) (((a) < (b)) ? (a) : (b))
#define max( a, b ) (((a) > (b)) ? (a) : (b))

#define InsertBefore( pNewL, pL )    \
{                                    \
    (pNewL)->Flink = (pL);           \
    (pNewL)->Blink = (pL)->Blink;    \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}

#define InsertAfter( pNewL, pL )     \
{                                    \
    (pNewL)->Flink = (pL)->Flink;    \
    (pNewL)->Blink = (pL);           \
    (pNewL)->Flink->Blink = (pNewL); \
    (pNewL)->Blink->Flink = (pNewL); \
}


// Winsock-ish host/network byte order converters for short and long integers.
//
#if (defined(_M_IX86) && (_MSC_FULL_VER > 13009037)) || ((defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_FULL_VER > 13009175))
#define htons(x) _byteswap_ushort((USHORT)(x))
#define htonl(x) _byteswap_ulong((ULONG)(x))
#else
#define htons( a ) ((((a) & 0xFF00) >> 8) |\
                    (((a) & 0x00FF) << 8))
#define htonl( a ) ((((a) & 0xFF000000) >> 24) | \
                    (((a) & 0x00FF0000) >> 8)  | \
                    (((a) & 0x0000FF00) << 8)  | \
                    (((a) & 0x000000FF) << 24))
#endif
#define ntohs( a ) htons(a)
#define ntohl( a ) htonl(a)

// Place in a TRACE argument list to correspond with a format of "%d.%d.%d.%d"
// to print network byte-ordered IP address 'x' in human readable form.
//
#define IPADDRTRACE(x) ((x) & 0x000000FF),         \
                       (((x) >> 8) & 0x000000FF),  \
                       (((x) >> 16) & 0x000000FF), \
                       (((x) >> 24) & 0x000000FF)


// All memory allocations and frees are done with these ALLOC_*/FREE_*
// macros/inlines to allow memory management scheme changes without global
// editing.  For example, might choose to lump several lookaside lists of
// nearly equal sized items into a single list for efficiency.
//
// NdisFreeMemory requires the length of the allocation as an argument.  NT
// currently doesn't use this for non-paged memory, but according to JameelH,
// Windows95 does.  These inlines stash the length at the beginning of the
// allocation, providing the traditional malloc/free interface.
//
__inline
VOID*
ALLOC_NONPAGED(
    IN ULONG ulBufLength,
    IN ULONG ulTag )
{
    CHAR* pBuf;

    NdisAllocateMemoryWithTag(
        &pBuf, (UINT )(ulBufLength + MEMORY_ALLOCATION_ALIGNMENT), ulTag );
    if (!pBuf)
    {
        return NULL;
    }

    ((ULONG* )pBuf)[ 0 ] = ulBufLength;
    ((ULONG* )pBuf)[ 1 ] = ulTag;
    return pBuf + MEMORY_ALLOCATION_ALIGNMENT;
}

__inline
VOID
FREE_NONPAGED(
    IN VOID* pBuf )
{
    ULONG ulBufLen;

    ulBufLen = *((ULONG* )(((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT));
    NdisFreeMemory(
        ((CHAR* )pBuf) - MEMORY_ALLOCATION_ALIGNMENT,
        (UINT )(ulBufLen + MEMORY_ALLOCATION_ALIGNMENT),
        0 );
}

#define ALLOC_VCCB( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistVcs )
#define FREE_VCCB( pA, pV ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistVcs, (pV) )

#define ALLOC_NDIS_WORK_ITEM( pA ) \
    NdisAllocateFromNPagedLookasideList( &(pA)->llistWorkItems )
#define FREE_NDIS_WORK_ITEM( pA, pNwi ) \
    NdisFreeToNPagedLookasideList( &(pA)->llistWorkItems, (pNwi) )


//-----------------------------------------------------------------------------
// Prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
CallCleanUp(
    IN VCCB* pVc );

VOID
CallTransitionComplete(
    IN VCCB* pVc );

VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
CloseCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

VOID
CompleteVc(
    IN VCCB* pVc );

VOID
DereferenceAdapter(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceAf(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceCall(
    IN VCCB* pVc );

VOID
DereferenceSap(
    IN ADAPTERCB* pAdapter );

VOID
DereferenceVc(
    IN VCCB* pVc );

BOOLEAN
IsWin9xPeer(
    IN VCCB* pVc );

PVOID
PtiCbGetReadBuffer(
    IN  PVOID   pVc,
    OUT PULONG  BufferSize,
    OUT PVOID*  RequestContext
    );

VOID
PtiRx(
    IN  PVOID       pVc,
    IN  PVOID       ReadBuffer,
    IN  NTSTATUS    Status,
    IN  ULONG       BytesTransfered,
    IN  PVOID       RequestContext
    );

VOID
PtiCbLinkEventHandler(
    IN  PVOID       pVc,
    IN  ULONG       PtiLinkEventId,
    IN  ULONG       PtiLinkEventData
    );

NDIS_STATUS
PtiCmOpenAf(
    IN NDIS_HANDLE CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY AddressFamily,
    IN NDIS_HANDLE NdisAfHandle,
    OUT PNDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
PtiCmCloseAf(
    IN NDIS_HANDLE CallMgrAfContext );

NDIS_STATUS
PtiCmRegisterSap(
    IN NDIS_HANDLE CallMgrAfContext,
    IN PCO_SAP Sap,
    IN NDIS_HANDLE NdisSapHandle,
    OUT PNDIS_HANDLE CallMgrSapContext );

VOID
RegisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiCmDeregisterSap(
    NDIS_HANDLE CallMgrSapContext );

VOID
DeregisterSapPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiCmCreateVc(
    IN NDIS_HANDLE ProtocolAfContext,
    IN NDIS_HANDLE NdisVcHandle,
    OUT PNDIS_HANDLE ProtocolVcContext );

NDIS_STATUS
PtiCmDeleteVc(
    IN NDIS_HANDLE ProtocolVcContext );

NDIS_STATUS
PtiCmMakeCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters,
    IN NDIS_HANDLE NdisPartyHandle,
    OUT PNDIS_HANDLE CallMgrPartyContext );

VOID
MakeCallPassive(
    IN NDIS_WORK_ITEM* pWork,
    IN VOID* pContext );

NDIS_STATUS
PtiCmCloseCall(
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN PVOID CloseData,
    IN UINT Size );

VOID
PtiCmIncomingCallComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
PtiCmActivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

VOID
PtiCmDeactivateVcComplete(
    IN NDIS_STATUS Status,
    IN NDIS_HANDLE CallMgrVcContext );

NDIS_STATUS
PtiCmModifyCallQoS(
    IN NDIS_HANDLE CallMgrVcContext,
    IN PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
PtiCmRequest(
    IN NDIS_HANDLE CallMgrAfContext,
    IN NDIS_HANDLE CallMgrVcContext,
    IN NDIS_HANDLE CallMgrPartyContext,
    IN OUT PNDIS_REQUEST NdisRequest );

NDIS_STATUS
PtiInit(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext );

VOID
PtiHalt(
    IN NDIS_HANDLE MiniportAdapterContext );

NDIS_STATUS
PtiReset(
    OUT PBOOLEAN AddressingReset,
    IN NDIS_HANDLE MiniportAdapterContext );

VOID
PtiReturnPacket(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet );

NDIS_STATUS
PtiQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded );

NDIS_STATUS
PtiSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded );

NDIS_STATUS
PtiCoActivateVc(
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PCO_CALL_PARAMETERS CallParameters );

NDIS_STATUS
PtiCoDeactivateVc(
    IN NDIS_HANDLE MiniportVcContext );

VOID
PtiCoSendPackets(
    IN NDIS_HANDLE MiniportVcContext,
    IN PPNDIS_PACKET PacketArray,
    IN UINT NumberOfPackets );

NDIS_STATUS
PtiCoRequest(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportVcContext,
    IN OUT PNDIS_REQUEST NdisRequest );

VOID
PtiReceive(
    IN VOID* pAddress,
    IN CHAR* pBuffer,
    IN ULONG ulOffset,
    IN ULONG ulBufferLen );

ULONG
ReadFlags(
    IN ULONG* pulFlags );

VOID
ReferenceAdapter(
    IN ADAPTERCB* pAdapter );

VOID
ReferenceAf(
    IN ADAPTERCB* pAdapter );

BOOLEAN
ReferenceCall(
    IN VCCB* pVc );

BOOLEAN
ReferenceSap(
    IN ADAPTERCB* pAdapter );

VOID
ReferenceVc(
    IN VCCB* pVc );

NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext );

VOID
SendClientString(
    IN PVOID pPtiExtension );

VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask );

VOID
SetupVcAsynchronously(
    IN ADAPTERCB* pAdapter );

ULONG
StrCmp(
    IN LPSTR cs,
    IN LPSTR ct,
    ULONG n );

ULONG
StrCmpW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 );

VOID
StrCpyW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 );

CHAR*
StrDup(
    IN CHAR* psz );

CHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString );

CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra );

ULONG
StrLenW(
    IN WCHAR* psz );

#endif // _PTIWAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\debug.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
//
// debug.h
// DirectParallel WAN mini-port/call-manager driver
// Debug helper header
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#ifndef _DEBUG_H_
#define _DEBUG_H_


//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//
#define MTAG_FREED      'fITP'
#define MTAG_ADAPTERCB  'aITP'
#define MTAG_VCCB       'vITP'
#define MTAG_UTIL       'uITP'
#define MTAG_VCTABLE    'tITP'
#define MTAG_PTIPARAMS  'pITP'
#define MTAG_PACKETPOOL 'pITP'
#define MTAG_FBUFPOOL   'bITP'
#define MTAG_INCALLBUF  'iITP'
#define MTAG_WORKITEM   'wITP'

// Trace levels.
//
#define TL_None 0    // Trace disabled
#define TL_A    0x10 // Alert
#define TL_I    0x20 // Interface
#define TL_N    0x30 // Normal
#define TL_V    0x40 // Verbose

// Trace mask bits.
//
#define TM_Cm   0x00000001 // Call manager general
#define TM_Mp   0x00000002 // Mini-port general
#define TM_Send 0x00000004 // Send path
#define TM_Recv 0x00000008 // Receive path
#define TM_Fsm  0x00000010 // Finite state machines
#define TM_Init 0x00000020 // Initialization
#define TM_Misc 0x00000040 // Miscellaneous
#define TM_Msg  0x00000100 // Messages
#define TM_Ref  0x00010000 // References
#define TM_Data 0x00020000 // Dump data under TESTMODE
#define TM_Pool 0x00080000 // Buffer and packet pooling
#define TM_MDmp 0x10000000 // Message dumps
#define TM_Dbg  0x80000000 // Debug corruption checks
#define TM_Spec 0x01000000 // Special

#define TM_Wild 0xFFFFFFFF // Everything
#define TM_All  0x7FFFFFFF // Everything except corruption checks
#define TM_Test 0x0001FFF3 // Base w/ messages and references
#define TM_Base 0x000000F3 // Base w/o send and receive

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern ULONG g_ulTraceLevel;
extern ULONG g_ulTraceMask;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.  For
// example...
//
// A "leave" routine message:
//     TRACE( TL_N, TM_Init, ( "DriverEntry=$%x", status ) );
// An error condition occurred:
//     TRACE( TL_E, TM_Init, ( "NdisMRegisterMiniport=$%x", status ) );
//
//
#define TRACE(ulLevel,ulMask,Args)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        DbgPrint( "RASPTI: " );                                \
        DbgPrint Args;                                         \
        DbgPrint( "\n" );                                      \
    }                                                          \
}

// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                           \
{                                                           \
    if (!(x))                                               \
    {                                                       \
        DbgPrint( "RASPTI: !ASSERT( %s ) at line %d of %s\n", \
            #x, __LINE__, __FILE__ );                       \
        DbgBreakPoint();                                    \
    }                                                       \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}


// Double-linked list corruption detector.  Runs the test if 'ulMask' is
// enabled, with TM_Dbg a suggested setting.  Shows verbose output if
// 'ulLevel' is at or above the current trace threshold.
//
#define CHECKLIST(ulMask,p,ulLevel)                            \
{                                                              \
    if (g_ulTraceMask & ulMask)                                \
    {                                                          \
        CheckList( p, (BOOLEAN )(ulLevel <= g_ulTraceLevel) ); \
    }                                                          \
}


// DBG_if can be used to put in TRACE/DUMPs conditional on an expression that
// need not be evaluated in non-DBG builds, e.g the statements below generate
// no code in a non-DBG build, but in DBG builds print the TRACE if x<y and
// asserts otherwise.
//
//     DBG_if (x < y)
//         TRACE( TL_N, TM_Misc, ( "x < y" ) );
//     DBG_else
//         ASSERT( FALSE );
//
//
#define DBG_if(x) if (x)
#define DBG_else  else


#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#undef ASSERT
#define ASSERT(x)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define CHECKLIST(ulMask,p,ulLevel)
#define DBG_if(x)
#define DBG_else

#endif


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ndis\raspti\util.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
// Copyright (c) 1997, Parallel Technologies, Inc., all rights reserved
//
// util.c
// DirectParallel WAN mini-port/call-manager driver
// General utility routines
//
// 01/07/97 Steve Cobb
// 09/15/97 Jay Lowe, Parallel Technologies, Inc.

#include "ptiwan.h"


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber );

VOID
ReversePsz(
    IN OUT CHAR* psz );

VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf );


//-----------------------------------------------------------------------------
// General utility routines (alphabetically)
//-----------------------------------------------------------------------------


VOID
ClearFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = ReadFlags( pulFlags );
        ulNewFlags = ulFlags & ~(ulMask);
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG)ulFlags);
}

VOID
IndicateLinkStatus(
    IN VCCB* pVc )

    // Indicate new WAN_CO_LINKPARAMS settings for 'pVc' to NDISWAN.
    //
{
    ADAPTERCB* pAdapter;
    WAN_CO_LINKPARAMS params;

    pAdapter = pVc->pAdapter;

    params.TransmitSpeed = pVc->ulConnectBps;
    params.ReceiveSpeed = params.TransmitSpeed;
    params.SendWindow = 1;
    TRACE( TL_N, TM_Mp, ( "NdisMCoIndStatus(LINK) cid=%d bps=%d sw=%d",
        pVc->usCallId, params.TransmitSpeed, params.SendWindow ) );
    NdisMCoIndicateStatus(
        pAdapter->MiniportAdapterHandle,
        pVc->NdisVcHandle,
        NDIS_STATUS_WAN_CO_LINKPARAMS,
        &params,
        sizeof(params) );
    TRACE( TL_N, TM_Mp, ( "NdisMCoIndStatus done" ) );
}

ULONG
ReadFlags(
    IN ULONG* pulFlags )

    // Read the value of '*pulFlags' as an interlocked operation.
    //
{
    return InterlockedExchangeAdd( pulFlags, 0 );
}


NDIS_STATUS
ScheduleWork(
    IN ADAPTERCB* pAdapter,
    IN NDIS_PROC pProc,
    IN PVOID pContext )

    // Schedules a PASSIVE IRQL callback to routine 'pProc' which will be
    // passed 'pContext'.  'PAdapter' is the adapter control block from which
    // the work item is allocated.  This routine takes an adapter reference
    // that should be removed by the called 'pProc'.
    //
    // Returns NDIS_STATUS_SUCCESS or an error code.
    //
{
    NDIS_STATUS status;
    NDIS_WORK_ITEM* pWork;

    pWork = ALLOC_NDIS_WORK_ITEM( pAdapter );
    if (!pWork)
    {
        ASSERT( !"Alloc work?" );
        return NDIS_STATUS_RESOURCES;
    }

    NdisInitializeWorkItem( pWork, pProc, pContext );

    ReferenceAdapter( pAdapter );
    status = NdisScheduleWorkItem( pWork );
    if (status != NDIS_STATUS_SUCCESS)
    {
        ASSERT( !"SchedWork?" );
        FREE_NDIS_WORK_ITEM( pAdapter, pWork );
        DereferenceAdapter( pAdapter );
    }

    return status;
}


VOID
SetFlags(
    IN OUT ULONG* pulFlags,
    IN ULONG ulMask )

    // Set 'ulMask' bits in '*pulFlags' flags as an interlocked operation.
    //
{
    ULONG ulFlags;
    ULONG ulNewFlags;

    do
    {
        ulFlags = ReadFlags( pulFlags );
        ulNewFlags = ulFlags | ulMask;
    }
    while (InterlockedCompareExchange(
               pulFlags, ulNewFlags, ulFlags ) != (LONG )ulFlags);
}


ULONG
StrCmp(
    IN LPSTR cs,
    IN LPSTR ct,
    ULONG n 
)
	// Return 0 if string cs = string ct for length n
    //
{
    char ret;

    while (n--)
    {
        ret = *cs - *ct;

        if (ret)
            break;

        cs++;
        ct++;
    }

    return (ULONG)ret;
}


ULONG
StrCmpW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 )

	// Returns 0 if 'psz1' matches 'psz2'.
    //
{
    WCHAR pch;

    pch = (WCHAR )0;
    while (*psz1 && *psz2)
    {
        pch = *psz1 - *psz2;
        if (pch)
        {
            break;
        }

        psz1++;
        psz2++;
    }

    return (ULONG )pch;
}


VOID
StrCpyW(
    IN WCHAR* psz1,
    IN WCHAR* psz2 )

	// Copies 'psz2' to 'psz1'.
    //
{
    while (*psz2)
    {
        *psz1++ = *psz2++;
    }

    *psz1 = L'\0';
}


CHAR*
StrDup(
    IN CHAR* psz )

    // Return a duplicate of 'psz'.  Caller must eventually call FREE_NONPAGED
    // on the returned string.
    //
{
    return StrDupSized( psz, strlen( psz ), 0 );
}


CHAR*
StrDupNdisString(
    IN NDIS_STRING* pNdisString )

    // Returns null-terminated ASCII copy of the NDIS_STRING 'pNdisString'
    // Caller must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( pNdisString->Length + 1, MTAG_UTIL );
    if (pszDup)
    {
        NdisZeroMemory( pszDup, pNdisString->Length + 1 );
        if (pNdisString->Length)
        {
            NdisMoveMemory( pszDup, pNdisString->Buffer, pNdisString->Length );
        }

        // NDIS_STRING is UNICODE_STRING on NT but need the corresponding
        // ASCII (not multi-byte ANSI) value from NDIS_STRING on any system.
        // If it looks like a Unicode string then "convert" it by picking out
        // every other byte, hopefully all the non-zero ones.  This is not
        // foolproof, but then Unicode doesn't convert to ASCII in any
        // foolproof way.
        //
        if (pNdisString->Length > 1 && pszDup[ 1 ] == '\0')
        {
            USHORT i;

            for (i = 0; i * 2 < pNdisString->Length; ++i)
            {
                pszDup[ i ] = pszDup[ i * 2 ];
            }

            pszDup[ i ] = '\0';
        }
    }

    return pszDup;
}


CHAR*
StrDupSized(
    IN CHAR* psz,
    IN ULONG ulLength,
    IN ULONG ulExtra )

    // Return a duplicate of the first 'ulLength' bytes of 'psz' followed by a
    // null character and 'ulExtra' extra bytes, or NULL on error.  Caller
    // must eventually call FREE_NONPAGED on the returned string.
    //
{
    CHAR* pszDup;

    pszDup = ALLOC_NONPAGED( ulLength + 1 + ulExtra, MTAG_UTIL );
    if (pszDup)
    {
        if (ulLength)
        {
            NdisMoveMemory( pszDup, psz, ulLength );
        }
        pszDup[ ulLength ] = '\0';
    }

    return pszDup;
}


ULONG
StrLenW(
    IN WCHAR* psz )

    // Returns number of characters in a null-terminated Unicode string.
    //
{
    ULONG ul;

    ul = 0;
    while (*psz++)
    {
        ++ul;
    }

    return ul;
}


//-----------------------------------------------------------------------------
// Local utility routines (alphabetically)
//-----------------------------------------------------------------------------

ULONG
atoul(
    IN CHAR* pszNumber )

    // Convert string of digits 'pszNumber' to it's ULONG value.
    //
{
    ULONG ulResult;

    ulResult = 0;
    while (*pszNumber && *pszNumber >= '0' && *pszNumber <= '9')
    {
        ulResult *= 10;
    ulResult += *pszNumber - '0';
    ++pszNumber;
    }

    return ulResult;
}


VOID
ReversePsz(
    IN OUT CHAR* psz )

    // Reverse the order of the characters in 'psz' in place.
    //
{
    CHAR* pchLeft;
    CHAR* pchRight;

    pchLeft = psz;
    pchRight = psz + strlen( psz ) - 1;

    while (pchLeft < pchRight)
    {
        CHAR ch;

        ch = *pchLeft;
        *pchLeft = *pchRight;
        *pchRight = *pchLeft;
    }
}


#if 0
VOID
ultoa(
    IN ULONG ul,
    OUT CHAR* pszBuf )

    // Convert 'ul' to null-terminated string form in caller's 'pszBuf'.
    //
{
    CHAR* pch;

    pch = pszBuf;
    do
    {
        *pch++ = (CHAR )((ul % 10) + '0');
        ul /= 10;
    }
    while (ul);
    *pch = '\0';

    ReversePsz( pszBuf );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaaconfig.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    aaaaconfig.h
//
// Abstract:
//
// Author: tperraut  04/99
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAACONFIG_H_
#define _AAAACONFIG_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

FN_HANDLE_CMD    HandleAaaaConfigSet;
FN_HANDLE_CMD    HandleAaaaConfigShow;

DWORD
AaaaConfigDumpConfig();

#ifdef __cplusplus
}
#endif
#endif //_AAAACONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaahndl.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
// 
// Module Name:
// 
//   aaaahndl.h
//
// Abstract:
//
//
// Revision History:
//
//    Thierry Perraut 04/02/1999
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAHNDL_H_
#define _AAAAHNDL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// FN_HANDLE_CMD    HandleAaaaShowServers;

NS_CONTEXT_DUMP_FN  AaaaDump;

#ifdef __cplusplus
}
#endif
#endif //_AAAAHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaamon.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-1999  Microsoft Corporation
// 
// Module Name:
// 
//      aaaamon.h
//
// Abstract:                           
//
//      Prototype for fns called in aaaamon.c
//
// Revision History:
//
//      Anand Mahalingam    7/10/98 (ipmon.h)
//      Thierry Perraut 04/02/1999  (aaaamon.h)
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAMON_H_
#define _AAAAMON_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern HANDLE   g_hModule;

#ifdef __cplusplus
}
#endif

#endif // _AAAAMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaaconfig.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-2000  Microsoft Corporation
//
// Module Name:
//
//    aaaaConfig.cpp
//
// Abstract:
//
//    Handlers for aaaa config commands
//
// Revision History:
//
//    pmay
//    tperraut 04/02/1999 
//    tperraut 04/03/2000 Version# test, use of upgrade code for version < 
//                        Whistler Proxy (2)
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "strdefs.h"
#include "rmstring.h"
#include "aaaamon.h"
#include "aaaaversion.h"
#include "aaaaconfig.h"

//
//  NOTE since WIN32 errors are assumed to fall in the range -32k to 32k
//  (see comment in winerror.h near HRESULT_FROM_WIN32 definition), we can
//  re-create original Win32 error from low-order 16 bits of HRESULT.
//
#define WIN32_FROM_HRESULT(x)	\
    ( (HRESULT_FACILITY(x) == FACILITY_WIN32) ? ((DWORD)((x) & 0x0000FFFF)) : (x) )


//////////////////////////////////////////////////////////////////////////////
//
// Parses the Aaaa set config from the command line
//
//////////////////////////////////////////////////////////////////////////////
DWORD
AaaaConfigParseCommandLine(
    IN  PWCHAR              *ppwcArguments,
    IN  DWORD               dwCurrentIndex,
    IN  DWORD               dwArgCount,
    IN  DWORD               dwCmdFlags
                            )

{
    const WCHAR IAS_MDB[]     = L"%SystemRoot%\\System32\\ias\\ias.mdb";
    DWORD   dwErr = NO_ERROR;
 
    TOKEN_VALUE rgEnumState[] = 
    {
        {TOKEN_SET,     HLP_AAAACONFIG_SET}, 
        {TOKEN_SHOW,    HLP_AAAACONFIG_SHOW}
    };
    AAAAMON_CMD_ARG  pArgs[] = 
    {
        {
            AAAAMONTR_CMD_TYPE_STRING, 
            // tag string, required or not, present or not
            {TOKEN_BLOB, NS_REQ_PRESENT,   FALSE}, //tag_type
            rgEnumState,
            sizeof(rgEnumState)/sizeof(*rgEnumState),
            NULL
        }
    };        

    do
    {
        // Parse
        //
        dwErr = RutlParse(
                            ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            NULL,
                            pArgs,
                            sizeof(pArgs) / sizeof(*pArgs));
        if ( dwErr != NO_ERROR )
        {
            break;
        }

        // Config
        //
        if ( !pArgs[0].rgTag.bPresent )
        {
            // tag blob not found 
            DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_FAIL);   
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        // tag blob found
        // Now try to restore the database from the script
        HRESULT     hres = IASRestoreConfig(ppwcArguments[dwCurrentIndex]);
        if ( FAILED(hres) )
        {
            DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_FAIL);   
            dwErr = WIN32_FROM_HRESULT(hres);
            break;
        }

        // set config successfull: refresh the service
        hres = RefreshIASService();
        if ( FAILED(hres) )
        {
            ///////////////////////////
            // Refresh should not fail.
            ///////////////////////////
            DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_REFRESH_FAIL);   
            dwErr = NO_ERROR;
        }
        else
        {
            DisplayMessage(g_hModule, MSG_AAAACONFIG_SET_SUCCESS);
            dwErr = NO_ERROR;
        }

    } while ( FALSE );  
    
    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
// Function Name:AaaConfigDumpConfig
//
// Parameters: none
//
// Description: writes the current config (header, content...) to the output
//
// Returns: NO_ERROR or ERROR_SUPPRESS_OUTPUT
//
//////////////////////////////////////////////////////////////////////////////
DWORD AaaaConfigDumpConfig()
{
    const int MAX_SIZE_DISPLAY_LINE  = 80;
    const int SIZE_MAX_STRING        = 512;
    const int WHISTLER_PROXY_VERSION = 3;

    DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_HEADER);

    bool bCoInitialized = false;
    do
    {
       HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
       if ( FAILED(hr) )
       {
           if ( hr != RPC_E_CHANGED_MODE )
           {
               break;
           }
       }
       else
       {
           bCoInitialized = true;
       }


       LONG        lVersion;
       hr = AaaaVersionGetVersion(&lVersion);
       if ( FAILED(hr) )
       {
           DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_FAIL);   
           break;
       }

       // Sanity check to make sure that the actual database is a Whistler DB
       if ( lVersion != WHISTLER_PROXY_VERSION )
       {
           DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_FAIL);   
           break;
       }

       WCHAR       sDisplayString[SIZE_MAX_STRING] = L"";
       _snwprintf( 
                   sDisplayString, 
                   SIZE_MAX_STRING,
                   L"# IAS.MDB Version = %d\n", 
                   lVersion
                 );

       DisplayMessageT(sDisplayString);
    
       ULONG       ulSize;
       WCHAR*      pDumpString;
       hr = IASDumpConfig(&pDumpString, &ulSize);

       if ( SUCCEEDED(hr) )
       {
           ULONG   RelativePos     = 0;
           ULONG   CurrentPos      = 0;
           WCHAR   DisplayLine [MAX_SIZE_DISPLAY_LINE];

           DisplayMessageT(MSG_AAAACONFIG_BLOBBEGIN);
           while ( CurrentPos <= ulSize )
           {
               WCHAR   TempChar = pDumpString[CurrentPos++];
               DisplayLine[RelativePos++] = TempChar;
               if ( TempChar == L'\r' )
               {
                   DisplayLine[RelativePos] = L'\0'; 
                   DisplayMessageT(DisplayLine);
                   RelativePos = 0;
               }
           }
           DisplayMessageT(L"*");

           free (pDumpString); // was allocated by malloc
           DisplayMessageT(MSG_AAAACONFIG_BLOBEND);

           DisplayMessage(
                           g_hModule, 
                           MSG_AAAACONFIG_SHOW_FOOTER
                         );

       }
       else
       {
           DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_INVALID_SYNTAX);   
           DisplayMessage(g_hModule, HLP_AAAACONFIG_SHOW);
       }
    }
    while (false);

    if (bCoInitialized)
    {
        CoUninitialize();
    }

    return  NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
//
// Handles the aaaa config set command
//
//////////////////////////////////////////////////////////////////////////////
DWORD
HandleAaaaConfigSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return AaaaConfigParseCommandLine(
                                          ppwcArguments,
                                          dwCurrentIndex,
                                          dwArgCount,
                                          dwFlags
                                      );
}


//////////////////////////////////////////////////////////////////////////////
//
// Handles the aaaa config show command
//
//////////////////////////////////////////////////////////////////////////////
DWORD
HandleAaaaConfigShow(
                IN      LPCWSTR   pwszMachine,
                IN OUT  LPWSTR   *ppwcArguments,
                IN      DWORD     dwCurrentIndex,
                IN      DWORD     dwArgCount,
                IN      DWORD     dwFlags,
                IN      LPCVOID   pvData,
                OUT     BOOL     *pbDone
                )
{
    if (dwCurrentIndex < dwArgCount)
    {
        DisplayMessage(g_hModule, MSG_AAAACONFIG_SHOW_FAIL);   
        DisplayMessage(g_hModule, HLP_AAAACONFIG_SHOW);
    }
    else
    {
        AaaaConfigDumpConfig();
    }

    return  NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaamontr.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-1999  Microsoft Corporation
// 
// Module Name:
// 
//    aaaamontr.h
//
// Abstract:                           
//
//    This file contains definitions which are needed by AAAAMONTR.DLL
//    and all NetSh helper DLLs which register under it.
//
// Revision History:
//
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAMONTR_H_
#define _AAAAMONTR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//{1D0FA29B-E93E-11d2-A91E-009027450464}
#define AAAAMONTR_GUID \
{ 0x1D0FA29B, 0xE93E, 0x11d2, { 0xA9, 0x1E, 0x00, 0x90, 0x27, 0x45, 0x04, 0x64 } }

#define AAAAMONTR_VERSION_50     0x0005000
#define AAAAMONTR_OS_BUILD_NT40  1381

//
// Enumerations for types of arguments (see AAAAMON_CMD_ARG)
//
#define AAAAMONTR_CMD_TYPE_STRING 0x1
#define AAAAMONTR_CMD_TYPE_ENUM   0x2

// 
// Macros to operate on AAAAMON_CMD_ARG's
//
#define AAAAMON_CMD_ARG_GetPsz(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.pszValue : NULL)

#define AAAAMON_CMD_ARG_GetDword(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : 0)

// 
// Structure defining a command line argument
//
typedef struct _AAAAMON_CMD_ARG
{
    IN  DWORD dwType;           // AAAAMONTR_CMD_TYPE_*
    IN  TAG_TYPE rgTag;         // The tag for this command
    IN  TOKEN_VALUE* rgEnums;   // The enumerations for this arg
    IN  DWORD dwEnumCount;      // Count of enums
    union
    {
        OUT PWCHAR pszValue;        // Valid only for AAAAMONTR_CMD_TYPE_STRING
        OUT DWORD dwValue;          // Valid only for AAAAMONTR_CMD_TYPE_ENUM
    } Val;        
    
} AAAAMON_CMD_ARG, *PAAAAMON_CMD_ARG;

//
// Api's that aaaamontr requires of its helpers
//
typedef
DWORD
(WINAPI AAAA_CONTEXT_ENTRY_FN)(
    IN    PWCHAR               pszServer,
    IN    DWORD                dwBuild,
    IN    PTCHAR               *pptcArguments,
    IN    DWORD                dwArgCount,
    IN    DWORD                dwFlags,
    OUT   PWCHAR               pwcNewContext
    );
typedef AAAA_CONTEXT_ENTRY_FN *PAAAA_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI AAAA_CONTEXT_DUMP_FN)(
    IN  HANDLE  hFile
    );
typedef AAAA_CONTEXT_DUMP_FN* PAAAA_CONTEXT_DUMP_FN;

//
// Api's that aaaamontr exposes to its helpers
//
typedef 
PVOID
(WINAPI AAAA_ALLOC_FN)(
    IN DWORD dwBytes,
    IN BOOL bZero
    );
typedef AAAA_ALLOC_FN* PAAAA_ALLOC_FN;

typedef 
VOID
(WINAPI AAAA_FREE_FN)(
    IN PVOID pvData
    );
typedef AAAA_FREE_FN* PAAAA_FREE_FN;

typedef 
PWCHAR
(WINAPI AAAA_STRDUP_FN)(
    IN PWCHAR pwszSrc
    );
typedef AAAA_STRDUP_FN* PAAAA_STRDUP_FN;

typedef
LPDWORD
(WINAPI AAAA_DWORDDUP_FN)(
    IN DWORD dwSrc
    );
typedef AAAA_DWORDDUP_FN* PAAAA_DWORDDUP_FN;

typedef 
DWORD
(WINAPI AAAA_CREATE_DUMP_FILE_FN)(
    IN  PWCHAR  pwszName,
    OUT PHANDLE phFile
    );
typedef AAAA_CREATE_DUMP_FILE_FN* PAAAA_CREATE_DUMP_FILE_FN;

typedef 
VOID
(WINAPI AAAA_CLOSE_DUMP_FILE_FN)(
    HANDLE  hFile
    );
typedef AAAA_CLOSE_DUMP_FILE_FN* PAAAA_CLOSE_DUMP_FILE_FN;

typedef 
DWORD
(WINAPI AAAA_GET_OS_VERSION_FN)(
    IN  PWCHAR  pwszRouter, 
    OUT LPDWORD lpdwVersion);
typedef AAAA_GET_OS_VERSION_FN* PAAAA_GET_OS_VERSION_FN;
    
typedef 
DWORD
(WINAPI AAAA_GET_TAG_TOKEN_FN)(
    IN  HANDLE      hModule,
    IN  PWCHAR      *ppwcArguments,
    IN  DWORD       dwCurrentIndex,
    IN  DWORD       dwArgCount,
    IN  PTAG_TYPE   pttTagToken,
    IN  DWORD       dwNumTags,
    OUT PDWORD      pdwOut
    );
typedef AAAA_GET_TAG_TOKEN_FN* PAAAA_GET_TAG_TOKEN_FN;

typedef
DWORD
(WINAPI AAAA_PARSE_FN)(
    IN  PWCHAR*         ppwcArguments,
    IN  DWORD           dwCurrentIndex,
    IN  DWORD           dwArgCount,
    IN  BOOL*           pbDone,
    OUT AAAAMON_CMD_ARG* pAaaaArgs,
    IN  DWORD           dwAaaaArgCount);
typedef AAAA_PARSE_FN* PAAAA_PARSE_FN;

typedef
BOOL
(WINAPI AAAA_IS_HELP_TOKEN_FN)(
    PWCHAR  pwszToken
    );
typedef AAAA_IS_HELP_TOKEN_FN* PAAAA_IS_HELP_TOKEN_FN;

typedef 
PWCHAR
(WINAPI AAAA_ASSIGN_FROM_TOKENS_FN)(
    IN HINSTANCE hModule,
    IN PWCHAR pwszTokenTkn,
    IN PWCHAR pwszTokenCmd);
typedef AAAA_ASSIGN_FROM_TOKENS_FN* PAAAA_ASSIGN_FROM_TOKENS_FN;

//
// Defines information exported to all aaaa helpers by the 
// aaaamontr module.
//
typedef struct _AAAAMONTR_ATTRIBUTES
{
    union
    {
        ULONGLONG       _ullAlign;

        struct 
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };
    };

    // Aaaamontr functions (common utilities)
    //
    PAAAA_ALLOC_FN               pfnAlloc;
    PAAAA_FREE_FN                pfnFree;
    PAAAA_STRDUP_FN              pfnStrDup;
    PAAAA_DWORDDUP_FN            pfnDwordDup;
    PAAAA_CREATE_DUMP_FILE_FN    pfnCreateDumpFile;
    PAAAA_CLOSE_DUMP_FILE_FN     pfnCloseDumpFile;
    PAAAA_GET_OS_VERSION_FN      pfnGetOsVersion;
    PAAAA_GET_TAG_TOKEN_FN       pfnGetTagToken;
    PAAAA_PARSE_FN               pfnParse;
    PAAAA_IS_HELP_TOKEN_FN       pfnIsHelpToken;
    PAAAA_ASSIGN_FROM_TOKENS_FN  pfnAssignFromTokens;

} AAAAMONTR_ATTRIBUTES, *PAAAAMONTR_ATTRIBUTES;

#ifdef __cplusplus
}
#endif

#endif // _AAAAMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaahndl.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998  Microsoft Corporation
// 
// Module Name:
// 
//   aaaahndl.c
//
// Abstract:
//
//    Handlers for aaaa commands
//
// Revision History:
//
//    pmay
//    Thierry Perraut 04/02/1999
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "strdefs.h"
#include "rmstring.h"
#include "aaaamon.h"
#include "aaaahndl.h"
#include "aaaaconfig.h"


//////////////////////////////////////////////////////////////////////////////
// AaaaDumpScriptHeader
// 
// Routine Description:
// 
//     Dumps the header of a script to the given file or to the 
//     screen if the file is NULL.
//     
//////////////////////////////////////////////////////////////////////////////
DWORD AaaaDumpScriptHeader(IN HANDLE hFile)
{
    DisplayMessage(g_hModule, MSG_AAAA_SCRIPTHEADER);
    DisplayMessageT( DMP_AAAA_PUSHD );

    return NO_ERROR;        
}


//////////////////////////////////////////////////////////////////////////////
// AaaaDumpScriptFooter
//
// Routine Description:
// 
//     Dumps the header of a script to the given file or to the 
//     screen if the file is NULL.
//////////////////////////////////////////////////////////////////////////////
DWORD AaaaDumpScriptFooter(IN HANDLE hFile)
{
    DisplayMessageT( DMP_AAAA_POPD );
    DisplayMessage(g_hModule, MSG_AAAA_SCRIPTFOOTER);
    return NO_ERROR;        
}


//////////////////////////////////////////////////////////////////////////////
// AaaaDump
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaDump(
        IN      LPCWSTR     pwszRouter,
        IN OUT  LPWSTR     *ppwcArguments,
        IN      DWORD       dwArgCount,
        IN      LPCVOID     pvData
        )
{
    AaaaDumpScriptHeader( NULL );
    AaaaConfigDumpConfig();
    DisplayMessageT(MSG_NEWLINE);
    AaaaDumpScriptFooter( NULL );
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaamon.c ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998  Microsoft Corporation
// 
// Module Name:
// 
//     aaaamon.c
// 
// Abstract:
// 
//     Main aaaamon file.
// 
// Revision History:
// 
//     pmay
//     Thierry Perraut 04/02/1999
// 
//////////////////////////////////////////////////////////////////////////////
#define AAAA_HELPER_VERSION 1

#include <windows.h>
#include "strdefs.h"
#include "rmstring.h"
#include <netsh.h>
#include "aaaamontr.h"
#include "context.h"
#include "aaaahndl.h"
#include "aaaaconfig.h"
#include "aaaaversion.h"

GUID g_AaaamontrGuid    = AAAAMONTR_GUID;
GUID g_NetshGuid        = NETSH_ROOT_GUID;

// 
// Reminder
//
// #define CREATE_CMD_ENTRY(t,f)   {CMD_##t, f, HLP_##t, HLP_##t##_EX, CMD_FLAG_PRIVATE}
// #define CREATE_CMD_ENTRY_EX(t,f,i) {CMD_##t, f, HLP_##t, HLP_##t##_EX, i}
// #define CMD_FLAG_PRIVATE     0x01 // not valid in sub-contexts
// #define CMD_FLAG_INTERACTIVE 0x02 // not valid from outside netsh
// #define CMD_FLAG_IMMEDIATE   0x04 // not valid from ancestor contexts
// #define CMD_FLAG_LOCAL       0x08 // not valid from a remote machine
// #define CMD_FLAG_ONLINE      0x10 // not valid in offline/non-commit mode

CMD_ENTRY g_AaaaSetCmdTable[] = 
{
    CREATE_CMD_ENTRY_EX(AAAACONFIG_SET, HandleAaaaConfigSet,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),

};                   

CMD_ENTRY g_AaaaShowCmdTable[] = 
{
    CREATE_CMD_ENTRY_EX(AAAACONFIG_SHOW, HandleAaaaConfigShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
    CREATE_CMD_ENTRY_EX(AAAAVERSION_SHOW, HandleAaaaVersionShow,(CMD_FLAG_PRIVATE | CMD_FLAG_ONLINE)),
};


CMD_GROUP_ENTRY g_AaaaCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,   g_AaaaSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,  g_AaaaShowCmdTable),

};

ULONG g_ulNumGroups = sizeof(g_AaaaCmdGroups)/sizeof(CMD_GROUP_ENTRY);

HANDLE   g_hModule;
BOOL     g_bCommit;
DWORD    g_dwNumTableEntries;
DWORD                 ParentVersion;
BOOL                  g_bAaaaDirty = FALSE;
NS_CONTEXT_CONNECT_FN AaaaConnect;

ULONG   g_ulInitCount;

//////////////////////////////////////////////////////////////////////////////
// AaaaCommit
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaCommit(
            IN  DWORD   dwAction
          )
{

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

//          bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaStartHelper
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaStartHelper(
                 IN CONST GUID *pguidParent,
                 IN DWORD       dwVersion
               )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.pwszContext = L"aaaa";
    attMyAttributes.guidHelper  = g_AaaamontrGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = CMD_FLAG_LOCAL;
    attMyAttributes.ulNumTopCmds  = 0;
    attMyAttributes.pTopCmds      = NULL;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_AaaaCmdGroups;
    attMyAttributes.pfnCommitFn = AaaaCommit;
    attMyAttributes.pfnDumpFn   = AaaaDump;
    attMyAttributes.pfnConnectFn= AaaaConnect;

    dwErr = RegisterContext( &attMyAttributes );

    return      dwErr;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaUnInit
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
AaaaUnInit(
            IN  DWORD   dwReserved
          )
{
    if(InterlockedDecrement(&g_ulInitCount) != 0)
    {
        return  NO_ERROR;
    }

    return  NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaDllEntry
//////////////////////////////////////////////////////////////////////////////
BOOL 
WINAPI
AaaaDllEntry(
                HINSTANCE   hInstDll,
                DWORD       fdwReason,
                LPVOID      pReserved
            )
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;
            DisableThreadLibraryCalls(hInstDll);
            break;
        }
        case DLL_PROCESS_DETACH:
        {
            g_hModule = NULL;
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
// InitHelperDll
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
InitHelperDll(
        IN  DWORD      dwNetshVersion,
        OUT PVOID      pReserved
             )
{
    DWORD  dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    g_bCommit = TRUE;

    // Register this module as a helper to the netsh root
    // context.
    //
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_AaaamontrGuid;
    attMyAttributes.dwVersion          = AAAA_HELPER_VERSION;
    attMyAttributes.pfnStart           = AaaaStartHelper;
    attMyAttributes.pfnStop            = NULL;
    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    // Register any sub contexts implemented in this dll
    //
    dwErr = AaaaContextInstallSubContexts();
    if (dwErr != NO_ERROR)
    {
        AaaaUnInit(0);
        return  dwErr;
    }

    return  NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaConnect
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
AaaaConnect(
               IN LPCWSTR pwszRouter
           )
{
    // If context info is dirty, reregister it
    if (g_bAaaaDirty)
    {
        AaaaStartHelper(NULL, ParentVersion);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaaversion.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-1999  Microsoft Corporation
// 
// Module Name:
// 
//    aaaaVersion.h
//
// Abstract:                           
//
//
// Revision History:
//
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _AAAAVERSION_H_
#define _AAAAVERSION_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

FN_HANDLE_CMD    HandleAaaaVersionShow;

HRESULT 
AaaaVersionGetVersion(
                      LONG*   pVersion
                      );

#ifdef __cplusplus
}
#endif
#endif // _AAAAVERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\base64tool.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
// 
// Module Name:
// 
//    base64tool.cpp
//
// Abstract:                           
//
//    base64 encoding and decoding functions
//
// Revision History:
//
//    Comes from SimpleLogObj.cpp (provided as part of the Microsoft 
//    Transaction Server Software Development Kit 
//    Copyright (C) 1997 Microsoft Corporation, All rights reserved 
//
//    Thierry Perraut 04/02/1999 (many minor changes)
//    10/19/1999 Change CoTaskMemAlloc(0) into CoTaskMemAlloc(sizeof(BSTR*))
//               fix the bug 416872 (memory used after the free). This bug 
//               became visible after fixing the first one, on checked builds.
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "base64tool.h"

// These characters are the legal digits, in order, that are 
// used in Base64 encoding 
// 
namespace
{
    const WCHAR rgwchBase64[] = 
                                L"ABCDEFGHIJKLMNOPQ" 
                                L"RSTUVWXYZabcdefgh" 
                                L"ijklmnopqrstuvwxy" 
                                L"z0123456789+/"; 
}
  

//////////////////////////////////////////////////////////////////////////////
//
// Encode and return the bytes in base 64 
//
//////////////////////////////////////////////////////////////////////////////
HRESULT ToBase64(LPVOID pv, ULONG cByteLength, BSTR* pbstr) 
{ 
    if ( !pbstr )
    {
        return E_OUTOFMEMORY;
    }

    ULONG   cb         = cByteLength; 
    int     cchPerLine = 72;        
            // conservative, must be mult of 4 for us 
    int     cbPerLine  = cchPerLine / 4 * 3; 
    LONG    cbSafe     = cb + 3;                    // allow for padding 
    LONG    cLine      = cbSafe / cbPerLine + 2;    // conservative 
    LONG    cchNeeded  = cLine * (cchPerLine + 4 /*CRLF*/) + 1 /*slash NULL*/;
    LONG    cbNeeded   = cchNeeded * sizeof(WCHAR); 
    HRESULT hr         = S_OK;

    LPWSTR wsz = static_cast<LPWSTR>(CoTaskMemAlloc(cbNeeded)); 
  
    if ( !wsz ) 
    { 
        return E_OUTOFMEMORY;
    }

    BYTE*  pb   = (BYTE*)pv; 
    WCHAR* pch  = wsz ; 
    int cchLine = 0; 
    // 
    // Main encoding loop 
    // 
    while (cb >= 3) 
    { 
        BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
        BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
        BYTE b2 = ((pb[1]&0x0F)<<2) | ((pb[2]>>6) & 0x03); 
        BYTE b3 = ((pb[2]&0x3F)); 

        *pch++ = rgwchBase64[b0]; 
        *pch++ = rgwchBase64[b1]; 
        *pch++ = rgwchBase64[b2]; 
        *pch++ = rgwchBase64[b3]; 

        pb += 3; 
        cb -= 3; 
         
        // put in line breaks 
        cchLine += 4; 
        if (cchLine >= cchPerLine) 
        { 
            *pch++ = L'\\'; 
            *pch++ = L'\r'; 
            cchLine = 0; 
        } 
    } 
    // 
    // Account for gunk at the end 
    // 
    *pch++ = L'\\'; 
    *pch++ = L'\r';     // easier than keeping track 
    if (cb==0) 
    { 
        // nothing to do 
    } 
    else if (cb==1) 
    { 
        BYTE b0     = ((pb[0]>>2) & 0x3F); 
        BYTE b1     = ((pb[0]&0x03)<<4) | 0; 
        *pch++      = rgwchBase64[b0]; 
        *pch++      = rgwchBase64[b1]; 
    } 
    else if (cb==2) 
    { 
        BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
        BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
        BYTE b2 = ((pb[1]&0x0F)<<2) | 0; 
        *pch++  = rgwchBase64[b0]; 
        *pch++  = rgwchBase64[b1]; 
        *pch++  = rgwchBase64[b2]; 
    }
    else
    {
        // should never go there
    }
     
    // 
    // NULL terminate the string 
    // 
    *pch++ = L'\\'; 
    *pch++ = L'\r';     // easier than keeping track 
    *pch++ = NULL; 

    // 
    // Allocate our final output 
    // 

    *pbstr = SysAllocString(wsz); 
    if ( !*pbstr )
    {
        return E_OUTOFMEMORY;
    }

    CoTaskMemFree(wsz); 
    wsz = NULL;

    #ifdef _DEBUG 
    if (hr==S_OK) 
    { 
        BLOB b; 
        FromBase64(*pbstr, &b); 
        _ASSERTE(b.cbSize == cByteLength); 
        _ASSERTE(memcmp(b.pBlobData, pv, cByteLength) == 0); 
        CoTaskMemFree(b.pBlobData); 
    } 
    #endif 
 
    return hr; 
} 
 
 
 
//////////////////////////////////////////////////////////////////////////////
// 
// Decode and return the Base64 encoded bytes 
// 
// Allocates the memory for the blob.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT FromBase64(BSTR bstr, BLOB* pblob, int Index) 
{ 
    ASSERT(Index >= 0);
    ASSERT(pblob);

    if (bstr == NULL)
    {
#ifdef DEBUG
        wprintf(L"FromBase64 (bstr == NULL)\n");
#endif //DEBUG
        return      E_FAIL;
    }

    HRESULT     hr  = S_OK; 
    ULONG       cbNeeded = wcslen(bstr); // an upper bound 
    BYTE*       rgb = static_cast<BYTE*>(CoTaskMemAlloc(cbNeeded)); 
    if ( !rgb )
    {
        return E_OUTOFMEMORY;
    }

    memset(rgb, 0, cbNeeded);

    BYTE    mpwchb[256]; 
    BYTE    bBad = (BYTE)-1; 

    // 
    // Initialize our decoding array 
    // 
    memset(&mpwchb[0], bBad, 256); 
    for ( BYTE i = 0; i < 64; ++i ) 
    { 
        WCHAR wch = rgwchBase64[i]; 
        mpwchb[wch] = i; 
    } 

    // 
    // Loop over the entire input buffer 
    // 
    // what we're in the process of filling up 
    ULONG   bCurrent   = 0;        
    // how many bits in it we've filled
    int     cbitFilled = 0;         
    // current destination (not filled)
    BYTE*   pb         = rgb;              
    
    // SysStringLen doesn't include the termination NULL character
    LONG    LoopCounter = static_cast<LONG>(SysStringLen(bstr) + 1);  
    for ( WCHAR* pwch = bstr; *pwch; ++pwch ) 
    { 
        WCHAR wch = *pwch; 
        // 
        // Ignore white space 
        // 
        if ( wch==0x0A || wch==0x0D || wch==0x20 || wch==0x09 ) 
        {
            continue; 
        }

        if ( Index > 0 )
        {
            LoopCounter--;
            ////////////////////////////////////////////
            // At least one section needs to be skipped
            ////////////////////////////////////////////

            if ( wch != L'*' ) 
            {
                //////////////////////////////////
                // Not the end of the section yet
                //////////////////////////////////
                continue; 
            }
            else
            {
                ///////////////////////////////
                // End of section marker found
                // decrease index and loop
                ///////////////////////////////
                Index --;
                continue;
            }
        }
        else  if ( wch == L'*' ) 
        {
            ////////////////////////////////
            // End of the section to decode 
            ////////////////////////////////
            break; 
        }

        // 
        // Have we reached the end? 
        // 
        if ( LoopCounter-- <= 0 )
        {
            break;
        }


        // 
        // How much is this character worth? 
        // 
        BYTE    bDigit = mpwchb[wch]; 

        if ( bDigit == bBad ) 
        { 
            hr = E_INVALIDARG; 
            break; 
        } 

        // 
        // Add in its contribution 
        // 
        bCurrent        <<= 6; 
        bCurrent        |= bDigit; 
        cbitFilled      += 6; 
        // 
        // If we've got enough, output a byte 
        // 
        if ( cbitFilled >= 8 ) 
        { 
            // get's top eight valid bits 
            ULONG       b   = (bCurrent >> (cbitFilled-8));
            *pb++           = (BYTE)(b&0xFF);// store the byte away 
            cbitFilled      -= 8; 
        } 
    } 

    if ( hr == S_OK ) 
    { 
        pblob->pBlobData    = rgb; 
        pblob->cbSize       = (ULONG) (pb - rgb); 
    } 
    else 
    { 
        CoTaskMemFree(rgb); 
        pblob->pBlobData    = NULL; 
    } 

    return      hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\aaaaversion.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998-1999  Microsoft Corporation
// 
// Module Name:
// 
//    aaaaVersion.cpp
//
// Abstract:                           
//
//    Handlers for aaaa version command
//
// Revision History:
//
//    pmay
//    tperraut 04/02/1999
//    tperraut 04/17/2000  Use the Jet wrapper from iasrecst.dll
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include "strdefs.h"
#include "aaaamon.h"
#include "aaaaversion.h"

const int   SIZE_MAX_STRING = 512; 

//////////////////////////////////////////////////////////////////////////////
// AaaaVersionGetVersion
//////////////////////////////////////////////////////////////////////////////
HRESULT AaaaVersionGetVersion(LONG*   pVersion)
{
    const WCHAR c_wcSELECT_VERSION[] = L"SELECT * FROM Version";
    const WCHAR c_wcIASMDBFileName[] = L"%SystemRoot%\\System32\\ias\\ias.mdb";
    if ( !pVersion )
    {
        return ERROR;
    }

    bool bCoInitialized = false;
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if ( FAILED(hr) )
    {
        if ( hr == RPC_E_CHANGED_MODE )
        {
            hr = S_OK;
        }
        else
        {
            *pVersion = 0;
            return hr;
        }
    }
    else
    {
        bCoInitialized = true;
    }

    WCHAR   wc_TempString[SIZE_MAX_STRING];
    // put the path to the DB in the property.  
    BOOL bResult = ExpandEnvironmentStringsForUserW(
                                               NULL,
                                               c_wcIASMDBFileName,
                                               wc_TempString,
                                               SIZE_MAX_STRING
                                               );


    do
    {
        if ( bResult )
        {
            CComPtr<IIASNetshJetHelper>     JetHelper;
            hr = CoCreateInstance(
                                     __uuidof(CIASNetshJetHelper),
                                     NULL,
                                     CLSCTX_SERVER,
                                     __uuidof(IIASNetshJetHelper),
                                     (PVOID*) &JetHelper
                                 );
            if ( FAILED(hr) )
            {
                break;
            }

            CComBSTR     DBPath(wc_TempString);
            if ( !DBPath ) 
            {
                hr = E_OUTOFMEMORY; 
                break;
            } 

            hr = JetHelper->OpenJetDatabase(DBPath, FALSE);
            if ( FAILED(hr) )
            {
                WCHAR sDisplayString[SIZE_MAX_STRING];
                DisplayError(NULL, EMSG_OPEN_DB_FAILED);
                break;
            }

            CComBSTR     SelectVersion(c_wcSELECT_VERSION);
            if ( !SelectVersion ) 
            { 
                hr = E_OUTOFMEMORY; 
                break;
            } 

            hr = JetHelper->ExecuteSQLFunction(
                                                  SelectVersion, 
                                                  pVersion
                                              );
            if ( FAILED(hr) ) // no Misc Table for instance
            {
                *pVersion = 0; //default value.
                hr = S_OK; // that's not an error 
            }
            hr = JetHelper->CloseJetDatabase();
        }
        else
        {
            DisplayMessage(g_hModule, MSG_AAAAVERSION_GET_FAIL);   
            hr = E_FAIL;
            break;
        }
    } while(false);

    if (bCoInitialized)
    {
        CoUninitialize();
    }
    return      hr;
}

  
//////////////////////////////////////////////////////////////////////////////
// AaaaVersionParseCommandLine
//
// Parses the AaaaVersion from the command line
//////////////////////////////////////////////////////////////////////////////
DWORD
AaaaVersionParseCommandLine(
                            IN  PWCHAR*     ppwcArguments,
                            IN  DWORD       dwCurrentIndex,
                            IN  DWORD       dwArgCount
                           )
{
    return  NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// AaaaVersionProcessCommand
//
// Processes a  command by parsing the command line
// and calling the appropriate callback
//////////////////////////////////////////////////////////////////////////////
DWORD 
AaaaVersionProcessCommand(
                            IN  PWCHAR*     ppwcArguments,
                            IN  DWORD       dwCurrentIndex,
                            IN  DWORD       dwArgCount,
                            IN  BOOL*       pbDone,
                            IN  HANDLE      hData
                         )
{
    DWORD dwErr = NO_ERROR;
    if (dwCurrentIndex != dwArgCount)
    {
        // some arguments are present on the command line and will be ignored
        DisplayMessage(g_hModule, MSG_AAAAVERSION_SHOW_FAIL);   
    }
    else
    {
        LONG            lVersion;

        HRESULT     hr = AaaaVersionGetVersion(&lVersion);
        if (!FAILED(hr))
        {
            WCHAR sDisplayString[SIZE_MAX_STRING];
            _snwprintf(
                        sDisplayString, 
                        SIZE_MAX_STRING,
                        L"Version = %d\n",
                        lVersion
                      ); 
            DisplayMessageT(sDisplayString);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_AAAAVERSION_GET_FAIL);   
            dwErr = ERROR;
        }
    }
    return      dwErr;
}


//////////////////////////////////////////////////////////////////////////////
// HandleAaaaVersionShow
//
// Shows whether HandleAaaaVersionSet has been called on the
// given domain.
//////////////////////////////////////////////////////////////////////////////
DWORD
HandleAaaaVersionShow(
                    IN      LPCWSTR   pwszMachine,
                    IN OUT  LPWSTR   *ppwcArguments,
                    IN      DWORD     dwCurrentIndex,
                    IN      DWORD     dwArgCount,
                    IN      DWORD     dwFlags,
                    IN      LPCVOID   pvData,
                    OUT     BOOL     *pbDone
                    )
{
    return AaaaVersionProcessCommand(
                                        ppwcArguments,
                                        dwCurrentIndex,
                                        dwArgCount,
                                        pbDone,
                                        NULL
                                    );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\context.h ===
//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    File:   context.h
//
// Abstract:
//
//    Definitions for mechanisms to process contexts relevant to 
//    aaaamontr.
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _CONTEXT_H_
#define _CONTEXT_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

DWORD 
AaaaContextInstallSubContexts(
    );

#ifdef __cplusplus
}
#endif
#endif //_CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\context.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
//
//    File:   context.c
//
//    Abstract: 
//
//      Mechanisms to process contexts relevant to aaaamontr.
//
//    Revision:
//
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "context.h"

//////////////////////////////////////////////////////////////////////////////
//
// Installs all of the sub contexts provided
// in this .dll (for example, "aaaa ip", "aaaa client", etc.)
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
AaaaContextInstallSubContexts()
{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\base64tool.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    base64tool.h
//
// Abstract:
//
//      Header for the base64 encoding and decoding functions
//
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _BASE64TOOL_H_
#define _BASE64TOOL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


HRESULT ToBase64(LPVOID pv, ULONG cByteLength, BSTR* pbstr);
HRESULT FromBase64(BSTR bstr, BLOB* pblob, int Index); 


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\iasmdbtool.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    iasmdbtool.h
//
// Abstract:
//      Header for the base64 encoding and decoding functions
//
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _IASMDBTOOL_H_
#define _IASMDBTOOL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

HRESULT IASDumpConfig(/*inout*/ WCHAR **ppDumpString, /*inout*/ ULONG *ulSize);
HRESULT IASRestoreConfig(/*int*/ const WCHAR *pRestoreString);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\iasmdbtool.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999-2000  Microsoft Corporation
//
// Module Name:
//
//    iasmdbtool.cpp
//
// Abstract:
//
//    dump the "Properties" table from ias.mdb to a text format
//              and also restore ias.mdb from such dump
//
//
// Revision History:
//  
//    tperraut 04/07/1999
//    tperraut 04/03/2000 Version table exported and imported.
//                        Set to 0 for old scripts (no version table)
//    tperraut 06/13/2000 Make use of the new upgrade code for IAS. i.e. 
//                        remove all the code to write into a database.
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <string>
#include <shlwapi.h>

using namespace std;

//////////////////////////////////////////////////////////////////////////////
HRESULT 
IASExpandString(const WCHAR* pInputString, /*in/out*/ WCHAR** ppOutputString);
//////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
    #define CHECK_CALL_HRES(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            wprintf(L"### %S returned 0x%X ###\n",  ## #expr, hres); \
            return hres; \
        }                       

    #define CHECK_CALL_HRES_NO_RETURN(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            wprintf(L"### %S returned 0x%X  ###\n",  ## #expr, hres); \
        }                       
    #define CHECK_CALL_HRES_BREAK(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            wprintf(L"### %S returned 0x%X  ###\n",  ## #expr, hres); \
            break; \
        }                       
#else //no printf, only the error code return if needed
    #define CHECK_CALL_HRES(expr) \
        hres = expr;      \
        if (FAILED(hres)) \
        {       \
            return hres; \
        }                       

    #define CHECK_CALL_HRES_NO_RETURN(expr) \
        hres = expr;      

    #define CHECK_CALL_HRES_BREAK(expr) \
        hres = expr;      \
        if (FAILED(hres)) break;                       

#endif //DEBUG


#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))

namespace
{
    const int   SIZELINEMAX                         = 512;
    const int   SIZE_LONG_MAX                       = 33;
    // Number of files generated
    // here one: backup.mdb
    const int   MAX_FILES                           = 1; 
    const int   EXTRA_CHAR_SPACE                    = 32;

    // file order
    const int   BACKUP_NB                           = 0;
    const int   BINARY_NB                           = 100;

    // that's a lot
    const int   DECOMPRESS_FACTOR                   = 100;
    const int   FILE_BUFFER_SIZE                    = 1024;
    
    struct IASKEY
    {
        const WCHAR*    c_wcKey;
        const WCHAR*    c_wcValue;
        DWORD     c_dwType;
    } IAS_Key_Struct;

    IASKEY    c_wcKEYS[] = 
    {
        {
            L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
            L"Allow SNMP Set",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RasMan\\PPP\\ControlProtocols\\BuiltIn",
            L"DefaultDomain",
            REG_SZ
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\AccountLockout",
            L"MaxDenials",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
            L"ResetTime (mins)",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Policy",
            L"Allow LM Authentication",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
            L"Default User Identity",
            REG_SZ
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
            L"User Identity Attribute",
            REG_DWORD
        },
        {
            L"SYSTEM\\CurrentControlSet\\Services\\IAS\\Parameters",
            L"Override User-Name",
            REG_DWORD
        },
    };

    const WCHAR c_wcKEYS_FILE[]     = L"%TEMP%\\";

#ifdef _WIN64
    const WCHAR c_wcIAS_MDB_FILE_NAME[] = 
                                     L"%SystemRoot%\\SysWow64\\ias\\ias.mdb";
    const WCHAR c_wcIAS_OLD[] = L"%SystemRoot%\\SysWow64\\ias\\iasold.mdb";

#else
    const WCHAR c_wcIAS_MDB_FILE_NAME[] = 
                                     L"%SystemRoot%\\System32\\ias\\ias.mdb";

    const WCHAR c_wcIAS_OLD[] = L"%SystemRoot%\\System32\\ias\\iasold.mdb";
#endif 

    const WCHAR c_wcFILE_BACKUP[] = L"%TEMP%\\Backup.mdb";
            
    

    const WCHAR c_wcSELECT_PROPERTIES_INTO[] = 
                                    L"SELECT * " 
                                    L"INTO Properties IN "
                                    L"\"%TEMP%\\Backup.mdb\" "
                                    L"FROM Properties;";

    const WCHAR c_wcSELECT_OBJECTS_INTO[] = 
                                    L"SELECT * " 
                                    L"INTO Objects IN "
                                    L"\"%TEMP%\\Backup.mdb\" "
                                    L"FROM Objects;";

    const WCHAR c_wcSELECT_VERSION_INTO[] = 
                                    L"SELECT * " 
                                    L"INTO Version IN "
                                    L"\"%TEMP%\\Backup.mdb\" "
                                    L"FROM Version;";
}


//////////////////////////////////////////////////////////////////////////////
//
// WideToAnsi 
// 
//  CALLED BY:everywhere 
// 
//  PARAMETERS: lpStr - destination string 
//  lpWStr - string to convert 
//  cchStr - size of dest buffer 
// 
//  DESCRIPTION: 
//  converts unicode lpWStr to ansi lpStr. 
//  fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-" 
// 
// 
//  RETURNS:  if cchStr is 0, returns the size required to hold the string 
//  otherwise, returns the number of chars converted 
//
//////////////////////////////////////////////////////////////////////////////
int WideToAnsi(char* lpStr,unsigned short* lpWStr, int cchStr) 
{ 
    BOOL        bDefault; 
 
    // use the default code page (CP_ACP) 
    // -1 indicates WStr must be null terminated 
    return WideCharToMultiByte(GetConsoleOutputCP(),0,lpWStr,-1,lpStr,cchStr,"-",&bDefault); 
} 


/////////////////////////////////////////////////////////////////////////////
//
// IASEnableBackupPrivilege
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASEnableBackupPrivilege()
{
    LONG                lResult = ERROR_SUCCESS;
    HANDLE              hToken  = NULL;
    do
    {
        if ( ! OpenProcessToken(
                                GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES,
                                &hToken
                                ))
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        LUID                luidB;
        if ( ! LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &luidB))
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        LUID                luidR;
        if ( ! LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &luidR))
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        TOKEN_PRIVILEGES            tp;
        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luidB;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( ! AdjustTokenPrivileges(
                                        hToken, 
                                        FALSE, 
                                        &tp, 
                                        sizeof(TOKEN_PRIVILEGES),
                                        NULL, 
                                        NULL 
                                        ) )
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luidR;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if ( ! AdjustTokenPrivileges(
                                        hToken, 
                                        FALSE, 
                                        &tp, 
                                        sizeof(TOKEN_PRIVILEGES),
                                        NULL, 
                                        NULL 
                                        ) )
        {
            lResult = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    } while (false);

    if ( hToken )
    {
        CloseHandle(hToken);
    }

    if ( lResult == ERROR_SUCCESS )
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// IASSaveRegKeys
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASSaveRegKeys()
{
    HRESULT     hres;
    
    int         c_NbKeys = celems(c_wcKEYS);
    
    if ( c_NbKeys == 0 )
    {
        hres = S_OK;
    }
    else
    {
        ////////////////////////////
        // Enable backup privilege. 
        ////////////////////////////
        CHECK_CALL_HRES (IASEnableBackupPrivilege());

        
        WCHAR*      CompleteFile;
        CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE, &CompleteFile));

        for ( int i = 0; i < c_NbKeys; ++i )
        {
            DWORD  dwType = 0;
            DWORD  cbData = SIZELINEMAX / 2;

            LPVOID   pvData = CoTaskMemAlloc(sizeof(WCHAR) * SIZELINEMAX);
            if (!pvData)
            {
                hres = E_OUTOFMEMORY;
                break;
            }

            DWORD lResult = SHGetValueW(
                                        HKEY_LOCAL_MACHINE,
                                        c_wcKEYS[i].c_wcKey,
                                        c_wcKEYS[i].c_wcValue,
                                        &dwType,
                                        pvData,
                                        &cbData
                                      );

            //
            // Try to allocate more memory if cbData returned the size needed
            //
            if ((lResult != ERROR_SUCCESS) && (cbData > SIZELINEMAX))
            {
                CoTaskMemFree(pvData);
                pvData = CoTaskMemAlloc(sizeof(WCHAR) * cbData);
                if ( !pvData )
                {
                    return E_OUTOFMEMORY;
                }
                lResult = SHGetValue(
                                        HKEY_LOCAL_MACHINE,
                                        c_wcKEYS[i].c_wcKey,
                                        c_wcKEYS[i].c_wcValue,
                                        &dwType,
                                        pvData,
                                        &cbData
                                      );
                if ( lResult  != ERROR_SUCCESS )
                {
                    hres = E_OUTOFMEMORY;
                    break;
                }
            }

            //
            // Create the file (in all situations)
            //
            wstring         sFileName(CompleteFile);
            WCHAR           buffer[SIZE_LONG_MAX];

            _itow(i, buffer, 10); // 10 means base 10
            sFileName += buffer;
            sFileName += L".txt";

            HANDLE hFile = CreateFileW(
                                        sFileName.c_str(),
                                        GENERIC_WRITE,       
                                        0,           
                                        NULL,
                                        CREATE_ALWAYS,  
                                        FILE_ATTRIBUTE_NORMAL,   
                                        NULL
                                      );
        

            if ( hFile == INVALID_HANDLE_VALUE )
            {
                hres = E_FAIL;
                CoTaskMemFree(pvData);
                break;
            }
            
            //
            // lResult = result of SHGetValue            
            // and might be an error but not 
            // a memory problem
            //
            if ( lResult == ERROR_SUCCESS )
            {
                //
                // Wrong data type
                //
                if ( dwType != c_wcKEYS[i].c_dwType )   
                {
                    // There's an error, fail
    #ifdef DEBUG // DEBUG
                    wprintf(L"#SHGetValue ok but wrong type returned . code %X"
                            L" param %s%s\n",
                                dwType,
                                c_wcKEYS[i].c_wcKey,
                                c_wcKEYS[i].c_wcValue
                            );
    #endif //DEBUG
                    hres = E_FAIL;
                    CoTaskMemFree(pvData);
                    CloseHandle(hFile);
                    break;
                }
                else
                {
                    //
                    // Save the value to the file
                    //
                    BYTE*   bBuffer = static_cast<BYTE*>(VirtualAlloc
                                                (
                                                  NULL,
                                                  (cbData > FILE_BUFFER_SIZE)? 
                                                       cbData:FILE_BUFFER_SIZE,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE
                                                ));
    #ifdef DEBUG //DEBUG
                        wprintf(L"#cbdata = %d \n",cbData);
    #endif //DEBUG
                    if ( !bBuffer )
                    {
    #ifdef DEBUG // DEBUG
                        wprintf(L"#VirtualAlloc failed");
    #endif //DEBUG
                        CoTaskMemFree(pvData);
                        CloseHandle(hFile);
                        hres = E_FAIL;
                        break;
                    }
                        
                    memset(bBuffer, '\0', (cbData > FILE_BUFFER_SIZE)? 
                                                cbData:FILE_BUFFER_SIZE);

                    if ( REG_SZ == c_wcKEYS[i].c_dwType )
                    {
                        wcscpy((WCHAR*)bBuffer, (WCHAR*)pvData);
                    }
                    else
                    {
                        memcpy(bBuffer, pvData, cbData);
                    }

                    CoTaskMemFree(pvData);

                    DWORD       NumberOfBytesWritten;

                    BOOL bResult = WriteFile(
                                              hFile,
                                              bBuffer,
                                              (cbData > FILE_BUFFER_SIZE)?
                                                     cbData:FILE_BUFFER_SIZE,
                                              &NumberOfBytesWritten,
                                              NULL
                                            );

                    VirtualFree(
                                    bBuffer,  
                                    (cbData > FILE_BUFFER_SIZE)?
                                         cbData:FILE_BUFFER_SIZE,
                                    MEM_RELEASE
                               ); // ignore result
                    CloseHandle(hFile);
                    if ( bResult )
                    {
    #ifdef DEBUG // DEBUG
                        wprintf(L"#nb of bytes written %d\n"
                            ,NumberOfBytesWritten);
    #endif //DEBUG
                        hres = S_OK;
                    }
                    else
                    {
    #ifdef DEBUG // DEBUG
                        wprintf(L"#WriteFile failed %X\n",GetLastError());
    #endif //DEBUG
                        hres = E_FAIL;
                        break;
                    }

                }
            }
            else 
            {
                //
                // create an empty file
#ifdef DEBUG // DEBUG
                wprintf(L"#REG_SZ = %d, REG_DWORD = %d\n",REG_SZ, REG_DWORD);

                wprintf(L"#SHGetValue failed code %X"
                        L" param %s\\%s\n"
                        L"# type = %d cbdata = %d\n",
                            lResult,
                            c_wcKEYS[i].c_wcKey,
                            c_wcKEYS[i].c_wcValue,
                            dwType,
                            cbData
                        );
                wprintf(L"#create an empty file\n\n");
#endif //DEBUG
                BYTE            bBuffer[FILE_BUFFER_SIZE];
                memset(bBuffer, '#', (cbData > FILE_BUFFER_SIZE)? 
                                                    cbData:FILE_BUFFER_SIZE);

                DWORD           NumberOfBytesWritten;

                BOOL bResult = WriteFile(
                                          hFile,
                                          &bBuffer,
                                          FILE_BUFFER_SIZE,
                                          &NumberOfBytesWritten,
                                          NULL
                                        );

                CoTaskMemFree(pvData);
                CloseHandle(hFile);

                if ( bResult )
                {
    #ifdef DEBUG // DEBUG
                    wprintf(L"#nb of bytes written %d\n"
                        ,NumberOfBytesWritten);
    #endif //DEBUG
                    hres = S_OK;
                }
                else
                {
    #ifdef DEBUG // DEBUG
                    wprintf(L"#WriteFile failed\n");
    #endif //DEBUG
                    hres = E_FAIL;
                    break;
                }

            }
        }
        ////////////
        // Clean
        ////////////
        CoTaskMemFree(CompleteFile);
    }    

    return      hres;
}


//////////////////////////////////////////////////////////////////////////////
//
// IASRestoreRegKeys
//
// if something cannot be restored because of an empty 
// backup file (no key saved), that's not an error
//
//////////////////////////////////////////////////////////////////////////////
HRESULT IASRestoreRegKeys()
{
    HRESULT     hres;
    int         c_NbKeys = celems(c_wcKEYS);
    
    if ( c_NbKeys == 0 )
    {
        hres = S_OK;
    }
    else
    {
        ////////////////////////////
        // Enable backup privilege. 
        // and sets hres
        ////////////////////////////
        CHECK_CALL_HRES (IASEnableBackupPrivilege());

        WCHAR*      CompleteFile;
        CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE, &CompleteFile));

        for ( int i = 0; i < c_NbKeys; ++i )
        {
            wstring         sFileName(CompleteFile);
            WCHAR           buffer[SIZE_LONG_MAX];
            DWORD           dwDisposition;

            _itow(i, buffer, 10); // 10 means base 10
            sFileName += buffer;
            sFileName += L".txt";

            // open the file
            HANDLE hFile = CreateFileW(
                                        sFileName.c_str(),
                                        GENERIC_READ,       
                                        0,           
                                        NULL,
                                        OPEN_EXISTING,  
                                        FILE_ATTRIBUTE_NORMAL,   
                                        NULL
                                      );
        

            if (INVALID_HANDLE_VALUE == hFile)
            {
                hres = E_FAIL;
                break;
            }

            // check the type of data expected
            LPVOID  lpBuffer = NULL;
            DWORD   SizeToRead; 
            if (REG_SZ == c_wcKEYS[i].c_dwType)
            {
                lpBuffer = CoTaskMemAlloc(sizeof(WCHAR) * FILE_BUFFER_SIZE);
                SizeToRead = FILE_BUFFER_SIZE;
            }
            else if (REG_DWORD == c_wcKEYS[i].c_dwType)
            {
                lpBuffer = CoTaskMemAlloc(sizeof(DWORD));
                SizeToRead = sizeof(DWORD);
            }
            else
            {
                // unknown
                ASSERT(FALSE);
            }

            if (!lpBuffer)
            {
                CloseHandle(hFile);
                hres = E_OUTOFMEMORY;
                break;
            }

            memset(lpBuffer,'\0',SizeToRead);

            // read the file
            DWORD     NumberOfBytesRead;
            ReadFile(
                        hFile,
                        lpBuffer,
                        SizeToRead, 
                        &NumberOfBytesRead,
                        NULL
                     ); // ignore return value. uses NumberOfBytesRead 
                        // to determine success condition
  
            CloseHandle(hFile);

            // check if the file contains ####
            if ( NumberOfBytesRead == 0 )
            {
                // problem
    #ifdef DEBUG // DEBUG
                wprintf(L"#ReadFile failed %d %d\n", 
                                                    SizeToRead,
                                                    NumberOfBytesRead
                                                    );
    #endif //DEBUG
                
                CoTaskMemFree(lpBuffer);
                hres = E_FAIL;
                break;
            }
            else
            {
                BYTE TempBuffer[sizeof(DWORD)];
                memset(TempBuffer, '#', sizeof(DWORD));
                
                if (0 == memcmp(lpBuffer, TempBuffer, sizeof(DWORD)))
                {
                    // no key saved, delete existing key if any
    #ifdef DEBUG // DEBUG
                    wprintf(L"#no key saved, delete existing key if any\n");
    #endif //DEBUG
                    HKEY hKeyToDelete = NULL;
                    if (ERROR_SUCCESS == RegOpenKeyW(
                                                      HKEY_LOCAL_MACHINE,
                                                      c_wcKEYS[i].c_wcKey, 
                                                      &hKeyToDelete
                                                   ))
                    {
                        if (ERROR_SUCCESS != RegDeleteValueW
                                                    (
                                                      hKeyToDelete,
                                                      c_wcKEYS[i].c_wcValue   
                                                    ))
                        {
            #ifdef DEBUG // DEBUG
                            wprintf(L"#delete existing key failed\n");
            #endif //DEBUG
                        }
                        RegCloseKey(hKeyToDelete);
                    }
                    // 
                    // else do nothing: key doesn't exist
                    //
                }
                else
                {
                    // key saved: restore value
                    // what if the value is bigger than
                    // the buffer size?

    #ifdef DEBUG // DEBUG
                    wprintf(L"#key saved: restore value\n");
    #endif //DEBUG
                    HKEY        hKeyToUpdate;
                

                    LONG lResult = RegCreateKeyExW(
                                                   HKEY_LOCAL_MACHINE,
                                                   c_wcKEYS[i].c_wcKey,
                                                   0, 
                                                   NULL,
                                                   REG_OPTION_NON_VOLATILE |
                                                   REG_OPTION_BACKUP_RESTORE ,
                                                   KEY_ALL_ACCESS,
                                                   NULL,
                                                   &hKeyToUpdate,        
                                                   &dwDisposition
                                                  );

                    if (ERROR_SUCCESS != lResult)
                    {
                        lResult = RegCreateKeyW(
                                                  HKEY_LOCAL_MACHINE,
                                                  c_wcKEYS[i].c_wcKey,
                                                  &hKeyToUpdate        
                                               );
                        if (ERROR_SUCCESS != lResult)
                        {
            #ifdef DEBUG
                            // DEBUG
                            wprintf(L"#RegCreateKeyW failed. code %x param %s\n",
                                        lResult,
                                        sFileName.c_str()
                                    );
            #endif //DEBUG
                            RegCloseKey(hKeyToUpdate);
                            hres = E_FAIL;
                            break;
                        }
                    }


                    if (REG_SZ == c_wcKEYS[i].c_dwType)
                    {
                        // nb of 
                        NumberOfBytesRead = (
                                                ( wcslen((WCHAR*)lpBuffer)
                                                  + 1               // for /0
                                                ) * sizeof(WCHAR)
                                            );
                    };

                    //
                    // Key created or key existing 
                    // both can be here (error = break)
                    //
                    if (ERROR_SUCCESS != RegSetValueExW(
                                                         hKeyToUpdate,           
                                                         c_wcKEYS[i].c_wcValue,
                                                         0,
                                                         c_wcKEYS[i].c_dwType,
                                                         (BYTE*)lpBuffer,
                                                         NumberOfBytesRead
                                                       ))
                    {
                        RegCloseKey(hKeyToUpdate);
                        hres = E_FAIL;
                        break;
                    }

                    RegCloseKey(hKeyToUpdate);
                    hres = S_OK;
                }

                CoTaskMemFree(lpBuffer);
            }
        }

        /////////
        // Clean
        /////////
        CoTaskMemFree(CompleteFile);
    }    

    return      hres;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASExpandString
//
// Expands strings containing %ENV_VARIABLE% 
//
// The output string is allocated only when the function succeed
/////////////////////////////////////////////////////////////////////////////
HRESULT 
IASExpandString(const WCHAR* pInputString, /*in/out*/ WCHAR** ppOutputString)
{
    _ASSERTE(pInputString);
    _ASSERTE(pppOutputString);
    
    HRESULT hres;

    *ppOutputString = static_cast<WCHAR*>(CoTaskMemAlloc(
                                                            SIZELINEMAX
                                                            * sizeof(WCHAR)
                                                        ));
    
    if ( ! *ppOutputString )
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        if ( ExpandEnvironmentStringsForUserW(
                                                 NULL,
                                                 pInputString,
                                                 *ppOutputString,
                                                 SIZELINEMAX
                                             )
           )

        {
            hres = S_OK;            
        }
        else
        {
            CoTaskMemFree(*ppOutputString);
            hres = E_FAIL;
        }
    }
#ifdef DEBUG // DEBUG
    wprintf(L"#ExpandString: %s\n", *ppOutputString);
#endif //DEBUG

    return      hres;
};


/////////////////////////////////////////////////////////////////////////////
//
// DeleteTemporaryFiles()
//
// delete the temporary files if any
//
/////////////////////////////////////////////////////////////////////////////
HRESULT DeleteTemporaryFiles()
{
    HRESULT         hres;
    WCHAR*          sz_FileBackup;

    CHECK_CALL_HRES (IASExpandString(c_wcFILE_BACKUP,
                                    &sz_FileBackup
                                   )
                    );
     
    DeleteFile(sz_FileBackup); //return value not checked
    CoTaskMemFree(sz_FileBackup);

    WCHAR*      TempPath;
    
    CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE, &TempPath));

    int     c_NbKeys = celems(c_wcKEYS);
    for ( int i = 0; i < c_NbKeys; ++i )
    {
        wstring         sFileName(TempPath);
        WCHAR           buffer[SIZE_LONG_MAX];
        _itow(i, buffer, 10); // 10 means base 10
        sFileName += buffer;
        sFileName += L".txt";
    
        DeleteFile(sFileName.c_str()); //return value not checked
    }
   
    CoTaskMemFree(TempPath);

    return      hres;
}        


/////////////////////////////////////////////////////////////////////////////
//
// IASCompress
//
// Wrapper for RtlCompressBuffer
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASCompress(
                   PUCHAR pInputBuffer, 
                   ULONG*  pulFileSize,
                   PUCHAR* ppCompressedBuffer
                  )
{
    ULONG       size, ignore;

    NTSTATUS status = RtlGetCompressionWorkSpaceSize(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                &size,
                &ignore
                );


    if (!NT_SUCCESS(status))
    {
    #ifdef DEBUG
        printf("RtlGetCompressionWorkSpaceSize returned 0x%08X.\n", status);
    #endif //DEBUG
        return E_FAIL;
    }

    PVOID workSpace;
    workSpace = RtlAllocateHeap(
                                   RtlProcessHeap(),
                                   0,
                                   size
                               );
    if ( !workSpace )
    {
        return E_OUTOFMEMORY;
    }

    size = *pulFileSize;

    // That's a minimum buffer size that can be used
    if ( size < FILE_BUFFER_SIZE )
    {
        size = FILE_BUFFER_SIZE;
    }

    *ppCompressedBuffer = static_cast<PUCHAR>(RtlAllocateHeap(
                                                              RtlProcessHeap(),
                                                              0,
                                                              size
                                                            ));

    if ( !*ppCompressedBuffer )
    {
        return E_OUTOFMEMORY;
    }

    status = RtlCompressBuffer(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                pInputBuffer,
                size,
                *ppCompressedBuffer,
                size,
                0,
                &size,
                workSpace
                );

    if (!NT_SUCCESS(status))
    {
        if (STATUS_BUFFER_TOO_SMALL == status)
        {
#ifdef DEBUG
            printf("STATUS_BUFFER_TOO_SMALL\n");
            printf("RtlCompressBuffer returned 0x%08X.\n", status);
#endif //DEBUG
        }
        else
        {
#ifdef DEBUG
            printf("RtlCompressBuffer returned 0x%08X.\n", status);
#endif //DEBUG
        }
        return E_FAIL;
    }

    *pulFileSize = size;

    RtlFreeHeap(
                   RtlProcessHeap(),
                   0,
                   workSpace
               );

    return  S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASUnCompress
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASUnCompress(
                   PUCHAR pInputBuffer, 
                   ULONG*  pulFileSize,
                   PUCHAR* ppDeCompressedBuffer
                  )
{
    ULONG size, ignore;

    NTSTATUS status = RtlGetCompressionWorkSpaceSize(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                &size,
                &ignore
                );


   if ( !NT_SUCCESS(status) )
   {
#ifdef DEBUG
      printf("RtlGetCompressionWorkSpaceSize returned 0x%08X.\n", status);
#endif //DEBUG
      return        E_FAIL;
   }

   size = *pulFileSize;

   if( FILE_BUFFER_SIZE >= size)
   {
       size = FILE_BUFFER_SIZE;
   }

   *ppDeCompressedBuffer = static_cast<PUCHAR>(RtlAllocateHeap(
                RtlProcessHeap(),
                0,
                size * DECOMPRESS_FACTOR
                ));
   if ( !*ppDeCompressedBuffer )
   {
       return E_OUTOFMEMORY;
   }

   ULONG        UncompressedSize;

   status = RtlDecompressBuffer(
                COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
                *ppDeCompressedBuffer,
                size * DECOMPRESS_FACTOR,
                pInputBuffer,
                *pulFileSize ,
                &UncompressedSize
                );

   if ( !NT_SUCCESS(status) )
   {
#ifdef DEBUG
        printf("RtlUnCompressBuffer returned 0x%08X.\n", status);
#endif //DEBUG

        switch (status)
        {
        case STATUS_INVALID_PARAMETER:
#ifdef DEBUG
            printf("STATUS_INVALID_PARAMETER");
#endif //DEBUG
            break;

        case STATUS_BAD_COMPRESSION_BUFFER:
#ifdef DEBUG
            printf("STATUS_BAD_COMPRESSION_BUFFER ");
            printf("size = %d %d",pulFileSize,UncompressedSize);

#endif //DEBUG
            break;
        case STATUS_UNSUPPORTED_COMPRESSION:
#ifdef DEBUG
            printf("STATUS_UNSUPPORTED_COMPRESSION  ");
#endif //DEBUG
            break;
        }
      return        E_FAIL;
   }

   *pulFileSize = UncompressedSize;

    return      S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASFileToBase64
//
// Compress then encode to Base64
//
//  BSTR by Allocated IASFileToBase64, should be freed by the caller
//
/////////////////////////////////////////////////////////////////////////////
HRESULT 
IASFileToBase64(const WCHAR* pFileName, /*out*/ BSTR* pOutputBSTR)
{
    _ASSERTE(pFileName);
    _ASSERTE(pppOutputString);
    
    HRESULT hres;
    
    HANDLE hFileHandle = CreateFileW(
                        pFileName,  
                        GENERIC_READ,    
                        FILE_SHARE_READ, 
                        NULL,           
                        OPEN_EXISTING,  
                        FILE_ATTRIBUTE_NORMAL,   
                        NULL        
                      );
 
    if ( hFileHandle == INVALID_HANDLE_VALUE )
    {
#ifdef DEBUG
        wprintf(L"#filename = %s",pFileName);
        wprintf(L"### INVALID_HANDLE_VALUE ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }

    // safe cast from DWORD to ULONG
    ULONG ulFileSize = (ULONG) GetFileSize(
                                hFileHandle, // file for which to get size
                                NULL// high-order word of file size
                                  );

    if (0xFFFFFFFF == ulFileSize)
    {
#ifdef DEBUG
        wprintf(L"### GetFileSize Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }
 

    HANDLE hFileMapping = CreateFileMapping(
                             hFileHandle,   // handle to file to map
                             NULL,          // optional security attributes
                             PAGE_READONLY, // protection for mapping object
                             0,         // high-order 32 bits of object size
                             0,         // low-order 32 bits of object size
                             NULL       // name of file-mapping object
                            );
 
    if (NULL == hFileMapping)
    {
#ifdef DEBUG
        wprintf(L"### CreateFileMapping Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }

    LPVOID pMemoryFile = MapViewOfFile(
                         hFileMapping,  // file-mapping object to map into 
                                                   //  address space
                         FILE_MAP_READ,      // access mode
                         0,     // high-order 32 bits of file offset
                         0,      // low-order 32 bits of file offset
                         0  // number of bytes to map
                        );
 
    if (NULL == pMemoryFile)
    {
#ifdef DEBUG
        wprintf(L"### MapViewOfFile Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
        return      hres;
    }


    /////////////////////////////
    // NOW compress 
    /////////////////////////////

    WCHAR* pCompressedBuffer;

    CHECK_CALL_HRES (IASCompress((PUCHAR) pMemoryFile, 
               /*IN OUT*/(ULONG *)  &ulFileSize, 
               /*IN OUT*/(PUCHAR*) &pCompressedBuffer));

    /////////////////////
    // Encode to Base64
    /////////////////////

    CHECK_CALL_HRES (ToBase64(
                                pCompressedBuffer,
                                (ULONG) ulFileSize, 
                                pOutputBSTR
                              )
                    );
    
    /////////////////////////////
    // Clean
    /////////////////////////////

    RtlFreeHeap(
                RtlProcessHeap(),
                0,
                pCompressedBuffer
               );
    
    BOOL bResult = UnmapViewOfFile(
                                   pMemoryFile// address where mapped view begins
                                  );
    if (FALSE == bResult)
    {
#ifdef DEBUG
        wprintf(L"### UnmapViewOfFile Failed ###\n");
#endif //DEBUG

        hres = E_FAIL;
    }

    CloseHandle(hFileMapping);
    CloseHandle(hFileHandle);

    return      hres;
}


/////////////////////////////////////////////////////////////////////////////
//
// IASDumpConfig
//
// Dump the configuration to some temporary files, then indidually 
// compress then encode them.
// one big string is created from those multiple Base64 strings.
//
// Remarks: IASDumpConfig does a malloc and allocates memory for
// *ppDumpString. The calling function will have to free that memory 
//
/////////////////////////////////////////////////////////////////////////////
HRESULT 
IASDumpConfig(/*inout*/ WCHAR **ppDumpString, /*inout*/ ULONG *ulSize)
{
    _ASSERTE(ppDumpString);
    _ASSERTE(ulSize);
    
    HRESULT         hres;

    /////////////////////////////////////// 
    // delete the temporary files if any
    /////////////////////////////////////// 
    CHECK_CALL_HRES (DeleteTemporaryFiles());

    ////////////////////////////////////////////////////
    // Save the Registry keys. that creates many files
    ////////////////////////////////////////////////////
    CHECK_CALL_HRES (IASSaveRegKeys());

    ////////////////////// 
    // connect to the DB
    ////////////////////// 
    WCHAR*      sz_DBPath;

    CHECK_CALL_HRES (IASExpandString(c_wcIAS_MDB_FILE_NAME, &sz_DBPath));

    CComPtr<IIASNetshJetHelper>     JetHelper;
    CHECK_CALL_HRES (CoCreateInstance(
                                         __uuidof(CIASNetshJetHelper),
                                         NULL,
                                         CLSCTX_SERVER,
                                         __uuidof(IIASNetshJetHelper),
                                         (PVOID*) &JetHelper
                                     ));
    
    CComBSTR     DBPath(sz_DBPath);
    if ( !DBPath ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->OpenJetDatabase(DBPath, TRUE));

    //////////////////////////////////////
    // Create a new DB named "Backup.mdb"
    //////////////////////////////////////
    WCHAR*      sz_FileBackup;

    CHECK_CALL_HRES (IASExpandString(c_wcFILE_BACKUP,
                                    &sz_FileBackup
                                   )
                    );

    CComBSTR     BackupDb(sz_FileBackup);
    if ( !BackupDb ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->CreateJetDatabase(BackupDb));

    
    ////////////////////////////////////////////////////////// 
    // exec the sql statements (to export)
    // the content into the temp database
    ////////////////////////////////////////////////////////// 
    WCHAR*  sz_SelectProperties;

    CHECK_CALL_HRES (IASExpandString(c_wcSELECT_PROPERTIES_INTO,
                                    &sz_SelectProperties  
                                   )
                    );

    CComBSTR     SelectProperties(sz_SelectProperties);
    if ( !SelectProperties ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->ExecuteSQLCommand(SelectProperties));

    WCHAR*  sz_SelectObjects;

    CHECK_CALL_HRES (IASExpandString(c_wcSELECT_OBJECTS_INTO,
                                    &sz_SelectObjects
                                   )
                    );
    
    CComBSTR     SelectObjects(sz_SelectObjects);
    if ( !SelectObjects ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->ExecuteSQLCommand(SelectObjects));

    WCHAR*  sz_SelectVersion;

    CHECK_CALL_HRES (IASExpandString(c_wcSELECT_VERSION_INTO,
                                    &sz_SelectVersion
                                   )
                    );

    CComBSTR     SelectVersion(sz_SelectVersion);
    if ( !SelectVersion ) { return E_OUTOFMEMORY; } 
    CHECK_CALL_HRES (JetHelper->ExecuteSQLCommand(SelectVersion));

    /////////////////////////////////////////////
    // transform the file into Base64 BSTR
    /////////////////////////////////////////////

    BSTR       FileBackupBSTR;

    CHECK_CALL_HRES (IASFileToBase64(
                                    sz_FileBackup,
                                    &FileBackupBSTR
                                    )
                    );

    int     NumberOfKeyFiles = celems(c_wcKEYS);

    BSTR    pFileKeys[celems(c_wcKEYS)];

    WCHAR*  sz_FileRegistry;

    CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE,
                                    &sz_FileRegistry
                                   )
                    );

    for ( int i = 0; i < NumberOfKeyFiles; ++i )
    {

        wstring         sFileName(sz_FileRegistry);
        WCHAR           buffer[SIZE_LONG_MAX];
        _itow(i, buffer, 10); // 10 means base 10
        sFileName += buffer;
        sFileName += L".txt";

        CHECK_CALL_HRES (IASFileToBase64(
                                        sFileName.c_str(),
                                        &pFileKeys[i]
                                        )
                        );

    }
    CoTaskMemFree(sz_FileRegistry);

    
    ///////////////////////////////////////////////
    // alloc the memory for full the Base64 string
    ///////////////////////////////////////////////

    *ulSize = SysStringByteLen(FileBackupBSTR)
              + EXTRA_CHAR_SPACE;

    for ( int j = 0; j < NumberOfKeyFiles; ++j )
    {
        *ulSize += SysStringByteLen(pFileKeys[j]);
        *ulSize += 2; // extra characters
    }

    *ppDumpString = (WCHAR *) calloc(
                                      *ulSize ,
                                      sizeof(WCHAR)
                                     );

    //////////////////////////////////////////////////
    // copy the different strings into one big string
    //////////////////////////////////////////////////
    if (*ppDumpString)
    {
        wcsncpy(
                (WCHAR*) *ppDumpString, 
                (WCHAR*) FileBackupBSTR, 
                SysStringLen(FileBackupBSTR)
               );
        
        for ( int k = 0; k < NumberOfKeyFiles; ++k )
        {
            wcscat(
                    (WCHAR*) *ppDumpString, 
                    L"*\\\n" 
                  );

            wcsncat(
                    (WCHAR*) *ppDumpString,
                    (WCHAR*) pFileKeys[k], 
                    SysStringLen(pFileKeys[k])
                   );
        }

        wcscat(
                (WCHAR*) *ppDumpString, 
                L"QWER    *    QWER\\\n" 
              );   

        *ulSize = wcslen(*ppDumpString);
    }
    else
    {
        hres = E_OUTOFMEMORY;
#ifdef DEBUG
        wprintf(L"### calloc failed ###\n");
#endif //DEBUG

    }

    /////////////////////////////////////// 
    // delete the temporary files if any
    /////////////////////////////////////// 
    CHECK_CALL_HRES (DeleteTemporaryFiles());

    /////////////////////////////////////////////
    // Clean
    /////////////////////////////////////////////
    
    for ( int k = 0; k < NumberOfKeyFiles; ++k )
    {
        SysFreeString(pFileKeys[k]);
    }

    CoTaskMemFree(sz_SelectVersion);
    CoTaskMemFree(sz_SelectProperties);
    CoTaskMemFree(sz_SelectObjects);
    CoTaskMemFree(sz_FileBackup);
    CoTaskMemFree(sz_DBPath);
    SysFreeString(FileBackupBSTR);
    CHECK_CALL_HRES (JetHelper->CloseJetDatabase());

    return      hres;
}


/////////////////////////////////////////////////////////////////////////////
//
//  IASSaveToFile
//
// Remark: if a new table has to be saved, an "entry" for that should be 
// created in that function to deal with the filemname
//
/////////////////////////////////////////////////////////////////////////////
HRESULT IASSaveToFile(
                     /* in */ int Index, 
                     /* in */ WCHAR* pContent, 
                     DWORD lSize = 0
                    )
{
    HRESULT             hres;

    wstring             sFileName;

    switch (Index)
    {
    case BACKUP_NB:
        {
            WCHAR*      sz_FileBackup;

            CHECK_CALL_HRES (IASExpandString(c_wcIAS_OLD,
                                               &sz_FileBackup
                                              )
                            );
            sFileName = sz_FileBackup;

            CoTaskMemFree(sz_FileBackup);
            break;
        }

    ///////////
    // binary
    ///////////
    default:
        {
            ///////////////////////////////////
            // i + BINARY_NB is the parameter
            ///////////////////////////////////
            WCHAR*          sz_FileRegistry;

            CHECK_CALL_HRES (IASExpandString(c_wcKEYS_FILE,
                                            &sz_FileRegistry
                                           )
                            );

            sFileName = sz_FileRegistry;
            WCHAR           buffer[SIZE_LONG_MAX];

            _itow(Index - BINARY_NB, buffer, 10); // 10 means base 10
            sFileName += buffer;
            sFileName += L".txt";
    
            CoTaskMemFree(sz_FileRegistry);
            break;
        }
    }

    HANDLE hFile = CreateFileW(
                                sFileName.c_str(),
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                              );

    if (INVALID_HANDLE_VALUE == hFile)
    {
        hres = E_FAIL;
    }
    else
    {
        DWORD       NumberOfBytesWritten;
        BOOL        bResult = WriteFile(
                                         hFile,
                                         (LPVOID) pContent,
                                         lSize,     
                                         &NumberOfBytesWritten,
                                         NULL
                                       );

        if (bResult)
        {
            hres = S_OK;
        }
        else
        {
            hres = E_FAIL;
        }
        CloseHandle(hFile);
    }

    return      hres;
}


/////////////////////////////////////////////////////////////////////////////
// IASRestoreConfig
//
// Clean the DB first, then insert back everything.
/////////////////////////////////////////////////////////////////////////////
HRESULT IASRestoreConfig(/*in*/ const WCHAR *pRestoreString)
{
    _ASSERTE(pRestoreString);

    bool    bCoInitialized = false;
    HRESULT     hres = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    if (FAILED(hres))
    {   
        if (RPC_E_CHANGED_MODE == hres)
        {
            hres = S_OK;
        }
        else
        {
            return hres;
        }
    }
    else
    {
        bCoInitialized = true;
    }

    BSTR    bstr = NULL;
    do
    {
        /////////////////////////////////////// 
        // delete the temporary files if any
        /////////////////////////////////////// 
        CHECK_CALL_HRES_BREAK (DeleteTemporaryFiles());

        CComPtr<IIASNetshJetHelper>     JetHelper;
        CHECK_CALL_HRES_BREAK (CoCreateInstance(
                                             __uuidof(CIASNetshJetHelper),
                                             NULL,
                                             CLSCTX_SERVER,
                                             __uuidof(IIASNetshJetHelper),
                                             (PVOID*) &JetHelper
                                         ));
    
        bstr = SysAllocStringLen(
                                   pRestoreString, 
                                   wcslen(pRestoreString) + 2
                                );
    
        if (bstr == NULL)
        {
    #ifdef DEBUG
            wprintf(L"### IASRestoreConfig->SysAllocStringLen failed\n"); 
    #endif //DEBUG

            return      E_OUTOFMEMORY;
        }

        int     RealNumberOfFiles = MAX_FILES + celems(c_wcKEYS);

        for ( int i = 0; i < RealNumberOfFiles; ++i )
        {
            BLOB            lBlob;

            lBlob.cbSize    = 0;
            lBlob.pBlobData = NULL;
            // split the files and registry info
            // uncompress (in memory ?)

            CHECK_CALL_HRES_BREAK (FromBase64(bstr, &lBlob, i));

            ULONG           ulSize = lBlob.cbSize;
            PUCHAR          pDeCompressedBuffer;

            ////////////////////////////////////
            // decode and decompress the base64
            ////////////////////////////////////

            CHECK_CALL_HRES_BREAK (IASUnCompress(
                                           lBlob.pBlobData, 
                                           &ulSize,
                                           &pDeCompressedBuffer
                                         ))


            if ( i >= MAX_FILES )
            {
                /////////////////////////////////////
                // Binary;  i + BINARY_NB used here
                /////////////////////////////////////
                IASSaveToFile( 
                             i - MAX_FILES + BINARY_NB, 
                             (WCHAR*)pDeCompressedBuffer, 
                             (DWORD) ulSize
                            );
            }
            else
            {
                IASSaveToFile( 
                             i, 
                             (WCHAR*)pDeCompressedBuffer, 
                             (DWORD) ulSize
                            );
            }
        
            ////////////
            // Clean
            ////////////
            RtlFreeHeap(RtlProcessHeap(), 0, pDeCompressedBuffer);

            CoTaskMemFree(lBlob.pBlobData);
        }

        ///////////////////////////////////////////////////
        // Now Upgrade the database (That's transactional)
        ///////////////////////////////////////////////////
        hres = JetHelper->UpgradeDatabase();

        if ( SUCCEEDED(hres) )
        {
    #ifdef DEBUG
            wprintf(L"### IASRestoreConfig->DB stuff successful\n"); 
    #endif //DEBUG

            ////////////////////////////////////////////////////////
            // Now restore the registry.
            ////////////////////////////////////////////////////////
            hres = IASRestoreRegKeys();
            if ( FAILED(hres) )
            {
    #ifdef DEBUG
            wprintf(L"### IASRestoreConfig->restore reg keys failed\n"); 
    #endif //DEBUG
            }
        }
        // delete the temporary files 
        DeleteTemporaryFiles(); // do not check the result
    } while (false);

    SysFreeString(bstr);    
    
    if (bCoInitialized)
    {
        CoUninitialize();
    }
    return  hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\rmstring.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999-2000  Microsoft Corporation
//
// Module Name:
//
//    rmstring.h
//
// Abstract:
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _RMSTRING_H__
#define _RMSTRING_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define MSG_HELP_START                      L"%1!-14s! - "
#define MSG_NEWLINE                         L"\n"

#define MSG_AAAACONFIG_DUMP                 L""
#define MSG_AAAACONFIG_BLOBBEGIN            L"pushd aaaa\nset config blob=\\\n"
#define MSG_AAAACONFIG_BLOBEND              L"\npopd\n"


#define CMD_GROUP_SHOW                      L"show"
#define CMD_GROUP_SET                       L"set"

#define CMD_AAAA_HELP1                      L"help"
#define CMD_AAAA_HELP2                      L"?"
#define CMD_AAAA_DUMP                       L"dump" 

#define CMD_AAAAVERSION_SHOW                L"version"

#define CMD_AAAACONFIG_SET                  L"config"
#define CMD_AAAACONFIG_SHOW                 L"config"

#define TOKEN_SET                           L"set"
#define TOKEN_BLOB                          L"blob"
#define TOKEN_SHOW                          L"show"
#define TOKEN_CONFIG                        L"config"

#define DMP_AAAA_PUSHD                      L"pushd aaaa\n\n"
#define DMP_AAAA_POPD                       L"\npopd\n"

#endif //_RMSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\stdafx.cpp ===
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\stdafx.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000  Microsoft Corporation
//
// Module Name:
//
//    stdafx.h
//
// Abstract:
//
// Revision History:
//  
//    Thierry Perraut 04/17/2000
//
//////////////////////////////////////////////////////////////////////////////
#ifndef MAX_DLL_NAME
#define MAX_DLL_NAME    48
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <oleauto.h>
#include <objbase.h>
#include <atlbase.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <rtutils.h>
#include <dsgetdc.h>

#include "iasmdbtool.h"
#include "base64tool.h"
#include <netsh.h>
#include <netshp.h>
#include "aaaamontr.h"
#include "utils.h"
#include "context.h"
#include "userenv.h"

// for the Jet wrapper
#include "datastore2.h"
#include "iasuuid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\utils.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    utils.h
//
// Abstract:
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _UTILS_H_
#define _UTILS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define BREAK_ON_DWERR(_e) if ((_e)) break;
// #define AAAAMON_ERROR_BASE 0XFEFF0000 

#define RutlDispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

HRESULT RefreshIASService();

AAAA_PARSE_FN               RutlParse;

#ifdef __cplusplus
}
#endif
#endif //_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\utils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999  Microsoft Corporation
//
// Module Name:
//
//    utils.c
//
// Abstract:
//
//      utils functions
//
// Revision History:
//  
//    Thierry Perraut 04/07/1999
//
//////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <netsh.h>
#include "aaaamontr.h"
#include "strdefs.h"
#include "rmstring.h"
#include "aaaamon.h"
#include "context.h"
#include <rtutils.h>
#include "utils.h"
#include "base64tool.h"

const WCHAR c_szCurrentBuildNumber[]      = L"CurrentBuildNumber";
const WCHAR c_szWinVersionPath[]          =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR c_szAssignFmt[]               = L"%s = %s";
const WCHAR pszAAAAEngineParamStub[]   = 
    L"SYSTEM\\CurrentControlSet\\Services\\AAAAEngine\\Parameters\\";

AAAA_ALLOC_FN               RutlAlloc;
AAAA_DWORDDUP_FN            RutlDwordDup;
AAAA_CREATE_DUMP_FILE_FN    RutlCreateDumpFile;
AAAA_CLOSE_DUMP_FILE_FN     RutlCloseDumpFile;
AAAA_ASSIGN_FROM_TOKENS_FN  RutlAssignmentFromTokens;
AAAA_STRDUP_FN              RutlStrDup;
AAAA_FREE_FN                RutlFree;
AAAA_GET_OS_VERSION_FN      RutlGetOsVersion;
AAAA_GET_TAG_TOKEN_FN       RutlGetTagToken;
AAAA_IS_HELP_TOKEN_FN       RutlIsHelpToken;



//////////////////////////////////////////////////////////////////////////////
// RutlGetTagToken
// 
// Routine Description:
// 
//     Identifies each argument based on its tag. It assumes that each argument
//     has a tag. It also removes tag= from each argument.
// 
// Arguments:
// 
//     ppwcArguments  - The argument array. Each argument has tag=value form
//     dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
//     dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
//     pttTagToken    - Array of tag token ids that are allowed in the args
//     dwNumTags      - Size of pttTagToken
//     pdwOut         - Array identifying the type of each argument.
// 
// Return Value:
// 
//     NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
// 
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
RutlGetTagToken(
                IN  HANDLE      hModule,
                IN  PWCHAR      *ppwcArguments,
                IN  DWORD       dwCurrentIndex,
                IN  DWORD       dwArgCount,
                IN  PTAG_TYPE   pttTagToken,
                IN  DWORD       dwNumTags,
                OUT PDWORD      pdwOut
               )
{
    PWCHAR     pwcTag,pwcTagVal,pwszArg = NULL;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for ( DWORD i = dwCurrentIndex; i < dwArgCount; ++i )
    {
        DWORD len = wcslen(ppwcArguments[i]);

        if ( !len )
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = static_cast<DWORD> (-1);
            continue;
        }

        pwszArg = static_cast<unsigned short *>(RutlAlloc(
                                                   (len + 1) * sizeof(WCHAR),
                                                   FALSE));

        if ( !pwszArg )
        {
            DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if ( !pwcTagVal )
        {
            DisplayMessage(g_hModule, 
                           ERROR_NO_TAG,
                           ppwcArguments[i]);

            RutlFree(pwszArg);

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        BOOL bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( DWORD j = 0; j < dwNumTags; ++j )
        {
            if ( MatchToken(pwcTag, pttTagToken[j].pwszTag) )
            {
                //
                // Tag matched
                //

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if ( bFound )
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            DisplayError(NULL,
                         ERROR_INVALID_OPTION_TAG, 
                         pwcTag);

            RutlFree(pwszArg);

            return ERROR_INVALID_OPTION_TAG;
        }

        RutlFree(pwszArg);
    }

    return NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// RutlCreateDumpFile
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
RutlCreateDumpFile(
                   IN  PWCHAR  pwszName,
                   OUT PHANDLE phFile
                  )
{
    HANDLE  hFile;

    *phFile = NULL;

    // Create/open the file
    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        return GetLastError();
    }

    // Go to the end of the file
    SetFilePointer(hFile, 0, NULL, FILE_END);    

    *phFile = hFile;

    return NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
// RutlCloseDumpFile
//////////////////////////////////////////////////////////////////////////////
VOID
WINAPI
RutlCloseDumpFile(HANDLE  hFile)
{
    CloseHandle(hFile);
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlAlloc
//
// Returns an allocated block of memory conditionally
// zeroed of the given size.
//
//////////////////////////////////////////////////////////////////////////////
PVOID 
WINAPI
RutlAlloc(
    IN DWORD    dwBytes,
    IN BOOL     bZero
    )
{
    DWORD dwFlags = 0;

    if ( bZero )
    {
        dwFlags |= HEAP_ZERO_MEMORY;
    }

    return HeapAlloc(GetProcessHeap(), dwFlags, dwBytes);
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlFree
//
// Conditionally free's a pointer if it is non-null
//
//////////////////////////////////////////////////////////////////////////////
VOID 
WINAPI
RutlFree(
            IN PVOID pvData
        )
{
    HeapFree(GetProcessHeap(), 0, pvData);
}


//////////////////////////////////////////////////////////////////////////////
// 
// RutlStrDup
// 
// Uses RutlAlloc to copy a string
//
//////////////////////////////////////////////////////////////////////////////
PWCHAR
WINAPI
RutlStrDup(
            IN PWCHAR pwszSrc
          )
{
    PWCHAR  pszRet = NULL;
    DWORD   dwLen; 
    
    if (( !pwszSrc ) || ((dwLen = wcslen(pwszSrc)) == 0))
    {
        return NULL;
    }

    pszRet = static_cast<PWCHAR>(RutlAlloc((dwLen + 1) * sizeof(WCHAR),FALSE));
    if ( pszRet )
    {
        wcscpy(pszRet, pwszSrc);
    }

    return pszRet;
}


//////////////////////////////////////////////////////////////////////////////
// RutlDwordDup
// 
// Uses RutlAlloc to copy a dword
//
//////////////////////////////////////////////////////////////////////////////
LPDWORD
WINAPI
RutlDwordDup(
              IN DWORD dwSrc
            )
{
    LPDWORD lpdwRet = NULL;
    
    lpdwRet = static_cast<LPDWORD>(RutlAlloc(sizeof(DWORD), FALSE));
    if ( lpdwRet )
    {
        *lpdwRet = dwSrc;
    }

    return lpdwRet;
}

    
//////////////////////////////////////////////////////////////////////////////
//
// RutlGetOsVersion
//
// Returns the build number of operating system
//
//////////////////////////////////////////////////////////////////////////////
DWORD
WINAPI
RutlGetOsVersion(
    IN  PWCHAR  pwszRouter, 
    OUT LPDWORD lpdwVersion)
{

    DWORD   dwErr, dwType = REG_SZ, dwLength;
    HKEY    hkMachine = NULL, hkVersion = NULL;
    WCHAR   pszBuildNumber[64];
    PWCHAR  pszMachine = pwszRouter;

    //
    // Validate and initialize
    //
    if ( !lpdwVersion ) 
    { 
        return ERROR_INVALID_PARAMETER; 
    }
    *lpdwVersion = FALSE;

    do 
    {
        //
        // Connect to the remote server
        //
        dwErr = RegConnectRegistry(
                    pszMachine,
                    HKEY_LOCAL_MACHINE,
                    &hkMachine);
        if ( dwErr != ERROR_SUCCESS )        
        {
            break;
        }

        //
        // Open the windows version key
        //

        dwErr = RegOpenKeyEx(
                    hkMachine, 
                    c_szWinVersionPath, 
                    0, 
                    KEY_QUERY_VALUE, 
                    &hkVersion
                    );
        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        //
        // Read in the current version key
        //
        dwLength = sizeof(pszBuildNumber);
        dwErr = RegQueryValueEx (
                    hkVersion, 
                    c_szCurrentBuildNumber, 
                    NULL, 
                    &dwType,
                    (BYTE*)pszBuildNumber, 
                    &dwLength
                    );
        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        *lpdwVersion = static_cast<DWORD>(wcstol(pszBuildNumber, NULL, 10));
        
    } while (FALSE);


    // Cleanup
    if ( hkVersion )
    {
        RegCloseKey( hkVersion );
    }
    if ( hkMachine )
    {
        RegCloseKey( hkMachine );
    }

    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlParseOptions
// 
// Routine Description:
// 
//     Based on an array of tag types returns which options are
//     included in the given command line.
// 
// Arguments:
// 
//     ppwcArguments   - Argument array
//     dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
//     dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
// 
// Return Value:
// 
//     NO_ERROR
// 
//////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI
RutlParseOptions(
                    IN  PWCHAR*                 ppwcArguments,
                    IN  DWORD                   dwCurrentIndex,
                    IN  DWORD                   dwArgCount,
                    IN  DWORD                   dwNumArgs,
                    IN  TAG_TYPE*               rgTags,
                    IN  DWORD                   dwTagCount,
                    OUT LPDWORD*                ppdwTagTypes
                )
{
    LPDWORD     pdwTagType;
    DWORD       i, dwErr = NO_ERROR;
    
    // If there are no arguments, there's nothing to to
    //
    if ( !dwNumArgs )
    {   
        return NO_ERROR;
    }

    // Set up the table of present options
    pdwTagType = static_cast<LPDWORD>(RutlAlloc(
                                                 dwArgCount * sizeof(DWORD), 
                                                 TRUE
                                               ));
    if( !pdwTagType )
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {
        //
        // The argument has a tag. Assume all of them have tags
        //
        if( wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER) )
        {
            dwErr = RutlGetTagToken(
                        g_hModule, 
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        dwTagCount,
                        pdwTagType);

            if( dwErr != NO_ERROR )
            {
                if( dwErr == ERROR_INVALID_OPTION_TAG )
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    break;
                }
            }
        }
        else
        {
            //
            // No tags - all args must be in order
            //
            for( i = 0; i < dwNumArgs; ++i )
            {
                pdwTagType[i] = i;
            }
        }
        
    } while (FALSE);        

    // Cleanup
    {
        if ( dwErr == NO_ERROR )
        {
            *ppdwTagTypes = pdwTagType;
        }
        else
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlIsHelpToken
//
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
RutlIsHelpToken(PWCHAR  pwszToken)
{
    if( MatchToken(pwszToken, CMD_AAAA_HELP1) )
    {
        return TRUE;
    }

    if( MatchToken(pwszToken, CMD_AAAA_HELP2) )
    {
        return TRUE;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlAssignmentFromTokens
//
//////////////////////////////////////////////////////////////////////////////
PWCHAR
WINAPI
RutlAssignmentFromTokens(
                            IN HINSTANCE hModule,
                            IN PWCHAR pwszToken,
                            IN PWCHAR pszString
                        )
{
    PWCHAR pszRet = NULL, pszCmd = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    
    do 
    {
        pszCmd = pwszToken;

        // Compute the string lenghth needed
        //
        dwSize = wcslen(pszString)      + 
                 wcslen(pszCmd)         + 
                 wcslen(c_szAssignFmt)  + 
                 1;
        dwSize *= sizeof(WCHAR);

        // Allocate the return value
        pszRet = (PWCHAR) RutlAlloc(dwSize, FALSE);
        if (pszRet == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy in the command assignment
        _snwprintf(
                    pszRet, 
                    dwSize,
                    c_szAssignFmt, 
                    pszCmd, 
                    pszString
                  );

    } while ( FALSE );

    // Cleanup
    {
        if ( dwErr != NO_ERROR )
        {
            if ( pszRet )
            {
                RutlFree(pszRet);
            }
            pszRet = NULL;
        }
    }
    return pszRet;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlRegReadDword
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegReadDword(
                    IN  HKEY hKey,
                    IN  PWCHAR pszValName,
                    OUT LPDWORD lpdwValue
                )
{
    DWORD dwSize = sizeof(DWORD), dwType = REG_DWORD, dwErr;

    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                &dwType,
                (LPBYTE)lpdwValue,
                &dwSize);
    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        dwErr = NO_ERROR;
    }

    return dwErr;                
}                
        

//////////////////////////////////////////////////////////////////////////////
//
// RutlRegReadString
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegReadString(
                    IN  HKEY hKey,
                    IN  PWCHAR pszValName,
                    OUT PWCHAR* ppszValue
                 )
{
    DWORD dwErr = NO_ERROR, dwSize = 0;

    *ppszValue = NULL;
    
    // Findout how big the buffer should be
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                NULL,
                &dwSize);
    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        return NO_ERROR;
    }
    if ( dwErr != ERROR_SUCCESS )
    {
        return dwErr;
    }

    // Allocate the string
    //
    *ppszValue = (PWCHAR) RutlAlloc(dwSize, TRUE);
    if ( ! *ppszValue )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Read the value in and return 
    //
    dwErr = RegQueryValueExW(
                hKey,
                pszValName,
                NULL,
                NULL,
                (LPBYTE)*ppszValue,
                &dwSize);
                
    return dwErr;
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlRegReadString
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegWriteDword(
                    IN HKEY hKey,
                    IN PWCHAR pszValName,
                    IN DWORD dwValue
                 )
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(DWORD));
}


//////////////////////////////////////////////////////////////////////////////
//
// RutlRegWriteString
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlRegWriteString(
                    IN HKEY hKey,
                    IN PWCHAR pszValName,
                    IN PWCHAR pszValue
                  )
{
    return RegSetValueExW(
                hKey,
                pszValName,
                0,
                REG_SZ,
                (LPBYTE)pszValue,
                (wcslen(pszValue) + 1) * sizeof(WCHAR));
}


//////////////////////////////////////////////////////////////////////////////
//RutlParse
//
// Generic parse
//
//////////////////////////////////////////////////////////////////////////////
DWORD
RutlParse(
            IN  PWCHAR*         ppwcArguments,
            IN  DWORD           dwCurrentIndex,
            IN  DWORD           dwArgCount,
            IN  BOOL*           pbDone,
            OUT AAAAMON_CMD_ARG* pAaaaArgs,
            IN  DWORD           dwAaaaArgCount
         )
{
    DWORD            i, dwNumArgs, dwErr, dwLevel = 0;
    LPDWORD          pdwTagType = NULL;
    TAG_TYPE*        pTags = NULL;
    AAAAMON_CMD_ARG*  pArg = NULL;

    if ( !dwAaaaArgCount )
    {
        return ERROR_INVALID_PARAMETER;
    }

    do 
    {
        // Initialize
        dwNumArgs = dwArgCount - dwCurrentIndex;
        
        // Generate a list of the tags
        //
        pTags = (TAG_TYPE*)
            RutlAlloc(dwAaaaArgCount * sizeof(TAG_TYPE), TRUE);
        if ( !pTags )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        for ( i = 0; i < dwAaaaArgCount; ++i )
        {
            CopyMemory(&pTags[i], &pAaaaArgs[i].rgTag, sizeof(TAG_TYPE));
        }
    
        // Get the list of present options
        //
        dwErr = RutlParseOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    dwNumArgs,
                    pTags,
                    dwAaaaArgCount,
                    &pdwTagType);
        if ( dwErr != NO_ERROR )
        {
            break;
        }

        // Copy the tag info back
        //
        for ( i = 0; i < dwAaaaArgCount; ++i )
        {
            CopyMemory(&pAaaaArgs[i].rgTag, &pTags[i], sizeof(TAG_TYPE));
        }
    
        for( i = 0; i < dwNumArgs; ++i )
        {
            // Validate the current argument
            //
            if ( pdwTagType[i] >= dwAaaaArgCount )
            {
                i = dwNumArgs;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            pArg = &pAaaaArgs[pdwTagType[i]];

            // Get the value of the argument
            //
            switch ( pArg->dwType )
            {
                case AAAAMONTR_CMD_TYPE_STRING:
                {
                    pArg->Val.pszValue = 
                        RutlStrDup(ppwcArguments[i + dwCurrentIndex]);
                    break;
                }
                    
                case AAAAMONTR_CMD_TYPE_ENUM:
                {
                    dwErr = MatchEnumTag(g_hModule,
                                         ppwcArguments[i + dwCurrentIndex],
                                         pArg->dwEnumCount,
                                         pArg->rgEnums,
                                         &(pArg->Val.dwValue));

                    if(dwErr != NO_ERROR)
                    {
                        RutlDispTokenErrMsg(
                            g_hModule, 
                            EMSG_BAD_OPTION_VALUE,
                            pArg->rgTag.pwszTag,
                            ppwcArguments[i + dwCurrentIndex]);
                        i = dwNumArgs;
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    break;
                }
            }
            if ( dwErr != NO_ERROR )
            {
                break;
            }

            // Mark the argument as present if needed
            //
            if ( pArg->rgTag.bPresent )
            {
                dwErr = ERROR_TAG_ALREADY_PRESENT;
                i = dwNumArgs;
                break;
            }
            pArg->rgTag.bPresent = TRUE;
        }
        if( dwErr != NO_ERROR )
        {
            break;
        }

        // Make sure that all of the required parameters have
        // been included.
        //
        for ( i = 0; i < dwAaaaArgCount; ++i )
        {
            if ( (pAaaaArgs[i].rgTag.dwRequired & NS_REQ_PRESENT)
             && !pAaaaArgs[i].rgTag.bPresent )
            {
                DisplayMessage(g_hModule, EMSG_CANT_FIND_EOPT);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
        if ( dwErr != NO_ERROR )
        {
            break;
        }

    } while (FALSE);  
    
    // Cleanup
    {
        if ( pTags )
        {
            RutlFree(pTags);
        }
        if ( pdwTagType )
        {
            RutlFree(pdwTagType);
        }
    }

    return dwErr;
}

    
//////////////////////////////////////////////////////////////////////////////
// RefreshIASService
//
// Send a control 128 (refresh)to IAS
//
//////////////////////////////////////////////////////////////////////////////
HRESULT RefreshIASService()
{
    SC_HANDLE   hManager = OpenSCManager(
                                          NULL,   
                                          SERVICES_ACTIVE_DATABASE,
                                          SC_MANAGER_CONNECT |
                                          SC_MANAGER_ENUMERATE_SERVICE |
                                          SC_MANAGER_QUERY_LOCK_STATUS
                                        );
    if ( !hManager )
    {
        return E_FAIL;
    }


    SC_HANDLE hService = OpenServiceW(
                                         hManager,  
                                         L"IAS",
                                         SERVICE_USER_DEFINED_CONTROL | 
                                         SERVICE_QUERY_STATUS
                                     );
    
    if ( !hService )
    {
        CloseServiceHandle(hManager);
        return E_FAIL;
    }
 
    SERVICE_STATUS      ServiceStatus;
    BOOL    bResultOk = QueryServiceStatus(
                                            hService,
                                            &ServiceStatus  
                                          );
    HRESULT     hres;
    if ( bResultOk )
    {
        if ( (SERVICE_STOPPED == ServiceStatus.dwCurrentState) ||
             (SERVICE_STOP_PENDING == ServiceStatus.dwCurrentState))
        {
            //////////////////////////////////////////////////
            // service not running = nothing to do to refresh
            //////////////////////////////////////////////////
            hres = S_OK;
        }
        else 
        {
            /////////////////////////////////////////////////////
            // the service is running thus send the refresh code
            /////////////////////////////////////////////////////
            BOOL    bControlOk = ControlService(
                                                   hService,
                                                   128,
                                                   &ServiceStatus  
                                               );
            if ( bControlOk == FALSE )
            {
                hres = E_FAIL;
            }
            else
            {
                hres = S_OK;
            }
        }
    }
    else
    {
        hres = E_FAIL;
    }

    //////////
    // clean
    //////////
    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
    // hres is always defined here.
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\aaaa\strdefs.h ===
//////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1999-2000  Microsoft Corporation
//
// Module Name:
//
//    strdef.h
//
// Abstract:
//      
//      NOTE - DONT USE 15000-15999
//
// Revision History:
//  
//    Thierry Perraut 04/02/1999
//
//////////////////////////////////////////////////////////////////////////////
#ifndef __STRDEFS_H__
#define __STRDEFS_H__
#if _MSC_VER > 1000
#pragma once
#endif

#define MSG_NULL                               1001
#define MSG_CMD_NOT_IMPLEMENTED                1004

#define HLP_AAAA_HELP1                          2300
#define HLP_AAAA_HELP1_EX                       2301
#define HLP_AAAA_HELP2                          HLP_AAAA_HELP1
#define HLP_AAAA_HELP2_EX                       HLP_AAAA_HELP1_EX

#define HLP_AAAA_DUMP                          3201
#define HLP_AAAA_DUMP_EX                       3202

#define HLP_AAAAVERSION_SHOW                   2342
#define HLP_AAAAVERSION_SHOW_EX                2343
#define HLP_AAAACONFIG_SET                     2344
#define HLP_AAAACONFIG_SET_EX                  2345
#define HLP_AAAACONFIG_SHOW                    2346
#define HLP_AAAACONFIG_SHOW_EX                 2347

#define HLP_GROUP_SET                          3292
#define HLP_GROUP_SHOW                         3293

#define HLP_SHOW_SERVERS                       3301
#define HLP_SHOW_SERVERS_EX                    3302

#define MSG_AAAA_SCRIPTHEADER                  4501
#define MSG_AAAA_SCRIPTFOOTER                  4502
#define MSG_AAAA_SHOW_SERVERS_HEADER           4503

#define MSG_AAAACONFIG_SET_SUCCESS             5402
#define MSG_AAAACONFIG_SET_FAIL                5403
#define MSG_AAAACONFIG_SHOW_SUCCESS            5404
#define MSG_AAAACONFIG_SHOW_FAIL               5405
#define MSG_AAAACONFIG_SHOW_HEADER             5406
#define MSG_AAAACONFIG_SHOW_FOOTER             5407
#define MSG_AAAAVERSION_SHOW_SUCCESS           5408
#define MSG_AAAAVERSION_SHOW_FAIL              5409
#define MSG_AAAAVERSION_GET_FAIL               5410
#define MSG_AAAACONFIG_SHOW_INVALID_SYNTAX     5411
#define MSG_AAAACONFIG_SET_REGISTRY_FAIL       5412
#define MSG_AAAACONFIG_SET_REFRESH_FAIL        5413

#define EMSG_TAG_ALREADY_PRESENT               10001
#define EMSG_CANT_FIND_EOPT                    10002
#define EMSG_BAD_OPTION_VALUE                  10003
#define EMSG_UNABLE_TO_CREATE_FILE             10005
#define EMSG_OPEN_DB_FAILED                    10006
#define EMSG_AAAACONFIG_SHOW_FAIL              10007
#define EMSG_AAAACONFIG_UPGRADE_FAIL           10008

#define EMSG_INCOMPLETE_COMMAND                11002

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\context.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\if\ip\context.c

Abstract:

    If subcontexts.

Revision History:

    lokeshs

--*/

#include "precomp.h"

// Includes for the sub contexts
//
#include "ifip.h"

NS_HELPER_ATTRIBUTES g_pSubContexts[] =
{
    // Ip subcontext
    //
    {
        { IFIP_VERSION, 0 }, IFIP_GUID, IfIpStartHelper, NULL
    },
};

#define g_dwSubContextCount \
            (sizeof(g_pSubContexts) / sizeof(*g_pSubContexts))





//
// Installs all of the sub contexts provided
// in this .dll (for example, "if ip", and any new ones.)
//
DWORD
IfContextInstallSubContexts(
    )
{
    DWORD dwErr = NO_ERROR, i;

    PNS_HELPER_ATTRIBUTES pCtx = NULL;

    for (i = 0, pCtx = g_pSubContexts; i < g_dwSubContextCount; i++, pCtx++)
    {
        // Initialize helper attributes
        //
        RegisterHelper( &g_IfGuid, pCtx );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\context.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    routing\netsh\if\context.h

Abstract:

Revision History:

--*/

DWORD
IfContextInstallSubContexts(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\defs.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\if\defs.h

Abstract:

    global definitions

Revision History:

    AmritanR

--*/


#define is      ==
#define isnot   !=
#define and     &&
#define or      ||

#define MAX_IF_FRIENDLY_NAME_LEN        512

#define LOCAL_ROUTER_PB_PATHW  L"%SystemRoot%\\system32\\RAS\\Router.Pbk"
#define REMOTE_ROUTER_PB_PATHW L"\\\\%ls\\Admin$\\system32\\RAS\\Router.Pbk"

#define IFMON_ERROR_BASE                0xFEFF0000

typedef DWORD          IPV4_ADDRESS, *PIPV4_ADDRESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifhandle.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\if\ifhandle.c

Abstract:

    Handlers for commands

Revision History:

    AmritanR

--*/

#include "precomp.h"
#pragma hdrstop

//
// Remove this when one can change interface friendly names
//
#define CANT_RENAME_IFS

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY      g_IfCmdGroups[];
extern CMD_ENTRY            g_IfCmds[];

DWORD
HandleIfAddIf(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for adding an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return RtrHandleAdd(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfDelIf(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Handler for deleting an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return RtrHandleDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);

}

DWORD
HandleIfShowIf(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    if (dwArgCount == dwCurrentIndex)
    {
        DisplayMessage(g_hModule, MSG_IF_TABLE_HDR);
    }

    return RtrHandleShow(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfShowCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for showing credentials of an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleShowCredentials(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfSetCredentials(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleSetCredentials(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfSet(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleSet(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
HandleIfResetAll(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Handler for resetting everything.
    
Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    return RtrHandleResetAll(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone);
}

DWORD
IfDump(
    IN  LPCWSTR     pwszRouter,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DWORD dwErr;

    dwErr = ConnectToRouter(pwszRouter);
    if (dwErr)
    {
        return dwErr;
    }

    return RtrDump(
                ppwcArguments,
                dwArgCount
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifhandle.h ===
FN_HANDLE_CMD    HandleIfAddIf;
FN_HANDLE_CMD    HandleIfDelIf;
FN_HANDLE_CMD    HandleIfSetCredentials;
FN_HANDLE_CMD    HandleIfShowIf;
FN_HANDLE_CMD    HandleIfShowCredentials;
FN_HANDLE_CMD    HandleIfSet;
FN_HANDLE_CMD    HandleIfResetAll;

NS_CONTEXT_DUMP_FN IfDump;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\if\ifmon.c

Abstract:

    If Command dispatcher.

Revision History:

    AmritanR

--*/

#include "precomp.h"


#define IFMON_GUID \
{ 0x705eca1, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }

GUID g_IfGuid = IFMON_GUID;

static const GUID g_NetshGuid = NETSH_ROOT_GUID;

#define IF_HELPER_VERSION 1


//
// The monitor's commands are broken into 2 sets
//      - The top level commands are those which deal with the monitor
//        itself (meta commands) and others which take 0 arguments
//      - The rest of the commands are split into "command groups"
//        i.e, commands grouped by the VERB where the VERB is ADD, DELETE,
//        GET or SET.  This is not for any technical reason - only for
//        staying with the semantics used in other monitors and helpers
//
// A command is described using a CMD_ENTRY structure. It requires the
// command token, the handler, a short help message token and an extended 
// help message token.  To make it easier to create we use the 
// CREATE_CMD_ENTRY macro. This, however puts restrictions on how the tokens
// are named.
//
// The command groups are simply arrays of the CMD_ENTRY structure.  The 
// top level commands are also grouped in a similar array.
//
// The info about a complete command group is put in a CMD_GROUP_ENTRY
// structure, all of which are put in an array.
//
 

//
// NOTE: Since we have only one entry per group, currently, we really didnt
// need command groups. This is done for later extensibility.
// To add a command entry to a group, simply add the command to the appropriate
// array
// To add a command group - create and array and add its info to the
// command group array
//

CMD_ENTRY  g_IfAddCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_ADD_IF, HandleIfAddIf),
};

CMD_ENTRY  g_IfDelCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_DEL_IF,  HandleIfDelIf),
};

CMD_ENTRY  g_IfSetCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_SET_INTERFACE, HandleIfSet),
    CREATE_CMD_ENTRY(IF_SET_CREDENTIALS, HandleIfSetCredentials),
};

CMD_ENTRY g_IfShowCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_SHOW_IF, HandleIfShowIf),
    CREATE_CMD_ENTRY(IF_SHOW_CREDENTIALS, HandleIfShowCredentials),
};

CMD_ENTRY g_IfResetCmdTable[] = 
{
    CREATE_CMD_ENTRY(IF_RESET_ALL, HandleIfResetAll),
};

CMD_GROUP_ENTRY g_IfCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_IfAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_IfDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_IfShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_IfSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_RESET, g_IfResetCmdTable),
};

ULONG   g_ulNumGroups = sizeof(g_IfCmdGroups)/sizeof(CMD_GROUP_ENTRY);

HANDLE   g_hModule;
HANDLE   g_hMprConfig = NULL;
HANDLE   g_hMprAdmin  = NULL;
HANDLE   g_hMIBServer = NULL;
BOOL     g_bCommit;
PWCHAR   g_pwszRouter = NULL;

DWORD                ParentVersion;
BOOL                 g_bIfDirty = FALSE;

ULONG   g_ulInitCount;
 
NS_CONTEXT_CONNECT_FN           IfConnect;

DWORD
WINAPI
IfCommit(
    IN  DWORD   dwAction
    )
{
    BOOL    bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if(g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.
            //

            if(g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    return NO_ERROR;
}

BOOL 
WINAPI
IfDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD
WINAPI
IfStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"interface";
    attMyAttributes.guidHelper  = g_IfGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = CMD_FLAG_PRIORITY;
    attMyAttributes.ulPriority  = 10; // very low so gets dumped first
    attMyAttributes.ulNumTopCmds  = 0;
    attMyAttributes.pTopCmds      = NULL;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_IfCmdGroups;
    attMyAttributes.pfnCommitFn = IfCommit;
    attMyAttributes.pfnDumpFn   = IfDump;
    attMyAttributes.pfnConnectFn= IfConnect;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
IfConnect(
    IN  LPCWSTR pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bIfDirty)
    {
        IfStartHelper(NULL, ParentVersion);
    }

    return ConnectToRouter(pwszRouter);
}


DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD   dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;
    WSADATA              wsa;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    dwErr = WSAStartup(MAKEWORD(2,0), &wsa);

    g_bCommit = TRUE;

    // Register helpers

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper         = g_IfGuid;
    attMyAttributes.dwVersion          = IF_HELPER_VERSION;
    attMyAttributes.pfnStart           = IfStartHelper;
    attMyAttributes.pfnStop            = NULL;

    RegisterHelper( &g_NetshGuid, &attMyAttributes );


    //
    // Register any sub contexts implemented in this dll
    //
    
    dwErr = IfContextInstallSubContexts();
    if (dwErr isnot NO_ERROR)
    {
        IfUnInit(0);
        return dwErr;
    }
    
    return NO_ERROR;
}

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    )
{
    DWORD    dwErr = NO_ERROR;

    do
    {
        // Change the router name if needed
        //
        if ((g_pwszRouter != pwszRouter) &&
            (!g_pwszRouter || !pwszRouter || lstrcmpi(g_pwszRouter,pwszRouter)))
        {
            if (g_hMprConfig)
            {
                MprConfigServerDisconnect(g_hMprConfig);
                g_hMprConfig = NULL;
            }

            if (g_hMprAdmin)
            {
                MprAdminServerDisconnect(g_hMprAdmin);
                g_hMprAdmin = NULL;
            }

            if (g_hMIBServer)
            {
                MprAdminMIBServerDisconnect(g_hMIBServer);
                g_hMIBServer = NULL;
            }
        }

        // Cleanup the old router name
        //
        if (g_pwszRouter)
        {
            IfutlFree(g_pwszRouter);
        }

        // Copy the new router name in
        //
        if (pwszRouter)
        {
            g_pwszRouter = IfutlStrDup(pwszRouter);
            if (g_pwszRouter == NULL)
            {
                dwErr = ERROR_CONNECT_REMOTE_CONFIG;
                break;
            }
        }
        else
        {
            g_pwszRouter = NULL;
        }

        if (!g_hMprConfig)
        {
            //
            // first time connecting to router config
            //

            dwErr = MprConfigServerConnect((LPWSTR)pwszRouter, &g_hMprConfig);

            if (dwErr isnot NO_ERROR)
            {
                //
                // cannot connect to router config.
                //
                break;
            }
        }

        //
        // Check to see if router is running. If so, get the handles
        //

        if (MprAdminIsServiceRunning((LPWSTR)pwszRouter))
        {
            if(MprAdminServerConnect((LPWSTR)pwszRouter, &g_hMprAdmin) != NO_ERROR)
            {
                g_hMprAdmin = NULL;
            }
        }

    } while (FALSE);

    return dwErr;    
}

DWORD
WINAPI
IfUnInit(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifip.c ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
// File: ifip.c
// Abstract:
//      This module implements the if/ip apis
//
// Author: K.S.Lokesh (lokeshs@)   8-1-99
//=============================================================================


#include "precomp.h"
#pragma hdrstop
#include "ifip.h"

//
// global variables
//

#define IFIP_IFNAME_MASK   0x0001
#define IFIP_SOURCE_MASK   0X0002
#define IFIP_ADDR_MASK     0X0004
#define IFIP_MASK_MASK     0X0008
#define IFIP_GATEWAY_MASK  0X0010
#define IFIP_GWMETRIC_MASK 0X0020
#define IFIP_INDEX_MASK    0X0040

#define DHCP 1
#define STATIC 2
#define NONE ~0
#define ALL ~0


// The guid for this context
//
GUID g_IfIpGuid = IFIP_GUID;

// The commands supported in this context
//

CMD_ENTRY  g_IfIpAddCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_ADD_IPADDR,IfIpHandleAddAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_ADD_DNS,IfIpHandleAddDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_ADD_WINS,IfIpHandleAddWins,CMD_FLAG_LOCAL),
};

CMD_ENTRY  g_IfIpSetCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_SET_IPADDR,IfIpHandleSetAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SET_DNS,IfIpHandleSetDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SET_WINS,IfIpHandleSetWins,CMD_FLAG_LOCAL),
};

CMD_ENTRY  g_IfIpDelCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_DEL_IPADDR,IfIpHandleDelAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_DEL_DNS,IfIpHandleDelDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_DEL_WINS,IfIpHandleDelWins,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_DEL_ARPCACHE,IfIpHandleDelArpCache,CMD_FLAG_LOCAL),
};


CMD_ENTRY  g_IfIpShowCmdTable[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_CONFIG,IfIpHandleShowConfig,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_IPADDR,IfIpHandleShowAddress,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_OFFLOAD,IfIpHandleShowOffload,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_DNS, IfIpHandleShowDns,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY_EX(IFIP_SHOW_WINS, IfIpHandleShowWins,CMD_FLAG_LOCAL),
    CREATE_CMD_ENTRY(IPMIB_SHOW_INTERFACE, HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_IPSTATS,   HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_IPADDRESS, HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_IPNET,     HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_ICMP,      HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_TCPSTATS,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_TCPCONN,   HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_UDPSTATS,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_UDPCONN,   HandleIpMibShowObject),
    CREATE_CMD_ENTRY_EX(IPMIB_SHOW_JOINS,  HandleIpShowJoins,CMD_FLAG_LOCAL),
};


CMD_GROUP_ENTRY g_IfIpCmdGroups[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_IfIpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_IfIpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_IfIpDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_IfIpShowCmdTable),
};

ULONG g_ulIfIpNumGroups = sizeof(g_IfIpCmdGroups)/sizeof(CMD_GROUP_ENTRY);


CMD_ENTRY g_IfIpTopCmds[] =
{
    CREATE_CMD_ENTRY_EX(IFIP_RESET, IfIpHandleReset, CMD_FLAG_LOCAL | CMD_FLAG_ONLINE),
};

ULONG g_ulIfIpNumTopCmds = sizeof(g_IfIpTopCmds)/sizeof(CMD_ENTRY);

#define DispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)



DWORD
WINAPI
IfIpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion)
/*++

Routine Description

    Used to initialize the helper.

Arguments

    pguidParent     Ifmon's guid

Return Value

    NO_ERROR
    other error code
--*/
{

    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES       attMyAttributes;


    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = L"ip";
    attMyAttributes.guidHelper  = g_IfIpGuid;
    attMyAttributes.dwVersion   = IFIP_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= g_ulIfIpNumTopCmds;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_IfIpTopCmds;
    attMyAttributes.ulNumGroups = g_ulIfIpNumGroups;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_IfIpCmdGroups;
    attMyAttributes.pfnDumpFn   = IfIpDump;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
WINAPI
IfIpDump(
    IN  LPCWSTR     pwszRouter,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
/*++

Routine Description

    Used when dumping all contexts

Arguments

Return Value

    NO_ERROR

--*/
{
    DWORD   dwErr;
    HANDLE  hFile = (HANDLE)-1;

    DisplayMessage( g_hModule, DMP_IFIP_HEADER );
    DisplayMessageT(DMP_IFIP_PUSHD);

    IfIpShowAllInterfaceInfo(pwszRouter, TYPE_IP_ALL, hFile);

    DisplayMessageT(DMP_IFIP_POPD);
    DisplayMessage( g_hModule, DMP_IFIP_FOOTER );

    return NO_ERROR;
}

DWORD
IfIpHandleSetAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

    NO_ERROR

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_SOURCE,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_MASK,FALSE,FALSE},
        {TOKEN_GATEWAY,FALSE,FALSE},
        {TOKEN_GWMETRIC,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr, dwAddMask, dwAddGateway, dwAddGwmetric;
    PWCHAR      pwszAddAddr, pwszAddMask, pwszAddGateway, pwszAddGwmetric;
    BOOL        EmptyGateway = FALSE;


    // At least interface name & address should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }


            case 1:
            {
                //
                // dhcp or static
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_DHCP, DHCP},
                     {TOKEN_VALUE_STATIC,STATIC}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwAddSource = dwRes ;
                dwBitVector |= IFIP_SOURCE_MASK;
                break;
            }



            case 2:
            {
                //
                // ip address for static
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }


           case 3:
            {
                //
                // get mask
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_NETWORK_MASK(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddMask = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_MASK_MASK;

                break;
            }

            case 4:
            {
                //
                // get default gateway addr
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_NONE, NONE}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    EmptyGateway = TRUE;
                    pwszAddGateway = pwszAddGwmetric = NULL;
                }
                else {
                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                    }

                    pwszAddGateway = ppwcArguments[i + dwCurrentIndex];

                }

                dwBitVector |= IFIP_GATEWAY_MASK;

                break;
            }

            case 5:
            {
                //
                // gwmetric
                //

                dwAddGwmetric =
                        _tcstoul(ppwcArguments[i + dwCurrentIndex], NULL, 10);


                if ( dwAddGwmetric > 9999 )
                {
                    dwErrIndex = i;
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                pwszAddGwmetric = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_GWMETRIC_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;



    // interface name should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)) {
        return ERROR_INVALID_SYNTAX;
    }


    if ( (dwBitVector & (IFIP_ADDR_MASK|IFIP_MASK_MASK))
         && (dwAddSource != STATIC))
    {
        return ERROR_INVALID_SYNTAX;

    }

    if (( (dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_MASK_MASK)  )
        ||( !(dwBitVector&IFIP_ADDR_MASK) && (dwBitVector&IFIP_MASK_MASK)  )
        ||( (dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_SOURCE_MASK)  )
        ||( (dwBitVector&IFIP_GATEWAY_MASK) && !EmptyGateway && !(dwBitVector&IFIP_GWMETRIC_MASK)  )
        ||( !(dwBitVector&IFIP_GATEWAY_MASK) && (dwBitVector&IFIP_GWMETRIC_MASK)  )
        ||((dwAddSource==STATIC) && !(dwBitVector&IFIP_ADDR_MASK)
                && !(dwBitVector&IFIP_GATEWAY_MASK) )
        ||( (dwBitVector&IFIP_GWMETRIC_MASK) && EmptyGateway)
       )
    {
        return ERROR_INVALID_SYNTAX;
    }

    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        if (dwAddSource == DHCP) {

            dwErr = IfIpSetDhcpModeMany(wszIfFriendlyName, &guid, REGISTER_UNCHANGED, TYPE_IPADDR) ;
            RETURN_ERROR_OKAY(dwErr);
        }
        else {

            if (dwBitVector&IFIP_ADDR_MASK) {
                dwErr = IfIpAddSetAddress(wszIfFriendlyName, &guid, pwszAddAddr, pwszAddMask, SET_FLAG);
            }

            if ( (dwBitVector&IFIP_GATEWAY_MASK) && (dwErr == NO_ERROR)) {
                dwErr = IfIpAddSetGateway(wszIfFriendlyName, &guid, pwszAddGateway, pwszAddGwmetric, SET_FLAG);
                RETURN_ERROR_OKAY(dwErr);
            }

            if (dwBitVector&IFIP_ADDR_MASK) {
                RETURN_ERROR_OKAY(dwErr);
            }

            if (!(dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_GATEWAY_MASK)) {

                DisplayMessage(g_hModule, EMSG_STATIC_INPUT);

                return ERROR_SUPPRESS_OUTPUT;
            }
        }

    };

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleSetDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpSetMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleSetWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpSetMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpSetMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_SOURCE,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_REGISTER,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr;
    DWORD       dwRegisterMode = REGISTER_UNCHANGED;
    PWCHAR      pwszAddAddr;


    // At least interface name,source should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }


            case 1:
            {
                //
                // dhcp or static
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_DHCP, DHCP},
                     {TOKEN_VALUE_STATIC,STATIC}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwAddSource = dwRes ;
                dwBitVector |= IFIP_SOURCE_MASK;

                //
                // If DHCP, then ADDR argument is not needed, so if the
                // syntax looks right (only one more argument), but we
                // classified the last argument as ADDR, then reclassify
                // it as REGISTER.
                //
                if ((dwRes == DHCP) && (i+2 == dwNumArg) && (pdwTagType[i+1] == 2))
                {
                    pdwTagType[i+1] = 3;
                }
                break;
            }


            case 2:
            {
                //
                // dns/wins address
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_NONE, NONE}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    pwszAddAddr = NULL;
                }

                else {
                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                }

                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }

            case 3:
            {
                //
                // ddns enabled or disabled
                //

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_NONE,    REGISTER_NONE},
                     {TOKEN_VALUE_PRIMARY, REGISTER_PRIMARY},
                     {TOKEN_VALUE_BOTH,    REGISTER_BOTH}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr != NO_ERROR)
                {
                    dwErrIndex = i;
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                dwRegisterMode = dwRes ;
                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;

    // interface name and source should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
            || (! (dwBitVector & IFIP_SOURCE_MASK))) {
        return ERROR_INVALID_SYNTAX;
    }

    if ( ((dwBitVector & IFIP_ADDR_MASK) && (dwAddSource != STATIC))
        ||(!(dwBitVector & IFIP_ADDR_MASK) && (dwAddSource == STATIC)) )
    {
        return ERROR_INVALID_SYNTAX;
    }

    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        if (dwAddSource == DHCP) {

            return IfIpSetDhcpModeMany(wszIfFriendlyName, &guid, dwRegisterMode, Type) ;
        }
        else {

            return IfIpAddSetDelMany(wszIfFriendlyName, &guid, pwszAddAddr, 0, dwRegisterMode, Type, SET_FLAG);
        }
    }

    return dwErr;
}


DWORD
IfIpHandleAddAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_MASK,FALSE,FALSE},
        {TOKEN_GATEWAY,FALSE,FALSE},
        {TOKEN_GWMETRIC,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr, dwAddMask, dwAddGateway, dwAddGwmetric;
    PWCHAR      pwszAddAddr, pwszAddMask, pwszAddGateway, pwszAddGwmetric;


    if (dwCurrentIndex >= dwArgCount)
    {
        // No arguments specified. At least interface name should be specified.

        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // ip address for static
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }


           case 2:
            {
                //
                // get mask
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_NETWORK_MASK(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddMask = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_MASK_MASK;

                break;
            }

            case 3:
            {
                //
                // get default gateway addr
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddGateway = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_GATEWAY_MASK;

                break;
            }

            case 4:
            {
                //
                // gwmetric
                //

                dwAddGwmetric =
                        _tcstoul(ppwcArguments[i + dwCurrentIndex], NULL, 10);


                if ( dwAddGwmetric > 9999 )
                {
                    dwErrIndex = i;
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                pwszAddGwmetric = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_GWMETRIC_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    // interface name should be present

    if (!pttTags[0].bPresent)
    {
        dwErr = ERROR_INVALID_SYNTAX;
    }


    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;


    // interface name should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK) ) {
        return ERROR_INVALID_SYNTAX;
    }


    if (( (dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_MASK_MASK)  )
        ||( !(dwBitVector&IFIP_ADDR_MASK) && (dwBitVector&IFIP_MASK_MASK)  )
        ||( (dwBitVector&IFIP_GATEWAY_MASK) && !(dwBitVector&IFIP_GWMETRIC_MASK)  )
        ||( !(dwBitVector&IFIP_GATEWAY_MASK) && (dwBitVector&IFIP_GWMETRIC_MASK)  )
       )
    {
        return ERROR_INVALID_SYNTAX;
    }

    {
        GUID guid;

        if (FAILED(CLSIDFromString(wszInterfaceName, &guid))) {
            return ERROR_INVALID_PARAMETER;
        }

        if (dwBitVector&IFIP_ADDR_MASK) {
            dwErr = IfIpAddSetAddress(wszIfFriendlyName, &guid, pwszAddAddr, pwszAddMask, ADD_FLAG);
        }

        if ( (dwBitVector&IFIP_GATEWAY_MASK) && (dwErr == NO_ERROR)) {

            dwErr = IfIpAddSetGateway(wszIfFriendlyName, &guid, pwszAddGateway, pwszAddGwmetric, ADD_FLAG);

            RETURN_ERROR_OKAY(dwErr);
        }

        if (dwBitVector&IFIP_ADDR_MASK) {
            RETURN_ERROR_OKAY(dwErr);
        }

        if (!(dwBitVector&IFIP_ADDR_MASK) && !(dwBitVector&IFIP_GATEWAY_MASK)) {

            DisplayMessage(g_hModule, EMSG_STATIC_INPUT);

            return ERROR_SUPPRESS_OUTPUT;
        }
    }

    RETURN_ERROR_OKAY(dwErr);
}

DWORD
IfIpHandleAddDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpAddMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleAddWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;

    dwErr = IfIpAddMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpAddMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_INDEX,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    DWORD       dwAddSource, dwAddAddr, dwAddIndex=~(0);
    PWCHAR      pwszAddAddr;


    // At least interface name/new address should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // dns/wins address
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwAddAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwAddAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                pwszAddAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }


            case 2:
            {
                //
                // index
                //

                dwAddIndex =
                        _tcstoul(ppwcArguments[i + dwCurrentIndex], NULL, 10);


                if ( (dwAddIndex <= 0 || dwAddIndex > 999) )
                {
                    dwErrIndex = i;
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                dwBitVector |= IFIP_INDEX_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;

    // interface name and new address should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
            || (! (dwBitVector & IFIP_ADDR_MASK))) {
        return ERROR_INVALID_SYNTAX;
    }


    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        return IfIpAddSetDelMany(wszIfFriendlyName, &guid, pwszAddAddr, dwAddIndex, REGISTER_UNCHANGED, Type, ADD_FLAG);
    }

    return dwErr;
}


DWORD
IfIpHandleDelAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE},
        {TOKEN_GATEWAY,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j, Flags = 0;
    PWCHAR      pwszDelAddr=NULL, pwszDelGateway=NULL;


    // At least interface name and ipaddr/gateway should be specified.

    if (dwCurrentIndex + 1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {

            case 0 :
            {
                // get IfName

                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }

                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // ip address for static
                //

                ULONG dwDelAddr;

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwDelAddr);

                if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwDelAddr))
                {
                    DispTokenErrMsg(g_hModule,
                                    EMSG_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;

                }

                pwszDelAddr = ppwcArguments[i + dwCurrentIndex];
                dwBitVector |= IFIP_ADDR_MASK;
                Flags |= TYPE_ADDR;

                break;
            }

            case 2:
            {
                //
                // get default gateway addr
                //

                ULONG dwDelGateway;
                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_ALL, ALL}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    pwszDelGateway = NULL;
                }
                else {

                    dwErr = NO_ERROR;

                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex],
                                     &dwDelGateway);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwDelGateway))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    pwszDelGateway = ppwcArguments[i + dwCurrentIndex];
                }

                dwBitVector |= IFIP_GATEWAY_MASK;
                Flags |= TYPE_GATEWAY;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }


    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;


    // interface name and addr/all should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
        || !(dwBitVector & (IFIP_GATEWAY_MASK | IFIP_ADDR_MASK))
        ) {
        return ERROR_INVALID_SYNTAX;
    }


    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        dwErr = IfIpHandleDelIpaddrEx(wszIfFriendlyName, &guid, pwszDelAddr, pwszDelGateway, Flags);

        RETURN_ERROR_OKAY(dwErr);
    }

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleDelDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;
    dwErr = IfIpDelMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );

    RETURN_ERROR_OKAY(dwErr);
}


DWORD
IfIpHandleDelWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr;
    dwErr = IfIpDelMany(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );

    RETURN_ERROR_OKAY(dwErr);
}

DWORD
IfIpDelMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE Type
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    DWORD       dwErr = NO_ERROR,dwRes, dwErrIndex=-1;
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE},
        {TOKEN_ADDR,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i, j;
    PWCHAR      pwszDelAddr=NULL;


    // At least interface name/address should be specified.

    if (dwCurrentIndex +1 >= dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }


    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        NUM_TAGS_IN_TABLE(pttTags),
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {

            case 0 :
            {
                // get IfName

                dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                 wszInterfaceName,&dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                        ppwcArguments[i + dwCurrentIndex]);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                    break;
                }


                wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                dwBitVector |= IFIP_IFNAME_MASK;

                break;
            }

            case 1:
            {
                //
                // address
                //

                ULONG dwDelAddr;

                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_ALL, ALL}};

                dwErr = MatchEnumTag(g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      NUM_TOKENS_IN_TABLE(rgEnums),
                                      rgEnums,
                                      &dwRes);

                if (dwErr == NO_ERROR) {
                    pwszDelAddr = NULL;
                }
                else {

                    dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &dwDelAddr);

                    if((dwErr != NO_ERROR) or CHECK_UNICAST_IP_ADDR(dwDelAddr))
                    {
                        DispTokenErrMsg(g_hModule,
                                        EMSG_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }

                    pwszDelAddr = ppwcArguments[i + dwCurrentIndex];
                }

                dwBitVector |= IFIP_ADDR_MASK;

                break;
            }

            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        } //switch

        if (dwErr != NO_ERROR)
            break ;

     }


    switch(dwErr)
    {
        case NO_ERROR :
            break;

        case ERROR_INVALID_PARAMETER:
            if (dwErrIndex != -1)
            {
                DispTokenErrMsg(g_hModule,
                                EMSG_BAD_OPTION_VALUE,
                                pttTags[pdwTagType[dwErrIndex]].pwszTag,
                                ppwcArguments[dwErrIndex + dwCurrentIndex]);
                dwErr = ERROR_SUPPRESS_OUTPUT;
            }
            break;

        default:
            // error message already printed
            break;
    }

    if (pdwTagType)
        IfutlFree(pdwTagType);

    if (dwErr != NO_ERROR)
        return dwErr;


    // interface name and address should be present

    if ( !(dwBitVector & IFIP_IFNAME_MASK)
        || !(dwBitVector & IFIP_ADDR_MASK)) {
        return ERROR_INVALID_SYNTAX;
    }


    {
        GUID guid;

        CLSIDFromString(wszInterfaceName, &guid);

        return IfIpAddSetDelMany(wszIfFriendlyName, &guid, pwszDelAddr, 0, REGISTER_UNCHANGED, Type, DEL_FLAG);
    }
}

DWORD
IfIpHandleShowAddress(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_IPADDR
                );
}



DWORD
IfIpHandleShowConfig(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_IP_ALL
                );
}

DWORD
IfIpHandleShowOffload(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_OFFLOAD
                );
}


DWORD
IfIpHandleShowDns(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_DNS
                );
}


DWORD
IfIpHandleShowWins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    return IfIpShowMany(
                pwszMachine,
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                pbDone,
                TYPE_WINS
                );
}

DWORD
IfIpShowMany(
    IN  LPCWSTR pwszMachineName,
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE  dtType
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD dwErr = NO_ERROR;
    ULONG Flags = 0, IfIndex;
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    PWCHAR      wszIfFriendlyName = NULL;

    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    TAG_TYPE    pttTags[] = {
        {TOKEN_NAME,FALSE,FALSE}};

    PDWORD      pdwTagType;
    DWORD       dwNumOpt, dwBitVector=0;
    DWORD       dwNumArg, i;
    BOOLEAN     bAll = FALSE;

    //
    // get interface friendly name
    //

    if (dwCurrentIndex > dwArgCount)
    {
        // No arguments specified. At least interface name should be specified.

        return ERROR_SHOW_USAGE;
    }
    else if (dwCurrentIndex == dwArgCount)
    {
        // show for all interfaces

        bAll = TRUE;
    }

    else {

        dwNumArg = dwArgCount - dwCurrentIndex;

        pdwTagType = HeapAlloc(GetProcessHeap(),
                               0,
                               dwNumArg * sizeof(DWORD));

        if (pdwTagType is NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwErr = MatchTagsInCmdLine(g_hModule,
                            ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            pttTags,
                            NUM_TAGS_IN_TABLE(pttTags),
                            pdwTagType);

        if (dwErr isnot NO_ERROR)
        {
            IfutlFree(pdwTagType);
            if (dwErr is ERROR_INVALID_OPTION_TAG)
            {
                return ERROR_INVALID_SYNTAX;
            }

            return dwErr;
        }

        for ( i = 0; i < dwNumArg; i++)
        {
            switch (pdwTagType[i])
            {
                case 0 :
                {
                    dwErr = GetIfNameFromFriendlyName(ppwcArguments[i + dwCurrentIndex],
                                                     wszInterfaceName,&dwBufferSize);

                    if (dwErr isnot NO_ERROR)
                    {
                        DisplayMessage(g_hModule, EMSG_INVALID_INTERFACE,
                            ppwcArguments[i + dwCurrentIndex]);
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }


                    wszIfFriendlyName = ppwcArguments[i + dwCurrentIndex];

                    dwBitVector |= IFIP_IFNAME_MASK;

                    break;
                }

                default:
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

            } //switch

            if (dwErr != NO_ERROR)
                break ;

         }


        // interface name should be present

        if (!pttTags[0].bPresent)
        {
            dwErr = ERROR_INVALID_SYNTAX;
        }


        if (pdwTagType)
            IfutlFree(pdwTagType);

    }

    if (dwErr != NO_ERROR)
        return dwErr;


    //
    // show for all interfaces
    //

    if (bAll) {

        dwErr = IfIpShowAllInterfaceInfo(pwszMachineName, dtType, NULL);
    }

    // show for specified interface
    else {

        GUID guid;

        dwErr = IfutlGetIfIndexFromInterfaceName(
                wszInterfaceName,
                &IfIndex);

        CLSIDFromString(wszInterfaceName, &guid);


        dwErr = IfIpShowManyEx(pwszMachineName,
                               IfIndex, wszIfFriendlyName, &guid, dtType, NULL);
        if (dwErr != NO_ERROR)
            return dwErr;
    }

    return dwErr;
}

DWORD
IfIpShowAllInterfaceInfo(
    LPCWSTR pwszMachineName,
    DISPLAY_TYPE dtType,
    HANDLE hFile
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    GUID    TmpGuid;
    PWCHAR  TmpGuidStr;
    WCHAR   wszIfFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PIP_INTERFACE_NAME_INFO pTable;
    DWORD dwErr, dwCount, i, dwBufferSize;

    // get interface index

    dwErr = NhpAllocateAndGetInterfaceInfoFromStack(
                &pTable,
                &dwCount,
                FALSE,
                GetProcessHeap(),
                0);

    if (dwErr != NO_ERROR)
        return dwErr;


    for (i=0;  i<dwCount;  i++) {

        // Don't dump the properties for
        // Demand Dial (IF_CONNECTION_DEMAND),
        // Dial Out    (IF_CONNECTION_DEMAND),
        // or Dial in  (IF_CONNECTION_PASSIVE) interfaces
        // i.e. dump properties for Dedicated connections only
        if ( pTable[i].ConnectionType != IF_CONNECTION_DEDICATED )
            continue;


        // If InterfaceGuid is all Zeros we will use DeviceGuid to get the
        // friendly name
        if ( IsEqualCLSID(&(pTable[i].InterfaceGuid), &GUID_NULL) ) {
            TmpGuid = pTable[i].DeviceGuid;
        }
        else {
            TmpGuid = pTable[i].InterfaceGuid;
        }


        // get ifname as a string
        dwErr = StringFromCLSID(&TmpGuid, &TmpGuidStr);
        if (dwErr != S_OK)
            return dwErr;


        // get friendly name
        dwBufferSize = sizeof(wszIfFriendlyName);
        IfutlGetInterfaceDescription(TmpGuidStr, wszIfFriendlyName,
                        &dwBufferSize);


        IfIpShowManyEx(pwszMachineName, pTable[i].Index, wszIfFriendlyName,
                    &TmpGuid, dtType, hFile);

        CoTaskMemFree(TmpGuidStr);
    }

    return dwErr==S_OK ? NO_ERROR : dwErr;
}


DWORD
IfIpHandleDelArpCache(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD       dwErr, dwCount, i, j, dwNumArg;
    TAG_TYPE    Tags[] = {{TOKEN_NAME,FALSE,FALSE}};
    PDWORD      pdwTagType;
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       dwBufferSize = sizeof(wszInterfaceName);
    GUID        Guid;

    PIP_INTERFACE_NAME_INFO pTable;

    dwErr = NhpAllocateAndGetInterfaceInfoFromStack(&pTable,
                                                    &dwCount,
                                                    FALSE,
                                                    GetProcessHeap(),
                                                    0);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    if(dwNumArg == 0)
    {
        for(i = 0 ; i < dwCount; i++)
        {
            dwErr = FlushIpNetTableFromStack(pTable[i].Index);
        }

        return ERROR_OKAY;
    }

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               Tags,
                               NUM_TAGS_IN_TABLE(Tags),
                               pdwTagType);

    if(dwErr isnot NO_ERROR)
    {
        IfutlFree(pdwTagType);

        if(dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for(j = 0; j < dwNumArg; j++)
    {
        switch(pdwTagType[j])
        {
            case 0 :
            {
                dwErr = GetIfNameFromFriendlyName(
                            ppwcArguments[j + dwCurrentIndex],
                            wszInterfaceName,
                            &dwBufferSize);

                if (dwErr isnot NO_ERROR)
                {
                    j = dwNumArg;

                    break;
                }

                CLSIDFromString(wszInterfaceName, &Guid);

                for(i = 0; i < dwCount; i ++)
                {
                    if(IsEqualGUID(&Guid,
                                   &(pTable[i].DeviceGuid)))
                    {
                        FlushIpNetTableFromStack(pTable[i].Index);
                        break;
                    }
                }

                if(i == dwCount)
                {
                    DisplayMessage(g_hModule,
                                   MSG_NO_SUCH_IF,
                                   ppwcArguments[j + dwCurrentIndex]);

                    dwErr = ERROR_SUPPRESS_OUTPUT;
                }

                break;
            }

            default:
            {
                j = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    if(dwErr == NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;

}

DWORD
TrRepair(
    FILE* LogFile
    );

DWORD
IfIpHandleReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    DWORD       dwErr, i;
    TAG_TYPE    pttTags[] = {{TOKEN_NAME,TRUE,FALSE}};
    DWORD       rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    PCWSTR      pwszLogFileName;
    FILE        *LogFile;

    // Parse arguments

    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    for (i=0; (dwErr == NO_ERROR) && (i<dwArgCount-dwCurrentIndex); i++) {
        switch(rgdwTagType[i]) {
        case 0: // NAME
            pwszLogFileName = ppwcArguments[i + dwCurrentIndex];
            break;
        default:
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
    }

    if (dwErr isnot NO_ERROR) {
        return dwErr;
    }

    // Open the log file for append.
    //
    LogFile = _wfopen(pwszLogFileName, L"a+");
    if (LogFile == NULL) {
        DisplayMessage(g_hModule, EMSG_OPEN_APPEND);
        return ERROR_SUPPRESS_OUTPUT;
    }

    dwErr = TrRepair(LogFile);

    fprintf(LogFile, "<completed>\n\n");
    fclose(LogFile);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\precomp.h ===
#define MAX_DLL_NAME    48

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>

#include <netcfgx.h>
#include <netcfgn.h>
#include <netcfgp.h>
#include <netcon.h>
#include <setupapi.h>
#include <devguid.h>


#include <rpc.h>
#include <rtutils.h>
#include <mprerror.h>
#include <ras.h>
#include <raserror.h>
#include <mprapi.h>
#include <nhapi.h>

#include <netsh.h>
#include <netshp.h>

// These 5 includes required by IP Tunnels
// The requirement for so many files should hopefully go away soon
#include <fltdefs.h>  // reqd by iprtinfo.h below
#include <iprtinfo.h> // required for IPINIP_CONFIG_INFO
#include <ipmontr.h>  // reqd for ADDR_LENGTH, IP_TO_WSTR
#include <ipinfoid.h> // reqd for IP_IPINIP_CFG_INFO
#include <rtinfo.h>   // reqd for RTR_INFO_BLOCK_HEADER

#include "strdefs.h"
#include "ifstring.h"
#include "defs.h"
#include "ifmon.h"
#include "routerdb.h"
#include "routerif.h"
#include "ifhandle.h"
#include "utils.h"

// required for ifip
#include "context.h"
#include <ipexport.h>
#include <ipinfo.h>
#include <iprtrmib.h>
#include <ntddip.h>
#include <iphlpstk.h>
#include "showmib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifip.h ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
// File: ifip.h
//
// Author: K.S.Lokesh (lokeshs@)   8-1-99
//=============================================================================


#ifndef __IFIP_H
#define __IFIP_H


#define DBG1 0

//kslksl

#define TCP_XMT_CHECKSUM_OFFLOAD  0x00000001
#define IP_XMT_CHECKSUM_OFFLOAD   0x00000002
#define TCP_RCV_CHECKSUM_OFFLOAD  0x00000004
#define IP_RCV_CHECKSUM_OFFLOAD   0x00000008
#define TCP_LARGE_SEND_OFFLOAD    0x00000010

//
// IPSEC General Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_CRYPTO_ONLY   0x00000020      // Raw crypto mode supported
#define IPSEC_OFFLOAD_AH_ESP        0x00000040      // Combined AH+ESP supported
#define IPSEC_OFFLOAD_TPT_TUNNEL    0x00000080      // Combined Tpt+Tunnel supported
#define IPSEC_OFFLOAD_V4_OPTIONS    0x00000100      // IPV4 Options supported
#define IPSEC_OFFLOAD_QUERY_SPI     0x00000200      // Get SPI supported

//
// IPSEC AH Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_AH_XMT        0x00000400      // IPSEC supported on Xmit
#define IPSEC_OFFLOAD_AH_RCV        0x00000800      // IPSEC supported on Rcv
#define IPSEC_OFFLOAD_AH_TPT        0x00001000      // IPSEC transport mode supported
#define IPSEC_OFFLOAD_AH_TUNNEL     0x00002000      // IPSEC tunnel mode supported
#define IPSEC_OFFLOAD_AH_MD5        0x00004000      // MD5 supported as AH and ESP algo
#define IPSEC_OFFLOAD_AH_SHA_1      0x00008000      // SHA_1 supported as AH and ESP algo

//
// IPSEC ESP Xmit\Recv capabilities
//
#define IPSEC_OFFLOAD_ESP_XMT       0x00010000      // IPSEC supported on Xmit
#define IPSEC_OFFLOAD_ESP_RCV       0x00020000      // IPSEC supported on Rcv
#define IPSEC_OFFLOAD_ESP_TPT       0x00040000      // IPSEC transport mode supported
#define IPSEC_OFFLOAD_ESP_TUNNEL    0x00080000      // IPSEC tunnel mode supported
#define IPSEC_OFFLOAD_ESP_DES       0x00100000      // DES supported as ESP algo
#define IPSEC_OFFLOAD_ESP_DES_40    0x00200000      // DES40 supported as ESP algo
#define IPSEC_OFFLOAD_ESP_3_DES     0x00400000      // 3DES supported as ESP algo
#define IPSEC_OFFLOAD_ESP_NONE      0x00800000      // Null ESP supported as ESP algo





#define IFIP_GUID \
{0x89d00931, 0x1e00, 0x11d3, {0x87, 0x38, 0x00, 0x60, 0x08, 0x37, 0xc7, 0x75} }


#define IFIP_VERSION 1

#define ADD_FLAG 1
#define SET_FLAG 2
#define DEL_FLAG 4

#define RETURN_ERROR_OKAY(dwErr) \
    return (dwErr) == NO_ERROR? ERROR_OKAY : dwErr;


#if DBG1
#define DEBUG_PRINT_CONFIG(pRemoteIpInfo) {\
        DisplayMessage(g_hModule, MSG_DEBUG_HDR);\
        DisplayMessage(g_hModule,\
                   MSG_IPADDR_LIST,\
                   (pRemoteIpInfo)->pszwIpAddrList,\
                   (pRemoteIpInfo)->pszwSubnetMaskList);\
    \
        DisplayMessage(g_hModule,\
                   MSG_OPTIONS_LIST,\
                   (pRemoteIpInfo)->pszwOptionList);\
        DisplayMessage(g_hModule, MSG_DEBUG_HDR);\
    \
}
#else
#define DEBUG_PRINT_CONFIG(pRemoteIpInfo)
#endif

typedef enum _DISPLAY_TYPE {
    TYPE_ADDR=0x01,
    TYPE_GATEWAY=0x02,
    TYPE_IPADDR=0x03,
    TYPE_DNS=0x04,
    TYPE_WINS=0x08,
    TYPE_IFMETRIC=0x10,
    TYPE_DDNS=0x20,
    TYPE_IP_ALL=0xff,

    TYPE_OFFLOAD=0x0100
} DISPLAY_TYPE;

typedef enum _REGISTER_MODE {
    REGISTER_NONE      = 0,
    REGISTER_PRIMARY   = 1,
    REGISTER_BOTH      = 3,
    REGISTER_UNCHANGED = 0xff
} REGISTER_MODE;

NS_HELPER_START_FN IfIpStartHelper;
NS_CONTEXT_DUMP_FN  IfIpDump;

FN_HANDLE_CMD IfIpHandleSetAddress;
FN_HANDLE_CMD IfIpHandleSetDns;
FN_HANDLE_CMD IfIpHandleSetWins;
FN_HANDLE_CMD IfIpHandleAddAddress;
FN_HANDLE_CMD IfIpHandleAddDns;
FN_HANDLE_CMD IfIpHandleAddWins;
FN_HANDLE_CMD IfIpHandleSetLmhosts;


DWORD
IfIpAddMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    );

DWORD
IfIpSetDhcpModeMany(
    LPCWSTR     pwszIfFriendlyName,
    GUID         *pGuid,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type
    );

DWORD
IfIpAddSetAddress(
    LPCWSTR     pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszAddr,
    LPCWSTR      pwszMask,
    DWORD        Flags
    );

DWORD
IfIpAddSetGateway(
    LPCWSTR pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszGateway,
    LPCWSTR      pwszGatewayMetric,
    DWORD        Flags
    );

FN_HANDLE_CMD IfIpHandleDelAddress;
FN_HANDLE_CMD IfIpHandleDelDns;
FN_HANDLE_CMD IfIpHandleDelWins;

DWORD
IfIpDelMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE Type
    );

FN_HANDLE_CMD IfIpHandleShowConfig;
FN_HANDLE_CMD IfIpHandleShowAddress;
FN_HANDLE_CMD IfIpHandleShowOffload;
FN_HANDLE_CMD IfIpHandleShowDns;
FN_HANDLE_CMD IfIpHandleShowWins;
FN_HANDLE_CMD IfIpHandleDelArpCache;
FN_HANDLE_CMD IfIpHandleReset;

DWORD
ShowInfoIpaddr(
    ULONG       IfIndex,
    GUID        *pGuid,
    PWCHAR      pFriendlyIfName
    );

DWORD
IfIpShowMany(
    IN  LPCWSTR pwszMachineName,
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DISPLAY_TYPE  dtType
    );

DWORD
IfIpShowAllInterfaceInfo(
    LPCWSTR pwszMachineName,
    DISPLAY_TYPE Type,
    HANDLE hFile
    );

DWORD
IfIpHandleDelIpaddrEx(
    LPCWSTR wszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszIpAddr,
    LPCWSTR      pwszGateway,
    ULONG        Flags
    );

DWORD
OpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    );

NTSTATUS
DoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );


DWORD
IfIpShowManyEx(
    LPCWSTR pwszMachineName,
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName,
    GUID *guid,
    DISPLAY_TYPE dtType,
    HANDLE hFile
    );

DWORD
IfIpShowManyExEx(
    LPCWSTR     pwszMachineName,
    ULONG       IfIndex,
    PWCHAR      pFriendlyIfName,
    GUID       *pGuid,
    ULONG       Flags,
    HANDLE      hFile
    );

DWORD
IfIpShowInfoOffload(
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName
    );

DWORD
IfIpGetInfoOffload(
    ULONG IfIndex,
    PULONG Flags
    );

DWORD
IfIpSetMany(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone,
    IN  DWORD   Type
    );

DWORD
IfIpAddSetDelMany(
    PWCHAR wszIfFriendlyName,
    GUID         *pGuid,
    PWCHAR       pwszAddress,
    DWORD        dwIndex,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type,
    DWORD        Flags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\ifmon.h   

Abstract:

     Prototype for fns called in ipmon.c

Author:

     Anand Mahalingam    7/10/98

--*/


#ifndef _IFMON_H_
#define _IFMON_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


extern HANDLE   g_hModule;
extern HANDLE   g_hMprConfig; 
extern HANDLE   g_hMprAdmin;
extern HANDLE   g_hMIBServer;
extern BOOL     g_bCommit;
extern DWORD    g_dwNumTableEntries;
extern PWCHAR   g_pwszRouter;
extern BOOL     g_bIfDirty;

//
// Api's that ifmon requires of its helpers
//
typedef
DWORD
(WINAPI IF_CONTEXT_ENTRY_FN)(
    IN    PWCHAR               pwszMachineName,
    IN    PTCHAR               *pptcArguments,
    IN    DWORD                dwArgCount,
    IN    DWORD                dwFlags,
    IN    MIB_SERVER_HANDLE    hMibServer,
    OUT   PWCHAR               pwcNewContext
    );
typedef IF_CONTEXT_ENTRY_FN *PIF_CONTEXT_ENTRY_FN;

extern GUID g_IfGuid;

DWORD
ShowMIB(
    MIB_SERVER_HANDLE    hMIBServer,
    PTCHAR                *pptcArguments,
    DWORD                dwArgCount
    );

NS_CONTEXT_COMMIT_FN IfCommit;
NS_CONTEXT_DUMP_FN   IfDump;

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    );

BOOL
WINAPI
IfDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    );

DWORD
WINAPI
IfUnInit(
    IN  DWORD   dwReserved
    );

#define GetIfNameFromFriendlyName(x,y,z) \
      NsGetIfNameFromFriendlyName(g_hMprConfig,x,y,z)
#define GetFriendlyNameFromIfName(x,y,z) \
      NsGetFriendlyNameFromIfName(g_hMprConfig,x,y,z)



#ifdef __cplusplus
}
#endif

#endif // _IFMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifip1.c ===
//=============================================================================
// Copyright (c) 1999 Microsoft Corporation
// File: ifip1.c
// Abstract:
//      This module implements the helpers for if/ip apis
//
// Author: K.S.Lokesh (lokeshs@)   8-1-99
//=============================================================================


#include "precomp.h"
#include "ifip.h"
#include <iphlpapi.h>
#include <iptypes.h>
#include "ifstring.h"

const WCHAR c_wszListSeparatorComma[] = L",";
const WCHAR c_wListSeparatorComma = L',';
const WCHAR c_wListSeparatorSC = L';';
const WCHAR c_wszListSeparatorSC[] = L";";
const WCHAR c_wcsDefGateway[] = L"DefGw=";
const WCHAR c_wcsGwMetric[] = L"GwMetric=";
const WCHAR c_wcsIfMetric[] = L"IfMetric=";
const WCHAR c_wcsDns[] = L"DNS=";
const WCHAR c_wcsDdns[] = L"DynamicUpdate=";
const WCHAR c_wcsDdnsSuffix[] = L"NameRegistration=";
const WCHAR c_wcsWins[] = L"WINS=";
const WCHAR c_wEqual = L'=';


BOOL g_fInitCom = TRUE;



HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc
    )
/*++

Routine Description

    Uninitializes and unlocks the INetCfg object
    
Arguments

    pnc [in]    INetCfg to uninitialize and unlock
    
Return Value

    S_OK if success, OLE or Win32 error otherwise

Author:     danielwe   13 Nov 1997

--*/
{
    HRESULT     hr = S_OK;

    hr = pnc->lpVtbl->Uninitialize(pnc);
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->lpVtbl->QueryInterface(pnc, &IID_INetCfgLock,
                                 (LPVOID *)(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->lpVtbl->ReleaseWriteLock(pnclock);

            if (pnclock)
            {
                pnclock->lpVtbl->Release(pnclock);
            }
            pnclock = NULL;
        }
    }

    // TraceResult("HrUninitializeAndUnlockINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
//    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->lpVtbl->Uninitialize (pnc);
    }

    if (pnc)
    {
        pnc->lpVtbl->Release(pnc);
    }
    
    pnc = NULL;

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    // TraceResult("HrUninitializeAndReleaseINetCfg", hr);
    return hr;
}


/*!--------------------------------------------------------------------------
    HrGetIpPrivateInterface
        -
    Author: TongLu, KennT
 ---------------------------------------------------------------------------*/
HRESULT HrGetIpPrivateInterface(INetCfg* pNetCfg,
                                ITcpipProperties **ppTcpProperties
                                )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    HRESULT hr;
    INetCfgClass* pncclass = NULL;

    if ((pNetCfg == NULL) || (ppTcpProperties == NULL))
        return E_INVALIDARG;

    hr = pNetCfg->lpVtbl->QueryNetCfgClass (pNetCfg, &GUID_DEVCLASS_NETTRANS, &IID_INetCfgClass,
                (void**)(&pncclass));
    if (SUCCEEDED(hr))
    {
        INetCfgComponent * pnccItem = NULL;

        // Find the component.
        hr = pncclass->lpVtbl->FindComponent(pncclass, TEXT("MS_TCPIP"), &pnccItem);
        //AssertSz (SUCCEEDED(hr), "pncclass->Find failed.");
        if (S_OK == hr)
        {
            INetCfgComponentPrivate* pinccp = NULL;
            hr = pnccItem->lpVtbl->QueryInterface(pnccItem, &IID_INetCfgComponentPrivate,
                                          (void**)(&pinccp));
            if (SUCCEEDED(hr))
            {
                hr = pinccp->lpVtbl->QueryNotifyObject(pinccp, &IID_ITcpipProperties,
                                     (void**)(ppTcpProperties));
                pinccp->lpVtbl->Release(pinccp);
            }
        }

        if (pnccItem)
            pnccItem->lpVtbl->Release(pnccItem);
    }

    if (pncclass)
        pncclass->lpVtbl->Release(pncclass);

    // S_OK indicates success (interface returned)
    // S_FALSE indicates Ipx not installed
    // other values are errors
    // TraceResult("HrGetIpPrivateInterface", hr);
    return hr;
}








HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR *    ppszwClientDesc
    )
/*++

Routine Description

    Cocreate and initialize the root INetCfg object.  This will
    optionally initialize COM for the caller too.

Arguments

    pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
                               returns TRUE if COM was successfully
                               initialized FALSE if not.  If NULL, means
                               don't initialize COM.
    ppnc            [out]  The returned INetCfg object.
    fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
    cmsTimeout      [in]   See INetCfg::LockForWrite
    szwClientDesc   [in]   See INetCfg::LockForWrite
    ppszwClientDesc [out]   See INetCfg::LockForWrite    
    
Return Value

    S_OK or an error code.
    
--*/
{
    HRESULT hr;
    

    // Initialize the output parameter.
    *ppnc = NULL;

    if (ppszwClientDesc)
        *ppszwClientDesc = NULL;

    // Initialize COM if the caller requested.
    hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            if (pfInitCom)
            {
                *pfInitCom = FALSE;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(&CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              &IID_INetCfg, (void**)(&pnc));
        // TraceResult("HrCreateAndInitializeINetCfg - CoCreateInstance(CLSID_CNetCfg)", hr);
        if (SUCCEEDED(hr))
        {
            INetCfgLock* pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->lpVtbl->QueryInterface(pnc, &IID_INetCfgLock,
                                         (LPVOID *)(&pnclock));
                // TraceResult("HrCreateAndInitializeINetCfg - QueryInterface(IID_INetCfgLock", hr);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->lpVtbl->AcquireWriteLock(pnclock, cmsTimeout, szwClientDesc,
                                               ppszwClientDesc);
                    // TraceResult("HrCreateAndInitializeINetCfg - INetCfgLock::LockForWrite", hr);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->lpVtbl->Initialize (pnc, NULL);
                // TraceResult("HrCreateAndInitializeINetCfg - Initialize", hr);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    if (pnc)
                        pnc->lpVtbl->AddRef(pnc);
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->lpVtbl->ReleaseWriteLock(pnclock);
                    }
                }
                // Transfer reference to caller.
            }

            if (pnclock)
            {
                pnclock->lpVtbl->Release(pnclock);
            }
            
            pnclock = NULL;


            if (pnc)
            {
                pnc->lpVtbl->Release(pnc);
            }
            
            pnc = NULL;
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }

    }

    return hr;
}

DWORD
GetTransportConfig(
    INetCfg **   pNetCfg,
    ITcpipProperties ** pTcpipProperties,
    REMOTE_IPINFO   **pRemoteIpInfo,
    GUID *pGuid,
    LPCWSTR pwszIfFriendlyName
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    WCHAR    wszDesc[] = L"Test of Change IP settings";
    HRESULT  hr;

    // Create the INetCfg, we get the write lock because we need read and write
    hr = HrCreateAndInitializeINetCfg(&g_fInitCom, /* &g_fInitCom, */
                                      pNetCfg,
                                      TRUE /* fGetWriteLock */,  
                                      500     /* cmsTimeout */,
                                      wszDesc/* swzClientDesc */,
                                      NULL  /* ppszwClientDesc */);
    
    if (hr == S_OK)
    {
        hr = HrGetIpPrivateInterface(*pNetCfg, pTcpipProperties);
    }

    if (hr == NETCFG_E_NO_WRITE_LOCK) {

        DisplayMessage( g_hModule, EMSG_NETCFG_WRITE_LOCK );
        return ERROR_SUPPRESS_OUTPUT;
    }
    
    if (hr == S_OK)
    {
        hr = (*pTcpipProperties)->lpVtbl->GetIpInfoForAdapter(*pTcpipProperties, pGuid, pRemoteIpInfo);

        if (hr != S_OK)
        {
            DisplayMessage(g_hModule, EMSG_PROPERTIES, pwszIfFriendlyName);
            hr = ERROR_SUPPRESS_OUTPUT;
        }
    }

    return (hr==S_OK) ? NO_ERROR : hr;
}


VOID
UninitializeTransportConfig(
    INetCfg *   pNetCfg,
    ITcpipProperties * pTcpipProperties,
    REMOTE_IPINFO   *pRemoteIpInfo
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    if (pTcpipProperties)
        pTcpipProperties->lpVtbl->Release(pTcpipProperties);

    if (pNetCfg)
    {
        HrUninitializeAndReleaseINetCfg(FALSE,
                                        pNetCfg,
                                        TRUE   /* fHasLock */);
    }

    if (pRemoteIpInfo) CoTaskMemFree(pRemoteIpInfo);
    
    return;
}
    
DWORD
IfIpAddSetAddress(
    LPCWSTR pwszIfFriendlyName,
    GUID *pGuid,
    LPCWSTR wszIp,
    LPCWSTR wszMask,
    DWORD Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    

    if (pGuid == NULL)
        return E_INVALIDARG;


    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pwszIfFriendlyName
                );
        

    while (hr == NO_ERROR) { //breakout block
    
        PWCHAR ptrAddr, ptrMask;
        DWORD Found = FALSE;
        PWCHAR pszwRemoteIpAddrList=NULL, pszwRemoteIpSubnetMaskList=NULL,
                pszwRemoteOptionList=pRemoteIpInfo->pszwOptionList;//i copy options list
        PWCHAR IpAddrListEnd;
        ULONG Length = wcslen(wszIp);

        // currently in static mode
        
        if (pRemoteIpInfo->dwEnableDhcp == FALSE) {

            pszwRemoteIpAddrList = pRemoteIpInfo->pszwIpAddrList;
            pszwRemoteIpSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
            IpAddrListEnd = pszwRemoteIpAddrList + wcslen(pszwRemoteIpAddrList);
        }

        
        //
        // if adding ipaddr, check if the IpAddr and Mask is already present
        //

        if (Flags & ADD_FLAG) {

            //
            // make sure it is in static mode
            //
            
            if (pRemoteIpInfo->dwEnableDhcp == TRUE) {

                DisplayMessage(g_hModule,
                           EMSG_ADD_IPADDR_DHCP);

                hr = ERROR_SUPPRESS_OUTPUT;
                break;
            }
            
            ptrAddr = pszwRemoteIpAddrList;
            ptrMask = pszwRemoteIpSubnetMaskList;

            while (ptrAddr && (ptrAddr + Length <= IpAddrListEnd) ){

                if (wcsncmp(ptrAddr, wszIp, Length) == 0) {

                    if ( *(ptrAddr+Length)==0 || *(ptrAddr+Length)==c_wListSeparatorComma){

                        Found = TRUE;
                        break;
                    }
                }

                ptrAddr = wcschr(ptrAddr, c_wListSeparatorComma);
                ptrMask = wcschr(ptrMask, c_wListSeparatorComma);

                if (ptrAddr){
                    ptrAddr++;
                    ptrMask++;
                }
            }
            
            if (Found) {

                PWCHAR MaskEnd;
                MaskEnd = wcschr(ptrMask, c_wListSeparatorComma);
                if (MaskEnd)
                    *MaskEnd = 0;
                    
                DisplayMessage(g_hModule,
                           EMSG_IPADDR_PRESENT,
                           wszIp, ptrMask);

                if (MaskEnd)
                    *MaskEnd = c_wListSeparatorComma;
                
                hr = ERROR_SUPPRESS_OUTPUT;
                break;
            }
        }
        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(newIPInfo));
        newIPInfo.dwEnableDhcp = FALSE;

        //
        // copy ip addr list
        //
        
        if (Flags & ADD_FLAG) {
        
            ULONG IpAddrListLength = 0;
            
            if (pszwRemoteIpAddrList)
                IpAddrListLength = wcslen(pszwRemoteIpAddrList);
                
            newIPInfo.pszwIpAddrList = IfutlAlloc (sizeof(WCHAR) * 
                                            (IpAddrListLength +
                                            Length + 2), TRUE);

            if (!newIPInfo.pszwIpAddrList)
                return ERROR_NOT_ENOUGH_MEMORY;
                
            newIPInfo.pszwIpAddrList[0] = 0;
            
            if (pszwRemoteIpAddrList) {
                wcscat(newIPInfo.pszwIpAddrList, pszwRemoteIpAddrList);
                wcscat(newIPInfo.pszwIpAddrList, c_wszListSeparatorComma);
            }
            
            wcscat(newIPInfo.pszwIpAddrList, wszIp);
        }
        else {
                newIPInfo.pszwIpAddrList = IfutlAlloc (sizeof(WCHAR) * 
                                                (Length + 1), FALSE);

                if (!newIPInfo.pszwIpAddrList)
                    return ERROR_NOT_ENOUGH_MEMORY;
                
                wcscpy(newIPInfo.pszwIpAddrList, wszIp);
        }

        //
        // copy subnet mask list
        //
        
        if (Flags & ADD_FLAG) {
        
            ULONG RemoteIpSubnetMaskListLen = 0;
            
            if (pszwRemoteIpSubnetMaskList)
                RemoteIpSubnetMaskListLen = wcslen(pszwRemoteIpSubnetMaskList);
                
            newIPInfo.pszwSubnetMaskList = IfutlAlloc (sizeof(WCHAR) * 
                                                (RemoteIpSubnetMaskListLen +
                                                wcslen(wszMask) + 2), TRUE);

            if (!newIPInfo.pszwSubnetMaskList)
                return ERROR_NOT_ENOUGH_MEMORY;

            newIPInfo.pszwSubnetMaskList[0]= 0;
            
            if (pszwRemoteIpSubnetMaskList) {
                wcscpy(newIPInfo.pszwSubnetMaskList, pszwRemoteIpSubnetMaskList);
                wcscat(newIPInfo.pszwSubnetMaskList, c_wszListSeparatorComma);
            }
        
            wcscat(newIPInfo.pszwSubnetMaskList, wszMask);
        }
        else {
                newIPInfo.pszwSubnetMaskList = IfutlAlloc (sizeof(WCHAR) * 
                                                    (wcslen(wszMask) + 1), FALSE);
                                                
                if (!newIPInfo.pszwSubnetMaskList)
                    return ERROR_NOT_ENOUGH_MEMORY;

                wcscpy(newIPInfo.pszwSubnetMaskList, wszMask);
        }

        

        // copy old options list
        
        newIPInfo.pszwOptionList = _wcsdup(pszwRemoteOptionList);

        DEBUG_PRINT_CONFIG(&newIPInfo);

        //
        // set the ip address
        //
        hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, &newIPInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);


        if (newIPInfo.pszwIpAddrList) IfutlFree(newIPInfo.pszwIpAddrList);
        if (newIPInfo.pszwSubnetMaskList) IfutlFree(newIPInfo.pszwSubnetMaskList);
        if (newIPInfo.pszwOptionList) free(newIPInfo.pszwOptionList);

        break; //breakout block
        
    } //breakout block
    

    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );

    return (hr == S_OK) ? NO_ERROR : hr;
}

VOID
AppendDdnsOptions(
    PWCHAR ptrDstn,
    PWCHAR ptrOptionList,
    DWORD Flags,
    DWORD dwRegisterMode
    )
/*++

Routine Description

    Adds the appropriate "DynamicUpdate=...;NameRegistration=...;"
    string to a net config option list.

Arguments

    ptrDstn        [in] Buffer to which to append DDNS options.
    ptrOptionList  [in] Old option list.
    Flags          [in] Used to tell whether this is in a SET or ADD.
    dwRegisterMode [in] New mode to convert to options values.
    
Return Value

    None.

--*/
{
    PWCHAR      ptrBegin, ptrEnd;

    //
    // Insert DynamicUpdate=...;
    //
    wcscat(ptrDstn, c_wcsDdns);
    if ((Flags & SET_FLAG) && (dwRegisterMode != REGISTER_UNCHANGED)) {
        //
        // Insert the new value.
        //
        if (dwRegisterMode == REGISTER_NONE) {
            wcscat(ptrDstn, L"0");
        } else {
            wcscat(ptrDstn, L"1");
        }
    } else {
        //
        // Copy the previous value.
        //
        ptrBegin = wcsstr(ptrOptionList, c_wcsDdns) + 
                   wcslen(c_wcsDdns);
        ptrEnd = wcschr(ptrBegin, c_wListSeparatorSC);

        ptrDstn += wcslen(ptrDstn);
        wcsncpy(ptrDstn, ptrBegin, (DWORD)(ptrEnd - ptrBegin));
        ptrDstn += (ULONG)(ptrEnd - ptrBegin);
        *ptrDstn = 0;
    }
    wcscat(ptrDstn, c_wszListSeparatorSC);

    //
    // Insert NameRegistration=...;
    //
    wcscat(ptrDstn, c_wcsDdnsSuffix);
    if ((Flags & SET_FLAG) && (dwRegisterMode != REGISTER_UNCHANGED)) {
        //
        // Insert the new value.
        //
        if (dwRegisterMode == REGISTER_BOTH) {
            wcscat(ptrDstn, L"1");
        } else {
            wcscat(ptrDstn, L"0");
        }
    } else {
        //
        // Copy the previous value.
        //
        ptrBegin = wcsstr(ptrOptionList, c_wcsDdnsSuffix) + 
                   wcslen(c_wcsDdnsSuffix);
        ptrEnd = wcschr(ptrBegin, c_wListSeparatorSC);

        ptrDstn += wcslen(ptrDstn);
        wcsncpy(ptrDstn, ptrBegin, (DWORD)(ptrEnd - ptrBegin));
        ptrDstn += (ULONG)(ptrEnd - ptrBegin);
        *ptrDstn = 0;
    }
    wcscat(ptrDstn, c_wszListSeparatorSC);
}

DWORD
IfIpSetDhcpModeMany(
    LPCWSTR pwszIfFriendlyName,    
    GUID         *pGuid,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    
    if (pGuid == NULL)
        return E_INVALIDARG;


    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pwszIfFriendlyName
                );
        

    while (hr == NO_ERROR) { //breakout block

        PWCHAR pszwBuffer;
        PWCHAR ptr, newPtr;
        
        PWCHAR pszwRemoteOptionList=pRemoteIpInfo->pszwOptionList;

        try {
            pszwBuffer = (PWCHAR) _alloca(sizeof(WCHAR) *
                            (wcslen(pszwRemoteOptionList) + 100)) ;
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }


        
        // if setting ipaddr, check if dhcp already enabled. return.
        
        if (Type==TYPE_IPADDR && pRemoteIpInfo->dwEnableDhcp) {

            DisplayMessage(g_hModule,
                       EMSG_DHCP_MODE);

            hr = ERROR_SUPPRESS_OUTPUT;
            break;
        }
        

        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(REMOTE_IPINFO));
        newIPInfo.dwEnableDhcp = pRemoteIpInfo->dwEnableDhcp;
        newIPInfo.pszwOptionList = pszwBuffer;


        pszwBuffer[0] = 0;
        switch(Type) {
            case TYPE_DNS:
                wcscpy(pszwBuffer, c_wcsDns);
                wcscat(pszwBuffer, c_wszListSeparatorSC);

                AppendDdnsOptions(pszwBuffer + wcslen(pszwBuffer),
                                  pRemoteIpInfo->pszwOptionList,
                                  SET_FLAG, dwRegisterMode); 
                break;
                
            case TYPE_WINS:
                wcscpy(pszwBuffer, c_wcsWins);
                wcscat(pszwBuffer, c_wszListSeparatorSC);
                break;
                
            
            case TYPE_IPADDR:

                newIPInfo.dwEnableDhcp = TRUE;

                newIPInfo.pszwIpAddrList = NULL;
                newIPInfo.pszwSubnetMaskList = NULL;

                wcscpy(pszwBuffer, c_wcsDefGateway);
                wcscat(pszwBuffer, c_wszListSeparatorSC);
                wcscat(pszwBuffer, c_wcsGwMetric);
                wcscat(pszwBuffer, c_wszListSeparatorSC);
                break;
        }
        
        DEBUG_PRINT_CONFIG(&newIPInfo);

        
        
        //
        // set the ip address
        //
        hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, &newIPInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);

        break;
        
    } //breakout block


    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );   

    return (hr == S_OK) ? NO_ERROR : hr;
}


DWORD
IfIpAddSetDelMany(
    PWCHAR wszIfFriendlyName,
    GUID         *pGuid,
    PWCHAR       pwszAddress,
    DWORD        dwIndex,
    DWORD        dwRegisterMode,
    DISPLAY_TYPE Type,
    DWORD        Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *           pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD               dwNetwork;
    HRESULT             hr = S_OK;
    REMOTE_IPINFO   *   pRemoteIpInfo = NULL;
    REMOTE_IPINFO       newIPInfo;

    if (pGuid == NULL)
        return E_INVALIDARG;

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                wszIfFriendlyName
                );
        

    while (hr==NO_ERROR) { //breakout block
    
        PWCHAR ptrBegin, ptrEnd, ptrTmp, ptrDstn, ptrDel;
        DWORD Found = FALSE;
        const WCHAR * Token;

        switch (Type) {

            case TYPE_DNS:
                Token = c_wcsDns;
                break;

            case TYPE_WINS:
                Token = c_wcsWins;
                break;
        }
        
        ptrBegin = wcsstr(pRemoteIpInfo->pszwOptionList, Token) + wcslen(Token);
        ptrEnd = wcschr(ptrBegin, c_wListSeparatorSC);
        
        //
        // check if the address is already present
        //
        if ( (Flags & (ADD_FLAG | DEL_FLAG)) && (pwszAddress)) {
        
            ULONG Length = wcslen(pwszAddress), Found = FALSE;
            
            ptrTmp = ptrBegin;

            while (ptrTmp && (ptrTmp+Length <= ptrEnd) ){

                if (ptrTmp = wcsstr(ptrTmp, pwszAddress)) {

                    if ( ((*(ptrTmp+Length)==c_wListSeparatorComma)
                            || (*(ptrTmp+Length)==c_wListSeparatorSC) )
                        && ( (*(ptrTmp-1)==c_wListSeparatorComma)
                            || (*(ptrTmp-1)==c_wEqual)) )
                    {
                        Found = TRUE;
                        ptrDel = ptrTmp;
                        break;
                    }
                    else {
                        ptrTmp = wcschr(ptrTmp, c_wListSeparatorComma);
                    }
                }
            }

            if (Found && (Flags & ADD_FLAG)) {
            
                DisplayMessage(g_hModule,
                       EMSG_SERVER_PRESENT,
                       pwszAddress);
                hr = ERROR_SUPPRESS_OUTPUT;
                break; //from breakout block
            }
            else if (!Found && (Flags & DEL_FLAG)) {

                DisplayMessage(g_hModule,
                       EMSG_SERVER_ABSENT,
                       pwszAddress);
                hr = ERROR_SUPPRESS_OUTPUT;
                break; //from breakout block

            }
            
        } // breakout block    

        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(newIPInfo));

        // copy ip addr list
        {
            newIPInfo.pszwIpAddrList = pRemoteIpInfo->pszwIpAddrList;
        }

        // copy subnet mask list
        {
            newIPInfo.pszwSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
        }

        try {
            newIPInfo.pszwOptionList = 
                (PWCHAR) _alloca(sizeof(PWCHAR) * 
                (wcslen(pRemoteIpInfo->pszwOptionList)+
                (pwszAddress?wcslen(pwszAddress):0) + 1));

        } except (EXCEPTION_EXECUTE_HANDLER) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

                
        // copy token in all cases

        ptrDstn = newIPInfo.pszwOptionList;
        ptrDstn[0] = 0;
        wcscpy(ptrDstn, Token);
        ptrDstn += wcslen(Token);
        
        if (Flags & ADD_FLAG) {

            DWORD i;
            
            ptrTmp = ptrBegin;
            
            for (i=0;  i<dwIndex-1 && ptrTmp && ptrTmp<ptrEnd;  i++) {

                ptrTmp = wcschr(ptrTmp, c_wListSeparatorComma);
                if (ptrTmp) ptrTmp++;
            }

            if (!ptrTmp) {

                ptrTmp = wcschr(ptrBegin, c_wListSeparatorSC);
            }

            if (*(ptrTmp-1) == c_wListSeparatorComma)
                ptrTmp--;
                
            // copy addresses before index

            if (ptrTmp>ptrBegin) {
                wcsncpy(ptrDstn, ptrBegin, (DWORD)(ptrTmp-ptrBegin));
                ptrDstn += (ULONG) (ptrTmp - ptrBegin);

                ptrTmp++;
                *ptrDstn++ = c_wListSeparatorComma;
                *ptrDstn = 0;
            }
            
        }

        // copy new address
        
        if (Flags & (ADD_FLAG|SET_FLAG) ) {

            if (pwszAddress) {
                wcscat(ptrDstn, pwszAddress);
                ptrDstn += wcslen(pwszAddress);
            }
        }
        
        // copy addresses after index

        if (Flags & ADD_FLAG) {

            if (ptrTmp < ptrEnd) {
                *ptrDstn++ = c_wListSeparatorComma;
                *ptrDstn = 0;

                wcsncpy(ptrDstn, ptrTmp, (DWORD)(ptrEnd - ptrTmp));
                ptrDstn += (ULONG)(ptrEnd - ptrTmp);
                *ptrDstn = 0;
            }
        }

        if (Flags & (ADD_FLAG|SET_FLAG) ) {
            wcscat(ptrDstn, c_wszListSeparatorSC);
        }


        if (Flags & DEL_FLAG) {

            if (pwszAddress) {

                BOOL AddrPrepend = FALSE;
            
                if (ptrDel > ptrBegin) {
                    wcsncat(ptrDstn, ptrBegin, (DWORD)(ptrDel-ptrBegin));
                    ptrDstn += (ULONG)(ptrDel-ptrBegin);
                    AddrPrepend = TRUE;
                    if ( *(ptrDstn-1) == c_wListSeparatorComma) {
                        *(--ptrDstn) = 0;
                    }
                }
                
                ptrTmp = ptrDel + wcslen(pwszAddress);
                if (*ptrTmp == c_wListSeparatorComma) 
                    ptrTmp++;

                if (AddrPrepend && *ptrTmp!=c_wListSeparatorSC)
                    *ptrDstn++ = c_wListSeparatorComma;

                wcsncat(ptrDstn, ptrTmp, (DWORD)(ptrEnd - ptrTmp));
                ptrDstn += (ULONG)(ptrEnd - ptrTmp);
                *ptrDstn = 0;
            }
            
            wcscat(ptrDstn, c_wszListSeparatorSC);
        }

        if (Type == TYPE_DNS) {
            AppendDdnsOptions(ptrDstn, pRemoteIpInfo->pszwOptionList,
                              Flags, dwRegisterMode); 
        }

        DEBUG_PRINT_CONFIG(&newIPInfo);

        
        //
        // set the ip address
        //
        hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, &newIPInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);

        break;
        
    } //breakout block
            
    
    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );
                
    return (hr == S_OK) ? NO_ERROR : hr;
}


DWORD
IfIpAddSetGateway(
    LPCWSTR pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszGateway,
    LPCWSTR      pwszGwMetric,
    DWORD        Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    PWCHAR      Gateways, GatewaysEnd, GwMetrics, GwMetricsEnd;

    if (pGuid == NULL)
        return E_INVALIDARG;

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pwszIfFriendlyName
                );
        
    while (hr==NO_ERROR) { //breakout block
    
        PWCHAR ptrAddr, ptrMask;
        DWORD bFound = FALSE;
        PWCHAR pszwRemoteIpAddrList=NULL, pszwRemoteIpSubnetMaskList=NULL,
                pszwRemoteOptionList=NULL;


        pszwRemoteIpAddrList = pRemoteIpInfo->pszwIpAddrList;
        pszwRemoteIpSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
        pszwRemoteOptionList = pRemoteIpInfo->pszwOptionList;

        Gateways = wcsstr(pszwRemoteOptionList, c_wcsDefGateway) + wcslen(c_wcsDefGateway);
        GatewaysEnd = wcschr(Gateways, c_wListSeparatorSC);
        GwMetrics = wcsstr(pszwRemoteOptionList, c_wcsGwMetric) + wcslen(c_wcsGwMetric);
        GwMetricsEnd = wcschr(GwMetrics, c_wListSeparatorSC);
            


        //
        // check if the gateway is already present
        //

        if (Flags & ADD_FLAG) {
        
            ULONG Length = wcslen(pwszGateway), Found = FALSE;
            PWCHAR TmpPtr;
            
            TmpPtr = Gateways;

            while (TmpPtr && (TmpPtr+Length <= GatewaysEnd) ){

                if (TmpPtr = wcsstr(TmpPtr, pwszGateway)) {

                    if ( ((*(TmpPtr+Length)==c_wListSeparatorComma)
                            || (*(TmpPtr+Length)==c_wListSeparatorSC) )
                        && ( (*(TmpPtr-1)==c_wListSeparatorComma)
                            || (*(TmpPtr-1)==c_wEqual)) )
                    {
                        Found = TRUE;
                        break;
                    }
                    else {
                        TmpPtr = wcschr(TmpPtr, c_wListSeparatorComma);
                    }
                }
            }

            if (Found) {
                DisplayMessage(g_hModule,
                       EMSG_DEFGATEWAY_PRESENT,
                       pwszGateway);
                hr = ERROR_SUPPRESS_OUTPUT;
                break; //from breakout block
            }
        }
        
        memcpy(&newIPInfo, pRemoteIpInfo, sizeof(newIPInfo));


        // copy ip addr list
        newIPInfo.pszwIpAddrList = pRemoteIpInfo->pszwIpAddrList;


        // copy subnet mask list
        newIPInfo.pszwSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;

        // copy old options list

        if (Flags & ADD_FLAG) {
        
            newIPInfo.pszwOptionList = IfutlAlloc (sizeof(WCHAR) * 
                                            (wcslen(pszwRemoteOptionList) +
                                             wcslen(pwszGateway) +
                                             wcslen(pwszGwMetric) +
                                             3), TRUE);
            if (!newIPInfo.pszwOptionList) {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break; //from breakout block
            }

            wcsncpy(newIPInfo.pszwOptionList, pszwRemoteOptionList,
                        (DWORD)(GatewaysEnd - pszwRemoteOptionList));

            *(newIPInfo.pszwOptionList + (GatewaysEnd - pszwRemoteOptionList)) = 0;
            if (*(GatewaysEnd-1) != c_wEqual) {
                wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorComma);
            }
            wcscat(newIPInfo.pszwOptionList, pwszGateway);
            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);

            {
                ULONG Length;
                Length = wcslen(newIPInfo.pszwOptionList);
            
                wcsncat(newIPInfo.pszwOptionList, GatewaysEnd+1,
                        (DWORD)(GwMetricsEnd - (GatewaysEnd+1)));
                Length += (DWORD) (GwMetricsEnd - (GatewaysEnd+1));

                newIPInfo.pszwOptionList[Length] = 0;
            }
            
            if (*(GwMetricsEnd-1) != c_wEqual) {
                wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorComma);
            }
            
            wcscat(newIPInfo.pszwOptionList, pwszGwMetric);
            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);
            wcscat(newIPInfo.pszwOptionList, GwMetricsEnd+1);
        }
        else {

            ULONG Length;
            
            Length = sizeof(WCHAR) * (wcslen(c_wcsDefGateway) + wcslen(c_wcsGwMetric) + 3);
            if (pwszGateway) 
                Length += sizeof(WCHAR) * (wcslen(pwszGateway) + wcslen(pwszGwMetric));
                
            newIPInfo.pszwOptionList = (PWCHAR) IfutlAlloc (Length, FALSE);
            if (newIPInfo.pszwOptionList == NULL) {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                break; //from breakout block
            }
            newIPInfo.pszwOptionList[0] = 0;

            // cat gateway
            
            wcscat(newIPInfo.pszwOptionList, c_wcsDefGateway);
            if (pwszGateway)
                wcscat(newIPInfo.pszwOptionList, pwszGateway);

            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);

            // cat gwmetric

            wcscat(newIPInfo.pszwOptionList, c_wcsGwMetric);
            if (pwszGateway)
                wcscat(newIPInfo.pszwOptionList, pwszGwMetric);

            wcscat(newIPInfo.pszwOptionList, c_wszListSeparatorSC);
        }


        DEBUG_PRINT_CONFIG(&newIPInfo);

        
        //
        // set the ip address
        //
        hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, &newIPInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);


        if (newIPInfo.pszwOptionList) IfutlFree(newIPInfo.pszwOptionList);

        break;
        
    } //breakout block
            

    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );   

    return (hr == S_OK) ? NO_ERROR : hr;
}

// 
// Display an IP address in Unicode form.  If First is false, 
// a string of spaces will first be printed so that the list lines up.
// For the first address, the caller is responsible for printing the
// header before calling this function.
//
VOID
ShowUnicodeAddress(
    BOOL  *pFirst, 
    PWCHAR pwszAddress)
{
    if (*pFirst) {
        *pFirst = FALSE;
    } else {
        DisplayMessage(g_hModule, MSG_ADDR2);
    }
    DisplayMessage(g_hModule, MSG_ADDR1, pwszAddress);
}

// Same as ShowUnicodeAddress, except that the address is passed 
// in multibyte form, such as is used by IPHLPAPI
VOID
ShowCharAddress(
    BOOL *pFirst, 
    char *chAddress)
{
    WCHAR pwszBuffer[16];

    if (!chAddress[0]) {
        return;
    }

    MultiByteToWideChar(GetConsoleOutputCP(), 0, chAddress, strlen(chAddress)+1,
                        pwszBuffer, 16);

    ShowUnicodeAddress(pFirst, pwszBuffer);
}

DWORD
IfIpShowManyExEx(
    LPCWSTR     pwszMachineName,
    ULONG       IfIndex,
    PWCHAR      pFriendlyIfName,
    GUID       *pGuid,
    ULONG       Flags,
    HANDLE      hFile
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork, dwSize = 0, dwErr;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    REMOTE_IPINFO    newIPInfo;
    PWCHAR      pQuotedFriendlyIfName = NULL;
    PIP_PER_ADAPTER_INFO pPerAdapterInfo = NULL;
    PIP_ADAPTER_INFO pAdaptersInfo = NULL, pAdapterInfo = NULL;
    DWORD            dwRegisterMode;

    if (pGuid == NULL)
        return E_INVALIDARG;

    if (hFile && pwszMachineName) {
        // not currently remotable
        return NO_ERROR;
    }

    if (!hFile && !pwszMachineName) {
        //
        // If we're not doing a "dump", and we're looking at the local
        // machine, then get active per-adapter information such as the
        // current DNS and WINS server addresses
        //

        GetPerAdapterInfo(IfIndex, NULL, &dwSize);
        pPerAdapterInfo = (PIP_PER_ADAPTER_INFO)IfutlAlloc(dwSize,FALSE);
        if (!pPerAdapterInfo) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        dwErr = GetPerAdapterInfo(IfIndex, pPerAdapterInfo, &dwSize);
        if (dwErr != NO_ERROR) {
            IfutlFree(pPerAdapterInfo);
            pPerAdapterInfo = NULL; 
        }

        dwSize = 0;
        GetAdaptersInfo(NULL, &dwSize);
        pAdaptersInfo = (PIP_ADAPTER_INFO)IfutlAlloc(dwSize,FALSE);
        if (!pAdaptersInfo) {
            IfutlFree(pPerAdapterInfo);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        dwErr = GetAdaptersInfo(pAdaptersInfo, &dwSize);
        if (dwErr != NO_ERROR) {
            IfutlFree(pAdaptersInfo);
            pAdaptersInfo = NULL; 
        }
        if (pAdaptersInfo) {
            for (pAdapterInfo = pAdaptersInfo; 
                 pAdapterInfo && pAdapterInfo->Index != IfIndex; 
                 pAdapterInfo = pAdapterInfo->Next);
        }
    }

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pFriendlyIfName
                );
        
    while (hr==NO_ERROR) { //breakout block
    
        PWCHAR ptrAddr, ptrMask, ptrAddrNew, ptrMaskNew;


        if (hr != NO_ERROR)
            break;


        pQuotedFriendlyIfName = MakeQuotedString( pFriendlyIfName );

        if ( pQuotedFriendlyIfName == NULL ) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }


        DEBUG_PRINT_CONFIG(pRemoteIpInfo);
        

        if (hFile) {
            DisplayMessage(g_hModule,
                    DMP_IFIP_INTERFACE_HEADER,
                    pQuotedFriendlyIfName);
        }
        else {
        
            DisplayMessage(g_hModule,
                    MSG_IFIP_HEADER,
                    pQuotedFriendlyIfName);
        }
        

        //
        // display ipaddress list
        //

        if (Flags & TYPE_IPADDR) {

            if (hFile) {
                DisplayMessageT(
                    (pRemoteIpInfo->dwEnableDhcp) ? DMP_DHCP : DMP_STATIC,
                    pQuotedFriendlyIfName
                    );
            }
            else {
                DisplayMessage(g_hModule,
                       (pRemoteIpInfo->dwEnableDhcp) ? MSG_DHCP : MSG_STATIC);
            }    

        
            if (!pRemoteIpInfo->dwEnableDhcp) {
            
                ptrAddr = pRemoteIpInfo->pszwIpAddrList;
                ptrMask = pRemoteIpInfo->pszwSubnetMaskList;
            } else if (!pwszMachineName) {
                // If on the local machine, get the active list
                ptrAddr = NULL;
                ptrMask = NULL;
            }

            if (ptrAddr && ptrMask) {

                    DWORD First = TRUE;
                    
                    while (ptrAddr && ptrMask && *ptrAddr!=0 && *ptrMask != 0) {
                        
                        ptrAddrNew = wcschr(ptrAddr, c_wListSeparatorComma);
                        ptrMaskNew = wcschr(ptrMask, c_wListSeparatorComma);

                        if (ptrAddrNew)
                            *ptrAddrNew = 0;
                        if (ptrMaskNew)
                            *ptrMaskNew = 0;

                        if (hFile) {

                            if (First) {
                                DisplayMessageT(
                                    DMP_IPADDR1,
                                    ptrAddr, ptrMask
                                    );
                                First = FALSE;
                            }
                            else {
                                DisplayMessageT(
                                    DMP_IPADDR2,
                                    pQuotedFriendlyIfName,
                                    ptrAddr, ptrMask
                                    );
                            }
                        }
                        else {
                            DisplayMessage(g_hModule,
                                MSG_IPADDR_LIST1,
                                ptrAddr, ptrMask);
                        }
                        
                        ptrAddr = ptrAddrNew ? ++ptrAddrNew : NULL;
                        ptrMask = ptrMaskNew ? ++ptrMaskNew : NULL;
                    }
            }
            
        } // end display ipaddr

        
        //
        // display options list
        //

        {
            PWCHAR IfMetric1, Gateways1, GwMetrics1, Dns1, Wins1,
                    Ptr1, Ptr2, Equal, SemiColon, Ddns1, DdnsSuffix1,
                    End1;

            if (hr != NO_ERROR)
                break;
                    
            Ptr1 = pRemoteIpInfo->pszwOptionList;
            IfMetric1 = wcsstr(Ptr1, c_wcsIfMetric);
            Gateways1 = wcsstr(Ptr1, c_wcsDefGateway);
            GwMetrics1 = wcsstr(Ptr1, c_wcsGwMetric);
            Dns1 = wcsstr(Ptr1, c_wcsDns);
            Wins1 = wcsstr(Ptr1, c_wcsWins);
            Ddns1 = wcsstr(Ptr1, c_wcsDdns);
            DdnsSuffix1 = wcsstr(Ptr1, c_wcsDdnsSuffix);

            while (*Ptr1) {
            
                Equal = wcschr(Ptr1, c_wEqual);
                SemiColon = wcschr(Ptr1, c_wListSeparatorSC);
                if (!Equal || !SemiColon)
                    break;

                Ptr2 = Ptr1;
                Ptr1 = SemiColon + 1;
                *SemiColon = 0;
                

                // display IfMetric
                
                if (Ptr2 == IfMetric1) {

                    if (! (Flags & TYPE_IPADDR))
                        continue;

                    if (hFile) {
                    }
                    else {
                        DisplayMessage(g_hModule,
                            MSG_IFMETRIC,
                            Equal+1);
                    }
                    
                }

                // display Gateways
                
                else if (Ptr2 == Gateways1) {

                    PWCHAR Gateway, GwMetric, GatewayEnd, GwMetricEnd,
                           Comma1, Comma2;
                    BOOL First = TRUE;

                    
                    if (! (Flags & TYPE_IPADDR))
                        continue;
                        

                    // gateways list null
                    
                    if (SemiColon == (Ptr2 + wcslen(c_wcsDefGateway)))
                        continue;


                    Gateway = Equal + 1;
                    GatewayEnd = SemiColon;

                    GwMetric = wcschr(GwMetrics1, c_wEqual) + 1;
                    GwMetricEnd = wcschr(GwMetrics1, c_wListSeparatorSC);
                    *GwMetricEnd = 0;
                    

                    do {
                        
                        Comma1 = wcschr(Gateway, c_wListSeparatorComma);
                        if (Comma1) *Comma1 = 0;

                        Comma2 = wcschr(GwMetric, c_wListSeparatorComma);
                        if (Comma2) *Comma2 = 0;

                        if (hFile) {

                            if (First) {
                                DisplayMessageT(
                                    DMP_GATEWAY2,
                                    pQuotedFriendlyIfName,
                                    Gateway, GwMetric
                                    );
                                First = FALSE;
                            }
                            else {
                                DisplayMessageT(
                                    DMP_GATEWAY3,
                                    pQuotedFriendlyIfName,
                                    Gateway, GwMetric
                                    );
                            }
                        }
                        else {
                            DisplayMessage(g_hModule,
                                MSG_GATEWAY,
                                Gateway, GwMetric);
                        }
                        
                        if (Comma1) *Comma1 = c_wListSeparatorComma;
                        if (Comma2) *Comma2 = c_wListSeparatorComma;

                        Gateway = Comma1 + 1;
                        GwMetric = Comma2 + 1;

                    } while (Comma1 && Gateway<GatewayEnd);

                    if (hFile && First) {
                        DisplayMessageT(
                            DMP_GATEWAY1,
                            pQuotedFriendlyIfName
                            );
                    }
                    
                    *GwMetricEnd = c_wListSeparatorSC;
                }

                else if (Ptr2 == GwMetrics1) {

                }

                // display wins and dns
                
                else if ( (Ptr2 == Dns1) || (Ptr2==Wins1)) {

                    PWCHAR BeginPtr, EndPtr, Comma1;
                    BOOL bDns = Ptr2==Dns1;
                    
                    if (Ptr2==Dns1) {
                        if (! (Flags & TYPE_DNS))
                            continue;
                    }
                    else {
                        if (! (Flags & TYPE_WINS))
                            continue;
                    }

                    BeginPtr = Equal + 1;
                    EndPtr = SemiColon;


                    // empty list
                    
                    if (BeginPtr==EndPtr) {
                    
                        if (hFile) {
                            DisplayMessageT(
                                pRemoteIpInfo->dwEnableDhcp
                                ? (bDns?DMP_DNS_DHCP:DMP_WINS_DHCP)
                                : (bDns?DMP_DNS_STATIC_NONE:DMP_WINS_STATIC_NONE),
                                pQuotedFriendlyIfName
                                );

                            if (bDns) {
                                //
                                // When generating a DNS (not WINS) line,
                                // also include the REGISTER=... argument.
                                // We need to look ahead in the option list
                                // since the DDNS info may occur after the
                                // WINS info, but we have to output it before.
                                //
                                if (!wcstol(Ddns1+wcslen(c_wcsDdns), &End1, 10)) {
                                    DisplayMessageT(DMP_STRING_ARG, 
                                        TOKEN_REGISTER, TOKEN_VALUE_NONE);
                                } else if (!wcstol(DdnsSuffix1+wcslen(
                                                c_wcsDdnsSuffix), &End1, 10)) {
                                    DisplayMessageT(DMP_STRING_ARG, 
                                        TOKEN_REGISTER, TOKEN_VALUE_PRIMARY);
                                } else {
                                    DisplayMessageT(DMP_STRING_ARG, 
                                        TOKEN_REGISTER, TOKEN_VALUE_BOTH);
                                }
                            }
                        }
                        else {
                            if (pRemoteIpInfo->dwEnableDhcp) {
                                IP_ADDR_STRING      *pAddr;
                                DWORD                dwErr;
                                BOOL                 First = TRUE;

                                if (!pwszMachineName) {
                                    DisplayMessage(g_hModule,
                                        (bDns?MSG_DNS_DHCP_HDR:MSG_WINS_DHCP_HDR)
                                        );

                                    // Display active list
                            
                                    if (bDns && pPerAdapterInfo) {        
                                        for (pAddr = &pPerAdapterInfo->DnsServerList;
                                             pAddr; 
                                             pAddr = pAddr->Next) 
                                        {
                                            ShowCharAddress(&First, pAddr->IpAddress.String);
                                        }
                                    } else if (!bDns && pAdapterInfo) {
                                        if (strcmp(pAdapterInfo->PrimaryWinsServer.IpAddress.String, "0.0.0.0")) {
                                            ShowCharAddress(&First, pAdapterInfo->PrimaryWinsServer.IpAddress.String);
                                        }
                                        if (strcmp(pAdapterInfo->SecondaryWinsServer.IpAddress.String, "0.0.0.0")) {
                                            ShowCharAddress(&First, pAdapterInfo->SecondaryWinsServer.IpAddress.String);
                                        }
                                    }

                                    if (First) {
                                        DisplayMessage(g_hModule, MSG_NONE);
                                    }
                                } else {
                                    DisplayMessage(g_hModule,
                                        (bDns?MSG_DNS_DHCP:MSG_WINS_DHCP)
                                        );
                                }
                            }
                            else {
                                DisplayMessage(g_hModule,
                                    bDns?MSG_DNS_HDR:MSG_WINS_HDR);
                                DisplayMessage(g_hModule,
                                    MSG_NONE);
                            }

                            //
                            // For show commands, we output either DNS or WINS
                            // information but not both, so we can wait until
                            // we process the DDNS information normally,
                            // before outputting the DDNS state.
                            //
                        }

                        continue;
                    }

                    {
                        PWCHAR Comma1;
                        BOOL   First = TRUE;

                        if (!hFile) {
                            DisplayMessage(g_hModule,
                                bDns?MSG_DNS_HDR:MSG_WINS_HDR);
                        }
                    
                        do {
                            Comma1 = wcschr(BeginPtr, c_wListSeparatorComma);
                            if (Comma1) *Comma1 = 0;
                    
                            if (hFile) {
                                DisplayMessageT(
                                    First 
                                    ? (First=FALSE,(bDns?DMP_DNS_STATIC_ADDR1:DMP_WINS_STATIC_ADDR1)) 
                                    : (bDns?DMP_DNS_STATIC_ADDR2:DMP_WINS_STATIC_ADDR2),
                                    pQuotedFriendlyIfName,
                                    BeginPtr);

                                if (bDns) {
                                    //
                                    // When generating a DNS (not WINS) line,
                                    // also include the REGISTER=... argument.
                                    // We need to look ahead in the option list
                                    // since the DDNS info may occur after the
                                    // WINS info, but we have to output it 
                                    // before.
                                    //
                                    if (!wcstol(Ddns1+wcslen(c_wcsDdns), &End1, 10)) {
                                        DisplayMessageT(DMP_STRING_ARG,
                                            TOKEN_REGISTER, TOKEN_VALUE_NONE);
                                    } else if (!wcstol(DdnsSuffix1+wcslen(
                                                    c_wcsDdnsSuffix), &End1, 10)) {
                                        DisplayMessageT(DMP_STRING_ARG,
                                            TOKEN_REGISTER, TOKEN_VALUE_PRIMARY);
                                    } else {
                                        DisplayMessageT(DMP_STRING_ARG,
                                            TOKEN_REGISTER, TOKEN_VALUE_BOTH);
                                    }
                                }
                            }
                            else {
                                ShowUnicodeAddress(&First, BeginPtr);

                            }
                            
                            if (Comma1) *Comma1 = c_wListSeparatorComma;
                            BeginPtr = Comma1 + 1;

                        } while (Comma1 && BeginPtr<EndPtr);
                    }
                }

                else if (Ptr2 == Ddns1) {
                    if (! (Flags & TYPE_DNS))
                        continue;

                    //
                    // When we see DynamicUpdate=..., save the value.
                    // We won't know the complete register mode until
                    // we see the subsequent NameRegistration=... value.
                    // NetConfig guarantees that DynamicUpdate will occur
                    // first.
                    //
                    dwRegisterMode = wcstol(Equal+1, &End1, 10)? REGISTER_PRIMARY : REGISTER_NONE;
                }
                else if (Ptr2 == DdnsSuffix1) {
                    if (! (Flags & TYPE_DNS))
                        continue;
                    if (hFile) {
                        //
                        // If this is a dump, we've already looked at
                        // this value, when we processed the DNS=... option.
                        //
                    } else {
                        PWCHAR pwszValue;

                        //
                        // Now that we've seen NameRegistration=...,
                        // we know the complete register mode and can
                        // output it accordingly.
                        //
                        if ((dwRegisterMode == REGISTER_PRIMARY) && 
                            wcstol(Equal+1, &End1, 10)) {
                            pwszValue = MakeString(g_hModule, STRING_BOTH);
                        } else if (dwRegisterMode == REGISTER_PRIMARY) {
                            pwszValue = MakeString(g_hModule, STRING_PRIMARY);
                        } else {
                            pwszValue = MakeString(g_hModule, STRING_NONE);
                        }

                        DisplayMessage(g_hModule, MSG_DDNS_SUFFIX, pwszValue);

                        FreeString(pwszValue);
                    }
                }
                
                // any other option
                
                else {
                
                    *Equal = 0;

                    if (!hFile) {
                        DisplayMessage(g_hModule,
                            MSG_OPTION,
                            Ptr2, Equal+1);
                    }                        
                }
            }
        } //end options list

        break;
        
    } // breakout block

    if ( pQuotedFriendlyIfName ) {
        FreeQuotedString( pQuotedFriendlyIfName );
    }
    
    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );

        
    IfutlFree(pPerAdapterInfo);
    IfutlFree(pAdaptersInfo);

    return (hr == S_OK) ? NO_ERROR : hr;
}



DWORD
IfIpHandleDelIpaddrEx(
    LPCWSTR      pwszIfFriendlyName,
    GUID         *pGuid,
    LPCWSTR      pwszIpAddr,
    LPCWSTR      pwszGateway,
    ULONG        Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    INetCfg *   pNetCfg = NULL;
    ITcpipProperties *  pTcpipProperties = NULL;
    DWORD       dwNetwork;
    HRESULT     hr = S_OK;
    REMOTE_IPINFO   *pRemoteIpInfo = NULL;
    PWCHAR      Gateways, GatewaysEnd, GwMetrics, GwMetricsEnd;

    if (pGuid == NULL)
        return E_INVALIDARG;

    hr = GetTransportConfig(
                &pNetCfg,
                &pTcpipProperties,
                &pRemoteIpInfo,
                pGuid,
                pwszIfFriendlyName
                );
        
    while (hr==NO_ERROR) { //breakout block

        if (Flags & TYPE_ADDR) {

            PWCHAR IpAddr, IpAddrEnd;
            PWCHAR Mask, MaskEnd;
            PWCHAR pszwRemoteIpAddrList = pRemoteIpInfo->pszwIpAddrList;
            PWCHAR pszwRemoteSubnetMaskList = pRemoteIpInfo->pszwSubnetMaskList;
            PWCHAR EndIpAddrList = pszwRemoteIpAddrList + wcslen(pszwRemoteIpAddrList);
            BOOL Found = FALSE;
            ULONG Length = wcslen(pwszIpAddr);

            
            IpAddr = pszwRemoteIpAddrList;
            Mask = pszwRemoteSubnetMaskList;
            
            while (IpAddr && (IpAddr + Length <= EndIpAddrList) ){

                if (wcsncmp(IpAddr, pwszIpAddr, Length) == 0) {

                    if ( *(IpAddr+Length)==0 || *(IpAddr+Length)==c_wListSeparatorComma){

                        Found = TRUE;
                        break;
                    }
                }

                IpAddr = wcschr(IpAddr, c_wListSeparatorComma);
                Mask = wcschr(Mask, c_wListSeparatorComma);

                if (IpAddr){
                    IpAddr++;
                    Mask++;
                }
            }

            
            // IpAddr not present
            
            if (!Found) {
                DisplayMessage(g_hModule,
                   EMSG_ADDRESS_NOT_PRESENT);

                hr = ERROR_SUPPRESS_OUTPUT;
                break;
            }

            
            // cannot delete addr in dhcp mode
            
            if (pRemoteIpInfo->dwEnableDhcp == TRUE) {

                DisplayMessage(g_hModule,
                   EMSG_DHCP_DELETEADDR);

                hr = ERROR_SUPPRESS_OUTPUT;
                break;
            }


            
            IpAddrEnd = wcschr(IpAddr, c_wListSeparatorComma);
            MaskEnd = wcschr(Mask, c_wListSeparatorComma);
            
            if (*(IpAddr-1) == c_wListSeparatorComma) {
                IpAddr --;
                Mask --;
            }
            else if (IpAddrEnd) {
                IpAddrEnd++;
                MaskEnd++;
            }

            
            pszwRemoteIpAddrList[IpAddr - pszwRemoteIpAddrList] = 0;
            pszwRemoteSubnetMaskList[Mask - pszwRemoteSubnetMaskList] = 0;
            
            if (IpAddrEnd) {
                wcscat(pszwRemoteIpAddrList, IpAddrEnd);
                wcscat(pszwRemoteSubnetMaskList, MaskEnd);
            }

            
            // should have at least one addr in static mode
            
            if (wcslen(pszwRemoteIpAddrList)==0 && 
                pRemoteIpInfo->dwEnableDhcp == FALSE)
            {
                DisplayMessage(g_hModule,
                   EMSG_MIN_ONE_ADDR);

                hr = ERROR_SUPPRESS_OUTPUT;
                break;

            }
        } //end delete ipaddr

    
        if (Flags & TYPE_GATEWAY) {

            PWCHAR pszwRemoteOptionList = pRemoteIpInfo->pszwOptionList;
            PWCHAR Gateways, GatewaysEnd, GwMetrics, GwMetricsEnd, GwMetrics1;
            BOOL Found = FALSE;
            
            Gateways = wcsstr(pszwRemoteOptionList, c_wcsDefGateway)
                + wcslen(c_wcsDefGateway);
            GwMetrics1 = GwMetrics = wcsstr(pszwRemoteOptionList, c_wcsGwMetric)
                + wcslen(c_wcsGwMetric);
            GatewaysEnd = wcschr(Gateways, c_wListSeparatorSC);

            // check if the gateway is present
        
            if (pwszGateway) {

                ULONG Length = wcslen(pwszGateway);

                while ((Gateways+Length) <= GatewaysEnd) {

                    if ( (wcsncmp(pwszGateway, Gateways, Length)==0)
                        && ( (*(Gateways+Length)==c_wListSeparatorComma)
                            || (*(Gateways+Length)==c_wListSeparatorSC)) )
                    {

                        Found = TRUE;
                        break;
                    }
                    else {

                        if (Gateways = wcschr(Gateways, c_wListSeparatorComma)) {

                            Gateways++;
                            GwMetrics = wcschr(GwMetrics, c_wListSeparatorComma) + 1;
                        }
                        else {
                            break;
                        }
                    }
                }
            
                if (!Found) {

                    DisplayMessage(g_hModule,
                       EMSG_GATEWAY_NOT_PRESENT);

                    hr = ERROR_SUPPRESS_OUTPUT;
                    
                    break; //from breakout block
                }
            }
            
            if (!pwszGateway) {

                wcscpy(pszwRemoteOptionList, c_wcsDefGateway);
                wcscat(pszwRemoteOptionList, c_wszListSeparatorSC);
                wcscat(pszwRemoteOptionList, c_wcsGwMetric);
                wcscat(pszwRemoteOptionList, c_wszListSeparatorSC);
            }
            else {
                PWCHAR GatewaysListEnd, GwMetricsListEnd, TmpPtr;

                GatewaysListEnd = wcschr(Gateways, c_wListSeparatorSC);
                GwMetricsListEnd = wcschr(GwMetrics, c_wListSeparatorSC);

                GatewaysEnd = Gateways + wcslen(pwszGateway);
                GwMetricsEnd = wcschr(GwMetrics, c_wListSeparatorComma);
                if (!GwMetricsEnd || GwMetricsEnd>GwMetricsListEnd)
                    GwMetricsEnd = wcschr(GwMetrics, c_wListSeparatorSC);
                    

                if (*(Gateways-1)==c_wListSeparatorComma) {
                    Gateways--;
                    GwMetrics--;
                    
                } else if (*GatewaysEnd==c_wListSeparatorComma) {
                    GatewaysEnd++;
                    GwMetricsEnd++;
                }
                
                wcsncpy(Gateways, GatewaysEnd, (DWORD)(GwMetrics - GatewaysEnd));
                TmpPtr = Gateways + (GwMetrics - GatewaysEnd);
                *TmpPtr = 0;
                wcscat(TmpPtr, GwMetricsEnd);
            }
        } //end delete gateway


        //
        // set the config
        //

        if (hr == S_OK)
            hr = pTcpipProperties->lpVtbl->SetIpInfoForAdapter(pTcpipProperties, pGuid, pRemoteIpInfo);

        if (hr == S_OK)
            hr = pNetCfg->lpVtbl->Apply(pNetCfg);

        break;
        
    }//end breakout block
                       

    UninitializeTransportConfig(
                pNetCfg,
                pTcpipProperties,
                pRemoteIpInfo
                );

    return (hr == S_OK) ? NO_ERROR : hr;
}

DWORD
OpenDriver(
    HANDLE *Handle,
    LPWSTR DriverName
    )
/*++

Routine Description:

    This function opens a specified IO drivers.

Arguments:

    Handle - pointer to location where the opened drivers handle is
        returned.

    DriverName - name of the driver to be opened.

Return Value:

    Windows Error Code.
Notes: copied from net\sockets\tcpcmd\ipcfgapi\ipcfgapi.c

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the IP driver.
    //

    RtlInitUnicodeString(&nameString, DriverName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile(
        Handle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        0,
        NULL,
        0
        );

    return( RtlNtStatusToDosError( status ) );
}

NTSTATUS
DoIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    )
/*++

Routine Description:

    Utility routine used to issue a filtering ioctl to the tcpip driver.

Arguments:

    Handle - An open file handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output 
buffer.

Return Value:

    NT Status Code.
Notes: copied from net\sockets\tcpcmd\ipcfgapi\ipcfgapi.c
--*/
{
    IO_STATUS_BLOCK    ioStatusBlock;
    NTSTATUS           status;


    ioStatusBlock.Information = 0;

    status = NtDeviceIoControlFile(
                 Handle,                          // Driver handle
                 NULL,                            // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IoctlCode,                       // Control code
                 Request,                         // Input buffer
                 RequestSize,                     // Input buffer size
                 Response,                        // Output buffer
                 *ResponseSize                    // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     Handle,
                     TRUE,
                     NULL
                     );
    }

 
    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
        *ResponseSize = (ULONG)ioStatusBlock.Information;
    }
    else {
        *ResponseSize = 0;
    }

    return(status);
}


DWORD
IfIpGetInfoOffload(
    ULONG IfIndex,
    PULONG Flags
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    NTSTATUS Status;
    HANDLE Handle;
    ULONG ResponseBufferSize = sizeof(Flags);
    
    Status = OpenDriver(&Handle, L"\\Device\\Ip");    
    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }    

    Status = DoIoctl(
                 Handle,
                 IOCTL_IP_GET_OFFLOAD_CAPABILITY,
                 &IfIndex,
                 sizeof(IfIndex),
                 Flags,
                 &ResponseBufferSize
                 );

    CloseHandle(Handle);

    if (!NT_SUCCESS(Status)) {
        return(RtlNtStatusToDosError(Status));
    }

    return NO_ERROR;
}


DWORD
IfIpShowManyEx(
    LPCWSTR pwszMachineName,
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName,
    GUID *guid,
    DISPLAY_TYPE dtType,
    HANDLE hFile
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    switch (dtType) {

        case TYPE_IPADDR:
        case TYPE_DNS:
        case TYPE_WINS:
        case TYPE_IP_ALL:
            return IfIpShowManyExEx(pwszMachineName, IfIndex, wszIfFriendlyName, guid, dtType, hFile);
        
        case TYPE_OFFLOAD:
            return IfIpShowInfoOffload(IfIndex, wszIfFriendlyName);
            
    }
    
    return NO_ERROR;
}

DWORD
IfIpShowInfoOffload(
    ULONG IfIndex,
    PWCHAR wszIfFriendlyName
    )
/*++

Routine Description

Arguments
    
Return Value

--*/
{
    ULONG Flags;
    DWORD dwErr;
    PWCHAR pQuotedFriendlyIfName = NULL;


    pQuotedFriendlyIfName = MakeQuotedString( wszIfFriendlyName );
    if ( pQuotedFriendlyIfName == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

        
    dwErr = IfIpGetInfoOffload(IfIndex, &Flags);
    if (dwErr != NO_ERROR)
        return dwErr;

        
    DisplayMessage(g_hModule,
               MSG_OFFLOAD_HDR, pQuotedFriendlyIfName, IfIndex);

    if (Flags & TCP_XMT_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_TCP_XMT_CHECKSUM_OFFLOAD);
    }

    if (Flags & IP_XMT_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_IP_XMT_CHECKSUM_OFFLOAD);
    }

    if (Flags & TCP_RCV_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_TCP_RCV_CHECKSUM_OFFLOAD);
    }

    if (Flags & IP_RCV_CHECKSUM_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_IP_RCV_CHECKSUM_OFFLOAD);
    }

    if (Flags & TCP_LARGE_SEND_OFFLOAD) {
        DisplayMessage(g_hModule,
            MSG_TCP_LARGE_SEND_OFFLOAD);
    }



    if (Flags & IPSEC_OFFLOAD_CRYPTO_ONLY) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_CRYPTO_ONLY);
    }

    if (Flags & IPSEC_OFFLOAD_AH_ESP) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_ESP);
    }

    if (Flags & IPSEC_OFFLOAD_TPT_TUNNEL) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_TPT_TUNNEL);
    }

    if (Flags & IPSEC_OFFLOAD_V4_OPTIONS) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_V4_OPTIONS);
    }

    if (Flags & IPSEC_OFFLOAD_QUERY_SPI) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_QUERY_SPI);
    }



    if (Flags & IPSEC_OFFLOAD_AH_XMT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_XMT);
    }

    if (Flags & IPSEC_OFFLOAD_AH_RCV) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_RCV);
    }

    if (Flags & IPSEC_OFFLOAD_AH_TPT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_TPT);
    }

    if (Flags & IPSEC_OFFLOAD_AH_TUNNEL) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_TUNNEL);
    }

    if (Flags & IPSEC_OFFLOAD_AH_MD5) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_MD5);
    }

    if (Flags & IPSEC_OFFLOAD_AH_SHA_1) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_AH_SHA_1);
    }



    if (Flags & IPSEC_OFFLOAD_ESP_XMT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_XMT);
    }

    if (Flags & IPSEC_OFFLOAD_ESP_RCV) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_RCV);
    }

    if (Flags & IPSEC_OFFLOAD_ESP_TPT) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_TPT);
    }

    if (Flags & IPSEC_OFFLOAD_ESP_TUNNEL) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_TUNNEL);
    }

    if (Flags & IPSEC_OFFLOAD_ESP_DES) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_DES);
    }

    if (Flags & IPSEC_OFFLOAD_ESP_DES_40) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_DES_40);
    }

    if (Flags & IPSEC_OFFLOAD_ESP_3_DES) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_3_DES);
    }

    if (Flags & IPSEC_OFFLOAD_ESP_NONE) {
        DisplayMessage(g_hModule,
            MSG_IPSEC_OFFLOAD_ESP_NONE);
    }

    if ( pQuotedFriendlyIfName ) {
        FreeQuotedString( pQuotedFriendlyIfName );
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\repair.c ===
#include "precomp.h"

EXTERN_C
VOID
WINAPI
NetCfgDiagRepairRegistryBindings (
    IN FILE* pLogFile);


#define REG_DELETE  100

typedef enum {
    COND_NONE,
    COND_VALUE,
    COND_ADD,
    COND_DELETE,
} CONDITIONAL;

typedef struct _TR_VALUE_DESCRIPTOR {
    PCSTR SubKeyName;
    PCSTR ValueName;
    DWORD RegType;
    union {
        ULONG_PTR __asignany;
        ULONG DataValue;
        CONST BYTE *DataPointer;
    };
    DWORD DataSize;

    //
    // If Conditional is not COND_NONE, then the value is conditionally
    // dependent on the presence of a key of the same name under the
    // ConditionalParentKeyName.  If the key is present, the values
    // below are used.  If not the values above are used.
    //
    // If Conditional is COND_ADD, then the value is added/set if
    // if the conditional key is present, and deleted if it is not present.
    //
    // If Conditional is COND_DELETE, then the value is added/set if
    // the conditional key is NOT present, and deleted if it is present.
    //
    CONDITIONAL Conditional;
    union {
        ULONG_PTR __asignany2;
        ULONG ConditionalDataValue;
        CONST BYTE *ConditionalDataPointer;
    };
} TR_VALUE_DESCRIPTOR;

#define TRV_DW(_subkey, _valuename, _data) \
    { _subkey, _valuename, REG_DWORD, (ULONG_PTR)_data, sizeof(DWORD) },

#define TRV_DW_CV(_subkey, _valuename, _datafalse, _datatrue) \
    { _subkey, _valuename, REG_DWORD, (ULONG_PTR)_datafalse, sizeof(DWORD), \
      COND_VALUE, (ULONG_PTR)_datatrue },

#define TRV_DW_CA(_subkey, _valuename, _data) \
    { _subkey, _valuename, REG_DWORD, 0, sizeof(DWORD), COND_ADD, \
      (ULONG_PTR)_data },

#define TRV_DW_CD(_subkey, _valuename, _data) \
    { _subkey, _valuename, REG_DWORD, (ULONG_PTR)_data, sizeof(DWORD), \
      COND_DELETE, 0 },

#define TRV_ESZ(_subkey, _valuename, _esz) \
    { _subkey, _valuename, REG_EXPAND_SZ, (ULONG_PTR)_esz, sizeof(_esz) },

#define TRV_MSZ(_subkey, _valuename, _msz) \
    { _subkey, _valuename, REG_MULTI_SZ, (ULONG_PTR)_msz, sizeof(_msz) },

#define TRV_MSZ_CA(_subkey, _valuename, _msz) \
    { _subkey, _valuename, REG_MULTI_SZ, 0, sizeof(_msz), COND_ADD, \
      (ULONG_PTR)_msz },

#define TRV_SZ(_subkey, _valuename, _sz) \
    { _subkey, _valuename, REG_SZ, (ULONG_PTR)_sz, sizeof(_sz) },

#define TRV_SZ_CA(_subkey, _valuename, _sz) \
    { _subkey, _valuename, REG_SZ, 0, sizeof(_sz), COND_ADD, \
      (ULONG_PTR)_sz },

#define TRV_DEL(_subkey, _valuename) \
    { _subkey, _valuename, REG_DELETE, 0, 0 },

#define TRV_END() \
    { NULL, NULL, REG_NONE, 0, 0 }


typedef struct _TR_KEY_DESCRIPTOR {
    //
    // RootKey is one of the HKEY_* values.  (e.g. HKEY_LOCAL_MACHINE)
    //
    HKEY RootKey;

    //
    // ParentKey is the name of a subkey (under RootKey) where either the
    // values reside or subkeys are to be enumerated and values found under
    // each subkey.
    //
    PCSTR ParentKeyName;

    //
    // TRUE if all subkeys of Parentkey are to be enumerated and values
    // found under each of those subkeys.
    //
    BOOL EnumKey;

    //
    // Pointer to an array of value descriptors.  The array is terminated
    // with an entry of all zeros.
    //
    CONST TR_VALUE_DESCRIPTOR *Value;

    //
    // ConditionalParentKeyName is the name of a subkey (under RootKey) 
    // where a value/subkey may reside, whose presence or lack thereof 
    // may affect the values set under subkeys of ParentKeyName.
    //
    PCSTR ConditionalParentKeyName;
} TR_KEY_DESCRIPTOR;


#define DHCP_OPT_TCPIP(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\"_name"\0"

#define DHCP_OPT_TCPIP_INTERFACE(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\"_name"\0"

#define DHCP_OPT_LEGACY_TCPIP_INTERFACE(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\?\\Parameters\\Tcpip\\"_name"\0"

#define DHCP_OPT_NETBT(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\"_name

#define DHCP_OPT_NETBT_INTERFACE(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\Tcpip_?\\"_name"\0"

#define DHCP_OPT_NETBT_ADAPTER(_name) \
    "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Adapters\\?\\"_name"\0"

CONST TR_VALUE_DESCRIPTOR DhcpParameterOptions_Values [] =
{
    TRV_DW ("1",  "KeyType",      7)
    TRV_MSZ("1",  "RegLocation",  DHCP_OPT_TCPIP_INTERFACE       ("DhcpSubnetMaskOpt")
                                  DHCP_OPT_LEGACY_TCPIP_INTERFACE("DhcpSubnetMaskOpt"))
    TRV_DW ("3",  "KeyType",      7)
    TRV_MSZ("3",  "RegLocation",  DHCP_OPT_TCPIP_INTERFACE       ("DhcpDefaultGateway")
                                  DHCP_OPT_LEGACY_TCPIP_INTERFACE("DhcpDefaultGateway"))
    TRV_DW ("6",  "KeyType",      1)
    TRV_MSZ("6",  "RegLocation",  DHCP_OPT_TCPIP_INTERFACE("DhcpNameServer")
                                  DHCP_OPT_TCPIP          ("DhcpNameServer"))
    TRV_DW ("15", "KeyType",      1)
    TRV_MSZ("15", "RegLocation",  DHCP_OPT_TCPIP_INTERFACE("DhcpDomain")
                                  DHCP_OPT_TCPIP          ("DhcpDomain"))
    TRV_DW ("44", "KeyType",      1)
    TRV_MSZ("44", "RegLocation",  DHCP_OPT_NETBT_INTERFACE("DhcpNameServerList")
                                  DHCP_OPT_NETBT_ADAPTER  ("DhcpNameServer"))
    TRV_DW ("46", "KeyType",      4)
    TRV_SZ ("46", "RegLocation",  DHCP_OPT_NETBT("DhcpNodeType"))
    TRV_DW ("47", "KeyType",      1)
    TRV_SZ ("47", "RegLocation",  DHCP_OPT_NETBT("DhcpScopeID"))
    TRV_DW ("DhcpNetbiosOptions", "KeyType",      4)
    TRV_DW ("DhcpNetbiosOptions", "OptionId",     1)
    TRV_DW ("DhcpNetbiosOptions", "VendorType",   1)
    TRV_MSZ("DhcpNetbiosOptions", "RegLocation",  DHCP_OPT_NETBT_INTERFACE("DhcpNetbiosOptions"))
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR DhcpParameterOptions =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Parameters\\Options",
    FALSE,
    DhcpParameterOptions_Values
};


CONST TR_VALUE_DESCRIPTOR DhcpParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\dhcpcsvc.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR DhcpParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Parameters",
    FALSE,
    DhcpParameter_Values
};


CONST TR_VALUE_DESCRIPTOR DnscacheParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\dnsrslvr.dll")
    TRV_DEL(NULL, "AdapterTimeoutCacheTime")
    TRV_DEL(NULL, "CacheHashTableBucketSize")
    TRV_DEL(NULL, "CacheHashTableSize")
    TRV_DEL(NULL, "DefaultRegistrationRefreshInterval")
    TRV_DEL(NULL, "MaxCacheEntryTtlLimit")
    TRV_DEL(NULL, "MaxSoaCacheEntryTtlLimit")
    TRV_DEL(NULL, "NegativeCacheTime")
    TRV_DEL(NULL, "NegativeSoaCacheTime")
    TRV_DEL(NULL, "NetFailureCacheTime")
    TRV_DEL(NULL, "NetFailureErrorPopupLimit")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR DnscacheParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Dnscache\\Parameters",
    FALSE,
    DnscacheParameter_Values
};


CONST TR_VALUE_DESCRIPTOR LmHostsParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\lmhsvc.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR LmHostsParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\LmHosts\\Parameters",
    FALSE,
    LmHostsParameter_Values
};


CONST TR_VALUE_DESCRIPTOR NetbtInterface_Values [] =
{
    TRV_DEL(NULL, "EnableAdapterDomainNameRegistration")
    TRV_MSZ(NULL, "NameServerList", "")
    TRV_DW (NULL, "NetbiosOptions", 0)
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR NetbtInterfaces =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Netbt\\Parameters\\Interfaces",
    TRUE,
    NetbtInterface_Values
};


CONST TR_VALUE_DESCRIPTOR NetbtParameter_Values [] =
{
    TRV_DEL(NULL, "BacklogIncrement")
    TRV_DW (NULL, "BcastNameQueryCount", 3)
    TRV_DW (NULL, "BcastQueryTimeout", 750)
    TRV_DEL(NULL, "BroadcastAddress")
    TRV_DEL(NULL, "CachePerAdapterEnabled")
    TRV_DW (NULL, "CacheTimeout", 600000)
    TRV_DEL(NULL, "ConnectOnRequestedInterfaceOnly")
    TRV_DEL(NULL, "EnableDns")
    TRV_DEL(NULL, "EnableLmhosts")
    TRV_DEL(NULL, "EnableProxy")
    TRV_DEL(NULL, "EnableProxyRegCheck")
    TRV_DEL(NULL, "InitialRefreshT.O.")
    TRV_DEL(NULL, "LmhostsTimeout")
    TRV_DEL(NULL, "MaxConnBackLog")
    TRV_DEL(NULL, "MaxDgramBuffering")
    TRV_DEL(NULL, "MaxPreloadEntries")
    TRV_DEL(NULL, "MinimumFreeLowerConnections")
    TRV_DEL(NULL, "MinimumRefreshSleepTime")
    TRV_DW (NULL, "NameServerPort", 137)
    TRV_DW (NULL, "NameSrvQueryCount", 3)
    TRV_DW (NULL, "NameSrvQueryTimeout", 1500)
    TRV_SZ (NULL, "NbProvider", "_tcp")
    TRV_DEL(NULL, "NodeType")
    TRV_DEL(NULL, "NoNameReleaseOnDemand")
    TRV_DEL(NULL, "RandomAdapter")
    TRV_DEL(NULL, "RefreshOpCode")
    TRV_DEL(NULL, "ScopeId")
    TRV_DW (NULL, "SessionKeepAlive", 3600000)
    TRV_DEL(NULL, "SingleResponse")
    TRV_DW (NULL, "Size/Small/Medium/Large", 1)
    TRV_DEL(NULL, "SmbDeviceEnabled")
    TRV_SZ (NULL, "TransportBindName", "\\Device\\")
    TRV_DEL(NULL, "TryAllIpAddrs")
    TRV_DEL(NULL, "TryAllNameServers")
    TRV_DEL(NULL, "UseDnsOnlyForNameResolutions")
    TRV_DEL(NULL, "WinsDownTimeout")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR NetbtParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Netbt\\Parameters",
    FALSE,
    NetbtParameter_Values
};


CONST TR_VALUE_DESCRIPTOR NlaParameter_Values [] =
{
    TRV_ESZ(NULL, "ServiceDll", "%SystemRoot%\\System32\\mswsock.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR NlaParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Nla\\Parameters",
    FALSE,
    NlaParameter_Values
};


CONST TR_VALUE_DESCRIPTOR TcpipInterface_Values [] =
{
    TRV_DW_CA (NULL, "AddressType", 0)
    TRV_MSZ   (NULL, "DefaultGateway", "")
    TRV_MSZ_CA(NULL, "DefaultGatewayMetric", "")
    TRV_DW_CA (NULL, "DisableDynamicUpdate", 0)
    TRV_DEL   (NULL, "DisableReverseAddressRegistrations")
    TRV_DW_CD (NULL, "DontAddDefaultGateway", 0)
    TRV_DW_CV (NULL, "EnableDhcp", 0, 1)
    TRV_MSZ   (NULL, "IpAddress", "0.0.0.0\0")
    TRV_DEL   (NULL, "IpAutoconfigurationAddress")
    TRV_DEL   (NULL, "IpAutoconfigurationEnabled")
    TRV_DEL   (NULL, "IpAutoconfigurationMask")
    TRV_DEL   (NULL, "IpAutoconfigurationSeed")
    TRV_DEL   (NULL, "IpAutoconfigurationSubnet")
    TRV_DEL   (NULL, "MaxForwardPending")
    TRV_DEL   (NULL, "Mtu")
    TRV_SZ_CA (NULL, "NameServer", "")
    TRV_DEL   (NULL, "PerformRouterDiscovery")
    TRV_DEL   (NULL, "PerformRouterDiscoveryBackup")
    TRV_DEL   (NULL, "PptpFiltering")
    TRV_MSZ_CA(NULL, "RawIpAllowedProtocols", "")
    TRV_DEL   (NULL, "SolicitationAddressBcast")
    TRV_MSZ   (NULL, "SubnetMask", "0.0.0.0\0")
    TRV_MSZ_CA(NULL, "TcpAllowedPorts", "")
    TRV_DEL   (NULL, "TcpDelAckTicks")
    TRV_DEL   (NULL, "TcpInitialRtt")
    TRV_DEL   (NULL, "TcpWindowSize")
    TRV_DEL   (NULL, "TypeOfInterface")
    TRV_MSZ_CA(NULL, "UdpAllowedPorts", "")
    TRV_DW    (NULL, "UseZeroBroadcast", 0)
    TRV_END   ()
};
CONST TR_KEY_DESCRIPTOR TcpipInterfaces =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces",
    TRUE,
    TcpipInterface_Values,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Adapters",
};


CONST TR_VALUE_DESCRIPTOR TcpipParameter_Values [] =
{
    TRV_DEL(NULL, "AllowUnqualifiedQuery")
    TRV_DEL(NULL, "AllowUserRawAccess")
    TRV_DEL(NULL, "ArpAlwaysSourceRoute")
    TRV_DEL(NULL, "ArpCacheLife")
    TRV_DEL(NULL, "ArpCacheMinReferencedLife")
    TRV_DEL(NULL, "ArpRetryCount")
    TRV_DEL(NULL, "ArpTrSingleRoute")
    TRV_DEL(NULL, "ArpUseEtherSnap")
    TRV_ESZ(NULL, "DatabasePath", "%SystemRoot%\\System32\\drivers\\etc")
    TRV_DEL(NULL, "DefaultRegistrationTtl")
    TRV_DEL(NULL, "DefaultTosValue")
    TRV_DEL(NULL, "DefaultTtl")
    TRV_DEL(NULL, "DisableDhcpMediaSense")
    TRV_DEL(NULL, "DisableDynamicUpdate")
    TRV_DEL(NULL, "DisableIpSourceRouting")
    TRV_DEL(NULL, "DisableMediaSenseEventLog")
    TRV_DEL(NULL, "DisableReplaceAddressesInConflicts")
    TRV_DEL(NULL, "DisableTaskOffload")
    TRV_DEL(NULL, "DisableUserTosSetting")
    TRV_DEL(NULL, "DisjointNameSpace")
    TRV_DEL(NULL, "DontAddDefaultGatewayDefault")
    TRV_DEL(NULL, "DnsQueryTimeouts")
    TRV_DEL(NULL, "EnableAddrMaskReply")
    TRV_DEL(NULL, "EnableBcastArpReply")
    TRV_DEL(NULL, "EnableDeadGwDetect")
    TRV_DEL(NULL, "EnableFastRouteLookup")
    TRV_DEL(NULL, "EnableIcmpRedirect")
    TRV_DEL(NULL, "EnableMulticastForwarding")
    TRV_DEL(NULL, "EnablePmtuBhDetect")
    TRV_DEL(NULL, "EnablePmtuDiscovery")
    TRV_DEL(NULL, "EnableSecurityFilters")
    TRV_DEL(NULL, "FfpControlFlags")
    TRV_DEL(NULL, "FfpFastForwardingCacheSize")
    TRV_DW (NULL, "ForwardBroadcasts", 0)
    TRV_DEL(NULL, "ForwardBufferMemory")
    TRV_DEL(NULL, "GlobalMaxTcpWindowSize")
    TRV_DEL(NULL, "IgmpLevel")
    TRV_DEL(NULL, "IpAutoconfigurationEnabled")
    TRV_DEL(NULL, "IpAutoconfigurationMask")
    TRV_DEL(NULL, "IpAutoconfigurationSeed")
    TRV_DW (NULL, "IpEnableRouter", 0)
    TRV_DEL(NULL, "IpEnableRouterBackup")
    TRV_DEL(NULL, "KeepAliveInterval")
    TRV_DEL(NULL, "KeepAliveTime")
    TRV_SZ (NULL, "NameServer", "")
    TRV_DEL(NULL, "MaxForwardBufferMemory")
    TRV_DEL(NULL, "MaxFreeTWTcbs")
    TRV_DEL(NULL, "MaxFreeTcbs")
    TRV_DEL(NULL, "MaxHashTableSize")
    TRV_DEL(NULL, "MaxNormLookupMemory")
    TRV_DEL(NULL, "MaxNumForwardPackets")
    TRV_DEL(NULL, "MaxUserPort")
    TRV_DEL(NULL, "NumForwardPackets")
    TRV_DEL(NULL, "NumTcbTablePartitions")
    TRV_DEL(NULL, "PptpTcpMaxDataRetransmissions")
    TRV_DEL(NULL, "PrioritizeRecordData")
    TRV_DEL(NULL, "QueryIpMatching")
    TRV_DEL(NULL, "SackOpts")
    TRV_DEL(NULL, "SearchList")
    TRV_DEL(NULL, "SynAttackProtect")
    TRV_DEL(NULL, "Tcp1323Opts")
    TRV_DEL(NULL, "TcpMaxConnectResponseRetransmissions")
    TRV_DEL(NULL, "TcpMaxConnectRetransmissions")
    TRV_DEL(NULL, "TcpMaxDataRetransmissions")
    TRV_DEL(NULL, "TcpMaxDupAcks")
    TRV_DEL(NULL, "TcpMaxHalfOpen")
    TRV_DEL(NULL, "TcpMaxHalfOpenRetried")
    TRV_DEL(NULL, "TcpMaxPortsExhausted")
    TRV_DEL(NULL, "TcpMaxSendFree")
    TRV_DEL(NULL, "TcpNumConnections")
    TRV_DEL(NULL, "TcpTimedWaitDelay")
    TRV_DEL(NULL, "TcpUseRfc1122UrgentPointer")
    TRV_DEL(NULL, "TcpWindowSize")
    TRV_DEL(NULL, "TrFunctionalMcastAddress")
    TRV_DEL(NULL, "UpdateSecurityLevel")
    TRV_DEL(NULL, "UseDomainNameDevolution")
    TRV_DW ("Winsock", "UseDelayedAcceptance", 0)
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR TcpipParameters =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
    FALSE,
    TcpipParameter_Values
};


CONST TR_VALUE_DESCRIPTOR TcpipPerformance_Values [] =
{
    TRV_SZ (NULL, "Close", "CloseTcpIpPerformanceData")
    TRV_SZ (NULL, "Collect", "CollectTcpIpPerformanceData")
    TRV_SZ (NULL, "Library", "Perfctrs.dll")
    TRV_SZ (NULL, "Open", "OpenTcpIpPerformanceData")
    TRV_SZ (NULL, "Object List", "502 510 546 582 638 658")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR TcpipPerformance =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Performance",
    FALSE,
    TcpipPerformance_Values
};


CONST TR_VALUE_DESCRIPTOR TcpipServiceProvider_Values [] =
{
    TRV_DW (NULL, "Class", 8)
    TRV_DW (NULL, "DnsPriority", 2000)
    TRV_DW (NULL, "HostsPriority", 500)
    TRV_DW (NULL, "LocalPriority", 499)
    TRV_DW (NULL, "NetbtPriority", 2001)
    TRV_SZ (NULL, "Name", "TCP/IP")
    TRV_ESZ(NULL, "ProviderPath", "%SystemRoot%\\System32\\wsock32.dll")
    TRV_END()
};
CONST TR_KEY_DESCRIPTOR TcpipServiceProvider =
{
    HKEY_LOCAL_MACHINE,
    "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\ServiceProvider",
    FALSE,
    TcpipServiceProvider_Values
};


CONST TR_KEY_DESCRIPTOR* TrRepairSet [] =
{
    &DhcpParameterOptions,
    &DhcpParameters,
    &DnscacheParameters,
    &LmHostsParameters,
    &NetbtInterfaces,
    &NetbtParameters,
    &NlaParameters,
    &TcpipInterfaces,
    &TcpipParameters,
    &TcpipPerformance,
    &TcpipServiceProvider,
    NULL
};


#define SAM_DESIRED KEY_READ | KEY_WRITE | DELETE


typedef enum _TR_LOG_ACTION {
    TR_ADDED,
    TR_DELETED,
    TR_RESET,
} TR_LOG_ACTION;

CONST PCSTR LogActionPrefix [] = {
    "added  ",
    "deleted",
    "reset  ",
};

typedef struct _TR_REPAIR_CONTEXT {
    HANDLE Heap;
    FILE *LogFile;
    PBYTE RegData;
    ULONG RegDataSize;
    CHAR EnumKeyName [MAX_PATH];
} TR_REPAIR_CONTEXT, *PTR_REPAIR_CTX;


BOOL
TrInitializeRepairContext(
    IN PTR_REPAIR_CTX Ctx,
    IN FILE *LogFile
    )
{
    ZeroMemory(Ctx, sizeof(TR_REPAIR_CONTEXT));
    Ctx->Heap = GetProcessHeap();
    Ctx->LogFile = LogFile;

    Ctx->RegDataSize = 1024;
    Ctx->RegData = HeapAlloc(Ctx->Heap, 0, Ctx->RegDataSize);

    *Ctx->EnumKeyName = 0;

    return (Ctx->RegData != NULL);
}

VOID
TrCleanupRepairContext(
    IN PTR_REPAIR_CTX Ctx
    )
{
    if (Ctx->RegData != NULL) {
        HeapFree(Ctx->Heap, 0, Ctx->RegData);
        Ctx->RegData = NULL;
    }
}

VOID
TrLogAction(
    IN TR_LOG_ACTION Action,
    IN PTR_REPAIR_CTX Ctx,
    IN CONST TR_KEY_DESCRIPTOR *Kd,
    IN CONST TR_VALUE_DESCRIPTOR *Vd
    )
{
    fprintf(Ctx->LogFile, "%s %s\\",
            LogActionPrefix[Action], Kd->ParentKeyName);

    if (Vd->SubKeyName != NULL) {
        fprintf(Ctx->LogFile, "%s\\", Vd->SubKeyName);
    }

    if (Kd->EnumKey) {
        fprintf(Ctx->LogFile, "%s\\", Ctx->EnumKeyName);
    }

    fprintf(Ctx->LogFile, "%s\n", Vd->ValueName);

    //
    // Show the value we are replacing.
    //
    if (TR_RESET == Action) {
        switch (Vd->RegType) {
        case REG_DWORD:
            fprintf(Ctx->LogFile, "            old REG_DWORD = %d\n\n", *(PULONG)Ctx->RegData);
            break;

        case REG_EXPAND_SZ:
            fprintf(Ctx->LogFile, "            old REG_EXPAND_SZ = %s\n\n", (PCSTR)Ctx->RegData);
            break;

        case REG_MULTI_SZ:
        {
            PCSTR Msz = (PCSTR)Ctx->RegData;

            fprintf(Ctx->LogFile, "            old REG_MULTI_SZ =\n");
            if (*Msz) {
                while (*Msz) {
                    fprintf(Ctx->LogFile, "                %s\n", Msz);
                    Msz += strlen(Msz) + 1;
                }
            } else {
                fprintf(Ctx->LogFile, "                <empty>\n");
            }
            fprintf(Ctx->LogFile, "\n");
            break;
        }

        case REG_SZ:
            fprintf(Ctx->LogFile, "            old REG_SZ = %s\n\n", (PCSTR)Ctx->RegData);
            break;

        default:
            break;
        }
    }
}

LONG
TrReadRegData(
    IN PTR_REPAIR_CTX Ctx,
    IN HKEY Key,
    IN CONST TR_VALUE_DESCRIPTOR *Vd,
    OUT PULONG ReturnedSize
    )
{
    LONG Error;
    ULONG Type, Size;

    *ReturnedSize = 0;

    Size = Ctx->RegDataSize;
    Error = RegQueryValueExA(Key, Vd->ValueName, NULL, &Type,
                             Ctx->RegData, &Size);

    if (ERROR_MORE_DATA == Error) {
        HeapFree(Ctx->Heap, 0, Ctx->RegData);
        Ctx->RegDataSize = (Size + 63) & ~63;
        Ctx->RegData = HeapAlloc(Ctx->Heap, 0, Ctx->RegDataSize);

        if (Ctx->RegData != NULL) {
            Size = Ctx->RegDataSize;
            Error = RegQueryValueExA(Key, Vd->ValueName, NULL, &Type,
                                     Ctx->RegData, &Size);
            if (NOERROR != Error) {
                fprintf(Ctx->LogFile,
                        "   RegQueryValueEx still failed. error = %d\n",
                        Error);
            } else {
                *ReturnedSize = Size;
            }
        } else {
            Error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else if (NOERROR == Error) {
        *ReturnedSize = Size;
    }

    return Error;
}

VOID
TrSetRegData(
    IN HKEY Key,
    IN CONST TR_VALUE_DESCRIPTOR *Vd,
    IN BOOLEAN ConditionalKeyPresent
    )
{
    CONST BYTE *Data;

    ConditionalKeyPresent &= (Vd->Conditional != COND_NONE);

    if (REG_DWORD == Vd->RegType) {
        Data = (CONST BYTE*)((ConditionalKeyPresent)? &Vd->ConditionalDataValue : &Vd->DataValue);
    } else {
        Data = (ConditionalKeyPresent)? Vd->ConditionalDataPointer : Vd->DataPointer;
    }

    RegSetValueExA(Key, Vd->ValueName, 0, Vd->RegType, Data, Vd->DataSize);
}

BOOLEAN
TrKeyShouldExist(
    IN CONST TR_VALUE_DESCRIPTOR *Vd,
    IN BOOLEAN ConditionalKeyPresent
    )
{
    if (REG_DELETE == Vd->RegType) {
        return FALSE;
    }

    if ((Vd->Conditional == COND_ADD) && !ConditionalKeyPresent) {
        return FALSE;
    }

    if ((Vd->Conditional == COND_DELETE) && ConditionalKeyPresent) {
        return FALSE;
    }

    return TRUE;
}

VOID
TrProcessOpenKey(
    IN PTR_REPAIR_CTX Ctx,
    IN HKEY ParentKey,
    IN BOOLEAN ConditionalKeyPresent,
    IN CONST TR_KEY_DESCRIPTOR *Kd
    )
{
    LONG Error;
    ULONG i, Size;
    CONST TR_VALUE_DESCRIPTOR *Vd, *PrevVd;
    HKEY SubKey, UseKey;

    PrevVd = NULL;
    SubKey = INVALID_HANDLE_VALUE;

    for (i = 0; Kd->Value[i].ValueName != NULL; i++) {
        Vd = &Kd->Value[i];

        if (Vd->SubKeyName == NULL) {
            UseKey = ParentKey;
        }

        //
        // Open a subkey if needed, and only if its not the same as
        // the one already open.
        //
        else if (((PrevVd == NULL) || (Vd->SubKeyName != PrevVd->SubKeyName))) {

            if (SubKey != INVALID_HANDLE_VALUE) {
                RegCloseKey(SubKey);
            }

            Error = RegOpenKeyExA(ParentKey, Vd->SubKeyName, 0,
                                 SAM_DESIRED, &SubKey);
            if (NOERROR == Error) {
                UseKey = SubKey;
            } else {
                SubKey = INVALID_HANDLE_VALUE;
            }
        }

        Error = TrReadRegData(Ctx, UseKey, Vd, &Size);

        if (ERROR_FILE_NOT_FOUND == Error) {

            if (TrKeyShouldExist(Vd, ConditionalKeyPresent)) {
                //
                // The value should exist, so set its default value.
                //
                TrSetRegData(UseKey, Vd, ConditionalKeyPresent);
                TrLogAction(TR_ADDED, Ctx, Kd, Vd);
            }

        } else if (NOERROR == Error) {
            //
            // The value exists and we read its data.
            //
            if (!TrKeyShouldExist(Vd, ConditionalKeyPresent)) {
                //
                // Need to delete the existing value.
                //
                RegDeleteValueA(UseKey, Vd->ValueName);
                TrLogAction(TR_DELETED, Ctx, Kd, Vd);
            } else {
                BOOL MisCompare = TRUE;
                //
                // Compare the value we read with the default value and reset
                // it if it is different.
                //
                if (Size == Vd->DataSize) {
                    if (REG_DWORD == Vd->RegType) {
                        MisCompare = (*(PULONG)Ctx->RegData != ((ConditionalKeyPresent && (Vd->Conditional != COND_NONE))? Vd->ConditionalDataValue : Vd->DataValue));
                    } else {
                        MisCompare = memcmp(Ctx->RegData, (ConditionalKeyPresent && (Vd->Conditional != COND_NONE))? Vd->ConditionalDataPointer : Vd->DataPointer, Size);
                    }
                }
                if (MisCompare) {
                    TrSetRegData(UseKey, Vd, ConditionalKeyPresent);
                    TrLogAction(TR_RESET, Ctx, Kd, Vd);
                }
            }

        } else {
            fprintf(Ctx->LogFile, "\nerror reading registry value (%s) (%d)\n", Vd->ValueName, Error);
        }

        PrevVd = Vd;
    }

    if (SubKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(SubKey);
    }
}

VOID
TrProcessKey(
    IN PTR_REPAIR_CTX Ctx,
    IN CONST TR_KEY_DESCRIPTOR *Kd
    )
{
    LONG Error;
    HKEY ParentKey, ConditionalParentKey;
    BOOLEAN ConditionalKeyPresent;

    Error = RegOpenKeyExA(Kd->RootKey, Kd->ConditionalParentKeyName, 0,
                          SAM_DESIRED, &ConditionalParentKey);
    if (NOERROR != Error) {
        ConditionalParentKey = NULL;
    }

    Error = RegOpenKeyExA(Kd->RootKey, Kd->ParentKeyName, 0,
                          SAM_DESIRED, &ParentKey);
    if (NOERROR == Error) {

        if (Kd->EnumKey) {
            ULONG i;
            ULONG EnumKeyNameLen;
            FILETIME LastWriteTime;
            HKEY SubKey, ConditionalSubKey;

            for (i = 0; NOERROR == Error; i++) {
                EnumKeyNameLen = sizeof(Ctx->EnumKeyName);
                Error = RegEnumKeyExA(ParentKey, i, Ctx->EnumKeyName, &EnumKeyNameLen,
                                      NULL, NULL, NULL, &LastWriteTime);
                if (NOERROR != Error) {
                    if (ERROR_NO_MORE_ITEMS != Error) {
                        fprintf(Ctx->LogFile, "enum error = %d  (index = %d)\n",
                                Error, i);
                    }
                    break;
                }

                ConditionalKeyPresent = FALSE;
                if (ConditionalParentKey) {
                    Error = RegOpenKeyExA(ConditionalParentKey, 
                                          Ctx->EnumKeyName, 0,
                                          SAM_DESIRED, &ConditionalSubKey);
                    if (NO_ERROR == Error) {
                        RegCloseKey(ConditionalSubKey);
                        ConditionalKeyPresent = TRUE;
                    }
                }

                Error = RegOpenKeyExA(ParentKey, Ctx->EnumKeyName, 0,
                                      SAM_DESIRED, &SubKey);
                if (NOERROR == Error) {
                    TrProcessOpenKey(Ctx, SubKey, ConditionalKeyPresent, Kd);

                    RegCloseKey(SubKey);
                }
            }
        } else {
            TrProcessOpenKey(Ctx, ParentKey, FALSE, Kd);
        }

        RegCloseKey(ParentKey);
    }

    if (ConditionalParentKey) {
        RegCloseKey(ConditionalParentKey);
    }
}


VOID
TrProcessSet(
    IN PTR_REPAIR_CTX Ctx,
    IN CONST TR_KEY_DESCRIPTOR *Set[]
    )
{
    ULONG i;

    //
    // Process each TR_KEY_DESCRIPTOR element in the set.
    //
    for (i = 0; Set[i] != NULL; i++) {
        TrProcessKey(Ctx, Set[i]);
    }
}


DWORD
TrRepair(
    FILE* LogFile
    )
{
    TR_REPAIR_CONTEXT Ctx;

    if (TrInitializeRepairContext(&Ctx, LogFile)) {

        TrProcessSet(&Ctx, TrRepairSet);

        NetCfgDiagRepairRegistryBindings(LogFile);

        TrCleanupRepairContext(&Ctx);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\ifstring.h ===
#define MSG_HELP_START                         _T("%1!-14s! - ")

    //
    // Tokens for commands
    // These must be in lower case
    //

#define CMD_GROUP_ADD                           L"add"
#define CMD_GROUP_DELETE                        L"delete"
#define CMD_GROUP_SHOW                          L"show"
#define CMD_GROUP_SET                           L"set"
#define CMD_GROUP_RESET                         L"reset"

#define CMD_DUMP                                L"dump"
#define CMD_HELP1                               L"help"
#define CMD_HELP2                               L"?"
#define CMD_IF_DUMP                             CMD_DUMP
#define CMD_IF_HELP1                            CMD_HELP1
#define CMD_IF_HELP2                            CMD_HELP2

#define CMD_IF_ADD_IF                           L"interface"
#define CMD_IF_DEL_IF                           L"interface"
#define CMD_IF_SHOW_IF                          L"interface"

#define CMD_IF_SET_CREDENTIALS                  L"credentials"
#define CMD_IF_SHOW_CREDENTIALS                 L"credentials"

#define CMD_IF_SET_INTERFACE                    L"interface"

#define CMD_IF_RESET_ALL                        L"all"


    // IF_IP commands
#define CMD_IFIP_SHOW_CONFIG                    L"config"

#define CMD_IFIP_ADD_IPADDR                     L"address"
#define CMD_IFIP_SET_IPADDR                     L"address"
#define CMD_IFIP_DEL_IPADDR                     L"address"
#define CMD_IFIP_SHOW_IPADDR                    L"address"

#define CMD_IFIP_ADD_DNS                        L"dns"
#define CMD_IFIP_SET_DNS                        L"dns"
#define CMD_IFIP_DEL_DNS                        L"dns"
#define CMD_IFIP_SHOW_DNS                       L"dns"

#define CMD_IFIP_ADD_WINS                       L"wins"
#define CMD_IFIP_SET_WINS                       L"wins"
#define CMD_IFIP_DEL_WINS                       L"wins"
#define CMD_IFIP_SHOW_WINS                      L"wins"

#define CMD_IFIP_SHOW_OFFLOAD                   L"offload"

#define CMD_IPMIB_SHOW_INTERFACE                L"interface"
#define CMD_IPMIB_SHOW_IPSTATS                  L"ipstats"
#define CMD_IPMIB_SHOW_IPADDRESS                L"ipaddress"
#define CMD_IPMIB_SHOW_IPNET                    L"ipnet"
#define CMD_IPMIB_SHOW_ICMP                     L"icmp"
#define CMD_IPMIB_SHOW_TCPSTATS                 L"tcpstats"
#define CMD_IPMIB_SHOW_TCPCONN                  L"tcpconn"
#define CMD_IPMIB_SHOW_UDPSTATS                 L"udpstats"
#define CMD_IPMIB_SHOW_UDPCONN                  L"udpconn"
#define CMD_IPMIB_SHOW_JOINS                    L"joins"

#define CMD_IFIP_DEL_ARPCACHE                   L"arpcache"

#define CMD_IFIP_RESET                          L"reset"

    //
    // TOKEN_Xxx are tokens for arguments
    // These must be in lower case
    //

#define TOKEN_NAME                             _T("name")
#define TOKEN_TYPE                             _T("type")
#define TOKEN_FULL                             _T("full")
#define TOKEN_USER                             _T("user")
#define TOKEN_DOMAIN                           _T("domain")
#define TOKEN_PASSWORD                         _T("password")
#define TOKEN_ADMIN                            _T("admin")
#define TOKEN_CONNECT                          _T("connect")
#define TOKEN_NEWNAME                          _T("newname")


    // tokens for interface/ip

#define TOKEN_SOURCE                            _T("source")
#define TOKEN_ADDR                              _T("addr")
#define TOKEN_MASK                              _T("mask")
#define TOKEN_GATEWAY                           _T("gateway")
#define TOKEN_GWMETRIC                          _T("gwmetric")
#define TOKEN_INDEX                             _T("index")
#define TOKEN_REGISTER                          _T("register")

#define TOKEN_MIB_OBJECT_INTERFACE              L"interface"
#define TOKEN_MIB_OBJECT_IPSTATS                L"ipstats"
#define TOKEN_MIB_OBJECT_IPADDRESS              L"ipaddress"
#define TOKEN_MIB_OBJECT_IPNET                  L"ipnet"
#define TOKEN_MIB_OBJECT_ICMP                   L"icmp"
#define TOKEN_MIB_OBJECT_TCPSTATS               L"tcpstats"
#define TOKEN_MIB_OBJECT_TCPCONN                L"tcpconn"
#define TOKEN_MIB_OBJECT_UDPSTATS               L"udpstats"
#define TOKEN_MIB_OBJECT_UDPCONN                L"udpconn"
#define TOKEN_MIB_OBJECT_JOINS                  L"joins"

    //
    // TOKEN_VALUE_Xxx are tokens for possible values than an argument
    // can take
    // These must be in upper case
    //

#define TOKEN_VALUE_ENABLED                    _T("ENABLED")
#define TOKEN_VALUE_DISABLED                   _T("DISABLED")
#define TOKEN_VALUE_CONNECTED                  _T("CONNECTED")
#define TOKEN_VALUE_DISCONNECTED               _T("DISCONNECTED")


// token values for ifIp

#define TOKEN_VALUE_DHCP                        _T("DHCP")
#define TOKEN_VALUE_STATIC                      _T("STATIC")
#define TOKEN_VALUE_NONE                        _T("NONE")
#define TOKEN_VALUE_ALL                         _T("ALL")
#define TOKEN_VALUE_PRIMARY                     _T("PRIMARY")
#define TOKEN_VALUE_BOTH                        _T("BOTH")


//
// Messages used to dump config - these closely follow the
// set/add help messages
//

#define DMP_IF_NEWLINE              L"\n"
#define DMP_IF_ADD_IF               L"\nadd interface name=%1!s! type=%2!s!"
#define DMP_IF_SET_IF               L"\nset interface name=%1!s! admin=%2!s!"
#define DMP_IF_SET_CRED_IF          L"\nset credentials name=%1!s! user=%2!s! domain=%3!s!"
#define DMP_IF_SET_CRED_IF_NOD      L"\nset credentials name=%1!s! user=%2!s!"
#define DMP_IF_HEADER               L"pushd interface\n\nreset all\n"
#define DMP_IF_FOOTER               L"\n\npopd\n"
#define DMP_IF_NOT_SUPPORTED        L"# Not yet supported"
#define DMP_IF_IPTUNNEL_CONFIG      L" srcaddr=%1!s! destaddr=%2!s! ttl=%3!d!"

#define DMP_IFIP_PUSHD              L"pushd interface ip\n"
#define DMP_IFIP_POPD               L"\n\n\npopd\n"
#define DMP_DHCP                    L"\nset address name=%1!s! source=dhcp "
#define DMP_STATIC                  L"\nset address name=%1!s! source=static "
#define DMP_IPADDR1                 L"addr=%1!s! mask=%2!s!"
#define DMP_IPADDR2                 L"\nadd address name=%1!s! addr=%2!s! mask=%3!s!"
#define DMP_GATEWAY1                L"\nset address name=%1!s! gateway=none"
#define DMP_GATEWAY2                L"\nset address name=%1!s! gateway=%2!s! gwmetric=%3!s!"
#define DMP_GATEWAY3                L"\nadd address name=%1!s! gateway=%2!s! gwmetric=%3!s!"
#define DMP_DNS_DHCP                L"\nset dns name=%1!s! source=dhcp"
#define DMP_DNS_STATIC_NONE         L"\nset dns name=%1!s! source=static addr=none"
#define DMP_DNS_STATIC_ADDR1        L"\nset dns name=%1!s! source=static addr=%2!s!"
#define DMP_DNS_STATIC_ADDR2        L"\nadd dns name=%1!s! addr=%2!s!"
#define DMP_WINS_DHCP               L"\nset wins name=%1!s! source=dhcp"
#define DMP_WINS_STATIC_NONE        L"\nset wins name=%1!s! source=static addr=none"
#define DMP_WINS_STATIC_ADDR1       L"\nset wins name=%1!s! source=static addr=%2!s!"
#define DMP_WINS_STATIC_ADDR2       L"\nadd wins name=%1!s! addr=%2!s!"

#define DMP_STRING_ARG              L" %1!s!=%2!s!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\routerdb.c ===
/*
    File    routerdb.c

    Implements a database abstraction for accessing router interfaces.

    If any caching/transactioning/commit-noncommit-moding is done, it
    should be implemented here with the api's remaining constant.

*/

#include "precomp.h"

EXTERN_C
HRESULT APIENTRY HrRenameConnection(const GUID* guidId, PCWSTR pszNewName);

typedef
DWORD 
(WINAPI *PRasValidateEntryName)(
    LPWSTR lpszPhonebook,   // pointer to full path and filename of phone-book file
    LPWSTR lpszEntry    // pointer to the entry name to validate
    );

typedef struct _RTR_IF_LIST
{
    WCHAR pszName[MAX_INTERFACE_NAME_LEN + 1];
    struct _RTR_IF_LIST* pNext;
    
} RTR_IF_LIST;

//
// Callback for RtrdbInterfaceEnumerate that adds the interface
// to a list if the interface is type wan.
//
DWORD
RtrdbAddWanIfToList(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwLevel,
    IN  DWORD   dwFormat,
    IN  PVOID   pvData,
    IN  HANDLE  hData)
{
    MPR_INTERFACE_0* pIf0 = (MPR_INTERFACE_0*)pvData;
    RTR_IF_LIST** ppList = (RTR_IF_LIST**)hData;
    RTR_IF_LIST* pNode = NULL;
    DWORD dwErr = NO_ERROR, dwSize;

    do
    {
        // See if the interface type is right
        //
        if (pIf0->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
        {
            // Initialize a new node for the list
            //
            pNode = (RTR_IF_LIST*) 
                IfutlAlloc(sizeof(RTR_IF_LIST), TRUE);
            if (pNode == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            dwSize = sizeof(pNode->pszName);
            dwErr = GetIfNameFromFriendlyName(
                        pwszIfName,
                        pNode->pszName,
                        &dwSize);
            BREAK_ON_DWERR(dwErr);

            // Add the interface to the list
            //
            pNode->pNext = *ppList;
            *ppList = pNode;
        }

    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            IfutlFree(pNode);
        }
    }

    return dwErr;
}

DWORD
RtrdbValidatePhoneBookEntry(
    PWSTR  pwszInterfaceName
    )
{
    HMODULE                     hRasApi32;
    PRasValidateEntryName       pfnRasValidateEntryName;
    DWORD                       dwErr;
    WCHAR                       rgwcPath[MAX_PATH+1];


    //
    // get phone book path + file name
    //

    if(g_pwszRouter is NULL)
    {
        dwErr =
            ExpandEnvironmentStringsW(LOCAL_ROUTER_PB_PATHW,
                                      rgwcPath,
                                      sizeof(rgwcPath)/sizeof(rgwcPath[0]));
    }
    else
    {
        dwErr = wsprintfW(rgwcPath,
                          REMOTE_ROUTER_PB_PATHW,
                          g_pwszRouter);
    }

    ASSERT(dwErr > 0);

    //
    // Load RASAPI32 DLL and call into it to verify specified
    // phone book entry
    //

    hRasApi32 = LoadLibraryW(L"RASAPI32.DLL");

    if(hRasApi32 isnot NULL)
    {
        pfnRasValidateEntryName =
            (PRasValidateEntryName) GetProcAddress(hRasApi32,
                                                   "RasValidateEntryNameW");
        
        if(pfnRasValidateEntryName isnot NULL )
        {
            dwErr = pfnRasValidateEntryName(rgwcPath,
                                            pwszInterfaceName);
                
            if(dwErr is NO_ERROR)
            {
                dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            }
            else
            {
                if(dwErr is ERROR_ALREADY_EXISTS)
                {
                    dwErr = NO_ERROR;
                }
            }
        }
        else
        {
            dwErr = GetLastError ();
        }

        FreeLibrary(hRasApi32);
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr;
}

DWORD
RtrInterfaceCreate(
    PMPR_INTERFACE_0    pIfInfo
    )
{
    DWORD   dwErr;
    HANDLE  hIfCfg, hIfAdmin;

    dwErr = MprConfigInterfaceCreate(g_hMprConfig,
                                     0,
                                     (PBYTE)pIfInfo,
                                     &hIfCfg);
                        
    if(dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule,
                     dwErr);
        
        return dwErr;
    }
                
    //
    // if router service is running add the interface
    // to it too.
    //
    
    if(IfutlIsRouterRunning())
    {
        dwErr = MprAdminInterfaceCreate(g_hMprAdmin,
                                        0,
                                        (PBYTE)pIfInfo,
                                        &hIfAdmin);
                            
        if(dwErr isnot NO_ERROR)
        {
            DisplayError(g_hModule,
                         dwErr);
        
            return dwErr;
        }
    }

    return NO_ERROR;
}

DWORD
RtrdbInterfaceAdd(
    IN PWCHAR pszInterface,
    IN DWORD  dwLevel,
    IN PVOID  pvInfo
    )

/*++

Routine Description:

    Adds an interface to the router

Arguments:

    pIfInfo     - Info for adding the interface

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr;
    HANDLE  hIfAdmin, hIfCfg;
    GUID    Guid;
    MPR_INTERFACE_0* pIfInfo = (MPR_INTERFACE_0*)pvInfo;

    //
    // If an interface with this name exists, bug out
    //
    
    if(pIfInfo->dwIfType is ROUTER_IF_TYPE_FULL_ROUTER)
    {
        //
        // to create an interface we need a phone book entry
        // for it.
        //

        dwErr = RtrdbValidatePhoneBookEntry(pIfInfo->wszInterfaceName);
        
        if(dwErr isnot NO_ERROR)
        {
            DisplayMessage(g_hModule,
                           EMSG_NO_PHONEBOOK,
                           pIfInfo->wszInterfaceName);

            return dwErr;
        }
    }
    else
    {
        DisplayMessage(g_hModule,
                       EMSG_BAD_IF_TYPE,
                       pIfInfo->dwIfType);

        return ERROR_INVALID_PARAMETER;
    }
     
    //
    // create interface with defaults
    //
            
    pIfInfo->hInterface = INVALID_HANDLE_VALUE;

    dwErr = RtrInterfaceCreate(pIfInfo);

    if(dwErr isnot NO_ERROR)
    {
        DisplayMessage(g_hModule,
                       EMSG_CANT_CREATE_IF,
                       pIfInfo->wszInterfaceName,
                       dwErr);
    }

    return dwErr;
}

DWORD
RtrdbInterfaceDelete(
    IN  PWCHAR  pwszIfName
    )

{
    DWORD   dwErr, dwSize, dwIfType;
    HANDLE  hIfCfg, hIfAdmin;
    GUID    Guid;

    PMPR_INTERFACE_0    pIfInfo;

    do
    {
        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            pwszIfName,
                                            &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }
    
        dwErr = MprConfigInterfaceGetInfo(g_hMprConfig,
                                          hIfCfg,
                                          0,
                                          (PBYTE *)&pIfInfo,
                                          &dwSize);
    
        if(dwErr isnot NO_ERROR)
        {
            break;
        }
        
        if(pIfInfo->dwIfType isnot ROUTER_IF_TYPE_FULL_ROUTER)
        {
            MprConfigBufferFree(pIfInfo);
        
            dwErr = ERROR_INVALID_PARAMETER;
        
            break;
        }

        if(IfutlIsRouterRunning())
        {        
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               pwszIfName,
                                               &hIfAdmin,
                                               FALSE);
        
            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        
            dwErr = MprAdminInterfaceDelete(g_hMprAdmin,
                                            hIfAdmin);
            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        
        }
       
        dwIfType = pIfInfo->dwIfType;

        dwErr = MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);
   
        MprConfigBufferFree(pIfInfo);
        
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

    }while(FALSE);

    return dwErr;
}

DWORD
RtrdbInterfaceEnumerate(
    IN DWORD dwLevel,
    IN DWORD dwFormat,
    IN RTR_IF_ENUM_FUNC pEnum,
    IN HANDLE hData 
    )
{
    DWORD dwErr, i, dwCount, dwTotal, dwResume, dwPrefBufSize;
    MPR_INTERFACE_0* pCurIf = NULL;
    LPBYTE pbBuffer = NULL;
    BOOL bRouter, bContinue;

    // Validate / Initiazlize
    if (pEnum == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    dwPrefBufSize = sizeof(MPR_INTERFACE_0) * 100; 
    bRouter = IfutlIsRouterRunning();
    dwResume = 0;

    do 
    {
        // Enumerate the first n interfaces
        //
        if (bRouter)
        {
            dwErr = MprAdminInterfaceEnum(
                        g_hMprAdmin,
                        0,
                        &pbBuffer,
                        dwPrefBufSize,
                        &dwCount,
                        &dwTotal,
                        &dwResume);
        }
        else
        {
            dwErr = MprConfigInterfaceEnum(
                        g_hMprConfig,
                        0,
                        &pbBuffer,
                        dwPrefBufSize,
                        &dwCount,
                        &dwTotal,
                        &dwResume);
        }
        if (dwErr == ERROR_MORE_DATA)
        {
            dwErr = NO_ERROR;
            bContinue = TRUE;
        }
        else
        {
            bContinue = FALSE;
        }
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Call the callback for each interface as long
        // as we're instructed to continue
        pCurIf = (MPR_INTERFACE_0*)pbBuffer;
        for (i = 0; (i < dwCount) && (dwErr == NO_ERROR); i++)
        {
            dwErr = (*pEnum)(
                        pCurIf->wszInterfaceName,
                        dwLevel,
                        dwFormat,
                        (PVOID)pCurIf,
                        hData);
            pCurIf++;                                
        }
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        // Free up the interface list buffer
	    if (pbBuffer)
	    {
	        if (bRouter)
	        {
	            MprAdminBufferFree(pbBuffer);
	        }
	        else 
	        {
    		    MprConfigBufferFree(pbBuffer);
    		}
            pbBuffer = NULL;
		}

		// Keep this loop going until there are 
		// no more interfaces
		//

    } while (bContinue);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrdbInterfaceRead(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo
    )
{
    DWORD   dwErr, dwSize;
    HANDLE  hIfCfg, hIfAdmin;
    
    PMPR_INTERFACE_0 pInfo = NULL;
    
    do
    {
        if(IfutlIsRouterRunning())
        {
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               pwszIfName,
                                               &hIfAdmin,
                                               FALSE);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }
            
            dwErr = MprAdminInterfaceGetInfo(g_hMprAdmin,
                                             hIfAdmin,
                                             0,
                                             (PBYTE *)&pInfo);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            if (pInfo == NULL)
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            *((MPR_INTERFACE_0*)pvInfo) = *pInfo;

            MprAdminBufferFree(pInfo);
            
        }
        else
        {
            dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                                pwszIfName,
                                                &hIfCfg);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }
            
            dwErr = MprConfigInterfaceGetInfo(g_hMprConfig,
                                              hIfCfg,
                                              0,
                                              (PBYTE *)&pInfo,
                                              &dwSize);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            *((MPR_INTERFACE_0*)pvInfo) = *pInfo;

            MprConfigBufferFree(pInfo);
        }
        
    } while(FALSE);

    return dwErr;
}

DWORD
RtrdbInterfaceWrite(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo
    )
{
    DWORD   dwErr;
    HANDLE  hIfCfg = NULL;
    MPR_INTERFACE_0* pIfInfo = (MPR_INTERFACE_0*)pvInfo;
    
    do
    {
        if(IfutlIsRouterRunning())
        {
            dwErr = MprAdminInterfaceSetInfo(g_hMprAdmin,
                                             pIfInfo->hInterface,
                                             0,
                                             (BYTE*)pIfInfo);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                                pIfInfo->wszInterfaceName,
                                                &hIfCfg);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            dwErr = MprConfigInterfaceSetInfo(g_hMprConfig,
                                              hIfCfg,
                                              0,
                                              (BYTE*)pIfInfo);
    
            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        }
        else
        {
            dwErr = MprConfigInterfaceSetInfo(g_hMprConfig,
                                              pIfInfo->hInterface,
                                              0,
                                              (BYTE*)pIfInfo);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }
        }            
        
    } while(FALSE);

    return dwErr;
}

DWORD
RtrdbInterfaceReadCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    )
{
    MPR_INTERFACE_0 If0;
    DWORD dwErr = NO_ERROR;

    do
    {
        ZeroMemory(&If0, sizeof(If0));
        dwErr = RtrdbInterfaceRead(
                    pszIfName,
                    0,
                    (PVOID)&If0);
        BREAK_ON_DWERR(dwErr);

        if (If0.dwIfType != ROUTER_IF_TYPE_FULL_ROUTER)
        {
            DisplayError(g_hModule, EMSG_IF_BAD_CREDENTIALS_TYPE);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Set the credentials
        //
        if (pszUser)
        {   
            pszUser[0] = L'\0';
        }
        if (pszDomain)
        {
            pszDomain[0] = L'\0';
        }
        if (pszPassword)
        {
            pszPassword[0] = L'\0';
        }            
        dwErr = MprAdminInterfaceGetCredentials(
                    g_pwszRouter,
                    pszIfName,
                    pszUser,
                    NULL,
                    pszDomain);
        BREAK_ON_DWERR(dwErr);

        if (pszPassword)
        {
            wcscpy(pszPassword, L"**********");
        }            
        
    } while (FALSE);        

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrdbInterfaceWriteCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    )
{
    MPR_INTERFACE_0 If0;
    DWORD dwErr = NO_ERROR;
    
    do
    {
        ZeroMemory(&If0, sizeof(If0));
        dwErr = RtrdbInterfaceRead(
                    pszIfName,
                    0,
                    (PVOID)&If0);
        BREAK_ON_DWERR(dwErr);
        if (If0.dwIfType != ROUTER_IF_TYPE_FULL_ROUTER)
        {
            DisplayError(g_hModule, EMSG_IF_BAD_CREDENTIALS_TYPE);
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Set the credentials
        //
        dwErr = MprAdminInterfaceSetCredentials(
                    g_pwszRouter,
                    pszIfName,
                    pszUser,
                    pszDomain,
                    pszPassword);
        BREAK_ON_DWERR(dwErr);
        
    } while (FALSE);        

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrdbInterfaceRename(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo,
    IN  PWCHAR     pszNewName)
{
    DWORD dwErr = NO_ERROR;
    HRESULT hr = S_OK;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UNICODE_STRING us;
    GUID Guid;

    do
    {
        // Get the guid from the interface name
        //
        RtlInitUnicodeString(&us, pwszIfName);
        ntStatus = RtlGUIDFromString(&us, &Guid);
        if (ntStatus != STATUS_SUCCESS)
        {
            dwErr = ERROR_BAD_FORMAT;
            break;
        }

        // Rename the interface
        //
        hr = HrRenameConnection(&Guid, pszNewName);
        if (FAILED(hr))
        {
            dwErr = HRESULT_CODE(hr);
            break;
        }
        
    } while (FALSE);

    // Cleanup
    //
    {
    }

    return dwErr;
}

DWORD
RtrdbResetAll()
{
    RTR_IF_LIST* pList = NULL, *pCur = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Build a list of interfaces that can be 
        // deleted
        //
        dwErr = RtrdbInterfaceEnumerate(
                    0,
                    0,
                    RtrdbAddWanIfToList,
                    (HANDLE)&pList);
        BREAK_ON_DWERR(dwErr);

        // Delete all of the interfaces
        //
        pCur = pList;
        while (pCur)
        {
            RtrdbInterfaceDelete(pCur->pszName);
            pCur = pCur->pNext;
            IfutlFree(pList);
            pList = pCur;
        }

    } while (FALSE);

    // Cleanup
    {
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\routerif.h ===
/*
    File: routerif.h

    Defines callbacks needed to deal with interfaces supported by
    the router.
*/

DWORD
RtrHandleResetAll(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleAdd(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleDel(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleSet(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleSetCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleShow(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleShowCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    );

DWORD
RtrHandleDump(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      *pbDone
    );

DWORD
RtrDump(
    IN  PWCHAR     *ppwcArguments,
    IN  DWORD       dwArgCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\showmib.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
     net\routing\netsh\if\showmib.c

Abstract:

    Fns to parse and show MIB information

Author:

     v raman

Revision History:

     Anand Mahalingam
     Dave Thaler
--*/

#include "precomp.h"
#pragma hdrstop
#include <time.h>

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

HANDLE g_hConsole, g_hStdOut;

MIB_OBJECT_PARSER   MIBObjectMap[] =
{
    {TOKEN_MIB_OBJECT_INTERFACE,1,GetMIBIfIndex},
    {TOKEN_MIB_OBJECT_IPSTATS,  0,NULL},
    {TOKEN_MIB_OBJECT_IPADDRESS,1,GetMIBIpAddress},
    {TOKEN_MIB_OBJECT_IPNET,    2,GetMIBIpNetIndex},
    {TOKEN_MIB_OBJECT_ICMP,     0,NULL},
    {TOKEN_MIB_OBJECT_TCPSTATS, 0,NULL},
    {TOKEN_MIB_OBJECT_TCPCONN,  4,GetMIBTcpConnIndex},
    {TOKEN_MIB_OBJECT_UDPSTATS, 0,NULL},
    {TOKEN_MIB_OBJECT_UDPCONN,  2,GetMIBUdpConnIndex},
};

ULONG   g_ulNumMibObjects = sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER);

MAGIC_TABLE    MIBVar[] = {
    {IF_ROW,          PrintIfRow},
    {IF_TABLE,        PrintIfTable},
    {IP_STATS,        PrintIpStats},
    {IP_STATS,        PrintIpStats},
    {IP_ADDRROW,      PrintIpAddrRow},
    {IP_ADDRTABLE,    PrintIpAddrTable},
    {IP_NETROW,       PrintIpNetRow},
    {IP_NETTABLE,     PrintIpNetTable},
    {ICMP_STATS,      PrintIcmp},
    {ICMP_STATS,      PrintIcmp},
    {TCP_STATS,       PrintTcpStats},
    {TCP_STATS,       PrintTcpStats},
    {TCP_ROW,         PrintTcpRow},
    {TCP_TABLE,       PrintTcpTable},
    {UDP_STATS,       PrintUdpStats},
    {UDP_STATS,       PrintUdpStats},
    {UDP_ROW,         PrintUdpRow},
    {UDP_TABLE,       PrintUdpTable},
};

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the interface index.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER
    
--*/
{
    DWORD dwErr = NO_ERROR;

    *pdwNumParsed = 1;

    // If index was specified just use it

    if (iswdigit(pptcArguments[dwCurrentIndex][0]))
    {
        pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

        return NO_ERROR;
    }

    // Try converting a friendly name to an ifindex

    return IfutlGetIfIndexFromFriendlyName( pptcArguments[dwCurrentIndex],
                                       &pdwIndices[0] );
}
    
DWORD
GetMIBIpAddress(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the IP address.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(pptcArguments[dwCurrentIndex], &pdwIndices[0]);

    *pdwNumParsed = 1;

    return dwErr;
}

DWORD
GetMIBIpNetIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the IP net index

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr;

    pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

    dwErr = GetIpAddress(pptcArguments[dwCurrentIndex + 1], &pdwIndices[1]);

    *pdwNumParsed = 2;

    return dwErr;
}


DWORD
GetMIBTcpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the tco conn index

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(pptcArguments[dwCurrentIndex], &pdwIndices[0]);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    pdwIndices[1] = htons((WORD)(_tcstoul(pptcArguments[dwCurrentIndex + 1],NULL,10)));

    dwErr = GetIpAddress(pptcArguments[dwCurrentIndex + 2], &pdwIndices[2]);

    pdwIndices[3] = htons((WORD)(_tcstoul(pptcArguments[dwCurrentIndex + 3],
                                          NULL,10)));

    *pdwNumParsed = 4;

    return dwErr;
}

DWORD
GetMIBUdpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the udp conn index

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(pptcArguments[dwCurrentIndex], &pdwIndices[0]);

    pdwIndices[1] = htons((WORD)(_tcstoul(pptcArguments[dwCurrentIndex + 1],
                                          NULL,10)));

    *pdwNumParsed = 2;

    return dwErr;
}

DWORD
GetIgmpList(IN IPV4_ADDRESS NTEAddr,
        OUT IPV4_ADDRESS *pIgmpList,
        OUT PULONG dwOutBufLen
        );

DWORD
GetPrintJoinRow(
    IPV4_ADDRESS ipAddr
    )
{
    DWORD         dwOutBufLen = 0;
    IPV4_ADDRESS *pIgmpList = NULL;
    DWORD         dwStatus;
    DWORD i;

    dwStatus = GetIgmpList( ipAddr,
                            pIgmpList,
                            &dwOutBufLen );

    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) 
    {
       pIgmpList = HeapAlloc(GetProcessHeap(), 0, dwOutBufLen);
       if (!pIgmpList)
           return ERROR_NOT_ENOUGH_MEMORY;

       dwStatus = GetIgmpList( ipAddr,
                               pIgmpList,
                               &dwOutBufLen );
    }
      
    if (dwStatus == STATUS_SUCCESS) 
    {
        WCHAR pwszIfAddr[20], pwszGrAddr[20];
        DWORD dwTotal = dwOutBufLen/sizeof(ipAddr);

        MakeAddressStringW(pwszIfAddr, ipAddr);
        if (!pwszIfAddr)
            return ERROR_NOT_ENOUGH_MEMORY;

        for (i=0; i<dwTotal; i++)
        {
            MakeAddressStringW(pwszGrAddr, pIgmpList[i]);
            if (!pwszGrAddr)
                return ERROR_NOT_ENOUGH_MEMORY;
                
            DisplayMessage(    g_hModule, 
                               MSG_MIB_JOIN_ROW,
                               pwszIfAddr,
                               pwszGrAddr );
        }
    }

    if (pIgmpList)
        HeapFree(GetProcessHeap(), 0, pIgmpList);

    return dwStatus;
}

DWORD
GetIPv4Addresses(
    IN LPSOCKET_ADDRESS_LIST *ppList)
{
    LPSOCKET_ADDRESS_LIST pList = NULL;
    ULONG                 ulSize = 0;
    DWORD                 dwErr;
    DWORD                 dwBytesReturned;
    SOCKET                s;

    *ppList = NULL;

    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET)
        return WSAGetLastError();

    for (;;) {
        dwErr = WSAIoctl(s, SIO_ADDRESS_LIST_QUERY, NULL, 0, pList, ulSize, 
                         &dwBytesReturned, NULL, NULL);

        if (!dwErr) {
            break;
        }

        if (pList) {
            FREE(pList);
            pList = NULL;
        }
    
        dwErr = WSAGetLastError();
        if (dwErr != WSAEFAULT)
            break;
    
        pList = MALLOC(dwBytesReturned);
        if (!pList) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        ulSize = dwBytesReturned;
    }

    closesocket(s);

    *ppList = pList;
    return dwErr;
}

DWORD
HandleIpShowJoins(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    MIB_OPAQUE_QUERY Query;
    PMIB_IPADDRTABLE lprpcTable;
    DWORD            dwOutBufLen = 0 , 
                     dwNumParsed;
    IPV4_ADDRESS    *pIgmpList = NULL, 
                     ipAddr;
    DWORD            dwResult = NO_ERROR,
                     dwOutEntrySize;
    DWORD            i;
    PMIB_OPAQUE_INFO pRpcInfo;
    PWCHAR           pszIfAddr;
    IFMON_CMD_ARG    pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING,
            {TOKEN_ADDR,  FALSE, FALSE},
            NULL,
            0,
            NULL
        }
    };

    do 
    {
        dwResult = IfutlParse( ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               NULL,
                               pArgs,
                               sizeof(pArgs) / sizeof(*pArgs));
        if (dwResult)
        {
            break;
        }

        DisplayMessage(g_hModule, MSG_MIB_JOIN_HDR);

        if (pArgs[0].rgTag.bPresent)
        {
            // address specified
            pszIfAddr = IFMON_CMD_ARG_GetPsz(&pArgs[0]);

            dwResult = GetIpAddress( pszIfAddr, &ipAddr );
            if (dwResult)
            {
                break;
            }
    
            GetPrintJoinRow(ipAddr);
        }
        else
        {
            SOCKET_ADDRESS_LIST *pList;
            INT                  j;

            // Get all IPv4 addresses
            dwResult = GetIPv4Addresses(&pList);
            if (dwResult != NO_ERROR)
                break;

            // For each IPv4 address
            for (j=0; j<pList->iAddressCount; j++)
            {
                GetPrintJoinRow( ((LPSOCKADDR_IN)pList->Address[j].lpSockaddr)->sin_addr.s_addr );
            }

            FREE(pList);
        }

    } while (FALSE);

    return dwResult;
}

DWORD
HandleIpMibShowObject(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Parses command to get MIB object and optional parameters

Arguments:

Return Value:

--*/
{
    DWORD                dwIndices[MAX_NUM_INDICES];
    DWORD                dwNumParsed = 0;
    PMIB_OPAQUE_QUERY    pQuery = NULL;
    PMIB_OPAQUE_INFO     pRpcInfo;
    DWORD                dwQuerySize;
    BOOL                 bFound = FALSE,bOptPresent = FALSE;
    DWORD                dwRefreshRate;
    DWORD                dwOutEntrySize;
    DWORD                i,dwResult,dwErr;
    DWORD                dwMIBIndex, dwIndex;
    BOOL                 bIndex = FALSE, dwType;
    DWORD                dwRR = 0, dwInd = 0;
    HANDLE               hMib;
    
#if 0
    TOKEN_VALUE          tvMfeTypes[] =
    {
        { TOKEN_VALUE_POSITIVE, PositiveMfe },
        { TOKEN_VALUE_NEGATIVE, NegativeMfe },
        { TOKEN_VALUE_BOTH, Both }
    };
#endif

    
    if ( ! IfutlIsRouterRunning() )
    {
        if (g_pwszRouter)
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_REMOTE_ROUTER_NOT_RUNNING, 
                           g_pwszRouter);
        } 
        else 
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_LOCAL_ROUTER_NOT_RUNNING);
        }

        return NO_ERROR;
    }
    
    //
    // Match MIB object
    //

    ppwcArguments += (dwCurrentIndex-1);
    dwArgCount    -= (dwCurrentIndex-1);
    dwCurrentIndex = 1;

    //DEBUG2("In IP MIB Show : %s\n",pptcArguments[0]);

    for (i = 0; i < sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER); i++)
    {
        if (MatchToken(ppwcArguments[0],MIBObjectMap[i].pwszMIBObj))
        {
            dwIndex = i;
            bFound = TRUE;
        
            break;
        }
    
    }
    
    if (!bFound)
    {
        return ERROR_CMD_NOT_FOUND;
    }

#if 0
    //
    // Special case for MFEs where MFE type is specified
    // before index option
    //

    if ( ( MIBVar[ 2 * dwIndex ].dwId is MCAST_MFE ) ||
         ( MIBVar[ 2 * dwIndex ].dwId is MCAST_MFE_STATS ) )
    {
        if ( dwArgCount > 1 )
        {
            if ( !_wcsnicmp( ppwcArguments[ 1 ], L"TYPE=", 5 ) )
            {
                wcscpy( ppwcArguments[ 1 ], &ppwcArguments[ 1 ][ 5 ] );  
            }
            
            dwErr = MatchEnumTag(
                        g_hModule, ppwcArguments[ 1 ],
                        NUM_TOKENS_IN_TABLE( tvMfeTypes ), tvMfeTypes,
                        &dwType
                        );
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        
        if (dwErr isnot NO_ERROR)
        {
            return ERROR_INVALID_SYNTAX;
        }
        
        dwErr = GetMibTagToken(&ppwcArguments[2],
                               dwArgCount - 2,
                               MIBObjectMap[dwIndex].dwMinOptArg,
                               &dwRR,
                               &bIndex,
                               &dwInd);
    }

    else
#endif
    {
        dwErr = GetMibTagToken(&ppwcArguments[1],
                               dwArgCount - 1,
                               MIBObjectMap[dwIndex].dwMinOptArg,
                               &dwRR,
                               &bIndex,
                               &dwInd);
    }

    
    if (dwErr isnot NO_ERROR)
    {
        return ERROR_INVALID_SYNTAX;
    }

    if (bIndex)
    {
        dwMIBIndex = dwIndex * 2;
        bOptPresent = TRUE;
    }
    else
    {
        dwMIBIndex = dwIndex * 2 + 1;
    }

    //
    // Convert refresh rate to msec
    //
    
    dwRR *= 1000;

    if (!InitializeConsole(&dwRR, &hMib, &g_hConsole))
    {
        return ERROR_INIT_DISPLAY;
    }

    //
    // Query the MIB
    //

    pQuery = NULL;

    for ( ; ; )
    {
        if(dwRR)
        {
            DisplayMessageToConsole(g_hModule,
                              g_hConsole,
                              MSG_CTRL_C_TO_QUIT);
        }

        // always...
        {
            if (!(dwMIBIndex % 2))
            {
                (*MIBObjectMap[dwIndex].pfnMIBObjParser)(ppwcArguments,
                                                         1,
                                                         dwIndices,
                                                         &dwNumParsed);
            }

            dwQuerySize = ( sizeof( MIB_OPAQUE_QUERY ) - sizeof( DWORD ) ) + 
                (dwNumParsed) * sizeof(DWORD);
        
            pQuery = (PMIB_OPAQUE_QUERY)HeapAlloc(GetProcessHeap(),
                                                  0,
                                                  dwQuerySize);
    
    
            if (pQuery is NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        
                return dwErr;
            }

            pQuery->dwVarId = MIBVar[dwMIBIndex].dwId;
    
            for( i = 0; i < dwNumParsed; i++ )
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
        
            dwResult = MibGet(             PID_IP,
                                           IPRTRMGR_PID,
                                           (PVOID) pQuery,
                                           dwQuerySize,
                                           (PVOID *) &pRpcInfo,
                                           &dwOutEntrySize );
    
            if ( dwResult isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwResult );
                return dwResult;
            }
        
            if ( pRpcInfo is NULL )
            {
                DisplayMessage(g_hModule,  MSG_IP_NO_ENTRIES );
                return dwResult;
            }

            (*MIBVar[dwMIBIndex].pfnPrintFunction)(g_hMIBServer, pRpcInfo);

            MprAdminMIBBufferFree( (PVOID) pRpcInfo );
        }
    
        if(pQuery != NULL )
        {
            HeapFree(GetProcessHeap(),0,pQuery);
        }

        if (!RefreshConsole(hMib, g_hConsole, dwRR))
        {
            break;
        }
    }
    
    return dwResult;
}
    
VOID 
PrintIfTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO  prpcInfo
    )
/*++

Routine Description:

    Prints interface table information

Arguments:

Return Value:

--*/
{
    PMIB_IFTABLE lprpcTable = (PMIB_IFTABLE)(prpcInfo->rgbyData);
    PTCHAR ptszIfType, ptszOper, ptszAdmin;
    TCHAR  tszDescr[MAXLEN_IFDESCR + 1], tszIfName[MAX_INTERFACE_NAME_LEN + 1];
    TCHAR  tszPhysAddr[DISPLAYLEN_PHYSADDR + 1];
    WCHAR  wszBuffer[MAX_INTERFACE_NAME_LEN+1];
    DWORD  dwSize;
    
    DWORD dwCount = lprpcTable->dwNumEntries;
    DWORD i;
    
    DisplayMessageToConsole(g_hModule, 
                      g_hConsole,
                      MSG_MIB_IF_HDR);
    
    if ( dwCount is 0 )
    {
        DisplayMessageToConsole(g_hModule, g_hConsole, MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < dwCount; i++)
    {
        switch(lprpcTable->table[i].dwType)
        {
            case IF_TYPE_ETHERNET_CSMACD:
            {
                ptszIfType = MakeString(g_hModule, STRING_ETHERNET);
                break;
            }
            case IF_TYPE_ISO88025_TOKENRING:
            {
                ptszIfType = MakeString(g_hModule, STRING_TOKENRING);
                break;
            }
            case IF_TYPE_FDDI:
            {
                ptszIfType = MakeString(g_hModule, STRING_FDDI);
                break;
            }
            case IF_TYPE_PPP:
            {
                ptszIfType = MakeString(g_hModule, STRING_PPP);
                break;
            }
            case IF_TYPE_SOFTWARE_LOOPBACK:
            {
                ptszIfType = MakeString(g_hModule, STRING_LOOPBACK);
                break;
            }
            case IF_TYPE_SLIP:
            {
                ptszIfType = MakeString(g_hModule, STRING_SLIP);
                break;
            }
            case IF_TYPE_OTHER:
            default:
            {
                ptszIfType = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
        
        switch(lprpcTable->table[i].dwAdminStatus)
        {
            case IF_ADMIN_STATUS_UP:
            {
                ptszAdmin = MakeString(g_hModule, STRING_UP);
                break;
            }
            case IF_ADMIN_STATUS_TESTING:
            {
                ptszAdmin = MakeString(g_hModule, STRING_TESTING);
                break;
            }
            case IF_ADMIN_STATUS_DOWN:
            default:
            {
                ptszAdmin = MakeString(g_hModule, STRING_DOWN);
                break;
            }
        }
        
        switch(lprpcTable->table[i].dwOperStatus)
        {
            case IF_OPER_STATUS_UNREACHABLE:
            {
                ptszOper = MakeString(g_hModule, STRING_UNREACHABLE);
                break;
            }
            case IF_OPER_STATUS_DISCONNECTED:
            {
                ptszOper = MakeString(g_hModule, STRING_DISCONNECTED);
                break;
            }
            case IF_OPER_STATUS_CONNECTING:
            {
                ptszOper = MakeString(g_hModule, STRING_CONNECTING);
                break;
            }
            case IF_OPER_STATUS_CONNECTED:
            {
                ptszOper = MakeString(g_hModule, STRING_CONNECTED);
                break;
            }
            case IF_OPER_STATUS_OPERATIONAL:
            {
                ptszOper = MakeString(g_hModule, STRING_OPERATIONAL);
                break;
            }
            case IF_OPER_STATUS_NON_OPERATIONAL:
            default:
            {
                ptszOper = MakeString(g_hModule, STRING_NON_OPERATIONAL);
                break;
            }
        }
    
#ifdef UNICODE
        wcscpy(tszIfName, lprpcTable->table[i].wszName);
        
        MultiByteToWideChar(GetConsoleOutputCP(),
                            0,
                            lprpcTable->table[i].bDescr,
                            -1,
                            tszDescr,
                            MAXLEN_IFDESCR);
#else
        WideCharToMultiByte(GetConsoleOutputCP(),
                            0,
                            lprpcTable->table[i].wszName,
                            -1,
                            tszIfName,
                            MAX_INTERFACE_NAME_LEN,
                            NULL,
                            NULL);
        
        strcpy(tszDescr,lprpcTable->table[i].bDescr);
#endif
        if (lprpcTable->table[i].dwPhysAddrLen == 0)
        {
            tszPhysAddr[0] = TEXT('\0');
        }
        else
        {
            MakeUnicodePhysAddr(tszPhysAddr,
                                lprpcTable->table[i].bPhysAddr,
                                lprpcTable->table[i].dwPhysAddrLen);
        }

        dwSize = sizeof(wszBuffer);
        IfutlGetInterfaceDescription( tszIfName, wszBuffer, &dwSize );

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_INTERFACE,
                       lprpcTable->table[i].dwIndex,
                       wszBuffer,
                       tszIfName,
                       ptszIfType,
                       lprpcTable->table[i].dwMtu,
                       lprpcTable->table[i].dwSpeed,
                       tszPhysAddr,
                       ptszAdmin,
                       ptszOper,
                       lprpcTable->table[i].dwLastChange,
                       lprpcTable->table[i].dwInOctets,
                       lprpcTable->table[i].dwInUcastPkts,
                       lprpcTable->table[i].dwInNUcastPkts,
                       lprpcTable->table[i].dwInDiscards,
                       lprpcTable->table[i].dwInErrors,
                       lprpcTable->table[i].dwInUnknownProtos,
                       lprpcTable->table[i].dwOutOctets,
                       lprpcTable->table[i].dwOutUcastPkts,
                       lprpcTable->table[i].dwOutNUcastPkts,
                       lprpcTable->table[i].dwOutDiscards,
                       lprpcTable->table[i].dwOutErrors,
                       lprpcTable->table[i].dwOutQLen,
                       tszDescr);
        
        FreeString(ptszIfType);
        FreeString(ptszAdmin);
        FreeString(ptszOper);
    }
}

VOID 
PrintIfRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO  prpcInfo
    )
/*++

Routine Description:

    Prints interface row information

Arguments:

Return Value:

--*/
{
    PMIB_IFROW ieRow = (PMIB_IFROW)(prpcInfo->rgbyData); 
    PTCHAR ptszIfType, ptszOper, ptszAdmin;
    TCHAR  tszDescr[MAXLEN_IFDESCR + 1], tszIfName[MAX_INTERFACE_NAME_LEN + 1];
    TCHAR  tszPhysAddr[DISPLAYLEN_PHYSADDR + 1];
    WCHAR  wszBuffer[MAX_INTERFACE_NAME_LEN+1];
    DWORD  dwSize;
    
    DisplayMessageToConsole(g_hModule, 
                      g_hConsole,
                      MSG_MIB_IF_HDR);
    
    switch(ieRow->dwType)
    {
        case IF_TYPE_ETHERNET_CSMACD:
        {
            ptszIfType = MakeString(g_hModule, STRING_ETHERNET);
            break;
        }
        case IF_TYPE_ISO88025_TOKENRING:
        {
            ptszIfType = MakeString(g_hModule, STRING_TOKENRING);
            break;
        }
        case IF_TYPE_FDDI:
        {
            ptszIfType = MakeString(g_hModule, STRING_FDDI);
            break;
        }
        case IF_TYPE_PPP:
        {
            ptszIfType = MakeString(g_hModule, STRING_PPP);
            break;
        }
        case IF_TYPE_SOFTWARE_LOOPBACK:
        {
            ptszIfType = MakeString(g_hModule, STRING_LOOPBACK);
            break;
        }
        case IF_TYPE_SLIP:
        {
            ptszIfType = MakeString(g_hModule, STRING_SLIP);
            break;
        }
        case IF_TYPE_OTHER:
        default:
        {
            ptszIfType = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }

    switch(ieRow->dwAdminStatus)
    {
        case IF_ADMIN_STATUS_UP:
        {
            ptszAdmin = MakeString(g_hModule, STRING_UP);
            break;
        }
        case IF_ADMIN_STATUS_TESTING:
        {
            ptszAdmin = MakeString(g_hModule, STRING_TESTING);
            break;
        }
        case IF_ADMIN_STATUS_DOWN:
        default:
        {
            ptszAdmin = MakeString(g_hModule, STRING_DOWN);
            break;
        }
    }

    switch(ieRow->dwOperStatus)
    {
        case IF_OPER_STATUS_UNREACHABLE:
        {
            ptszOper = MakeString(g_hModule, STRING_UNREACHABLE);
            break;
        }
        case IF_OPER_STATUS_DISCONNECTED:
        {
            ptszOper = MakeString(g_hModule, STRING_DISCONNECTED);
            break;
        }
        case IF_OPER_STATUS_CONNECTING:
        {
            ptszOper = MakeString(g_hModule, STRING_CONNECTING);
            break;
        }
        case IF_OPER_STATUS_CONNECTED:
        {
            ptszOper = MakeString(g_hModule, STRING_CONNECTED);
            break;
        }
        case IF_OPER_STATUS_OPERATIONAL:
        {
            ptszOper = MakeString(g_hModule, STRING_OPERATIONAL);
            break;
        }
        case IF_OPER_STATUS_NON_OPERATIONAL:
        default:
        {
            ptszOper = MakeString(g_hModule, STRING_NON_OPERATIONAL);
            break;
        }
   }
    
    
#ifdef UNICODE
    wcscpy(tszIfName, ieRow->wszName);
    
    MultiByteToWideChar(GetConsoleOutputCP(),
                        0,
                        ieRow->bDescr,
                        -1,
                        tszDescr,
                        MAXLEN_IFDESCR);
#else
    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ieRow->wszName,
                        -1,
                        tszIfName,
                        MAX_INTERFACE_NAME_LEN,
                        NULL,
                        NULL);

    strcpy(tszDescr,ieRow->bDescr);
#endif

    if (ieRow->dwPhysAddrLen == 0)
    {
        tszPhysAddr[0] = TEXT('\0');
    }
    else
    {
        MakeUnicodePhysAddr(tszPhysAddr,ieRow->bPhysAddr,ieRow->dwPhysAddrLen);
    }

    dwSize = sizeof(wszBuffer);
    IfutlGetInterfaceDescription( tszIfName, wszBuffer, &dwSize );
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_INTERFACE,
                   ieRow->dwIndex,
                   wszBuffer,
                   tszIfName,
                   ptszIfType,
                   ieRow->dwMtu,
                   ieRow->dwSpeed,
                   tszPhysAddr,
                   ptszAdmin,
                   ptszOper,
                   ieRow->dwLastChange,
                   ieRow->dwInOctets,
                   ieRow->dwInUcastPkts,
                   ieRow->dwInNUcastPkts,
                   ieRow->dwInDiscards,
                   ieRow->dwInErrors,
                   ieRow->dwInUnknownProtos,
                   ieRow->dwOutOctets,
                   ieRow->dwOutUcastPkts,
                   ieRow->dwOutNUcastPkts,
                   ieRow->dwOutDiscards,
                   ieRow->dwOutErrors,
                   ieRow->dwOutQLen,
                   tszDescr);
    
    FreeString(ptszIfType);
    FreeString(ptszAdmin);
    FreeString(ptszOper);
    
}

VOID 
PrintIcmp(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints ICMP information.

Arguments:

Return Value:

--*/
{
    PMIB_ICMP lprpcIcmp = (PMIB_ICMP)(prpcInfo->rgbyData);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_ICMP,
                   lprpcIcmp->stats.icmpInStats.dwMsgs,
                   lprpcIcmp->stats.icmpInStats.dwErrors,
                   lprpcIcmp->stats.icmpInStats.dwDestUnreachs,
                   lprpcIcmp->stats.icmpInStats.dwTimeExcds,
                   lprpcIcmp->stats.icmpInStats.dwParmProbs,
                   lprpcIcmp->stats.icmpInStats.dwSrcQuenchs,
                   lprpcIcmp->stats.icmpInStats.dwRedirects,
                   lprpcIcmp->stats.icmpInStats.dwEchos,
                   lprpcIcmp->stats.icmpInStats.dwEchoReps,
                   lprpcIcmp->stats.icmpInStats.dwTimestamps,
                   lprpcIcmp->stats.icmpInStats.dwTimestampReps,
                   lprpcIcmp->stats.icmpInStats.dwAddrMasks,
                   lprpcIcmp->stats.icmpInStats.dwAddrMaskReps,
                   lprpcIcmp->stats.icmpOutStats.dwMsgs,
                   lprpcIcmp->stats.icmpOutStats.dwErrors,
                   lprpcIcmp->stats.icmpOutStats.dwDestUnreachs,
                   lprpcIcmp->stats.icmpOutStats.dwTimeExcds,
                   lprpcIcmp->stats.icmpOutStats.dwParmProbs,
                   lprpcIcmp->stats.icmpOutStats.dwSrcQuenchs,
                   lprpcIcmp->stats.icmpOutStats.dwRedirects,
                   lprpcIcmp->stats.icmpOutStats.dwEchos,
                   lprpcIcmp->stats.icmpOutStats.dwEchoReps,
                   lprpcIcmp->stats.icmpOutStats.dwTimestamps,
                   lprpcIcmp->stats.icmpOutStats.dwTimestampReps,
                   lprpcIcmp->stats.icmpOutStats.dwAddrMasks,
                   lprpcIcmp->stats.icmpOutStats.dwAddrMaskReps);
}

VOID 
PrintUdpStats(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints UDP statistics.

Arguments:

Return Value:

--*/
{
    PMIB_UDPSTATS lprpcUdp = (PMIB_UDPSTATS)(prpcInfo->rgbyData);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_STATS,
                   lprpcUdp->dwInDatagrams,
                   lprpcUdp->dwNoPorts,
                   lprpcUdp->dwInErrors,
                   lprpcUdp->dwOutDatagrams);
}

VOID 
PrintUdpTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints UDP table information.

Arguments:

Return Value:

--*/
{
    PMIB_UDPTABLE lprpcTable = (PMIB_UDPTABLE)(prpcInfo->rgbyData);
    
    TCHAR tszAddr[ADDR_LENGTH + 1];
    DWORD i;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        MakeUnicodeIpAddr(tszAddr,
                          inet_ntoa(*((struct in_addr *)(&lprpcTable->table[i].dwLocalAddr))));

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY,
                       tszAddr,
                       ntohs((WORD)lprpcTable->table[i].dwLocalPort));
    }
}

VOID 
PrintUdpRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints UDP row information.

Arguments:

Return Value:

--*/
{
    PMIB_UDPROW ueRow = (PMIB_UDPROW)(prpcInfo->rgbyData);
    
    TCHAR tszAddr[ADDR_LENGTH + 1];
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY_HDR);
    
    MakeUnicodeIpAddr(tszAddr,inet_ntoa(*((struct in_addr *)
                                          (&ueRow->dwLocalAddr))));
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_UDP_ENTRY,
                   tszAddr,
                   ntohs((WORD)ueRow->dwLocalPort));
}

VOID 
PrintTcpStats(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints TCP Statistics

Arguments:

Return Value:

--*/

{
    PMIB_TCPSTATS lprpcTcp = (PMIB_TCPSTATS)(prpcInfo->rgbyData);
    
    PTCHAR ptszMaxConn, ptszAlgo;
    
    switch(lprpcTcp->dwRtoAlgorithm)
    {
        case MIB_TCP_RTO_CONSTANT:
        {
            ptszAlgo = MakeString(g_hModule, STRING_CONSTANT);
            break;
        }
        case MIB_TCP_RTO_RSRE:
        {
            ptszAlgo = MakeString(g_hModule, STRING_RSRE);
            break;
        }
        case MIB_TCP_RTO_VANJ:
        {
            ptszAlgo = MakeString(g_hModule, STRING_VANJ);
            break;
        }
        case MIB_TCP_RTO_OTHER:
        default:
        {
            ptszAlgo = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    if(lprpcTcp->dwMaxConn is MIB_TCP_MAXCONN_DYNAMIC)
    {
        ptszMaxConn = MakeString(g_hModule, STRING_DYNAMIC);
    }
    else
    {
        ptszMaxConn = HeapAlloc(GetProcessHeap(),0,20);
        
        if(ptszMaxConn is NULL)
        {
            return;
        }
        _stprintf(ptszMaxConn,TEXT("%d"),lprpcTcp->dwMaxConn);
    }
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_STATS,
                   ptszAlgo,
                   lprpcTcp->dwRtoMin,
                   lprpcTcp->dwRtoMax,
                   ptszMaxConn,
                   lprpcTcp->dwActiveOpens,
                   lprpcTcp->dwPassiveOpens,
                   lprpcTcp->dwAttemptFails,
                   lprpcTcp->dwEstabResets,
                   lprpcTcp->dwCurrEstab,
                   lprpcTcp->dwInSegs,
                   lprpcTcp->dwOutSegs,
                   lprpcTcp->dwRetransSegs,
                   lprpcTcp->dwInErrs,
                   lprpcTcp->dwOutRsts);
    
    FreeString(ptszAlgo);

    if(lprpcTcp->dwMaxConn is MIB_TCP_MAXCONN_DYNAMIC)
    {
        FreeString(ptszMaxConn);
    }
    else
    {
        HeapFree(GetProcessHeap,0,ptszMaxConn);
    }
    
}

VOID 
PrintTcpTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints TCP table information.

Arguments:

Return Value:

--*/
{
    PMIB_TCPTABLE lprpcTable = (PMIB_TCPTABLE)(prpcInfo->rgbyData);
    
    TCHAR  tszLAddr[ADDR_LENGTH + 1], tszRAddr[ADDR_LENGTH + 1];
    PTCHAR ptszState;
    DWORD i;

    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        switch(lprpcTable->table[i].dwState)
        {
            case MIB_TCP_STATE_CLOSED:
            {
                ptszState = MakeString(g_hModule, STRING_CLOSED);
                break;
            }
            case MIB_TCP_STATE_LISTEN:
            {
                ptszState = MakeString(g_hModule, STRING_LISTEN);
                break;
            }
            case MIB_TCP_STATE_SYN_SENT:
            {
                ptszState = MakeString(g_hModule, STRING_SYN_SENT);
                break;
            }
            case MIB_TCP_STATE_SYN_RCVD:
            {
                ptszState = MakeString(g_hModule, STRING_SYN_RCVD);
                break;
            }
            case MIB_TCP_STATE_ESTAB:
            {
                ptszState = MakeString(g_hModule, STRING_ESTAB);
                break;
            }
            case MIB_TCP_STATE_FIN_WAIT1:
            {
                ptszState = MakeString(g_hModule, STRING_FIN_WAIT1);
                break;
            }
            case MIB_TCP_STATE_FIN_WAIT2:
            {
                ptszState = MakeString(g_hModule, STRING_FIN_WAIT2);
                break;
            }
            case MIB_TCP_STATE_CLOSE_WAIT:
            {
                ptszState = MakeString(g_hModule, STRING_CLOSE_WAIT);
                break;
            }
            case MIB_TCP_STATE_CLOSING:
            {
                ptszState = MakeString(g_hModule, STRING_CLOSING);
                break;
            }
            case MIB_TCP_STATE_LAST_ACK:
            {
                ptszState = MakeString(g_hModule, STRING_LAST_ACK);
                break;
            }
            case MIB_TCP_STATE_TIME_WAIT:
            {
                ptszState = MakeString(g_hModule, STRING_TIME_WAIT);
                break;
            }
            case MIB_TCP_STATE_DELETE_TCB :
            {
                ptszState = MakeString(g_hModule, STRING_DELETE_TCB);
                break;
            }
        }
    
        MakeUnicodeIpAddr(tszLAddr, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwLocalAddr))));
        MakeUnicodeIpAddr(tszRAddr, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwRemoteAddr))));
        
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY,
                       tszLAddr,
                       ntohs((WORD)lprpcTable->table[i].dwLocalPort),
                       tszRAddr,
                       ntohs((WORD)lprpcTable->table[i].dwRemotePort),
                       ptszState);
        
        FreeString(ptszState);
    }
}

VOID 
PrintTcpRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints TCP row information.

Arguments:

Return Value:

--*/
{
    PMIB_TCPROW tcteRow = (PMIB_TCPROW)(prpcInfo->rgbyData);
    TCHAR  tszLAddr[ADDR_LENGTH + 1], tszRAddr[ADDR_LENGTH + 1];
    PTCHAR ptszState;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY_HDR);
    
    switch(tcteRow->dwState)
    {
        case MIB_TCP_STATE_CLOSED:
        {
            ptszState = MakeString(g_hModule, STRING_CLOSED);
            break;
        }
        case MIB_TCP_STATE_LISTEN:
        {
            ptszState = MakeString(g_hModule, STRING_LISTEN);
            break;
        }
        case MIB_TCP_STATE_SYN_SENT:
        {
            ptszState = MakeString(g_hModule, STRING_SYN_SENT);
            break;
        }
        case MIB_TCP_STATE_SYN_RCVD:
        {
            ptszState = MakeString(g_hModule, STRING_SYN_RCVD);
            break;
        }
        case MIB_TCP_STATE_ESTAB:
        {
            ptszState = MakeString(g_hModule, STRING_ESTAB);
            break;
        }
        case MIB_TCP_STATE_FIN_WAIT1:
        {
            ptszState = MakeString(g_hModule, STRING_FIN_WAIT1);
            break;
        }
        case MIB_TCP_STATE_FIN_WAIT2:
        {
            ptszState = MakeString(g_hModule, STRING_FIN_WAIT2);
            break;
        }
        case MIB_TCP_STATE_CLOSE_WAIT:
        {
            ptszState = MakeString(g_hModule, STRING_CLOSE_WAIT);
            break;
        }
        case MIB_TCP_STATE_CLOSING:
        {
            ptszState = MakeString(g_hModule, STRING_CLOSING);
            break;
        }
        case MIB_TCP_STATE_LAST_ACK:
        {
            ptszState = MakeString(g_hModule, STRING_LAST_ACK);
            break;
        }
        case MIB_TCP_STATE_TIME_WAIT:
        {
            ptszState = MakeString(g_hModule, STRING_TIME_WAIT);
            break;
        }
        case MIB_TCP_STATE_DELETE_TCB :
        {
            ptszState = MakeString(g_hModule, STRING_DELETE_TCB);
            break;
        }
    }
    
    MakeUnicodeIpAddr(tszLAddr, inet_ntoa(*((struct in_addr *)
                                            (&tcteRow->dwLocalAddr))));
    MakeUnicodeIpAddr(tszRAddr, inet_ntoa(*((struct in_addr *)
                                            (&tcteRow->dwRemoteAddr))));
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_TCP_ENTRY,
                      tszLAddr,
                      ntohs((WORD)tcteRow->dwLocalPort),
                      tszRAddr,
                      ntohs((WORD)tcteRow->dwRemotePort),
                      ptszState);
    
    FreeString(ptszState);
}

VOID 
PrintIpStats(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
{
    PMIB_IPSTATS lprpcIp = (PMIB_IPSTATS)(prpcInfo->rgbyData);
    PTCHAR   ptszForw;

    
    if(lprpcIp->dwForwarding is MIB_IP_FORWARDING)
    {
        ptszForw = MakeString(g_hModule, STRING_ENABLED);
    }
    else
    {
        ptszForw = MakeString(g_hModule, STRING_DISABLED);
    }
     
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_STATS,
                      ptszForw,
                      lprpcIp->dwDefaultTTL,
                      lprpcIp->dwInReceives,
                      lprpcIp->dwInHdrErrors,
                      lprpcIp->dwInAddrErrors,
                      lprpcIp->dwForwDatagrams,
                      lprpcIp->dwInUnknownProtos,
                      lprpcIp->dwInDiscards,
                      lprpcIp->dwInDelivers,
                      lprpcIp->dwOutRequests,
                      lprpcIp->dwRoutingDiscards,
                      lprpcIp->dwOutDiscards,
                      lprpcIp->dwOutNoRoutes,
                      lprpcIp->dwReasmTimeout,
                      lprpcIp->dwReasmReqds,
                      lprpcIp->dwReasmOks,
                      lprpcIp->dwReasmFails,
                      lprpcIp->dwFragOks,
                      lprpcIp->dwFragFails,
                      lprpcIp->dwFragCreates);
    
    FreeString(ptszForw);
}

VOID 
PrintIpAddrTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP address table.

Arguments:

Return Value:

--*/
{
    WCHAR wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPADDRTABLE lprpcTable;
    TCHAR tszAddr[ADDR_LENGTH + 1], tszMask[ADDR_LENGTH + 1];
    DWORD i, dwErr = NO_ERROR;

    lprpcTable = (PMIB_IPADDRTABLE)(prpcInfo->rgbyData);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        MakeUnicodeIpAddr(tszAddr,
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwAddr))));
        MakeUnicodeIpAddr(tszMask,
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwMask))));

        dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                            lprpcTable->table[i].dwIndex,
                                            wszFriendlyName,
                                            sizeof(wszFriendlyName) );

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_ENTRY,
                          tszAddr,
                          tszMask,
                          lprpcTable->table[i].dwBCastAddr,
                          lprpcTable->table[i].dwReasmSize,
                          wszFriendlyName
                         );
    }
}

VOID 
PrintIpAddrRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP address table row.

Arguments:

Return Value:

--*/
{
    WCHAR wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPADDRROW iaeRow = (PMIB_IPADDRROW)(prpcInfo->rgbyData);
    DWORD          dwErr = NO_ERROR;
    
    TCHAR           tszAddr[ADDR_LENGTH + 1], tszMask[ADDR_LENGTH + 1];
    
    MakeUnicodeIpAddr(tszAddr,
                      inet_ntoa(*((struct in_addr *)(&iaeRow->dwAddr))));
    MakeUnicodeIpAddr(tszMask,
                      inet_ntoa(*((struct in_addr *)(&iaeRow->dwMask))));

    dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                        iaeRow->dwIndex,
                                        wszFriendlyName,
                                        sizeof(wszFriendlyName) );

    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_HDR);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_ADDR_ENTRY,
                          tszAddr,
                          tszMask,
                          iaeRow->dwBCastAddr,
                          iaeRow->dwReasmSize,
                          wszFriendlyName );
}

VOID 
PrintIpNetTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP net table information.

Arguments:

Return Value:

--*/
{
    WCHAR           wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPNETTABLE lprpcTable = (PMIB_IPNETTABLE)(prpcInfo->rgbyData);
    TCHAR           tszPhysAddr[DISPLAYLEN_PHYSADDR + 1],
                    tszIpAddr[ADDR_LENGTH + 1];
    PTCHAR          ptszType;
    DWORD           i, dwErr = NO_ERROR;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        switch(lprpcTable->table[i].dwType)
        {
            case MIB_IPNET_TYPE_INVALID:
            {
                ptszType = MakeString(g_hModule, STRING_INVALID);
                break;
            }
            case MIB_IPNET_TYPE_DYNAMIC:
            {
                ptszType = MakeString(g_hModule, STRING_DYNAMIC);
                break;
            }
            case MIB_IPNET_TYPE_STATIC:
            {
                ptszType = MakeString(g_hModule, STRING_STATIC);
                break;
            }
            case MIB_IPNET_TYPE_OTHER:
            default:
            {
                ptszType = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
    
        MakeUnicodeIpAddr(tszIpAddr, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwAddr))));
        
        MakeUnicodePhysAddr(tszPhysAddr,
                            lprpcTable->table[i].bPhysAddr,
                            lprpcTable->table[i].dwPhysAddrLen);

        dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                            lprpcTable->table[i].dwIndex,
                                            wszFriendlyName,
                                            sizeof(wszFriendlyName) );

        if (dwErr != NO_ERROR) {
            wcscpy(wszFriendlyName, L"?");
        }

        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_ENTRY,
                       wszFriendlyName,
                       tszPhysAddr,
                       tszIpAddr,
                       ptszType);
        
        FreeString(ptszType);
    }
}

VOID 
PrintIpNetRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP net row information.

Arguments:

Return Value:

--*/
{
    WCHAR         wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPNETROW inmeRow = (PMIB_IPNETROW)(prpcInfo->rgbyData);
    TCHAR         tszPhysAddr[DISPLAYLEN_PHYSADDR + 1],
                  tszIpAddr[ADDR_LENGTH + 1];
    PTCHAR        ptszType;
    DWORD         dwErr = NO_ERROR;
    
    switch(inmeRow->dwType)
    {
        case MIB_IPNET_TYPE_INVALID:
        {
            ptszType = MakeString(g_hModule, STRING_INVALID);
            break;
        }
        case MIB_IPNET_TYPE_DYNAMIC:
        {
            ptszType = MakeString(g_hModule, STRING_DYNAMIC);
            break;
        }
        case MIB_IPNET_TYPE_STATIC:
        {
            ptszType = MakeString(g_hModule, STRING_STATIC);
            break;
        }
        case MIB_IPNET_TYPE_OTHER:
        default:
        {
            ptszType = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    MakeUnicodeIpAddr(tszIpAddr,
                      inet_ntoa(*((struct in_addr *)(&inmeRow->dwAddr))));
    
    MakeUnicodePhysAddr(tszPhysAddr,inmeRow->bPhysAddr,inmeRow->dwPhysAddrLen);

    dwErr = IfutlGetFriendlyNameFromIfIndex( hMibServer,
                                        inmeRow->dwIndex,
                                        wszFriendlyName,
                                        sizeof(wszFriendlyName) );
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_HDR);
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_IP_NET_ENTRY,
                   wszFriendlyName,
                   tszPhysAddr,
                   tszIpAddr,
                   ptszType);
        
    
    FreeString(ptszType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\routerdb.h ===
/*
    File    routerdb.h

    Implements a database abstraction for accessing router interfaces.

    If any caching/transactioning/commit-noncommit-moding is done, it
    should be implemented here with the api's remaining constant.

*/

#ifndef IFMON_ROUTERDB_H
#define IFMON_ROUTERDB_H

//
// Defines a function callback that receives enumerated 
// interfaces.
//
typedef
DWORD
(*RTR_IF_ENUM_FUNC)(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwLevel,
    IN  DWORD   dwFormat,
    IN  PVOID   pvData,
    IN  HANDLE  hData
    );

DWORD
RtrdbInterfaceAdd(
    IN PWCHAR pszInterface,
    IN DWORD  dwLevel,
    IN PVOID  pvInfo
    );

DWORD
RtrdbInterfaceDelete(
    IN  PWCHAR  pwszIfName
    );

DWORD
RtrdbInterfaceEnumerate(
    IN DWORD dwLevel,
    IN DWORD dwFormat,
    IN RTR_IF_ENUM_FUNC pEnum,
    IN HANDLE hData 
    );

DWORD
RtrdbInterfaceRead(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo
    );

DWORD
RtrdbInterfaceWrite(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo
    );

DWORD
RtrdbInterfaceReadCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    );

DWORD
RtrdbInterfaceWriteCredentials(
    IN  PWCHAR     pszIfName,
    IN  PWCHAR     pszUser            OPTIONAL,
    IN  PWCHAR     pszPassword        OPTIONAL,
    IN  PWCHAR     pszDomain          OPTIONAL
    );

DWORD
RtrdbInterfaceRename(
    IN  PWCHAR     pwszIfName,
    IN  DWORD      dwLevel,
    IN  PVOID      pvInfo,
    IN  PWCHAR     pszNewName);

DWORD
RtrdbResetAll();


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\routerif.c ===
/*
    File: routerif.c

    Defines callbacks needed to deal with interfaces supported by
    the router.
*/

#include "precomp.h"

DWORD
RtruiInterfaceShow(
    IN  PWCHAR  pwszIfName,
    IN  DWORD   dwLevel,
    IN  DWORD   dwFormat,
    IN  PVOID   pvData,
    IN  HANDLE  hData
    )

/*++

Routine Description:

    Prints interface info to display or file

Arguments:

    pIfInfo     - Info for adding the interface

Return Value:

    NO_ERROR

--*/

{
    DWORD   dwErr, dwSize;
    WCHAR   rgwcIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszEnabled, pwszDisabled, pwszConnected, pwszDisconn;
    PWCHAR  pwszConnecting, pwszClient, pwszHome, pwszFull;
    PWCHAR  pwszDedicated, pwszInternal, pwszLoop;
    PWCHAR  pwszAdminState, pwszState, pwszType;
    MPR_INTERFACE_0* pIfInfo = (MPR_INTERFACE_0*)pvData;
    BOOL    bDump = (hData) && (*((BOOL*)hData));
    
    pwszEnabled     = MakeString(g_hModule, STRING_ENABLED);
    pwszDisabled    = MakeString(g_hModule, STRING_DISABLED);
    pwszConnected   = MakeString(g_hModule, STRING_CONNECTED);
    pwszDisconn     = MakeString(g_hModule, STRING_DISCONNECTED);
    pwszConnecting  = MakeString(g_hModule, STRING_CONNECTING);
    pwszClient      = MakeString(g_hModule, STRING_CLIENT);
    pwszHome        = MakeString(g_hModule, STRING_HOME_ROUTER);
    pwszFull        = MakeString(g_hModule, STRING_FULL_ROUTER);
    pwszDedicated   = MakeString(g_hModule, STRING_DEDICATED);
    pwszInternal    = MakeString(g_hModule, STRING_INTERNAL);
    pwszLoop        = MakeString(g_hModule, STRING_LOOPBACK);

    do
    {
        if(!pwszEnabled or
           !pwszDisabled or
           !pwszConnected or
           !pwszDisconn or
           !pwszConnecting or
           !pwszClient or
           !pwszHome or
           !pwszFull or
           !pwszDedicated or
           !pwszInternal or
           !pwszLoop)
        {

            DisplayError(NULL,
                         ERROR_NOT_ENOUGH_MEMORY);

            break;
        }

        dwSize = sizeof(rgwcIfDesc);

        IfutlGetInterfaceDescription(pIfInfo->wszInterfaceName,
                                rgwcIfDesc,
                                &dwSize);
        
        switch(pIfInfo->dwConnectionState)
        {
            case ROUTER_IF_STATE_DISCONNECTED:
            {
                pwszState = pwszDisconn;

                break;
            }
            
            case ROUTER_IF_STATE_CONNECTING:
            {
                pwszState = pwszConnecting;

                break;
            }

            case ROUTER_IF_STATE_CONNECTED:
            {
                pwszState = pwszConnected;

                break;
            }

            default:
            {
                pwszState = L"";
                
                break;
            }
                
        }

        if (bDump == FALSE)
        {
            switch(pIfInfo->dwIfType)
            {
                case ROUTER_IF_TYPE_CLIENT:
                    pwszType = pwszClient;
                    break;

                case ROUTER_IF_TYPE_HOME_ROUTER:
                    pwszType = pwszHome;
                    break;
                    
                case ROUTER_IF_TYPE_FULL_ROUTER:
                    pwszType = pwszFull;
                    break;
                
                case ROUTER_IF_TYPE_DEDICATED:
                    pwszType = pwszDedicated;
                    break;
                
                case ROUTER_IF_TYPE_INTERNAL:
                    pwszType = pwszInternal;
                    break;
                
                case ROUTER_IF_TYPE_LOOPBACK:
                    pwszType = pwszLoop;
                    break;
                    
                default:
                    pwszType = L"";
                    break;
            }
            
            if(pIfInfo->fEnabled)
            {
                pwszAdminState = pwszEnabled;
            }
            else
            {
                pwszAdminState = pwszDisabled;
            }
        }
        else
        {
            switch(pIfInfo->dwIfType)
            {
                case ROUTER_IF_TYPE_FULL_ROUTER:
                    pwszType = TOKEN_FULL;
                    break;
                
                default:
                    pwszType = L"";
                    break;
            }
            
            if(pIfInfo->fEnabled)
            {
                pwszAdminState = TOKEN_VALUE_ENABLED;
            }
            else
            {
                pwszAdminState = TOKEN_VALUE_DISABLED;
            }
        }
                
        if (bDump)
        {
            
            PWCHAR pwszQuoted = NULL;
            
            if (wcscmp(pIfInfo->wszInterfaceName, rgwcIfDesc))
            {
                pwszQuoted = MakeQuotedString( rgwcIfDesc );
            }
            else
            {
                pwszQuoted = MakeQuotedString( pIfInfo->wszInterfaceName );
            }

            if (pIfInfo->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
            {               
                WCHAR pwszUser[256], pwszDomain[256];
                PWCHAR pszQuoteUser = NULL, pszQuoteDomain = NULL;

                DisplayMessageT( DMP_IF_ADD_IF,
                                 pwszQuoted,
                                 pwszType);

                DisplayMessageT( DMP_IF_SET_IF,
                                 pwszQuoted,
                                 pwszAdminState);

                dwErr = RtrdbInterfaceReadCredentials(
                    pIfInfo->wszInterfaceName,
                    pwszUser,
                    NULL,
                    pwszDomain);

                if (dwErr == NO_ERROR)
                {
                    pszQuoteUser = MakeQuotedString( pwszUser );
                    if (pszQuoteUser == NULL)
                    {
                        break;
                    }
                    if (*pwszDomain == L'\0')
                    {
                        DisplayMessageT( DMP_IF_SET_CRED_IF_NOD,
                                         pwszQuoted,
                                         pszQuoteUser);
                    }
                    else
                    {
                        pszQuoteDomain = MakeQuotedString( pwszDomain );
                        if (pszQuoteUser == NULL)
                        {
                            FreeString(pszQuoteUser);
                            break;
                        }
                        DisplayMessageT( DMP_IF_SET_CRED_IF,
                                         pwszQuoted,
                                         pszQuoteUser,
                                         pszQuoteDomain);
                        FreeString(pszQuoteDomain);
                    }                                             
                }
                
                DisplayMessageT( DMP_IF_NEWLINE );
            }

            FreeQuotedString(pwszQuoted);
        }

        else
        {
            DisplayMessage(g_hModule,
                           (dwFormat>0)? MSG_IF_ENTRY_LONG : MSG_IF_ENTRY_SHORT,
                           pwszAdminState,
                           pwszState,
                           pwszType,
                           rgwcIfDesc );
        } 
    }while(FALSE);
    
    
    if(pwszEnabled)
    {
        FreeString(pwszEnabled);
    }
        
    if(pwszDisabled)
    {
        FreeString(pwszDisabled);
    }
    
    if(pwszConnected)
    {
        FreeString(pwszConnected);
    }
    
    if(pwszDisconn)
    {
        FreeString(pwszDisconn);
    }
    
    if(pwszConnecting)
    {
        FreeString(pwszConnecting);
    }
    
    if(pwszClient)
    {
        FreeString(pwszClient);
    }
    
    if(pwszHome)
    {
        FreeString(pwszHome);
    }
    
    if(pwszFull)
    {
        FreeString(pwszFull);
    }
    
    if(pwszDedicated)
    {
        FreeString(pwszDedicated);
    }
    
    if(pwszInternal)
    {
        FreeString(pwszInternal);
    }
        
    if(pwszLoop)
    {
        FreeString(pwszLoop);
    }
    
    return NO_ERROR;
}

DWORD
RtrHandleResetAll(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];

    do 
    {
        // Make sure no arguments were passed in
        //
        if (dwArgCount - dwCurrentIndex != 0)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }
        
        dwErr = RtrdbResetAll();
        BREAK_ON_DWERR(dwErr);

    } while (FALSE);

    // Cleanup
    {
    }

    return dwErr;
}

DWORD
RtrHandleAddDel(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    bAdd
    )

/*++

Routine Description:

    The actual parser for the add and delete commands

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg
    bAdd            - TRUE to add the interface
Return Value:

    NO_ERROR

--*/

{
    DWORD       i, dwNumArgs, dwRes, dwErr, dwIfType, dwSize;
    MPR_INTERFACE_0 IfInfo;
    PWCHAR pszIfDesc = NULL;
    TOKEN_VALUE rgEnumType[] = 
    {
        {TOKEN_FULL,   ROUTER_IF_TYPE_FULL_ROUTER}
    };
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_ENUM, 
            {TOKEN_TYPE,    FALSE,   FALSE}, 
            rgEnumType,
            sizeof(rgEnumType) / sizeof(*rgEnumType),
            NULL
        }
    };   

    // Initialize
    //
    ZeroMemory(&IfInfo, sizeof(IfInfo));
    IfInfo.fEnabled = TRUE;


    do
    {
        // Parse out the values
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs) / sizeof(*pArgs));
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        //
        // Get the arguments that were specified
        //
        pszIfDesc = IFMON_CMD_ARG_GetPsz(&pArgs[0]);
        IfInfo.dwIfType = IFMON_CMD_ARG_GetDword(&pArgs[1]);

        if(bAdd)
        {
            // Make sure the type was specified
            //
            if (! pArgs[1].rgTag.bPresent)
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            
            wcscpy(
                IfInfo.wszInterfaceName,
                pszIfDesc
                );
                
            dwErr = RtrdbInterfaceAdd(
                        IfInfo.wszInterfaceName,
                        0,
                        (PVOID)&IfInfo);
        }
        else
        {
            WCHAR pszName[MAX_INTERFACE_NAME_LEN + 1];
            dwSize = sizeof(pszName);
            
            IfutlGetInterfaceName(
                pszIfDesc,
                pszName,
                &dwSize);
        
            dwErr = RtrdbInterfaceDelete(pszName);
        }

    } while(FALSE);

    // Cleanup
    {
        IfutlFree(pszIfDesc);
    }

    return dwErr;
}

DWORD
RtrHandleAdd(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )

/*++

Routine Description:

    Handler for adding an dial interface to the router

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{

    return RtrHandleAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                TRUE);

}

DWORD
RtrHandleDel(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )

/*++

Routine Description:

    Handler for deleting a dial interface or from the router

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return RtrHandleAddDel(
                ppwcArguments,
                dwCurrentIndex,
                dwArgCount,
                FALSE);

}

DWORD
RtrHandleSet(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    TOKEN_VALUE rgEnumAdmin[] = 
    {
        {TOKEN_VALUE_ENABLED,  TRUE},
        {TOKEN_VALUE_DISABLED, FALSE}
    };
    TOKEN_VALUE rgEnumConnect[] = 
    {
        {TOKEN_VALUE_CONNECTED,  TRUE},
        {TOKEN_VALUE_DISCONNECTED, FALSE}
    };
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_ENUM, 
            {TOKEN_ADMIN,  FALSE,   FALSE}, 
            rgEnumAdmin,
            sizeof(rgEnumAdmin) / sizeof(*rgEnumAdmin),
            NULL
        },
        
        {
            IFMON_CMD_TYPE_ENUM, 
            {TOKEN_CONNECT,  FALSE,   FALSE}, 
            rgEnumConnect,
            sizeof(rgEnumConnect) / sizeof(*rgEnumConnect),
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NEWNAME,  FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        }
    };   
    PWCHAR pszIfName = NULL, pszNewName = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];
    BOOL fEnable = FALSE, fConnect = FALSE;
    BOOL fEnablePresent = FALSE, fConnectPresent = FALSE;

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);
        fEnable     = IFMON_CMD_ARG_GetDword(&pArgs[1]);
        fConnect    = IFMON_CMD_ARG_GetDword(&pArgs[2]);
        pszNewName  = IFMON_CMD_ARG_GetPsz(&pArgs[3]);
        fEnablePresent = pArgs[1].rgTag.bPresent;
        fConnectPresent = pArgs[2].rgTag.bPresent;
        
        // Get the interface info so that we can 
        // make sure we have the right type.
        //
        dwSize = sizeof(pszName);
        dwErr = GetIfNameFromFriendlyName(
                    pszIfName,
                    pszName,
                    &dwSize);
        BREAK_ON_DWERR(dwErr);

        ZeroMemory(&If0, sizeof(If0));
        dwErr = RtrdbInterfaceRead(
                    pszName,
                    0,
                    (PVOID*)&If0);
        BREAK_ON_DWERR(dwErr);

        // Rename the interface if that is the request
        //
        if ( If0.dwIfType == ROUTER_IF_TYPE_DEDICATED )
        {
            if (!pszNewName)
            {
                DisplayError(
                    g_hModule,
                    EMSG_CANT_FIND_EOPT);

                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }

            if (g_pwszRouter)
            {
                DisplayError(
                    g_hModule,
                    EMSG_IF_NEWNAME_ONLY_FOR_LOCAL);

                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
            
            if (fEnablePresent || fConnectPresent)
            {
                DisplayError(
                    g_hModule,
                    EMSG_IF_LAN_ONLY_COMMAND);

                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            // Rename the interface
            //
            dwErr = RtrdbInterfaceRename(
                        pszName,
                        0,
                        (PVOID)&If0,
                        pszNewName);
            break;                        
        }

        if (pszNewName)
        {
            DisplayError(
                g_hModule,
                EMSG_IF_NEWNAME_ONLY_FOR_LAN);

            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
            
        // Make sure that at least one option was specified
        //
        if (!fEnablePresent && !fConnectPresent)
        {
            dwErr = ERROR_INVALID_SYNTAX;
            break;
        }

        // Validate the interface type
        //
        //if ( ( If0.dwIfType == ROUTER_IF_TYPE_DEDICATED ) ||
        //     ( If0.dwIfType == ROUTER_IF_TYPE_INTERNAL ) 
        //   )
        if ( If0.dwIfType != ROUTER_IF_TYPE_FULL_ROUTER )
        {
            DisplayError(
                g_hModule,
                EMSG_IF_WAN_ONLY_COMMAND);

            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Allow the connection request to override
        // the admin enabling.
        if (fConnectPresent)
        {
            if (!IfutlIsRouterRunning())
            {
                DisplayError(
                    g_hModule,
                    EMSG_IF_CONNECT_ONLY_WHEN_ROUTER_RUNNING);

                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (fConnect)
            {
                fEnablePresent = TRUE;
                fEnable = TRUE;
            }                
        }

        // Enable if requested
        //
        if (fEnablePresent)
        {
            // Enable/disable the interface
            //
            If0.fEnabled = fEnable;

            // Commit
            //
            dwErr = RtrdbInterfaceWrite(
                        If0.wszInterfaceName, 
                        0, 
                        (PVOID)&If0);
            BREAK_ON_DWERR(dwErr);                    
        }

        // Connect if requested
        //
        if (fConnectPresent)
        {
            if (fConnect)
            {
                dwErr = MprAdminInterfaceConnect(
                            g_hMprAdmin,
                            If0.hInterface,
                            NULL,
                            TRUE);

                BREAK_ON_DWERR(dwErr);                
            }
            else
            {
                dwErr = MprAdminInterfaceDisconnect(
                            g_hMprAdmin,
                            If0.hInterface);
                    
                BREAK_ON_DWERR(dwErr);                
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        IfutlFree(pszIfName);
        IfutlFree(pszNewName);
    }

    return dwErr;
}

DWORD
RtrHandleSetCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_USER,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_DOMAIN,   FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        },

        {
            IFMON_CMD_TYPE_STRING,
            {TOKEN_PASSWORD,  FALSE,  FALSE}, 
            NULL,
            0,
            NULL
        }
    };   
    PWCHAR pszIfName = NULL, pszUser = NULL;
    PWCHAR pszPassword = NULL, pszDomain = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);
        pszUser     = IFMON_CMD_ARG_GetPsz(&pArgs[1]);
        pszDomain   = IFMON_CMD_ARG_GetPsz(&pArgs[2]);
        pszPassword = IFMON_CMD_ARG_GetPsz(&pArgs[3]);

        // Get the interface info so that we can 
        // make sure we have the right type.
        //
        dwSize = sizeof(pszName);
        dwErr = GetIfNameFromFriendlyName(
                    pszIfName,
                    pszName,
                    &dwSize);
        BREAK_ON_DWERR(dwErr);

        dwErr = RtrdbInterfaceWriteCredentials(
                    pszName,
                    pszUser,
                    pszPassword,
                    pszDomain);
        BREAK_ON_DWERR(dwErr);                    
        
    } while (FALSE);

    // Cleanup
    {
        IfutlFree(pszIfName);
        IfutlFree(pszUser);
        IfutlFree(pszPassword);
        IfutlFree(pszDomain);
    }

    return dwErr;
}

DWORD
RtrHandleShow(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )

/*++

Routine Description:

    Handler for displaying interfaces

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   FALSE,   FALSE}, 
            NULL,
            0,
            NULL
        }
    };   
    PWCHAR pszIfName = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);

        // Handle the no argument case
        //
        if (pszIfName == NULL)
        {
            RtrdbInterfaceEnumerate(0, 0, RtruiInterfaceShow, NULL);
            dwErr = NO_ERROR;
            break;
        }

        // Map the name
        //
        dwSize = sizeof(pszName);
        GetIfNameFromFriendlyName(
            pszIfName,
            pszName,
            &dwSize);

        // Get the info
        //
        dwErr = RtrdbInterfaceRead(
                    pszName,
                    0,
                    (PVOID)&If0);
        BREAK_ON_DWERR( dwErr );                    

        RtruiInterfaceShow(
            If0.wszInterfaceName, 
            0, 
            1, 
            (PVOID)&If0, 
            NULL
            );
        
    } while (FALSE);

    // Cleanup
    //
    {
        if (pszIfName != NULL)
        {
            IfutlFree(pszIfName);
        }
    }

    return dwErr;
}

DWORD
RtrHandleShowCredentials(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwCurrentIndex,
    IN  DWORD   dwArgCount,
    IN  BOOL    *pbDone
    )
/*++

Routine Description:

    Handler for showing credentials of an interface

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD           dwErr = NO_ERROR, dwSize;
    MPR_INTERFACE_0 If0;
    IFMON_CMD_ARG  pArgs[] = 
    {
        {
            IFMON_CMD_TYPE_STRING, 
            {TOKEN_NAME,   TRUE,   FALSE}, 
            NULL,
            0,
            NULL
        },
    };   
    PWCHAR pszIfName = NULL;
    WCHAR pszName[MAX_INTERFACE_NAME_LEN];
    WCHAR pszUser[256], pszDomain[256], pszPassword[256];

    do 
    {
        // Parse
        //
        dwErr = IfutlParse(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    NULL,
                    pArgs,
                    sizeof(pArgs)/sizeof(*pArgs));
        BREAK_ON_DWERR(dwErr);                    

        // Get the returned values from the parse
        //
        pszIfName   = IFMON_CMD_ARG_GetPsz(&pArgs[0]);

        // Get the interface info so that we can 
        // make sure we have the right type.
        //
        dwSize = sizeof(pszName);
        dwErr = GetIfNameFromFriendlyName(
                    pszIfName,
                    pszName,
                    &dwSize);
        BREAK_ON_DWERR(dwErr);

        dwErr = RtrdbInterfaceReadCredentials(
                    pszName,
                    pszUser,
                    pszPassword,
                    pszDomain);
        BREAK_ON_DWERR(dwErr);

        DisplayMessage(
            g_hModule,
            MSG_IF_CREDENTIALS,
            pszIfName,
            pszUser,
            pszDomain,
            pszPassword);
        
    } while (FALSE);

    // Cleanup
    {
        IfutlFree(pszIfName);
    }

    return dwErr;
}

DWORD
RtrHandleDump(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      *pbDone
    )
{
    DWORD               dwErr, dwCount, dwTotal;
    ULONG               i;
    PMPR_INTERFACE_0    pIfTable;
    BOOL                bFormat = TRUE;

    // Display dump header
    //
    DisplayMessage(g_hModule, DMP_IF_HEADER_COMMENTS);

    DisplayMessageT(DMP_IF_HEADER);

    // Display the interfaces
    //
    RtrdbInterfaceEnumerate(0, 0, RtruiInterfaceShow, &bFormat);

    // Display dump footer
    //
    DisplayMessageT(DMP_IF_FOOTER);

    DisplayMessage(g_hModule, DMP_IF_FOOTER_COMMENTS);

    return NO_ERROR;
}

DWORD
RtrDump(
    IN  PWCHAR     *ppwcArguments,
    IN  DWORD       dwArgCount
    )
{
    BOOL bDone;

    return RtrHandleDump(ppwcArguments, 1, dwArgCount, &bDone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\showmib.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\if\showmib.h

Abstract:



Author:

     Dave Thaler    7/21/99

Revision History:


--*/

#ifndef __IFMON_SHOWMIB_H__
#define __IFMON_SHOWMIB_H__

#define MAX_NUM_INDICES 6

typedef
DWORD
(*PGET_OPT_FN)(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    );

typedef struct _MIB_OBJECT_PARSER
{
    PWCHAR         pwszMIBObj;
    DWORD          dwMinOptArg;
    PGET_OPT_FN    pfnMIBObjParser;
} MIB_OBJECT_PARSER,*PMIB_OBJECT_PARSER;

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBIpAddress(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBIpNetIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBTcpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

DWORD
GetMIBUdpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
);

typedef
VOID
(PRINT_FN)(
    IN MIB_SERVER_HANDLE hMibServer,
    IN PMIB_OPAQUE_INFO  pInfo
    );

typedef PRINT_FN *PPRINT_FN;

PRINT_FN PrintIfTable;
PRINT_FN PrintIfRow;
PRINT_FN PrintIcmp;
PRINT_FN PrintUdpStats;
PRINT_FN PrintUdpTable;
PRINT_FN PrintUdpRow;
PRINT_FN PrintTcpStats;
PRINT_FN PrintTcpTable;
PRINT_FN PrintTcpRow;
PRINT_FN PrintIpStats;
PRINT_FN PrintIpAddrTable;
PRINT_FN PrintIpAddrRow;
PRINT_FN PrintIpNetTable;
PRINT_FN PrintIpNetRow;

typedef struct _MAGIC_TABLE
{
    DWORD      dwId;
    PPRINT_FN  pfnPrintFunction;
}MAGIC_TABLE, *PMAGIC_TABLE;

FN_HANDLE_CMD HandleIpMibShowObject;

DWORD
GetMibTagToken(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    );

#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(GetConsoleOutputCP(),                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

FN_HANDLE_CMD    HandleIpShowJoins;

#endif // __IFMON_SHOWMIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    NOTE - DONT USE 15000-15999

Author:

    Amritansh Raghav  01/25/1996

Revision History:


--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_NULL                                1001

#define HLP_IF_DUMP                             2501
#define HLP_IF_DUMP_EX                          2502
#define HLP_DUMP                                HLP_IF_DUMP
#define HLP_DUMP_EX                             HLP_IF_DUMP_EX

#define HLP_HELP                                2601
#define HLP_HELP_EX                             2602
#define HLP_IF_HELP1                            HLP_HELP
#define HLP_IF_HELP1_EX                         HLP_HELP_EX
#define HLP_IF_HELP2                            HLP_HELP
#define HLP_IF_HELP2_EX                         HLP_HELP_EX
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX


#define HLP_IF_ADD_IF                           3101
#define HLP_IF_ADD_IF_EX                        3102

#define HLP_IF_DEL_IF                           3201
#define HLP_IF_DEL_IF_EX                        3202

#define HLP_IF_SET_CREDENTIALS                  3301
#define HLP_IF_SET_CREDENTIALS_EX               3302

#define HLP_IF_SHOW_IF                          3401
#define HLP_IF_SHOW_IF_EX                       3402

#define HLP_IF_SHOW_CREDENTIALS                 3450
#define HLP_IF_SHOW_CREDENTIALS_EX              3451

#define HLP_IF_SET_INTERFACE                    3500
#define HLP_IF_SET_INTERFACE_EX                 3501

#define HLP_IF_RESET_ALL                        3550
#define HLP_IF_RESET_ALL_EX                     3551

#define HLP_GROUP_ADD                           3901
#define HLP_GROUP_DELETE                        3903
#define HLP_GROUP_SET                           3905
#define HLP_GROUP_SHOW                          3907
#define HLP_GROUP_RESET                         3908

    // ifip
#define HLP_IFIP_SHOW_CONFIG                    4001
#define HLP_IFIP_SHOW_CONFIG_EX                 4002
#define HLP_IFIP_ADD_IPADDR                     4003
#define HLP_IFIP_ADD_IPADDR_EX                  4004
#define HLP_IFIP_SET_IPADDR                     4005
#define HLP_IFIP_SET_IPADDR_EX                  4006
#define HLP_IFIP_DEL_IPADDR                     4007
#define HLP_IFIP_DEL_IPADDR_EX                  4008
#define HLP_IFIP_SHOW_IPADDR                    4009
#define HLP_IFIP_SHOW_IPADDR_EX                 4010


#define HLP_IFIP_ADD_DNS                        4011
#define HLP_IFIP_ADD_DNS_EX                     4012
#define HLP_IFIP_SET_DNS                        4013
#define HLP_IFIP_SET_DNS_EX                     4014
#define HLP_IFIP_DEL_DNS                        4015
#define HLP_IFIP_DEL_DNS_EX                     4016
#define HLP_IFIP_SHOW_DNS                       4017
#define HLP_IFIP_SHOW_DNS_EX                    4018


#define HLP_IFIP_ADD_WINS                       4021
#define HLP_IFIP_ADD_WINS_EX                    4022
#define HLP_IFIP_SET_WINS                       4023
#define HLP_IFIP_SET_WINS_EX                    4024
#define HLP_IFIP_DEL_WINS                       4025
#define HLP_IFIP_DEL_WINS_EX                    4026
#define HLP_IFIP_SHOW_WINS                      4027
#define HLP_IFIP_SHOW_WINS_EX                   4028


    // ifip offload
#define HLP_IFIP_SHOW_OFFLOAD                   4031
#define HLP_IFIP_SHOW_OFFLOAD_EX                4032

#define HLP_IFIP_DEL_ARPCACHE                   4040
#define HLP_IFIP_DEL_ARPCACHE_EX                4041

#define HLP_IFIP_RESET                          4050
#define HLP_IFIP_RESET_EX                       4051

#define HLP_IPMIB_SHOW_IPSTATS                  9300
#define HLP_IPMIB_SHOW_IPSTATS_EX               9301
#define HLP_IPMIB_SHOW_IPADDRESS                9302
#define HLP_IPMIB_SHOW_IPADDRESS_EX             9303
#define HLP_IPMIB_SHOW_IPFORWARD                9304
#define HLP_IPMIB_SHOW_IPFORWARD_EX             9305
#define HLP_IPMIB_SHOW_TCPSTATS                 9306
#define HLP_IPMIB_SHOW_TCPSTATS_EX              9307
#define HLP_IPMIB_SHOW_TCPCONN                  9308
#define HLP_IPMIB_SHOW_TCPCONN_EX               9309
#define HLP_IPMIB_SHOW_UDPSTATS                 9310
#define HLP_IPMIB_SHOW_UDPSTATS_EX              9311
#define HLP_IPMIB_SHOW_UDPCONN                  9312
#define HLP_IPMIB_SHOW_UDPCONN_EX               9313
#define HLP_IPMIB_SHOW_JOINS                    9314
#define HLP_IPMIB_SHOW_JOINS_EX                 9315
#define HLP_IPMIB_SHOW_IPNET                    9322
#define HLP_IPMIB_SHOW_IPNET_EX                 9323
#define HLP_IPMIB_SHOW_ICMP                     9324
#define HLP_IPMIB_SHOW_ICMP_EX                  9325
#define HLP_IPMIB_SHOW_INTERFACE                9328
#define HLP_IPMIB_SHOW_INTERFACE_EX             9329

//
// STRING_Xxx are used to display configuration etc.
// These should generally be lower case, first letter capitalized
//

#define STRING_ENABLED                          9001
#define STRING_DISABLED                         9002
#define STRING_CONNECTED                        9003
#define STRING_DISCONNECTED                     9004
#define STRING_CONNECTING                       9005
#define STRING_CLIENT                           9006
#define STRING_HOME_ROUTER                      9007
#define STRING_FULL_ROUTER                      9008
#define STRING_DEDICATED                        9009
#define STRING_INTERNAL                         9010
#define STRING_LOOPBACK                         9011
#define STRING_PRIMARY                          9012
#define STRING_BOTH                             9013
#define STRING_NONE                             9014

#define STRING_OTHER                            30001
#define STRING_ETHERNET                         30002
#define STRING_TOKENRING                        30003
#define STRING_FDDI                             30004
#define STRING_PPP                              30005
#define STRING_SLIP                             30007

#define STRING_STATIC                           33020
#define STRING_INVALID                          34002

    // interface status
#define STRING_UP                               36001
#define STRING_DOWN                             36002
#define STRING_TESTING                          36003

#define STRING_NON_OPERATIONAL                  36051
#define STRING_UNREACHABLE                      36052
#define STRING_OPERATIONAL                      36056    // interface status

    // TCP constants
#define STRING_CONSTANT                         31002
#define STRING_RSRE                             31003
#define STRING_VANJ                             31004

    // TCP states
#define STRING_CLOSED                           32001
#define STRING_LISTEN                           32002
#define STRING_SYN_SENT                         32003
#define STRING_SYN_RCVD                         32004
#define STRING_ESTAB                            32005
#define STRING_FIN_WAIT1                        32006
#define STRING_FIN_WAIT2                        32007
#define STRING_CLOSE_WAIT                       32008
#define STRING_CLOSING                          32009
#define STRING_LAST_ACK                         32010
#define STRING_TIME_WAIT                        32011
#define STRING_DELETE_TCB                       32012
#define STRING_DYNAMIC                          32013

#define EMSG_NO_PHONEBOOK                       11001
#define EMSG_BAD_OPTION_VALUE                   11004
#define EMSG_CANT_CREATE_IF                     11006
#define EMSG_CAN_NOT_CONNECT_DIM                11011
#define EMSG_BAD_IF_TYPE                        11012
#define EMSG_IF_ALREADY_EXISTS                  11013
#define EMSG_CANT_FIND_EOPT                     11014
#define EMSG_IF_BAD_CREDENTIALS_TYPE            11015
#define EMSG_IF_CONNECT_ONLY_WHEN_ROUTER_RUNNING 11016
#define EMSG_IF_WAN_ONLY_COMMAND                11017
#define EMSG_IF_LAN_ONLY_COMMAND                11018
#define EMSG_IF_NEWNAME_ONLY_FOR_LAN            11019
#define EMSG_IF_NEWNAME_ONLY_FOR_LOCAL          11020


// error messages for IfIp
#define EMSG_IPADDR_PRESENT                     11031
#define EMSG_DHCP_MODE                          11032
#define EMSG_DEFGATEWAY_PRESENT                 11033
#define EMSG_STATIC_INPUT                       11035
#define EMSG_DHCP_DELETEADDR                    11036
#define EMSG_ADDRESS_NOT_PRESENT                11037
#define EMSG_MIN_ONE_ADDR                       11038
#define EMSG_GATEWAY_NOT_PRESENT                11039
#define EMSG_ADD_IPADDR_DHCP                    11040
#define EMSG_PROPERTIES                         11041
#define EMSG_SERVER_PRESENT                     11042
#define EMSG_SERVER_ABSENT                      11043
#define EMSG_INVALID_INTERFACE                  11044
#define EMSG_NETCFG_WRITE_LOCK                  11045
#define EMSG_OPEN_APPEND                        11046

#define DMP_IF_HEADER_COMMENTS                  20001
#define DMP_IF_FOOTER_COMMENTS                  20002

#define MSG_MIB_IF_HDR                          21002
#define MSG_MIB_INTERFACE                       21003
#define MSG_MIB_IP_STATS                        21004
#define MSG_MIB_IP_ADDR_HDR                     21005
#define MSG_MIB_IP_ADDR_ENTRY                   21006
#define MSG_MIB_IP_NET_HDR                      21009
#define MSG_MIB_IP_NET_ENTRY                    21010
#define MSG_MIB_ICMP                            21011
#define MSG_MIB_UDP_STATS                       21012
#define MSG_MIB_UDP_ENTRY_HDR                   21013
#define MSG_MIB_UDP_ENTRY                       21014
#define MSG_MIB_TCP_STATS                       21015
#define MSG_MIB_TCP_ENTRY_HDR                   21016
#define MSG_MIB_TCP_ENTRY                       21017
#define MSG_MIB_JOIN_HDR                        21059
#define MSG_MIB_JOIN_ROW                        21060

#define MSG_IF_TABLE_HDR                        50001
#define MSG_IF_ENTRY_LONG                       50002
#define MSG_IF_CREDENTIALS                      50003
#define MSG_IF_ENTRY_SHORT                      50004


// msgs for ifip

#define MSG_DHCP                                50021
#define MSG_STATIC                              50022
#define MSG_IPADDR_LIST                         50023
#define MSG_IPADDR_LIST1                        50024
#define MSG_IFIP_HEADER                         50025
#define MSG_OPTIONS_LIST                        50026
#define MSG_IFMETRIC                            50028
#define MSG_GATEWAY                             50030
#define MSG_DNS_HDR                             50031
#define MSG_DNS_DHCP                            50032
#define MSG_WINS_HDR                            50033
#define MSG_WINS_DHCP                           50034
#define MSG_ADDR1                               50035
#define MSG_ADDR2                               50036
#define MSG_OPTION                              50037
#define MSG_NONE                                50038
#define MSG_DEBUG_HDR                           50039
#define MSG_DNS_DHCP_HDR                        50040
#define MSG_WINS_DHCP_HDR                       50041
#define DMP_IFIP_HEADER                         50051
#define DMP_IFIP_FOOTER                         50052
#define DMP_IFIP_INTERFACE_HEADER               50053
#define MSG_DDNS_SUFFIX                         50054


// Capability Flags

#define MSG_OFFLOAD_HDR                         50100
#define MSG_TCP_XMT_CHECKSUM_OFFLOAD            50101
#define MSG_IP_XMT_CHECKSUM_OFFLOAD             50102
#define MSG_TCP_RCV_CHECKSUM_OFFLOAD            50103
#define MSG_IP_RCV_CHECKSUM_OFFLOAD             50104
#define MSG_TCP_LARGE_SEND_OFFLOAD              50105


// IPSEC General Xmit\Recv capabilities

#define MSG_IPSEC_OFFLOAD_CRYPTO_ONLY           50111
#define MSG_IPSEC_OFFLOAD_AH_ESP                50112
#define MSG_IPSEC_OFFLOAD_TPT_TUNNEL            50113
#define MSG_IPSEC_OFFLOAD_V4_OPTIONS            50114
#define MSG_IPSEC_OFFLOAD_QUERY_SPI             50115


// IPSEC AH Xmit\Recv capabilities

#define MSG_IPSEC_OFFLOAD_AH_XMT                50121
#define MSG_IPSEC_OFFLOAD_AH_RCV                50122
#define MSG_IPSEC_OFFLOAD_AH_TPT                50123
#define MSG_IPSEC_OFFLOAD_AH_TUNNEL             50124
#define MSG_IPSEC_OFFLOAD_AH_MD5                50125
#define MSG_IPSEC_OFFLOAD_AH_SHA_1              50126

// IPSEC ESP Xmit\Recv capabilities

#define MSG_IPSEC_OFFLOAD_ESP_XMT               50131
#define MSG_IPSEC_OFFLOAD_ESP_RCV               50132
#define MSG_IPSEC_OFFLOAD_ESP_TPT               50133
#define MSG_IPSEC_OFFLOAD_ESP_TUNNEL            50134
#define MSG_IPSEC_OFFLOAD_ESP_DES               50135
#define MSG_IPSEC_OFFLOAD_ESP_DES_40            50136
#define MSG_IPSEC_OFFLOAD_ESP_3_DES             50137
#define MSG_IPSEC_OFFLOAD_ESP_NONE              50138


#define MSG_IP_DIM_ERROR                        60005
#define MSG_NO_SUCH_IF                          60006
#define MSG_IP_LOCAL_ROUTER_NOT_RUNNING         60011
#define MSG_IP_REMOTE_ROUTER_NOT_RUNNING        60013
#define MSG_IP_NO_ENTRIES                       60015
#define MSG_IP_NOT_ENOUGH_MEMORY                60024
#define MSG_CTRL_C_TO_QUIT                      60062

#endif //__STDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\utils.c ===
#include "precomp.h"

BOOL    g_bRouterRunning;
ULONG   g_ulNumChecks;

VOID
IfutlGetInterfaceName(
    IN  PWCHAR pwszIfDesc,
    OUT PWCHAR pwszIfName,
    IN  PDWORD pdwSize
    )
/*++

Routine Description:

    Gets Guid Interface Name from Friendly Interface Name

Arguments:

    pwszIfDesc      - Buffer holding Friendly Interace Name
    pwszIfName      - Buffer to hold the Guid Interface Name
    pdwSize         - Pointer to the size (in Bytes) of pwszIfName buffer

--*/
{
    DWORD   dwErr;

    dwErr = GetIfNameFromFriendlyName(pwszIfDesc,
                                      pwszIfName,
                                      pdwSize);

    if(dwErr isnot NO_ERROR)
    {
        wcsncpy(pwszIfName,
                pwszIfDesc,
                (*pdwSize)/sizeof(WCHAR));
    }

}

VOID
IfutlGetInterfaceDescription(
    IN  PWCHAR pwszIfName,
    OUT PWCHAR pwszIfDesc,
    IN  PDWORD pdwSize
    )
/*++

Routine Description:

    Gets Friendly Interface Name from Guid Interface Name

Arguments:

    pwszIfName      - Buffer holding Guid Interace Name
    pwszIfDesc      - Buffer to hold the Friendly Interface Name
    pdwSize         - Pointer to the size (in Bytes) of pwszIfDesc buffer

--*/

{
    DWORD   dwErr;
    DWORD   dwLen = (*pdwSize)/sizeof(WCHAR) - 1;

    dwErr = GetFriendlyNameFromIfName(pwszIfName,
                                      pwszIfDesc,
                                      pdwSize);

    if(dwErr isnot NO_ERROR)
    {
        wcsncpy(pwszIfDesc,
                pwszIfName,
                dwLen);
        pwszIfDesc[dwLen] = 0;
    }
}

DWORD
IfutlGetTagToken(
    IN  HANDLE      hModule,
    IN  PWCHAR      *ppwcArguments,
    IN  DWORD       dwCurrentIndex,
    IN  DWORD       dwArgCount,
    IN  PTAG_TYPE   pttTagToken,
    IN  DWORD       dwNumTags,
    OUT PDWORD      pdwOut
    )

/*++

Routine Description:

    Identifies each argument based on its tag. It assumes that each argument
    has a tag. It also removes tag= from each argument.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/

{
    DWORD      i,j,len;
    PWCHAR     pwcTag,pwcTagVal,pwszArg;
    BOOL       bFound = FALSE;

    //
    // This function assumes that every argument has a tag
    // It goes ahead and removes the tag.
    //

    for (i = dwCurrentIndex; i < dwArgCount; i++)
    {
        len = wcslen(ppwcArguments[i]);

        if (len is 0)
        {
            //
            // something wrong with arg
            //

            pdwOut[i] = (DWORD) -1;
            continue;
        }

        pwszArg = HeapAlloc(GetProcessHeap(),0,(len + 1) * sizeof(WCHAR));

        if (pwszArg is NULL)
        {
            DisplayError(NULL, 
                         ERROR_NOT_ENOUGH_MEMORY);

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(pwszArg, ppwcArguments[i]);

        pwcTag = wcstok(pwszArg, NETSH_ARG_DELIMITER);

        //
        // Got the first part
        // Now if next call returns NULL then there was no tag
        //

        pwcTagVal = wcstok((PWCHAR)NULL,  NETSH_ARG_DELIMITER);

        if (pwcTagVal is NULL)
        {
            DisplayMessage(g_hModule, 
                           ERROR_NO_TAG,
                           ppwcArguments[i]);

            HeapFree(GetProcessHeap(),0,pwszArg);

            return ERROR_INVALID_PARAMETER;
        }

        //
        // Got the tag. Now try to match it
        //

        bFound = FALSE;
        pdwOut[i - dwCurrentIndex] = (DWORD) -1;

        for ( j = 0; j < dwNumTags; j++)
        {
            if (MatchToken(pwcTag, pttTagToken[j].pwszTag))
            {
                //
                // Tag matched
                //

                bFound = TRUE;
                pdwOut[i - dwCurrentIndex] = j;
                break;
            }
        }

        if (bFound)
        {
            //
            // Remove tag from the argument
            //

            wcscpy(ppwcArguments[i], pwcTagVal);
        }
        else
        {
            DisplayError(NULL,
                         ERROR_INVALID_OPTION_TAG, 
                         pwcTag);

            HeapFree(GetProcessHeap(),0,pwszArg);

            return ERROR_INVALID_OPTION_TAG;
        }

        HeapFree(GetProcessHeap(),0,pwszArg);
    }

    return NO_ERROR;
}

//
// Helper to IfutlParse that parses options
//
DWORD 
WINAPI
IfutlParseOptions(
    IN  PWCHAR*                 ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwNumArgs,
    IN  TAG_TYPE*               rgTags,
    IN  DWORD                   dwTagCount,
    OUT LPDWORD*                ppdwTagTypes)

/*++

Routine Description:

    Based on an array of tag types returns which options are
    included in the given command line.

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
    
{
    LPDWORD     pdwTagType;
    DWORD       i, dwErr = NO_ERROR;
    
    // If there are no arguments, there's nothing to to
    //
    if ( dwNumArgs == 0 )
    {   
        return NO_ERROR;
    }

    // Set up the table of present options
    pdwTagType = (LPDWORD) IfutlAlloc(dwArgCount * sizeof(DWORD), TRUE);
    if(pdwTagType is NULL)
    {
        DisplayError(NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do {
        //
        // The argument has a tag. Assume all of them have tags
        //
        if(wcsstr(ppwcArguments[dwCurrentIndex], NETSH_ARG_DELIMITER))
        {
            dwErr = IfutlGetTagToken(
                        g_hModule, 
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        dwTagCount,
                        pdwTagType);

            if(dwErr isnot NO_ERROR)
            {
                if(dwErr is ERROR_INVALID_OPTION_TAG)
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    break;
                }
            }
        }
        else
        {
            //
            // No tags - all args must be in order
            //
            for(i = 0; i < dwNumArgs; i++)
            {
                pdwTagType[i] = i;
            }
        }
        
    } while (FALSE);        

    // Cleanup
    {
        if (dwErr is NO_ERROR)
        {
            *ppdwTagTypes = pdwTagType;
        }
        else
        {
            IfutlFree(pdwTagType);
        }
    }

    return dwErr;
}


//
// Generic parse
//
DWORD
IfutlParse(
    IN  PWCHAR*         ppwcArguments,
    IN  DWORD           dwCurrentIndex,
    IN  DWORD           dwArgCount,
    IN  BOOL*           pbDone,
    OUT IFMON_CMD_ARG*  pIfArgs,
    IN  DWORD           dwIfArgCount)
{
    DWORD            i, dwNumArgs, dwErr, dwLevel = 0;
    LPDWORD          pdwTagType = NULL;
    TAG_TYPE*        pTags = NULL;
    IFMON_CMD_ARG*   pArg = NULL;

    if (dwIfArgCount == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do {
        // Initialize
        dwNumArgs = dwArgCount - dwCurrentIndex;
        
        // Generate a list of the tags
        //
        pTags = (TAG_TYPE*)
            IfutlAlloc(dwIfArgCount * sizeof(TAG_TYPE), TRUE);
        if (pTags == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        for (i = 0; i < dwIfArgCount; i++)
        {
            CopyMemory(&pTags[i], &pIfArgs[i].rgTag, sizeof(TAG_TYPE));
        }
    
        // Get the list of present options
        //
        dwErr = IfutlParseOptions(
                    ppwcArguments,
                    dwCurrentIndex,
                    dwArgCount,
                    dwNumArgs,
                    pTags,
                    dwIfArgCount,
                    &pdwTagType);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Copy the tag info back
        //
        for (i = 0; i < dwIfArgCount; i++)
        {
            CopyMemory(&pIfArgs[i].rgTag, &pTags[i], sizeof(TAG_TYPE));
        }
    
        for(i = 0; i < dwNumArgs; i++)
        {
            // Validate the current argument
            //
            if (pdwTagType[i] >= dwIfArgCount)
            {
                i = dwNumArgs;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
            pArg = &pIfArgs[pdwTagType[i]];

            // Get the value of the argument
            //
            switch (pArg->dwType)
            {
                case IFMON_CMD_TYPE_STRING:
                    pArg->Val.pszValue = 
                        IfutlStrDup(ppwcArguments[i + dwCurrentIndex]);
                    break;
                    
                case IFMON_CMD_TYPE_ENUM:
                    dwErr = MatchEnumTag(g_hModule,
                                         ppwcArguments[i + dwCurrentIndex],
                                         pArg->dwEnumCount,
                                         pArg->rgEnums,
                                         &(pArg->Val.dwValue));

                    if(dwErr != NO_ERROR)
                    {
                        IfutlDispTokenErrMsg(
                            g_hModule, 
                            EMSG_BAD_OPTION_VALUE,
                            pArg->rgTag.pwszTag,
                            ppwcArguments[i + dwCurrentIndex]);
                        i = dwNumArgs;
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                    break;
            }
            if (dwErr != NO_ERROR)
            {
                break;
            }

            // Mark the argument as present if needed
            //
            if (pArg->rgTag.bPresent)
            {
                dwErr = ERROR_TAG_ALREADY_PRESENT;
                i = dwNumArgs;
                break;
            }
            pArg->rgTag.bPresent = TRUE;
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        // Make sure that all of the required parameters have
        // been included.
        //
        for (i = 0; i < dwIfArgCount; i++)
        {
            if ((pIfArgs[i].rgTag.dwRequired & NS_REQ_PRESENT) 
             && !pIfArgs[i].rgTag.bPresent)
            {
                DisplayMessage(g_hModule, EMSG_CANT_FIND_EOPT);
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
        if(dwErr isnot NO_ERROR)
        {
            break;
        }

    } while (FALSE);  
    
    // Cleanup
    {
        if (pTags)
        {
            IfutlFree(pTags);
        }
        if (pdwTagType)
        {
            IfutlFree(pdwTagType);
        }
    }

    return dwErr;
    
}

//
// Returns an allocated block of memory conditionally
// zeroed of the given size.
//
PVOID 
WINAPI
IfutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    )
{
    PVOID pvRet;
    DWORD dwFlags = 0;

    if (bZero)
    {
        dwFlags |= HEAP_ZERO_MEMORY;
    }

    return HeapAlloc(GetProcessHeap(), dwFlags, dwBytes);
}

//
// Conditionally free's a pointer if it is non-null
//
VOID 
WINAPI
IfutlFree(
    IN PVOID pvData
    )
{
    if (pvData)
    {
        HeapFree(GetProcessHeap(), 0, pvData);
    }        
}

// 
// Uses IfutlAlloc to copy a string
//
PWCHAR
WINAPI
IfutlStrDup(
    IN LPCWSTR pwszSrc
    )
{
    PWCHAR pszRet = NULL;
    DWORD dwLen; 
    
    if ((pwszSrc is NULL) or
        ((dwLen = wcslen(pwszSrc)) == 0)
       )
    {
        return NULL;
    }

    pszRet = (PWCHAR) IfutlAlloc((dwLen + 1) * sizeof(WCHAR), FALSE);
    if (pszRet isnot NULL)
    {
        wcscpy(pszRet, pwszSrc);
    }

    return pszRet;
}

BOOL
IfutlIsRouterRunning(
    VOID
    )

/*++

Routine Description:

    Gets the status of the router

Arguments:


Return Value:


--*/

{
    DWORD   dwErr;

    //
    // Check every 5th call
    //

    if(g_ulNumChecks isnot 0)
    {
        return g_bRouterRunning;
    }

    g_ulNumChecks++;

    g_ulNumChecks %= 5;

    if(MprAdminIsServiceRunning(g_pwszRouter))
    {
        if(g_bRouterRunning)
        {
            return TRUE;
        }

        dwErr = MprAdminServerConnect(g_pwszRouter,
                                      &g_hMprAdmin);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           EMSG_CAN_NOT_CONNECT_DIM,
                           dwErr);

            return FALSE;
        }

        dwErr = MprAdminMIBServerConnect(g_pwszRouter,
                                         &g_hMIBServer);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           EMSG_CAN_NOT_CONNECT_DIM,
                           dwErr);

            MprAdminServerDisconnect(g_hMprAdmin);

            g_hMprAdmin = NULL;

            return FALSE;
        }

        g_bRouterRunning = TRUE;
    }
    else
    {
        if(g_bRouterRunning)
        {
            g_bRouterRunning = FALSE;
            g_hMprAdmin      = NULL;
            g_hMIBServer     = NULL;
        }
    }

    return g_bRouterRunning;
}

DWORD
GetIpAddress(
    IN  PWCHAR        ppwcArg,
    OUT PIPV4_ADDRESS pipAddress
    )
/*++

Routine Description:

    Gets the ip address from the string.

Arguments:

    pwszIpAddr - Ip address string
    pipAddress - IP address

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER

--*/
{
    CHAR     pszIpAddr[ADDR_LENGTH+1];

    // Make sure all characters are legal [0-9.]

    if (ppwcArg[ wcsspn(ppwcArg, L"0123456789.") ])
    {
        return ERROR_INVALID_PARAMETER;
    }

    // make sure there are 3 "." (periods)
    {
        DWORD i;
        PWCHAR TmpPtr;
        
        for (i=0,TmpPtr=ppwcArg;  ;  i++) {
            TmpPtr = wcschr(TmpPtr, L'.');
            if (TmpPtr)
                TmpPtr++;
            else
                break;
        }

        if (i!=3)
            return ERROR_INVALID_PARAMETER;
    }

     
    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ppwcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';

    *pipAddress = (DWORD) inet_addr(pszIpAddr);

    // if there was an error, make sure that the address
    // specified was not 255.255.255.255
    
    if (*pipAddress == INADDR_NONE
        && wcscmp(ppwcArg,L"255.255.255.255"))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ((*pipAddress&0x000000FF) == 0)
        return ERROR_INVALID_PARAMETER;
        
    return NO_ERROR;
}



// NOTE: CheckMask fails when IpAddr is 0xffffffff!
BOOL
CheckMask(
    DWORD IpAddr
    )
{
    DWORD i,Mask;
    
    IpAddr = htonl(IpAddr);

    for (i=0,Mask=0;  i<32;  (Mask = ((Mask>>1) + 0x80000000)), i++ ) {
        if (IpAddr == Mask)
            return FALSE;
    }
    
    return TRUE;
}


DWORD
IfutlGetIfIndexFromFriendlyName(
    PWCHAR IfFriendlyName,
    PULONG pdwIfIndex
    )
{
    WCHAR wszGuid[200];
    DWORD dwSize = sizeof(wszGuid);
    

    IfutlGetInterfaceName(
                IfFriendlyName,
                wszGuid,
                &dwSize
                );

    return IfutlGetIfIndexFromInterfaceName(
                wszGuid,
                pdwIfIndex);
}

DWORD
IfutlGetIfIndexFromInterfaceName(
    IN  PWCHAR            pwszGuid,
    OUT PDWORD            pdwIfIndex
    )
{
    GUID guid;
    DWORD dwErr, i, dwCount;
    PIP_INTERFACE_NAME_INFO pTable;
    BOOL bFound = FALSE;
    PWCHAR TmpGuid;
    
    *pdwIfIndex = 0;
    
    dwErr = NhpAllocateAndGetInterfaceInfoFromStack(
                &pTable,
                &dwCount,
                FALSE,
                GetProcessHeap(),
                0);

    if (dwErr != NO_ERROR)
        return dwErr;

    for (i=0;  i<dwCount;  i++) {

        dwErr = StringFromCLSID(&pTable[i].DeviceGuid, &TmpGuid);
        if (dwErr != S_OK)
            return dwErr;

        
        if (wcscmp(TmpGuid, pwszGuid) == 0) {
            bFound = TRUE;
            *pdwIfIndex = pTable[i].Index;
            break;
        }

        CoTaskMemFree(TmpGuid);
    }

    if (!bFound)
        return ERROR_CAN_NOT_COMPLETE;

    return NO_ERROR;
}

DWORD
WINAPI
InterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    )
{
    DWORD               dwRes;
    PMPR_INTERFACE_0    pmi0;

    /*if(!IsRouterRunning())*/
    {
    
        dwRes = MprConfigInterfaceEnum(g_hMprConfig,
                                       0,
                                       (LPBYTE*) &pmi0,
                                       (DWORD) -1,
                                       pdwCount,
                                       pdwTotal,
                                       NULL);

        if(dwRes == NO_ERROR)
        {
            *ppb = (PBYTE)pmi0;
        }
    }
    /*else
    {
        dwRes = MprAdminInterfaceEnum(g_hMprAdmin,
                                      0,
                                      (LPBYTE*) &pmi0,
                                      (DWORD) -1,
                                      pdwCount,
                                      pdwTotal,
                                      NULL);


        if(dwRes == NO_ERROR)
        {
            *ppb = HeapAlloc(GetProcessHeap(),
                             0,
                             sizeof(MPR_INTERFACE_0) * (*pdwCount));


            if(*ppb == NULL)
            {
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(*ppb, pmi0, sizeof(MPR_INTERFACE_0) * (*pdwCount));

            MprAdminBufferFree(pmi0);

        }
    }*/

    return dwRes;
}

VOID
MakeAddressStringW(
    OUT PWCHAR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    )
{
    swprintf( pwcPrefixStr,
              L"%d.%d.%d.%d",
              PRINT_IPADDR(ipAddr) );
}

DWORD
GetGuidFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT PWCHAR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
{
    MIB_OPAQUE_QUERY  Query;
    PMIB_IFROW        pIfRow;
    DWORD             dwErr, dwOutEntrySize;
    PMIB_OPAQUE_INFO  pRpcInfo;

    Query.dwVarId         = IF_ROW;
    Query.rgdwVarIndex[0] = dwIfIndex;

    dwErr = MibGet(             PID_IP,
                                IPRTRMGR_PID,
                                (PVOID) &Query,
                                sizeof(Query),
                                (PVOID *) &pRpcInfo,
                                &dwOutEntrySize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pIfRow = (PMIB_IFROW)(pRpcInfo->rgbyData);

    wcscpy( pwszBuffer, pIfRow->wszName );

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return NO_ERROR;
}

DWORD
IfutlGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT PWCHAR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
/*++

Routine Description:

    Gets Friendly Interface Name from Interface Index

Arguments:

    hMibServer      - Handle to the MIB server
    dwIfIndex       - Interface index
    pwszBuffer      - Buffer to hold the Friendly Interface Name
    dwBufferSize    - Size (in Bytes) of pwszBuffer buffer

--*/
{
    WCHAR        wszGuid[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        dwErr;

    dwErr = GetGuidFromIfIndex(hMibServer, dwIfIndex, wszGuid, sizeof(wszGuid));

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    IfutlGetInterfaceDescription(wszGuid, pwszBuffer, &dwBufferSize);

    return NO_ERROR;
}

DWORD
GetMibTagToken(
    IN  PWCHAR  *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    )

/*++

Routine Description:

    Looks for indices and refresh rate arguments in the command. If index
    tag is present, it would be of the form index= index1 index2 ....
    The index= is removed by this function. So is rr= if it is there in
    the command. If pdwRR is 0 then, no refresh sought.

Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG

--*/
{
    DWORD    i;
    BOOL     bTag;

    if (dwArgCount is 0)
    {
        *pdwRR = 0;
        *pbIndex = FALSE;

        return NO_ERROR;
    }

    if (dwArgCount < dwNumIndices)
    {
        //
        // No index
        //

        *pbIndex = FALSE;

        if (dwArgCount > 1)
        {
            *pdwRR = 0;

            return ERROR_INVALID_PARAMETER;
        }

        //
        // No Index specified. Make sure refresh rate is specified
        // with tag.
        //

        if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
        {
            //
            // get the refresh rate
            //

            *pdwRR = wcstoul(&ppwcArguments[0][3], NULL, 10);
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        //
        // Check for index tag
        //

        if (_wcsnicmp(ppwcArguments[0],L"INDEX=",6) == 0)
        {
            *pbIndex = TRUE;
            *pdwIndex = 0;

            //
            // remove tag and see if refresh rate is specified
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][6]);

            if (dwArgCount > dwNumIndices)
            {
                //
                // Make sure that argument has RR tag
                //

                if (_wcsnicmp(ppwcArguments[dwNumIndices],L"RR=",3) == 0)
                {
                    //
                    // get the refresh rate
                    //

                    *pdwRR = wcstoul(&ppwcArguments[dwNumIndices][3], NULL , 10);
                }
                else
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                //
                // No refresh rate specified
                //

                *pdwRR = 0;
                return NO_ERROR;
            }
        }
        else
        {
            //
            // Not index tag, See if it has an RR tag
            //

            if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
            {
                //
                // get the refresh rate
                //

                *pdwRR = wcstoul(&ppwcArguments[0][3], NULL , 10);

                //
                // See if the index follows
                //

                if (dwArgCount > dwNumIndices)
                {
                    if (dwArgCount > 1)
                    {
                        if (_wcsnicmp(ppwcArguments[1],L"INDEX=",6) == 0)
                        {
                            wcscpy(ppwcArguments[1], &ppwcArguments[1][6]);
                            *pbIndex = TRUE;
                            *pdwIndex = 1;

                            return NO_ERROR;
                        }
                        else
                        {
                            *pdwRR = 0;
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        return NO_ERROR;
                    }
                }
            }
            //
            // No RR Tag either
            //
            else if (dwArgCount > dwNumIndices)
            {
                //
                // Assume ppwcArguments[dwNumIndices] is the refresh rate
                //

                *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);

                if (dwNumIndices != 0)
                {
                    *pbIndex = TRUE;
                    *pdwIndex = 0;
                }
            }
            else
            {
                //
                // only index present with no tag
                //
                *pbIndex = TRUE;
                *pdwIndex = 0;
            }
        }
    }

    return NO_ERROR;
}

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGet( g_hMIBServer,
                                 dwTransportId,
                                 dwRoutingPid,
                                 lpInEntry,
                                 dwInEntrySize,
                                 lplpOutEntry,
                                 lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\inc\macros.h ===
#ifndef _DEBUG
#define DEBUG(s)
#define DEBUG1(s1,s2)
#define DEBUG2(s1,s2)
#else
#define DEBUG(s) wprintf(L"%s\n", L##s)
#define DEBUG1(s1,s2) wprintf(L##s1, L##s2)
#define DEBUG2(s1,s2) wprintf(L##s1, L##s2)
#endif

#define PRINT(s) wprintf(L"%s\n",s)
#define PRINT1(s,s1) wprintf(L##s , L##s1)

#define is ==
#define isnot !=
#define or ||
#define and &&

#define FREE_STRING_NOT_NULL(ptszString) if (ptszString) FreeString(ptszString)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\inc\ipmontr.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ipmontr.h

Abstract:
    This file contains definitions which are needed by IPMONTR.DLL
    and all NetSh helper DLLs which register under it.

--*/

#ifndef _IPMONTR_H_
#define _IPMONTR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// {65EC23C0-D1B9-11d2-89E4-006008B0E5B9}
#define ROUTING_GUID \
{ 0x65ec23c0, 0xd1b9, 0x11d2, { 0x89, 0xe4, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }


// {0705ECA0-7AAC-11d2-89DC-006008B0E5B9}
#define IPMONTR_GUID \
{ 0x705eca0, 0x7aac, 0x11d2, { 0x89, 0xdc, 0x0, 0x60, 0x8, 0xb0, 0xe5, 0xb9 } }

#define IPMON_VERSION_50    0x0005000

#define ADDR_LENGTH          24
#define ADDR_LEN              4

#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define IP_TO_WSTR(str,addr) swprintf((str),L"%d.%d.%d.%d", \
                    (addr)[0],    \
                    (addr)[1],    \
                    (addr)[2],    \
                    (addr)[3])

#ifdef UNICODE
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    MultiByteToWideChar(GetConsoleOutputCP(),                            \
                        0,                                 \
                        (pszAddr),                         \
                        -1,                                \
                        (ptszUnicode),                     \
                        ADDR_LENGTH)
#else
#define MakeUnicodeIpAddr(ptszUnicode,pszAddr)             \
    strcpy((ptszUnicode),(pszAddr))
#endif //UNICODE

//
// API prototypes and structures used by them
//

typedef
DWORD
(WINAPI IP_CONTEXT_ENTRY_FN)(
    IN     LPCWSTR              pwszMachine,
    IN OUT LPWSTR              *pptcArguments,
    IN     DWORD                dwArgCount,
    IN     DWORD                dwFlags,
    IN     MIB_SERVER_HANDLE    hMIBServer,
    OUT    LPWSTR               pwcNewContext
    );

typedef IP_CONTEXT_ENTRY_FN *PIP_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI ROUTING_CONTEXT_ENTRY_FN)(
    IN     LPCWSTR              pwszRouter,
    IN OUT LPSTR               *pptcArguments,
    IN     DWORD                dwArgCount,
    IN     DWORD                dwFlags,
    OUT    LPSTR                pwcNewContext
    );

typedef ROUTING_CONTEXT_ENTRY_FN *PROUTING_CONTEXT_ENTRY_FN;

typedef
DWORD
(WINAPI ROUTING_CONTEXT_COMMIT_FN)(
    IN  DWORD   dwAction
    );

typedef ROUTING_CONTEXT_COMMIT_FN *PROUTING_CONTEXT_COMMIT_FN;

DWORD WINAPI
IpmontrDeleteInfoBlockFromInterfaceInfo(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType
    );

DWORD WINAPI
IpmontrDeleteInfoBlockFromGlobalInfo(
    IN  DWORD       dwType
    );

DWORD WINAPI
IpmontrDeleteProtocol(
    IN  DWORD       dwProtoId
    );

DWORD WINAPI
IpmontrGetInfoBlockFromGlobalInfo(
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount
    );

DWORD WINAPI
IpmontrGetInfoBlockFromInterfaceInfo(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwIfType
    );

DWORD WINAPI
IpmontrSetInfoBlockInGlobalInfo(
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

DWORD WINAPI
IpmontrSetInfoBlockInInterfaceInfo(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

DWORD WINAPI
IpmontrInterfaceEnum(
    OUT BYTE        **ppb,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwTotal
    );

typedef
BOOL
(WINAPI *PIM_ROUTER_STATUS)(
    VOID
    );

DWORD WINAPI
IpmontrGetInterfaceType(
    IN  LPCWSTR   pwszIfName,
    OUT PDWORD    pdwIfType
    );

typedef
DWORD
(WINAPI *PIM_MATCH_ROUT_PROTO)(
    IN  LPCWSTR   pwszToken
    );

DWORD WINAPI
IpmontrGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD WINAPI
IpmontrGetIfIndexFromFriendlyName(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszBuffer,
    OUT PDWORD            pdwIfIndex
    );

DWORD WINAPI
IpmontrGetFriendlyNameFromIfName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD WINAPI
IpmontrGetIfNameFromFriendlyName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD WINAPI
IpmontrCreateInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName,
    IN  DWORD   dwLocalAddress,
    IN  DWORD   dwRemoteAddress,
    IN  BYTE    byTtl
    );

DWORD WINAPI
IpmontrDeleteInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName
    );

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#ifdef __cplusplus
}
#endif

#endif // _IPMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\inc\ipxmontr.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ipxmontr.h

Abstract:
    This file contains definitions which are needed by IPXMONTR.DLL
    and all NetSh helper DLLs which register under it.

--*/

#ifndef _IPXMONTR_H_
#define _IPXMONTR_H_


#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// {b1641451-84b8-11d2-b940-3078302c2030}
#define IPXMONTR_GUID \
{                                                           \
    0xb1641451, 0x84b8, 0x11d2,                             \
    {                                                       \
        0xb9, 0x40, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30      \
    }                                                       \
}


#define IPXMON_VERSION_50       0x0005000


//
// API prototypes and structures used by them
//

typedef
DWORD
(WINAPI IPX_CONTEXT_ENTRY_FN)(
    IN     LPCWSTR              pwszMachine,
    IN OUT LPWSTR               *ppwcArguments,
    IN     DWORD                dwArgCount,
    IN     DWORD                dwFlags,
    IN     MIB_SERVER_HANDLE    hMIBServer,
    OUT    LPWSTR               pwcNewContext
    );

typedef IPX_CONTEXT_ENTRY_FN *PIPX_CONTEXT_ENTRY_FN;

typedef struct _PROTO_STRING
{
    DWORD    dwProtoId;
    DWORD    dwTokenId;
}PROTO_STRING, *PPROTO_STRING;

typedef
DWORD
(WINAPI *PIM_DEL_INFO_BLK_IF)(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType
    );

typedef
DWORD
(WINAPI *PIM_DEL_INFO_BLK_GLOBAL)(
    IN  DWORD       dwType
    );

typedef
DWORD
(WINAPI *PIM_DEL_PROTO)(
    IN  DWORD       dwProtoId
    );

typedef
DWORD
(WINAPI *PIM_GET_INFO_BLK_GLOBAL)(
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount
    );

typedef
DWORD
(WINAPI *PIM_GET_INFO_BLK_IF)(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    OUT BYTE        **ppbInfoBlk,
    OUT PDWORD      pdwSize,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwIfType
    );

typedef
DWORD
(WINAPI *PIM_SET_INFO_BLK_GLOBAL)(
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

typedef
DWORD
(WINAPI *PIM_SET_INFO_BLK_IF)(
    IN  LPCWSTR     pwszIfName,
    IN  DWORD       dwType,
    IN  PBYTE       pbInfoBlk,
    IN  DWORD       dwSize,
    IN  DWORD       dwCount
    );

typedef
DWORD
(WINAPI *PIM_IF_ENUM)(
    OUT BYTE        **ppb,
    OUT PDWORD      pdwCount,
    OUT PDWORD      pdwTotal
    );

typedef
DWORD
(WINAPI *PIM_PROTO_LIST)(
    OUT PPROTO_STRING    *ppps,
    OUT PDWORD           pdwNumProto
    );

typedef
BOOL
(WINAPI *PIM_ROUTER_STATUS)(
    VOID
    );

typedef
DWORD
(WINAPI *PIM_GET_IF_TYPE)(
    IN  LPCWSTR   pwszIfName,
    OUT PDWORD    pdwIfType
    );

typedef
DWORD
(WINAPI *PIM_MATCH_ROUT_PROTO)(
    IN  LPCWSTR   pwszToken
    );

#ifdef __cplusplus
}
#endif

#endif // _IPXMONTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\boundary.h ===
typedef DWORD          IPV4_ADDRESS, *PIPV4_ADDRESS;

FN_HANDLE_CMD HandleIpAddScope;
FN_HANDLE_CMD HandleIpDelScope;
FN_HANDLE_CMD HandleIpSetScope;
FN_HANDLE_CMD HandleIpShowScope;

FN_HANDLE_CMD HandleIpAddBoundary;
FN_HANDLE_CMD HandleIpDelBoundary;
FN_HANDLE_CMD HandleIpSetBoundary;
FN_HANDLE_CMD HandleIpShowBoundary;

DWORD
GetPrintBoundaryInfo(
    MIB_SERVER_HANDLE hMIBServer
    );

#if 0
DWORD
GetPrintScopeInfo(
    MIB_SERVER_HANDLE hMIBServer
    );
#endif

DWORD
ShowScopes(
    IN HANDLE  hFile
    );

DWORD
ShowBoundaryInfoForInterface(
    IN  HANDLE  hFile,
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwNumRows
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\boundary.c ===
#include "precomp.h"
#pragma hdrstop

#ifdef SN_UNICODE
# define  sn_strlen  wcslen
# define  sn_strcpy  wcscpy
# define  sn_sprintf wsprintf
# define  sn_strcmp  wcscmp
# define  SN_EMPTYSTRING L""
# define  SN_L       L
#else
# define  sn_strlen  strlen
# define  sn_strcpy  strcpy
# define  sn_sprintf sprintf
# define  sn_strcmp  strcmp
# define  SN_EMPTYSTRING ""
# define  SN_L
#endif

IPV4_ADDRESS g_ipGrpAddr,
             g_ipGrpMask;
SCOPE_NAME   g_snScopeName;

enum RouterOps
{
    ADD_BOUNDARY       = 1,
    DELETE_BOUNDARY,
    ADD_SCOPE,
    DELETE_SCOPE,
    SET_SCOPE
};

typedef struct _SCOPE_ENTRY {
    IPV4_ADDRESS      ipGroupAddress;
    IPV4_ADDRESS      ipGroupMask;
    ULONG             ulNumNames;
    BOOL              bDivisible;
    LANGID            idLanguage;
    SCOPE_NAME_BUFFER snScopeNameBuffer;
    DWORD             dwNumInterfaces;
} SCOPE_ENTRY, *PSCOPE_ENTRY;

#define MIN_SCOPE_ADDR         0xef000000
#define MAX_SCOPE_ADDR        (0xefff0000 - 1)

DWORD
UpdateBoundaryBlock( 
    IN     DWORD  dwAction,
    IN     PBYTE  pib,
    OUT    PBYTE *ppibNew,
    IN OUT DWORD *pdwBlkSize,
    IN OUT DWORD *pdwCount,
    OUT    BOOL  *bChanged
    );

PSCOPE_ENTRY
FindScopeByPrefix(
    IN  IPV4_ADDRESS      ipGroupAddress,
    IN  IPV4_ADDRESS      ipGroupMask,
    IN  PSCOPE_ENTRY      pScopes,
    IN  ULONG             ulNumScopes
    )
{
    DWORD dwInd;

    for (dwInd = 0; dwInd < ulNumScopes; dwInd++)
    {
        if ( pScopes[dwInd].ipGroupAddress == ipGroupAddress
          && pScopes[dwInd].ipGroupMask    == ipGroupMask )
        {
            return &pScopes[dwInd];
        }
    }

    return NULL;
}

DWORD
FindScopeByName(
    IN  SCOPE_NAME    snScopeName,
    IN  PSCOPE_ENTRY  pScopes,
    IN  ULONG         ulNumScopes,
    OUT PSCOPE_ENTRY *ppScope
    )
{
    DWORD dwErr = NO_ERROR;
    ULONG i, j, dwCnt = 0;

    for (i = 0; i < ulNumScopes; i++)
    {
        if ( !sn_strcmp(snScopeName, pScopes[i].snScopeNameBuffer))
        {
            *ppScope = &pScopes[i];

            dwCnt++;
        }
    }

    switch (dwCnt) 
    {
    case 0:
        *ppScope = NULL;

        return ERROR_NOT_FOUND;

    case 1: 
        return NO_ERROR;

    default:
        return ERROR_MORE_DATA;
    }
}


DWORD
MakeInfoFromScopes2(
    OUT    PBYTE        pBuffer,
    IN OUT ULONG       *pulBufferLen,
    IN     PSCOPE_ENTRY pScopes,
    IN     ULONG        ulNumScopes
    )
/*++
Description:
    Compose registry block from array of scopes.
--*/
{
    DWORD dwLen, i, dwSize, dwNumNames, j, dwLanguage, dwFlags;
    PLIST_ENTRY pleNode;

    if (ulNumScopes is 0) {
        *pulBufferLen = 0;
        return NO_ERROR;
    }

    // Compute size needed

    dwSize = sizeof(DWORD);

    for (i=0; i< ulNumScopes; i++) 
    {
        dwSize += 2 * sizeof(IPV4_ADDRESS) + 2 * sizeof(DWORD);
        
        // Currently we only store at most one name.
        for (j=0; j<pScopes[i].ulNumNames; j++)
        {
            dwSize += (DWORD)(2*sizeof(DWORD)
                   + sn_strlen(pScopes[i].snScopeNameBuffer) * sizeof(SN_CHAR));
        }
    }

    if (dwSize > *pulBufferLen)
    {
        *pulBufferLen = dwSize;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Save scope count in first DWORD
    //

    *((PDWORD) pBuffer) = ulNumScopes;
    pBuffer += sizeof(DWORD);

    //
    // Now step through and add each scope to the buffer
    //

    for (i=0; i< ulNumScopes; i++)
    {
       // Copy scope address, and mask
       dwLen = 2 * sizeof(IPV4_ADDRESS);
       CopyMemory(pBuffer, &pScopes[i], dwLen);
       pBuffer += dwLen;

       // Copy flags
       dwFlags = pScopes[i].bDivisible;
       CopyMemory(pBuffer, &dwFlags, sizeof(dwFlags));
       pBuffer += sizeof(dwFlags);

       // Copy # of names
       CopyMemory(pBuffer, &pScopes[i].ulNumNames, sizeof(DWORD));
       pBuffer += sizeof(DWORD);

       // Currently we only save at most one name
       for (j=0; j<pScopes[i].ulNumNames; j++)
       {
           // Save language
           dwLanguage = pScopes[i].idLanguage;
           CopyMemory(pBuffer, &dwLanguage, sizeof(dwLanguage));
           pBuffer += sizeof(dwLanguage);

           // Copy scope name (save length in words)
           dwLen = sn_strlen(pScopes[i].snScopeNameBuffer);
           CopyMemory(pBuffer, &dwLen, sizeof(DWORD));
           pBuffer += sizeof(DWORD);
           dwLen *= sizeof(SN_CHAR);

           if (dwLen) 
           {
               CopyMemory(pBuffer, pScopes[i].snScopeNameBuffer, dwLen);
               pBuffer += dwLen;
           }
       }
    }

    return NO_ERROR;
}

DWORD
MakeInfoFromScopes( 
    OUT PBYTE       *ppibNew, 
    OUT DWORD       *pdwSize, 
    IN  PSCOPE_ENTRY pScopes, 
    IN  ULONG        ulNumScopes
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
--*/
{
    *pdwSize = 0;
    *ppibNew = NULL;

    if (MakeInfoFromScopes2(NULL, pdwSize, pScopes, ulNumScopes)
      is ERROR_INSUFFICIENT_BUFFER)
    {
        *ppibNew = MALLOC( *pdwSize );

        if ( *ppibNew == NULL )
        {
            DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return MakeInfoFromScopes2(*ppibNew, pdwSize, pScopes, ulNumScopes);
}

PSCOPE_ENTRY
GetScopesFromInfo(
    IN  PBYTE                   pBuffer,
    OUT PULONG                  pulNumScopes
    )
/*++
Description:
    Convert a registry block into an array of scope information.
    Caller is responsible for freeing pointer returned.
--*/
{
    PSCOPE_ENTRY pScopes;
    DWORD        dwLen, i, dwNumNames, j, dwLanguage, dwFlags;

    if (pBuffer is NULL) 
    {
        *pulNumScopes = 0;
        return NULL;
    }

    //
    // Retrieve scope count from first DWORD
    //

    *pulNumScopes = *((PDWORD) pBuffer);
    pBuffer += sizeof(DWORD);

    //
    // Malloc enough space for pScopes
    //

    pScopes = MALLOC( (*pulNumScopes) * sizeof(SCOPE_ENTRY) );
    if (pScopes is NULL)
    {
        *pulNumScopes = 0;
        return NULL;
    }

    //
    // Now step through and add each scope to the array
    //

    for (i=0; i< *pulNumScopes; i++)
    {
       // Copy scope address, and mask
       dwLen = 2 * sizeof(IPV4_ADDRESS);
       CopyMemory(&pScopes[i], pBuffer, dwLen);
       pBuffer += dwLen;

       // Get flags
       CopyMemory(&dwFlags, pBuffer, sizeof(dwFlags));   
       pScopes[i].bDivisible = dwFlags;
       pBuffer += sizeof(dwFlags);

       // Get # of names
       CopyMemory(&dwNumNames, pBuffer, sizeof(DWORD));   
       pScopes[i].ulNumNames = dwNumNames;
       pBuffer += sizeof(DWORD);

       // Get names.  Currently, we'll only keep the last name (if any)
       // and throw out the rest.
       for (j=0; j<dwNumNames; j++)
       {
           // Set language name
           CopyMemory(&dwLanguage, pBuffer, sizeof(dwLanguage));
           pBuffer += sizeof(dwLanguage);
           pScopes[i].idLanguage = (LANGID)dwLanguage;
           
           CopyMemory(&dwLen, pBuffer, sizeof(DWORD));
           pBuffer += sizeof(DWORD);
           CopyMemory( pScopes[i].snScopeNameBuffer, 
                       pBuffer, 
                       dwLen * sizeof(SN_CHAR) );
           pScopes[i].snScopeNameBuffer[ dwLen ] = '\0';
           pBuffer += dwLen * sizeof(SN_CHAR);

           pScopes[i].ulNumNames = 1;
       }

       pScopes[i].dwNumInterfaces = 0; // this value is ignored
    }

    return pScopes;
}

PSCOPE_ENTRY
GetScopes(
    OUT PULONG                  pulNumScopes,
    OUT PBYTE                  *ppBuffer
    )
/*++
Description:
    Creates a SCOPE_ENTRY array by parsing the info block
    Caller is responsible for freeing both the pointer returned
    and the buffer passed back.
Called by:
    ShowBoundaryInfoForInterface(), UpdateScopeBlock()
--*/
{
    DWORD         i, dwLen, dwErr, dwBlkSize, dwCount;
    DWORD         dwInd;
    PSCOPE_ENTRY  pScopes;

    if ( IpmontrGetInfoBlockFromGlobalInfo( IP_MCAST_BOUNDARY_INFO,
                                     ppBuffer,
                                     &dwBlkSize,
                                     &dwCount ) isnot NO_ERROR)
    {
        *pulNumScopes = 0;
        return NULL;
    }

    pScopes = GetScopesFromInfo(*ppBuffer, pulNumScopes);

    return pScopes;
}

DWORD
ScopeNameToPrefix(
    IN  SCOPE_NAME    snScopeName,
    OUT IPV4_ADDRESS *pipScopeAddr,
    OUT IPV4_ADDRESS *pipScopeMask
    )
{
    DWORD        dwErr = ERROR_NOT_FOUND;
    ULONG        ulNumScopes;
    PBYTE        pBuffer = NULL;
    PSCOPE_ENTRY pScopes, pScope;

    // If first character is a digit, then assume it's
    // an address, not a name.

    if (iswdigit(snScopeName[0]))
    {
        dwErr = GetIpAddress(snScopeName, pipScopeAddr);

        if (dwErr is NO_ERROR)
        {
            return NO_ERROR;
        }
    }

    pScopes = GetScopes( &ulNumScopes, &pBuffer );

    if (pScopes)
    {
        dwErr = FindScopeByName(snScopeName, pScopes, ulNumScopes, &pScope);

        if (dwErr is NO_ERROR)
        {
            *pipScopeAddr = pScope->ipGroupAddress;
            *pipScopeMask = pScope->ipGroupMask;

            dwErr = NO_ERROR;
        }

        FREE(pScopes);
    }

    if (pBuffer)
        FREE(pBuffer);

    return dwErr;
}

DWORD
UpdateScope( 
    IN      PSCOPE_ENTRY  pScopeToUpdate,
    IN      PSCOPE_ENTRY  pScopes,
    IN      ULONG         ulNumScopes,
    OUT     PBYTE        *ppibNew,
    OUT     DWORD        *pdwSizeNew
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
--*/
{
    // Update the scope name

    sn_strcpy(pScopeToUpdate->snScopeNameBuffer, g_snScopeName);

    pScopeToUpdate->ulNumNames = 1;
    pScopeToUpdate->idLanguage = GetUserDefaultLangID();

    // Now convert the array to a buffer

    return MakeInfoFromScopes( ppibNew, pdwSizeNew, pScopes, ulNumScopes);
}

DWORD
DeleteBoundaryFromInterface( 
    IN  LPCWSTR      pwszIfName,
    IN  PSCOPE_ENTRY pScopeToDelete 
    )
{
    BOOL  bChanged;
    DWORD dwErr, dwBlkSize, dwCount, dwIfType;
    PBYTE pibNew, pib;

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo( pwszIfName,
                                           IP_MCAST_BOUNDARY_INFO,
                                           &pib,
                                           &dwBlkSize,
                                           &dwCount,
                                           &dwIfType );

    if (dwErr is ERROR_NOT_FOUND)
        return NO_ERROR;

    if (dwErr isnot NO_ERROR)
        return dwErr;

    dwErr = UpdateBoundaryBlock( DELETE_BOUNDARY,
                                 pib,
                                 &pibNew,
                                 &dwBlkSize,
                                 &dwCount,
                                 &bChanged );

    if (dwErr is NO_ERROR && bChanged)
    {
        dwErr = IpmontrSetInfoBlockInInterfaceInfo( pwszIfName,
                                             IP_MCAST_BOUNDARY_INFO,
                                             pibNew,
                                             dwBlkSize,
                                             dwCount );
    }

    if (pib)
        FREE(pib);

    if (pibNew)
        FREE(pibNew);
    
    return dwErr;
}

DWORD
DeleteScopeBoundaries(
    IN      PSCOPE_ENTRY  pScopeToDelete
    )
{
    DWORD dwErr, dwCount, dwTotal, i;
    PMPR_INTERFACE_0     pmi0;

    // Enumerate interfaces

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    // Delete scope boundaries for each interface

    for ( i = 0; i < dwCount && dwErr is NO_ERROR; i++)
    {
        dwErr = DeleteBoundaryFromInterface( pmi0[i].wszInterfaceName,
                                             pScopeToDelete );

        // Ignore ERROR_NO_SUCH_INTERFACE since it may be that IP
        // is not enabled on the interface, so we expect to get this
        // error sometimes.

        if (dwErr is ERROR_NO_SUCH_INTERFACE)
        {
            dwErr = NO_ERROR;
        }
    }

    return dwErr;
}

DWORD
DeleteScope( 
    IN      PSCOPE_ENTRY  pScopeToDelete,
    IN      PSCOPE_ENTRY  pScopes,
    IN      ULONG        *pulNumScopes,
    OUT     PBYTE        *ppibNew,
    OUT     DWORD        *pdwSizeNew
    )
/*++
Description:
    Creates a new info block which does not include the scope given
    by pScopeToDelete.
    Caller is responsible for freeing buffer returned.
Called by:
    UpdateScopeBlock()
--*/
{
    DWORD dwErr;

    // Delete all boundaries for this scope

    dwErr = DeleteScopeBoundaries(pScopeToDelete);

    if (dwErr isnot NO_ERROR)
        return dwErr;

    // Delete the scope from the array

    MoveMemory( pScopeToDelete, 
                pScopeToDelete+1, 
                ((PBYTE)(pScopes + *pulNumScopes)) 
                  - ((PBYTE)(pScopeToDelete + 1) ));

    (*pulNumScopes)--;

    // Now convert the array to a buffer

    return MakeInfoFromScopes( ppibNew, pdwSizeNew, pScopes, *pulNumScopes);
}

DWORD
AddScope(
    IN OUT  PSCOPE_ENTRY *ppScopes,
    IN      ULONG        *pulNumScopes,
    OUT     PBYTE        *ppibNew,
    OUT     DWORD        *pdwSizeNew
    )
/*++
Description:
    Creates a new info block which includes the scope given
    by g_snScopeName, g_dwDstAddr, and g_dwDstMask.
    Caller is responsible for freeing buffer returned.
Called by:
    UpdateScopeBlock()
--*/
{
    PBYTE                  *pBuff;

    DWORD                   dwRes       = NO_ERROR,
                            dwInd,
                            dwSize      = 0,
                            dwSizeReqd  = 0;

    SCOPE_ENTRY            *pScopes = *ppScopes;

    do
    {
        // Make room for the new scope

        if (*pulNumScopes > 0)
            pScopes = REALLOC( pScopes, 
                               (*pulNumScopes + 1) * sizeof(SCOPE_ENTRY) );
        else
            pScopes = MALLOC( sizeof(SCOPE_ENTRY) );
        
        if (!pScopes)
            return ERROR_NOT_ENOUGH_MEMORY;

        dwInd = (*pulNumScopes)++;

        // Fill in the new scope 

        ZeroMemory(&pScopes[dwInd], sizeof(SCOPE_ENTRY));
        pScopes[dwInd].ipGroupAddress = g_ipGrpAddr;
        pScopes[dwInd].ipGroupMask    = g_ipGrpMask;
        sn_strcpy(pScopes[dwInd].snScopeNameBuffer, g_snScopeName);
        pScopes[dwInd].ulNumNames = 1;
        pScopes[dwInd].idLanguage = GetUserDefaultLangID();

        // Now convert the array to a buffer

        dwRes = MakeInfoFromScopes( ppibNew, &dwSize, pScopes, *pulNumScopes);

    } while ( FALSE );

    *pdwSizeNew = dwSize;

    *ppScopes = pScopes;

    return dwRes;
}

BOOL
IsContiguous(
    IN IPV4_ADDRESS dwMask
    )
{
    register int i;

    dwMask = ntohl(dwMask);

    // Set i to index of lowest 1 bit, or 32 if none
    for (i=0; i<32 && !(dwMask & (1<<i)); i++);

    // Set i to index of lowest 0 bit greater than the 1 bit found,
    // or 32 if none
    for (; i<32 && (dwMask & (1<<i)); i++);

    // Mask is contiguous if we got up to 32 without finding such
    // a 0 bit.
    return (i is 32);
}

DWORD
UpdateScopeBlock( 
    DWORD  dwAction,
    PBYTE  pib,
    PBYTE *ppibNew,
    DWORD *pdwBlkSize,
    DWORD *pdwCount
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
Called by:
    IpAddSetDelScope()
--*/
{
    DWORD                   dwRes       = (DWORD) -1,
                            dwInd       = 0,
                            dwSize      = 0;

    ULONG                   ulNumScopes = 0;

    PSCOPE_ENTRY            pScopes     = NULL,
                            pFoundScope = NULL;

    do
    {
        *ppibNew = NULL;
        *pdwBlkSize = 0;
        *pdwCount = 0;

        //
        // Verify scope info.
        //

        if ( ( g_ipGrpAddr & g_ipGrpMask ) != g_ipGrpAddr
         || ntohl(g_ipGrpAddr) < MIN_SCOPE_ADDR
         || ntohl(g_ipGrpAddr) > MAX_SCOPE_ADDR)
        {
            dwRes = ERROR_INVALID_PARAMETER;
            break;
        }

        // Make sure mask is contiguous
        if (!IsContiguous(g_ipGrpMask))
        {
            char buff[20], *lpstr;

            lpstr = inet_ntoa( *((struct in_addr *) &g_ipGrpMask));

            if (lpstr != NULL)
            {
                strcpy( buff, lpstr );
                DisplayMessage( g_hModule,  MSG_IP_BAD_IP_MASK, buff );
            }
            break;
        }

        //
        // Find if specified scope is present
        //

        pScopes = GetScopesFromInfo( pib, &ulNumScopes );

        if ( pScopes )
        {
            pFoundScope = FindScopeByPrefix( g_ipGrpAddr,
                                             g_ipGrpMask,
                                             pScopes,
                                             ulNumScopes
                                           );
        }

        //
        // Update the scope infoblock.
        //

        switch ( dwAction )
        {

        case ADD_SCOPE:

            //
            // If scope is not present, add it. Else return error.
            //

            if ( !pFoundScope )
            {
                dwRes = AddScope( &pScopes, &ulNumScopes, ppibNew, &dwSize );

                if ( dwRes == NO_ERROR )
                {
                    *pdwBlkSize = dwSize;

                    *pdwCount = 1;
                }

                break;
            }
            // else fall through into SET_SCOPE.

        case SET_SCOPE:

            //
            // if scope present, update it.
            //

            if ( pFoundScope )
            {
                dwRes = UpdateScope( pFoundScope,
                                     pScopes,
                                     ulNumScopes,
                                     ppibNew,
                                     &dwSize );

                if ( dwRes == NO_ERROR )
                {
                    *pdwBlkSize = dwSize;

                    *pdwCount = 1;
                }
            }
            else
            {
                dwRes = ERROR_INVALID_PARAMETER;
            }

            break;

        case DELETE_SCOPE:

            //
            // Delete scope only if present.
            //

            if ( pFoundScope )
            {
                dwRes = DeleteScope( pFoundScope, 
                                     pScopes, 
                                     &ulNumScopes,
                                     ppibNew, 
                                     &dwSize );

                if ( dwRes == NO_ERROR )
                {
                    *pdwBlkSize = dwSize;

                    *pdwCount = (dwSize>0)? 1 : 0;
                }
            }
            else
            {
                dwRes = ERROR_INVALID_PARAMETER;
            }

            break;
        }

    } while ( FALSE );

    if (pScopes)
        FREE( pScopes );

    return dwRes;
}

DWORD
VerifyBoundaryPrefix(
    IPV4_ADDRESS ipAddr,
    IPV4_ADDRESS ipMask
    )
{
    WCHAR                   wstr1[20], wstr2[20];

    //
    // Verify boundary info.
    //

    if (ntohl(ipAddr) < MIN_SCOPE_ADDR
     || ntohl(ipAddr) > MAX_SCOPE_ADDR)
    {
        MakeAddressStringW(wstr1, htonl(MIN_SCOPE_ADDR));
        MakeAddressStringW(wstr2, htonl(MAX_SCOPE_ADDR));

        DisplayMessage( g_hModule, 
                        EMSG_INVALID_ADDR, 
                        wstr1, 
                        wstr2 );

        return ERROR_INVALID_PARAMETER;
    }

    if ( ( ipAddr & ipMask ) != ipAddr )
    {
        DisplayMessage( g_hModule, EMSG_PREFIX_ERROR );

        return ERROR_INVALID_PARAMETER;
    }

    // Make sure mask is contiguous
    if (!IsContiguous(ipMask))
    {
        char buff[20], *lpstr;

        lpstr = inet_ntoa( *((struct in_addr *) &g_ipGrpMask));

        if (lpstr != NULL)
        {
            strcpy( buff, lpstr );
            DisplayMessage( g_hModule,  MSG_IP_BAD_IP_MASK, buff );
        }

        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

DWORD
IpAddSetDelScope( 
    DWORD     dwAction,
    PWCHAR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_GROUP_ADDRESS,FALSE,FALSE},
                             {TOKEN_GROUP_MASK,    FALSE,FALSE},
                             {TOKEN_SCOPE_NAME,    FALSE,FALSE}};
    SCOPE_NAME_BUFFER snScopeName;
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    IPV4_ADDRESS ipGroup, ipMask;
    DWORD        dwBlkSize, dwCount, i, dwNumParsed;
    PBYTE        pib, pibNew = NULL;
    DWORD        dwArgsReqd = (dwAction is DELETE_SCOPE)? 1 : 3;
    PWCHAR       p;    

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              dwArgsReqd,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              rgdwTagType );

    if (dwErr) 
    {
        return dwErr;
    }

    g_ipGrpAddr = g_ipGrpMask = 0;

    for(i = 0; i < dwArgCount - dwCurrentIndex; i ++)
    {
        switch (rgdwTagType[i])
        {
            case 1: // GRPMASK
            {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &g_ipGrpMask);

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[rgdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    return NO_ERROR;
                }

                break;
            }

            case 0: // GRPADDR
            {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &g_ipGrpAddr,
                                    &g_ipGrpMask);

                if (!((dwErr is ERROR_INVALID_PARAMETER)
                      && (dwAction is DELETE_SCOPE)))
                {
                    break;
                }

                // FALLTHROUGH
            }


            case 2 : // SCOPENAME
            {
                // Strip leading and trailing whitespace
                for (p = ppwcArguments[i + dwCurrentIndex]; iswspace(*p); p++);
                while (iswspace( p[wcslen(p) - 1] ))
                {
                    p[ wcslen(p)-1 ] = 0;
                }

                if (wcslen(p) > MAX_SCOPE_NAME_LEN)
                {
                    DisplayMessage( g_hModule, 
                                    EMSG_SCOPE_NAME_TOO_LONG,
                                    MAX_SCOPE_NAME_LEN );

                    return NO_ERROR;
                }

                sn_strcpy( snScopeName, p);
                g_snScopeName = snScopeName;

                if (dwAction is DELETE_SCOPE)
                {
                    dwErr = ScopeNameToPrefix(snScopeName,
                                              &g_ipGrpAddr,
                                              &g_ipGrpMask);

                    if (dwErr is ERROR_MORE_DATA)
                    {
                        DisplayMessage( g_hModule,  EMSG_AMBIGUOUS_SCOPE_NAME,
                                        ppwcArguments[i + dwCurrentIndex]);

                        return NO_ERROR;
                    }
                }

                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if (!g_ipGrpAddr || !g_ipGrpMask)
    {
        return ERROR_INVALID_SYNTAX;
    }

    dwErr = VerifyBoundaryPrefix(g_ipGrpAddr, g_ipGrpMask);

    if (dwErr)
    {
        return NO_ERROR;
    }

    do {

        dwErr = IpmontrGetInfoBlockFromGlobalInfo( IP_MCAST_BOUNDARY_INFO,
                                            &pib,
                                            &dwBlkSize,
                                            &dwCount );

        if (dwErr is ERROR_NOT_FOUND)
        {
            //
            // No info of this type is currently present
            //
     
            dwErr = NO_ERROR;
            dwCount = 1;
        }

        if (dwErr isnot NO_ERROR)
            break;

        dwErr = UpdateScopeBlock( dwAction,
                                  pib, 
                                  &pibNew, 
                                  &dwBlkSize, 
                                  &dwCount );

        if (dwErr isnot NO_ERROR)
            break;

        dwErr = IpmontrSetInfoBlockInGlobalInfo( IP_MCAST_BOUNDARY_INFO,
                                          pibNew,
                                          dwBlkSize,
                                          dwCount );

    } while (FALSE);

    if (pib)
        HeapFree(GetProcessHeap(), 0 , pib);

    if (pibNew)
        HeapFree(GetProcessHeap(), 0 , pibNew);

    return dwErr;
}

DWORD
HandleIpAddScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetDelScope( ADD_SCOPE,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
HandleIpDelScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetDelScope( DELETE_SCOPE,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
HandleIpSetScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetDelScope( SET_SCOPE,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}


DWORD
ShowScopes(
    IN HANDLE  hFile
    )
{
    DWORD                   dwRes        = (DWORD) -1,
                            dwCnt        = 0,
                            dwInd        = 0,
                            dwGlobalSize = 0;

    ULONG                   ulNumScopes    = 0;

    CHAR                    szAddr1[ ADDR_LENGTH ],
                            szAddr2[ ADDR_LENGTH ];

    PSCOPE_ENTRY            pScope,
                            pScopes;

    HANDLE                  hTransport    = (HANDLE) NULL;

    PBYTE                   pScopesBuffer;

    SCOPE_NAME_BUFFER       snScopeNameBuffer;

    do
    {
        pScopes = GetScopes( &ulNumScopes, &pScopesBuffer );

        if (hFile is NULL)
        {
            if (ulNumScopes)
            {
                DisplayMessage( g_hModule, MSG_RTR_SCOPE_HDR );
            }
            else
            {
                DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
            }
        }

        //
        // Enumerate the scopes
        //

        for ( dwCnt = 0; dwCnt < ulNumScopes; dwCnt++ )
        {
            pScope = &pScopes[dwCnt];

            strcpy(
                    szAddr1,
                    inet_ntoa( *((struct in_addr *) &pScope->ipGroupAddress) )
                  );

            strcpy(
                    szAddr2,
                    inet_ntoa( *((struct in_addr *) &pScope->ipGroupMask) )
                  );

            MakePrefixStringW(snScopeNameBuffer,
                              pScope->ipGroupAddress,
                              pScope->ipGroupMask);

            if (hFile)
            {
                PWCHAR pwszQuoted = MakeQuotedString( (pScope->ulNumNames)? 
                    pScope->snScopeNameBuffer : snScopeNameBuffer );

                DisplayMessageT( DMP_SCOPE_INFO,
                                 szAddr1,
                                 szAddr2,
                                 pwszQuoted );

                FreeQuotedString(pwszQuoted);
            }
            else
            {
                DisplayMessage( g_hModule,
                    MSG_RTR_SCOPE_INFO,
                    szAddr1,
                    szAddr2,
                    (pScope->ulNumNames)? pScope->snScopeNameBuffer 
                                        : snScopeNameBuffer );
            }
        }

        dwRes = NO_ERROR;

        if (pScopes)
            FREE(pScopes);

        if (pScopesBuffer)
            FREE(pScopesBuffer);

    } while ( FALSE );

    return dwRes;
}

DWORD
HandleIpShowScope(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return ShowScopes(0);
}





DWORD
DeleteBoundary(
   IN     DWORD  dwDelInd,
   IN     PBYTE  pib,
   OUT    PBYTE *ppibNew,
   IN OUT DWORD *pdwCount
   )
/*++
Description:
    Creates a new info block header which does not include the
    boundary with the specified index.
    Caller is responsible for freeing buffer returned.
Called by:
    UpdateBoundaryBlock()
--*/
{
    DWORD                   dwInd   = 0,
                            dwCnt   = 0,
                            dwCnt0  = 0,
                            dwSize  = 0,
                            dwRes   = NO_ERROR;

    LPBYTE                  pbDst   = (LPBYTE) NULL,
                            pbSrc   = (LPBYTE) NULL;

    PRTR_INFO_BLOCK_HEADER  pibh    = (PRTR_INFO_BLOCK_HEADER) NULL;

    PMIB_BOUNDARYROW      pimbSrc  = (PMIB_BOUNDARYROW) NULL;
    PMIB_BOUNDARYROW      pimbDst  = (PMIB_BOUNDARYROW) NULL;

    //
    // Create new info block with boundary removed.
    //

    dwSize = (*pdwCount - 1) * sizeof( MIB_BOUNDARYROW );

    if (dwSize is 0) 
    {
        *ppibNew = NULL;

        *pdwCount = 0;

        return NO_ERROR;
    }

    *ppibNew = MALLOC( dwSize );

    if ( *ppibNew == NULL )
    {
        DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy boundaries, skip boundary to be deleted
    //

    pimbDst = (PMIB_BOUNDARYROW) *ppibNew;
    pimbSrc = (PMIB_BOUNDARYROW) pib;

    for ( dwCnt = 0, dwCnt0 = 0;
          dwCnt < *pdwCount;
          dwCnt++ )
    {
        if ( dwCnt == dwDelInd )
        {
            continue;
        }

        pimbDst[ dwCnt0 ] = pimbSrc[ dwCnt ];
        dwCnt0++;
    }

    (*pdwCount)--;

    return NO_ERROR;
}

DWORD
AddBoundary (
   IN     PBYTE  pib,
   OUT    PBYTE *ppibNew,
   IN OUT DWORD *pdwCount
   )
/*++
Description:
   Creates a new info block which includes a boundary for the
   scope identified by g_ipGrpAddr/g_ipGrpMask.
   Caller is responsible for freeing buffer returned.
Called by:
   UpdateBoundaryBlock()
--*/
{
    DWORD                   dwRes     = NO_ERROR,
                            dwInd     = 0,
                            dwSize    = 0;

    LPBYTE                  pbDst     = (LPBYTE) NULL,
                            pbSrc     = (LPBYTE) NULL;

    PMIB_BOUNDARYROW        pimb      = (PMIB_BOUNDARYROW ) NULL;

    dwRes = VerifyBoundaryPrefix(g_ipGrpAddr, g_ipGrpMask);

    if (dwRes)
    {
        return NO_ERROR;
    }

    do
    {
        *ppibNew = NULL;

        //
        // If this is the first boundary, create info block
        // with an extra TocEntry.
        //

        dwSize = (*pdwCount + 1) * sizeof( MIB_BOUNDARYROW );

        *ppibNew = MALLOC( dwSize );

        if ( *ppibNew == NULL )
        {
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pbDst = *ppibNew;

        CopyMemory( pbDst, pib, (*pdwCount) * sizeof(MIB_BOUNDARYROW) );

        pbDst += (*pdwCount) * sizeof(MIB_BOUNDARYROW);

        (*pdwCount)++;

        pimb = (PMIB_BOUNDARYROW) pbDst;
        pimb-> dwGroupAddress = g_ipGrpAddr;
        pimb-> dwGroupMask    = g_ipGrpMask;

        pbDst += sizeof( MIB_BOUNDARYROW );

    } while ( FALSE );

    return dwRes;
}

BOOL
IsBoundaryPresent(
   IN  IPV4_ADDRESS        ipGroupAddress,
   IN  IPV4_ADDRESS        ipGroupMask,
   IN  PMIB_BOUNDARYROW    pimb,
   IN  DWORD               dwNumBoundaries,
   OUT PDWORD              pdwInd
   )
/*++
Returns:
   TRUE if present, and sets dwInd to index
   FALSE if not present, and sets dwInd to -1
Called by:
   UpdateBoundaryBlock()
--*/
{
    DWORD       dwInd = 0;

    *pdwInd = (DWORD) -1;

    for ( dwInd = 0; dwInd < dwNumBoundaries; dwInd++, pimb++ )
    {
        if ( pimb-> dwGroupAddress != ipGroupAddress
          || pimb-> dwGroupMask    != ipGroupMask )
        {
            continue;
        }

        *pdwInd = dwInd;
        return TRUE;
    }

    return FALSE;
}

DWORD
UpdateBoundaryBlock( 
    IN     DWORD  dwAction,
    IN     PBYTE  pib,
    OUT    PBYTE *ppibNew,
    IN OUT DWORD *pdwBlkSize,
    IN OUT DWORD *pdwCount,
    OUT    BOOL  *pbChanged
    )
/*++
Description:
    Caller is responsible for freeing buffer returned.
Called by:
    IpAddDelBoundary(), DeleteBoundaryFromInterface()
--*/
{
    DWORD                   dwRes           = NO_ERROR,
                            dwInd           = 0,
                            dwInd0          = 0;

    BOOL                    bBoFound        = FALSE;

    PMIB_BOUNDARYROW        pimb            = (PMIB_BOUNDARYROW) NULL;

    *pbChanged = FALSE;

    do
    {
        *ppibNew = NULL;

        //
        // Find if specified boundary is present
        //

        bBoFound = IsBoundaryPresent( g_ipGrpAddr,
                                      g_ipGrpMask,
                                      (PMIB_BOUNDARYROW)pib,
                                      *pdwCount,
                                      &dwInd0 );

        //
        // Update the boundary infoblock.
        //

        switch ( dwAction )
        {

        case ADD_BOUNDARY:

            //
            // If boundary is not present, add it. Else return error.
            //

            if ( !bBoFound )
            {
                dwRes = AddBoundary( pib, ppibNew, pdwCount );

                *pdwBlkSize = sizeof(MIB_BOUNDARYROW);

                *pbChanged = TRUE;
            }
            else
            {
                dwRes = ERROR_OBJECT_ALREADY_EXISTS;
            }
            break;

        case DELETE_BOUNDARY:

            //
            // Delete boundary only if present.
            //

            if ( bBoFound )
            {
                dwRes = DeleteBoundary( dwInd0, pib, ppibNew, pdwCount );

                *pbChanged = TRUE;
            }

            // If not present, return success but don't set the changed flag.

            break;
        }

    } while ( FALSE );

    return dwRes;
}


DWORD
IpAddDelBoundary(
    DWORD     dwAction,
    PWCHAR   *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount
    )
{
    DWORD        dwErr;
    TAG_TYPE     pttTags[] = {{TOKEN_NAME,          TRUE, FALSE},
                              {TOKEN_GROUP_ADDRESS, FALSE,FALSE},
                              {TOKEN_GROUP_MASK,    FALSE,FALSE},
                              {TOKEN_SCOPE_NAME,    FALSE,FALSE},
                             };
    WCHAR        rgwcIfName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    IPV4_ADDRESS ipGroup, ipMask;
    DWORD        dwBlkSize, dwCount, dwIfType, i, dwNumParsed;
    PBYTE        pib, pibNew = NULL;
    BOOL         bChanged; 

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              2,
                              3,
                              rgdwTagType );

    if (dwErr) 
    {
        return dwErr;
    }

    g_ipGrpAddr = g_ipGrpMask = 0;

    for(i = 0; i < dwArgCount - dwCurrentIndex; i ++)
    {
        switch (rgdwTagType[i])
        {
            case 0 : // NAME
            {
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 rgwcIfName,
                                 sizeof(rgwcIfName),
                                 &dwNumParsed);

                break;
            }

            case 1: // GRPADDR
            {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &g_ipGrpAddr,
                                    &g_ipGrpMask);

                if (!((dwErr is ERROR_INVALID_PARAMETER)
                      && (dwAction is DELETE_BOUNDARY)))
                {
                    break;
                }

                // FALLTHROUGH
            }

            case 3: // SCOPENAME
            {
                dwErr = ScopeNameToPrefix( ppwcArguments[i + dwCurrentIndex],
                                           &g_ipGrpAddr,
                                           &g_ipGrpMask );

                if (dwErr is ERROR_MORE_DATA)
                {
                    DisplayMessage( g_hModule,  EMSG_AMBIGUOUS_SCOPE_NAME,
                                    ppwcArguments[i + dwCurrentIndex]);

                    return NO_ERROR;
                }

                break;
            }

            case 2: // GRPMASK
            {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &g_ipGrpMask);

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[rgdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    return NO_ERROR;
                }

                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if (!g_ipGrpAddr || !g_ipGrpMask)
    {
        return ERROR_INVALID_SYNTAX;
    }

    do {

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo( rgwcIfName,
                                               IP_MCAST_BOUNDARY_INFO,
                                               &pib,
                                               &dwBlkSize,
                                               &dwCount,
                                               &dwIfType );

        if (dwErr is ERROR_NOT_FOUND)
        {
            //
            // No info of this type is currently present
            //
     
            dwErr = NO_ERROR;
            dwCount = 0;
        }

        if (dwErr isnot NO_ERROR)
            break;

        dwErr = UpdateBoundaryBlock( dwAction,
                                     pib, 
                                     &pibNew, 
                                     &dwBlkSize, 
                                     &dwCount,
                                     &bChanged );

        if (dwErr isnot NO_ERROR)
            break;

        if (bChanged)
        {
            dwErr = IpmontrSetInfoBlockInInterfaceInfo( rgwcIfName,
                                                 IP_MCAST_BOUNDARY_INFO,
                                                 pibNew,
                                                 dwBlkSize,
                                                 dwCount );
        }

    } while (FALSE);

    if (pib)
        FREE(pib);

    if (pibNew)
        FREE(pibNew);

    return dwErr;
}

DWORD
HandleIpAddBoundary(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddDelBoundary( ADD_BOUNDARY,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
HandleIpDelBoundary(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddDelBoundary( DELETE_BOUNDARY,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount );
}

DWORD
ShowBoundaryInfoForInterface(
    IN  HANDLE  hFile,
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwNumRows
    )
/*++
Called by:
   ShowBoundaryInfo()
--*/
{
    DWORD                   dwErr,
                            dwBlkSize,
                            dwCount,
                            dwIfType,
                            dwNumParsed,
                            dwInd          = 0,
                            dwCnt          = 0,
                            dwSize         = 0,
                            dwGlobalSize   = 0,
                            dwIfLen        = 0;

    WCHAR                   wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];

    ULONG                   ulNumScopes    = 0;

    CHAR                    szAddr1[ ADDR_LENGTH ],
                            szAddr2[ ADDR_LENGTH ];

    HANDLE                  hIfTransport   = (HANDLE) NULL,
                            hTransport     = (HANDLE) NULL;

    PRTR_INFO_BLOCK_HEADER  pibhIfInfo     = (PRTR_INFO_BLOCK_HEADER) NULL,
                            pibhGlobalInfo = (PRTR_INFO_BLOCK_HEADER) NULL;

    PMIB_BOUNDARYROW        pimb;

    PSCOPE_ENTRY            pScope,
                            pScopes;

    PBYTE                   pScopesBuffer;

    SCOPE_NAME_BUFFER       snScopeNameBuffer;

    do
    {
        dwErr = IpmontrGetInfoBlockFromInterfaceInfo( pwszIfName,
                                               IP_MCAST_BOUNDARY_INFO,
                                               (PBYTE*)&pimb,
                                               &dwBlkSize,
                                               &dwCount,
                                               &dwIfType );

        if (dwErr is ERROR_NOT_FOUND)
            dwErr = NO_ERROR;

        if (dwErr isnot NO_ERROR)
            return dwErr;

        if ( !dwCount )
            break;

        dwErr = GetInterfaceDescription(pwszIfName,
                                        wszIfDesc,
                                        &dwNumParsed);

        if (!dwNumParsed)
        {
            wcscpy(wszIfDesc, pwszIfName);
        }

        dwIfLen = wcslen(wszIfDesc);

        //
        // Retrieve the list of scopes in pScopes[]
        //

        pScopes = GetScopes( &ulNumScopes, &pScopesBuffer );

        //
        // Enumerate the boundaries
        //

        for ( dwCnt = 0; dwCnt < dwCount; dwCnt++ )
        {
            pScope = FindScopeByPrefix( pimb[dwCnt].dwGroupAddress,
                                        pimb[dwCnt].dwGroupMask,
                                        pScopes,
                                        ulNumScopes );

            strcpy( szAddr1,
                    inet_ntoa( *((struct in_addr *) &pimb[dwCnt].dwGroupAddress)
)
                  );

            strcpy( szAddr2,
                    inet_ntoa( *((struct in_addr *) &pimb[dwCnt].dwGroupMask) )
                  );

            // Copy prefix to snScopeNameBuffer

            MakePrefixStringW(snScopeNameBuffer,
                              pimb[dwCnt].dwGroupAddress,
                              pimb[dwCnt].dwGroupMask);

            if (hFile)
            {
                PWCHAR pwszQuoted = MakeQuotedString(wszIfDesc);

                DisplayMessageT( DMP_BOUNDARY_INFO,
                    pwszQuoted,
                    szAddr1,
                    szAddr2,
                    (pScope && pScope->ulNumNames)? 
                       pScope->snScopeNameBuffer : snScopeNameBuffer );

                FreeQuotedString(pwszQuoted);
            }
            else
            {
                if ( !*pdwNumRows )
                {
                    DisplayMessage( g_hModule, MSG_RTR_BOUNDARY_HDR );
                }

                if (dwIfLen <= 15) 
                {
                    DisplayMessage( g_hModule,
                        MSG_RTR_BOUNDARY_INFO_2,
                        wszIfDesc,
                        szAddr1,
                        szAddr2,
                        (pScope && pScope->ulNumNames)? 
                           pScope->snScopeNameBuffer : snScopeNameBuffer );
                }
                else
                {
                    DisplayMessage( g_hModule,
                        MSG_RTR_BOUNDARY_INFO_0,
                        wszIfDesc
                    );
                    DisplayMessage( g_hModule,
                        MSG_RTR_BOUNDARY_INFO_1,
                        szAddr1,
                        szAddr2,
                        (pScope && pScope->ulNumNames)? 
                            pScope->snScopeNameBuffer : snScopeNameBuffer );
                }
            }

            (*pdwNumRows) ++;
        }

        dwErr = NO_ERROR;

        if (pScopes)
            FREE(pScopes);

        if (pScopesBuffer)
            FREE(pScopesBuffer);

    } while ( FALSE );

    if ( pimb ) { FREE(pimb); }

    return dwErr;
}

DWORD
HandleIpShowBoundary(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/
{
    DWORD        dwErr, dwTotal;
    TAG_TYPE     pttTags[] = {{TOKEN_NAME,FALSE,FALSE}};
    WCHAR        rgwcIfName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD        dwBlkSize, dwCount, dwIfType, i, dwNumParsed;
    PBYTE        pib, pibNew = NULL;
    PMPR_INTERFACE_0     pmi0;
    DWORD        dwNumRows = 0;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              1,
                              rgdwTagType );

    if (dwErr) 
    {
        return dwErr;
    }

    // If interface specified, show boundaries for specified interface only.

    if (dwArgCount > dwCurrentIndex) {

        GetInterfaceName( ppwcArguments[dwCurrentIndex],
                          rgwcIfName,
                          sizeof(rgwcIfName),
                          &dwNumParsed );

        dwErr = ShowBoundaryInfoForInterface( 0, rgwcIfName, &dwNumRows );

        if (!dwNumRows)
        {
            DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
        }

        return dwErr;
    }

    // No Interface specified.  Enumerate interfaces and show
    // boundaries for each interface.

    //
    // No interface name specified. List all interfaces under IP
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    for ( i = 0; i < dwCount && dwErr is NO_ERROR; i++)
    {
        dwErr = ShowBoundaryInfoForInterface( 0, 
                                              pmi0[i].wszInterfaceName, 
                                              &dwNumRows );

        if (dwErr is ERROR_NO_SUCH_INTERFACE)
        {
            dwErr = NO_ERROR;
        }
    }

    if (!dwNumRows)
    {
        DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
    }

    return dwErr;
}

//----------------------------------------------------------------------------
// PrintScope   
//
//
//----------------------------------------------------------------------------

static VOID
PrintScope(
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastAddr,
    PDWORD                      pdwLastMask
)
{
    TCHAR                       ptszAddr[ ADDR_LENGTH + 1 ],
                                ptszMask[ ADDR_LENGTH + 1 ],
                                ptszBuffer[ MAX_SCOPE_NAME_LEN + 40 ];
                    
    PMIB_IPMCAST_SCOPE          pmims;

    //
    // get scope
    //
    
    pmims = (PMIB_IPMCAST_SCOPE) prpcInfo->rgbyData;
    
    *pdwLastAddr = pmims-> dwGroupAddress;
    
    MakeUnicodeIpAddr(ptszAddr,
        inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupAddress))));

    *pdwLastMask = pmims-> dwGroupMask;
    
    MakeUnicodeIpAddr(ptszMask,
                      inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupMask))));

    _stprintf(ptszBuffer, _T("%-15.15s  %-15.15s  %s"), 
        ptszAddr, 
        ptszMask,
        pmims-> snNameBuffer
        );

    DisplayMessage( g_hModule,
        MSG_MIB_SCOPE_INFO,
        ptszBuffer
        );
        
    return;
}

//----------------------------------------------------------------------------
// PrintBoundary
//
//
//----------------------------------------------------------------------------

static VOID
PrintBoundary(
    MIB_SERVER_HANDLE           hMibServer,
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastIfIndex,
    PDWORD                      pdwLastAddr,
    PDWORD                      pdwLastMask
)
{
    WCHAR   wszBuffer[MAX_INTERFACE_NAME_LEN+1];
    TCHAR                       ptszAddr[ ADDR_LENGTH + 1 ],
                                ptszMask[ ADDR_LENGTH + 1 ];
                    
    PMIB_IPMCAST_BOUNDARY       pmims;

    //
    // get boundary
    //
    
    pmims = (PMIB_IPMCAST_BOUNDARY) prpcInfo->rgbyData;
    
    *pdwLastIfIndex = pmims-> dwIfIndex;
     
    *pdwLastAddr = pmims-> dwGroupAddress;
    
    MakeUnicodeIpAddr(ptszAddr,
        inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupAddress))));

    *pdwLastMask = pmims-> dwGroupMask;
    
    MakeUnicodeIpAddr(ptszMask,
                      inet_ntoa(*((struct in_addr *)(&pmims-> dwGroupMask))));

    IpmontrGetFriendlyNameFromIfIndex( hMibServer,
                                pmims->dwIfIndex,
                                wszBuffer,
                                sizeof(wszBuffer) );

    DisplayMessageToConsole( g_hModule, g_hConsole,
        MSG_MIB_BOUNDARY_INFO,
        ptszAddr, 
        ptszMask,
        wszBuffer
        );
        
    return;
}

#if 0
//----------------------------------------------------------------------------
// GetPrintScopeInfo
//
//----------------------------------------------------------------------------

DWORD
GetPrintScopeInfo(
    MIB_SERVER_HANDLE hMIBServer
    )
{
    DWORD                       dwErr, dwOutEntrySize = 0, dwQuerySize,
                                dwLastAddr = 0, 
                                dwLastMask = 0, i;
    
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;

    PMIB_IPMCAST_SCOPE          pmims = NULL;

    PMIB_OPAQUE_QUERY           pQuery;
    
    do
    {
        //
        // allocate and setup query structure
        //
        
        dwQuerySize = sizeof( MIB_OPAQUE_QUERY ) + sizeof(DWORD);
        
        pQuery = (PMIB_OPAQUE_QUERY) HeapAlloc(
                                        GetProcessHeap(), 0, dwQuerySize
                                        );
        
        if ( pQuery == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DisplayMessage( g_hModule, ERROR_CONFIG, dwErr );

            break;
        }

        
        pQuery->dwVarId = MCAST_SCOPE;
        
        for( i = 0; i < 2; i++ )
        {
            pQuery->rgdwVarIndex[i] = 0;
        }

        
        //
        // get first scope
        //

        dwErr = MibGetFirst(
                    PID_IP,
                    IPRTRMGR_PID,
                    (PVOID) pQuery,
                    dwQuerySize,
                    (PVOID *) &pRpcInfo,
                    &dwOutEntrySize
                    );

        if ( dwErr != NO_ERROR )
        {
            DisplayError( g_hModule, dwErr );
            break;
        }

        
        //
        // if no scopes are present print a message to tell the user
        //

        pmims = (PMIB_IPMCAST_SCOPE)( pRpcInfo->rgbyData );

#if 0
        if ( pTable->dwNumEntries is 0 )
        {
            //
            // no scopes present.
            //

            DisplayMessage( g_hModule, MSG_MIB_NO_SCOPES );

            break;
        }
#endif


        //
        // print the scope
        //

        DisplayMessage( g_hModule, MSG_MIB_SCOPE_HDR );

        PrintScope( pRpcInfo, &dwLastAddr, &dwLastMask );

        MprAdminMIBBufferFree( pRpcInfo );

        pRpcInfo = NULL;

        dwOutEntrySize = 0;


        //
        // while there are more scopes
        //  get next scope
        //  print it.
        //

        pQuery->rgdwVarIndex[ 0 ] = dwLastAddr;
        pQuery->rgdwVarIndex[ 1 ] = dwLastMask;

        while ( ( dwErr = MibGetNext(
                            PID_IP, IPRTRMGR_PID, (PVOID) pQuery,
                            dwQuerySize, (PVOID *) &pRpcInfo, &dwOutEntrySize
                            ) ) == NO_ERROR )
        {
            //
            // if no scopes are present quit
            //

            pmims = (PMIB_IPMCAST_SCOPE)( pRpcInfo->rgbyData );
#if 0
            pTable = (PMIB_IPMCAST_SCOPE)( pRpcInfo->rgbyData );

            if ( pTable->dwNumEntries is 0 )
            {
                break;
            }
#endif


            //
            // print the scope
            //

            PrintScope( pRpcInfo, &dwLastAddr, &dwLastMask );

            MprAdminMIBBufferFree( pRpcInfo );

            pRpcInfo = NULL;

            dwOutEntrySize = 0;


            //
            // set up the next query
            //
            
            pQuery->rgdwVarIndex[ 0 ] = dwLastAddr;
            pQuery->rgdwVarIndex[ 1 ] = dwLastMask;
        }

        if ( dwErr != NO_ERROR )
        {
            DisplayMessage( g_hModule, ERROR_ADMIN, dwErr );
        }
        
    } while ( FALSE );

    return dwErr;
}
#endif

//----------------------------------------------------------------------------
// GetPrintBoundaryInfo
//
//----------------------------------------------------------------------------

DWORD
GetPrintBoundaryInfo(
    MIB_SERVER_HANDLE hMIBServer
    )
{
    DWORD                       dwErr, dwOutEntrySize = 0, dwQuerySize,
                                dwLastIfIndex = 0, dwLastAddr = 0, 
                                dwLastMask = 0, i;
    
    PMIB_OPAQUE_INFO            pRpcInfo = NULL;

    PMIB_IPMCAST_BOUNDARY       pmims = NULL;

    PMIB_OPAQUE_QUERY           pQuery;
    
    do
    {
        //
        // allocate and setup query structure
        //
        
        dwQuerySize = sizeof( MIB_OPAQUE_QUERY ) + 2 * sizeof(DWORD);
        
        pQuery = (PMIB_OPAQUE_QUERY) HeapAlloc(
                                        GetProcessHeap(), 0, dwQuerySize
                                        );
        
        if ( pQuery == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DisplayMessage( g_hModule, ERROR_CONFIG, dwErr );

            break;
        }

        
        pQuery->dwVarId = MCAST_BOUNDARY;
        
        for( i = 0; i < 2; i++ )
        {
            pQuery->rgdwVarIndex[i] = 0;
        }

        
        //
        // get first boundary
        //

        dwErr = MibGetFirst(
                    PID_IP,
                    IPRTRMGR_PID,
                    (PVOID) pQuery,
                    dwQuerySize,
                    (PVOID *) &pRpcInfo,
                    &dwOutEntrySize
                    );

        if ( dwErr != NO_ERROR )
        {
            DisplayError( g_hModule, dwErr );
            break;
        }

        
        //
        // if no boundaries are present print a message to tell the user
        //

        pmims = (PMIB_IPMCAST_BOUNDARY)( pRpcInfo->rgbyData );

#if 0
        if ( pTable->dwNumEntries is 0 )
        {
            //
            // no boundaries present.
            //

            DisplayMessage( g_hModule, MSG_MIB_NO_BOUNDARIES );

            break;
        }
#endif


        //
        // print the boundary
        //

        DisplayMessageToConsole( g_hModule, g_hConsole, MSG_MIB_BOUNDARY_HDR );

        PrintBoundary( hMIBServer,
                       pRpcInfo, &dwLastIfIndex, &dwLastAddr, &dwLastMask );

        MprAdminMIBBufferFree( pRpcInfo );

        pRpcInfo = NULL;

        dwOutEntrySize = 0;


        //
        // while there are more boundaries
        //  get next boundary
        //  print it.
        //

        pQuery->rgdwVarIndex[ 0 ] = dwLastIfIndex;
        pQuery->rgdwVarIndex[ 1 ] = dwLastAddr;
        pQuery->rgdwVarIndex[ 2 ] = dwLastMask;

        while ( ( dwErr = MibGetNext(
                            PID_IP, IPRTRMGR_PID, (PVOID) pQuery,
                            dwQuerySize, (PVOID *) &pRpcInfo, &dwOutEntrySize
                            ) ) == NO_ERROR )
        {
            //
            // if no boundaries are present quit
            //

            pmims = (PMIB_IPMCAST_BOUNDARY)( pRpcInfo->rgbyData );
#if 0
            pTable = (PMIB_IPMCAST_BOUNDARY)( pRpcInfo->rgbyData );

            if ( pTable->dwNumEntries is 0 )
            {
                break;
            }
#endif


            //
            // print the boundary
            //

            PrintBoundary( 
                hMIBServer,
                pRpcInfo, &dwLastIfIndex, &dwLastAddr, &dwLastMask 
                );

            MprAdminMIBBufferFree( pRpcInfo );

            pRpcInfo = NULL;

            dwOutEntrySize = 0;


            //
            // set up the next query
            //
            
            pQuery->rgdwVarIndex[ 0 ] = dwLastIfIndex;
            pQuery->rgdwVarIndex[ 1 ] = dwLastAddr;
            pQuery->rgdwVarIndex[ 2 ] = dwLastMask;
        }

        if ( dwErr != NO_ERROR )
        {
            DisplayMessage( g_hModule, ERROR_ADMIN, dwErr );
        }
        
    } while ( FALSE );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\if\utils.h ===
#define ADDR_LENGTH          24

//
// Misc macros
//
#define IfutlDispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

#define BREAK_ON_DWERR(x) if ((x) != NO_ERROR) break;

// 
// Macros for dealing with IFMON_CMD_ARGS
//
#define IFMON_CMD_ARG_GetPsz(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.pszValue : NULL)

#define IFMON_CMD_ARG_GetDword(pArg)     \
    (((pArg)->rgTag.bPresent) ? (pArg)->Val.dwValue : 0)

//
// Enumerations for types of arguments (see RASMON_CMD_ARG)
//
#define IFMON_CMD_TYPE_STRING 0x1
#define IFMON_CMD_TYPE_ENUM   0x2



#define CHECK_UNICAST_IP_ADDR(Addr) \
    (((DWORD)((Addr) & 0x000000E0) >= (DWORD)0x000000E0) or \
    ((DWORD)((Addr) & 0x000000FF) == (DWORD)0x0000007F) or \
    ((Addr) == 0))


BOOL
CheckMask(
    DWORD Mask
    );


#define CHECK_NETWORK_MASK(Mask) \
    (CheckMask(Mask) || (Mask==0xFFFFFFFF) || (Mask==0))

// 
// Structure defining a command line argument
//
typedef struct _IFMON_CMD_ARG
{
    IN  DWORD dwType;           // RASMONTR_CMD_TYPE_*
    IN  TAG_TYPE rgTag;         // The tag for this command
    IN  TOKEN_VALUE* rgEnums;   // The enumerations for this arg
    IN  DWORD dwEnumCount;      // Count of enums
    union
    {
        OUT PWCHAR pszValue;        // Valid only for RASMONTR_CMD_TYPE_STRING
        OUT DWORD dwValue;          // Valid only for RASMONTR_CMD_TYPE_ENUM
    } Val;        
    
} IFMON_CMD_ARG, *PIFMON_CMD_ARG;

DWORD
IfutlGetTagToken(
    IN  HANDLE      hModule,
    IN  PWCHAR      *ppwcArguments,
    IN  DWORD       dwCurrentIndex,
    IN  DWORD       dwArgCount,
    IN  PTAG_TYPE   pttTagToken,
    IN  DWORD       dwNumTags,
    OUT PDWORD      pdwOut
    );

VOID
IfutlGetInterfaceName(
    IN  PWCHAR pwszIfDesc,
    OUT PWCHAR pwszIfName,
    IN  PDWORD pdwSize
    );

VOID
IfutlGetInterfaceDescription(
    IN  PWCHAR pwszIfName,
    OUT PWCHAR pwszIfDesc,
    IN  PDWORD pdwSize
    );

PVOID 
WINAPI
IfutlAlloc(
    IN DWORD dwBytes,
    IN BOOL bZero
    );

VOID 
WINAPI
IfutlFree(
    IN PVOID pvData
    );

PWCHAR
WINAPI
IfutlStrDup(
    IN LPCWSTR pwszSrc
    );
    
DWORD
IfutlParse(
    IN  PWCHAR*         ppwcArguments,
    IN  DWORD           dwCurrentIndex,
    IN  DWORD           dwArgCount,
    IN  BOOL*           pbDone,
    OUT IFMON_CMD_ARG*  pIfArgs,
    IN  DWORD           dwIfArgCount);

BOOL
IfutlIsRouterRunning(
    VOID
    );
   
DWORD
GetIpAddress(
    PWCHAR        ppwcArg,
    PIPV4_ADDRESS ipAddress
    );

DWORD
IfutlGetIfIndexFromInterfaceName(
    IN  PWCHAR            pwszGuid,
    OUT PDWORD            pdwIfIndex
    );


DWORD
WINAPI
InterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    );

DWORD
IfutlGetIfIndexFromFriendlyName(
    PWCHAR IfFriendlyName,
    PULONG pdwIfIndex
    );

VOID
MakeAddressStringW(
    OUT PWCHAR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    );

DWORD
IfutlGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT PWCHAR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\filter.c ===
#include "precomp.h"

DWORD
UpdateFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragCheck
    )

/*++

Routine Description:

    Updates fragcheck variable

Arguments:

    pwszIfName - Interface Name
    bFragCheck - enabled or disabled
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD              dwBlkSize, dwCount, dwErr = NO_ERROR;
    PIFFILTER_INFO     pfi     = NULL;
    IFFILTER_INFO      Info;
    DWORD              dwIfType;

    do
    {
        //
        // Make sure that the input or output filter blocks are present
        //

        if ((IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                           IP_IN_FILTER_INFO,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL) != NO_ERROR) &&
            (IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                           IP_OUT_FILTER_INFO,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL) != NO_ERROR))
        {
            dwErr = ERROR_INVALID_PARAMETER;

            DisplayMessage(g_hModule,  MSG_IP_NO_FILTER_FOR_FRAG);

            break;
        }            
            
        //
        // Get the IP_IFFILTER_INFO block from router config/router
        //

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              IP_IFFILTER_INFO,
                                              (PBYTE *) &pfi,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwErr is NO_ERROR)
        {
            pfi->bEnableFragChk = bFragCheck;

            dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                                IP_IFFILTER_INFO,
                                                (PBYTE) pfi,
                                                dwBlkSize,
                                                dwCount);

            break;
        }

        if (dwErr isnot ERROR_NOT_FOUND)
        {
            break;
        }

        Info.bEnableFragChk = bFragCheck;

        dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                            IP_IFFILTER_INFO,
                                            (PBYTE) &Info,
                                            sizeof(IFFILTER_INFO),
                                            1);

    } while (FALSE);

    if (pfi)
    {
        HeapFree(GetProcessHeap(), 0, pfi);
    }

    switch(dwErr)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        case ERROR_INVALID_PARAMETER:
            break;
            
        default:
            DisplayError(g_hModule,
                         dwErr);
            break;
    }

    return dwErr;
}

DWORD
SetFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragChk
    )

/*++

Routine Description:

    Updates fragcheck info in router and router config

Arguments:

    pwszIfName - Interface Name
    bFragCheck - enabled or disabled
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD    dwErr;

    dwErr = UpdateFragCheckInfo(pwszIfName, bFragChk);

    return dwErr;
}

DWORD
SetFilterInfo(
    IN    LPCWSTR   pwszIfName,
    IN    DWORD     dwFilterType,
    IN    DWORD     dwAction
    )

/*++

Routine Description:

    Sets filter info

Arguments:

    pwszIfName   - interface name
    dwFilterType - Filter type (input, output or dial)
    dwAction     - drop or forward 
    
Return Value:

    ERROR_OKAY
    
--*/

{
    PFILTER_DESCRIPTOR      pfd = (PFILTER_DESCRIPTOR) NULL;
    FILTER_DESCRIPTOR       Info;
    DWORD                   dwRes = NO_ERROR;
    DWORD                   dwBlkSize, dwIfType, dwCount;
    BOOL                    bFree;

    bFree = FALSE;
 
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              dwFilterType,
                                              (PBYTE *) &pfd,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);
        
        if (dwRes != NO_ERROR)
        {
            Info.dwVersion          = IP_FILTER_DRIVER_VERSION;
            Info.dwNumFilters       = 0;
            Info.faDefaultAction    = (PFFORWARD_ACTION) dwAction;

            dwCount     = 1;
            dwBlkSize   = FIELD_OFFSET(FILTER_DESCRIPTOR, fiFilter[0]);

            pfd         = &Info;

            bFree       = FALSE;
        }
        else
        {
            pfd->faDefaultAction = (PFFORWARD_ACTION) dwAction;

            bFree = TRUE;
        }

        dwRes = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                            dwFilterType,
                                            (PBYTE) pfd,
                                            dwBlkSize,
                                            dwCount);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }

    } while (FALSE);

    if (bFree)
    {
        HeapFree(GetProcessHeap(), 0, pfd);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            dwRes = ERROR_OKAY;
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_FILTER_INFO);
            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }

    return dwRes;
}



DWORD
AddDelFilterInfo(
    IN    FILTER_INFO    fi,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwFilterType,
    IN    BOOL           bAdd
    )

/*++

Routine Description:

    Adds/deletes interface filters

Arguments:

    fi            -  Filter info
    pwszIfName    -  Interface Name
    dwFilterType  -  FilterType
    bAdd          -  To add or not 
    
Return Value:

    ERROR_OKAY
    
--*/

{
    DWORD                 dwRes = (DWORD) -1;
    PFILTER_DESCRIPTOR    pfd = NULL, pfdNew = NULL;
    DWORD                 dwIfType, dwBlkSize, dwNewSize, dwCount;

    
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              dwFilterType,
                                              (PBYTE *) &pfd,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwRes is ERROR_NOT_FOUND && bAdd)
        {
            //
            // No filter info of this type is currently present
            //
            
            pfd = NULL;
            dwRes = NO_ERROR;
            dwCount = 1;
        }
        
        if (dwRes isnot NO_ERROR)
        {
            break;
        }
        
        dwRes = (bAdd) ? AddNewFilter(pfd, fi, dwBlkSize, &pfdNew, &dwNewSize):
                DeleteFilter(pfd, fi, dwBlkSize, &pfdNew, &dwNewSize);
            
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        dwRes = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                            dwFilterType,
                                            (PBYTE) pfdNew,
                                            dwNewSize,
                                            dwCount);

        if (dwRes isnot NO_ERROR)
        {
            break;
        }
        
        if (pfd)
        {
            HeapFree(GetProcessHeap(), 0 , pfd);
            pfd = NULL;
        }
        
        HeapFree(GetProcessHeap(), 0 , pfdNew);
        pfdNew = NULL;
        
        DEBUG("Made Changes to Route config");

    } while ( FALSE );

    if (pfd)
    {
        HeapFree(GetProcessHeap(), 0, pfd);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            dwRes = ERROR_OKAY;
            break;

        case ERROR_NOT_FOUND :
            DisplayMessage(g_hModule, EMSG_IP_NO_FILTER_INFO);
            break;
            
        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}

DWORD
AddNewFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize, 
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    )

/*++

Routine Description:

    Adds interface filter

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    DWORD                   dwNumFilt = 0, dwSize = 0, dwInd = 0;
    DWORD                   dwRes = (DWORD) -1;
    PFILTER_DESCRIPTOR      pfdSrc = (PFILTER_DESCRIPTOR) NULL;
    PFILTER_DESCRIPTOR      pfdDst = (PFILTER_DESCRIPTOR) NULL;

    pfdSrc = pfd;
    
    do
    {
        //
        // If filter info block was found, check if the filter being added 
        // is already present.  If it is quit and return ok
        //

        if ( pfdSrc )
        {
            if ( IsFilterPresent( pfdSrc, fi, &dwInd ) )
            {
                dwRes = ERROR_OBJECT_ALREADY_EXISTS;

                break;
            }

            //
            // We can be left with a FILTER_DESCRIPTOR with no filters if
            // the added filters have all been deleted.  Once a 
            // FILTER_DESCRIPTOR has been added, it is never deleted even
            // if all the filters in it have been.
            //
            
            dwSize = dwBlkSize + sizeof(FILTER_INFO);

            dwNumFilt = pfdSrc-> dwNumFilters;
        }
        
        else
        {
            dwNumFilt = 0;
            
            dwSize = sizeof( FILTER_DESCRIPTOR );
        }

        //
        // Create new info block 
        //
        
        pfdDst = HeapAlloc(GetProcessHeap(), 
                           0, 
                           dwSize);
        
        if ( pfdDst is NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (pfdSrc)
        {
            //
            // Copy info blocks as is.
            //
        
            CopyMemory(pfdDst, pfdSrc, dwSize);
        }
        else
        {
            //
            // if new filter info block has to be added set up the
            // FILTER_DESCRIPTOR 
            //

            pfdDst-> dwVersion           = IP_FILTER_DRIVER_VERSION;
            pfdDst-> faDefaultAction     = PF_ACTION_FORWARD;
            pfdDst-> dwNumFilters        = 0;
        }

        //
        // Append new filter
        //
        
        pfdDst-> fiFilter[ dwNumFilt ].dwSrcAddr     = fi.dwSrcAddr;
        pfdDst-> fiFilter[ dwNumFilt ].dwSrcMask     = fi.dwSrcMask;
        pfdDst-> fiFilter[ dwNumFilt ].dwDstAddr     = fi.dwDstAddr;
        pfdDst-> fiFilter[ dwNumFilt ].dwDstMask     = fi.dwDstMask;
        pfdDst-> fiFilter[ dwNumFilt ].dwProtocol    = fi.dwProtocol;

        pfdDst-> fiFilter[ dwNumFilt ].fLateBound    = fi.fLateBound;
        // !@# check when tcp established

        pfdDst-> fiFilter[ dwNumFilt ].wSrcPort  = fi.wSrcPort;
        pfdDst-> fiFilter[ dwNumFilt ].wDstPort  = fi.wDstPort;

        pfdDst-> dwNumFilters++;
        
        *ppfd = pfdDst;

        *pdwSize = dwSize;
        
        dwRes = NO_ERROR;
        
    } while ( FALSE );

    return dwRes;
}


DWORD
DeleteFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize,
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    )

/*++

Routine Description:

    Deletes interface filter

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    
    DWORD                   dwRes = NO_ERROR, dwSize = 0, dwNumFilt = 0;
    DWORD                   dwInd = 0, dwSrc = 0, dwDst = 0;
    PFILTER_DESCRIPTOR      pfdSrc      = (PFILTER_DESCRIPTOR) NULL,
                            pfdDst      = (PFILTER_DESCRIPTOR) NULL; 

    
    do
    {
    
        pfdSrc = pfd;

        //
        // if no filter information was found or
        // the specified filter was not found quit.
        //
        
        if ( !pfdSrc )
        {
            dwRes = ERROR_NOT_FOUND;
            break;
        }

        if ( !IsFilterPresent( pfdSrc, fi, &dwInd ) )
        {
            dwRes = ERROR_NOT_FOUND;
            break;
        }

        //
        // delete the filter info. for the specified filter.
        //
        
        dwSize      = dwBlkSize - sizeof( FILTER_INFO );

        dwNumFilt   = pfdSrc-> dwNumFilters - 1;
                   
        pfdDst = HeapAlloc( GetProcessHeap( ), 0, dwSize );
                   
        if ( pfdDst == NULL )
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pfdDst-> dwVersion              = pfdSrc-> dwVersion;
        pfdDst-> dwNumFilters           = pfdSrc-> dwNumFilters - 1;
        pfdDst-> faDefaultAction        = pfdSrc-> faDefaultAction;
        
        //
        // copy each filter, skipping over the filter to be deleted.
        //
                
        for ( dwSrc = 0, dwDst = 0; 
              dwSrc < pfdSrc-> dwNumFilters;
              dwSrc++
            )
        {
            if ( dwSrc == dwInd )
            {
                continue;
            }
            
            pfdDst-> fiFilter[ dwDst ] = pfdSrc-> fiFilter[ dwSrc ];
            
            dwDst++;                          
         }

        *ppfd = pfdDst;

        *pdwSize = dwSize;
         
    } while( FALSE );

    return dwRes;
}


BOOL
IsFilterPresent(
    PFILTER_DESCRIPTOR pfd,
    FILTER_INFO        fi,
    PDWORD pdwInd
    )

/*++

Routine Description:

    Checks to see if filter is already present

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    DWORD   dwInd   = 0;

    for ( dwInd = 0; dwInd < pfd-> dwNumFilters; dwInd++ )
    {
        if ( pfd-> fiFilter[ dwInd ].dwSrcAddr != fi.dwSrcAddr ||
             pfd-> fiFilter[ dwInd ].dwSrcMask != fi.dwSrcMask ||
             pfd-> fiFilter[ dwInd ].dwDstAddr != fi.dwDstAddr ||
             pfd-> fiFilter[ dwInd ].dwDstMask != fi.dwDstMask ||
             pfd-> fiFilter[ dwInd ].dwProtocol != fi.dwProtocol )
        {
            continue;
        }

        switch ( fi.dwProtocol )
        {
        case FILTER_PROTO_TCP:
            // compare tcp and tcp established
            if (IsTcpEstablished(&pfd-> fiFilter[ dwInd ]) !=
                IsTcpEstablished(&fi))
            {
                continue;
            }
            // fall through...
            
        case FILTER_PROTO_UDP:
        case FILTER_PROTO_ICMP:
            if ( ( pfd-> fiFilter[ dwInd ].wSrcPort == fi.wSrcPort ) &&
                 ( pfd-> fiFilter[ dwInd ].wDstPort == fi.wDstPort ) )
            {
                *pdwInd = dwInd;
                return TRUE;
            }

            break;

        case FILTER_PROTO_ANY:
            *pdwInd = dwInd;
            return TRUE;

        default:
            *pdwInd = dwInd;
            return TRUE;

        }            
    }

    return FALSE;
}

DWORD
DisplayFilters(
    HANDLE                  hFile,
    PFILTER_DESCRIPTOR      pfd,
    PWCHAR                  pwszIfName,
    PWCHAR                  pwszQuotedIfName,
    DWORD                   dwFilterType
    )

/*++

Routine Description:

    Displays filter information.

Arguments:

    pfd           - Filter to be displayed
    pwszIfName    - Interface name
    dwFilterType  - Filter Type (input , output , dial)
    
Return Value:

    NO_ERROR
    
--*/

{

    DWORD       dwCnt           = 0,
                dwInd           = 0,
                dwRes;

    PWCHAR      pwszType        = (PTCHAR) NULL,
                pwszAction      = (PTCHAR) NULL,
                pwszProtocol    = (PTCHAR) NULL;

    WCHAR       wszSrcAddr[ ADDR_LENGTH + 1 ],
                wszSrcMask[ ADDR_LENGTH + 1 ],
                wszDstAddr[ ADDR_LENGTH + 1 ],
                wszDstMask[ ADDR_LENGTH + 1 ],
                wszProtoNum[24];

    BYTE        *pbyAddr;
    BOOL        bDontFree;


    //
    // Display header
    //

    switch(dwFilterType)
    {
        case IP_IN_FILTER_INFO:
        {
            pwszType = MakeString(g_hModule,  STRING_INPUT );

            break;
        }

        case IP_OUT_FILTER_INFO:
        {
            pwszType = MakeString(g_hModule,  STRING_OUTPUT );

            break;
        }
        case IP_DEMAND_DIAL_FILTER_INFO:
        {
            pwszType = MakeString(g_hModule,  STRING_DIAL );

            break;
        }
    }

    if ( pfd-> faDefaultAction == PF_ACTION_DROP )
    {
        pwszAction  = MakeString(g_hModule,  STRING_DROP );
    }
    else
    {
        pwszAction  = MakeString(g_hModule,  STRING_FORWARD );
    }

    if(pfd->dwNumFilters ||
       (pfd->faDefaultAction == PF_ACTION_DROP))
    {
        if(hFile != NULL)
        {
            DisplayMessageT( DMP_IP_SET_IF_FILTER,
                        pwszQuotedIfName,
                        pwszType,
                        pwszAction);
        }
        else
        {
            DisplayMessage(g_hModule, MSG_RTR_FILTER_HDR,
                           pwszType, 
                           pwszAction);
        }
    }
    
    //
    // Enumerate Filters
    //

    bDontFree = FALSE;

    for ( dwInd = 0;
          dwInd < pfd-> dwNumFilters;
          dwInd++ )
    {
        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwSrcAddr);
        IP_TO_WSTR(wszSrcAddr, pbyAddr);

        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwSrcMask);
        IP_TO_WSTR(wszSrcMask, pbyAddr);

        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwDstAddr);
        IP_TO_WSTR(wszDstAddr, pbyAddr);

        pbyAddr = (PBYTE) &(pfd-> fiFilter[ dwInd ].dwDstMask);
        IP_TO_WSTR(wszDstMask, pbyAddr);

        switch( pfd-> fiFilter[ dwInd ].dwProtocol )
        {
            case FILTER_PROTO_TCP:
                if (IsTcpEstablished(&pfd-> fiFilter[ dwInd ]))
                {
                    pwszProtocol = MakeString(g_hModule,  STRING_TCP_ESTAB );
                }
                else
                {
                    pwszProtocol = MakeString(g_hModule,  STRING_TCP );
                }

                break;

            case FILTER_PROTO_UDP:
                pwszProtocol = MakeString(g_hModule,  STRING_UDP );
                break;
    
            case FILTER_PROTO_ICMP:
                pwszProtocol = MakeString(g_hModule,  STRING_ICMP );
                break;

            case FILTER_PROTO_ANY:
                pwszProtocol = MakeString(g_hModule,  STRING_PROTO_ANY );
                break;

            default:
                wsprintf(wszProtoNum,
                         L"%d",
                         pfd-> fiFilter[ dwInd ].dwProtocol);

                pwszProtocol = wszProtoNum;

                bDontFree = TRUE;

                break;
        }

        if(hFile != NULL)
        {
            DisplayMessageT( DMP_IP_ADD_IF_FILTER,
                        pwszQuotedIfName,                
                        pwszType,
                        wszSrcAddr,
                        wszSrcMask,
                        wszDstAddr,
                        wszDstMask,
                        pwszProtocol);

            if((pfd-> fiFilter[dwInd].dwProtocol == FILTER_PROTO_TCP) ||
               (pfd-> fiFilter[dwInd].dwProtocol == FILTER_PROTO_UDP))
            {
                DisplayMessageT( DMP_IP_ADD_IF_FILTER_PORT,
                            ntohs(pfd->fiFilter[dwInd].wSrcPort),
                            ntohs(pfd->fiFilter[dwInd].wDstPort)); 
            }

            if(pfd-> fiFilter[dwInd].dwProtocol == FILTER_PROTO_ICMP)
            {
                DisplayMessageT( DMP_IP_ADD_IF_FILTER_TC,
                            pfd->fiFilter[dwInd].wSrcPort,
                            pfd->fiFilter[dwInd].wDstPort);
            }
        }
        else
        {
            if ( pfd-> fiFilter[ dwInd ].dwProtocol == FILTER_PROTO_ICMP )
            {
                DisplayMessage(g_hModule, 
                               MSG_RTR_FILTER_INFO,
                               wszSrcAddr,
                               wszSrcMask,
                               wszDstAddr,
                               wszDstMask,
                               pwszProtocol,
                               pfd->fiFilter[ dwInd ].wSrcPort,
                               pfd->fiFilter[ dwInd ].wDstPort);
            }
            else
            {
                DisplayMessage(g_hModule, 
                               MSG_RTR_FILTER_INFO,
                               wszSrcAddr,
                               wszSrcMask,
                               wszDstAddr,
                               wszDstMask,
                               pwszProtocol,
                               ntohs(pfd->fiFilter[dwInd].wSrcPort),
                               ntohs(pfd->fiFilter[dwInd].wDstPort));
            }
        }
   
        if(!bDontFree)
        {
             FreeString(pwszProtocol); 
        }
    }

    FreeString(pwszType);

    FreeString(pwszAction);

    return NO_ERROR;
}

DWORD
ShowIpIfFilter(
    IN    HANDLE    hFile,
    IN    DWORD     dwFormat,
    IN    LPCWSTR   pwszIfName,
    IN OUT PDWORD   pdwNumRows
    )

/*++

Routine Description:

    Gets filter information for the interface and displays it.

Arguments:

     pwszIfName - Interface name
     
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                 dwErr, dwBlkSize, dwCount, dwIfType, i;
    PFILTER_DESCRIPTOR    pfd[3];
    DWORD                 pdwType[] = { IP_IN_FILTER_INFO,
                                        IP_OUT_FILTER_INFO,
                                        IP_DEMAND_DIAL_FILTER_INFO };
    WCHAR                 wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PIFFILTER_INFO        pFragInfo = NULL;
    DWORD                 dwNumParsed = 0;
    PWCHAR                pwszFrag, pwszTokenFrag, pwszQuoted;


    for ( i = 0 ; i < 3; i++)
    {
        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              pdwType[i],
                                              (PBYTE *) &(pfd[i]),
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_NO_SUCH_INTERFACE)
            {
                // DisplayMessage(g_hModule, MSG_NO_INTERFACE, pwszIfName);
                return dwErr;
            }

            pfd[i] = NULL;
        }
    }

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                          IP_IFFILTER_INFO,
                                          (PBYTE *) &pFragInfo,
                                          &dwBlkSize,
                                          &dwCount,
                                          &dwIfType);


    if (dwErr isnot NO_ERROR)
    {
        pFragInfo = NULL;
    }
    
    
    dwErr = GetInterfaceDescription(pwszIfName,
                                    wszIfDesc,
                                    &dwNumParsed);

    if (!dwNumParsed)
    {
        wcscpy(wszIfDesc, pwszIfName);
    }

    pwszQuoted = MakeQuotedString(wszIfDesc);

    pwszFrag = NULL;
 
    if((pFragInfo is NULL) || 
       (pFragInfo->bEnableFragChk is FALSE))
    {
        pwszFrag      = MakeString(g_hModule, STRING_DISABLED);
        pwszTokenFrag = TOKEN_VALUE_DISABLE;
    }
    else
    {
        pwszFrag      = MakeString(g_hModule, STRING_ENABLED);
        pwszTokenFrag = TOKEN_VALUE_ENABLE;
    }

    //
    // First lets handle the table case
    //

    if(dwFormat is FORMAT_TABLE)
    {
        DWORD   dwInput, dwOutput, dwDemand;
        PWCHAR  pwszDrop, pwszForward;

        pwszDrop    = MakeString(g_hModule,  STRING_DROP);
        pwszForward = MakeString(g_hModule,  STRING_FORWARD);

        dwInput  = (pfd[0] is NULL) ? 0 : pfd[0]->dwNumFilters;
        dwOutput = (pfd[1] is NULL) ? 0 : pfd[1]->dwNumFilters;
        dwDemand = (pfd[2] is NULL) ? 0 : pfd[2]->dwNumFilters;


        if(*pdwNumRows is 0)
        {
            DisplayMessage(g_hModule, MSG_RTR_FILTER_HDR2);
        }

#define __PF_ACT(x) \
    ((((x) is NULL) || ((x)->faDefaultAction is PF_ACTION_FORWARD)) ? \
     pwszForward : pwszDrop)
 
        DisplayMessage(g_hModule, 
                       MSG_RTR_FILTER_INFO2,
                       dwInput,
                       __PF_ACT(pfd[0]),
                       dwOutput,
                       __PF_ACT(pfd[1]),
                       dwDemand,
                       __PF_ACT(pfd[2]),
                       pwszFrag,
                       wszIfDesc);

#undef __PF_ACT

        (*pdwNumRows)++;

        return NO_ERROR;
    }


    if(hFile == NULL)
    {
        DisplayMessage(g_hModule, MSG_RTR_FILTER_HDR1, wszIfDesc);

        //
        // Can display the frag check status before displaying filters
        //

        DisplayMessage(g_hModule, MSG_IP_FRAG_CHECK,
                       pwszFrag);
    }

    FreeString(pwszFrag);

    if ( pfd[0] == (PFILTER_DESCRIPTOR) NULL )
    {
        if(hFile == NULL)
        {
            DisplayMessage(g_hModule,  MSG_IP_NO_INPUT_FILTER);
        }
    }
    else
    {
        DisplayFilters(hFile,
                       pfd[0], 
                       wszIfDesc,
                       pwszQuoted, 
                       IP_IN_FILTER_INFO);

        (*pdwNumRows)++;
    }

    if ( pfd[1] == (PFILTER_DESCRIPTOR) NULL )
    {
        if(hFile == NULL)
        {
            DisplayMessage(g_hModule,  MSG_IP_NO_OUTPUT_FILTER);
        }
    }
    else
    {
        DisplayFilters(hFile,
                       pfd[1], 
                       wszIfDesc, 
                       pwszQuoted,
                       IP_OUT_FILTER_INFO);

        (*pdwNumRows)++;
    }

    if(pfd[2] == (PFILTER_DESCRIPTOR) NULL)
    {
        if(hFile == NULL)
        {
            DisplayMessage(g_hModule, MSG_IP_NO_DIAL_FILTER);
        }
    }
    else
    {
        DisplayFilters(hFile,
                       pfd[2], 
                       wszIfDesc, 
                       pwszQuoted,
                       IP_DEMAND_DIAL_FILTER_INFO);

        (*pdwNumRows)++;
    }

    for (i = 0; i < 3 ; i++)
    {
        if (pfd[i])
        {
            HeapFree(GetProcessHeap(), 0, pfd[i]);
        }
    }

    if(hFile != NULL)
    {
        DisplayMessageT( DMP_IP_SET_IF_FILTER_FRAG,
                    pwszQuoted,
                    pwszTokenFrag);
    }

    if(pFragInfo)
    {
        HeapFree(GetProcessHeap(), 0, pFragInfo);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\info.h ===
typedef struct _TRANSPORT_INFO
{
    PRTR_INFO_BLOCK_HEADER    pibhInfo;
    BOOL                      bValid;
}TRANSPORT_INFO,*PTRANSPORT_INFO;

typedef struct _INTERFACE_STORE
{
    LIST_ENTRY                le;
    PWCHAR                    pwszIfName;
    PRTR_INFO_BLOCK_HEADER    pibhInfo;
    DWORD                     dwIfType;
    BOOL                      bValid;
}INTERFACE_STORE,*PINTERFACE_STORE;

extern LIST_ENTRY           g_leIfListHead;
extern TRANSPORT_INFO       g_tiTransport;


#define FREE_BUFFER(pibh)               \
{                                       \
    HeapFree(GetProcessHeap(),          \
             0,                         \
             pibh);                     \
    pibh = NULL;                        \
}

DWORD
ValidateInterfaceInfo(
    IN  LPCWSTR                 pwszIfName,
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo,   OPTIONAL
    OUT PDWORD                  pdwIfType,  OPTIONAL
    OUT INTERFACE_STORE         **ppIfStore OPTIONAL
    );

DWORD
ValidateGlobalInfo(
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo
    );

DWORD
GetGlobalInfo(
    OUT  RTR_INFO_BLOCK_HEADER  **ppibhInfo
    );

DWORD
SetGlobalInfo(
    IN  PRTR_INFO_BLOCK_HEADER  pibhInfo
    );

DWORD
GetInterfaceInfo(
    IN     LPCWSTR                 pwszIfName,
    OUT    PRTR_INFO_BLOCK_HEADER  *ppibhInfo,
    IN     PMPR_INTERFACE_0        pMprIf0,
    OUT    PDWORD                  pdwIfType
    );

DWORD
SetInterfaceInfo(
    IN    PRTR_INFO_BLOCK_HEADER    pibhInfo,
    IN    LPCWSTR                   pwszIfName
    );

DWORD
AddInterfaceInfo(
    IN    LPCWSTR                   pwszIfName
    );

DWORD
DeleteInterfaceInfo(
    IN    LPCWSTR                   pwszIfName
    );

DWORD
WINAPI
IpCommit(
    IN  DWORD   dwAction
    );

DWORD
CreateInterface(
    IN  LPCWSTR pwszFriendlyName,
    IN  LPCWSTR pwszGuidName,
    IN  DWORD   dwIfType,
    IN  BOOL    bCreateRouterIf
    );

#define IFCLASS_LOOPBACK  1
#define IFCLASS_P2P       2
#define IFCLASS_BROADCAST 3
#define IFCLASS_NBMA      4

DWORD
GetInterfaceClass(
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwIfClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\filter.h ===
DWORD
UpdateFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragCheck
    );


DWORD
SetFragCheckInfo(
    IN    LPCWSTR pwszIfName,
    IN    BOOL    bFragChk
    );

DWORD
SetFilterInfo(
    IN    LPCWSTR   pwszIfName,
    IN    DWORD     dwFilterType,
    IN    DWORD     dwAction
    );

DWORD
AddDelFilterInfo(
    IN    FILTER_INFO    fi,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwFilterType,
    IN    BOOL           bAdd
    );

DWORD
AddNewFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize, 
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    );

DWORD
DeleteFilter( 
    IN    PFILTER_DESCRIPTOR    pfd,
    IN    FILTER_INFO           fi,
    IN    DWORD                 dwBlkSize,
    OUT   PFILTER_DESCRIPTOR    *ppfd,
    OUT   PDWORD                pdwSize
    );

BOOL
IsFilterPresent(
    PFILTER_DESCRIPTOR pfd,
    FILTER_INFO        fi,
    PDWORD pdwInd
    );

DWORD
DisplayFilters(
    HANDLE                  hFile,
    PFILTER_DESCRIPTOR      pfd,
    PWCHAR                  pwszIfName,
    PWCHAR                  pwszQuotedIfName,
    DWORD                   dwFilterType
    );

DWORD
ShowIpIfFilter(
    IN     HANDLE   hFile,
    IN     DWORD    dwFormat,
    IN     LPCWSTR  pwszIfName,
    IN OUT PDWORD   pdwNumRows
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\ipcfg.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\ipcfg.h

Abstract:

    ProtoTypes for fns in ipcfg.c

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

DWORD
AddProtocolInfo(
    IN    LPCWSTR           pwszIfName,
    IN    DWORD             dwRoutingProtId,
    IN    BOOL              bInterface
    );

DWORD
DeleteProtocolInfo(
    IN    LPCWSTR           pwszIfName,
    IN    DWORD             dwRoutingProtId,
    IN    BOOL              bInterface
    );

DWORD
MakeIpRipGlobalInfo(
    OUT      PBYTE                   *ppbStart,
    OUT      PDWORD                  pdwSize
    );

DWORD
MakeIpRipInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                   *ppbStart,
    OUT     PDWORD                  pdwSize
    );

DWORD
MakeIpOspfGlobalInfo(
    OUT      PBYTE                   *ppbStart,
    OUT      PDWORD                   pdwSize
    );
DWORD
MakeIpOspfInterfaceInfo(
    IN      ROUTER_INTERFACE_TYPE   rifType,
    OUT     PBYTE                   *ppbStart,
    OUT     PDWORD                  pdwSize
    );

DWORD 
MakeProtocolBlock(
    DWORD                   dwProtId,
    BOOL                    bGlobal,
    DWORD                   dwIfType,
    PBYTE                   *ppbBlk,
    PDWORD                  pdwSize
    );

DWORD
AddDeleteRoutePrefLevel ( 
    IN    PPROTOCOL_METRIC    ppm,
    IN    DWORD               dwNumProto,
    IN    BOOL                bAdd
    );

DWORD
AddNewRoutePrefToBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize
    );

DWORD
DeleteRoutePrefFromBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize  
    );

DWORD
SetRoutePrefLevel ( 
    IN    PROTOCOL_METRIC    pm
    );

DWORD
UpdateRtrPriority(
    IN    PPRIORITY_INFO            ppi,
    IN    PROTOCOL_METRIC           pm
    );

DWORD
SetGlobalConfigInfo(
    IN    DWORD    dwLoggingLevel
    );

DWORD
ShowRoutePref(
    HANDLE  hFile   OPTIONAL
    );

DWORD
ShowIpProtocol(
    VOID 
    );

DWORD
ShowIpGlobal(
    IN HANDLE hFile OPTIONAL
    );

DWORD
ListIpInterface(
    VOID
    );

DWORD
ShowIpInterface(
    IN  DWORD     dwFormat,
    IN  LPCWSTR   pwszIfName,
    IN OUT PDWORD pdwNumRows
    );

#define FORMAT_TABLE       1
#define FORMAT_VERBOSE     2
#define FORMAT_DUMP        3

DWORD
UpdateInterfaceStatusInfo(
    IN    DWORD          dwAction,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwStatus
    );

DWORD
CreateDumpFile(
    IN  LPCWSTR  pwszName,
    OUT PHANDLE  phFile
    );

VOID
DumpIpInformation(
    HANDLE  hFile
    );

VOID
CloseDumpFile(
    HANDLE  hFile
    );

DWORD
UpdateAutoStaticRoutes(
    IN  LPCWSTR  pwszIfName
    );

PWCHAR
GetProtoProtoString(
    IN  DWORD  dwProtoType,
    IN  DWORD  dwProtoVendor,
    IN  DWORD  dwProtoProto
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\info.c ===
#include "precomp.h"

WCHAR   g_wszRtrMgrDLL[]    = L"%SystemRoot%\\system32\\IPRTRMGR.DLL";
DWORD   g_dwIfState         = MIB_IF_ADMIN_STATUS_UP;
BOOL    g_bDiscEnable       = FALSE;

#define IP_KEY L"Ip"

#undef EXTRA_DEBUG

DWORD
ValidateInterfaceInfo(
    IN  LPCWSTR                 pwszIfName,
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo,   OPTIONAL
    OUT PDWORD                  pdwIfType,  OPTIONAL
    OUT INTERFACE_STORE         **ppIfStore OPTIONAL
    )
{
    PRTR_INFO_BLOCK_HEADER    pOldInfo = NULL;
    DWORD                     dwErr, dwIfType, dwTmpSize;
    BOOL                      bFound = FALSE;
    LIST_ENTRY                *ple;
    PINTERFACE_STORE           pii;

    if(ppInfo)
    {
        *ppInfo = NULL;
    }

    if(ppIfStore)
    {
        *ppIfStore  = NULL;
    }
   
    //
    // If the current mode is commit, get info from config/router
    //

    if(g_bCommit)
    {
        dwErr = GetInterfaceInfo(pwszIfName,
                                 ppInfo,
                                 NULL,
                                 pdwIfType);

        return dwErr;
    }

    //
    // Uncommit mode. Try to find the interface in the list
    //
    
    bFound = FALSE;
    
    for(ple = g_leIfListHead.Flink;
        ple != &g_leIfListHead;
        ple = ple->Flink)
    {
        pii = CONTAINING_RECORD(ple, INTERFACE_STORE, le);
        
        if (_wcsicmp(pii->pwszIfName, pwszIfName) == 0)
        {
            bFound = TRUE;
            
            break;
        }
    }
    
    if(!bFound ||
       !pii->bValid)
    {
        //
        // the required one was not found, or it was not valid
        // Need to get the info for both cases
        //
        
        dwErr = GetInterfaceInfo(pwszIfName,
                                 &pOldInfo,
                                 NULL,
                                 &dwIfType);
        
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }
    }
    
    if(bFound)
    {
        if(!pii->bValid)
        {
            //
            // Update
            //
            
            pii->pibhInfo   = pOldInfo;
            pii->bValid     = TRUE;
            pii->dwIfType   = dwIfType;
        }
    }
    else
    {
        //
        // No entry for the interface in the list.
        //
        
        pii = HeapAlloc(GetProcessHeap(),
                        0,
                        sizeof(INTERFACE_STORE));
        
        if(pii == NULL)
        {
            FREE_BUFFER(pOldInfo);
            
            DisplayMessage(g_hModule,  MSG_IP_NOT_ENOUGH_MEMORY );
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        pii->pwszIfName =
            HeapAlloc(GetProcessHeap(),
                      0,
                      (wcslen(pwszIfName) + 1) * sizeof(WCHAR));
        
        if(pii->pwszIfName == NULL)
        {
            FREE_BUFFER(pOldInfo);
            
            HeapFree(GetProcessHeap(),
                     0,
                     pii);
            
            DisplayMessage(g_hModule,  MSG_IP_NOT_ENOUGH_MEMORY );
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        InsertHeadList(&g_leIfListHead, &(pii->le));
        
        wcscpy(pii->pwszIfName, pwszIfName);
        
        pii->pibhInfo   = pOldInfo;
        pii->bValid     = TRUE;
        pii->dwIfType   = dwIfType;
    }

    if(ppIfStore)
    {
        *ppIfStore = pii;
    }

    if(pdwIfType)
    {
        *pdwIfType = pii->dwIfType;
    }

    if(ppInfo)
    {
        *ppInfo = pii->pibhInfo;
    }

    return NO_ERROR;
}

DWORD
ValidateGlobalInfo(
    OUT RTR_INFO_BLOCK_HEADER   **ppInfo
    )
{
    DWORD                     dwErr;
    
    //
    // If the current mode is commit, get info from config/router
    //

    if(g_bCommit)
    {
        dwErr = GetGlobalInfo(ppInfo);

        return dwErr;
    }

    //
    // Uncommit mode. Check if the info in g_tiTransport is valid
    //
    
    if(g_tiTransport.bValid)
    {
        *ppInfo = g_tiTransport.pibhInfo;
    }
    else
    {   
        //
        // Get the info from config/router and store in g_tiTransport
        // Mark the info to be valid.
        //
        
        dwErr = GetGlobalInfo(ppInfo);
        
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }

        g_tiTransport.pibhInfo = *ppInfo;
        g_tiTransport.bValid   = TRUE;
    }

    return NO_ERROR;
}


DWORD
GetGlobalInfo(
    OUT PRTR_INFO_BLOCK_HEADER  *ppibhInfo
    )

/*++

Routine Description:

    Gets global transport information from registry or router.

Arguments:

    bMprConfig  - Info from Registry or info from router
    ppibhInfo   - ptr to header
    
Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_ROUTER_STOPPED
    
--*/

{

    HANDLE    hTransport = (HANDLE) NULL;
    DWORD     dwRes, dwSize;
    PRTR_INFO_BLOCK_HEADER  pibhInfo = (PRTR_INFO_BLOCK_HEADER ) NULL;
   
    if(ppibhInfo == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        if (IsRouterRunning())
        {
            //
            // Retrieve global protocol information from router
            //

            dwRes = MprAdminTransportGetInfo(g_hMprAdmin,
                                             PID_IP,
                                             (LPBYTE*) &pibhInfo,
                                             &dwSize,
                                             NULL,
                                             NULL);

            if ( dwRes != NO_ERROR )
            {
                break;
            }
            
            if ( pibhInfo == (PRTR_INFO_BLOCK_HEADER) NULL )
            {
                dwRes = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // unfortunately, the memory allocation mechanisms 
            // are different between the apis that access the registry
            // and those that access that the running router. To make
            // the source of the info transparent to the caller, we
            // need to copy this info out.
            //

            *ppibhInfo = HeapAlloc(GetProcessHeap(),
                                   0,
                                   dwSize);

            if ( *ppibhInfo == NULL)
            {
                dwRes = GetLastError();

                break;
            }

            CopyMemory(*ppibhInfo,
                       pibhInfo,
                       dwSize);

            MprAdminBufferFree(pibhInfo);
        }
        else
        {
            //
            // router not running, get info from registry
            //

            dwRes = MprConfigTransportGetHandle(g_hMprConfig,
                                                PID_IP,
                                                &hTransport);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            dwRes = MprConfigTransportGetInfo(g_hMprConfig,
                                              hTransport,
                                              (LPBYTE*) &pibhInfo,
                                              &dwSize,
                                              NULL,
                                              NULL,
                                              NULL);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            if(( pibhInfo == (PRTR_INFO_BLOCK_HEADER) NULL )
             or (dwSize < sizeof(RTR_INFO_BLOCK_HEADER)))
            {
                dwRes = ERROR_TRANSPORT_NOT_PRESENT;
                
                break;
            }    

            //
            // HACKHACK: we know that MprConfigXxx apis allocate from
            // process heap, so we can return the same block
            //
            
            *ppibhInfo = pibhInfo;
        }
         
    } while(FALSE);

    return dwRes;
}

DWORD
SetGlobalInfo(
    IN  PRTR_INFO_BLOCK_HEADER  pibhInfo
    )

/*++

Routine Description:

    Sets global transport information to both the registry and the router

Arguments:

    pibhInfo    - ptr to header
    
Return Value:

    NO_ERROR, ERROR_ROUTER_STOPPED
    
--*/

{
    DWORD                   dwARes = NO_ERROR,
                            dwCRes = NO_ERROR;
    HANDLE                  hTransport;
    UINT                    i;
    PRTR_INFO_BLOCK_HEADER  pibhNewInfo, pibhOldInfo;

    // 
    // Create a new info block with all 0-length blocks removed
    // since we don't want to write them to the registry,
    // we only need to send them to the router which we
    // will do with the original info block below.
    //

    pibhOldInfo = NULL;
    pibhNewInfo = pibhInfo;

    for (i=0; (dwCRes is NO_ERROR) && (i<pibhInfo->TocEntriesCount); i++)
    {
        if (pibhInfo->TocEntry[i].InfoSize is 0)
        {
            pibhOldInfo = pibhNewInfo;

            dwCRes = MprInfoBlockRemove(pibhOldInfo, 
                                        pibhOldInfo->TocEntry[i].InfoType,
                                        &pibhNewInfo);

            if (pibhOldInfo isnot pibhInfo)
            {
                FREE_BUFFER(pibhOldInfo);
            }
        }
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigTransportGetHandle(g_hMprConfig,
                                             PID_IP,
                                             &hTransport);
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigTransportSetInfo(g_hMprConfig,
                                           hTransport,
                                           (LPBYTE) pibhNewInfo,
                                           pibhNewInfo->Size,
                                           NULL,
                                           0,
                                           NULL);
    }

    if (pibhNewInfo isnot pibhInfo)
    {
        FREE_BUFFER(pibhNewInfo);
    }

    //
    // Even if we failed to write to the registry, we still want
    // to write to the router.
    //
    // We use the original format when writing to the router, since it 
    // needs to see the 0-length blocks in order to delete config info.
    //

    if(IsRouterRunning())
    {
        dwARes = MprAdminTransportSetInfo(g_hMprAdmin,
                                          PID_IP,
                                          (LPBYTE) pibhInfo,
                                          pibhInfo->Size,
                                          NULL,
                                          0);

    }

    return (dwARes isnot NO_ERROR)? dwARes : dwCRes;
}

DWORD
GetInterfaceInfo(
    IN     LPCWSTR                 pwszIfName,
    OUT    RTR_INFO_BLOCK_HEADER   **ppibhInfo, OPTIONAL
    OUT    PMPR_INTERFACE_0        pMprIfInfo, OPTIONAL
    OUT    PDWORD                  pdwIfType   OPTIONAL
    )

/*++

Routine Description:

    Gets global transport information from registry or router.

    If one of the out information is not required, then the parameter
    can be NULL.
    
Arguments:

    pwszIfName  - Interface Name
    bMprConfig  - Info from Registry or info from router
    ppibhInfo   - ptr to header
    pMprIfInfo  - ptr to interface info
    pdwIfType   - Type of interface
    
Return Value:

    NO_ERROR, 
    ERROR_NO_SUCH_INTERFACE
    ERROR_TRANSPORT_NOT_PRESENT

--*/

{
    PMPR_INTERFACE_0          pMprIf = NULL;
    PRTR_INFO_BLOCK_HEADER    pibh;
    HANDLE                    hInterface,hIfTransport;
    DWORD                     dwRes, dwSize;

   
    if(((ULONG_PTR)ppibhInfo | (ULONG_PTR)pMprIfInfo | (ULONG_PTR)pdwIfType) ==
       (ULONG_PTR)NULL)
    {
        return NO_ERROR;
    }
 
    do 
    {
        if(IsRouterRunning())
        {
            //
            // Get info from the router
            //
            
            dwRes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszIfName,
                                               &hInterface,
                                               FALSE);

            if( dwRes != NO_ERROR )
            {
                break;
            }


            if(pMprIfInfo || pdwIfType)
            {
                dwRes = MprAdminInterfaceGetInfo(g_hMprAdmin,
                                                 hInterface,
                                                 0,
                                                 (LPBYTE *) &pMprIf);

                if ( dwRes != NO_ERROR )
                {
                    break;
                }

                if (pMprIf == NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                
                if(pMprIfInfo)
                {
                    //
                    // structure copy
                    //

                    *pMprIfInfo= *pMprIf;
                }

                if(pdwIfType)
                {
                    *pdwIfType = pMprIf->dwIfType;
                }

                MprAdminBufferFree(pMprIf);

            }


            if(ppibhInfo)
            {
                dwRes = MprAdminInterfaceTransportGetInfo(g_hMprAdmin,
                                                          hInterface,
                                                          PID_IP,
                                                          (LPBYTE*) &pibh,
                                                          &dwSize);

                if(dwRes != NO_ERROR)
                {
                    break;
                }
            
                if(pibh == (PRTR_INFO_BLOCK_HEADER) NULL)
                {
                    dwRes = ERROR_TRANSPORT_NOT_PRESENT;

                    break;
                }

                //
                // The info returned to the user must be from
                // process heap. Admin calls use MIDL allocation, so
                // copy out info
                //
                
                *ppibhInfo = HeapAlloc(GetProcessHeap(),
                                       0,
                                       dwSize);

                if(*ppibhInfo == NULL)
                {
                    dwRes = GetLastError();

                    break;
                }

                CopyMemory(*ppibhInfo,
                           pibh,
                           dwSize);

                MprAdminBufferFree(pibh);
            }

        }
        else
        {
            //
            // Router not running, get info from the registry
            //
            
            dwRes = MprConfigInterfaceGetHandle(g_hMprConfig,
                                                (LPWSTR)pwszIfName,         
                                                &hInterface);

            if(dwRes != NO_ERROR)
            {
                break;
            }

            if(pMprIfInfo || pdwIfType)
            {
                dwRes = MprConfigInterfaceGetInfo(g_hMprConfig,
                                                  hInterface,
                                                  0,
                                                  (LPBYTE *) &pMprIf,
                                                  &dwSize);
            
                if(dwRes != NO_ERROR)
                {
                    break;
                }

                if (pMprIf == NULL)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                
                if(pdwIfType)
                {
                    *pdwIfType = pMprIf->dwIfType;
                }

                if(pMprIfInfo)
                {
                    *pMprIfInfo = *pMprIf;
                }

                MprConfigBufferFree(pMprIf);
            }
            
            if (ppibhInfo)
            {
                dwRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                             hInterface,
                                                             PID_IP,
                                                             &hIfTransport);

                if(dwRes != NO_ERROR)
                {
                    break;
                } 
            
                dwRes = MprConfigInterfaceTransportGetInfo(g_hMprConfig,
                                                           hInterface,
                                                           hIfTransport,
                                                           (LPBYTE*) &pibh,
                                                           &dwSize);

                if(dwRes != NO_ERROR)
                {
                    break;
                }
            
                if((pibh == (PRTR_INFO_BLOCK_HEADER) NULL)
                  or (dwSize < sizeof(RTR_INFO_BLOCK_HEADER)))
                {
                    dwRes = ERROR_TRANSPORT_NOT_PRESENT;

                    break;
                }

                //
                // Again, since this is also allocated from process heap
                //
                
                *ppibhInfo = pibh;
            }
        }

    } while (FALSE);

    return dwRes;
}

DWORD
MakeIPGlobalInfo( LPBYTE* ppBuff )
{

    DWORD                   dwSize      = 0,
            				dwRes       = (DWORD) -1;
    LPBYTE                  pbDataPtr   = (LPBYTE) NULL;

    PRTR_TOC_ENTRY          pTocEntry   = (PRTR_TOC_ENTRY) NULL;

    PGLOBAL_INFO            pGlbInfo    = NULL;
    PPRIORITY_INFO          pPriorInfo  = NULL;

    PRTR_INFO_BLOCK_HEADER  pIBH        = (PRTR_INFO_BLOCK_HEADER) NULL;

    
    //
    // Alocate for minimal global Information
    //
    
    dwSize = sizeof( RTR_INFO_BLOCK_HEADER ) + sizeof(GLOBAL_INFO) +
             sizeof( RTR_TOC_ENTRY ) + SIZEOF_PRIORITY_INFO(7) + 
             2 * ALIGN_SIZE;

    pIBH = (PRTR_INFO_BLOCK_HEADER) HeapAlloc( GetProcessHeap(), 0, dwSize );

    if ( pIBH == (PRTR_INFO_BLOCK_HEADER) NULL )
    {
        DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY );
        *ppBuff = (LPBYTE) NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // init. infobase fields
    //
    *ppBuff                 = (LPBYTE) pIBH;

    pIBH-> Version          = RTR_INFO_BLOCK_VERSION;
    pIBH-> TocEntriesCount  = 2;
    pIBH-> Size             = dwSize;

    pbDataPtr = (LPBYTE) &( pIBH-> TocEntry[ pIBH-> TocEntriesCount ] );
    ALIGN_POINTER( pbDataPtr );

    //
    // make IP rtr mgr global info.
    //
    
    pTocEntry                   = &(pIBH-> TocEntry[ 0 ]);

    pTocEntry-> InfoType        = IP_GLOBAL_INFO;
    pTocEntry-> Count           = 1;
    pTocEntry-> Offset          = (ULONG)(pbDataPtr - (PBYTE) pIBH);
    pTocEntry-> InfoSize        = sizeof(GLOBAL_INFO);


    pGlbInfo                    = (PGLOBAL_INFO) pbDataPtr;
    pGlbInfo-> bFilteringOn     = TRUE;
    pGlbInfo-> dwLoggingLevel   = IPRTR_LOGGING_ERROR;

    pbDataPtr += pTocEntry->Count * pTocEntry-> InfoSize;
    ALIGN_POINTER( pbDataPtr );
    
    //
    // make IP rtr priority. Info
    //
    
    pTocEntry               = &(pIBH-> TocEntry[ 1 ]);


    pTocEntry-> InfoType    = IP_PROT_PRIORITY_INFO;
    pTocEntry-> Count       = 1;
    pTocEntry-> Offset      = (DWORD)(pbDataPtr - (PBYTE) pIBH);
    pTocEntry-> InfoSize    = SIZEOF_PRIORITY_INFO(7);


    pPriorInfo                      = (PPRIORITY_INFO) pbDataPtr;
    pPriorInfo-> dwNumProtocols     = 7;

    pPriorInfo-> ppmProtocolMetric[ 0 ].dwProtocolId   = PROTO_IP_LOCAL;
    pPriorInfo-> ppmProtocolMetric[ 0 ].dwMetric       = 1;

    pPriorInfo-> ppmProtocolMetric[ 1 ].dwProtocolId   = PROTO_IP_NT_STATIC;
    pPriorInfo-> ppmProtocolMetric[ 1 ].dwMetric       = 3;

    pPriorInfo-> ppmProtocolMetric[ 2 ].dwProtocolId   = PROTO_IP_NT_STATIC_NON_DOD;
    pPriorInfo-> ppmProtocolMetric[ 2 ].dwMetric       = 5;

    pPriorInfo-> ppmProtocolMetric[ 3 ].dwProtocolId   = PROTO_IP_NT_AUTOSTATIC;
    pPriorInfo-> ppmProtocolMetric[ 3 ].dwMetric       = 7;

    pPriorInfo-> ppmProtocolMetric[ 4 ].dwProtocolId   = PROTO_IP_NETMGMT;
    pPriorInfo-> ppmProtocolMetric[ 4 ].dwMetric       = 10;

    pPriorInfo-> ppmProtocolMetric[ 5 ].dwProtocolId   = PROTO_IP_OSPF;
    pPriorInfo-> ppmProtocolMetric[ 5 ].dwMetric       = 110;

    pPriorInfo-> ppmProtocolMetric[ 6 ].dwProtocolId   = PROTO_IP_RIP;
    pPriorInfo-> ppmProtocolMetric[ 6 ].dwMetric       = 120;

    return NO_ERROR;
}

DWORD 
MakeIPInterfaceInfo( 
    LPBYTE* ppBuff,
    DWORD   dwIfType
    )
{
    DWORD           dwSize          = (DWORD) -1;
    DWORD           dwTocEntries    = 2;
    LPBYTE          pbDataPtr       = (LPBYTE) NULL;

    PRTR_TOC_ENTRY  pTocEntry       = (PRTR_TOC_ENTRY) NULL;

#if 0
    PRTR_DISC_INFO  pRtrDisc        = (PRTR_DISC_INFO) NULL;
#endif

    PINTERFACE_STATUS_INFO  pifStat = (PINTERFACE_STATUS_INFO) NULL;

    PRTR_INFO_BLOCK_HEADER   pIBH   = (PRTR_INFO_BLOCK_HEADER) NULL;
    PIPINIP_CONFIG_INFO pIpIpCfg;
    
    //
    // Allocate for minimal interface Info.
    // a TOC entry is allocated for IP_ROUTE_INFO, but no route info
    // block is created, since initially there are no static routes.
    //
    
    dwSize = sizeof( RTR_INFO_BLOCK_HEADER )                                + 
             sizeof( RTR_TOC_ENTRY ) + sizeof( INTERFACE_STATUS_INFO )      +
             2 * ALIGN_SIZE;

#if 0
    if (dwIfType is ROUTER_IF_TYPE_DEDICATED)
    {
        dwSize += sizeof( RTR_TOC_ENTRY ) 
                + sizeof( RTR_DISC_INFO )
                + ALIGN_SIZE;

        dwTocEntries++;
    }
#endif

    pIBH = (PRTR_INFO_BLOCK_HEADER) HeapAlloc( GetProcessHeap(), 0, dwSize );
    
    if ( pIBH == (PRTR_INFO_BLOCK_HEADER) NULL )
    {
        *ppBuff = (LPBYTE) NULL;
        DisplayMessage( g_hModule, MSG_IP_NOT_ENOUGH_MEMORY  );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppBuff                     = (LPBYTE) pIBH;

    pIBH-> Version              = RTR_INFO_BLOCK_VERSION;
    pIBH-> TocEntriesCount      = dwTocEntries;
    pIBH-> Size                 = dwSize;

    
    pbDataPtr = (LPBYTE) &( pIBH-> TocEntry[ pIBH-> TocEntriesCount ] );
    ALIGN_POINTER( pbDataPtr );

    //
    // Create empty route info block
    //
    
    pTocEntry                   = (PRTR_TOC_ENTRY) &( pIBH-> TocEntry[ 0 ] );
    pTocEntry-> InfoType        = IP_ROUTE_INFO;
    pTocEntry-> InfoSize        = sizeof( MIB_IPFORWARDROW );
    pTocEntry-> Count           = 0;
    pTocEntry-> Offset          = (ULONG) (pbDataPtr - (PBYTE) pIBH);
            
    pbDataPtr += pTocEntry-> Count * pTocEntry-> InfoSize;
    ALIGN_POINTER( pbDataPtr );
    
    //
    // Create interface status block.
    //

    pTocEntry                   = (PRTR_TOC_ENTRY) &( pIBH-> TocEntry[ 1 ] );
    pTocEntry-> InfoType        = IP_INTERFACE_STATUS_INFO;
    pTocEntry-> InfoSize        = sizeof( INTERFACE_STATUS_INFO );
    pTocEntry-> Count           = 1;
    pTocEntry-> Offset          = (ULONG) (pbDataPtr - (LPBYTE) pIBH);
    
    pifStat                     = (PINTERFACE_STATUS_INFO) pbDataPtr;
    pifStat-> dwAdminStatus     = g_dwIfState;
    
    pbDataPtr += pTocEntry-> Count * pTocEntry-> InfoSize;
    ALIGN_POINTER( pbDataPtr );
    
#if 0
    if (dwIfType is ROUTER_IF_TYPE_DEDICATED)
    {
        //
        // Create Router Disc. Info.
        //
    
        pTocEntry                   = (PRTR_TOC_ENTRY) &( pIBH-> TocEntry[ 2 ]);
        pTocEntry-> InfoType        = IP_ROUTER_DISC_INFO;
        pTocEntry-> InfoSize        = sizeof( RTR_DISC_INFO );
        pTocEntry-> Count           = 1;
        pTocEntry-> Offset          = (ULONG) (pbDataPtr - (LPBYTE) pIBH);
        
    
        pRtrDisc                    = (PRTR_DISC_INFO) pbDataPtr;
    
        pRtrDisc-> bAdvertise       = TRUE;
        pRtrDisc-> wMaxAdvtInterval = g_wMaxAdvtInterval;
        pRtrDisc-> wMinAdvtInterval = g_wMinAdvtInterval;
        pRtrDisc-> wAdvtLifetime    = g_wAdvtLifeTime;
        pRtrDisc-> lPrefLevel		= g_lPrefLevel;

        pbDataPtr += pTocEntry-> Count * pTocEntry-> InfoSize;

        ALIGN_POINTER( pbDataPtr );
    }
#endif

    return NO_ERROR;
}

DWORD
AddInterfaceInfo(
    IN    LPCWSTR                    pwszIfName
    )
{
    DWORD       dwRes               = (DWORD) -1,
                dwIfType,
                dwSize              = 0;
    BOOL        bAddRtrMgr          = FALSE;

    HANDLE      hInterface          = (HANDLE) NULL,
                hTransport          = (HANDLE) NULL,
                hIfAdmin            = (HANDLE) NULL,
                hIfTransport        = (HANDLE) NULL;

    PRTR_INFO_BLOCK_HEADER  pibhTmp = (PRTR_INFO_BLOCK_HEADER) NULL;

#ifdef EXTRA_DEBUG
    PRINT(L"AddInterfaceInfo:");
    PRINT(pwszIfName);
#endif

    do
    {
        PMPR_INTERFACE_0 pmiIfInfo;

        //
        // verify interface name.
        //

        dwRes = MprConfigInterfaceGetHandle( g_hMprConfig,
                                             (LPWSTR)pwszIfName,
                                             &hInterface );
        if ( dwRes != NO_ERROR )
        {
            DisplayMessage( g_hModule, MSG_NO_INTERFACE, pwszIfName );
            break;
        }

        // Make sure interface exists

        dwRes = MprConfigInterfaceGetInfo(g_hMprConfig,
                                          hInterface,
                                          0,
                                          (BYTE **)&pmiIfInfo,
                                          &dwSize);
        if( dwRes != NO_ERROR )
        {
            DisplayError( NULL, dwRes );
            break;
        }

        dwIfType = pmiIfInfo->dwIfType;

        // Here's a hack due apparently due to the inability of
        // the current stack to do Foo-over-IP tunnels, so adding 
        // an ipip tunnel both creates the tunnel and enables IP 
        // on it.

        if(dwIfType is ROUTER_IF_TYPE_TUNNEL1)
        {
            MprConfigBufferFree(pmiIfInfo);

            dwRes = ERROR_INVALID_PARAMETER;
            DisplayMessage(g_hModule, MSG_IP_IF_IS_TUNNEL);

            break;
        }

        MprConfigBufferFree(pmiIfInfo);

        //
        // Is IP RtrMgr present on this router.
        //
        // if specified IP router manager is absent,
        // we shall need to add global info for this
        // router manager "before" we add the interface
        // information
        //

        //
        // Try to get a handle to the rtr mgr.
        //

        dwRes = MprConfigTransportGetHandle(g_hMprConfig,
                                            PID_IP,
                                            &hTransport);
        if ( dwRes != NO_ERROR )
        {
            if ( dwRes == ERROR_UNKNOWN_PROTOCOL_ID )
            {
                bAddRtrMgr = TRUE;
            }
            else
            {
                DisplayError( NULL, dwRes );
                break;
            }
        }

        //
        // if handle is available, try to retrieve global info.
        // if not available we shall need to add the global info.
        //

        if ( !bAddRtrMgr )
        {
            dwRes = MprConfigTransportGetInfo(g_hMprConfig,
                                              hTransport,
                                              (LPBYTE*) &pibhTmp,
                                              &dwSize,
                                              NULL,
                                              NULL,
                                              NULL);
            if ( dwRes != NO_ERROR )
            {
                DisplayError( NULL, dwRes );
                break;
            }

            if ( pibhTmp == (PRTR_INFO_BLOCK_HEADER) NULL )
            {
                bAddRtrMgr = TRUE;
            }

            else
            {
                MprConfigBufferFree( pibhTmp );
                pibhTmp = NULL;
            }
        }

        //
        // If IP is already present on router, see if IP was already
        // added to the interface.  If so, complain.
        //

        if ( !bAddRtrMgr )
        {
            dwRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                         hInterface,
                                                         PID_IP,
                                                         &hIfTransport);
            if ( dwRes == NO_ERROR )
            {
                dwRes =  ERROR_INVALID_PARAMETER;
                // was SetInterfaceInRouterConfig(); to update
                break;
            }
        }

        //
        // If IP RtrMgr is not present, add global info.
        //

        if ( bAddRtrMgr )
        {
            dwRes = MakeIPGlobalInfo( (LPBYTE *)&pibhTmp );
            if ( dwRes != NO_ERROR )
            {
                break;
            }
            dwRes = MprConfigTransportCreate( g_hMprConfig,
                                              PID_IP,
                                              IP_KEY,
                                              (LPBYTE) pibhTmp,
                                              pibhTmp-> Size,
                                              NULL,
                                              0,
                                              g_wszRtrMgrDLL,
                                              &hTransport );
            if ( dwRes != NO_ERROR )
            {
                DisplayError( NULL, dwRes );
                break;
            }

            HeapFree( GetProcessHeap(), 0, pibhTmp );
        }

        pibhTmp = (PRTR_INFO_BLOCK_HEADER) NULL;

        //
        // Add IP Rtr Mgr. information for the interface
        //

        dwRes = MakeIPInterfaceInfo( (LPBYTE*) &pibhTmp, dwIfType);

        if ( dwRes != NO_ERROR )
        {
            break;
        }

        dwRes = MprConfigInterfaceTransportAdd( g_hMprConfig,
                                                hInterface,
                                                PID_IP,
                                                IP_KEY,
                                                (LPBYTE) pibhTmp,
                                                pibhTmp-> Size,
                                                &hIfTransport );
        if ( dwRes != NO_ERROR )
        {
            DisplayError( NULL, dwRes );
            break;
        }

        if(IsRouterRunning())
        {
            dwRes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszIfName,
                                               &hIfAdmin,
                                               FALSE);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            dwRes = MprAdminInterfaceTransportAdd( g_hMprAdmin,
                                                   hIfAdmin,
                                                   PID_IP,
                                                   (LPBYTE) pibhTmp,
                                                   pibhTmp->Size );

            if ( dwRes != NO_ERROR )
            {
                DisplayMessage( g_hModule, ERROR_ADMIN, dwRes );
                break;
            }

            break;
        }

    } while( FALSE );

    //
    // Free all allocations
    //

    if ( pibhTmp ) { HeapFree( GetProcessHeap(), 0, pibhTmp ); }

    return dwRes;
}

DWORD
DeleteInterfaceInfo(
    IN    LPCWSTR    pwszIfName
    )
{
    DWORD     dwRes, dwIfType = 0, dwErr;
    HANDLE    hIfTransport, hInterface;

    do
    {
        dwRes = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            (LPWSTR)pwszIfName,
                                            &hInterface);
            
        if ( dwRes != NO_ERROR )
        {
            break;
        }
       
        //
        // Get the type of the interface
        //

        dwErr = GetInterfaceInfo(pwszIfName,
                                 NULL,
                                 NULL,
                                 &dwIfType);

        if(dwErr != NO_ERROR)
        {
            break;
        }

        dwRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                     hInterface,
                                                     PID_IP,
                                                     &hIfTransport);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }
        
        dwRes = MprConfigInterfaceTransportRemove(g_hMprConfig,
                                                  hInterface,
                                                  hIfTransport);

        //
        // If its an ip in ip tunnel, clear out its name and delete from the
        // router
        //

        if(dwIfType == ROUTER_IF_TYPE_TUNNEL1)
        {
            dwRes = MprConfigInterfaceDelete(g_hMprConfig,
                                             hInterface);

            if(dwRes == NO_ERROR)
            {
                GUID      Guid;

                dwRes = ConvertStringToGuid(pwszIfName,
                                            (USHORT)(wcslen(pwszIfName) * sizeof(WCHAR)),
                                            &Guid);
        
                if(dwRes != NO_ERROR)
                {
                    break;
                }

                MprSetupIpInIpInterfaceFriendlyNameDelete(g_pwszRouter,
                                                          &Guid);
            }
        }
                                                      
        if(IsRouterRunning())
        {
            dwRes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszIfName,
                                               &hInterface,
                                               FALSE);

            if ( dwRes != NO_ERROR )
            {
                break;
            }

            dwRes = MprAdminInterfaceTransportRemove(g_hMprAdmin,
                                                     hInterface,
                                                     PID_IP);


            if(dwIfType == ROUTER_IF_TYPE_TUNNEL1)
            {
                dwRes = MprAdminInterfaceDelete(g_hMprAdmin,
                                                hInterface);
            }

            break;
        }
        
    } while (FALSE);

    return dwRes;
}

DWORD
SetInterfaceInfo(
    IN    PRTR_INFO_BLOCK_HEADER    pibhInfo,
    IN    LPCWSTR                   pwszIfName
    )

/*++

Routine Description:

    Sets interface transport information in registry or router.
    
Arguments:

    pwszIfName  - Interface Name
    pibhInfo   - ptr to header
    
Return Value:

    NO_ERROR, ERROR_ROUTER_STOPPED
    
--*/

{
    DWORD                   dwARes = NO_ERROR,
                            dwCRes = NO_ERROR;
    HANDLE                  hIfTransport, hInterface;
    UINT                    i;
    PRTR_INFO_BLOCK_HEADER  pibhNewInfo, pibhOldInfo;

    // 
    // Create a new info block with all 0-length blocks removed
    // since we don't want to write them to the registry,
    // we only need to send them to the router which we
    // will do with the original info block below.
    //

    pibhNewInfo = pibhInfo;
    pibhOldInfo = NULL;

    for (i=0; (dwCRes is NO_ERROR) && (i<pibhInfo->TocEntriesCount); i++)
    {
        if (pibhInfo->TocEntry[i].InfoSize is 0)
        {
            pibhOldInfo = pibhNewInfo;

            dwCRes = MprInfoBlockRemove(pibhOldInfo, 
                                        pibhInfo->TocEntry[i].InfoType,
                                        &pibhNewInfo);

            if (pibhOldInfo isnot pibhInfo)
            {
                FREE_BUFFER(pibhOldInfo);
            }
        }
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigInterfaceGetHandle(g_hMprConfig,
                                             (LPWSTR)pwszIfName,
                                             &hInterface);
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                      hInterface,
                                                      PID_IP,
                                                      &hIfTransport);
    }

    if (dwCRes is NO_ERROR)
    {
        dwCRes = MprConfigInterfaceTransportSetInfo(g_hMprConfig,
                                                    hInterface,
                                                    hIfTransport,
                                                    (LPBYTE) pibhNewInfo,
                                                    pibhNewInfo->Size);
    }

    if (pibhNewInfo isnot pibhInfo)
    {
        FREE_BUFFER(pibhNewInfo);
    }

    //
    // Even if we failed to write to the registry, we still want
    // to write to the router.
    //
    // We use the original format when writing to the router, since it 
    // needs to see the 0-length blocks in order to delete config info.
    //

    if(IsRouterRunning())
    {
        dwARes = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                            (LPWSTR)pwszIfName,
                                            &hInterface,
                                            FALSE);

        if (dwARes is NO_ERROR)
        {
            dwARes = MprAdminInterfaceTransportSetInfo(g_hMprAdmin,
                                                       hInterface,
                                                       PID_IP,
                                                       (LPBYTE) pibhInfo,
                                                       pibhInfo->Size);
        }
    }

    return (dwARes isnot NO_ERROR)? dwARes : dwCRes;
}

DWORD
WINAPI
IpCommit(
    IN  DWORD   dwAction
    )
{
    PINTERFACE_STORE    pii;
    PLIST_ENTRY        ple, pleTmp;
    BOOL               bCommit, bFlush = FALSE;

    switch(dwAction)
    {
        case NETSH_COMMIT:
        {
            if (g_bCommit == TRUE)
            {
                return NO_ERROR;
            }

            g_bCommit = TRUE;

            break;
        }

        case NETSH_UNCOMMIT:
        {
            g_bCommit = FALSE;

            return NO_ERROR;
        }

        case NETSH_SAVE:
        {
            if (g_bCommit)
            {
                return NO_ERROR;
            }

            break;
        }

        case NETSH_FLUSH:
        {
            //
            // Action is a flush. If current state is commit, then
            // nothing to be done.

            if (g_bCommit)
            {
                return NO_ERROR;
            }

            bFlush = TRUE;

            break;
        }

        default:
        {
            return NO_ERROR;
        }
    }

    //
    // Switched to commit mode. So set all valid info in the
    // strutures. Free memory and invalidate the info.
    //

    if((g_tiTransport.bValid && g_tiTransport.pibhInfo) &&
        !bFlush)
    {
        SetGlobalInfo(g_tiTransport.pibhInfo);

    }

    g_tiTransport.bValid = FALSE;

    if(g_tiTransport.pibhInfo)
    {
        FREE_BUFFER(g_tiTransport.pibhInfo);

        g_tiTransport.pibhInfo = NULL;
    }

    //
    // Set the interface info
    //

    while(!IsListEmpty(&g_leIfListHead))
    {
        ple = RemoveHeadList(&g_leIfListHead);

        pii = CONTAINING_RECORD(ple,
                                INTERFACE_STORE,
                                le);

        if ((pii->bValid && pii->pibhInfo) &&
            !bFlush)
        {
            // Set the info in config

            SetInterfaceInfo(pii->pibhInfo,
                             pii->pwszIfName);
        }

        pii->bValid = FALSE;

        if(pii->pibhInfo)
        {
            FREE_BUFFER(pii->pibhInfo);

            pii->pibhInfo = NULL;
        }

        if(pii->pwszIfName)
        {
            HeapFree(GetProcessHeap(),
                     0,
                     pii->pwszIfName);

            pii->pwszIfName = NULL;
        }

        //
        // Free the list entry
        //

        HeapFree(GetProcessHeap(),
                 0,
                 pii);
    }

    return NO_ERROR;
}

DWORD
CreateInterface(
    IN  LPCWSTR pwszFriendlyName,
    IN  LPCWSTR pwszGuidName,
    IN  DWORD   dwIfType,
    IN  BOOL    bCreateRouterIf
    )

{
    DWORD   i, dwErr, dwType, dwSize;
    HANDLE  hIfCfg, hIfAdmin, hIfTransport;
    PBYTE   pbyData;

    PRTR_INFO_BLOCK_HEADER  pInfo;
    PINTERFACE_STATUS_INFO  pStatus;
#if 0
    PRTR_DISC_INFO          pDisc;
#endif

    //
    // The only type we can create in the router is TUNNEL1
    //

    if(dwIfType != ROUTER_IF_TYPE_TUNNEL1)
    {
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;
    }

    hIfAdmin = NULL;
    hIfCfg   = NULL;

    if(bCreateRouterIf)
    {
        MPR_INTERFACE_0         IfInfo;

        //
        // The caller wants us to create an interface in the router, also
        //

        wcsncpy(IfInfo.wszInterfaceName,
                pwszGuidName,
                MAX_INTERFACE_NAME_LEN);

        IfInfo.fEnabled = TRUE;

        IfInfo.dwIfType = dwIfType;

        IfInfo.wszInterfaceName[MAX_INTERFACE_NAME_LEN] = UNICODE_NULL;

        dwErr = MprConfigInterfaceCreate(g_hMprConfig,
                                         0,
                                         (PBYTE)&IfInfo,
                                         &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            return dwErr;
        }

        //
        // if router service is running add the interface
        // to it too.
        //

        if(IsRouterRunning())
        {
            dwErr = MprAdminInterfaceCreate(g_hMprAdmin,
                                            0,
                                            (PBYTE)&IfInfo,
                                            &hIfAdmin);

            if(dwErr isnot NO_ERROR)
            {
                DisplayError(NULL,
                             dwErr);


                MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);
   
                return dwErr;
            }
        }
    }
    else
    {
        //
        // The interface existed in the router but not in IP
        //

        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            (LPWSTR)pwszGuidName,
                                            &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            return dwErr;
        }

        if(IsRouterRunning())
        {
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszGuidName,
                                               &hIfAdmin,
                                               FALSE);

            if(dwErr isnot NO_ERROR)
            {
                DisplayError(NULL,
                             dwErr);

                return dwErr;
            }
        }
    }

    //
    // At this point we have an interface which doesnt have IP on it
    // We have the handles to config and admin (if router is running)
    // Set the default information for the interface
    //

    dwSize  =  FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry[0]);

    dwSize += (sizeof(INTERFACE_STATUS_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);

#if 0
    dwSize += (sizeof(RTR_DISC_INFO) +
               sizeof(RTR_TOC_ENTRY) +
               ALIGN_SIZE);
#endif

    pInfo = HeapAlloc(GetProcessHeap(),
                      0,
                      dwSize);

    if(pInfo is NULL)
    {
        DisplayError(NULL,
                     ERROR_NOT_ENOUGH_MEMORY);

        if(bCreateRouterIf)
        {
            MprConfigInterfaceDelete(g_hMprConfig,
                                     hIfCfg);
        }

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pInfo->Version          = IP_ROUTER_MANAGER_VERSION;
    pInfo->TocEntriesCount  = 1;
    pInfo->Size             = dwSize;

    //
    // Make data point to N+1th entry
    //

    pbyData = (PBYTE)&(pInfo->TocEntry[1]);

    ALIGN_POINTER(pbyData);

    pStatus = (PINTERFACE_STATUS_INFO)pbyData;

    pStatus->dwAdminStatus =  IF_ADMIN_STATUS_UP;

    pInfo->TocEntry[0].InfoSize  = sizeof(INTERFACE_STATUS_INFO);
    pInfo->TocEntry[0].InfoType  = IP_INTERFACE_STATUS_INFO;
    pInfo->TocEntry[0].Count     = 1;
    pInfo->TocEntry[0].Offset    = (ULONG)(pbyData - (PBYTE)pInfo);

    pbyData = (PBYTE)((ULONG_PTR)pbyData + sizeof(INTERFACE_STATUS_INFO));

    ALIGN_POINTER(pbyData);

#if 0
    pDisc = (PRTR_DISC_INFO)pbyData;

    pDisc->wMaxAdvtInterval = 
        DEFAULT_MAX_ADVT_INTERVAL;
    pDisc->wMinAdvtInterval = 
        (WORD)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
    pDisc->wAdvtLifetime    = 
        DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL;
    pDisc->bAdvertise       = FALSE;
    pDisc->lPrefLevel       = DEFAULT_PREF_LEVEL;

    pInfo->TocEntry[1].InfoSize  = sizeof(RTR_DISC_INFO);
    pInfo->TocEntry[1].InfoType  = IP_ROUTER_DISC_INFO;
    pInfo->TocEntry[1].Count     = 1;
    pInfo->TocEntry[1].Offset    = (ULONG)(pbyData - (PBYTE)pInfo);
#endif

    dwErr = MprConfigInterfaceTransportAdd(g_hMprConfig,
                                           hIfCfg,
                                           PID_IP,
                                           IP_KEY,
                                           (PBYTE) pInfo,
                                           dwSize,
                                           &hIfTransport);

    if(dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),
                 0,
                 pInfo);

        DisplayMessage(g_hModule,
                       EMSG_CANT_CREATE_IF,
                       pwszFriendlyName,
                       dwErr);

        if(bCreateRouterIf)
        {
            MprConfigInterfaceDelete(g_hMprConfig,
                                     hIfCfg);
        }

        return dwErr;
    }

    if(hIfAdmin isnot NULL)
    {
        dwErr = MprAdminInterfaceTransportAdd(g_hMprAdmin,
                                              hIfAdmin,
                                              PID_IP,
                                              (PBYTE) pInfo,
                                              dwSize);

        if(dwErr isnot NO_ERROR)
        {
            DisplayMessage(g_hModule,
                           EMSG_CANT_CREATE_IF,
                           pwszFriendlyName,
                           dwErr);

            MprConfigInterfaceTransportRemove(g_hMprConfig,
                                              hIfCfg,
                                              hIfTransport);

            if(bCreateRouterIf)
            {
                MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);
            }

        }
    }

    HeapFree(GetProcessHeap(),
             0,
             pInfo);

    return NO_ERROR;
}

DWORD
GetInterfaceClass(
    IN  LPCWSTR pwszIfName,
    OUT PDWORD  pdwIfClass
    )
/*++
Description:
    Determine whether an interface is of class Loopback, P2P,
    Subnet, or NBMA.  Currently there is no global way to do this,
    so we test for some enumerated types and assume everything else
    is Subnet.
Returns:
    IFCLASS_xxx (see info.h)
--*/
{
    DWORD   dwErr, dwType;

    dwErr = GetInterfaceInfo(pwszIfName,
                             NULL,
                             NULL,
                             &dwType);

    if (dwErr)
    {
        return dwErr;
    }

    switch (dwType) {
    case ROUTER_IF_TYPE_FULL_ROUTER : *pdwIfClass = IFCLASS_P2P;       break;
    case ROUTER_IF_TYPE_INTERNAL    : *pdwIfClass = IFCLASS_NBMA;      break;
    case ROUTER_IF_TYPE_LOOPBACK    : *pdwIfClass = IFCLASS_LOOPBACK;  break;
    case ROUTER_IF_TYPE_TUNNEL1     : *pdwIfClass = IFCLASS_P2P;       break;
    case ROUTER_IF_TYPE_DIALOUT     : *pdwIfClass = IFCLASS_P2P;       break;
    default:                          *pdwIfClass = IFCLASS_BROADCAST; break;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\ipcfg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\ipcfg.c

Abstract:

    Fns to change configuration at the IP Rtr Mgr level

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
AddDeleteRoutePrefLevel ( 
    IN    PPROTOCOL_METRIC    ppm,
    IN    DWORD               dwNumProto,
    IN    BOOL                bAdd
    )
/*++

Routine Description:

    Adds, deletes route preferences

Arguments:

    ppm         - array of protocols to be added/deleted
    dwNumProto  - Number of protocols to be added/deleted
    bAdd        - To add or not to add
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD                   dwRes = (DWORD) -1, dwSize = 0;
    PPRIORITY_INFO          ppi = NULL, ppiNew = NULL;
    DWORD                   dwBlkSize, dwNewBlkSize, dwCount;
    
    DEBUG("In AddDelRoutePrefLevel");
    
    if (dwNumProto is 0)
    {
        return NO_ERROR;
    }
   
 

    do
    {
        dwRes = IpmontrGetInfoBlockFromGlobalInfo(IP_PROT_PRIORITY_INFO,
                                           (PBYTE *) &ppi,
                                           &dwBlkSize,
                                           &dwCount);
    
        if(dwRes != NO_ERROR)
        {
            break;
        }

        if(bAdd)
        {
            dwRes = AddNewRoutePrefToBlock(ppi,
                                           dwBlkSize,
                                           ppm,
                                           dwNumProto,
                                           &ppiNew,
                                           &dwNewBlkSize);
        }
        else
        {
            dwRes = DeleteRoutePrefFromBlock(ppi,
                                             dwBlkSize,
                                             ppm,
                                             dwNumProto,
                                             &ppiNew,
                                             &dwNewBlkSize);
        }

        if(dwRes != NO_ERROR)
        {
            if(dwRes is ERROR_NO_CHANGE)
            {
                //
                // No Change in config, proceed to change in router
                //
    
                dwRes = NO_ERROR;

                ppiNew = NULL;

                break;
            }
        }
        else
        {
            if(ppiNew)
            {
                dwRes = IpmontrSetInfoBlockInGlobalInfo(IP_PROT_PRIORITY_INFO,
                                                (PBYTE) ppiNew,
                                                dwNewBlkSize,
                                                dwCount);
            }
        }

    }while(FALSE);

    //        
    // free allocations
    //

    if(ppi)
    { 
        FreeInfoBuffer(ppi);

        ppi = NULL;
    }

    if(ppiNew)
    { 
        FREE(ppiNew);

        ppiNew = NULL;
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_PRIO_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}

DWORD
AddNewRoutePrefToBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize
    )

/*++

Routine Description:

    creates route preference block 

Arguments:

    ppi          - preference block
    dwNumBlkSize - size of block
    ppm          - protocols to be added
    dwNumProto   - number of protocols
    pppi         - new preference block
    pdwSize      - size of new block
    
Return Value:

    NO_ERROR
    
--*/

{
    PPRIORITY_INFO  pPriorInfoOld = NULL, pPriorInfoNew = NULL;
    DWORD           i = 0, dwNewSize = 0, dwRes = NO_ERROR;
    BOOL            bFound = FALSE;
    PDWORD          pdwValid;
    DWORD           j, dwProtoCount;
    
    //
    // Have an array to tell which ones are valid.
    //
    pdwValid = MALLOC( dwNumProto * sizeof(DWORD));

    if (pdwValid is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(pdwValid, dwNumProto * sizeof(DWORD));

    //
    // find the PrefLevel block
    //
    
    pPriorInfoOld = ppi;
        
    if ( pPriorInfoOld == (PPRIORITY_INFO) NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_CORRUPT_INFO );
        FREE(pdwValid);
        
        return ERROR_INVALID_PARAMETER;
    }

    
    for ( j = 0, dwNewSize = 0; j < dwNumProto; j++)
    {
        //
        // make sure preference level for the protocol does not already exist.
        //

        for ( i = 0;  i < pPriorInfoOld-> dwNumProtocols;  i++ )
        {
            if (pPriorInfoOld->ppmProtocolMetric[ i ].dwProtocolId 
                == ppm[j].dwProtocolId)
            {
                bFound = TRUE;
                break;
            }
        }

        if (bFound)
        {
            pdwValid[j] = 0;
            DisplayMessage(g_hModule, MSG_IP_PROTO_PREF_LEVEL_EXISTS, 
                           pPriorInfoOld->ppmProtocolMetric[ i ].dwMetric);
            
            bFound = FALSE;
        }
        else
        {
            pdwValid[j] = 1;
            dwNewSize += sizeof(PROTOCOL_METRIC);
        }
    }

    //
    // allocate new info block
    //

    if (dwNewSize is 0)
    {
        //
        // All specified protocols already present
        //

        FREE(pdwValid);

        return ERROR_NO_CHANGE;
    }

    dwProtoCount = dwNewSize / sizeof(PROTOCOL_METRIC);
    
    dwNewSize += dwBlkSize;
    
    pPriorInfoNew = MALLOC(dwNewSize);

    if ( pPriorInfoNew == NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_NOT_ENOUGH_MEMORY );
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    do
    {
        //
        // copy the old PrefLevels and set the number of protocols
        //
        
        CopyMemory((PBYTE) &pPriorInfoNew-> ppmProtocolMetric, 
                   (PBYTE) &pPriorInfoOld-> ppmProtocolMetric,
                   sizeof(PROTOCOL_METRIC)*pPriorInfoOld-> dwNumProtocols);

        pPriorInfoNew-> dwNumProtocols = pPriorInfoOld-> dwNumProtocols +
                                         dwProtoCount;


        //
        // add the new PrefLevel and increment count of protocols
        // with PrefLevels
        //

        i = pPriorInfoOld-> dwNumProtocols;
        
        for ( j = 0 ; j < dwNumProto ; j++)
        {
            if (pdwValid[j])
            {
                //
                // Add the protocol priority
                //
            
                pPriorInfoNew-> ppmProtocolMetric[i].dwProtocolId
                    = ppm[j].dwProtocolId;
                
                pPriorInfoNew-> ppmProtocolMetric[i++].dwMetric 
                    = ppm[j].dwMetric;
            }
        }
        
    } while (FALSE);

    FREE(pdwValid);
    
    if ( dwRes == NO_ERROR )
    {
        *pppi = pPriorInfoNew;
        *pdwSize = dwNewSize;
    }

    return dwRes;
}


DWORD
DeleteRoutePrefFromBlock (
    IN    PPRIORITY_INFO            ppi,
    IN    DWORD                     dwBlkSize,
    IN    PPROTOCOL_METRIC          ppm,
    IN    DWORD                     dwNumProto,
    OUT   PPRIORITY_INFO            *pppi,
    OUT   PDWORD                    pdwSize  
    )
/*++

Routine Description:

    creates route preference block 

Arguments:

    ppi          - preference block
    dwNumBlkSize - size of block
    ppm          - protocols to be added
    dwNumProto   - number of protocols
    pppi         - new preference block
    pdwSize      - size of new block
    
Return Value:

    NO_ERROR
    
--*/
{
    PPRIORITY_INFO          pPriorInfoOld = NULL, pPriorInfoNew = NULL;
    DWORD                   dwInd = 0, dwNewSize = 0, dwRes = NO_ERROR, i, j;
    BOOL                    bFound = FALSE;
    PDWORD                  pdwToDelete;


    // find the PrefLevel block

    pPriorInfoOld = ppi;

    if ( pPriorInfoOld == (PPRIORITY_INFO) NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_CORRUPT_INFO );
        return ERROR_INVALID_PARAMETER;
    }

    pdwToDelete = MALLOC( pPriorInfoOld-> dwNumProtocols * sizeof(DWORD));

    if (pdwToDelete is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(pdwToDelete, pPriorInfoOld-> dwNumProtocols * sizeof(DWORD));

    for ( i = 0, dwNewSize = 0; i < dwNumProto; i++)
    {
        //
        // make sure preference level for the protocol already exists.
        //

        for ( dwInd = 0;  dwInd < pPriorInfoOld-> dwNumProtocols;  dwInd++ )
        {
            if (pPriorInfoOld-> ppmProtocolMetric[ dwInd ].dwProtocolId 
                == ppm[i].dwProtocolId)
            {
                bFound = TRUE;
                break;
            }
        }
    
        if (!bFound)
        {
            DisplayMessage(g_hModule, MSG_IP_PROTO_PREF_LEVEL_NOT_FOUND,
                           ppm[i].dwProtocolId);
        }
        else
        {
            bFound = FALSE;
            pdwToDelete[dwInd] = 1;
            dwNewSize += sizeof(PROTOCOL_METRIC);
        }
    }

    if (dwNewSize is 0)
    {
        //
        // None of the protocols specified were found.
        //

        FREE(pdwToDelete);
        return ERROR_NO_CHANGE;
    }
    
    //
    // allocate new info block
    //

    dwNewSize = dwBlkSize - dwNewSize;
    
    pPriorInfoNew = MALLOC(dwNewSize);

    if ( pPriorInfoNew == NULL )
    {
        FREE(pdwToDelete);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    do
    {
        for ( i = 0, j = 0; i < pPriorInfoOld-> dwNumProtocols; i++)
        {
            if (pdwToDelete[i])
            {
                //
                // Do not copy this protocol
                //
            }
            else
            {
                pPriorInfoNew->ppmProtocolMetric[j].dwProtocolId =
                    pPriorInfoOld->ppmProtocolMetric[i].dwProtocolId;
                pPriorInfoNew->ppmProtocolMetric[j++].dwMetric =
                    pPriorInfoOld->ppmProtocolMetric[i].dwMetric;
            }
        }
        
        pPriorInfoNew-> dwNumProtocols = j;
        
    } while (FALSE);

    FREE(pdwToDelete);
    
    if ( dwRes == NO_ERROR )
    {
        *pppi = pPriorInfoNew;
        *pdwSize = dwNewSize;
    }

    return dwRes;
}

DWORD
SetRoutePrefLevel ( 
    IN    PROTOCOL_METRIC    pm
    )
/*++

Routine Description:

    sets route preference

Arguments:

    ppm - preference to set
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD                   dwRes = (DWORD) -1, dwSize = 0;
    PPRIORITY_INFO          ppi = NULL;
    DWORD                   dwBlkSize, dwCount;

    DEBUG("In SetRoutePrefLevel");
 
    do
    {
        //
        // get router config, add new router preference level,
        // and set the config
        //

        dwRes = IpmontrGetInfoBlockFromGlobalInfo(IP_PROT_PRIORITY_INFO,
                                           (PBYTE *) &ppi,
                                           &dwBlkSize,
                                           &dwCount);
        
        if (dwRes != NO_ERROR)
        {
            break;
        }

        dwRes = UpdateRtrPriority(ppi, pm);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        dwRes = IpmontrSetInfoBlockInGlobalInfo(IP_PROT_PRIORITY_INFO,
                                        (PBYTE) ppi,
                                        dwBlkSize,
                                        dwCount);
        
        if ( dwRes != NO_ERROR )
        {
            break;
        }

        PRINT(L"Made Changes to Router Config");

        if (!IsRouterRunning())
        {
            break;
        }
        
    } while (FALSE);
    
    //
    // Free all allocations
    //

    if ( ppi )
    { 
        FREE(ppi);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_PRIO_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        case ERROR_INVALID_PARAMETER:
            break;
            
        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}

DWORD
UpdateRtrPriority(
    IN    PPRIORITY_INFO            ppi,
    IN    PROTOCOL_METRIC           pm
    )
/*++

Routine Description:

    sets route preference

Arguments:

    ppi - route preference block
    ppm - preference to set
    
Return Value:

    NO_ERROR
    
--*/
{
    BOOL            bFound = FALSE;
    DWORD           i = 0;


    if ( ppi == (PPRIORITY_INFO) NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_CORRUPT_INFO );
        return ERROR_INVALID_PARAMETER;
    }


    // search for the protocol
    
    for ( i = 0;  i < ppi-> dwNumProtocols;  i++ )
    {
        if (ppi-> ppmProtocolMetric[ i ].dwProtocolId 
                    == pm.dwProtocolId )
        {
            ppi-> ppmProtocolMetric[ i ].dwMetric = pm.dwMetric;
            
            bFound = TRUE;
            break;
        }
    }

    
    if (!bFound)
    {
        // preference level for that protocolId does not exist

        DisplayMessage(g_hModule,  MSG_IP_NO_PREF_FOR_PROTOCOL_ID,
                        pm.dwProtocolId );
        
        return ERROR_INVALID_PARAMETER;
    }
    
    return NO_ERROR;
}

DWORD
SetGlobalConfigInfo(
    IN    DWORD    dwLoggingLevel
    )
/*++

Routine Description:

    sets global logging level

Arguments:

    dwLoggingLevel - Loggging level
    
Return Value:

    NO_ERROR
    
--*/
{
    PGLOBAL_INFO     pgi = NULL;
    DWORD            dwBlkSize, dwCount, dwErr = NO_ERROR;
 
    do
    {
        //
        // Get the IP_GLOBAL_INFO block from router config
        //

        dwErr = IpmontrGetInfoBlockFromGlobalInfo(IP_GLOBAL_INFO,
                                           (PBYTE *) &pgi,
                                           &dwBlkSize,
                                           &dwCount);

        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        pgi->dwLoggingLevel = dwLoggingLevel;

        //
        // Set the IP_GLOBAL_INFO block in router config
        //

        dwErr = IpmontrSetInfoBlockInGlobalInfo(IP_GLOBAL_INFO,
                                        (PBYTE) pgi,
                                        dwBlkSize,
                                        dwCount);

        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        FREE(pgi);

        pgi = NULL;
        
        DEBUG("Set logging level in router config\n");
        
    }while (FALSE);

    if (pgi)
    {
        FREE(pgi);
    }

    switch(dwErr)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_PRIO_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwErr);
            break;
    }

    return dwErr;
}

DWORD
UpdateInterfaceStatusInfo(
    IN    DWORD          dwAction,
    IN    LPCWSTR        pwszIfName,
    IN    DWORD          dwStatus
    )

/*++

Routine Description:

    Sets interface discovery information

Arguments:

    pwszIfName   - interface name
    dwStatus     - enabled or disabled
    
Return Value:

    NO_ERROR
    
--*/

{
    PINTERFACE_STATUS_INFO  pifStat = (PINTERFACE_STATUS_INFO) NULL;
    DWORD                   dwRes = NO_ERROR, dwBlkSize;
    DWORD                   dwCount, dwIfType;
    
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                              IP_INTERFACE_STATUS_INFO,
                                              (PBYTE *) &pifStat,
                                              &dwBlkSize,
                                              &dwCount,
                                              &dwIfType);

        if (dwRes is ERROR_NOT_FOUND)
        {
            //
            // No info of this type is currently present
            //

            dwRes = NO_ERROR;
            dwCount = 0;

            // Add interface
            if (dwAction is ADD_COMMAND) {
                pifStat = (PINTERFACE_STATUS_INFO)MALLOC(
                    sizeof(INTERFACE_STATUS_INFO));
                if (pifStat is NULL) {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                dwCount++;
            }
        }
        
        if (dwRes != NO_ERROR)
        {
            break;
        }

        if (dwCount is 0)
            return ERROR_NOT_FOUND;

        if (dwAction is DELETE_COMMAND)
        {
            dwCount = 0;
        }
        else
        {
            pifStat->dwAdminStatus = dwStatus;
        }
        
        dwRes = IpmontrSetInfoBlockInInterfaceInfo( pwszIfName,
                                             IP_INTERFACE_STATUS_INFO,
                                             (PBYTE) pifStat,
                                             dwBlkSize,
                                             dwCount);
        
    } while (FALSE);
    
    //
    // Free all allocations
    //

    if ( pifStat )
    { 
        FREE(pifStat);
    }

    switch(dwRes)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule, EMSG_IP_NO_IF_STATUS_INFO, L"Router");

            break;

        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwRes);
            break;
    }
    
    return dwRes;
}




DWORD
ShowRoutePref(
    HANDLE  hFile
    )

/*++

Routine Description:

    Displays the protocol route preferences.

Arguments:

    
Return Value:

    NO_ERROR
    
--*/

{
    PPRIORITY_INFO    ppi;
    DWORD             dwBlkSize, dwCount, dwNumProto, i;
    DWORD             dwErr;
    WCHAR             wszBuff[80]; 

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(IP_PROT_PRIORITY_INFO,
                                       (PBYTE *)&ppi,
                                       &dwBlkSize,
                                       &dwCount);


    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);
    
        return ERROR_SUPPRESS_OUTPUT;
    }

    dwNumProto = ppi-> dwNumProtocols;

    if (dwNumProto && 
        (hFile == NULL))
    {
        DisplayMessage(g_hModule, MSG_RTR_PRIO_INFO_HDR);
    }
    
    for (i=0;  i < dwNumProto;  i++)
    {
        PTCHAR  ptszProto, ptszToken;
        
        switch (ppi-> ppmProtocolMetric[ i ].dwProtocolId)
        {
            case PROTO_IP_LOCAL:
            {
                ptszProto = MakeString(g_hModule,  STRING_LOCAL );
                ptszToken = TOKEN_VALUE_LOCAL;

                break;
            }

            case PROTO_IP_NETMGMT:
            {
                ptszProto = MakeString(g_hModule,  STRING_NETMGMT );
                ptszToken = TOKEN_VALUE_NETMGMT;

                break;
            }

            case PROTO_IP_OSPF :
            {
                ptszProto = MakeString(g_hModule,  STRING_OSPF );
                ptszToken = TOKEN_VALUE_OSPF;

                break;
            }

            case PROTO_IP_RIP :
            {
                ptszProto = MakeString(g_hModule,  STRING_RIP );
                ptszToken = TOKEN_VALUE_RIP;

                break;
            }

            case PROTO_IP_NT_AUTOSTATIC :
            {
                ptszProto = MakeString(g_hModule,  STRING_NT_AUTOSTATIC );
                ptszToken = TOKEN_VALUE_AUTOSTATIC;
                
                break;
            }

            case PROTO_IP_NT_STATIC :
            {
                ptszProto = MakeString(g_hModule,  STRING_STATIC );
                ptszToken = TOKEN_VALUE_STATIC;

                break;
            }

            case PROTO_IP_NT_STATIC_NON_DOD :
            {
                ptszProto = MakeString(g_hModule,  STRING_NONDOD );
                ptszToken = TOKEN_VALUE_NONDOD;
                
                break;
            }

            default:
            {
                ptszProto = NULL;
                ptszToken = NULL;

                break;
            }
        }

        if ( ptszProto == NULL || ptszToken == NULL )
        {
            swprintf( wszBuff, 
                      L"%d", 
                      ppi-> ppmProtocolMetric[ i ].dwProtocolId );
        }
            
        if(hFile != NULL)
        {
            DisplayMessageT( DMP_IP_SET_PROTOPREF,
                        (ptszToken)? ptszToken : wszBuff,
                        ppi->ppmProtocolMetric[i].dwMetric);
            
        }
        else
        {
            DisplayMessage(g_hModule, 
                           MSG_RTR_PRIO_INFO, 
                           (ptszProto)? ptszProto : wszBuff,
                           ppi->ppmProtocolMetric[i].dwMetric);
        }

        if(ptszProto)
        {
            FreeString(ptszProto);
        }
    }

    FREE(ppi);

    return NO_ERROR;
}


DWORD
ShowIpGlobal(
    HANDLE  hFile
    )

/*++

Routine Description:

    Displays the logging level for IP

Arguments:

    
Return Value:

    NO_ERROR
    
--*/

{
    PGLOBAL_INFO     pgi = NULL;
    DWORD            dwBlkSize, dwCount;
    DWORD            dwErr;
    PWCHAR           ptszLoglevel, ptszLog;
    WCHAR             wszBuff[80];
    
    dwErr = IpmontrGetInfoBlockFromGlobalInfo(IP_GLOBAL_INFO,
                                       (PBYTE *)&pgi,
                                       &dwBlkSize,
                                       &dwCount);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    switch (pgi->dwLoggingLevel)
    {
        case IPRTR_LOGGING_NONE:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_NONE);
            ptszLog      = TOKEN_VALUE_NONE;
            
            break;
        }

        case IPRTR_LOGGING_ERROR:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_ERROR);
            ptszLog      = TOKEN_VALUE_ERROR;
            
            break;
        }

        case IPRTR_LOGGING_WARN:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_WARN);
            ptszLog      = TOKEN_VALUE_WARN;
            
            break;
        }
        
        case IPRTR_LOGGING_INFO:
        {
            ptszLoglevel = MakeString(g_hModule, STRING_LOGGING_INFO);
            ptszLog      = TOKEN_VALUE_INFO;
            
            break;
        }
    }

    if ( ptszLoglevel == NULL || ptszLog == NULL )
    {
        swprintf( wszBuff, 
                  L"%d", 
                  pgi->dwLoggingLevel);
    }

    if(hFile)
    {
        DisplayMessageT( DMP_IP_SET_LOGLEVEL,
                    (ptszLog) ? ptszLog : wszBuff);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_IP_GLOBAL_HDR);
        DisplayMessage(g_hModule, MSG_IP_LOG_LEVEL, 
                    (ptszLoglevel) ? ptszLoglevel : wszBuff);
    }

    if ( ptszLoglevel )
    {
        FreeString(ptszLoglevel);
    }
    
    FREE(pgi);

    return NO_ERROR;
}

PWCHAR
GetIfTypeString(
    DWORD  dwIfType
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsList[] = {{ROUTER_IF_TYPE_CLIENT,      STRING_CLIENT},
                               {ROUTER_IF_TYPE_HOME_ROUTER, STRING_HOME_ROUTER},
                               {ROUTER_IF_TYPE_FULL_ROUTER, STRING_FULL_ROUTER},
                               {ROUTER_IF_TYPE_DEDICATED,   STRING_DEDICATED},
                               {ROUTER_IF_TYPE_INTERNAL,    STRING_INTERNAL},
                               {ROUTER_IF_TYPE_LOOPBACK,    STRING_LOOPBACK},
                               {ROUTER_IF_TYPE_TUNNEL1,     STRING_TUNNEL},
                              };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwIfType == ppsList[i].dwValue)
        {
            dwMsgId = ppsList[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        if ( pwszStr )
        {
            wcscpy(buff, pwszStr);
            FreeString(pwszStr);
        }
        else
        {
            wsprintf(buff, L"%d", dwIfType);
        }
    }
    else
    {
        wsprintf(buff, L"%d", dwIfType);
    }

    return buff;
}

PWCHAR
GetProtoTypeString(
    DWORD  dwProtoType
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsList[] = {{PROTO_TYPE_UCAST, STRING_UNICAST},
                               {PROTO_TYPE_MCAST, STRING_MULTICAST},
                               {PROTO_TYPE_MS1,   STRING_GENERAL},
                               {PROTO_TYPE_MS0,   STRING_GENERAL},
                              };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwProtoType == ppsList[i].dwValue)
        {
            dwMsgId = ppsList[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        if ( pwszStr )
        {
            wcscpy(buff, pwszStr);
            FreeString(pwszStr);
        }
        else
        {
            wsprintf(buff, L"%d", dwProtoType);
        }
    }
    else
    {
        wsprintf(buff, L"%d", dwProtoType);
    }

    return buff;
}

PWCHAR
GetProtoVendorString(  
    DWORD  dwProtoVendor
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_TOKEN   ppsList[] = {{PROTO_VENDOR_MS0, TOKEN_MICROSOFT0},
                               {PROTO_VENDOR_MS1, TOKEN_MICROSOFT1},
                               {PROTO_VENDOR_MS2, TOKEN_MICROSOFT2},
                              };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwProtoVendor == ppsList[i].dwValue)
        {
            return (PWCHAR)ppsList[i].pwszToken;
            break;
        }
    }

    wsprintf(buff, L"%d", dwProtoVendor);

    return buff;
}

PWCHAR
GetProtoProtoString( 
    DWORD  dwProtoType,
    DWORD  dwProtoVendor,
    DWORD  dwProtoProto
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsUList[] = {{PROTO_IP_RIP,    STRING_RIP},
                                {PROTO_IP_OSPF,   STRING_OSPF},
                                {PROTO_IP_BOOTP,  STRING_BOOTP},
                                {PROTO_IP_NAT,    STRING_NAT},
                                {PROTO_IP_LOCAL,  STRING_LOCAL},
                                {PROTO_IP_OTHER,  STRING_OTHER},
                                {PROTO_IP_NETMGMT,STRING_NETMGMT},
                                {PROTO_IP_NT_AUTOSTATIC,STRING_NT_AUTOSTATIC},
                                {PROTO_IP_NT_STATIC,    STRING_STATIC},
                                {PROTO_IP_NT_STATIC_NON_DOD,STRING_NONDOD},
#ifdef MS_IP_BGP
                                {PROTO_IP_BGP,    STRING_BGP},
#endif
                               };
    VALUE_STRING  ppsMList[] = {{PROTO_IP_IGMP,  STRING_IGMP},
                               };
    VALUE_STRING  ppsGList[] = {{IP_IN_FILTER_INFO,  STRING_IN_FILTER},
                                {IP_OUT_FILTER_INFO, STRING_OUT_FILTER},
                                {IP_GLOBAL_INFO,     STRING_GLOBAL_INFO},
                                {IP_INTERFACE_STATUS_INFO, STRING_IF_STATUS},
                                {IP_ROUTE_INFO,      STRING_ROUTE_INFO},
                                {IP_PROT_PRIORITY_INFO, STRING_PROT_PRIORITY},
                                {IP_ROUTER_DISC_INFO, STRING_RTRDISC},
                                {IP_DEMAND_DIAL_FILTER_INFO, STRING_DD_FILTER},
                                {IP_MCAST_HEARBEAT_INFO, STRING_MC_HEARTBEAT},
                                {IP_MCAST_BOUNDARY_INFO, STRING_MC_BOUNDARY},
                                {IP_IPINIP_CFG_INFO,     STRING_IPIP},
                                {IP_IFFILTER_INFO,       STRING_IF_FILTER},
                                {IP_MCAST_LIMIT_INFO,    STRING_MC_LIMIT},
                               };
    VALUE_STRING  pps2List[] = {{PROTO_IP_DNS_PROXY,     STRING_DNS_PROXY},
                                {PROTO_IP_DHCP_ALLOCATOR,STRING_DHCP_ALLOCATOR},
                                {PROTO_IP_NAT,           STRING_NAT},
                                {PROTO_IP_DIFFSERV,      STRING_DIFFSERV},
                                {PROTO_IP_VRRP,          STRING_VRRP},
                               };
                                   
    VALUE_STRING *pVS;
    DWORD         dwNum, i;
    DWORD         dwMsgId = 0;

    switch (dwProtoType) {
    case PROTO_TYPE_UCAST:
        pVS   = ppsUList;
        dwNum = sizeof(ppsUList)/sizeof(VALUE_STRING);
        break;

    case PROTO_TYPE_MCAST:
        pVS   = ppsMList;
        dwNum = sizeof(ppsMList)/sizeof(VALUE_STRING);
        break;

    case PROTO_TYPE_MS1:
        pVS   = ppsGList;
        dwNum = sizeof(ppsGList)/sizeof(VALUE_STRING);
        break;
    
    case PROTO_TYPE_MS0:
        pVS   = pps2List;
        dwNum = sizeof(pps2List)/sizeof(VALUE_STRING);
        break;
    
    default:
        dwNum = 0;
    }

    for (i=0; i<dwNum; i++)
    {
        if (dwProtoProto == PROTO_FROM_PROTO_ID(pVS[i].dwValue))
        {
            dwMsgId = pVS[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        if ( pwszStr )
        {
            wcscpy(buff, pwszStr);
            FreeString(pwszStr);
        }
        else
        {
            wsprintf(buff, L"%d", dwProtoProto);
        }
    }
    else
    {
        wsprintf(buff, L"%d", dwProtoProto);
    }

    return buff;
}

DWORD
ShowIpIfProtocols(
    IN LPCWSTR pwszIfName
    )
{
    DWORD            dwNumProto, dwErr, i;
    PBYTE            pby;
    DWORD            dwBlkSize, dwCount;
    RTR_INFO_BLOCK_HEADER *pInfoHdr;
    DWORD            dwProtoType, dwProtoVendor, dwProtoProto;

    dwErr = ValidateInterfaceInfo(pwszIfName, &pInfoHdr, NULL, NULL);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // Do this check just to keep the prefix checker happy
    if (!pInfoHdr)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DisplayMessage(g_hModule, MSG_RTR_INTERFACE_PROTOCOL_HDR);

    DisplayMessage(g_hModule, MSG_IP_PROTOCOL_HDR);

    // Walk pInfo and output a line for each protocol found

    for (i=0; i<pInfoHdr->TocEntriesCount; i++)
    {
        // Extract type, vendorid, and protocolid
        
        dwProtoType   = TYPE_FROM_PROTO_ID(  pInfoHdr->TocEntry[i].InfoType);
        dwProtoVendor = VENDOR_FROM_PROTO_ID(pInfoHdr->TocEntry[i].InfoType);
        dwProtoProto  = PROTO_FROM_PROTO_ID( pInfoHdr->TocEntry[i].InfoType);

        DisplayMessageT(L"%1!-11s! %2!-13s! %3!s!\n",
            GetProtoTypeString(  dwProtoType),
            GetProtoVendorString(dwProtoVendor),
            GetProtoProtoString( dwProtoType, dwProtoVendor, dwProtoProto));
    }

    if (i is 0)
    {
        DisplayMessage(g_hModule, MSG_IP_NO_PROTOCOL);
    }
    
    return NO_ERROR;
}

DWORD
ShowIpProtocol(
    VOID
    )

/*++

Routine Description:

    Displays all the protocols under IP RTR MGR.

Arguments:

    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD            dwNumProto, dwErr, i;
    PBYTE            pby;
    DWORD            dwBlkSize, dwCount;
    RTR_INFO_BLOCK_HEADER *pInfoHdr;
    DWORD            dwProtoType, dwProtoVendor, dwProtoProto;

    dwErr = ValidateGlobalInfo(&pInfoHdr);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    DisplayMessage(g_hModule, MSG_IP_PROTOCOL_HDR);

    // Walk pInfo and output a line for each protocol found

    for (i=0; i<pInfoHdr->TocEntriesCount; i++)
    {
        // Extract type, vendorid, and protocolid
        
        dwProtoType   = TYPE_FROM_PROTO_ID(  pInfoHdr->TocEntry[i].InfoType);
        dwProtoVendor = VENDOR_FROM_PROTO_ID(pInfoHdr->TocEntry[i].InfoType);
        dwProtoProto  = PROTO_FROM_PROTO_ID( pInfoHdr->TocEntry[i].InfoType);

        DisplayMessageT(L"%1!-11s! %2!-13s! %3!s!\n",
            GetProtoTypeString(  dwProtoType),
            GetProtoVendorString(dwProtoVendor),
            GetProtoProtoString( dwProtoType, dwProtoVendor, dwProtoProto));
    }

    if (i is 0)
    {
        DisplayMessage(g_hModule, MSG_IP_NO_PROTOCOL);
    }
    
    return NO_ERROR;
}

DWORD
ListIpInterface(
    VOID
    )

/*++

Routine Description:

    Lists all interfaces under ip

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    DWORD                dwErr;
    DWORD                dwCount, dwTotal, i, dwNumParsed = 0;
    PMPR_INTERFACE_0     pmi0;
    WCHAR                wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    HANDLE               hIfTransport = (HANDLE) NULL,
                         hInterface;

    DisplayMessage(g_hModule, MSG_IP_INTERFACE_HDR);
    
    //
    // No interface name specified. List all interfaces under IP
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);

    if (dwErr isnot NO_ERROR)
    {
        DisplayError(g_hModule, dwErr);

        return dwErr;
    }

    for ( i = 0; i < dwCount; i++)
    {
        // Make sure IP is enabled on this interface

        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            pmi0[i].wszInterfaceName,
                                            &hInterface);

        dwErr = MprConfigInterfaceTransportGetHandle(g_hMprConfig,
                                                     hInterface,
                                                     PID_IP,
                                                     &hIfTransport);

        if (dwErr isnot NO_ERROR)
            continue;

        dwErr = GetInterfaceDescription(pmi0[i].wszInterfaceName,
                                        wszIfDesc,
                                        &dwNumParsed);

        if (!dwNumParsed)
        {
            wcscpy(wszIfDesc, pmi0[i].wszInterfaceName);
        }

        DisplayMessage(g_hModule, MSG_IP_INTERFACE_INFO, wszIfDesc);
    }

    if (dwCount is 0)
    {
        DisplayMessage(g_hModule, MSG_IP_NO_INTERFACE);
    }
    
    return NO_ERROR;
}

DWORD
ShowIpInIpInfo(
    IN DWORD   dwFormat, 
    IN LPCWSTR pwszIfName, 
    IN LPCWSTR pwszQuoted
    )
{
    PIPINIP_CONFIG_INFO     pIpIpInfo;
    WCHAR                   rgwcLocalAddr[ADDR_LENGTH + 1];
    WCHAR                   rgwcRemAddr[ADDR_LENGTH + 1];
    DWORD                   dwBlkSize, dwCount, dwIfType, dwErr;

    // IP-in-IP info

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                          IP_IPINIP_CFG_INFO,
                                          (PBYTE *) &pIpIpInfo,
                                          &dwBlkSize,
                                          &dwCount,
                                          &dwIfType);


    if(dwErr is NO_ERROR)
    {
        ASSERT(dwIfType is ROUTER_IF_TYPE_TUNNEL1);

        IP_TO_WSTR(rgwcLocalAddr, ((PBYTE)&(pIpIpInfo->dwLocalAddress)));
        IP_TO_WSTR(rgwcRemAddr, ((PBYTE)&(pIpIpInfo->dwRemoteAddress)));

        switch (dwFormat) 
        {
        case FORMAT_VERBOSE:
            DisplayMessage(g_hModule,  
                           MSG_RTR_INTERFACE_IPIP_INFO,
                           rgwcLocalAddr,
                           rgwcRemAddr,
                           MAKELONG(MAKEWORD(pIpIpInfo->byTtl, 0x00), 0x0000));
            break;

        // IP-in-IP tunnels need to be added in the interface context in
        // ifmon.dll, not here.  But this is how it works for now!!!  So
        // we'll just dump the command that works.
        case FORMAT_DUMP:
            DisplayMessageT(DMP_IP_ADD_IPIPTUNNEL,
                            pwszQuoted,
                            rgwcLocalAddr,
                            rgwcRemAddr,
                            MAKELONG(MAKEWORD(pIpIpInfo->byTtl,0x00), 0x0000));
            break;

        default:
            break;
        }
    }

    if (pIpIpInfo)
    {
        FREE_BUFFER(pIpIpInfo);
    }

    return dwErr;
}

DWORD
ShowIpInterface(
    IN     DWORD   dwFormat,
    IN     LPCWSTR pwszIfName,
    IN OUT PDWORD  pdwNumRows
    )

/*++

Routine Description:

    Show the interface info for the interface
    The interface info consists of
        AdminStatus
        Router Discovery Info
        Protocols on the interface
    Other information like filters and routes are should using different
    commands

Arguments:

    pwszIfName - Interface name
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                   dwErr;
    WCHAR                   wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PVALUE_STRING           pps;
    DWORD                   dwNumProto, dwBlkSize, dwCount, dwNumParsed;
    DWORD                   dwIfType , i;
    PBYTE                   pby;
    PWCHAR                  pwszStatus, pwszQuoted;
    PWCHAR                  pwszTokenStatus, pwszIfType;
    PINTERFACE_STATUS_INFO  pifStat;

    //
    // Interface status info
    //
 
    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                          IP_INTERFACE_STATUS_INFO,
                                          (PBYTE *) &pifStat,
                                          &dwBlkSize,
                                          &dwCount,
                                          &dwIfType);
        
    if (dwErr != NO_ERROR)
    {
        // DisplayMessage(g_hModule, EMSG_IP_NO_STATUS_INFO);
        return dwErr;
    }

    if (pifStat->dwAdminStatus is IF_ADMIN_STATUS_UP)
    {
        pwszStatus      = MakeString(g_hModule, STRING_ENABLED);
        pwszTokenStatus = TOKEN_VALUE_ENABLE;
    }
    else
    {
        pwszStatus      = MakeString(g_hModule, STRING_DISABLED);
        pwszTokenStatus = TOKEN_VALUE_DISABLE;
    }

    FREE_BUFFER(pifStat);

    // Get description
   
    dwErr = GetInterfaceDescription(pwszIfName,
                                    wszIfDesc,
                                    &dwNumParsed);

    if (!dwNumParsed)
    {
        wcscpy(wszIfDesc, pwszIfName);
    }
   
    if(dwFormat is FORMAT_DUMP)
    {
        pwszQuoted = MakeQuotedString(wszIfDesc);
    }
    else
    {
        pwszQuoted = NULL;
    }
 
    pwszIfType = GetIfTypeString(dwIfType);

    // Display generic interface info

    switch (dwFormat) {
    case FORMAT_VERBOSE:
        DisplayMessage(g_hModule,  
                       MSG_RTR_INTERFACE_HDR, 
                       wszIfDesc);

        DisplayMessage(g_hModule, 
                       MSG_IP_IF_STATUS, 
                       pwszStatus);

        ShowIpIfProtocols(pwszIfName);

        break;

    case FORMAT_TABLE:
        if (*pdwNumRows is 0)
        {
            DisplayMessage(g_hModule, MSG_IP_IF_HEADER);
        }
        DisplayMessage(g_hModule, MSG_IP_IF_ENTRY, pwszStatus, pwszIfType,
                       wszIfDesc);
        break;

    case FORMAT_DUMP:
        DisplayMessageT(DMP_IP_ADD_IF, pwszQuoted, pwszTokenStatus);
        break;
    }
    (*pdwNumRows)++;

    ShowIpInIpInfo(dwFormat, pwszIfName, pwszQuoted);

    FreeQuotedString(pwszQuoted);
    FreeString(pwszStatus);
    
    return NO_ERROR;
}


DWORD
CreateDumpFile(
    IN  LPCWSTR pwszName,
    OUT PHANDLE phFile
    )
{
    HANDLE  hFile;

    *phFile = NULL;

    hFile = CreateFileW(pwszName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if(hFile == INVALID_HANDLE_VALUE)
        return GetLastError();

    *phFile = hFile;

    return NO_ERROR;
}

VOID
DumpIpInformation(
    HANDLE  hFile
    )

/*++

Routine Description:

    Dumps all the IP Router manager information to the given file

Arguments:

    hFile   Handle of file

Return Value:

    None

--*/

{
    DWORD               dwErr, dwCount, dwTotal;
    DWORD               dwNumParsed, i;
    PMPR_INTERFACE_0    pmi0;
    WCHAR               wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    DWORD               dwNumRows = 0;

    // Display dump header

    DisplayMessage(g_hModule, DMP_IP_HEADER_COMMENTS);

    DisplayMessageT(DMP_IP_HEADER);

    //
    // First dump the global information
    //

    ShowIpGlobal(hFile);

    ShowRoutePref(hFile);

    ShowScopes(hFile);

    //
    // Dump the per interface info
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, 
                          &dwCount, 
                          &dwTotal);

    if(dwErr != NO_ERROR)
    {
        DisplayError(g_hModule,
                     dwErr);

        return;
    }

    for(i = 0; i < dwCount; i++)
    {
        ShowIpInterface(FORMAT_DUMP,
                        pmi0[i].wszInterfaceName, &dwNumRows);

        ShowIpIfFilter(hFile,
                       FORMAT_DUMP,
                       pmi0[i].wszInterfaceName, &dwNumRows);

        ShowIpPersistentRoute(hFile,
                              pmi0[i].wszInterfaceName, &dwNumRows);

        ShowBoundaryInfoForInterface(hFile,
                                     pmi0[i].wszInterfaceName,
                                     &dwNumRows);
    }
    
    // Display dump footer

    DisplayMessageT(DMP_POPD);

    DisplayMessage(g_hModule, DMP_IP_FOOTER_COMMENTS);
}

DWORD
UpdateAutoStaticRoutes(
    IN  LPCWSTR pwszIfName
    )

{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\iphandle.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor\ip\ipgetopt.c

Abstract:

     Prototype for the IP get opt functions.

Author:

     Anand Mahalingam    7/10/98
     Dave Thaler        10/26/98

--*/

NS_CONTEXT_DUMP_FN      IpDump;
NS_CONTEXT_SUBENTRY_FN  IpSubEntry;

FN_HANDLE_CMD HandleIpUpdate;
FN_HANDLE_CMD HandleIpReset;
FN_HANDLE_CMD HandleIpUninstall;
FN_HANDLE_CMD HandleIpInstall;

FN_HANDLE_CMD HandleIpAddIfFilter;
FN_HANDLE_CMD HandleIpDelIfFilter;

FN_HANDLE_CMD HandleIpAddRtmRoute;
FN_HANDLE_CMD HandleIpSetRtmRoute;
FN_HANDLE_CMD HandleIpDelRtmRoute;

FN_HANDLE_CMD HandleIpAddPersistentRoute;
FN_HANDLE_CMD HandleIpSetPersistentRoute;
FN_HANDLE_CMD HandleIpDelPersistentRoute;
FN_HANDLE_CMD HandleIpShowPersistentRoute;

FN_HANDLE_CMD HandleIpAddRoutePref;
FN_HANDLE_CMD HandleIpSetRoutePref;
FN_HANDLE_CMD HandleIpDelRoutePref;
FN_HANDLE_CMD HandleIpShowRoutePref;

FN_HANDLE_CMD HandleIpAddInterface;
FN_HANDLE_CMD HandleIpSetInterface;
FN_HANDLE_CMD HandleIpDelInterface;
FN_HANDLE_CMD HandleIpShowInterface;

FN_HANDLE_CMD HandleIpSetIfFilter;
FN_HANDLE_CMD HandleIpShowIfFilter;

FN_HANDLE_CMD HandleIpSetLogLevel;
FN_HANDLE_CMD HandleIpShowLogLevel;

FN_HANDLE_CMD HandleIpShowProtocol;

FN_HANDLE_CMD HandleIpAddIpIpTunnel;
FN_HANDLE_CMD HandleIpSetIpIpTunnel;

FN_HANDLE_CMD HandleIpShowRtmDestinations;
FN_HANDLE_CMD HandleIpShowRtmRoutes;

DWORD
IpAddSetIpIpTunnel(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    );

DWORD
PreHandleCommand(
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,

    IN      TAG_TYPE *pttTags,
    IN      DWORD     dwTagCount,
    IN      DWORD     dwMinArgs,
    IN      DWORD     dwMaxArgs,
    OUT     DWORD    *pdwTagType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\ipip.c ===
#include "precomp.h"

DWORD
AddSetIpIpTunnelInfo(
    IN  LPCWSTR             pwszIfName,
    IN  PIPINIP_CONFIG_INFO pInfo
    )

{
    DWORD   dwErr, dwType = 0;
    WCHAR   rgwcNameBuffer[MAX_INTERFACE_NAME_LEN + 2];
    LPCWSTR pwszGuidName, pwszFriendlyName;
    BOOL    bCreateIf, bCreatedMapping;

    PRTR_INFO_BLOCK_HEADER  pIpInfo;
    MPR_IPINIP_INTERFACE_0  NameInfo;

    dwErr = GetInterfaceInfo(pwszIfName,
                             &pIpInfo,
                             NULL,
                             &dwType);

    if(dwErr is NO_ERROR)
    {
        if(dwType is ROUTER_IF_TYPE_TUNNEL1)
        {
            dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                                IP_IPINIP_CFG_INFO,
                                                (PBYTE)pInfo,
                                                sizeof(IPINIP_CONFIG_INFO),
                                                1);
  
            if(dwErr isnot NO_ERROR)
            { 
                DisplayMessage(g_hModule,
                               EMSG_CANT_SET_IF_INFO,
                               pwszIfName,
                               dwErr);
            }
        }

        FREE_BUFFER(pIpInfo);

        return dwErr;
    }


    if((dwErr isnot ERROR_NO_SUCH_INTERFACE) and
       (dwErr isnot ERROR_TRANSPORT_NOT_PRESENT))
    {
        DisplayMessage(g_hModule,
                       EMSG_CANT_GET_IF_INFO,
                       pwszIfName,
                       dwErr);

        return dwErr;
    }

    //
    // If we get ERROR_NO_SUCH_INTERFACE, we need to create the i/f in
    // the router, as well as adding it to IP
    //

    bCreateIf = (dwErr is ERROR_NO_SUCH_INTERFACE);


    //
    // Figure out if there is no friendly name <-> guid mapping.
    // Even if the interface is not added with the router, there could
    // be turds left in the name map. In case there is a friendly name
    // present, then the IfName passed to us is a GUID.
    //

    
    dwErr = MprConfigGetFriendlyName(g_hMprConfig,
                                     (LPWSTR)pwszIfName, 
                                     rgwcNameBuffer,
                                     sizeof(rgwcNameBuffer));

    if(dwErr is NO_ERROR)
    {
        //
        // name mapping exists,
        //

        pwszGuidName        = pwszIfName;
        pwszFriendlyName    = rgwcNameBuffer;

        bCreatedMapping = FALSE;
    }
    else
    {
        //
        // no such name. this means the IfName passed to us is the
        // friendly name, so create a guid and map this name to it
        //


        if(UuidCreate(&(NameInfo.Guid)) isnot RPC_S_OK)
        {
            return ERROR_CAN_NOT_COMPLETE;
        }

        wcsncpy(NameInfo.wszFriendlyName,
                pwszIfName,
                MAX_INTERFACE_NAME_LEN);

        NameInfo.wszFriendlyName[MAX_INTERFACE_NAME_LEN] = UNICODE_NULL;

        //
        // Set the mapping
        //

        dwErr = MprSetupIpInIpInterfaceFriendlyNameCreate(g_pwszRouter,
                                                          &NameInfo);

        if(dwErr isnot NO_ERROR)
        {
            return dwErr;
        }

        ConvertGuidToString(&(NameInfo.Guid),
                            rgwcNameBuffer);


        pwszGuidName        = rgwcNameBuffer;
        pwszFriendlyName    = pwszIfName;

        bCreatedMapping = TRUE;
    }

    dwErr = CreateInterface(pwszFriendlyName,
                            pwszGuidName,
                            ROUTER_IF_TYPE_TUNNEL1,
                            bCreateIf);

    if(dwErr isnot NO_ERROR)
    {
        DisplayMessage(g_hModule,
                       EMSG_CANT_CREATE_IF,
                       pwszIfName,
                       dwErr);


        if(bCreatedMapping or bCreateIf)
        {
            MprSetupIpInIpInterfaceFriendlyNameDelete(g_pwszRouter,
                                                      &(NameInfo.Guid));
        }

        return dwErr;
    }

    dwErr = IpmontrSetInfoBlockInInterfaceInfo(pwszGuidName,
                                        IP_IPINIP_CFG_INFO,
                                        (PBYTE)pInfo,
                                        sizeof(IPINIP_CONFIG_INFO),
                                        1);

    if(dwErr isnot NO_ERROR)
    {
        DisplayMessage(g_hModule,
                       EMSG_CANT_SET_IF_INFO,
                       pwszIfName,
                       dwErr);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\ipip.h ===
DWORD
AddSetIpIpTunnelInfo(
    IN  LPCWSTR             pwszIfName,
    IN  PIPINIP_CONFIG_INFO pInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\ipmon.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor\ip\showmib.h   

Abstract:

     Prototype for fns called in ipmon.c

Author:

     Anand Mahalingam    7/10/98

--*/

#define MALLOC(x)    HeapAlloc( GetProcessHeap(), 0, x )
#define REALLOC(x,y) HeapReAlloc( GetProcessHeap(), 0, x, y )
#define FREE(x)      HeapFree( GetProcessHeap(), 0, x )

extern HANDLE g_hModule;
extern HANDLE g_hMprConfig; 
extern HANDLE g_hMprAdmin;
extern HANDLE g_hMIBServer;
extern BOOL   g_bCommit;
extern PWCHAR g_pwszRouter;
extern const GUID g_IpGuid;

DWORD
ShowMIB(
    MIB_SERVER_HANDLE    hMIBServer,
    PTCHAR                *pptcArguments,
    DWORD                dwArgCount
    );

DWORD
GetHelperAttributes(
    IN  LPCWSTR                pwszRouter,
    IN  DWORD                  dwIndex,
    OUT PIP_CONTEXT_ENTRY_FN    *ppfnEntryFn,
    OUT PNS_CONTEXT_DUMP_FN     *ppfnDumpFn
    );

enum IpMonCommands
{
    ADD_COMMAND = 0,
    SET_COMMAND,
    DELETE_COMMAND
};

NS_DLL_STOP_FN StopHelperDll;

//
// Misc Macros
//

#define CHECK_ROUTER_RUNNING()                                \
    if  (!IsRouterRunning())                                  \
    {                                                         \
        if (g_pwszRouter)                                     \
        {                                                     \
            DisplayMessage(g_hModule,                         \
                           MSG_IP_REMOTE_ROUTER_NOT_RUNNING,  \
                           g_pwszRouter);                     \
        }                                                     \
        else                                                  \
        {                                                     \
            DisplayMessage(g_hModule,                         \
                           MSG_IP_LOCAL_ROUTER_NOT_RUNNING);  \
        }                                                     \
                                                              \
        return ERROR_SUPPRESS_OUTPUT;                         \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\iphandle.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\ip\iphandle.c

Abstract:

    Fns to get command options

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

#undef EXTRA_DEBUG

#define SHOW_IF_FILTER          0
#define SHOW_INTERFACE          1
#define SHOW_PERSISTENTROUTE    2

extern ULONG g_ulNumTopCmds;
extern ULONG g_ulNumGroups;

extern CMD_GROUP_ENTRY      g_IpCmdGroups[];
extern CMD_ENTRY            g_IpCmds[];

DWORD
PreHandleCommand(
    IN  LPWSTR   *ppwcArguments,
    IN  DWORD     dwCurrentIndex,
    IN  DWORD     dwArgCount,

    IN  TAG_TYPE *pttTags,
    IN  DWORD     dwTagCount,
    IN  DWORD     dwMinArgs,
    IN  DWORD     dwMaxArgs,
    OUT DWORD    *pdwTagType
    )
{
    ZeroMemory(pdwTagType, sizeof(DWORD) * dwMaxArgs);
    
    return PreprocessCommand(g_hModule,
                             ppwcArguments,
                             dwCurrentIndex,
                             dwArgCount,
                             pttTags,
                             dwTagCount,
                             dwMinArgs,
                             dwMaxArgs,
                             pdwTagType);
}

DWORD
HandleIpUpdate(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Updates IP autostatic routes on an interface
    
Arguments:


Return Value:

    NO_ERROR

--*/

{
    TAG_TYPE    rgTags[] = {TOKEN_NAME, TRUE,FALSE};
    DWORD       dwErr, dwSize, dwTagType = -1;
    WCHAR       rgwcIfName[MAX_INTERFACE_NAME_LEN+1];

    if (dwArgCount != 3)
    {
        //
        // Need the name of the interface
        //

        return ERROR_INVALID_SYNTAX;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                        ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        rgTags,
                        sizeof(rgTags)/sizeof(TAG_TYPE),
                        &dwTagType);

    if(dwErr isnot NO_ERROR)
    {
        if(dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    if(dwTagType isnot 0)
    {
        return ERROR_INVALID_SYNTAX;
    }

    dwSize = sizeof(rgwcIfName);

    IpmontrGetIfNameFromFriendlyName(ppwcArguments[dwCurrentIndex],
                              rgwcIfName,
                              &dwSize);

    dwErr = UpdateAutoStaticRoutes(rgwcIfName);

    return dwErr;
}



// (almost) borrowed from netsh\if\utils.c
// compares dwAddress against all valid masks (all 33 of them!) till a match
BOOL ValidMask(DWORD dwAddress)
{
    DWORD i, dwMask;

    dwAddress = ntohl(dwAddress); // dwAddress is in network byte order
    for (i=0, dwMask=0;  i<33; (dwMask = ((dwMask>>1) + 0x80000000)), i++)
    {
        if (dwAddress == dwMask)
            return TRUE;
    }

    return FALSE;
}



DWORD
IpAddDelIfFilter(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )

/*++

Routine Description:

    Gets options for add/del interface filters

Arguments:
    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    bAdd            - To add or to delete

Return Value:

    NO_ERROR
    
--*/

{
    FILTER_INFO        fi;
    DWORD              dwBitVector = 0, dwNumParsed = 0;
    DWORD              dwErr = NO_ERROR,dwRes;
    PDWORD             pdwTagType;
    DWORD              dwNumOpt, dwStatus = (DWORD) -1;
    DWORD              dwNumTags = 11, dwNumArg, i, j, dwFilterType;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    BOOL               bTags = FALSE, bOkay = TRUE;
    TAG_TYPE           pttTags[] = {{TOKEN_NAME,TRUE,FALSE},
                                    {TOKEN_FILTER_TYPE,TRUE,FALSE},
                                    {TOKEN_SOURCE_ADDRESS,TRUE,FALSE},
                                    {TOKEN_SOURCE_MASK,TRUE,FALSE},
                                    {TOKEN_DEST_ADDRESS,TRUE,FALSE},
                                    {TOKEN_DEST_MASK,TRUE,FALSE},
                                    {TOKEN_PROTOCOL,TRUE,FALSE},
                                    {TOKEN_SOURCE_PORT,TRUE,FALSE},
                                    {TOKEN_DEST_PORT,TRUE,FALSE},
                                    {TOKEN_TYPE,TRUE,FALSE},
                                    {TOKEN_CODE,TRUE,FALSE}};

    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    ZeroMemory(&fi, sizeof(fi));
    
    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            dwErr = ERROR_INVALID_SYNTAX; // show usage
        }

        HeapFree(GetProcessHeap(),0,pdwTagType);
        return dwErr;
    }

    bTags = TRUE;        

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 sizeof(wszIfName),
                                 &dwNumParsed);

                // no filters allowed on INTERNAL/LOOPBACK interfaces
                if (!_wcsicmp(wszIfName, L"internal") or
                    !_wcsicmp(wszIfName, L"loopback"))
                {
                    DisplayMessage(g_hModule,
                                   MSG_IP_BAD_INTERFACE_TYPE,
                                   wszIfName);
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                }
                    
                break;
            }

            case 1:
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_INPUT, IP_IN_FILTER_INFO},
                     {TOKEN_VALUE_OUTPUT, IP_OUT_FILTER_INFO},
                     {TOKEN_VALUE_DIAL, IP_DEMAND_DIAL_FILTER_INFO}};

                //
                // Tag FILTERTYPE
                //

                dwErr = MatchEnumTag(g_hModule, 
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE), 
                                     rgEnums,
                                     &dwRes);

                if(dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;
                    dwErr = NO_ERROR;
                    bOkay = FALSE;
                    break;
                }    

                dwFilterType = dwRes;

                break;
            }

            case 2:
            {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], &fi.dwSrcAddr);
                
                if(dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                    break;
                }

                //
                // Get the src mask too.
                //

                if (pdwTagType[i+1] != 3)
                {
                    //
                    // Addr Mask pair not present
                    //
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                dwErr = GetIpAddress(ppwcArguments[i + 1 + dwCurrentIndex], 
                                     &fi.dwSrcMask);

                if ((dwErr is ERROR_INVALID_PARAMETER)  or
                    (!ValidMask(fi.dwSrcMask))          or
                    ((fi.dwSrcAddr & fi.dwSrcMask) isnot fi.dwSrcAddr))
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + 1 + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i + 1]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex + 1]);

                    dwErr = ERROR_INVALID_PARAMETER;

                    i = dwNumArg;

                    break;
                }

                i++;
                
                break;
            }

            case 4 :
            {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &fi.dwDstAddr);
            
                if(dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);
                    
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    dwErr = ERROR_INVALID_PARAMETER;

                    i = dwNumArg;

                    break;
                }

                //
                // Get the dst mask too.
                //

                if (pdwTagType[i+1] != 5)
                {
                    //
                    // Addr Mask pair not present
                    //
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                dwErr = GetIpAddress(ppwcArguments[i + 1 + dwCurrentIndex], 
                                     &fi.dwDstMask);

                
                if ((dwErr is ERROR_INVALID_PARAMETER)  or
                    (!ValidMask(fi.dwDstMask))          or
                    ((fi.dwDstAddr & fi.dwDstMask) isnot fi.dwDstAddr))
                {
                    DisplayMessage(g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + 1 + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i + 1]].pwszTag,
                                    ppwcArguments[i + 1 + dwCurrentIndex]);

                    dwErr = ERROR_INVALID_PARAMETER;

                    i = dwNumArg;

                    break;
                }

                i++;

                break;
            }

            case 6:
            {
                TOKEN_VALUE    rgEnums[] =
                {
                    {TOKEN_VALUE_ANY,       FILTER_PROTO_ANY},
                    {TOKEN_VALUE_TCP,       FILTER_PROTO_TCP},
                    {TOKEN_VALUE_TCP_ESTAB, FILTER_PROTO_TCP},
                    {TOKEN_VALUE_UDP,       FILTER_PROTO_UDP},
                    {TOKEN_VALUE_ICMP,      FILTER_PROTO_ICMP}
                };
                    
                if (MatchEnumTag(g_hModule,
                                 ppwcArguments[i + dwCurrentIndex],
                                 sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                 rgEnums,
                                 &dwRes) != NO_ERROR)
                {
                    //
                    // In this case see if its a valid value
                    //
                    dwRes = wcstoul(ppwcArguments[i + dwCurrentIndex],
                                    NULL,
                                    10);

                    if((dwRes < 1) ||
                       (dwRes > 255))
                    {
                        DispTokenErrMsg(g_hModule, 
                                        MSG_IP_BAD_OPTION_VALUE,
                                        pttTags[pdwTagType[i]].pwszTag,
                                        ppwcArguments[i + dwCurrentIndex]);

                        DisplayMessage( g_hModule,
                                        MSG_IP_BAD_OPTION_ENUMERATION,
                                        pttTags[pdwTagType[i]].pwszTag );
                    
                        for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                        {
                            DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                        }

                        i = dwNumArg;
                        dwErr = NO_ERROR;
                        bOkay = FALSE;
                        break;
                    }
                }

                fi.dwProtocol = dwRes;

                switch (fi.dwProtocol)
                {
                    case FILTER_PROTO_ANY :
                        //
                        // We are done
                        //
                        fi.wSrcPort = fi.wDstPort = 0;
                        
                        break;

                    case FILTER_PROTO_TCP :
                        // TCP and TCP_ESTABLISHED have same protocol number
                        if (!MatchToken(ppwcArguments[i + dwCurrentIndex],
                                        TOKEN_VALUE_TCP))
                        {
                            fi.fLateBound |= TCP_ESTABLISHED_FLAG;
                        }
                        
                        // continue processing as we could for UDP...
                        
                    case FILTER_PROTO_UDP :
                        //
                        // Get the src and dst ports too
                        //
                        
                        if (i + 2 >= dwNumArg)
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }
                            
                        if (bTags &&
                            (pdwTagType[i+1] != 7 || pdwTagType[i+2] != 8))
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }

                        fi.wSrcPort =
                            htons((WORD)wcstoul(ppwcArguments[i + 1 + dwCurrentIndex],
                                          NULL, 
                                          10));

                        fi.wDstPort = 
                            htons((WORD)wcstoul(ppwcArguments[i + 2 + dwCurrentIndex],
                                          NULL, 
                                          10));

                        i += 2;

                        break;

                    case FILTER_PROTO_ICMP :

                        //
                        // Get the src and dst ports too
                        //

                        if (i + 2 >= dwNumArg)
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }

                        // src and dest ports acted upon as type and code
                        if (bTags &&
                            (pdwTagType[i+1] != 7 || pdwTagType[i+2] != 8) &&
                            (pdwTagType[i+1] != 9 || pdwTagType[i+2] != 10))
                        {
                            dwErr = ERROR_INVALID_SYNTAX;
                            i = dwNumArg;
                            break;
                        }

                        fi.wSrcPort = (BYTE)wcstoul(ppwcArguments[i + 1 + dwCurrentIndex], NULL, 10);

                        fi.wDstPort = (BYTE)wcstoul(ppwcArguments[i + 2 + dwCurrentIndex], NULL, 10);

                        i += 2;

                        break;


                    default:
                    {
                        //    
                        // any 'other' protocol
                        //
                        fi.wSrcPort = fi.wDstPort = 0;
                        break;
                    }   
                }                  

                break;
            }
            
            default:
            {
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }

    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    //
    // Make sure all parameters are present
    //

    if ( !pttTags[0].bPresent ||
         !pttTags[1].bPresent ||
         !pttTags[2].bPresent ||
         !pttTags[3].bPresent ||
         !pttTags[4].bPresent ||
         !pttTags[5].bPresent ||
         !pttTags[6].bPresent )
    {
        DisplayMessage(g_hModule, MSG_CANT_FIND_EOPT);

        return ERROR_INVALID_SYNTAX;
    }
         
    dwErr = AddDelFilterInfo(fi,
                             wszIfName,
                             dwFilterType,
                             bAdd);

    return dwErr;
}

DWORD
HandleIpAddIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Gets options for add interface filters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    return IpAddDelIfFilter(ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            TRUE);
    
}

DWORD
HandleIpDelIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Gets options for del interface filters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    return IpAddDelIfFilter(ppwcArguments,
                            dwCurrentIndex,
                            dwArgCount,
                            FALSE);
}

DWORD
IpAddSetDelRtmRoute(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCommand
    )

/*++

Routine Description:

    Gets options for add/del routes over interfaces.
    These operations are performed directly to RTM
    and do not involve the registry. As persistence
    is not involved, we need the router to be running.

Arguments:
    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    dwCommand       - To add, set, or delete

Return Value:

    NO_ERROR
    
--*/

{
    INTERFACE_ROUTE_INFO route;
    DWORD              dwNumParsed, dwErr, dwRes;
    DWORD              dwNumOpt, dwStatus = (DWORD) -1;
    DWORD              dwNumArg, i;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    TAG_TYPE           pttTags[] = {{TOKEN_DEST,TRUE,FALSE},
                                    {TOKEN_MASK,FALSE,FALSE},
                                    {TOKEN_NAMEINDEX,FALSE,FALSE},
                                    {TOKEN_NHOP,FALSE,FALSE},
                                    {TOKEN_PREFERENCE,FALSE,FALSE},
                                    {TOKEN_METRIC,FALSE,FALSE},
                                    {TOKEN_VIEW,FALSE,FALSE}};
    enum idx {DEST, MASK, NAMEINDEX, NHOP, PREFERENCE, METRIC, VIEW};
    DWORD              pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD              dwMaxArgs;
    DWORD              dwIfClass;
    DWORD              dwFlags;
    PINTERFACE_ROUTE_INFO pTable = NULL;

    //
    // We can add non persistent routes only if router is running
    //

    CHECK_ROUTER_RUNNING();

    ZeroMemory(&route,
               sizeof(route));

    route.dwRtInfoProto   = PROTO_IP_NETMGMT; // default proto
    route.dwRtInfoPreference = 0; // default preference = protocol default
    route.dwRtInfoMetric1 = 1; // default metric
    route.dwRtInfoMetric2 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoMetric3 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // At this point, the arg array contains only values (either because
    // the tags werent present, or because that info has now been split out)
    // So we go through each of the each of the arguments, look up its tag
    // type in the tag array, switch on the type of tag it is and then
    // process accordingly.
    //
    
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
        case DEST: // DEST
        {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &route.dwRtInfoDest,
                                    &route.dwRtInfoMask);
                break;
        }

        case MASK: // MASK
        {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &route.dwRtInfoMask);
                break;
        }

        case NAMEINDEX : // INDEX or NAME
        {
            //
            // If it starts with '0x', this is a hex index
            //

            if ((ppwcArguments[i + dwCurrentIndex][0] == L'0') &&
                (ppwcArguments[i + dwCurrentIndex][1] == L'x'))
            {
                route.dwRtInfoIfIndex = 
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                        NULL,
                        16);
            }
            else
            {
                route.dwRtInfoIfIndex = 
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                        NULL,
                        10);
            }

            if (route.dwRtInfoIfIndex == 0)
            {
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 sizeof(wszIfName),
                                 &dwNumParsed);

                if (!dwNumParsed)
                {
                    DisplayMessage(g_hModule, EMSG_CANT_MATCH_NAME);
                    return ERROR_INVALID_PARAMETER;
                }
            }

            break;
        }

        case NHOP: // NHOP
        {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &route.dwRtInfoNextHop);
                break;
        }

        case PREFERENCE:
        {
                route.dwRtInfoPreference =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case METRIC: // METRIC
        {
                route.dwRtInfoMetric1 =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case VIEW:
        {
            TOKEN_VALUE rgMaskEnums[] = {
                { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                  |RTM_VIEW_MASK_MCAST } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &route.dwRtInfoViewSet);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;

                    return ERROR_INVALID_PARAMETER;
                }

                break;
        }
        }
    }

    if (dwErr)
    {
        return dwErr;
    }

    if (route.dwRtInfoDest & ~route.dwRtInfoMask)
    {
        // Mask contains bits not in address
        DisplayMessage(g_hModule, EMSG_PREFIX_ERROR);
        return ERROR_INVALID_PARAMETER;
    }

    if (!pttTags[NAMEINDEX].bPresent)
    {
        //
        // Neither NAME nor INDEX - adding with a nexthop
        //

        PMIB_IPADDRTABLE AddrTable;
        PMIB_IPADDRROW   AddrEntry;
        MIB_OPAQUE_QUERY Query;
        PMIB_OPAQUE_INFO Info;
        DWORD            dwQuerySize;
        DWORD            dwEntrySize;
        INT              iFirstMatch;
        UINT             i;

        if (!pttTags[NHOP].bPresent)
        {
            DisplayMessage(g_hModule, EMSG_CANT_FIND_NAME_OR_NHOP);
            return ERROR_INVALID_SYNTAX;
        }

        //
        // Search for the interface that matches nexthop
        //

        dwQuerySize = sizeof(MIB_OPAQUE_QUERY) - sizeof(DWORD);

        Query.dwVarId = IP_ADDRTABLE;

        dwErr = MibGet(PID_IP,
                       IPRTRMGR_PID,
                       (PVOID) &Query,
                       dwQuerySize,
                       (PVOID *) &Info,
                       &dwEntrySize);

        if (dwErr != NO_ERROR)
        {
            DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwErr);
            return ERROR_SUPPRESS_OUTPUT;
        }
        
        if (Info is NULL)
        {
            DisplayMessage(g_hModule, EMSG_CANT_FIND_INDEX);
            return ERROR_INVALID_PARAMETER;
        }
            
        AddrTable = (PMIB_IPADDRTABLE)Info->rgbyData;

        iFirstMatch = -1;

        for (i = 0; i < AddrTable->dwNumEntries; i++)
        {
            AddrEntry = &AddrTable->table[i];

            if ((route.dwRtInfoNextHop & AddrEntry->dwMask) ==
                (AddrEntry->dwAddr & AddrEntry->dwMask))
            {
                if (iFirstMatch != -1)
                {
                    //
                    // We already matched an interface
                    // [Ambiguous next hop description]
                    //

                    MprAdminMIBBufferFree((PVOID)Info);
                    DisplayMessage(g_hModule, EMSG_AMBIGUOUS_INDEX_FROM_NHOP);
                    return ERROR_INVALID_PARAMETER;
                }

                iFirstMatch = i;
            }
        }
            
        if (iFirstMatch == -1)
        {
            //
            // Could not find the direct nexthop
            //

            MprAdminMIBBufferFree((PVOID)Info);
            DisplayMessage(g_hModule, EMSG_CANT_FIND_INDEX);
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Found the interface used to reach nexthop
        //

        route.dwRtInfoIfIndex = AddrTable->table[iFirstMatch].dwIndex;

        MprAdminMIBBufferFree((PVOID)Info);
    }

    if (route.dwRtInfoIfIndex)
    {
        //
        // Check if this index has a public exported name
        //

        GetGuidFromIfIndex(g_hMIBServer,
                           route.dwRtInfoIfIndex,
                           wszIfName,
                           MAX_INTERFACE_NAME_LEN);
        //
        // We proceed and see if we can still add/set/del
        //
    }
     
    if (wszIfName[0] != L'\0')
    {
        //
        // NAME specified, or derived from INDEX above
        //
            
        dwErr = GetInterfaceClass(wszIfName, &dwIfClass);

        //
        // If we get an error, we will skip remaining
        // checks which will be performed by iprtrmgr
        //

        if (dwErr == NO_ERROR)
        {
            if (dwIfClass is IFCLASS_LOOPBACK)
            {
                return ERROR_INVALID_SYNTAX;
            }

            if (!pttTags[NHOP].bPresent)
            {
                // Make sure interface is p2p
                if (dwIfClass isnot IFCLASS_P2P)
                {
                    DisplayMessage(g_hModule, EMSG_NEED_NHOP);
                    return ERROR_INVALID_PARAMETER;
                }
            }
        }            
    }

    //
    // If it is a set, we should not overwrite things not specified
    //

    dwFlags = ALL_FIELDS_SPECIFIED;

    if (dwCommand == SET_COMMAND)
    {
        if (!pttTags[PREFERENCE].bPresent) dwFlags |= PREF_NOT_SPECIFIED;
        if (!pttTags[METRIC].bPresent)     dwFlags |= METRIC_NOT_SPECIFIED;
        if (!pttTags[VIEW].bPresent)       dwFlags |= VIEW_NOT_SPECIFIED;
    }

    return AddSetDelRtmRouteInfo(&route, wszIfName, dwCommand, dwFlags);
}

DWORD
HandleIpAddRtmRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelRtmRoute(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               ADD_COMMAND);
}

DWORD
HandleIpDelRtmRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelRtmRoute(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               DELETE_COMMAND);
}

DWORD
HandleIpSetRtmRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelRtmRoute(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SET_COMMAND);
}

DWORD
IpAddSetDelPersistentRoute(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwCommand
    )

/*++

Routine Description:

    Gets options for add/del routes over interfaces.
    These operations are performed directly to the
    registry and so these routes are persistent. If
    the router is running, they go into the RTM too.

Arguments:
    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    dwCommand       - To add, set, or delete

Return Value:

    NO_ERROR
    
--*/

{
    INTERFACE_ROUTE_INFO route;
    DWORD              dwNumParsed, dwErr, dwRes;
    DWORD              dwNumOpt, dwStatus = (DWORD) -1;
    DWORD              dwNumArg, i;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    TAG_TYPE           pttTags[] = {{TOKEN_DEST,TRUE,FALSE},
                                    {TOKEN_MASK,FALSE,FALSE},
                                    {TOKEN_NAME,FALSE,FALSE},
                                    {TOKEN_NHOP,FALSE,FALSE},
                                    {TOKEN_PROTOCOL,FALSE,FALSE},
                                    {TOKEN_PREFERENCE,FALSE,FALSE},
                                    {TOKEN_METRIC,FALSE,FALSE},
                                    {TOKEN_VIEW,FALSE,FALSE}};
    enum idx {DEST, MASK, NAME, NHOP, PROTO, PREFERENCE, METRIC, VIEW};
    DWORD              pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD              dwMaxArgs;
    DWORD              dwIfClass;
    DWORD              dwFlags;
    PINTERFACE_ROUTE_INFO pTable = NULL;

    ZeroMemory(&route,
               sizeof(route));

    route.dwRtInfoProto   = PROTO_IP_NT_STATIC_NON_DOD; // default proto
    route.dwRtInfoPreference = 0; // default preference = protocol default
    route.dwRtInfoMetric1 = 1; // default metric
    route.dwRtInfoMetric2 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoMetric3 = MIB_IPROUTE_METRIC_UNUSED;
    route.dwRtInfoViewSet = RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    //
    // At this point, the arg array contains only values (either because
    // the tags werent present, or because that info has now been split out)
    // So we go through each of the each of the arguments, look up its tag
    // type in the tag array, switch on the type of tag it is and then
    // process accordingly.
    //
    
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
        case DEST: // DEST
        {
                dwErr = GetIpPrefix(ppwcArguments[i + dwCurrentIndex], 
                                    &route.dwRtInfoDest,
                                    &route.dwRtInfoMask);
                break;
        }

        case MASK: // MASK
        {
                dwErr = GetIpMask(ppwcArguments[i + dwCurrentIndex], 
                                  &route.dwRtInfoMask);
                break;
        }

        case NAME : // NAME
        {
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 sizeof(wszIfName),
                                 &dwNumParsed);
                break;
        }

        case NHOP: // NHOP
        {
                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &route.dwRtInfoNextHop);
                break;
        }

        case PROTO : // PROTO
        {
                TOKEN_VALUE    rgEnums[] = 
                {/*{TOKEN_VALUE_AUTOSTATIC, PROTO_IP_NT_AUTOSTATIC},*/
                 {TOKEN_VALUE_STATIC, PROTO_IP_NT_STATIC},
                 {TOKEN_VALUE_NONDOD, PROTO_IP_NT_STATIC_NON_DOD}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwRes);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule,
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    return NO_ERROR;
                }    

                route.dwRtInfoProto = dwRes;
                
                break;
        }

        case PREFERENCE:
        {
                route.dwRtInfoPreference =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case METRIC:
        {
                route.dwRtInfoMetric1 =
                    wcstoul(ppwcArguments[i + dwCurrentIndex],
                             NULL,
                             10);
                break;
        }

        case VIEW:
        {
            TOKEN_VALUE rgMaskEnums[] = {
                { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                                        |RTM_VIEW_MASK_MCAST } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &route.dwRtInfoViewSet);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;

                    return ERROR_INVALID_PARAMETER;
                }

                break;
        }
        }
    }

    if (dwErr)
    {
        return dwErr;
    }

    if (route.dwRtInfoDest & ~route.dwRtInfoMask)
    {
        // Mask contains bits not in address
        DisplayMessage(g_hModule, EMSG_PREFIX_ERROR);
        return ERROR_INVALID_PARAMETER;
    }

    if (!pttTags[NAME].bPresent)
    {
        // Need if name to add persistent route
        DisplayMessage(g_hModule, EMSG_CANT_FIND_NAME);
        return ERROR_INVALID_SYNTAX;
    }
     
    dwErr = GetInterfaceClass(wszIfName, &dwIfClass);

    if (dwErr)
    {
        DisplayMessage(g_hModule, EMSG_CANT_GET_IF_INFO,
                       wszIfName,
                       dwErr);

        return ERROR_INVALID_PARAMETER;
    }
            
    if (dwIfClass is IFCLASS_LOOPBACK)
    {
        return ERROR_INVALID_SYNTAX;
    }

    if (!pttTags[NHOP].bPresent)
    {
        // Make sure interface is p2p
        if (dwIfClass isnot IFCLASS_P2P)
        {
            DisplayMessage(g_hModule, EMSG_NEED_NHOP);
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (dwIfClass is IFCLASS_P2P)
    { 
        if (!pttTags[PROTO].bPresent)
        {
            // if not explicitly specified, change protocol to static
            route.dwRtInfoProto = PROTO_IP_NT_STATIC; // default proto
        }
    } 
    else
    {
        // make sure we didn't try to set static on a non-P2P interface
        if (route.dwRtInfoProto is PROTO_IP_NT_STATIC)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If it is a set, we should not overwrite things not specified
    //

    dwFlags = ALL_FIELDS_SPECIFIED;

    if (dwCommand == SET_COMMAND)
    {
        if (!pttTags[PREFERENCE].bPresent) dwFlags |= PREF_NOT_SPECIFIED;
        if (!pttTags[METRIC].bPresent)     dwFlags |= METRIC_NOT_SPECIFIED;
        if (!pttTags[VIEW].bPresent)       dwFlags |= VIEW_NOT_SPECIFIED;
    }

    return AddSetDelPersistentRouteInfo(&route, wszIfName, dwCommand, dwFlags);
}


DWORD
HandleIpAddPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelPersistentRoute(ppwcArguments,
                                      dwCurrentIndex,
                                      dwArgCount,
                                      ADD_COMMAND);
}

DWORD
HandleIpDelPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelPersistentRoute(ppwcArguments,
                                      dwCurrentIndex,
                                      dwArgCount,
                                      DELETE_COMMAND);
}

DWORD
HandleIpSetPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    return IpAddSetDelPersistentRoute(ppwcArguments,
                                      dwCurrentIndex,
                                      dwArgCount,
                                      SET_COMMAND);
}

DWORD
HandleIpAddRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

    Gets options for adding route preferences

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{

    PPROTOCOL_METRIC            ppm;
    DWORD                       dwBitVector = 0, dwNumPref,dwPrefIndex;
    DWORD                       dwErr = NO_ERROR,dwRes;
    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 2, dwNumArg, i, dwAddr;
    TAG_TYPE                    pttTags[] = {{TOKEN_PROTOCOL, TRUE,FALSE},
                                             {TOKEN_PREF_LEVEL, TRUE,FALSE}};


    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }
 
    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);

        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            dwErr = ERROR_INVALID_SYNTAX; // show usage
        }

        return dwErr;
    }

    dwNumPref = dwNumArg / 2 + dwNumArg % 2;

    ppm = HeapAlloc(GetProcessHeap(),
                    0,
                    dwNumPref * sizeof(PROTOCOL_METRIC));

    if (ppm is NULL)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);

        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    for ( i = 0, dwPrefIndex = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0:
            {
                //
                // TAG = PROTOCOL
                //

                dwRes = MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                if (dwRes == (DWORD) -1)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
 
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                ppm[dwPrefIndex].dwProtocolId = dwRes;

                //
                // Get the metric too
                //

                if (pdwTagType[i+1] == 1)
                {
                    ppm[dwPrefIndex].dwMetric =
                        wcstoul(ppwcArguments[i + 1 +dwCurrentIndex],NULL,10);

                    if (ppm[dwPrefIndex].dwMetric==0
                        && wcscmp(ppwcArguments[i + 1 +dwCurrentIndex], L"0")!=0)
                    {
                        dwErr = ERROR_INVALID_SYNTAX;
                        i = dwNumArg;
                        break;
                    }

                    i++;
                    dwPrefIndex++;
                }
                else
                {
                    //
                    // the range is not an addr mask pair.
                    // So ignore the addr (i.e. don't increment dwRangeIndex)
                    //
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                break;
            }

            default :
            {
                  
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (dwPrefIndex)
    {
        //
        // Add route pref
        //

        dwRes = AddDeleteRoutePrefLevel(ppm,
                                        dwPrefIndex,
                                        TRUE);
            
    }

    HeapFree(GetProcessHeap(), 0, ppm);

    return dwErr;
}

DWORD
HandleIpDelRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Gets options for deleting route preferences

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    PPROTOCOL_METRIC            ppm;
    DWORD                       dwBitVector = 0, dwNumPref,dwPrefIndex;
    DWORD                       dwErr = NO_ERROR,dwRes;
    TAG_TYPE                    pttTags[] = {{TOKEN_PROTOCOL,TRUE,FALSE}};

    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 1, dwNumArg, i, dwAddr;

    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            dwErr = ERROR_INVALID_SYNTAX; // show usage
        }
        return dwErr;
    }

    dwNumPref = dwNumArg;

    ppm = HeapAlloc(GetProcessHeap(),
                    0,
                    dwNumPref * sizeof(PROTOCOL_METRIC));

    if (ppm is NULL)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);

        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    for ( i = 0, dwPrefIndex = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0:
            {

                //
                // TAG = PROTOCOL
                //

                dwRes = MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                if (dwRes == (DWORD) -1)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
 
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                ppm[dwPrefIndex++].dwProtocolId = dwRes;

                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (dwPrefIndex)
    {
        //
        // Add route pref
        //

        dwRes = AddDeleteRoutePrefLevel(ppm,
                                        dwPrefIndex,
                                        FALSE);
            
    }

    HeapFree(GetProcessHeap(), 0, ppm);

    return dwErr;
}

DWORD
HandleIpSetRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Gets options for setting route preferences

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    PROTOCOL_METRIC             pm;
    DWORD                       dwBitVector = 0, dwNumPref,dwPrefIndex;
    DWORD                       dwErr = NO_ERROR,dwRes;
    TAG_TYPE                    pttTags[] = {{TOKEN_PROTOCOL, TRUE,FALSE},
                                             {TOKEN_PREF_LEVEL, TRUE,FALSE}};
    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 2, dwNumArg, i, dwAddr;


    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX; // show usage
        } 
        return dwErr;
    }

    for ( i = 0, dwPrefIndex = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // PROTOCOL

                dwRes = MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                if (dwRes == (DWORD) -1)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwNumArg;
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                pm.dwProtocolId = dwRes;

                //
                // Get the metric too
                //

                if (pdwTagType[i+1] == 1)
                {
                    pm.dwMetric =
                        wcstoul(ppwcArguments[i + 1 +dwCurrentIndex],NULL,10);

                    if (pm.dwMetric==0 
                        && wcscmp(ppwcArguments[i + 1 +dwCurrentIndex], L"0")!=0)
                    {
                        dwErr = ERROR_INVALID_SYNTAX;
                        i = dwNumArg;
                        break;
                    }

                    i++;
                    dwPrefIndex++;
                }
                else
                {
                    dwErr = ERROR_INVALID_SYNTAX;
                    i = dwNumArg;
                    break;
                }

                break;

            default :
                i = dwNumArg;
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    dwErr = SetRoutePrefLevel(pm);

    return dwErr;
}


DWORD
HandleIpSetLogLevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Gets options for setting global parameter namely logging level

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    DWORD                       dwErr = NO_ERROR;
    TAG_TYPE                    pttTags[] = {{TOKEN_LOG_LEVEL,TRUE,FALSE}};
    PDWORD                      pdwTagType;
    DWORD                       dwNumTags = 1, dwNumArg, i, dwAddr;
    DWORD                       dwLoggingLevel = (DWORD) -1;
    BOOL                        bOkay = TRUE;
    
    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // LOGLEVEL
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_NONE, IPRTR_LOGGING_NONE},
                     {TOKEN_VALUE_ERROR, IPRTR_LOGGING_ERROR},
                     {TOKEN_VALUE_WARN, IPRTR_LOGGING_WARN},
                     {TOKEN_VALUE_INFO, IPRTR_LOGGING_INFO}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwLoggingLevel);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<4; i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = NO_ERROR;
    
                    bOkay = FALSE;

                    break;
                }

                break;
            }

            default :
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }


    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    dwErr = SetGlobalConfigInfo(dwLoggingLevel);

    return dwErr;
}

DWORD
HandleIpSetIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

    Gets options for setting interface filter parameters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    DWORD              dwNumParsed = 0;
    DWORD              dwErr = NO_ERROR,dwRes;
    TAG_TYPE           pttTags[] = {{TOKEN_NAME,TRUE,FALSE},
                                    {TOKEN_FILTER_TYPE,FALSE,FALSE},
                                    {TOKEN_ACTION,FALSE,FALSE},
                                    {TOKEN_FRAGCHECK,FALSE,FALSE}};
    PDWORD             pdwTagType;
    DWORD              dwNumOpt;
    DWORD              dwNumTags = 4, dwNumArg, i, j;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD              dwFilterType, dwAction;
    BOOL               bFragCheck, bOkay = TRUE;
    
    if (dwCurrentIndex >= dwArgCount)
    {
        //
        // No arguments specified
        //

        return ERROR_SHOW_USAGE;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    pdwTagType = HeapAlloc(GetProcessHeap(),
                           0,
                           dwNumArg * sizeof(DWORD));

    if (pdwTagType is NULL)
    {
        DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    dwErr = MatchTagsInCmdLine(g_hModule, ppwcArguments,
                        dwCurrentIndex,
                        dwArgCount,
                        pttTags,
                        dwNumTags,
                        pdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        HeapFree(GetProcessHeap(),0,pdwTagType);
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX; // show usage
        }
        return dwErr;
    }

    for ( i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 sizeof(wszIfName),
                                 &dwNumParsed);
    
                // no filters allowed on INTERNAL/LOOPBACK interfaces
                if (!_wcsicmp(wszIfName, L"internal") or
                    !_wcsicmp(wszIfName, L"loopback"))
                {
                    DisplayMessage(g_hModule,
                                   MSG_IP_BAD_INTERFACE_TYPE,
                                   wszIfName);
                    dwErr = ERROR_INVALID_PARAMETER;
                    i = dwNumArg;
                }
                    
                break;
            }

            case 1:
            {
                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_INPUT, IP_IN_FILTER_INFO},
                     {TOKEN_VALUE_OUTPUT, IP_OUT_FILTER_INFO},
                     {TOKEN_VALUE_DIAL, IP_DEMAND_DIAL_FILTER_INFO}};

                //
                // Tag TYPE
                //

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwFilterType);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;
                    bOkay = FALSE;
                    dwErr = NO_ERROR;
                    break;
                }    

                break;
            }

            case 2:
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_DROP, PF_ACTION_DROP},
                     {TOKEN_VALUE_FORWARD, PF_ACTION_FORWARD}};

                //
                // Tag ACTION
                //

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwAction);

                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = NO_ERROR;
                    bOkay = FALSE;

                    break;
                }    

                break;
            }

            case 3:
            {
                TOKEN_VALUE    rgEnums[] =
                    {{TOKEN_VALUE_ENABLE, TRUE},
                     {TOKEN_VALUE_DISABLE, FALSE}};

                //
                // TAG = FRAGCHK
                //

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwRes);

                
                if (dwErr != NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = NO_ERROR;
                    bOkay = FALSE;

                    break;
                }    

                bFragCheck = (dwRes) ? TRUE : FALSE;
                
                break;
            }

            default:
            {
                i = dwNumArg;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    HeapFree(GetProcessHeap(), 0, pdwTagType);

    switch(dwErr)
    {
        case NO_ERROR :
            break;

        default:
            return dwErr;
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    if (!pttTags[0].bPresent ||
        (pttTags[1].bPresent & !pttTags[2].bPresent) ||
        (!pttTags[1].bPresent & pttTags[2].bPresent))
    {
       return ERROR_INVALID_SYNTAX; // show usage
    }

    if (pttTags[3].bPresent)
    {
        dwErr = SetFragCheckInfo(wszIfName, bFragCheck);
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    if (pttTags[1].bPresent)
    {
        dwErr = SetFilterInfo(wszIfName, dwFilterType, dwAction);
    }

    return dwErr;
}

DWORD
IpAddSetDelInterface(
    PWCHAR    *ppwcArguments,
    DWORD      dwCurrentIndex,
    DWORD      dwArgCount,
    DWORD      dwAction
    )

/*++

Routine Description:

    Gets options for setting interface parameters

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{
    DWORD              dwBitVector = 0, dwNumParsed = 0;
    DWORD              dwErr = NO_ERROR, dwRes;
    TAG_TYPE           pttTags[] = {
        {TOKEN_NAME,             TRUE, FALSE},
        {TOKEN_STATUS,           FALSE,FALSE}};
    BOOL               bOkay = TRUE;
    DWORD              pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD              dwNumOpt, dwStatus = (DWORD) -1;
    DWORD              dwNumTags = 2, dwNumArg, i, j;
    WCHAR              wszIfName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD   dwMaxArgs = (dwAction is DELETE_COMMAND)? 1 
                         : sizeof(pttTags)/sizeof(TAG_TYPE);

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              1,
                              dwMaxArgs,
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwNumArg = dwArgCount - dwCurrentIndex;

    for (i=0; i<dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0: // NAME
            {
                GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                 wszIfName,
                                 sizeof(wszIfName),
                                 &dwNumParsed);
                break;
            }

            case 1: // STATE
            {
                TOKEN_VALUE    rgEnums[] = 
                    {{TOKEN_VALUE_ENABLE, IF_ADMIN_STATUS_UP},
                     {TOKEN_VALUE_DISABLE, IF_ADMIN_STATUS_DOWN}};

                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                     rgEnums,
                                     &dwStatus);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg(g_hModule, 
                                    MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DisplayMessage( g_hModule,
                                    MSG_IP_BAD_OPTION_ENUMERATION,
                                    pttTags[pdwTagType[i]].pwszTag );
                    
                    for (i=0; i<sizeof(rgEnums)/sizeof(TOKEN_VALUE); i++) 
                    {
                        DisplayMessageT( L"  %1!s!\n", rgEnums[i].pwszToken );
                    }

                    i = dwNumArg;

                    dwErr = NO_ERROR;
                    bOkay = FALSE;

                    break;
                }    

                break;
            }
        }
    }

    if (!bOkay)
    {
        return NO_ERROR;
    }

    if (dwAction is DELETE_COMMAND)
    {
        dwErr = DeleteInterfaceInfo(wszIfName);
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }
        return ERROR_OKAY;
    }

    if (dwStatus is IF_ADMIN_STATUS_DOWN)
    {
        DWORD dwIfType;

        // Make sure we support disabling this interface

        dwErr = GetInterfaceInfo(wszIfName, NULL, NULL, &dwIfType);

        if (dwErr == NO_ERROR)
        {
            if (dwIfType isnot ROUTER_IF_TYPE_DEDICATED)
            {
                DisplayMessage( g_hModule, MSG_IP_CANT_DISABLE_INTERFACE );
                return ERROR_SUPPRESS_OUTPUT;
            }
        }
    }

    if (dwAction is ADD_COMMAND)
    {
        dwErr = AddInterfaceInfo(wszIfName);
    }

    dwErr = UpdateInterfaceStatusInfo(dwAction,
                                      wszIfName,
                                      dwStatus);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    return ERROR_OKAY;
}

DWORD
HandleIpAddInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

{
    return IpAddSetDelInterface( ppwcArguments, 
                                 dwCurrentIndex, 
                                 dwArgCount, 
                                 ADD_COMMAND);
}

DWORD
HandleIpSetInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

{
    return IpAddSetDelInterface( ppwcArguments, 
                                 dwCurrentIndex, 
                                 dwArgCount, 
                                 SET_COMMAND );
}

DWORD
HandleIpDelInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

{
    return IpAddSetDelInterface( ppwcArguments, 
                                 dwCurrentIndex, 
                                 dwArgCount, 
                                 DELETE_COMMAND);
}

DWORD
HandleIpShowRoutePref(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:


Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    //
    // No options expected
    //

    return ShowRoutePref(NULL);
}


DWORD
HandleIpShowLogLevel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    //
    // No options expected
    //

    if (dwCurrentIndex != dwArgCount)
    {
        return ERROR_SHOW_USAGE;
    }
    
    return ShowIpGlobal(NULL);
}

DWORD
HandleIpShowProtocol(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/
{
    //
    // No options expected
    //

    return ShowIpProtocol();
}

DWORD
IpShowSingleInterfaceInfo(
    IN     LPCWSTR   pwszInterfaceName,
    IN     DWORD     dwInfoType,
    IN     DWORD     dwFormat,
    IN OUT PDWORD    pdwNumRows
    )
{
    switch(dwInfoType)
    {
        case SHOW_IF_FILTER:
        {
            return ShowIpIfFilter(NULL, dwFormat, pwszInterfaceName, pdwNumRows);
        }

        case SHOW_INTERFACE:
        {
            return ShowIpInterface(dwFormat, pwszInterfaceName, pdwNumRows);
        }

        case SHOW_PERSISTENTROUTE:
        {
            return ShowIpPersistentRoute(NULL, pwszInterfaceName, pdwNumRows);
        }

        default:
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
}

DWORD
IpShowInterfaceInfo(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwInfoType
    )
/*++

Routine Description:

    Gets options for showing various interface information
    
Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 
    dwInfoType      - The type of info to display

Return Value:

    NO_ERROR
    
--*/
{    
    DWORD       dwErr, dwTotal;
    TAG_TYPE    pttTags[] = {{TOKEN_NAME,FALSE,FALSE}};
    WCHAR       wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    DWORD       rgdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD       dwCount, i, j, dwNumOpt;
    DWORD       dwNumTags = 1, dwNumArg, dwNumParsed;
    DWORD       dwSize, dwRes, dwNumRows = 0;
    PMPR_INTERFACE_0 pmi0;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              1,
                              rgdwTagType );
                              
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // If interface specified, show info for specified interface only.

    for (i=0; i<dwArgCount-dwCurrentIndex; i++)
    {
        switch (rgdwTagType[i])
        {
            case 0: // NAME
            {
                GetInterfaceName( ppwcArguments[i + dwCurrentIndex],
                                  wszInterfaceName,
                                  sizeof(wszInterfaceName),
                                  &dwNumParsed);

                dwErr = IpShowSingleInterfaceInfo(wszInterfaceName, 
                                                  dwInfoType,
                                                  FORMAT_VERBOSE,
                                                  &dwNumRows);

                if (!dwNumRows)
                {
                    DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
                }

                return dwErr;
            }
        }
    }

    // No Interface specified.  Enumerate interfaces and show
    // info for each interface.

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    for (i=0; i<dwCount && dwErr is NO_ERROR; i++)
    {
        dwErr = IpShowSingleInterfaceInfo( pmi0[i].wszInterfaceName, 
                                           dwInfoType,
                                           FORMAT_TABLE,
                                           &dwNumRows );
        if (dwErr is ERROR_NO_SUCH_INTERFACE)
        {
            dwErr = NO_ERROR;
        }
    }

    if (!dwNumRows)
    {
        DisplayMessage( g_hModule, MSG_IP_NO_ENTRIES );
    }

    return dwErr;
}

DWORD
HandleIpShowIfFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{
    return IpShowInterfaceInfo(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SHOW_IF_FILTER);
}

DWORD
HandleIpShowInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg 

Return Value:

    NO_ERROR
    
--*/

{
    return IpShowInterfaceInfo(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SHOW_INTERFACE);
}

DWORD
HandleIpShowPersistentRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )


/*++

Routine Description:

    Handler for show ip route. We just call the main interface info display
    handler

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    if (IsRouterRunning())
    {
        DisplayMessage(g_hModule, MSG_IP_PERSISTENT_ROUTER);
    }
    else
    {
        DisplayMessage(g_hModule, MSG_IP_PERSISTENT_CONFIG);
    }

    return IpShowInterfaceInfo(ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               SHOW_PERSISTENTROUTE);
}


DWORD
HandleIpAddIpIpTunnel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetIpIpTunnel(ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              TRUE);
}

DWORD
HandleIpSetIpIpTunnel(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )

/*++

Routine Description:

Arguments:

    ppwcArguments   - Argument array
    dwCurrentIndex  - ppwcArguments[dwCurrentIndex] is the first arg
    dwArgCount      - ppwcArguments[dwArgCount - 1] is the last arg

Return Value:

    NO_ERROR

--*/

{
    return IpAddSetIpIpTunnel(ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              FALSE);
}

DWORD
IpAddSetIpIpTunnel(
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    BOOL      bAdd
    )

{
    DWORD       dwNumArgs, dwErr, dwNumParsed;

    TAG_TYPE    rgTags[] = {{TOKEN_NAME,      TRUE, FALSE},
                            {TOKEN_LOCALADDR, TRUE, FALSE},
                            {TOKEN_REMADDR,   TRUE, FALSE},
                            {TOKEN_TTL,       FALSE,FALSE}};

    WCHAR       rgwcIfName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD       rgdwTagType[sizeof(rgTags)/sizeof(TAG_TYPE)];
    ULONG       i;
    PWCHAR      pwszIfName;

    IPINIP_CONFIG_INFO  ConfigInfo;

    dwNumArgs = dwArgCount - dwCurrentIndex;

    if((dwCurrentIndex > dwArgCount) or
       (dwNumArgs isnot 4))
    {
        //
        // No arguments specified
        //
        
        return ERROR_SHOW_USAGE;
    }

    dwErr = MatchTagsInCmdLine(g_hModule,
                               ppwcArguments,
                               dwCurrentIndex,
                               dwArgCount,
                               rgTags,
                               sizeof(rgTags)/sizeof(TAG_TYPE),
                               rgdwTagType);

    if (dwErr isnot NO_ERROR)
    {
        if (dwErr is ERROR_INVALID_OPTION_TAG)
        {
            return ERROR_INVALID_SYNTAX;
        }

        return dwErr;
    }

    for(i = 0; i < dwNumArgs; i ++)
    {
        switch (rgdwTagType[i])
        {
            case 0 : // NAME
            {
                dwErr = GetInterfaceName(ppwcArguments[i + dwCurrentIndex],
                                         rgwcIfName,
                                         sizeof(rgwcIfName),
                                         &dwNumParsed);

                if(bAdd)
                {
                    if(dwErr is NO_ERROR)
                    {
                        return ERROR_OBJECT_ALREADY_EXISTS;
                    }
 
                    pwszIfName = ppwcArguments[i + dwCurrentIndex];
                }
                else
                {
                    if(dwErr isnot NO_ERROR)
                    {
                        return dwErr;
                    }

                    pwszIfName = rgwcIfName;
                }

                break;
            }

            case 1:
            {
                //
                // Tag for localaddr
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &ConfigInfo.dwLocalAddress);

                break;
            }

            case 2:
            {
                //
                // Tag for remoteaddr
                //

                dwErr = GetIpAddress(ppwcArguments[i + dwCurrentIndex], 
                                     &ConfigInfo.dwRemoteAddress);

                break;
            }

            case 3:
            {
                //
                // Tag for ttl
                //

                ConfigInfo.byTtl =
                    LOBYTE(LOWORD(wcstoul(ppwcArguments[i + dwCurrentIndex],
                                          NULL,
                                          10)));

                break;
            }

            default:
            {
                i = dwNumArgs;

                dwErr = ERROR_INVALID_SYNTAX;

                break;
            }
        }
    }

    switch(dwErr)
    {
        case NO_ERROR:
        {
            break;
        }

        default:
        {
            return dwErr;
        }
    }

    for(i = 0; i < dwNumArgs; i++)
    {
        if(!rgTags[i].bPresent)
        {
            DisplayMessage(g_hModule, 
                           MSG_CANT_FIND_EOPT);

            return ERROR_INVALID_SYNTAX;
        }
    }

    dwErr = AddSetIpIpTunnelInfo(pwszIfName,
                                 &ConfigInfo);

    return dwErr;
}
 
DWORD
IpDump(
    IN  LPCWSTR     pwszRouter,
    IN  LPWSTR     *ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  LPCVOID     pvData
    )
{
    DumpIpInformation((HANDLE)-1);

    return NO_ERROR;
}

#if 0
DWORD
HandleIpInstall(
    PWCHAR    pwszMachine,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )
{
    // XXX DLLPath, ProtocolId

    // XXX set default info here
    // global info block (what is this?)
    // protocol priority block (no need?)
    // multicast boundaries block (no need)

    return NO_ERROR;
}

DWORD
HandleIpUninstall(
    PWCHAR    pwszMachine,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    PVOID     pvData,
    BOOL      *pbDone
    )
{
    PMPR_INTERFACE_0  pmi0;
    DWORD             dwCount, dwTotal, i, dwErr;

    // Remove global info
    // XXX

    // Remove interface info
    
    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr is NO_ERROR)
    {
        for (i=0; i<dwCount; i++)
        { 
            DeleteInterfaceInfo(pmi0[i].wszInterfaceName);
        }
    }

    return NO_ERROR;
}
#endif

DWORD
HandleIpReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    PMPR_INTERFACE_0  pmi0;
    DWORD             dwCount, dwTotal, i, dwErr, dwSize, dwBlkSize;
    DWORD             dwNumProtocols;
    GLOBAL_INFO       gi;
    PPRIORITY_INFO    pPriInfo;
    PPROTOCOL_METRIC  pProtocolMetrics;
    RTR_INFO_BLOCK_HEADER *pInfoHdr;
    RTR_INFO_BLOCK_HEADER *pLocalInfoHdr;

    PROTOCOL_METRIC   defaultProtocolMetrics[] = 
                            {
                                {PROTO_IP_LOCAL,                1},
                                {PROTO_IP_NT_STATIC,            3},
                                {PROTO_IP_NT_STATIC_NON_DOD,    5},
                                {PROTO_IP_NT_AUTOSTATIC,        7},
                                {PROTO_IP_NETMGMT,              10},
                                {PROTO_IP_OSPF,                 110},
                                {PROTO_IP_RIP,                  120}
                            };

    PROTOCOL_METRIC   defaultProtocolMetricsNT4[] = 
                            {
                                {PROTO_IP_LOCAL,                1},
                                {PROTO_IP_NETMGMT,              2},
                                {PROTO_IP_OSPF,                 3},
                                {PROTO_IP_RIP,                  4},
                                {PROTO_IP_IGMP,                 5}
                            };

    // delete all blocks except the IP_GLOBAL_INFO
    dwErr = ValidateGlobalInfo(&pInfoHdr);
    if (dwErr is NO_ERROR)
    {
        // Copy to a local buffer just in case the APIs modify it as we go
        dwSize = sizeof(RTR_INFO_BLOCK_HEADER) * pInfoHdr->TocEntriesCount;
        pLocalInfoHdr = MALLOC(dwSize);
        if (pLocalInfoHdr is NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        memcpy(pLocalInfoHdr, pInfoHdr, dwSize);

        // Set Global and RoutePref info
        {
                dwBlkSize         = sizeof(GLOBAL_INFO);
                dwCount           = 1;
                gi.bFilteringOn   = FALSE;
                gi.dwLoggingLevel = IPRTR_LOGGING_ERROR;
                dwErr = IpmontrSetInfoBlockInGlobalInfo(IP_GLOBAL_INFO,
                                                 (PBYTE) &gi,
                                                 dwBlkSize,
                                                 dwCount);
        }

        {
                // Based on the router version, calculate the number 
                // of protocols etc.
                // TODO: currently assuming >=NT5. Should find out the router
                // version somehow
                dwNumProtocols    =
                    sizeof(defaultProtocolMetrics)/sizeof(PROTOCOL_METRIC);
                pProtocolMetrics  = defaultProtocolMetrics;

                dwBlkSize         = SIZEOF_PRIORITY_INFO(dwNumProtocols);
                dwCount           = 1;

                // Allocate buffer to hold the Priority Information
                pPriInfo = MALLOC(dwBlkSize);
                if (pPriInfo is NULL)
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                pPriInfo->dwNumProtocols = dwNumProtocols; 
                memcpy(
                        pPriInfo->ppmProtocolMetric, 
                        pProtocolMetrics, 
                        dwNumProtocols * sizeof(PROTOCOL_METRIC));

                dwErr = IpmontrSetInfoBlockInGlobalInfo(IP_PROT_PRIORITY_INFO,
                                                 (PBYTE) pPriInfo,
                                                 dwBlkSize,
                                                 dwCount);

                FREE(pPriInfo); 
        }

        for (i=0; i<pLocalInfoHdr->TocEntriesCount; i++)
        {
            switch (pLocalInfoHdr->TocEntry[i].InfoType)
            {
            case IP_GLOBAL_INFO:
            case IP_PROT_PRIORITY_INFO:
                // already done
                break;

            default:
                IpmontrDeleteInfoBlockFromGlobalInfo(
                    pLocalInfoHdr->TocEntry[i].InfoType );
                break;
            }
        }

        FREE(pLocalInfoHdr);
    }

    // Delete all interface info
    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr is NO_ERROR)
    {
        for (i=0; i<dwCount; i++)
        { 
            DeleteInterfaceInfo(pmi0[i].wszInterfaceName);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\ipmon.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ip\ipmon\ipmon.c

Abstract:

    IP Command dispatcher.

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"

const GUID g_IpGuid      = IPMONTR_GUID;

#define IP_HELPER_VERSION 1

DWORD             g_dwNumTableEntries = 0; // 6;

//
// The table of Add, Delete, Set and Show Commands for IP RTR MGR
// To add a command to one of the command groups, just add the
// CMD_ENTRY to the correct table. To add a new cmd group, create its
// cmd table and then add the group entry to group table
//

//
// The commands are prefix-matched with the command-line, in sequential
// order. So a command like 'ADD INTERFACE FILTER' must come before
// the command 'ADD INTERFACE' in the table.  Likewise,
// a command like 'ADD ROUTE' must come before the command 
// 'ADD ROUTEXXXX' in the table.
//

CMD_ENTRY  g_IpAddCmdTable[] = {
    CREATE_CMD_ENTRY(IP_ADD_BOUNDARY,   HandleIpAddBoundary),
    CREATE_CMD_ENTRY(IP_ADD_IF_FILTER,  HandleIpAddIfFilter),
    CREATE_CMD_ENTRY(IP_ADD_INTERFACE,  HandleIpAddInterface),
    //CREATE_CMD_ENTRY(IP_ADD_IPIPTUNNEL, HandleIpAddIpIpTunnel),
    CREATE_CMD_ENTRY(IP_ADD_PROTOPREF,  HandleIpAddRoutePref),
    CREATE_CMD_ENTRY(IP_ADD_SCOPE,      HandleIpAddScope),
    CREATE_CMD_ENTRY(IP_ADD_RTMROUTE,   HandleIpAddRtmRoute),
    CREATE_CMD_ENTRY(IP_ADD_PERSISTENTROUTE,HandleIpAddPersistentRoute),
};

CMD_ENTRY  g_IpDelCmdTable[] = {
    CREATE_CMD_ENTRY(IP_DEL_BOUNDARY,   HandleIpDelBoundary),
    CREATE_CMD_ENTRY(IP_DEL_IF_FILTER,  HandleIpDelIfFilter),
    CREATE_CMD_ENTRY(IP_DEL_INTERFACE,  HandleIpDelInterface),
    CREATE_CMD_ENTRY(IP_DEL_PROTOPREF,  HandleIpDelRoutePref),
    CREATE_CMD_ENTRY(IP_DEL_SCOPE,      HandleIpDelScope),
    CREATE_CMD_ENTRY(IP_DEL_RTMROUTE,   HandleIpDelRtmRoute),
    CREATE_CMD_ENTRY(IP_DEL_PERSISTENTROUTE,HandleIpDelPersistentRoute),
};

CMD_ENTRY g_IpSetCmdTable[] = {
    CREATE_CMD_ENTRY(IP_SET_IF_FILTER,  HandleIpSetIfFilter),
    CREATE_CMD_ENTRY(IP_SET_INTERFACE,  HandleIpSetInterface),
    //CREATE_CMD_ENTRY(IP_SET_IPIPTUNNEL, HandleIpSetIpIpTunnel),
    CREATE_CMD_ENTRY(IP_SET_LOGLEVEL,   HandleIpSetLogLevel),
    CREATE_CMD_ENTRY(IP_SET_PROTOPREF,  HandleIpSetRoutePref),
    CREATE_CMD_ENTRY(IP_SET_SCOPE,      HandleIpSetScope),
    CREATE_CMD_ENTRY(IP_SET_RTMROUTE,   HandleIpSetRtmRoute),
    CREATE_CMD_ENTRY(IP_SET_PERSISTENTROUTE,HandleIpSetPersistentRoute)
};

CMD_ENTRY g_IpShowCmdTable[] = {
    CREATE_CMD_ENTRY(IP_SHOW_BOUNDARY,     HandleIpShowBoundary),
    CREATE_CMD_ENTRY(IPMIB_SHOW_BOUNDARY,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_RTMDEST,   HandleIpShowRtmDestinations),
    CREATE_CMD_ENTRY(IP_SHOW_IF_FILTER,    HandleIpShowIfFilter),
    CREATE_CMD_ENTRY(IP_SHOW_INTERFACE,    HandleIpShowInterface),
//  CREATE_CMD_ENTRY(IPMIB_SHOW_IPFORWARD, HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IP_SHOW_LOGLEVEL,     HandleIpShowLogLevel),
    CREATE_CMD_ENTRY(IPMIB_SHOW_MFE,       HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IPMIB_SHOW_MFESTATS,  HandleIpMibShowObject),
    CREATE_CMD_ENTRY(IP_SHOW_PROTOCOL,     HandleIpShowProtocol),
    CREATE_CMD_ENTRY(IPMIB_SHOW_RTMROUTE,  HandleIpShowRtmRoutes),
    CREATE_CMD_ENTRY(IP_SHOW_PROTOPREF,    HandleIpShowRoutePref),
    CREATE_CMD_ENTRY(IP_SHOW_SCOPE,        HandleIpShowScope),
    CREATE_CMD_ENTRY(IP_SHOW_PERSISTENTROUTE,HandleIpShowPersistentRoute)
};

CMD_GROUP_ENTRY g_IpCmdGroups[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_IpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_IpDelCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_IpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_IpShowCmdTable),
};

ULONG   g_ulNumGroups = sizeof(g_IpCmdGroups)/sizeof(CMD_GROUP_ENTRY);

CMD_ENTRY g_IpCmds[] = 
{
//  CREATE_CMD_ENTRY(IP_INSTALL,   HandleIpInstall),
    CREATE_CMD_ENTRY(IP_RESET,     HandleIpReset),
    CREATE_CMD_ENTRY_EX(IP_UPDATE, HandleIpUpdate, 0),
//  CREATE_CMD_ENTRY(IP_UNINSTALL, HandleIpUninstall),
};

ULONG g_ulNumTopCmds = sizeof(g_IpCmds)/sizeof(CMD_ENTRY);

BOOL   g_bIpDirty = FALSE;
HANDLE g_hModule;
HANDLE g_hMprConfig = NULL;
HANDLE g_hMprAdmin  = NULL;
HANDLE g_hMIBServer = NULL;
BOOL   g_bCommit;
DWORD  g_dwNumTableEntries;

TRANSPORT_INFO      g_tiTransport;
LIST_ENTRY          g_leIfListHead;
NS_CONTEXT_CONNECT_FN IpConnect;

ULONG   g_ulInitCount;

DWORD
WINAPI
IpUnInit(
    IN  DWORD   dwReserved
    );

static DWORD                ParentVersion = 0;

DWORD
WINAPI
IpStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;
    PNS_PRIV_CONTEXT_ATTRIBUTES  pNsPrivContextAttributes;

    pNsPrivContextAttributes = MALLOC(sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));
    if (!pNsPrivContextAttributes)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));
    ZeroMemory(pNsPrivContextAttributes, sizeof(NS_PRIV_CONTEXT_ATTRIBUTES));

    attMyAttributes.pwszContext   = L"ip";
    attMyAttributes.guidHelper    = g_IpGuid;
    attMyAttributes.dwVersion     = 1;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = g_ulNumTopCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_IpCmds;
    attMyAttributes.ulNumGroups   = g_ulNumGroups;
    attMyAttributes.pCmdGroups    = (CMD_GROUP_ENTRY (*)[])&g_IpCmdGroups;
    attMyAttributes.pfnCommitFn   = IpCommit;
    attMyAttributes.pfnDumpFn     = IpDump;
    attMyAttributes.pfnConnectFn  = IpConnect;
   
    pNsPrivContextAttributes->pfnEntryFn    = NULL;
    pNsPrivContextAttributes->pfnSubEntryFn = IpSubEntry;
    attMyAttributes.pReserved     = pNsPrivContextAttributes;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD WINAPI
IpSubEntry(
    IN      const NS_CONTEXT_ATTRIBUTES *pSubContext,
    IN      LPCWSTR                      pwszMachine,
    IN OUT  LPWSTR                      *ppwcArguments,
    IN      DWORD                        dwArgCount,
    IN      DWORD                        dwFlags,
    IN      LPCVOID                      pvData,
    OUT     LPWSTR                       pwcNewContext
    )
{
    PNS_PRIV_CONTEXT_ATTRIBUTES pNsPrivContextAttributes = pSubContext->pReserved;
    
    if ( (!pNsPrivContextAttributes) || (!pNsPrivContextAttributes->pfnEntryFn) )
    {
        return GenericMonitor(pSubContext,
                               pwszMachine,
                               ppwcArguments,
                               dwArgCount,
                               dwFlags,
                               g_hMIBServer,
                               pwcNewContext );
    }

    return (*pNsPrivContextAttributes->pfnEntryFn)( pwszMachine,
                                    ppwcArguments,
                                    dwArgCount,
                                    dwFlags,
                                    g_hMIBServer,
                                    pwcNewContext );
}

DWORD
WINAPI
InitHelperDll(
    IN  DWORD               dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES  pDllTable
    )
{
    WORD       wVersion = MAKEWORD(1,1);
    WSADATA    wsaData;
    DWORD      dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    //
    // See if this is the first time we are being called
    //

    if(InterlockedIncrement(&g_ulInitCount) != 1)
    {
        return NO_ERROR;
    }

    dwErr = WSAStartup(wVersion,&wsaData);

    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    //
    // Initialize interface list and the Transport Info Block
    //

    InitializeListHead(&g_leIfListHead);

    g_tiTransport.bValid   = FALSE;
    g_tiTransport.pibhInfo = NULL;

    g_bCommit = TRUE;

    pDllTable->dwVersion     = NETSH_VERSION_50;
    pDllTable->pfnStopFn     = StopHelperDll;

    // Register helpers
    // We have 2 helpers (ROUTING, IP)

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.guidHelper               = g_RoutingGuid;
    attMyAttributes.dwVersion                = IP_HELPER_VERSION;
    attMyAttributes.pfnStart                 = RoutingStartHelper;
    attMyAttributes.pfnStop                  = NULL;

    RegisterHelper( &g_NetshGuid, &attMyAttributes );

    attMyAttributes.guidHelper               = g_IpGuid;
    attMyAttributes.dwVersion                = IP_HELPER_VERSION;
    attMyAttributes.pfnStart                 = IpStartHelper;
    attMyAttributes.pfnStop                  = NULL;

    RegisterHelper( &g_RoutingGuid, &attMyAttributes );

    return NO_ERROR;
}

DWORD
WINAPI
StopHelperDll(
    IN  DWORD   dwReserved
    )
{
    if(InterlockedDecrement(&g_ulInitCount) isnot 0)
    {
        return NO_ERROR;
    }

    IpCommit(NETSH_FLUSH);
   
    return NO_ERROR;
}
 
BOOL 
WINAPI
IpDllEntry(
    HINSTANCE   hInstDll,
    DWORD       fdwReason,
    LPVOID      pReserved
    )
{

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD WINAPI
IpConnect(
    IN  LPCWSTR pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bIpDirty)
    {
        IpStartHelper(NULL, ParentVersion);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>

#include <rpc.h>
#include <nhapi.h>

#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <ipinfoid.h>
#include <rtmv2.h>
#include <macros.h>
#include <netsh.h>
#include <netshp.h>
#include <ipmontr.h>

#include "ipmon.h"
#include "strdefs.h"
#include "ipstring.h"
#include "info.h"
#include "ipcfg.h"
#include "iphandle.h"
#include "mprip.h"
#include "route.h"
#include "filter.h"
#include "ipip.h"
#include "showmib.h"
#include "boundary.h"
#include "utils.h"
#include "routing.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\mprip.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\mprip.c

Abstract:

    Functions to modify transport header (global and interface)
    This file now contains all the function exported by ipmon.dll to
    the helpers

Revision History:

    Anand Mahalingam         7/29/98  Created
    AmritanR

--*/

#include "precomp.h"
#include <time.h>
#pragma hdrstop

#define MaxIfDisplayLength 1024
#define SetErrorType(pdw)   *(pdw) = IsRouterRunning()?ERROR_ADMIN:ERROR_CONFIG

BOOL    g_bRouterRunning;
ULONG   g_ulNumChecks;

VOID
FreeInfoBuffer(
    IN  PVOID   pvBuffer
    )
{
    HeapFree(GetProcessHeap(),
             0,
             pvBuffer);
    
}


DWORD
WINAPI
IpmontrSetInfoBlockInGlobalInfo(
    IN  DWORD   dwType,
    IN  PBYTE   pbInfoBlk,
    IN  DWORD   dwSize,
    IN  DWORD   dwCount
    )

/*++

Routine Description:

    Called to Set or Add an info block to the Global Info

Arguments:

    pbInfoBlk  - Info block to be added
    dwType     - Type of the info block
    dwSize     - Size of each item in the info block
    dwCount    - Number of items in the info block
    
Return Value:

    NO_ERROR
    
--*/

{
    PRTR_INFO_BLOCK_HEADER    pOldInfo, pNewInfo;
    DWORD                     dwErr;
   
    //
    // Get/update global info
    //
 
    dwErr = ValidateGlobalInfo(&pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if(MprInfoBlockExists(pOldInfo,
                          dwType))
    {   
        //
        // The block already exists. So call set to replace it
        //
        
        dwErr = MprInfoBlockSet(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);
    }
    else
    {
        //
        // No info currently, add it
        //
        
        dwErr = MprInfoBlockAdd(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);
    }

    //
    // Dont need the old info
    //
    
    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        if(!g_bCommit)
        {
            g_tiTransport.pibhInfo = NULL;
            
            g_tiTransport.bValid   = FALSE;
        }
        
        return dwErr;
    }


    //
    // If in commit mode, set it to the router/registry
    // Otherwise update the local copy
    //

    if(g_bCommit)
    {
        dwErr = SetGlobalInfo(pNewInfo);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        ASSERT(g_tiTransport.bValid);

        g_tiTransport.pibhInfo = pNewInfo;

        dwErr = NO_ERROR;
    }

    return dwErr;
}

DWORD
WINAPI
IpmontrSetInfoBlockInInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    IN  PBYTE   pbInfoBlk,
    IN  DWORD   dwSize,
    IN  DWORD   dwCount
    )

/*++

Routine Description:

    Adds or Sets and infoblock in the interface info

Arguments:

    pwszIfName - interface name
    pbInfoBlk  - Info block to be added
    dwType     - Type of the info block
    dwSize     - Size of each item in the info block
    dwCount    - Number of items in the info block
    
Return Value:

    NO_ERROR
    
--*/
{

    PRTR_INFO_BLOCK_HEADER    pOldInfo, pNewInfo;
    DWORD                     dwErr;
    PINTERFACE_STORE          pii;
    
    pii = NULL;
   
    //
    // Get/Update the interface info
    //
 
    dwErr = ValidateInterfaceInfo(pwszIfName,
                                  &pOldInfo,
                                  NULL,
                                  &pii);
            
    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }


    if(MprInfoBlockExists(pOldInfo,
                          dwType))
    {
        //
        // The block already exists call Set to replace
        //

        dwErr = MprInfoBlockSet(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);

    }
    else
    {
        dwErr = MprInfoBlockAdd(pOldInfo,
                                dwType,
                                dwSize,
                                dwCount,
                                pbInfoBlk,
                                &pNewInfo);
    }

    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        //
        // Some error - invalidate info
        //

        if(!g_bCommit)
        {
            ASSERT(pii);
            ASSERT(pii->bValid);
        
            pii->pibhInfo = NULL;
            pii->bValid   = FALSE;
        }

        return dwErr;
    }

    if(g_bCommit)
    {
        //
        // Set to router/registry
        //

        dwErr = SetInterfaceInfo(pNewInfo,
                                 pwszIfName);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        //
        // Update local copy with new info (old one has been freed)
        //

        ASSERT(pii);
        ASSERT(pii->bValid);

        pii->pibhInfo = pNewInfo;
        pii->bValid   = TRUE;

        dwErr = NO_ERROR;
    }

    return dwErr;
}            


DWORD
WINAPI
IpmontrDeleteInfoBlockFromGlobalInfo(
    IN  DWORD   dwType
    )
    
/*++

Routine Description:

    Deletes an infoblock from the global info.
    The Infoblock is deleted by setting its Size and Count to 0

Arguments:

    dwType  - Id of Protocol to be added
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                  dwErr = NO_ERROR;
    PRTR_INFO_BLOCK_HEADER pOldInfo, pNewInfo;

    dwErr = ValidateGlobalInfo(&pOldInfo);
    
    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    if(!MprInfoBlockExists(pOldInfo,
                           dwType))
    {
        if(g_bCommit)
        {
            //
            // Arent saving a local copy so free this info
            //

            FREE_BUFFER(pOldInfo);
        }

        return NO_ERROR;
    }

    //
    // The router manager will only delete config info if we set
    // the size to 0.  However, we don't want to write 0-size
    // blocks to the registry, so we will strip them out when
    // we write to the registry.
    //

    dwErr = MprInfoBlockSet(pOldInfo,
                            dwType,
                            0,
                            0,
                            NULL,
                            &pNewInfo);

    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        if(!g_bCommit)
        {
            ASSERT(g_tiTransport.bValid);

            g_tiTransport.pibhInfo = NULL;
            g_tiTransport.bValid   = FALSE;
        }
            
        return dwErr;
    }

    if(g_bCommit)
    {
        dwErr = SetGlobalInfo(pNewInfo);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        ASSERT(g_tiTransport.bValid);
        
        g_tiTransport.pibhInfo = pNewInfo;

        dwErr = NO_ERROR;
    }
    
    return dwErr;
}

DWORD
WINAPI
IpmontrDeleteInfoBlockFromInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType
    )
    
/*++

Routine Description:

    Deletes an info block from the interface info. The info block is
    deleted by setting its Size and Count to 0

Arguments:

    pwszIfName       - Interface on which to add the protocol
    dwType  - Id of Protocol to be added
    
Return Value:

    NO_ERROR
    
--*/

{
    DWORD                  dwErr;
    PRTR_INFO_BLOCK_HEADER pOldInfo, pNewInfo;
    PINTERFACE_STORE       pii;
   
    pii = NULL;

    dwErr = ValidateInterfaceInfo(pwszIfName,
                                  &pOldInfo,
                                  NULL,
                                  &pii);
            
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    if(!MprInfoBlockExists(pOldInfo,
                           dwType))
    {
        if (g_bCommit)
        {
            FREE_BUFFER(pOldInfo);
        }
        
        return NO_ERROR;
    }

    //
    // If it does exist, remove it
    // This creates a new block
    // HACKHACK - Again we can interchangeably use info that is allocated
    // by GetXxx functions and MprInfoBlock functions since both allocations
    // are from ProcessHeap()
    //

    //
    // The router manager will only delete config info if we set
    // the size to 0.  However, we don't want to write 0-size
    // blocks to the registry, so we will strip them out when
    // we write to the registry.
    //

    dwErr = MprInfoBlockSet(pOldInfo,
                            dwType,
                            0,
                            0,
                            NULL,
                            &pNewInfo);

    //
    // One way or another, done with the old info
    //

    FREE_BUFFER(pOldInfo);

    if(dwErr isnot NO_ERROR)
    {
        if(!g_bCommit)
        {
            ASSERT(pii);
            ASSERT(pii->bValid);
        
            pii->pibhInfo = NULL;
            pii->bValid   = FALSE;
        }

        return dwErr;
    }

    if(g_bCommit)
    {
        dwErr = SetInterfaceInfo(pNewInfo,
                                 pwszIfName);

        FREE_BUFFER(pNewInfo);
    }
    else
    {
        ASSERT(pii);
        ASSERT(pii->bValid);

        pii->pibhInfo = pNewInfo;
        pii->bValid   = TRUE;

        dwErr = NO_ERROR;
    }

    return dwErr;
}

DWORD
WINAPI
IpmontrDeleteProtocol(
    IN  DWORD   dwProtoId
    )

/*++

Routine Description:

    Deletes Protocol from a transport

Arguments:

    dwProtoId   - Id of Protocol to be deleted

Return Value:

    NO_ERROR

--*/

{
    DWORD               dwRes;
    PMPR_INTERFACE_0    pmi0;
    DWORD               dwCnt, dwTot, dwInd, dwCount, dwErrType;

    SetErrorType(&dwErrType);

    do
    {
        //
        // Protocol being deleted globally, so remove from
        // all interfaces.
        //

        dwRes = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                              &dwCnt,
                              &dwTot);

        if(dwRes != NO_ERROR)
        {
            DisplayMessage(g_hModule, dwErrType, dwRes);
            break;
        }

        if (pmi0 == NULL)
        {
            dwCnt = 0;
        }

        for (dwInd = 0; dwInd < dwCnt; dwInd++)
        {
            
            dwRes =
                IpmontrDeleteInfoBlockFromInterfaceInfo(pmi0[dwInd].wszInterfaceName,
                                                 dwProtoId);

            if (dwRes is ERROR_NOT_ENOUGH_MEMORY)
            {
                break;
            }
        }

        //
        // Remove protocol from global info
        //
        
        dwRes = IpmontrDeleteInfoBlockFromGlobalInfo(dwProtoId);

        if (dwRes != NO_ERROR)
        {
            break;
        }

    } while(FALSE);

    if (pmi0)
    {
        HeapFree(GetProcessHeap(), 0, pmi0);
    }

    return dwRes;
}


DWORD
WINAPI
IpmontrGetInfoBlockFromGlobalInfo(
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk, OPTIONAL
    OUT PDWORD  pdwSize,      OPTIONAL
    OUT PDWORD  pdwCount      OPTIONAL
    )

/*++

Routine Description:

    Gets the info block from global info. If we get a zero sized block
    we return ERROR_NOT_FOUND so as to not configure the caller

Arguments:

    dwType     - Type of the info block
    ppbInfoBlk - ptr to info block
    pdwSize    - size of each item in block
    pdwCount   - number of items in block
    
Return Value:

    NO_ERROR
    ERROR_NOT_FOUND if the block doesnt exist.
    
--*/

{

    PRTR_INFO_BLOCK_HEADER    pInfo;
    DWORD                     dwErr;
    BOOL                      *pbValid;
    PBYTE                     pbyTmp = NULL;
    DWORD                     dwSize, dwCnt;

    if(ppbInfoBlk)
    {
        *ppbInfoBlk = NULL;
    }

    if(pdwSize)
    {
        *pdwSize = 0;
    }

    if(pdwCount)
    {
        *pdwCount = 0;
    }

    dwErr = ValidateGlobalInfo(&pInfo);
    
    if(dwErr isnot NO_ERROR)
    {
        return dwErr;
    }
    
    dwErr = MprInfoBlockFind(pInfo,
                             dwType,
                             &dwSize,
                             &dwCnt,
                             &pbyTmp);

    if(dwErr is NO_ERROR)
    {
        if(dwSize is 0)
        {
            if(g_bCommit)
            {
                FREE_BUFFER(pInfo);
            }

            return ERROR_NOT_FOUND;
        }

        if(ppbInfoBlk)
        {
            *ppbInfoBlk = HeapAlloc(GetProcessHeap(),
                                    0,
                                    dwSize * dwCnt);

            if(*ppbInfoBlk is NULL)
            {
                if(g_bCommit)
                {
                    FREE_BUFFER(pInfo);
                }
                
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            
            CopyMemory(*ppbInfoBlk,
                       pbyTmp,
                       dwSize * dwCnt);
        }
            
        if(pdwSize)
        {
            *pdwSize = dwSize;
        }
        
        if(pdwCount)
        {
            *pdwCount = dwCnt;
        }
    }

    if(g_bCommit)
    {
        FREE_BUFFER(pInfo);
    }
        
    return dwErr;
}

DWORD
WINAPI
IpmontrGetInfoBlockFromInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk,   OPTIONAL
    OUT PDWORD  pdwSize,        OPTIONAL
    OUT PDWORD  pdwCount,       OPTIONAL
    OUT PDWORD  pdwIfType       OPTIONAL
    )

/*++

Routine Description:

    Gets the info block from interface transport header

Arguments:

    pwszIfName - Interface Name
    dwType     - Type of the info block
    ppbInfoBlk - ptr to info block
    pdwSize    - size of each item in block
    pdwCount   - number of items in block
    pdwIfType  - interface type
    
Return Value:

    NO_ERROR
    ERROR_NOT_FOUND
    
--*/
{
    PRTR_INFO_BLOCK_HEADER    pInfo, *ppInfo;
    
    DWORD   dwErr;
    PBYTE   pbTmp, pbyTmp;
    DWORD   dwSize, dwCount;

    if(ppbInfoBlk)
    {
        *ppbInfoBlk = NULL;
    }

    if(pdwSize)
    {
        *pdwSize = 0;
    }

    if(pdwCount)
    {
        *pdwCount = 0;
    }

    //
    // If the user doesnt want any info, size or count, then we can optimize 
    // a bit by passing NULL to validate
    //

    if(((ULONG_PTR)ppbInfoBlk | (ULONG_PTR)pdwSize | (ULONG_PTR)pdwCount))
    {
        ppInfo = &pInfo;
    }
    else
    {
        ppInfo = NULL;
    }

    dwErr = ValidateInterfaceInfo(pwszIfName,
                                  ppInfo,
                                  pdwIfType,
                                  NULL);
            
    if((dwErr isnot NO_ERROR) or 
       (ppInfo is NULL))
    {
        //
        // If the user had an error or only wanted the ifType we are done
        //

        return dwErr;
    }

    //
    // Return protocol block info.
    //

    dwErr = MprInfoBlockFind(pInfo,
                             dwType,
                             &dwSize,
                             &dwCount,
                             &pbyTmp);

    if(dwErr is NO_ERROR)
    {
        if(dwSize is 0)
        {
            if(g_bCommit)
            {
                FREE_BUFFER(pInfo);
            }

            return ERROR_NOT_FOUND;
        }

        if(ppbInfoBlk)
        {
            *ppbInfoBlk = HeapAlloc(GetProcessHeap(),
                                    0,
                                    dwSize * dwCount);

            if(*ppbInfoBlk is NULL)
            {
                if(g_bCommit)
                {
                    FREE_BUFFER(pInfo);
                }
                    
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(*ppbInfoBlk,
                       pbyTmp,
                       dwSize * dwCount);

            if(pdwSize)
            {
                *pdwSize = dwSize;
            }

            if(pdwCount)
            {
                *pdwCount = dwCount;
            }
        }
    }

    if(g_bCommit)
    {
        FREE_BUFFER(pInfo);
    }
    

    return dwErr;
}

DWORD WINAPI
IpmontrGetInterfaceType(
    IN    LPCWSTR   pwszIfName,
    OUT   PDWORD    pdwIfType
    )
{
    return GetInterfaceInfo(pwszIfName,
                            NULL,
                            NULL,
                            pdwIfType);
}

DWORD 
WINAPI
GetInterfaceName(
    IN  LPCWSTR ptcArgument,
    OUT LPWSTR  pwszIfName,
    IN  DWORD   dwSizeOfIfName,
    OUT PDWORD  pdwNumParsed
    )
/*++
Description:
    Convert a friendly name to an interface name

Arguments:

    ptcArgument     - Buffer holding the Friendly Name of an interface
    pwszIfName      - Buffer to hold the Guid Interface Name
    dwSizeOfIfName  - Size (in Bytes) of the pwszIfName
    pdwNumParsed    - 
--*/
{
    DWORD dwErr;

    dwErr = IpmontrGetIfNameFromFriendlyName( 
                ptcArgument, 
                pwszIfName, 
                &dwSizeOfIfName );

    *pdwNumParsed = (dwErr is NO_ERROR)? 1 : 0;

    return dwErr;
}

DWORD
WINAPI
GetInterfaceDescription(
    IN      LPCWSTR    pwszIfName,
    OUT     LPWSTR     pwszIfDesc,
    OUT     PDWORD     pdwNumParsed
    )
{
    DWORD rc,dwSize;
    WCHAR IfNamBuffer[MaxIfDisplayLength];
    DWORD dwLen = (DWORD) wcslen(pwszIfName);

    if ( !dwLen || dwLen > MAX_INTERFACE_NAME_LEN )
    {
        *pdwNumParsed = 0;
        return ERROR_INVALID_PARAMETER;
    }

    dwSize = sizeof(IfNamBuffer); 
    //======================================
    // Translate the Interface Name
    //======================================
    rc = IpmontrGetFriendlyNameFromIfName(pwszIfName, IfNamBuffer, &dwSize);

    if (rc == NO_ERROR)
    {
        wcscpy(pwszIfDesc,IfNamBuffer);
        *pdwNumParsed = 1;
    }
    else
    {
        *pdwNumParsed = 0;
    }
    
    return rc;
}

DWORD 
WINAPI
IpmontrInterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    )
{
    DWORD               dwRes;
    PMPR_INTERFACE_0    pmi0;

    if(!IsRouterRunning())
    {
        dwRes = MprConfigInterfaceEnum(g_hMprConfig,
                                       0,
                                       (LPBYTE*) &pmi0,
                                       (DWORD) -1,
                                       pdwCount,
                                       pdwTotal,
                                       NULL);

        if(dwRes == NO_ERROR)
        {
            *ppb = (PBYTE)pmi0;
        }
    }
    else
    {
        dwRes = MprAdminInterfaceEnum(g_hMprAdmin,
                                      0,
                                      (LPBYTE*) &pmi0,
                                      (DWORD) -1,
                                      pdwCount,
                                      pdwTotal,
                                      NULL);

    
        if(dwRes == NO_ERROR)
        {
            *ppb = HeapAlloc(GetProcessHeap(),
                             0,
                             sizeof(MPR_INTERFACE_0) * (*pdwCount));

    
            if(*ppb == NULL)
            {
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            CopyMemory(*ppb, pmi0, sizeof(MPR_INTERFACE_0) * (*pdwCount));

            MprAdminBufferFree(pmi0);

        }
    }

    return dwRes;
}

DWORD
WINAPI
MatchRoutingProtoTag(
    IN  LPCWSTR  pwszToken
    )

/*++

Routine Description:

    Gets the protocol ID corresponding to a protocol tag.

Arguments:

    pwszArg - protocol token

Return Value:

    Protocol Id or (DWORD)-1

--*/

{
    DWORD   dwRes, dwErr;

    TOKEN_VALUE rgEnums[] ={{TOKEN_VALUE_RIP, PROTO_IP_RIP},
                         {TOKEN_VALUE_OSPF, PROTO_IP_OSPF},
                         {TOKEN_VALUE_AUTOSTATIC, PROTO_IP_NT_AUTOSTATIC},
                         {TOKEN_VALUE_STATIC, PROTO_IP_NT_STATIC},
                         {TOKEN_VALUE_NETMGMT, PROTO_IP_NETMGMT},
                         {TOKEN_VALUE_LOCAL, PROTO_IP_LOCAL},
                         {TOKEN_VALUE_NONDOD, PROTO_IP_NT_STATIC_NON_DOD}};

    if (iswdigit(pwszToken[0]))
    {
        return wcstoul(pwszToken, NULL, 10);
    }
    
    dwErr = MatchEnumTag(g_hModule,
                         pwszToken,
                         sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                         rgEnums,
                         &dwRes);

    if(dwErr != NO_ERROR)
    {
        return (DWORD)-1;
    }

    return dwRes;
}

BOOL
WINAPI
IsRouterRunning(
    VOID
    )

/*++

Routine Description:

    Gets the protocol ID corresponding to a protocol tag.

Arguments:

    pwszArg - protocol token

Return Value:

    Protocol Id or (DWORD)-1

--*/

{
    DWORD   dwErr;

    //
    // Check at most once per second
    //
    // We don't care about wrapping, we just need a fast way to
    // get some identifier of the current "second".
    //

    static time_t dwPreviousTime = 0;
    time_t        dwCurrentTime;
    time(&dwCurrentTime);

    if (dwCurrentTime == dwPreviousTime)
    {
        return g_bRouterRunning;
    }

    dwPreviousTime = dwCurrentTime;

    if(MprAdminIsServiceRunning(g_pwszRouter))
    {
        if(g_bRouterRunning)
        {
            return TRUE;
        }

        dwErr = MprAdminServerConnect(g_pwszRouter,
                                      &g_hMprAdmin);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           MSG_IP_CAN_NOT_CONNECT_DIM,
                           dwErr);

            return FALSE;
        }

        dwErr = MprAdminMIBServerConnect(g_pwszRouter,
                                         &g_hMIBServer);

        if(dwErr isnot NO_ERROR)
        {
            DisplayError(NULL,
                         dwErr);

            DisplayMessage(g_hModule,
                           MSG_IP_CAN_NOT_CONNECT_DIM,
                           dwErr);

            MprAdminServerDisconnect(g_hMprAdmin);

            g_hMprAdmin = NULL;

            return FALSE;
        }

        g_bRouterRunning = TRUE;
    }
    else
    {
        if(g_bRouterRunning)
        {
            g_bRouterRunning = FALSE;
            g_hMprAdmin      = NULL;
            g_hMIBServer     = NULL;
        }
    }

    return g_bRouterRunning; 
}

DWORD
MibGetFirst(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGetFirst( g_hMIBServer,
                                      dwTransportId,
                                      dwRoutingPid,
                                      lpInEntry,
                                      dwInEntrySize,
                                      lplpOutEntry,
                                      lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}

DWORD
MibGetNext(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGetNext( g_hMIBServer,
                                     dwTransportId,
                                     dwRoutingPid,
                                     lpInEntry,
                                     dwInEntrySize,
                                     lplpOutEntry,
                                     lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    )
{
    DWORD dwErr;

    dwErr = MprAdminMIBEntryGet( g_hMIBServer,
                                 dwTransportId,
                                 dwRoutingPid,
                                 lpInEntry,
                                 dwInEntrySize,
                                 lplpOutEntry,
                                 lpdwOutEntrySize );

    if (dwErr is RPC_S_INVALID_BINDING)
    {
        g_bRouterRunning = FALSE;
        g_hMprAdmin      = NULL;
        g_hMIBServer     = NULL;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\remras.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0268 */
/* at Wed Jun 02 22:49:58 1999
 */
/* Compiler settings for remras.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __remras_h__
#define __remras_h__

/* Forward Declarations */ 

#ifndef __IRemoteNetworkConfig_FWD_DEFINED__
#define __IRemoteNetworkConfig_FWD_DEFINED__
typedef interface IRemoteNetworkConfig IRemoteNetworkConfig;
#endif 	/* __IRemoteNetworkConfig_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IRemoteNetworkConfig_INTERFACE_DEFINED__
#define __IRemoteNetworkConfig_INTERFACE_DEFINED__

/* interface IRemoteNetworkConfig */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IRemoteNetworkConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A2DB1B-D706-11d0-A37B-00C04FC9DA04")
    IRemoteNetworkConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpgradeRouterConfig( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserConfig( 
            /* [in] */ LPCOLESTR pszService,
            /* [in] */ LPCOLESTR pszNewGroup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteNetworkConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRemoteNetworkConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRemoteNetworkConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRemoteNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpgradeRouterConfig )( 
            IRemoteNetworkConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserConfig )( 
            IRemoteNetworkConfig __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszService,
            /* [in] */ LPCOLESTR pszNewGroup);
        
        END_INTERFACE
    } IRemoteNetworkConfigVtbl;

    interface IRemoteNetworkConfig
    {
        CONST_VTBL struct IRemoteNetworkConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteNetworkConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteNetworkConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteNetworkConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteNetworkConfig_UpgradeRouterConfig(This)	\
    (This)->lpVtbl -> UpgradeRouterConfig(This)

#define IRemoteNetworkConfig_SetUserConfig(This,pszService,pszNewGroup)	\
    (This)->lpVtbl -> SetUserConfig(This,pszService,pszNewGroup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRemoteNetworkConfig_UpgradeRouterConfig_Proxy( 
    IRemoteNetworkConfig __RPC_FAR * This);


void __RPC_STUB IRemoteNetworkConfig_UpgradeRouterConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRemoteNetworkConfig_SetUserConfig_Proxy( 
    IRemoteNetworkConfig __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszService,
    /* [in] */ LPCOLESTR pszNewGroup);


void __RPC_STUB IRemoteNetworkConfig_SetUserConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteNetworkConfig_INTERFACE_DEFINED__ */



#ifdef __cplusplus

class DECLSPEC_UUID("1AA7F844-C7F5-11d0-A376-00C04FC9DA04")
RemoteRouterConfig;
#endif
#endif /* __REMRRASLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\ipstring.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor2\ip\ipstring.h

Abstract:

    Definitions of command line tokens are not localized.

Author:

     Dave Thaler
     
Revision History:

    V Raman                 1/19/99
--*/



#define MSG_NEWLINE                             L"\n"
#define MSG_STRING                              L"%1!s!"
#define MSG_HELP_START                          L"%1!-14s! - "

#define TOKEN_MIB_OBJECT_MFE                    L"mfe"
#define TOKEN_MIB_OBJECT_MFESTATS               L"mfestats"
#define TOKEN_MIB_OBJECT_BOUNDARY               L"boundarystats"
#define TOKEN_MIB_OBJECT_SCOPE                  L"scope"
#define TOKEN_MIB_OBJECT_JOINS                  L"joins"
#define TOKEN_MIB_OBJECT_RTMDESTINATIONS        L"rtmdestinations"
#define TOKEN_MIB_OBJECT_RTMROUTES              L"rtmroutes"

#define CMD_IPMIB_SHOW_INTERFACE                L"interface"
#define CMD_IPMIB_SHOW_IPSTATS                  L"ipstats"
#define CMD_IPMIB_SHOW_IPADDRESS                L"ipaddress"
#define CMD_IPMIB_SHOW_IPFORWARD                L"ipforward"
#define CMD_IPMIB_SHOW_IPNET                    L"ipnet"
#define CMD_IPMIB_SHOW_TCPSTATS                 L"tcpstats"
#define CMD_IPMIB_SHOW_TCPCONN                  L"tcpconn"
#define CMD_IPMIB_SHOW_UDPSTATS                 L"udpstats"
#define CMD_IPMIB_SHOW_UDPCONN                  L"udpconn"
#define CMD_IPMIB_SHOW_MFE                      L"mfe"
#define CMD_IPMIB_SHOW_MFESTATS                 L"mfestats"
#define CMD_IPMIB_SHOW_JOINS                    L"joins"
#define CMD_IPMIB_SHOW_RTMDEST                  L"rtmdestinations"
#define CMD_IPMIB_SHOW_RTMROUTE                 L"rtmroutes"
#define CMD_IPMIB_SHOW_BOUNDARY                 L"boundarystats"
#define CMD_IPMIB_SHOW_SCOPE                    L"scope"

//
// TOKEN_Xxx are tokens for arguments
// These must be in lower case
//

#define TOKEN_NAME                              L"name"
#define TOKEN_STATUS                            L"state"
#define TOKEN_LOCALADDR                         L"localaddr"
#define TOKEN_REMADDR                           L"remaddr"
#define TOKEN_TTL                                L"ttl"

#define TOKEN_FILTER_TYPE                        L"filtertype"
#define TOKEN_SOURCE_ADDRESS                    L"srcaddr"
#define TOKEN_SOURCE_MASK                       L"srcmask"
#define TOKEN_DEST_ADDRESS                      L"dstaddr"
#define TOKEN_DEST_MASK                         L"dstmask"
#define TOKEN_ACTION                            L"action"
#define TOKEN_CODE                              L"code"
#define TOKEN_SOURCE_PORT                       L"srcport"
#define TOKEN_DEST_PORT                         L"dstport"
#define TOKEN_FILTER                            L"filtering"
#define TOKEN_FRAGCHECK                         L"fragcheck"
#define TOKEN_OPERATOR                          L"operator"
#define TOKEN_VIEW                              L"view"

#define TOKEN_DEST                              L"dest"
#define TOKEN_MASK                              L"mask"
#define TOKEN_NAMEINDEX                         L"nameorindex"
#define TOKEN_NHOP                              L"nhop"
#define TOKEN_METRIC                            L"metric"
#define TOKEN_PREFERENCE                        L"preference"
#define TOKEN_PROTOCOL                          L"proto"
#define TOKEN_TYPE                               L"type"
#define TOKEN_PREF_LEVEL                        L"preflevel"
#define TOKEN_REFRESH                           L"rr"
#define TOKEN_STATS                             L"stats"

// Multicast scope options
#define TOKEN_GROUP_ADDRESS                     L"grpaddr"
#define TOKEN_GROUP_MASK                        L"grpmask"
#define TOKEN_SCOPE_NAME                        L"scopename"

#define TOKEN_LOG_LEVEL                         L"loglevel"

#define TOKEN_DEFAULT                           L"default"

//
// TOKEN_VALUE_Xxx are tokens for possible values than an argument
// can take
// These must be in upper case
//

#define TOKEN_VALUE_RIP                         L"RIP"
#define TOKEN_VALUE_OSPF                        L"OSPF"

#define TOKEN_VALUE_TCP                         L"TCP"
#define TOKEN_VALUE_TCP_ESTAB                   L"TCP-EST"
#define TOKEN_VALUE_UDP                         L"UDP"
#define TOKEN_VALUE_ICMP                        L"ICMP"
#define TOKEN_VALUE_NETMGMT                     L"NetMgmt"
#define TOKEN_VALUE_LOCAL                       L"LOCAL"
#define TOKEN_VALUE_STATIC                      L"STATIC"
#define TOKEN_VALUE_AUTOSTATIC                  L"AUTOSTATIC"
#define TOKEN_VALUE_NONDOD                      L"NONDOD"
#define TOKEN_VALUE_ANY                         L"ANY"


#define TOKEN_VALUE_ERROR                       L"error"
#define TOKEN_VALUE_WARN                        L"warn"
#define TOKEN_VALUE_INFO                        L"info"

#define TOKEN_VALUE_INPUT                       L"input"
#define TOKEN_VALUE_OUTPUT                      L"output"
#define TOKEN_VALUE_DIAL                        L"dial"

#define TOKEN_VALUE_ENABLE                      L"enable"
#define TOKEN_VALUE_DISABLE                     L"disable"

#define TOKEN_VALUE_YES                         L"yes"
#define TOKEN_VALUE_NO                          L"no"

#define TOKEN_VALUE_NONE                        L"none"

#define TOKEN_VALUE_DROP                        L"drop"
#define TOKEN_VALUE_FORWARD                     L"forward"

#define TOKEN_VALUE_POSITIVE                    L"active"
#define TOKEN_VALUE_NEGATIVE                    L"negative"
#define TOKEN_VALUE_BOTH                        L"both"

#define TOKEN_VALUE_ALL                         L"all"

#define TOKEN_VALUE_UNICAST                     L"unicast"
#define TOKEN_VALUE_MULTICAST                   L"multicast"

#define TOKEN_VALUE_MATCHING                    L"matching"
#define TOKEN_VALUE_SHORTER                     L"shorterthan"
#define TOKEN_VALUE_LONGER                      L"longerthan"

#define TOKEN_MICROSOFT0                        L"MS-0000"
#define TOKEN_MICROSOFT1                        L"Microsoft"
#define TOKEN_MICROSOFT2                        L"-"

//
// Tokens for commands
// These must be in lower case
//

#define CMD_GROUP_ADD                           L"add"
#define CMD_GROUP_DELETE                        L"delete"
#define CMD_GROUP_SET                           L"set"
#define CMD_GROUP_SHOW                          L"show"

#define CMD_IP_LIST                             L"list"
#define CMD_IP_HELP1                                L"?"
#define CMD_IP_HELP2                                L"help"
#define CMD_IP_INSTALL                          L"install"
#define CMD_IP_UNINSTALL                        L"uninstall"
#define CMD_IP_RESET                            L"reset"
#define CMD_IP_DUMP                             L"dump"
#define CMD_IP_UPDATE                           L"update"
#define CMD_IP_MIB                              L"mib"

#define CMD_IP_ADD_PROTOPREF                    L"preferenceforprotocol"
#define CMD_IP_ADD_INTERFACE                    L"interface"
#define CMD_IP_ADD_IF_FILTER                    L"filter"
#define CMD_IP_ADD_RTMROUTE                     L"rtmroute"
#define CMD_IP_ADD_PERSISTENTROUTE              L"persistentroute"
#define CMD_IP_ADD_IPIPTUNNEL                   L"ipiptunnel"
#define CMD_IP_ADD_SCOPE                        L"scope"
#define CMD_IP_ADD_BOUNDARY                     L"boundary"
#define CMD_IP_ADD_HELPER                       L"helper"

#define CMD_IP_DEL_PROTOPREF                    L"preferenceforprotocol"
#define CMD_IP_DEL_INTERFACE                    L"interface"
#define CMD_IP_DEL_IF_FILTER                    L"filter"
#define CMD_IP_DEL_RTMROUTE                     L"rtmroute"
#define CMD_IP_DEL_PERSISTENTROUTE              L"persistentroute"
#define CMD_IP_DEL_SCOPE                        L"scope"
#define CMD_IP_DEL_BOUNDARY                     L"boundary"
#define CMD_IP_DEL_HELPER                       L"helper"

#define CMD_IP_SET_PROTOPREF                    L"preferenceforprotocol"
#define CMD_IP_SET_INTERFACE                    L"interface"
#define CMD_IP_SET_IF_FILTER                    L"filter"
#define CMD_IP_SET_LOGLEVEL                     L"loglevel"
#define CMD_IP_SET_IPIPTUNNEL                   L"ipiptunnel"
#define CMD_IP_SET_RTMROUTE                     L"rtmroute"
#define CMD_IP_SET_PERSISTENTROUTE              L"persistentroute"
#define CMD_IP_SET_SCOPE                        L"scope"

#define CMD_IP_SHOW_PROTOPREF                   L"preferenceforprotocol"
#define CMD_IP_SHOW_PROTOCOL                    L"protocol"
#define CMD_IP_SHOW_INTERFACE                   L"interface"
#define CMD_IP_SHOW_IF_FILTER                   L"filter"
#define CMD_IP_SHOW_PERSISTENTROUTE             L"persistentroutes"
#define CMD_IP_SHOW_LOGLEVEL                    L"loglevel"
#define CMD_IP_SHOW_SCOPE                       L"scope"
#define CMD_IP_SHOW_BOUNDARY                    L"boundary"
#define CMD_IP_SHOW_HELPER                      L"helper"

#define MSG_IP_MIB_CMD                          L"%1!s! %2!s!\n"

#define DMP_IP_ADD_IF                           L"\
\nadd interface name=%1!s! state=%2!s!"

#define DMP_IP_ADD_IF_FILTER                    L"\
\nadd filter name=%1!s! filtertype=%2!s! srcaddr=%3!s! srcmask=%4!s! \
    dstaddr=%5!s! dstmask=%6!s! proto=%7!s! "

#define DMP_IP_ADD_IF_FILTER_PORT               L"\
srcport=%1!d! dstport=%2!d!"

#define DMP_IP_ADD_IF_FILTER_TC                 L"\
type=%1!d! code=%2!d!"

#define DMP_IP_ADDSET_PERSISTENTROUTE           L"\
\nadd persistentroute dest=%1!s! mask=%2!s! name=%3!s! nhop=%4!s! proto=%5!s! \
    preference=%6!d! metric=%7!d! view=%8!s!\
\nset persistentroute dest=%1!s! mask=%2!s! name=%3!s! nhop=%4!s! proto=%5!s! \
    preference=%6!d! metric=%7!d! view=%8!s!"

#define DMP_IP_SET_PROTOPREF                    L"\
\nadd preferenceforprotocol proto=%1!s! preflevel=%2!d!"

#define DMP_IP_SET_LOGLEVEL                     L"\
\nset loglevel %1!s!"

#define DMP_IP_SET_IF                           L"\
\nset interface name=%1!s! state=%2!s! disc=%3!s! minint=%4!d!\
 maxint=%5!d! life=%6!d! level=%7!d!"

#define DMP_IP_SET_RTR_DISC_INFO                L"\
\nset interface name=%1!s! disc=%2!s! minint=%3!d!\
 maxint=%4!d! life=%5!d! level=%6!d!"

#define DMP_IP_SET_IF_FILTER_FRAG               L"\
\nset filter name=%1!s! fragcheck=%2!s!"

#define DMP_IP_SET_IF_FILTER                    L"\
\nset filter name=%1!s! filtertype=%2!s! action=%3!s!"

#define DMP_IP_ADD_IPIPTUNNEL                   L"\
\nadd ipiptunnel name=%1!s! localaddr=%2!s! remaddr=%3!s! ttl=%4!d!"

#define DMP_ROUTING_HEADER                      L"pushd routing\nreset"

#define DMP_IP_HEADER                           L"pushd routing ip\nreset"

#define DMP_POPD                                L"\npopd\n"

#define DMP_SCOPE_INFO                          L"\
\nadd scope grpaddr=%1!hs! grpmask=%2!hs! scopename=%3!s!"

#define DMP_BOUNDARY_INFO                       L"\
\nadd boundary name=%1!s! grpaddr=%2!hs! grpmask=%3!hs!"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\mprip.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\mprip.h

Abstract:

    Prototypes for functions exported by mprip.c

Revision History:

    Anand Mahalingam         7/29/98  Created

--*/


VOID
FreeInfoBuffer(
    IN  PVOID   pvBuffer
    );

DWORD
WINAPI
IpmontrDeleteInfoBlockFromGlobalInfo(
    IN  DWORD   dwRoutingProtId
    );

DWORD
WINAPI
IpmontrDeleteInfoBlockFromInterfaceInfo(
    IN  LPCWSTR  pwszIfName,
    IN  DWORD    dwRoutingProtId
    );

DWORD
WINAPI
IpmontrDeleteProtocol(
    IN  DWORD dwRoutingProtId
    );

DWORD
WINAPI
IpmontrGetInfoBlockFromGlobalInfo(
    IN  DWORD   dwType,
    OUT PBYTE   *ppbInfoBlk, OPTIONAL
    OUT PDWORD  pdwSize,
    OUT PDWORD  pdwCount
    );

DWORD
WINAPI
IpmontrGetInfoBlockFromInterfaceInfo(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT PBYTE   *ppbInfoBlk,
    OUT PDWORD  pdwSize,
    OUT PDWORD  pdwCount,
    OUT PDWORD  pdwIfType
    );

DWORD
WINAPI
IpmontrSetInfoBlockInGlobalInfo(
    IN    DWORD    dwType,
    IN    PBYTE    pbInfoBlk,
    IN    DWORD    dwSize,
    IN    DWORD    dwCount
    );

DWORD
WINAPI
IpmontrSetInfoBlockInInterfaceInfo(
    IN    LPCWSTR   pwszIfName,
    IN    DWORD     dwType,
    IN    PBYTE     pbInfoBlk,
    IN    DWORD     dwSize,
    IN    DWORD     dwCount
    );

DWORD WINAPI
IpmontrGetInterfaceType(
    IN    LPCWSTR   pwszIfName,
    OUT   PDWORD    pdwIfType
    );

DWORD 
WINAPI
GetInterfaceName(
    IN  LPCWSTR ptcArgument,
    OUT LPWSTR  pwszIfName,
    IN  DWORD   dwSizeOfIfName,
    OUT PDWORD  pdwNumParsed
    );

DWORD
WINAPI
GetInterfaceDescription(
    IN      LPCWSTR    pwszIfName,
    OUT     LPWSTR     pwszIfDesc,
    OUT     PDWORD     pdwNumParsed
    );

DWORD
WINAPI
InterfaceEnum(
    OUT    PBYTE               *ppb,
    OUT    PDWORD              pdwCount,
    OUT    PDWORD              pdwTotal
    );

DWORD
WINAPI
MatchRoutingProtoTag(
    IN  LPCWSTR pwszToken
    );

BOOL
WINAPI
IsRouterRunning(
    VOID
    );

DWORD
MibGet(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );

DWORD
MibGetFirst(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );

DWORD
MibGetNext(
    DWORD   dwTransportId,
    DWORD   dwRoutingPid,
    LPVOID  lpInEntry,
    DWORD   dwInEntrySize,
    LPVOID *lplpOutEntry,
    LPDWORD lpdwOutEntrySize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\route.h ===
#define ALL_FIELDS_SPECIFIED  0x00

#define PREF_NOT_SPECIFIED    0x01
#define METRIC_NOT_SPECIFIED  0x02
#define VIEW_NOT_SPECIFIED    0x04

#define FIELDS_NOT_SPECIFIED  0x0F

DWORD
AddSetDelRtmRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    );

DWORD
AddSetDelPersistentRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    );

DWORD
AddRoute(
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount,
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    );

DWORD
SetRoute(
    IN      PINTERFACE_ROUTE_INFO pTable,
    IN      PINTERFACE_ROUTE_INFO pRoute,
    IN      DWORD                 dwIfType,
    IN      DWORD                 dwFlags,
    IN OUT  PDWORD                pdwCount
    );

DWORD
DeleteRoute(
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount,
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    );

BOOL
IsRoutePresent(
    IN  PINTERFACE_ROUTE_INFO pTable,
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  DWORD                 dwIfType,
    IN  ULONG                 ulCount,
    OUT PULONG                pulIndex
    );

DWORD
ShowIpPersistentRoute(
    IN     HANDLE  hFile,  OPTIONAL
    IN     LPCWSTR pwszIfName,
    IN OUT PDWORD  pdwNumRows
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\routing.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\ipmon\routing.h

Abstract:

     Prototype for fns called in routing.c

Author:

     Dave Thaler         3/03/99

--*/

extern const GUID g_RoutingGuid;
extern const GUID g_NetshGuid;

NS_HELPER_START_FN RoutingStartHelper;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\routing.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ip\ipmon\routing.c

Abstract:

    Routing Command dispatcher.

Revision History:

    Dave Thaler              3/03/99  Created

--*/

#include "precomp.h"

const GUID g_RoutingGuid = ROUTING_GUID;
const GUID g_NetshGuid   = NETSH_ROOT_GUID;
PWCHAR g_pwszRouter      = NULL;

HRESULT RouterReset(LPCTSTR pszMachineName);

NS_CONTEXT_DUMP_FN     RoutingDump;
NS_CONTEXT_CONNECT_FN  RoutingConnect;

FN_HANDLE_CMD HandleRoutingReset;

DWORD                ParentVersion;
BOOL                 g_bRoutingDirty = FALSE;

CMD_ENTRY g_RoutingCmds[] =
{
    CREATE_CMD_ENTRY(IP_RESET, HandleRoutingReset),
};

ULONG g_ulRoutingNumTopCmds = sizeof(g_RoutingCmds)/sizeof(CMD_ENTRY);

DWORD
WINAPI
RoutingStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    ParentVersion         = dwVersion;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext   = L"routing";
    attMyAttributes.guidHelper    = g_RoutingGuid;
    attMyAttributes.dwVersion     = 1;
    attMyAttributes.dwFlags       = 0;
    attMyAttributes.ulNumTopCmds  = g_ulRoutingNumTopCmds;
    attMyAttributes.pTopCmds      = (CMD_ENTRY (*)[])&g_RoutingCmds;
    attMyAttributes.ulNumGroups   = 0; 
    attMyAttributes.pCmdGroups    = NULL;
    attMyAttributes.pfnCommitFn   = NULL; // RoutingCommit;
    attMyAttributes.pfnDumpFn     = RoutingDump;
    attMyAttributes.pfnConnectFn  = RoutingConnect;

    dwErr = RegisterContext( &attMyAttributes );

    return dwErr;
}

DWORD
HandleRoutingReset(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    // Call KennT's "router upgrade" function
    RouterReset( g_pwszRouter );

    return NO_ERROR;
}

DWORD
ConnectToRouter(
    IN  LPCWSTR  pwszRouter
    )
{
    DWORD    rc;

    if (g_pwszRouter != pwszRouter)
    {
        if (g_hMprConfig)
        {
            MprConfigServerDisconnect(g_hMprConfig);
            g_hMprConfig = NULL;
        }

        if (g_hMprAdmin)
        {
            MprAdminServerDisconnect(g_hMprAdmin);
            g_hMprAdmin = NULL;
        }

        if (g_hMIBServer)
        {
            MprAdminMIBServerDisconnect(g_hMIBServer);
            g_hMIBServer = NULL;
        }

        if (g_pwszRouter)
        {
            FREE(g_pwszRouter);
            g_pwszRouter = NULL;
        }

        if (pwszRouter)
        {
            g_pwszRouter = MALLOC((wcslen(pwszRouter)+1)*sizeof(WCHAR));
            if (g_pwszRouter)
            {
                wcscpy(g_pwszRouter, pwszRouter);
            }
            else
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if (!g_hMprConfig)
    {
        //
        // first time connecting to router config
        //

        rc = MprConfigServerConnect ((LPWSTR)pwszRouter,
                                     &g_hMprConfig);

        if (rc isnot NO_ERROR)
        {
            //
            // cannot connect to router config.
            //
            return ERROR_CONNECT_REMOTE_CONFIG;
        }
    }

    //
    // Check to see if router is running. If so, get the handles
    //

    do
    {
        if (MprAdminIsServiceRunning((LPWSTR)pwszRouter))
        {
            if (MprAdminServerConnect((LPWSTR)pwszRouter, &g_hMprAdmin) == NO_ERROR)
            {
                DEBUG("Got admin handle");
                if (MprAdminMIBServerConnect ((LPWSTR)pwszRouter,
                                              &g_hMIBServer) == NO_ERROR)
                {
                    DEBUG("Got server handle");
                    break;
                }
                else
                {
                    MprAdminServerDisconnect (g_hMprAdmin);
                }
            }
        }
        g_hMprAdmin = g_hMIBServer = NULL;

    } while (FALSE);

    return NO_ERROR;
}

DWORD WINAPI
RoutingConnect(
    IN  LPCWSTR  pwszRouter
    )
{
    // If context info is dirty, reregister it
    if (g_bRoutingDirty)
    {
        RoutingStartHelper(NULL, ParentVersion);
    }

    return ConnectToRouter(pwszRouter);
}

DWORD
RoutingDump(
    IN  LPCWSTR     pwszRouter,
    IN  WCHAR     **ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  PVOID       pvData
    )
{    
    DWORD dwErr;

    dwErr = ConnectToRouter(pwszRouter);

    // Dump routing information
    DisplayMessage( g_hModule, DMP_ROUTING_HEADER_COMMENTS);
    DisplayMessageT(DMP_ROUTING_HEADER);
    DisplayMessageT(DMP_POPD);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\route.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    routing\netsh\ip\route.c

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
AddSetDelRtmRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    )

/*++

Routine Description:

    Adds/deletes normal (read as non persistant)
    routes on interfaces.

Arguments:

    pRoute        - route to add/set/delete
    pwszIfName    -  Interface Name
    dwCommand     -  Add, set, or delete
    
Return Value:

    NO_ERROR
    
--*/

{
    ULONG                 dwOutEntrySize;
    DWORD                 dwRes, i;
    PMIB_IPDESTTABLE      lpTable;
    PMIB_IPDESTROW        pEntry;
    MIB_OPAQUE_QUERY      QueryBuff[3]; // more than enough
    MIB_OPAQUE_QUERY     *pQuery = QueryBuff;
    PMIB_OPAQUE_INFO      pInfo;
    DEFINE_MIB_BUFFER(pRouteInfo, MIB_IPDESTROW, pRouteRow);

    if (!pRoute->dwRtInfoIfIndex)
    {
        //
        // Get the interface index from friendly name
        //

        dwRes = IpmontrGetIfIndexFromFriendlyName(g_hMIBServer,
                                                  pwszIfName,
                                                  &pRoute->dwRtInfoIfIndex);
        if (dwRes != NO_ERROR)
        {
            return dwRes;
        }

        //
        // The interface probably is disconnected
        //

        if (pRoute->dwRtInfoIfIndex == 0)
        {
            DisplayMessage(g_hModule, EMSG_INTERFACE_INVALID_OR_DISC);
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Use MprAdmin api to add, del or set entry
    //

    switch(dwCommand) 
    {
    case ADD_COMMAND:
    case SET_COMMAND:

        //
        // Does this route already exist in the router ?
        //

        // Get all this protocol routes on dest

        pQuery->dwVarId = ROUTE_MATCHING;

        pQuery->rgdwVarIndex[0] = pRoute->dwRtInfoDest;
        pQuery->rgdwVarIndex[1] = pRoute->dwRtInfoMask;
        pQuery->rgdwVarIndex[2] = RTM_VIEW_MASK_ANY;
        pQuery->rgdwVarIndex[3] = pRoute->dwRtInfoProto;

        pInfo = NULL;

        dwRes = MibGet(PID_IP,
                       IPRTRMGR_PID,
                       (PVOID) pQuery,
                       sizeof(MIB_OPAQUE_QUERY) + 3 * sizeof(DWORD),
                       (PVOID *) &pInfo,
                       &dwOutEntrySize);

        if ( dwRes isnot NO_ERROR )
        {
            DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwRes );
            return dwRes;
        }

        if ( pInfo isnot NULL )
        {
            //
            // Search for a matching route 
            //

            lpTable = (PMIB_IPDESTTABLE)(pInfo->rgbyData);

            for (i=0; i<lpTable->dwNumEntries; i++)
            {
                pEntry = &lpTable->table[i];

                if ((pEntry->dwForwardIfIndex == pRoute->dwRtInfoIfIndex) &&
                    (pEntry->dwForwardNextHop == pRoute->dwRtInfoNextHop))
                {
                    break;
                }
            }

            if (i == lpTable->dwNumEntries)
            {
                //
                // No matching route found - quit if set
                //

                if (dwCommand == SET_COMMAND)
                {
                    MprAdminMIBBufferFree((PVOID)pInfo);
                    return ERROR_NOT_FOUND;
                }
            }
            else
            {
                //
                // A matching route found - quit if add
                //

                if (dwCommand == ADD_COMMAND)
                {
                    MprAdminMIBBufferFree((PVOID)pInfo);
                    return ERROR_OBJECT_ALREADY_EXISTS;
                }
            }
        }
        else
        {
            //
            // No matching routes found - quit if set
            //

            if (dwCommand == SET_COMMAND)
            {
                return ERROR_NOT_FOUND;
            }
        }

        //
        // Convert the route to a ip route row format
        //

        pRouteInfo->dwId = ROUTE_MATCHING;

        pRouteRow->dwForwardDest       = pRoute->dwRtInfoDest;
        pRouteRow->dwForwardMask       = pRoute->dwRtInfoMask;
        pRouteRow->dwForwardPolicy     = 0;
        pRouteRow->dwForwardNextHop    = pRoute->dwRtInfoNextHop;
        pRouteRow->dwForwardIfIndex    = pRoute->dwRtInfoIfIndex;
        pRouteRow->dwForwardType       = 0;
        pRouteRow->dwForwardProto      = pRoute->dwRtInfoProto;
        pRouteRow->dwForwardAge        = INFINITE;
        pRouteRow->dwForwardNextHopAS  = 0;
        pRouteRow->dwForwardMetric1    = pRoute->dwRtInfoMetric1;
        pRouteRow->dwForwardMetric2    = pRoute->dwRtInfoMetric2;
        pRouteRow->dwForwardMetric3    = pRoute->dwRtInfoMetric3;
        pRouteRow->dwForwardMetric4    = MIB_IPROUTE_METRIC_UNUSED;
        pRouteRow->dwForwardMetric5    = MIB_IPROUTE_METRIC_UNUSED;
        pRouteRow->dwForwardPreference = pRoute->dwRtInfoPreference;
        pRouteRow->dwForwardViewSet    = pRoute->dwRtInfoViewSet;

        if (dwCommand == ADD_COMMAND)
        {
            dwRes = MprAdminMIBEntryCreate(g_hMIBServer,
                                           PID_IP,
                                           IPRTRMGR_PID,
                                           (PVOID)pRouteInfo,
                                           MIB_INFO_SIZE(MIB_IPDESTROW));
        }
        else
        {
            if (dwFlags & FIELDS_NOT_SPECIFIED)
            {
                //
                // Get the old preference, metric, or view
                //

                if (dwFlags & PREF_NOT_SPECIFIED)
                {
                    pRouteRow->dwForwardPreference=pEntry->dwForwardPreference;
                }

                if (dwFlags & METRIC_NOT_SPECIFIED)
                {
                    pRouteRow->dwForwardMetric1 = pEntry->dwForwardMetric1;
                }

                if (dwFlags & VIEW_NOT_SPECIFIED)
                {
                    pRouteRow->dwForwardViewSet = pEntry->dwForwardViewSet;
                }
            }

            dwRes = MprAdminMIBEntrySet(g_hMIBServer,
                                        PID_IP,
                                        IPRTRMGR_PID,
                                        (PVOID)pRouteInfo,
                                        MIB_INFO_SIZE(MIB_IPDESTROW));
        }

        // Free the old route information obtained
        if (pInfo)
        {
            MprAdminMIBBufferFree((PVOID)pInfo);
        }

        break;
        
    case DELETE_COMMAND:
    {
        DWORD               rgdwInfo[6];
        PMIB_OPAQUE_QUERY   pIndex = (PMIB_OPAQUE_QUERY)rgdwInfo;

        pIndex->dwVarId = ROUTE_MATCHING;

        pIndex->rgdwVarIndex[0]  = pRoute->dwRtInfoDest;
        pIndex->rgdwVarIndex[1]  = pRoute->dwRtInfoMask;
        pIndex->rgdwVarIndex[2]  = pRoute->dwRtInfoIfIndex;
        pIndex->rgdwVarIndex[3]  = pRoute->dwRtInfoNextHop;
        pIndex->rgdwVarIndex[4]  = pRoute->dwRtInfoProto;

        dwRes = MprAdminMIBEntryDelete(g_hMIBServer,
                                       PID_IP,
                                       IPRTRMGR_PID,
                                       (PVOID)pIndex,
                                       sizeof(rgdwInfo));
        break;
    }

    default:
        dwRes = ERROR_INVALID_PARAMETER;
    }
    
    return dwRes;
}


DWORD
AddSetDelPersistentRouteInfo(
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  LPCWSTR               pwszIfName,
    IN  DWORD                 dwCommand,
    IN  DWORD                 dwFlags
    )

/*++

Routine Description:

    Adds/deletes persitant routes on interfaces.

Arguments:

    route         - route to add/set/delete
    pwszIfName    -  Interface Name
    dwCommand     -  Add, set, or delete
    
Return Value:

    ERROR_OKAY
    
--*/

{
    DWORD                 dwRes;
    PINTERFACE_ROUTE_INFO pOldTable, pNewTable;
    DWORD                 dwIfType, dwSize, dwCount;

    pNewTable = NULL;
   
    do
    {
        dwRes = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                                     IP_ROUTE_INFO,
                                                     (PBYTE *) &pOldTable,
                                                     &dwSize,
                                                     &dwCount,
                                                     &dwIfType);

        if((dwRes is ERROR_NOT_FOUND) &&
           dwCommand is ADD_COMMAND)
        {
            //
            // No route info but we are asked to add
            //
            
            pOldTable   = NULL;
            dwRes       = NO_ERROR;
            dwCount     = 0;
        }
        
        if(dwRes isnot NO_ERROR)
        {
            break;
        }

        //
        // These take the old table and return a new one in its stead
        //
        
        switch(dwCommand) 
        {
        case ADD_COMMAND:
            dwRes = AddRoute(pOldTable,
                             pRoute,
                             dwIfType,
                             &dwCount,
                             &pNewTable);
            break;
        
        case DELETE_COMMAND:
            dwRes = DeleteRoute(pOldTable,
                                pRoute,
                                dwIfType,
                                &dwCount,
                                &pNewTable);
            break;

        case SET_COMMAND:

            dwRes = SetRoute(pOldTable,
                             pRoute,
                             dwIfType,
                             dwFlags,
                             &dwCount);

            pNewTable = pOldTable;
            pOldTable = NULL;

            break;
        }
            
        if(dwRes != NO_ERROR)
        {
            break;
        }

        //
        // Set the new info back
        //
        
        dwRes = IpmontrSetInfoBlockInInterfaceInfo(pwszIfName,
                                                  IP_ROUTE_INFO,
                                                  (PBYTE)pNewTable,
                                                  sizeof(INTERFACE_ROUTE_INFO),
                                                  dwCount);
        
        
        if(dwRes != NO_ERROR)
        {
            break;
        }
        
        
        pNewTable = NULL;
        
 
    } while ( FALSE );

    if(pOldTable)
    {
        FREE_BUFFER(pOldTable);
    }
        

    if(pNewTable)
    {
        HeapFree(GetProcessHeap(),
                 0,
                 pNewTable);

        pNewTable = NULL;
    }


    switch(dwRes)
    {
        case NO_ERROR:
        {
            dwRes = ERROR_OKAY;
            break;
        }

        case ERROR_NOT_FOUND:
        {
            WCHAR  wszBuffer[MAX_INTERFACE_NAME_LEN+1];
            DWORD  dwSizeTemp = sizeof(wszBuffer);
            IpmontrGetFriendlyNameFromIfName( pwszIfName, wszBuffer, &dwSizeTemp);

            DisplayMessage(g_hModule, EMSG_IP_NO_ROUTE_INFO, wszBuffer);

            dwRes = ERROR_SUPPRESS_OUTPUT;

            break;
        }
        
        case ERROR_NOT_ENOUGH_MEMORY:
        {
            DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);

            dwRes = ERROR_SUPPRESS_OUTPUT;
            
            break;
        }
    }
    
    return dwRes;
}

DWORD
SetRoute( 
    IN      PINTERFACE_ROUTE_INFO pTable,
    IN      PINTERFACE_ROUTE_INFO pRoute,
    IN      DWORD                 dwIfType,
    IN      DWORD                 dwFlags,
    IN OUT  PDWORD                pdwCount
    )
{
    ULONG   ulIndex, i;
    
    //
    // If the count is 0, the function will return false
    // and we will error out
    //
    
    if(!IsRoutePresent(pTable,
                       pRoute,
                       dwIfType,
                       *pdwCount,
                       &ulIndex))
    {
        return ERROR_NOT_FOUND;
    }

    if (dwFlags & FIELDS_NOT_SPECIFIED)
    {
        //
        // Preserve the old values if not specified
        //

        if (dwFlags & PREF_NOT_SPECIFIED)
        {
            pRoute->dwRtInfoPreference = pTable[ulIndex].dwRtInfoPreference;
        }

        if (dwFlags & METRIC_NOT_SPECIFIED)
        {
            pRoute->dwRtInfoMetric1 = pTable[ulIndex].dwRtInfoMetric1;
        }

        if (dwFlags & VIEW_NOT_SPECIFIED)
        {
            pRoute->dwRtInfoViewSet = pTable[ulIndex].dwRtInfoViewSet;
        }
    }

    pTable[ulIndex] = *pRoute;

    return NO_ERROR;
}

DWORD
AddRoute( 
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount, 
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    )

/*++

Routine Description:

    Adds a route to the current info

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    ULONG   ulIndex, i;

    
    if(IsRoutePresent(pOldTable,
                      pRoute,
                      dwIfType,
                      *pdwCount,
                      &ulIndex))
    {
        return ERROR_OBJECT_ALREADY_EXISTS;
            
    }

    //
    // Just create a block with size n + 1
    //
    
    *ppNewTable = HeapAlloc(GetProcessHeap(),
                            0,
                            ((*pdwCount) + 1) * sizeof(INTERFACE_ROUTE_INFO));
    
    if(*ppNewTable is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i = 0; i < *pdwCount; i++)
    {
        //
        // structure copy
        //
        
        (*ppNewTable)[i] = pOldTable[i];
    } 

    //
    // copy the new route
    //

    
    (*ppNewTable)[i] = *pRoute;
        
    *pdwCount += 1;
    
    return NO_ERROR;
}

DWORD
DeleteRoute( 
    IN      PINTERFACE_ROUTE_INFO  pOldTable,
    IN      PINTERFACE_ROUTE_INFO  pRoute,
    IN      DWORD                  dwIfType,
    IN OUT  PDWORD                 pdwCount,
    OUT     INTERFACE_ROUTE_INFO **ppNewTable
    )

/*++

Routine Description:

    Deletes a route from an interface

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    ULONG   ulIndex, i, j;
    
    //
    // If the count is 0, the function will return false
    // and we will error out
    //
    
    if(!IsRoutePresent(pOldTable,
                       pRoute,
                       dwIfType,
                       *pdwCount,
                       &ulIndex))
    {
        return ERROR_NOT_FOUND;
    }


    //
    // If the count is 1
    //
    
    *pdwCount -= 1;
        
    if(*pdwCount is 0)
    {
        *ppNewTable = NULL;

        return NO_ERROR;
    }

    
    //
    // delete the route
    //

    *ppNewTable = HeapAlloc(GetProcessHeap(),
                            0,
                            (*pdwCount) * sizeof(INTERFACE_ROUTE_INFO));
    
    if(*ppNewTable is NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    i = j = 0;
    
    while(i <= *pdwCount)
    {
        if(i == ulIndex)
        {
            i++;
            continue;
        }
        
        //
        // structure copy
        //
        
        (*ppNewTable)[j] = pOldTable[i];

        i++;
        j++;
    } 

    return NO_ERROR;
}


BOOL
IsRoutePresent(
    IN  PINTERFACE_ROUTE_INFO pTable,
    IN  PINTERFACE_ROUTE_INFO pRoute,
    IN  DWORD                 dwIfType,
    IN  ULONG                 ulCount,
    OUT PULONG                pulIndex
    )

/*++

Routine Description:

    Checks to see if interface is already present

Arguments:

Return Value:

    NO_ERROR
    
--*/

{
    ULONG   i;
    BOOL    bDontMatchNHop;

    if((dwIfType is ROUTER_IF_TYPE_DEDICATED) or
       (dwIfType is ROUTER_IF_TYPE_INTERNAL))
    {
        bDontMatchNHop = FALSE;
    }
    else
    {
        bDontMatchNHop = TRUE;
    }

    // Do this check just to keep the prefix checker happy
    if (pTable is NULL)
    {
        return FALSE;
    }
    
    for(i = 0; i < ulCount; i++)
    {
        if((pTable[i].dwRtInfoDest is pRoute->dwRtInfoDest) and
           (pTable[i].dwRtInfoMask is pRoute->dwRtInfoMask) and
#if 0
           (pTable[i].dwRtInfoProto is pRoute->dwRtInfoProto) and
#endif
           (bDontMatchNHop or
            (pTable[i].dwRtInfoNextHop is pRoute->dwRtInfoNextHop)))
        {
            *pulIndex = i;

            return TRUE;
        }
    }

    return FALSE;
}


DWORD
ShowIpPersistentRoute(
    IN     HANDLE  hFile,  OPTIONAL
    IN     LPCWSTR pwszIfName,
    IN OUT PDWORD  pdwNumRows
    )

/*++

Routine Description:

    Show the static (persistent) routes on the interface

Arguments:

    pwszIfName - Interface name

Return Value:

    NO_ERROR

--*/

{
    PINTERFACE_ROUTE_INFO pRoutes;

    DWORD   dwErr, dwBlkSize, dwCount, dwIfType, dwNumParsed, i;
    WCHAR   wszNextHop[ADDR_LENGTH + 1];
    WCHAR   wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];
    PWCHAR  pwszProto, pwszToken, pwszQuoted;
    WCHAR   wszViews[3];

    dwErr = GetInterfaceDescription(pwszIfName,
                                    wszIfDesc,
                                    &dwNumParsed);

    if (!dwNumParsed)
    {
        wcscpy(wszIfDesc, pwszIfName);
    }

    //
    // Retrieve the routes
    //

    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                                 IP_ROUTE_INFO,
                                                 (PBYTE *) &pRoutes,
                                                 &dwBlkSize,
                                                 &dwCount,
                                                 &dwIfType);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    if((pRoutes == NULL) ||
       (dwCount == 0))
    {
        return NO_ERROR;
    }

    if(hFile == NULL)
    {
        if (*pdwNumRows is 0)
        {
            DisplayMessage(g_hModule, MSG_RTR_ROUTE_HDR);
        }

        pwszQuoted = NULL;
    }
    else
    {
        pwszQuoted = MakeQuotedString(wszIfDesc);
    }

    for(i = 0; i < dwCount; i++)
    {
        wszViews[0] = (pRoutes[i].dwRtInfoViewSet & RTM_VIEW_MASK_UCAST)? 'U':' ';
        wszViews[1] = (pRoutes[i].dwRtInfoViewSet & RTM_VIEW_MASK_MCAST)? 'M':' ';
        wszViews[2] = '\0';

        switch(pRoutes[i].dwRtInfoProto)
        {
            case PROTO_IP_NT_AUTOSTATIC:
            {
                pwszProto = MakeString(g_hModule, STRING_NT_AUTOSTATIC);
                pwszToken = TOKEN_VALUE_AUTOSTATIC;
    
                break;
            }

            case PROTO_IP_NT_STATIC:
            {
                pwszProto = MakeString(g_hModule, STRING_STATIC);
                pwszToken = TOKEN_VALUE_STATIC;
    
                break;
            }

            case PROTO_IP_NT_STATIC_NON_DOD:
            {
                pwszProto = MakeString(g_hModule, STRING_NONDOD);
                pwszToken = TOKEN_VALUE_NONDOD;
    
                break;
            }

            default:
            {
                pwszProto = MakeString(g_hModule, STRING_PROTO_UNKNOWN);
                pwszToken = NULL;
 
                break;
            }
        }

        MakeUnicodeIpAddr(wszNextHop,
                          inet_ntoa(*((struct in_addr *)&(pRoutes[i].dwRtInfoNextHop))));

        if(hFile)
        {
            if(pwszToken)
            {
                WCHAR   wszMask[ADDR_LENGTH + 1], wszDest[ADDR_LENGTH + 1];
                PWCHAR  pwszView = NULL;

                MakeUnicodeIpAddr(wszDest,
                                  inet_ntoa(*((struct in_addr *)&(pRoutes[i].dwRtInfoDest))));
                MakeUnicodeIpAddr(wszMask,
                                  inet_ntoa(*((struct in_addr *)&(pRoutes[i].dwRtInfoMask))));

                switch (pRoutes[i].dwRtInfoViewSet)
                { 
                case RTM_VIEW_MASK_UCAST: pwszView=TOKEN_VALUE_UNICAST  ; break;
                case RTM_VIEW_MASK_MCAST: pwszView=TOKEN_VALUE_MULTICAST; break;
                case RTM_VIEW_MASK_UCAST
                    |RTM_VIEW_MASK_MCAST: pwszView=TOKEN_VALUE_BOTH; break;
                }

                if (pwszView)
                {
                    DisplayMessageT( DMP_IP_ADDSET_PERSISTENTROUTE,
                                     wszDest,
                                     wszMask,
                                     pwszQuoted,
                                     wszNextHop,
                                     pwszToken,
                                     pRoutes[i].dwRtInfoPreference,
                                     pRoutes[i].dwRtInfoMetric1,
                                     pwszView );
                }
            }
        }
        else
        {
            WCHAR wcszBuffer[80];

            MakePrefixStringW( wcszBuffer,
                               pRoutes[i].dwRtInfoDest,
                               pRoutes[i].dwRtInfoMask );

            DisplayMessage(g_hModule,
                           MSG_RTR_ROUTE_INFO,
                           wcszBuffer,
                           pwszProto,
                           pRoutes[i].dwRtInfoPreference,
                           pRoutes[i].dwRtInfoMetric1,
                           wszNextHop,
                           wszViews,
                           wszIfDesc);

            (*pdwNumRows)++;
        }
      
        FreeString(pwszProto); 
    }

    if(pwszQuoted)
    {
        FreeQuotedString(pwszQuoted);
    }

    HeapFree(GetProcessHeap(), 
             0, 
             pRoutes);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\rtmv2.c ===
#include "precomp.h"
#pragma hdrstop

#define DEFAULT_VIEW_MASK RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST // both
#define DEFAULT_VIEW_ID   RTM_VIEW_ID_UCAST
#define DEFAULT_ADDR      0                   // 0.0.0.0
#define DEFAULT_MASK      0                   // 0.0.0.0
#define DEFAULT_PROTO     RTM_BEST_PROTOCOL

DWORD
HandleIpShowRtmDestinations(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    TAG_TYPE            pttTags[] = {{TOKEN_OPERATOR,    FALSE,FALSE},
                                     {TOKEN_DEST,        FALSE,FALSE},
                                     {TOKEN_MASK,        FALSE,FALSE},
                                     {TOKEN_VIEW,        FALSE,FALSE},
                                     {TOKEN_PROTOCOL,    FALSE,FALSE}};
    DWORD               pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD               dwErr, i, dwOperator = DEST_LONGER;
    DWORD               dwViewMask = DEFAULT_VIEW_MASK;
    DWORD               dwProtocol = DEFAULT_PROTO;
    IPV4_ADDRESS        ipMask     = DEFAULT_MASK;
    IPV4_ADDRESS        ipAddress  = DEFAULT_ADDR;
    MIB_OPAQUE_QUERY    QueryBuff[3]; // more than enough
    MIB_OPAQUE_QUERY   *pQuery = QueryBuff;
    DWORD               dwOutEntrySize, dwCount;
    PMIB_OPAQUE_INFO    pRpcInfo;
    PMIB_IPDESTTABLE    lprpcTable;
    WCHAR               wcszBuffer[80], wcszNHop[80];
    WCHAR               wcszName[MAX_INTERFACE_NAME_LEN+1];
    WCHAR               wszViews[3];

    //
    // We can show non persistent info only if router is running
    //

    CHECK_ROUTER_RUNNING();

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwArgCount -= dwCurrentIndex;

    for (i=0; i<dwArgCount; i++) 
    {
        switch(pdwTagType[i])
        {
            case 0: // OPERATOR
            {
                TOKEN_VALUE rgEnums[] ={{ TOKEN_VALUE_MATCHING, DEST_MATCHING},
                                        { TOKEN_VALUE_LONGER,   DEST_LONGER },
                                        { TOKEN_VALUE_SHORTER,  DEST_SHORTER}};

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &dwOperator);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 1: // ADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &ipAddress,
                                     &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 2: // MASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 3: // VIEW
            {
                TOKEN_VALUE rgMaskEnums[] = {
                 { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                 { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                 { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                                         |RTM_VIEW_MASK_MCAST   } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &dwViewMask);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;
                    
                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 4: // PROTO
            {
                dwProtocol = 
                    MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);
                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // Compose MIB query

    pQuery->dwVarId = dwOperator;
    pQuery->rgdwVarIndex[0] = ipAddress;
    pQuery->rgdwVarIndex[1] = ipMask;
    pQuery->rgdwVarIndex[2] = dwViewMask;
    pQuery->rgdwVarIndex[3] = dwProtocol;

    dwErr = MibGet(              PID_IP,
                                 IPRTRMGR_PID,
                                 (PVOID) pQuery,
                                 sizeof(MIB_OPAQUE_QUERY) + 3*sizeof(DWORD),
                                 (PVOID *) &pRpcInfo,
                                 &dwOutEntrySize );

    if ( dwErr isnot NO_ERROR )
    {
        DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwErr );
        return dwErr;
    }

    if ( pRpcInfo is NULL )
    {
        DisplayMessage(g_hModule, MSG_IP_NO_ENTRIES );
        return dwErr;
    }

    // Display info
    lprpcTable = (PMIB_IPDESTTABLE)(pRpcInfo->rgbyData);
    dwCount = lprpcTable->dwNumEntries;

    DisplayMessage( g_hModule, MSG_RTR_ROUTE_HDR );

    for (i=0; i<dwCount; i++)
    {
        MakePrefixStringW( wcszBuffer, 
                           lprpcTable->table[i].dwForwardDest,
                           lprpcTable->table[i].dwForwardMask );

        if (IpmontrGetFriendlyNameFromIfIndex( g_hMIBServer,
                                    lprpcTable->table[i].dwForwardIfIndex,
                                    wcszName,
                                    sizeof(wcszName) ) != NO_ERROR)
        {
            //
            // If we do not have a name for this index, display index
            //

            swprintf( wcszName, 
                      L"0x%x",
                      lprpcTable->table[i].dwForwardIfIndex );
        }


        MakeAddressStringW( wcszNHop,
                            lprpcTable->table[i].dwForwardNextHop );

        wszViews[0] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_UCAST)? 'U':' ';
        wszViews[1] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_MCAST)? 'M':' ';
        wszViews[2] = '\0';

        DisplayMessage( g_hModule, MSG_RTR_ROUTE_INFO,
                         wcszBuffer,
                         GetProtoProtoString( 
                            PROTO_TYPE_UCAST, 
                            0, 
                            lprpcTable->table[i].dwForwardProto ),
                         lprpcTable->table[i].dwForwardPreference,
                         lprpcTable->table[i].dwForwardMetric1,
                         wcszNHop,
                         wszViews,
                         wcszName );
    }

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return dwErr;
}

DWORD
HandleIpShowRtmRoutes(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    TAG_TYPE            pttTags[] = {{TOKEN_OPERATOR,    FALSE,FALSE},
                                     {TOKEN_DEST,        FALSE,FALSE},
                                     {TOKEN_MASK,        FALSE,FALSE},
                                     {TOKEN_VIEW,        FALSE,FALSE},
                                     {TOKEN_PROTOCOL,    FALSE,FALSE}};
    DWORD               pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD               dwErr, i, dwOperator = ROUTE_LONGER;
    DWORD               dwViewMask = DEFAULT_VIEW_MASK;
    DWORD               dwProtocol = DEFAULT_PROTO;
    IPV4_ADDRESS        ipMask     = DEFAULT_MASK;
    IPV4_ADDRESS        ipAddress  = DEFAULT_ADDR;
    MIB_OPAQUE_QUERY    QueryBuff[3]; // more than enough
    MIB_OPAQUE_QUERY   *pQuery = QueryBuff;
    DWORD               dwOutEntrySize, dwCount;
    PMIB_OPAQUE_INFO    pRpcInfo;
    PMIB_IPDESTTABLE    lprpcTable;
    WCHAR               wcszBuffer[80], wcszNHop[80];
    WCHAR               wcszName[MAX_INTERFACE_NAME_LEN+1];
    WCHAR               wszViews[3];

    //
    // We can show non persistent info only if router is running
    //

    CHECK_ROUTER_RUNNING();

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    dwArgCount -= dwCurrentIndex;

    for (i=0; i<dwArgCount; i++) 
    {
        switch(pdwTagType[i])
        {
            case 0: // OPERATOR
            {
                TOKEN_VALUE rgEnums[] ={{ TOKEN_VALUE_MATCHING,ROUTE_MATCHING},
                                        { TOKEN_VALUE_LONGER,  ROUTE_LONGER },
                                        { TOKEN_VALUE_SHORTER, ROUTE_SHORTER}};

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &dwOperator);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 1: // ADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &ipAddress,
                                     &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 2: // MASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &ipMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 3: // VIEW
            {
                TOKEN_VALUE rgMaskEnums[] = {
                 { TOKEN_VALUE_UNICAST,   RTM_VIEW_MASK_UCAST },
                 { TOKEN_VALUE_MULTICAST, RTM_VIEW_MASK_MCAST },
                 { TOKEN_VALUE_BOTH,      RTM_VIEW_MASK_UCAST
                                         |RTM_VIEW_MASK_MCAST   } };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgMaskEnums)/sizeof(TOKEN_VALUE),
                                      rgMaskEnums,
                                      &dwViewMask);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    i = dwArgCount;
                    
                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 4: // PROTO
            {
                dwProtocol = 
                    MatchRoutingProtoTag(ppwcArguments[i + dwCurrentIndex]);

                break;
            }
        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    // Compose MIB query

    pQuery->dwVarId = dwOperator;
    pQuery->rgdwVarIndex[0] = ipAddress;
    pQuery->rgdwVarIndex[1] = ipMask;
    pQuery->rgdwVarIndex[2] = dwViewMask;
    pQuery->rgdwVarIndex[3] = dwProtocol;

    dwErr = MibGet(              PID_IP,
                                 IPRTRMGR_PID,
                                 (PVOID) pQuery,
                                 sizeof(MIB_OPAQUE_QUERY) + 3*sizeof(DWORD),
                                 (PVOID *) &pRpcInfo,
                                 &dwOutEntrySize );

    if ( dwErr isnot NO_ERROR )
    {
        DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwErr );
        return dwErr;
    }

    if ( pRpcInfo is NULL )
    {
        DisplayMessage(g_hModule,  MSG_IP_NO_ENTRIES );
        return dwErr;
    }

    // Display info
    lprpcTable = (PMIB_IPDESTTABLE)(pRpcInfo->rgbyData);
    dwCount = lprpcTable->dwNumEntries;

    DisplayMessage( g_hModule, MSG_RTR_ROUTE_HDR );

    for (i=0; i<dwCount; i++)
    {
        MakePrefixStringW( wcszBuffer, 
                           lprpcTable->table[i].dwForwardDest,
                           lprpcTable->table[i].dwForwardMask );

        if (IpmontrGetFriendlyNameFromIfIndex( g_hMIBServer,
                                    lprpcTable->table[i].dwForwardIfIndex,
                                    wcszName,
                                    sizeof(wcszName) ) != NO_ERROR)
        {
            //
            // If we do not have a name for this index, display index
            //

            swprintf( wcszName, 
                      L"0x%x",
                      lprpcTable->table[i].dwForwardIfIndex );
        }

        MakeAddressStringW( wcszNHop,
                            lprpcTable->table[i].dwForwardNextHop );

        wszViews[0] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_UCAST)? 'U':' ';
        wszViews[1] = (lprpcTable->table[i].dwForwardViewSet & RTM_VIEW_MASK_MCAST)? 'M':' ';
        wszViews[2] = '\0';

        DisplayMessage(  g_hModule, 
                         MSG_RTR_ROUTE_INFO, 
                         wcszBuffer,
                         GetProtoProtoString( 
                            PROTO_TYPE_UCAST, 
                            0, 
                            lprpcTable->table[i].dwForwardProto ),
                         lprpcTable->table[i].dwForwardPreference,
                         lprpcTable->table[i].dwForwardMetric1,
                         wcszNHop,
                         wszViews,
                         wcszName );
    }

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\rtrreset.c ===
//
// This code obtained from KennT  2-June-1999
//
#include "precomp.h"
#pragma hdrstop

// Use the C macros for simpler coding
#define COBJMACROS
#include "remras.h"
#include <objbase.h>

// {1AA7F844-C7F5-11d0-A376-00C04FC9DA04}
const GUID CLSID_RemoteRouterConfig
    = { 0x1aa7f844, 0xc7f5, 0x11d0, { 0xa3, 0x76, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4 } };

// {66A2DB1b-D706-11d0-A37B-00C04FC9DA04}
const GUID IID_IRemoteNetworkConfig = 
    { 0x66a2db1b, 0xd706, 0x11d0, { 0xa3, 0x7b, 0x0, 0xc0, 0x4f, 0xc9, 0xda, 0x4 } };


HRESULT CoCreateRouterConfig(LPCTSTR pszMachine,
							 REFIID riid,
							 IUnknown **ppUnk);
HRESULT RouterReset(LPCTSTR pszMachineName);


#ifdef STANDALONE
void main(int argc, char *argv[])
{
    LPCTSTR pszMachineName = NULL;
    HRESULT hr;
    
    if (argc > 1)
        pszMachineName = argv[1];

    hr = RouterReset(pszMachineName);

    printf("hr=%d\n", hr);
}
#endif

HRESULT RouterReset(LPCTSTR pszMachineName)
{
    IRemoteNetworkConfig *  pNetwork = NULL;
    HRESULT                 hr = S_OK;

    // CoInitialize unless it's already been done
    // ----------------------------------------------------------------
    
    if (CoInitialize(NULL) == S_OK)
    {
        // Create the router configuration object
        // ------------------------------------------------------------
        hr = CoCreateRouterConfig(pszMachineName,
                                  &IID_IRemoteNetworkConfig,
                                  (IUnknown **) &pNetwork);
                                  

        if (hr == S_OK)
        {
            // Ok we succeeded in creating the object, now let's
            // have it do the upgrade.
            // --------------------------------------------------------
            IRemoteNetworkConfig_UpgradeRouterConfig(pNetwork);
            IRemoteNetworkConfig_Release(pNetwork);
            pNetwork = NULL;
        }

        CoUninitialize();
    }

    return hr;
}


/*!--------------------------------------------------------------------------
	CoCreateRouterConfig
        -
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CoCreateRouterConfig(LPCTSTR pszMachine,
                             REFIID riid,
							 IUnknown **ppUnk)
{
	HRESULT		hr = S_OK;
	MULTI_QI	qi;

	*ppUnk = NULL;

    if ((pszMachine == NULL) || (*pszMachine == 0))
	{
        // Hmmm.. this points to a security hole, can anyone
        // create this object?  I need to check for the proper
        // access rights.
        // ------------------------------------------------------------
		hr = CoCreateInstance(&CLSID_RemoteRouterConfig,
							  NULL,
							  CLSCTX_SERVER,
							  riid,
							  (LPVOID *) &(qi.pItf));
	}
	else
	{
		qi.pIID = riid;
		qi.pItf = NULL;
		qi.hr = 0;

		hr = CoCreateInstanceEx(&CLSID_RemoteRouterConfig,
								NULL,
								CLSCTX_SERVER,
								NULL,
								1,
								&qi);
	}

    if (hr == S_OK)
	{
		*ppUnk = qi.pItf;
		qi.pItf = NULL;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\showmib.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\monitor\ip\showmib.h   

Abstract:

    

Author:

     Anand Mahalingam    7/10/98

Revision History:


--*/

#ifndef __IPMON_SHOWMIB_H__
#define __IPMON_SHOWMIB_H__

#define MAX_NUM_INDICES 6

typedef
DWORD
(*PGET_OPT_FN)(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    );

typedef struct _MIB_OBJECT_PARSER
{
    PWCHAR         pwszMIBObj;
    DWORD          dwMinOptArg;
    PGET_OPT_FN    pfnMIBObjParser;
} MIB_OBJECT_PARSER,*PMIB_OBJECT_PARSER;

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBIpAddress(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

    
DWORD
GetMIBIpFwdIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBIpNetIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBTcpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);

DWORD
GetMIBUdpConnIndex(
    IN    PTCHAR    *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
);


extern MIB_OBJECT_PARSER    MIBObjectMap[];
extern ULONG                g_ulNumMibObjects;
extern HANDLE               g_hConsole;

typedef
VOID
(PRINT_FN)(
    IN MIB_SERVER_HANDLE hMibServer,
    IN PMIB_OPAQUE_INFO  pInfo
    );

PRINT_FN PrintIpForwardTable;
PRINT_FN PrintIpForwardRow;

VOID
PrintMfeTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo,
    PDWORD           pdwLastGrp,
    PDWORD           pdwLastSrc,
    PDWORD           pdwLastSrcMask,
    DWORD            dwRangeGrp,
    DWORD            dwRangeGrpMask,
    DWORD            dwRangeSrc,
    DWORD            dwRangeSrcMask,
    DWORD            dwType,
    PBOOL            pbDone
    );

VOID
PrintMfeStatsTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo,
    PDWORD           pdwLastGrp,
    PDWORD           pdwLastSrc,
    PDWORD           pdwLastSrcMask,
    DWORD            dwRangeGrp,
    DWORD            dwRangeGrpMask,
    DWORD            dwRangeSrc,
    DWORD            dwRangeSrcMask,
    DWORD            dwType,
    PBOOL            pbDone,
    BOOL             bStatsAll
);

DWORD
GetMfe(
    MIB_SERVER_HANDLE   hMIBServer,
    BOOL                bIndexPresent,
    PTCHAR             *pptcAruments,
    DWORD               dwNumArg,
    BOOL                bIncludeStats
);

DWORD
GetPrintDestinationInfo(
    MIB_SERVER_HANDLE   hMprMIB,
    BOOL                bIndexPresent,
    PWCHAR             *ppwcArguments,
    DWORD               dwArgCount
    );

DWORD
GetPrintRouteInfo(
    MIB_SERVER_HANDLE   hMprMIB,
    BOOL                bIndexPresent,
    PWCHAR             *ppwcArguments,
    DWORD               dwArgCount
    );

void cls(HANDLE hConsole);

BOOL WINAPI HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    );


#define PRINT_IPADDR(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

typedef PRINT_FN *PPRINT_FN;

typedef struct _MAGIC_TABLE
{
    DWORD      dwId;
    PPRINT_FN  pfnPrintFunction;
}MAGIC_TABLE, *PMAGIC_TABLE;

extern MAGIC_TABLE    MIBVar[];

#define IGMP_GETMODE_EXACT  0
#define IGMP_GETMODE_FIRST  1
#define IGMP_GETMODE_NEXT   2

#define DISPLAYLEN_PHYSADDR 3*MAXLEN_PHYSADDR + 8

#ifdef UNICODE
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    MultiByteToWideChar(GetConsoleOutputCP(),                             \
                        0,                                  \
                        (__szTemp),                         \
                        -1,                                 \
                        (ptszUnicode),                      \
                        3*__i);                             \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#else
#define MakeUnicodePhysAddr(ptszUnicode,pszAddr,dwLen)      \
{                                                           \
    CHAR __szTemp[DISPLAYLEN_PHYSADDR + 1];                 \
    DWORD __i,__dwTempLen;                                  \
    __dwTempLen = (((dwLen) <= MAXLEN_PHYSADDR) ? (dwLen) : MAXLEN_PHYSADDR); \
    for(__i = 0; __i < __dwTempLen; __i++)                  \
    {                                                       \
        sprintf(&(__szTemp[3*__i]),"%02X-",pszAddr[__i]);   \
    }                                                       \
    strncpy((ptszUnicode),__szTemp,3*__i);                  \
    ptszUnicode[(3*__i) - 1] = TEXT('\0');                  \
}
#endif //UNICODE

FN_HANDLE_CMD HandleIpMibShowObject;

#endif // __IPMON_SHOWMIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\showmib.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\showmib.c    

Abstract:

    Fns to parse and show MIB information

Author:

     v raman

Revision History:

     Anand Mahalingam
--*/

#include "precomp.h"
#pragma hdrstop

enum MFETYPES 
{
    NegativeMfe = 0, PositiveMfe, Both
};


HANDLE g_hConsole, g_hStdOut;

MIB_OBJECT_PARSER   MIBObjectMap[] =
{
//  {TOKEN_MIB_OBJECT_IPFORWARD,3,GetMIBIpFwdIndex},
    {TOKEN_MIB_OBJECT_MFE,0,NULL},
    {TOKEN_MIB_OBJECT_MFESTATS,0,NULL},
    {TOKEN_MIB_OBJECT_BOUNDARY,0,NULL},
    {TOKEN_MIB_OBJECT_SCOPE,0,NULL},
    {TOKEN_MIB_OBJECT_RTMDESTINATIONS,0,NULL},
    {TOKEN_MIB_OBJECT_RTMROUTES,0,NULL}
};

ULONG   g_ulNumMibObjects = sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER);

MAGIC_TABLE    MIBVar[] = {
//  {IP_FORWARDROW, PrintIpForwardRow},
//  {IP_FORWARDTABLE, PrintIpForwardTable},
    {MCAST_MFE, NULL},
    {MCAST_MFE, NULL},
    {MCAST_MFE_STATS, NULL},
    {MCAST_MFE_STATS, NULL},
    {MCAST_BOUNDARY, NULL},
    {MCAST_BOUNDARY, NULL},
    {MCAST_SCOPE, NULL},
    {MCAST_SCOPE, NULL},
    {0, NULL}, // destinations, unused
    {0, NULL}, // destinations, unused
    {0, NULL}, // routes, unused
    {0, NULL}, // routes, unused
};

#if 0
DWORD
GetMIBIpFwdIndex(
    IN    PTCHAR    *ppwcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the IP forward index

Arguments:

    ppwcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD dwErr = GetIpAddress(ppwcArguments[dwCurrentIndex], &pdwIndices[0]);

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pdwIndices[1] = _tcstoul(ppwcArguments[dwCurrentIndex + 1],NULL,10);

    dwErr = GetIpAddress(ppwcArguments[dwCurrentIndex + 2], &pdwIndices[2]);

    pdwIndices[3] = 0;

    *pdwNumParsed = 4;

    return dwErr;
}
#endif

DWORD
HandleIpMibShowObject(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:

    Parses command to get MIB object and optional parameters

Arguments:

Return Value:

--*/
{
    DWORD                dwIndices[MAX_NUM_INDICES];
    DWORD                dwNumParsed = 0;
    PMIB_OPAQUE_QUERY    pQuery = NULL;
    PMIB_OPAQUE_INFO     pRpcInfo;
    DWORD                dwQuerySize;
    BOOL                 bFound = FALSE,bOptPresent = FALSE;
    DWORD                dwRefreshRate;
    DWORD                dwOutEntrySize;
    DWORD                i,dwResult = NO_ERROR,dwErr;
    DWORD                dwMIBIndex, dwIndex;
    BOOL                 bIndex = FALSE, dwType;
    DWORD                dwRR = 0, dwInd = 0;
    HANDLE               hMib;
    

    
    if ( ! IsRouterRunning() )
    {
        if (g_pwszRouter)
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_REMOTE_ROUTER_NOT_RUNNING, 
                           g_pwszRouter);
        } 
        else 
        {
            DisplayMessage(g_hModule, 
                           MSG_IP_LOCAL_ROUTER_NOT_RUNNING);
        }

        return NO_ERROR;
    }
    
    //
    // Match MIB object
    //

    ppwcArguments += (dwCurrentIndex-1);
    dwArgCount    -= (dwCurrentIndex-1);
    dwCurrentIndex = 1;

    //DEBUG2("In IP MIB Show : %s\n",ppwcArguments[0]);

    for (i = 0; i < sizeof(MIBObjectMap)/sizeof(MIB_OBJECT_PARSER); i++)
    {
        if (MatchToken(ppwcArguments[0],MIBObjectMap[i].pwszMIBObj))
        {
            dwIndex = i;
            bFound = TRUE;
        
            DEBUG("found");
        
            break;
        }
    
    }
    
    if (!bFound)
    {
        return ERROR_CMD_NOT_FOUND;
    }


    if (!MatchToken( MIBObjectMap[dwIndex].pwszMIBObj,
                 TOKEN_MIB_OBJECT_RTMDESTINATIONS)
     && !MatchToken( MIBObjectMap[dwIndex].pwszMIBObj,
                 TOKEN_MIB_OBJECT_RTMROUTES))
    {
        dwErr = GetMibTagToken(&ppwcArguments[1],
                               dwArgCount - 1,
                               MIBObjectMap[dwIndex].dwMinOptArg,
                               &dwRR,
                               &bIndex,
                               &dwInd);

	    if (dwErr isnot NO_ERROR)
	    {
	        return ERROR_INVALID_SYNTAX;
	    }
    }

    
    if (bIndex)
    {
        dwMIBIndex = dwIndex * 2;
        bOptPresent = TRUE;
    }
    else
    {
        dwMIBIndex = dwIndex * 2 + 1;
    }

    //
    // Convert refresh rate to msec
    //
    
    dwRR *= 1000;

    if (!InitializeConsole(&dwRR, &hMib, &g_hConsole))
    {
        return ERROR_INIT_DISPLAY;
    }

    //
    // Query the MIB
    //

    pQuery = NULL;

    for ( ; ; )
    {
        if(dwRR)
        {
            DisplayMessageToConsole(g_hModule,
                              g_hConsole,
                              MSG_CTRL_C_TO_QUIT);
        }

        if (MatchToken(MIBObjectMap[dwIndex].pwszMIBObj, 
                       TOKEN_MIB_OBJECT_BOUNDARY))
        {
            dwResult = GetPrintBoundaryInfo(g_hMIBServer);
        }

        else if (MIBVar[ dwMIBIndex ].dwId is MCAST_MFE)
        {
            //
            // Call the special function
            //

            GetMfe( 
                g_hMIBServer, bIndex, ppwcArguments + 1, dwArgCount - 1, FALSE 
                );
        }

        else if(MIBVar[ dwMIBIndex ].dwId is MCAST_MFE_STATS)
        {
            //
            // Call the special function
            //
    
            GetMfe( 
                g_hMIBServer, bIndex, ppwcArguments + 1, dwArgCount - 1, TRUE
                );
        }
        else
        {
            //
            // For all else, the generic one is just fine
            //
    
            if (!(dwMIBIndex % 2))
            {
                (*MIBObjectMap[dwIndex].pfnMIBObjParser)(ppwcArguments,
                                                         1,
                                                         dwIndices,
                                                         &dwNumParsed);
            }

            dwQuerySize = ( sizeof( MIB_OPAQUE_QUERY ) - sizeof( DWORD ) ) + 
                (dwNumParsed) * sizeof(DWORD);
        
            pQuery = (PMIB_OPAQUE_QUERY)HeapAlloc(GetProcessHeap(),
                                                  0,
                                                  dwQuerySize);
    
    
            if (pQuery is NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                DisplayMessage(g_hModule, MSG_IP_NOT_ENOUGH_MEMORY);
        
                return dwErr;
            }

            pQuery->dwVarId = MIBVar[dwMIBIndex].dwId;
    
            for( i = 0; i < dwNumParsed; i++ )
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
        
            dwResult = MibGet(             PID_IP,
                                           IPRTRMGR_PID,
                                           (PVOID) pQuery,
                                           dwQuerySize,
                                           (PVOID *) &pRpcInfo,
                                           &dwOutEntrySize );
    
            if ( dwResult isnot NO_ERROR )
            {
                DisplayMessage(g_hModule,  MSG_IP_DIM_ERROR, dwResult );
                return dwResult;
            }
        
            if ( pRpcInfo is NULL )
            {
                DisplayMessage(g_hModule,  MSG_IP_NO_ENTRIES );
                return dwResult;
            }

            (*MIBVar[dwMIBIndex].pfnPrintFunction)(g_hMIBServer, pRpcInfo);

            MprAdminMIBBufferFree( (PVOID) pRpcInfo );
        }
    
        if(pQuery != NULL )
        {
            HeapFree(GetProcessHeap(),0,pQuery);
        }

        if (!RefreshConsole(hMib, g_hConsole, dwRR))
        {
            break;
        }
    }
    
    return dwResult;
}
    
#if 0
VOID 
PrintIpForwardTable(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints IP forward table.

Arguments:

Return Value:

--*/
{
    WCHAR wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPFORWARDTABLE lprpcTable = (PMIB_IPFORWARDTABLE)(prpcInfo->rgbyData);
    TCHAR               tszMask[ADDR_LENGTH + 1],
                        tszDest[ADDR_LENGTH + 1],
                        tszNextHop[ADDR_LENGTH + 1];
    PTCHAR              ptszType, ptszProto;
    DWORD               i, dwErr = NO_ERROR;

    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_HDR);
    
    if(lprpcTable->dwNumEntries is 0)
    {
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_IP_NO_ENTRIES);
        return;
    }
    
    for(i = 0; i < lprpcTable->dwNumEntries; i++)
    {
        switch(lprpcTable->table[i].dwForwardProto)
        {
            case MIB_IPPROTO_LOCAL:
            {
                ptszProto = MakeString(g_hModule, STRING_LOCAL);
                break;
            }
            case MIB_IPPROTO_NETMGMT:
            {
                ptszProto = MakeString(g_hModule, STRING_NETMGMT);
                break;
            }
            case MIB_IPPROTO_ICMP:
            {
                ptszProto = MakeString(g_hModule, STRING_ICMP);
                break;
            }
            case MIB_IPPROTO_EGP:
            {
                ptszProto = MakeString(g_hModule, STRING_EGP);
                break;
            }
            case MIB_IPPROTO_GGP:
            {
                ptszProto = MakeString(g_hModule, STRING_GGP);
                break;
            }
            case MIB_IPPROTO_HELLO:
            {
                ptszProto = MakeString(g_hModule, STRING_HELLO);
                break;
            }
            case MIB_IPPROTO_RIP:
            {
                ptszProto = MakeString(g_hModule, STRING_RIP);
                break;
            }
            case MIB_IPPROTO_IS_IS:
            {
                ptszProto = MakeString(g_hModule, STRING_IS_IS);
                break;
            }
            case MIB_IPPROTO_ES_IS:
            {
                ptszProto = MakeString(g_hModule, STRING_ES_IS);
                break;
            }
            case MIB_IPPROTO_CISCO:
            {
                ptszProto = MakeString(g_hModule, STRING_CISCO);
                break;
            }
            case MIB_IPPROTO_BBN:
            {
                ptszProto = MakeString(g_hModule, STRING_BBN);
                break;
            }
            case MIB_IPPROTO_OSPF:
            {
                ptszProto = MakeString(g_hModule, STRING_OSPF);
                break;
            }
            case MIB_IPPROTO_BGP:
            {
                ptszProto = MakeString(g_hModule, STRING_BGP);
                break;
            }
            case MIB_IPPROTO_OTHER:
            default:
            {
                ptszProto = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
    
        switch(lprpcTable->table[i].dwForwardType)
        {
            case MIB_IPROUTE_TYPE_INVALID:
            {
                ptszType = MakeString(g_hModule, STRING_INVALID);
                break;
            }
            case MIB_IPROUTE_TYPE_DIRECT:
            {
                ptszType = MakeString(g_hModule, STRING_DIRECT);
                break;
            }
            case MIB_IPROUTE_TYPE_INDIRECT:
            {
                ptszType = MakeString(g_hModule, STRING_INDIRECT);
                break;
            }
            case MIB_IPROUTE_TYPE_OTHER:
            default:
            {
                ptszType = MakeString(g_hModule, STRING_OTHER);
                break;
            }
        }
    
        MakeUnicodeIpAddr(tszDest, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwForwardDest))));
        MakeUnicodeIpAddr(tszMask, 
                          inet_ntoa(*((struct in_addr *)
                                      (&lprpcTable->table[i].dwForwardMask))));
        MakeUnicodeIpAddr(tszNextHop, 
                          inet_ntoa(*((struct in_addr *)
                                   (&lprpcTable->table[i].dwForwardNextHop))));
        
        dwErr = IpmontrGetFriendlyNameFromIfIndex( 
                          hMibServer,
                          lprpcTable->table[i].dwForwardIfIndex,
                          wszFriendlyName,
                          sizeof(wszFriendlyName) );
        
        DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_ENTRY,
                          tszDest,
                          tszMask,
                          lprpcTable->table[i].dwForwardPolicy,
                          tszNextHop,
                          wszFriendlyName,
                          ptszType,
                          ptszProto,
                          lprpcTable->table[i].dwForwardAge,
                          lprpcTable->table[i].dwForwardNextHopAS,
                          lprpcTable->table[i].dwForwardMetric1,
                          lprpcTable->table[i].dwForwardMetric2,
                          lprpcTable->table[i].dwForwardMetric3,
                          lprpcTable->table[i].dwForwardMetric4,
                          lprpcTable->table[i].dwForwardMetric5);
        
        FreeString(ptszType);
        FreeString(ptszProto);
    }
}

VOID 
PrintIpForwardRow(
    MIB_SERVER_HANDLE hMibServer,
    PMIB_OPAQUE_INFO prpcInfo
    )
/*++

Routine Description:

    Prints Ip forward table row.

Arguments:

Return Value:

--*/
{
    WCHAR             wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    PMIB_IPFORWARDROW ireRow = (PMIB_IPFORWARDROW)(prpcInfo->rgbyData);
    TCHAR             tszMask[ADDR_LENGTH + 1],
                      tszDest[ADDR_LENGTH + 1],
                      tszNextHop[ADDR_LENGTH + 1];
    PTCHAR            ptszType, ptszProto;
    DWORD             dwErr = NO_ERROR;
    
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_HDR);
    
    switch(ireRow->dwForwardProto)
    {
        case MIB_IPPROTO_LOCAL:
        {
            ptszProto = MakeString(g_hModule, STRING_LOCAL);
            break;
        }
        case MIB_IPPROTO_NETMGMT:
        {
            ptszProto = MakeString(g_hModule, STRING_NETMGMT);
            break;
        }
        case MIB_IPPROTO_ICMP:
        {
            ptszProto = MakeString(g_hModule, STRING_ICMP);
            break;
        }
        case MIB_IPPROTO_EGP:
        {
            ptszProto = MakeString(g_hModule, STRING_EGP);
            break;
        }
        case MIB_IPPROTO_GGP:
        {
            ptszProto = MakeString(g_hModule, STRING_GGP);
            break;
        }
        case MIB_IPPROTO_HELLO:
        {
            ptszProto = MakeString(g_hModule, STRING_HELLO);
            break;
        }
        case MIB_IPPROTO_RIP:
        {
            ptszProto = MakeString(g_hModule, STRING_RIP);
            break;
        }
        case MIB_IPPROTO_IS_IS:
        {
            ptszProto = MakeString(g_hModule, STRING_IS_IS);
            break;
        }
        case MIB_IPPROTO_ES_IS:
        {
            ptszProto = MakeString(g_hModule, STRING_ES_IS);
            break;
        }
        case MIB_IPPROTO_CISCO:
        {
            ptszProto = MakeString(g_hModule, STRING_CISCO);
            break;
        }
        case MIB_IPPROTO_BBN:
        {
            ptszProto = MakeString(g_hModule, STRING_BBN);
            break;
        }
        case MIB_IPPROTO_OSPF:
        {
            ptszProto = MakeString(g_hModule, STRING_OSPF);
            break;
        }
        case MIB_IPPROTO_BGP:
        {
            ptszProto = MakeString(g_hModule, STRING_BGP);
            break;
        }
        case MIB_IPPROTO_OTHER:
        default:
        {
            ptszProto = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    switch(ireRow->dwForwardType)
    {
        case MIB_IPROUTE_TYPE_INVALID:
        {
            ptszType = MakeString(g_hModule, STRING_INVALID);
            break;
        }
        case MIB_IPROUTE_TYPE_DIRECT:
        {
            ptszType = MakeString(g_hModule, STRING_DIRECT);
            break;
        }
        case MIB_IPROUTE_TYPE_INDIRECT:
        {
            ptszType = MakeString(g_hModule, STRING_INDIRECT);
            break;
        }
        case MIB_IPROUTE_TYPE_OTHER:
        default:
        {
            ptszType = MakeString(g_hModule, STRING_OTHER);
            break;
        }
    }
    
    MakeUnicodeIpAddr(tszDest,
                      inet_ntoa(*((struct in_addr *)
                                  (&ireRow->dwForwardDest))));
    MakeUnicodeIpAddr(tszMask,
                      inet_ntoa(*((struct in_addr *)
                                  (&ireRow->dwForwardMask))));
    MakeUnicodeIpAddr(tszNextHop,
                      inet_ntoa(*((struct in_addr *)
                                  (&ireRow->dwForwardNextHop))));


    dwErr = IpmontrGetFriendlyNameFromIfIndex( hMibServer,
                                        ireRow->dwForwardIfIndex,
                                        wszFriendlyName,
                                        sizeof(wszFriendlyName) );
        
    DisplayMessageToConsole(g_hModule, g_hConsole,MSG_MIB_FORWARD_ENTRY,
                      tszDest,
                      tszMask,
                      ireRow->dwForwardPolicy,
                      tszNextHop,
                      wszFriendlyName,
                      ptszType,
                      ptszProto,
                      ireRow->dwForwardAge,
                      ireRow->dwForwardNextHopAS,
                      ireRow->dwForwardMetric1,
                      ireRow->dwForwardMetric2,
                      ireRow->dwForwardMetric3,
                      ireRow->dwForwardMetric4,
                      ireRow->dwForwardMetric5);
    
    FreeString(ptszType);
    FreeString(ptszProto);
    
}
#endif

VOID
PrintMfeTable(
    MIB_SERVER_HANDLE           hMibServer,
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastGrp,
    PDWORD                      pdwLastSrc,
    PDWORD                      pdwLastSrcMask,
    DWORD                       dwRangeGrp,
    DWORD                       dwRangeGrpMask,
    DWORD                       dwRangeSrc,
    DWORD                       dwRangeSrcMask,
    DWORD                       dwType,
    PBOOL                       pbDone
    )
/*++

Routine Description:

    Prints MFE table information.

Arguments:

Return Value:

--*/
{
    WCHAR               wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];
    INT                 iCmp;
    DWORD               i, j, dwErr = NO_ERROR;
    TCHAR               ptszSource[ADDR_LENGTH + 1];
    TCHAR               ptszGroup[ADDR_LENGTH + 1];
    TCHAR               ptszUpstrm[ADDR_LENGTH + 1];
    TCHAR               ptszBuffer[80];
    TCHAR               ptszIf[18 + 1];
    
    PMIB_MFE_TABLE      pTable;
    PMIB_IPMCAST_MFE    pmimm;
    

    pTable = ( PMIB_MFE_TABLE )( prpcInfo-> rgbyData );

    if ( pTable->dwNumEntries is 0 )
    {
        DisplayMessageToConsole( g_hModule, g_hConsole,MSG_MIB_NO_MFES );

        return;
    }

    
    pmimm = pTable-> table;

    for( i = 0; i < pTable->dwNumEntries; i++ )
    {
        *pdwLastGrp = pmimm-> dwGroup;

        *pdwLastSrc = pmimm-> dwSource ;

        *pdwLastSrcMask = pmimm-> dwSrcMask ;
        

        //
        // Check if the MFEs are in the range provided 
        //
        
        if ( dwRangeGrp && dwRangeGrpMask &&
             ( ( dwRangeGrp & dwRangeGrpMask ) != 
               ( pmimm-> dwGroup & dwRangeGrpMask ) ) )
        {
            *pbDone = TRUE;
            break;
        }

        if ( dwRangeSrc && dwRangeSrcMask &&
             ( ( dwRangeSrc & dwRangeSrcMask ) !=
               ( pmimm-> dwSource & dwRangeSrcMask ) ) )
        {
            continue;
        }
        
        if ( ( dwType == Both ) ||
             ( ( dwType == PositiveMfe ) && ( pmimm-> ulNumOutIf ) ) ||
             ( ( dwType == NegativeMfe ) && ( !pmimm-> ulNumOutIf ) ) )
        {
            MakePrefixStringW( ptszGroup, pmimm-> dwGroup, 0xFFFFFFFF );

            MakePrefixStringW( ptszSource, pmimm-> dwSource, pmimm-> dwSrcMask );

            MakeAddressStringW( ptszUpstrm, pmimm-> dwUpStrmNgbr );

            IpmontrGetFriendlyNameFromIfIndex( 
                hMibServer, pmimm-> dwInIfIndex, wszFriendlyName,
                sizeof(wszFriendlyName) 
                );

            if ( wcslen(wszFriendlyName) < 18 )
            {
                wsprintf( ptszIf, L"%-18.18s", wszFriendlyName );
            }

            else
            {
                wsprintf(
                    ptszIf, L"%-12.12s...%-3.3s", wszFriendlyName, 
                    &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                    );
            }
            
            wsprintf( 
                ptszBuffer, L"\n%18.18s %18.18s %-6.6s %-18.18s %15.15s",
                ptszGroup, ptszSource,
                GetProtoProtoString( 
                    PROTO_TYPE_MCAST, 0, 
                    pmimm-> dwInIfProtocol
                    ),
                ptszIf, ptszUpstrm
                );
                
            DisplayMessageToConsole(
                g_hModule, g_hConsole, MSG_MIB_MFE, ptszBuffer
                );

            for (j = 0; j < pmimm-> ulNumOutIf; j++)
            {
                IpmontrGetFriendlyNameFromIfIndex( 
                    hMibServer, pmimm-> rgmioOutInfo[j].dwOutIfIndex, 
                    wszFriendlyName,
                    sizeof(wszFriendlyName) 
                    );

                if ( wcslen(wszFriendlyName) < 18 )
                {
                    wsprintf( ptszIf, L"%-18.18s", wszFriendlyName );
                }

                else
                {
                    wsprintf(
                        ptszIf, L"%-12.12s...%-3.3s", wszFriendlyName, 
                        &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                        );
                }

                MakeAddressStringW( ptszUpstrm, pmimm-> rgmioOutInfo[j].dwNextHopAddr );
                
                wsprintf(
                    ptszBuffer,
                    L"\n                                             %-18.18s %15.15s",
                    ptszIf, ptszUpstrm
                    );
                    
                DisplayMessageToConsole(
                    g_hModule, g_hConsole, MSG_MIB_MFE, ptszBuffer
                    );
            }
        }
        
        pmimm = (PMIB_IPMCAST_MFE)
            ((PBYTE) pmimm + SIZEOF_MIB_MFE( pmimm-> ulNumOutIf ));
    }
}

//----------------------------------------------------------------------------
// PrintMfeStatsTable
//
//
//----------------------------------------------------------------------------

VOID
PrintMfeStatsTable(
    MIB_SERVER_HANDLE           hMibServer,
    PMIB_OPAQUE_INFO            prpcInfo,
    PDWORD                      pdwLastGrp,
    PDWORD                      pdwLastSrc,
    PDWORD                      pdwLastSrcMask,
    DWORD                       dwRangeGrp,
    DWORD                       dwRangeGrpMask,
    DWORD                       dwRangeSrc,
    DWORD                       dwRangeSrcMask,
    DWORD                       dwType,
    PBOOL                       pbDone,
    BOOL                        bStatsAll
    )
/*++

Routine Description:

    Prints MFE stats table information.

Arguments:

Return Value:

--*/
{
    WCHAR                       wszFriendlyName[MAX_INTERFACE_NAME_LEN + 1];

    INT                         iCmp;
    
    DWORD                       i, j, dwIndex, dwErr = NO_ERROR, 
                                dwNextMfe;
    
    TCHAR                       ptszSource[ ADDR_LENGTH + 1 ], 
                                ptszGroup[ ADDR_LENGTH + 1 ],
                                ptszSrcMask[ ADDR_LENGTH + 1 ],
                                ptszUpstrm[ ADDR_LENGTH + 1 ],
                                ptszIf[ 18 + 1 ];
                                
    TCHAR                       ptszBuffer[ 256 ];
                    
    ULONG                       ulCurrLen, ulStringLen;
    
    PTCHAR                      ptcString;
    
    PMIB_MFE_STATS_TABLE        pTable;

    PMIB_IPMCAST_MFE_STATS      pmims;

    PMIB_IPMCAST_OIF_STATS      pmimos;


    //
    // get stats table
    //
    
    pTable = (PMIB_MFE_STATS_TABLE)( prpcInfo->rgbyData );

    if ( pTable->dwNumEntries is 0 )
    {
        //
        // no MFEs present.
        //

        return;
    }


    pmims = pTable-> table;
    
    //
    // Display MFE
    // - display header and incoming stats
    // - display multiple outgoing stats
    //

    for (i = 0; i < pTable->dwNumEntries; i++)
    {
        *pdwLastGrp = pmims-> dwGroup;
        
        *pdwLastSrc = pmims-> dwSource;
        
        *pdwLastSrcMask = pmims-> dwSrcMask;
        

        //
        // Check if the MFEs are in the range provided 
        //
        
        if ( dwRangeGrp && dwRangeGrpMask &&
             ( ( dwRangeGrp & dwRangeGrpMask ) != 
               ( pmims-> dwGroup & dwRangeGrpMask ) ) )
        {
            *pbDone = TRUE;
            break;
        }

        if ( dwRangeSrc && dwRangeSrcMask &&
             ( ( dwRangeSrc & dwRangeSrcMask ) !=
               ( pmims-> dwSource & dwRangeSrcMask ) ) )
        {
            pmims = (PMIB_IPMCAST_MFE_STATS)
                ((PBYTE) pmims + 
                    (bStatsAll) ?
                    SIZEOF_MIB_MFE_STATS_EX( pmims-> ulNumOutIf ) :
                    SIZEOF_MIB_MFE_STATS( pmims-> ulNumOutIf ));
                
            continue;
        }

        
        if ( ( dwType == Both ) ||
             ( ( dwType == PositiveMfe ) && ( pmims-> ulNumOutIf ) ) ||
             ( ( dwType == NegativeMfe ) && ( !pmims-> ulNumOutIf ) ) )
        {
            MakePrefixStringW( ptszGroup, pmims-> dwGroup, 0xFFFFFFFF );

            MakePrefixStringW( ptszSource, pmims-> dwSource, pmims-> dwSrcMask );

            MakeAddressStringW( ptszUpstrm, pmims-> dwUpStrmNgbr );

            IpmontrGetFriendlyNameFromIfIndex( 
                hMibServer, pmims-> dwInIfIndex, wszFriendlyName,
                sizeof(wszFriendlyName) 
                );

            if ( wcslen(wszFriendlyName) < 14 )
            {
                wsprintf( ptszIf, L"%-14.14s", wszFriendlyName );
            }

            else
            {
                wsprintf(
                    ptszIf, L"%-8.8s...%-3.3s", wszFriendlyName, 
                    &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                    );
            }

            if (bStatsAll)
            {
                PMIB_IPMCAST_MFE_STATS_EX pmimsex =
                    (PMIB_IPMCAST_MFE_STATS_EX) pmims;
                
                wsprintf( 
                    ptszBuffer, L"\n%18.18s %18.18s %-6.6s %-14.14s %15.15s " 
                    L"%10d %10d %10d %10d %10d %10d %10d %10d %10d",
                    ptszGroup, ptszSource,
                    GetProtoProtoString( 
                        PROTO_TYPE_MCAST, 0, 
                        pmimsex-> dwInIfProtocol
                        ),
                    ptszIf, ptszUpstrm,
                    pmimsex-> ulInPkts, pmimsex-> ulInOctets,
                    pmimsex-> ulPktsDifferentIf, pmimsex-> ulQueueOverflow,
                    pmimsex-> ulUninitMfe, pmimsex-> ulNegativeMfe,
                    pmimsex-> ulNegativeMfe, pmimsex-> ulInDiscards,
                    pmimsex-> ulInHdrErrors, pmimsex-> ulTotalOutPackets
                    );

                 pmimos = pmimsex-> rgmiosOutStats;
            }
            else
            {
                wsprintf( 
                    ptszBuffer, L"\n%18.18s %18.18s %-14.14s %15.15s %10d",
                    ptszGroup, ptszSource,
                    ptszIf, ptszUpstrm,
                    pmims-> ulInPkts
                    );

                pmimos = pmims-> rgmiosOutStats;
            }

            
            DisplayMessageToConsole(g_hModule, g_hConsole,
                              MSG_MIB_MFESTATS,
                              ptszBuffer);

            //
            // Display outgoing statistics
            //

            if ( pmims-> ulNumOutIf )
            {
                //
                // for each outgoing interface show outgoing interface stats
                //
                
                for ( j = 0; j < pmims-> ulNumOutIf; j++ )
                {
                    IpmontrGetFriendlyNameFromIfIndex( 
                        hMibServer, pmimos[j].dwOutIfIndex, 
                        wszFriendlyName,
                        sizeof(wszFriendlyName) 
                        );

                    if ( wcslen(wszFriendlyName) < 14 )
                    {
                        wsprintf( ptszIf, L"%-14.14s", wszFriendlyName );
                    }

                    else
                    {
                        wsprintf(
                            ptszIf, L"%-8.8s...%-3.3s", wszFriendlyName, 
                            &wszFriendlyName[wcslen(wszFriendlyName) - 3]
                            );
                    }

                    MakeAddressStringW( ptszUpstrm, pmimos[j].dwNextHopAddr );

                    if (!bStatsAll)
                    {
                        wsprintf(
                            ptszBuffer,
                            L"\n                                      %-14.14s %15.15s %10d",
                            ptszIf, ptszUpstrm, 
                            pmimos[j].ulOutPackets
                            );
                    }

                    else
                    {
                        wsprintf(
                            ptszBuffer,
                            L"\n                                             %-14.14s %15.15s %10d %10d %10d %10d",
                            ptszIf, ptszUpstrm, 
                            pmimos[j].ulOutPackets, 
                            pmimos[j].ulOutDiscards, 
                            pmimos[j].ulTtlTooLow,
                            pmimos[j].ulFragNeeded
                            );
                    }
                    
                    DisplayMessageToConsole(
                        g_hModule, g_hConsole,
                        MSG_MIB_MFESTATS,
                        ptszBuffer);
                }
            }
        }
        
        dwNextMfe = bStatsAll ?
            SIZEOF_MIB_MFE_STATS_EX( pmims-> ulNumOutIf ) :
            SIZEOF_MIB_MFE_STATS( pmims-> ulNumOutIf );

        pmims = (PMIB_IPMCAST_MFE_STATS)
                    (((PBYTE) pmims) + dwNextMfe);
    }

    return;
}



//----------------------------------------------------------------------------
// PrintMfeStatsTable
//
//
//----------------------------------------------------------------------------

DWORD
GetMfe(
    MIB_SERVER_HANDLE   hMprMIB,
    BOOL                bIndexPresent,
    PWCHAR             *ppwcArguments,
    DWORD               dwArgCount,
    BOOL                bIncludeStats
    )
/*++

Routine Description:

    Gets MFE stats information.

Arguments:

Return Value:

--*/
{
    TAG_TYPE             pttTags[] = {{TOKEN_GROUP_ADDRESS,  FALSE, FALSE},
                                      {TOKEN_GROUP_MASK,     FALSE, FALSE},
                                      {TOKEN_SOURCE_ADDRESS, FALSE, FALSE},
                                      {TOKEN_SOURCE_MASK,    FALSE, FALSE},
                                      {TOKEN_TYPE,           FALSE, FALSE},
                                      {TOKEN_STATS,          FALSE, FALSE}};

    DWORD                pdwTagType[sizeof(pttTags)/sizeof(TAG_TYPE)];
    DWORD                dwErr, dwOutEntrySize = 0, dwQuerySize,
                         dwLastGroup = 0, dwLastSource = 0, 
                         dwLastSrcMask = 0, i,
                         dwRangeGroup = 0, dwRangeGrpMask = 0,
                         dwRangeSource = 0, dwRangeSrcMask = 0, 
                         dwNumParsed;
    DWORD                dwType = Both;
    DWORD                dwCurrentIndex = 0;

    BOOL                 bDone = FALSE, bStatsAll = FALSE;
    
    PMIB_OPAQUE_INFO     pRpcInfo = NULL;

    PMIB_MFE_STATS_TABLE pTable = NULL;

    PMIB_OPAQUE_QUERY    pQuery;

    // Do generic processing

    dwErr = PreHandleCommand( ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              0,
                              sizeof(pttTags)/sizeof(TAG_TYPE),
                              pdwTagType );

    if (dwErr)
    {
        return dwErr;
    }

    for (i=0; i<dwArgCount; i++)
    {
        switch(pdwTagType[i])
        {
            case 0: // GRPADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &dwRangeGroup,
                                     &dwRangeGrpMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 1: // GRPMASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &dwRangeGrpMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 2: // SRCADDR
            {
                dwErr = GetIpPrefix( ppwcArguments[i+dwCurrentIndex],
                                     &dwRangeSource,
                                     &dwRangeSrcMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 3: // SRCMASK
            {
                dwErr = GetIpMask( ppwcArguments[i+dwCurrentIndex],
                                   &dwRangeSrcMask );

                if (dwErr is ERROR_INVALID_PARAMETER)
                {
                    DisplayMessage( g_hModule,  MSG_IP_BAD_IP_ADDR,
                                    ppwcArguments[i + dwCurrentIndex]);

                    DispTokenErrMsg(g_hModule, MSG_IP_BAD_OPTION_VALUE,
                                    pttTags[pdwTagType[i]].pwszTag,
                                    ppwcArguments[i + dwCurrentIndex]);
                    i = dwArgCount;
                    break;
                }
                break;
            }

            case 4: // TYPE
            {
                TOKEN_VALUE rgEnums[] =
                {
                    { TOKEN_VALUE_POSITIVE, PositiveMfe },
                    { TOKEN_VALUE_NEGATIVE, NegativeMfe },
                    { TOKEN_VALUE_BOTH,     Both }
                };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &dwType);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }

            case 5: // STATS
            {
                TOKEN_VALUE rgEnums[] =
                {
                    { TOKEN_VALUE_ALL, TRUE },
                };

                dwErr = MatchEnumTag( g_hModule,
                                      ppwcArguments[i + dwCurrentIndex],
                                      sizeof(rgEnums)/sizeof(TOKEN_VALUE),
                                      rgEnums,
                                      &bStatsAll);

                if (dwErr isnot NO_ERROR)
                {
                    DispTokenErrMsg( g_hModule,
                                     MSG_IP_BAD_OPTION_VALUE,
                                     pttTags[pdwTagType[i]].pwszTag,
                                     ppwcArguments[i + dwCurrentIndex] );

                    return ERROR_INVALID_PARAMETER;
                }

                break;
            }


        }
    }

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    do {
        //
        // allocate and setup query structure
        //
        
        dwQuerySize = sizeof( MIB_OPAQUE_QUERY ) + 2 * sizeof(DWORD);
        
        pQuery = (PMIB_OPAQUE_QUERY) HeapAlloc(
                                        GetProcessHeap(), 0, dwQuerySize
                                        );
        
        if ( pQuery == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;

            DisplayMessageToConsole(g_hModule, g_hConsole, ERROR_CONFIG, dwErr );

            break;
        }

        
        pQuery->dwVarId = ( bIncludeStats ) ? 
                            ( ( bStatsAll ) ? 
                                MCAST_MFE_STATS_EX : MCAST_MFE_STATS ) :
                                MCAST_MFE;
        
        pQuery->rgdwVarIndex[ 0 ] = dwRangeGroup & dwRangeGrpMask;
        pQuery->rgdwVarIndex[ 1 ] = dwRangeSource;
        pQuery->rgdwVarIndex[ 2 ] = dwRangeSrcMask;
        

        if (bIncludeStats)
        {
            DisplayMessageToConsole(
                g_hModule, g_hConsole, 
                bStatsAll ? MSG_MIB_MFESTATS_ALL_HDR : MSG_MIB_MFESTATS_HDR
                );
        }

        else
        {
            DisplayMessageToConsole(g_hModule, g_hConsole, MSG_MIB_MFE_HDR );
        }
    

        while ((dwErr = MibGetNext(             PID_IP,
                                                IPRTRMGR_PID,
                                                (PVOID) pQuery,
                                                dwQuerySize,
                                                (PVOID *) &pRpcInfo,
                                                &dwOutEntrySize))
               == NO_ERROR )
        {
            //
            // if no MFEs are present quit
            //

            pTable = (PMIB_MFE_STATS_TABLE)( pRpcInfo->rgbyData );

            if ( pTable->dwNumEntries is 0 )
            {
                break;
            }


            //
            // print the MFEs
            //

            if ( bIncludeStats )
            {
                PrintMfeStatsTable(  hMprMIB,
                    pRpcInfo, &dwLastGroup, &dwLastSource, &dwLastSrcMask,
                    dwRangeGroup, dwRangeGrpMask, dwRangeSource, 
                    dwRangeSrcMask, dwType, &bDone, bStatsAll
                    );
            }

            else
            {
                PrintMfeTable(  hMprMIB,
                    pRpcInfo, &dwLastGroup, &dwLastSource, &dwLastSrcMask,
                    dwRangeGroup, dwRangeGrpMask, dwRangeSource, 
                    dwRangeSrcMask, dwType, &bDone
                    );
            }
        
            MprAdminMIBBufferFree( pRpcInfo );

            pRpcInfo = NULL;

            dwOutEntrySize = 0;


            //
            // Check if we are done
            //

            if ( bDone )
            {
                break;
            }
            
            //
            // set up the next query
            //
            
            pQuery->rgdwVarIndex[ 0 ] = dwLastGroup;
            pQuery->rgdwVarIndex[ 1 ] = dwLastSource;
            pQuery->rgdwVarIndex[ 2 ] = dwLastSrcMask;
        }

        if ( dwErr != NO_ERROR && dwErr != ERROR_NO_MORE_ITEMS && dwErr != ERROR_NOT_FOUND )
        {
            DisplayError(NULL, dwErr );
        }
        
    } while ( FALSE );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\utils.c

Abstract:

     Utility functions

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

DWORD
GetMibTagToken(
    IN  LPWSTR *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    )

/*++

Routine Description:

    Looks for indices and refresh rate arguments in the command. If index
    tag is present, it would be of the form index= index1 index2 ....
    The index= is removed by this function. So is rr= if it is there in
    the command. If pdwRR is 0 then, no refresh sought.
    
Arguments:

    ppwcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - ppwcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - ppwcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
    
--*/
{
    DWORD    i;
    BOOL     bTag;

    if (dwArgCount is 0)
    {
        *pdwRR = 0;
        *pbIndex = FALSE;
        
        return NO_ERROR;
    }

    if (dwArgCount < dwNumIndices)
    {
        //
        // No index
        //
        
        *pbIndex = FALSE;

        if (dwArgCount > 1)
        {
            *pdwRR = 0;
            
            return ERROR_INVALID_PARAMETER;
        }
        
        //
        // No Index specified. Make sure refresh rate is specified
        // with tag.
        //

        if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
        {
            //
            // get the refresh rate
            //

            *pdwRR = wcstoul(&ppwcArguments[0][3], NULL, 10);
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        //
        // Check for index tag
        //

        if (_wcsnicmp(ppwcArguments[0],L"INDEX=",6) == 0)
        {
            *pbIndex = TRUE;
            *pdwIndex = 0;

            //
            // remove tag and see if refresh rate is specified
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][6]);

            if (dwArgCount > dwNumIndices)
            {
                //
                // Make sure that argument has RR tag
                //

                if (_wcsnicmp(ppwcArguments[dwNumIndices],L"RR=",3) == 0)
                {
                    //
                    // get the refresh rate
                    //

                    *pdwRR = wcstoul(&ppwcArguments[dwNumIndices][3], NULL , 10);
                }
                else
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                //
                // No refresh rate specified
                //

                *pdwRR = 0;
                return NO_ERROR;
            }
        }
        else
        {
            //
            // Not index tag, See if it has an RR tag
            // 

            if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
            {
                //
                // get the refresh rate
                //

                *pdwRR = wcstoul(&ppwcArguments[0][3], NULL , 10);

                //
                // See if the index follows
                //

                if (dwArgCount > dwNumIndices)
                {
                    if (dwArgCount > 1)
                    {
                        if (_wcsnicmp(ppwcArguments[1],L"INDEX=",6) == 0)
                        {
                            wcscpy(ppwcArguments[1], &ppwcArguments[1][6]);
                            *pbIndex = TRUE;
                            *pdwIndex = 1;
                            
                            return NO_ERROR;
                        }
                        else
                        {
                            *pdwRR = 0;
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        return NO_ERROR;
                    }
                }
            }
            //
            // No RR Tag either
            //
            else if (dwArgCount > dwNumIndices)
            {
                //
                // Assume ppwcArguments[dwNumIndices] is the refresh rate
                //

                *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);

                if (dwNumIndices != 0)
                {
                    *pbIndex = TRUE;
                    *pdwIndex = 0;
                }
            }
            else
            {
                //
                // only index present with no tag
                //
                *pbIndex = TRUE;
                *pdwIndex = 0;
            }
        }
    }

    return NO_ERROR;
}

DWORD
GetIpPrefix(
    IN  LPCWSTR       ppwcArg,
    OUT PIPV4_ADDRESS pipAddress,
    OUT PIPV4_ADDRESS pipMask
    )
{
    CHAR     pszIpAddr[ADDR_LENGTH+1], *p;
    DWORD    dwDots;

    // Accept "default" as a special case

    if (MatchToken( ppwcArg, TOKEN_DEFAULT))
    {
        *pipAddress = *pipMask = 0;
        return NO_ERROR;
    }

    // Make sure all characters are legal [/0-9.]

    if (ppwcArg[ wcsspn(ppwcArg, L"/0123456789.") ])
    {
        return ERROR_INVALID_PARAMETER;
    }

    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ppwcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';

    p = strchr( pszIpAddr, '/' );
    if (p)
    {
        ULONG ulLen = (atoi(p+1));
        *pipMask = (ulLen)? htonl(~0 << (32 - ulLen)) : 0;
        *p = 0;
    }
    else
    {
        *pipMask = ~0;
    }

    // If less than three dots were specified, append .0 until there are
    for (dwDots=0, p=strchr(pszIpAddr, '.'); p; dwDots++,p=strchr(p+1,'.'));
    while (dwDots < 3) {
        strcat(pszIpAddr, ".0");
        dwDots++;
    }

    *pipAddress = (DWORD) inet_addr(pszIpAddr);

    return NO_ERROR;
}

DWORD
GetIpMask(
    IN  LPCWSTR       ppwcArg,
    OUT PIPV4_ADDRESS pipAddress
    )
/*++

Routine Description:

    Gets the ip address from the string.
    
Arguments:

    pwszIpAddr - Ip address string
    pipAddress - IP address
    
Return Value:
    
    NO_ERROR, ERROR_INVALID_PARAMETER
    
--*/
{
    CHAR     pszIpAddr[ADDR_LENGTH+1];

    // Make sure all characters are legal [/0-9.]

    if (ppwcArg[ wcsspn(ppwcArg, L"/0123456789.") ])
    {
        return ERROR_INVALID_PARAMETER;
    }

    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        ppwcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';

    if (pszIpAddr[0] is '/')
    {
        ULONG ulLen = (atoi(pszIpAddr+1));
        *pipAddress = (ulLen)? htonl(~0 << (32 - ulLen)) : 0;
    }
    else
    {
        *pipAddress = (DWORD) inet_addr(pszIpAddr);
    }

    return NO_ERROR;
}



DWORD
GetIpAddress(
    IN  LPCWSTR         pwszArgument,
    OUT PIPV4_ADDRESS   pipAddress
    )
/*++

Routine Description
    Gets the ip address from the string.

Arguments
    pwszArgument        argument specifing an ip address
    pipAddress          ip address

Return Value
    NO_ERROR            if success
    Failure code        o/w

--*/
{
    CHAR    pszAddress[ADDR_LENGTH + 1];
    DWORD   dwAddress   = 0;
    PCHAR   pcNext      = NULL;
    ULONG   ulCount     = 0;

    // ensure all characters are legal [0-9.]
    if (pwszArgument[wcsspn(pwszArgument, L"0123456789.")])
        return ERROR_INVALID_PARAMETER;

    // convert to an ansi string
    sprintf(pszAddress, "%S", pwszArgument);

    // ensure there are 3 '.' (periods)
    for (pcNext = pszAddress, ulCount = 0; *pcNext != '\0'; pcNext++)
        if (*pcNext is '.')
            ulCount++;
    if (ulCount != 3)
        return ERROR_INVALID_PARAMETER;

    dwAddress = (DWORD) inet_addr(pszAddress);
    // return an error if dwAddress is INADDR_NONE (255.255.255.255)
    // and the address specified isn't 255.255.255.255 (INADDR_NONE)
    if ((dwAddress is INADDR_NONE) and
        strcmp(pszAddress, "255.255.255.255"))
        return ERROR_INVALID_PARAMETER;

    *pipAddress = dwAddress;

    return NO_ERROR;
}



BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    )
{
    register int i;

    dwMask = ntohl(dwMask);

    for (i=0; i<32 && !(dwMask & (1<<i)); i++);

    return 32-i;
}

VOID
MakeAddressStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    )
{
    swprintf( pwcPrefixStr,
              L"%d.%d.%d.%d",
              PRINT_IPADDR(ipAddr) );
}

VOID
MakePrefixStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr,
    IN  IPV4_ADDRESS ipMask
    )
{
    swprintf( pwcPrefixStr,
              L"%d.%d.%d.%d/%d",
              PRINT_IPADDR(ipAddr),
              MaskToMaskLen(ipMask) );
}

DWORD
GetIfIndexFromGuid(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszGuid,
    OUT PDWORD            pdwIfIndex
    )
{
    MIB_OPAQUE_QUERY  Query;
    PMIB_IFTABLE      pIfTable;
    DWORD             dwErr, dwOutEntrySize;
    PMIB_OPAQUE_INFO  pRpcInfo;
    DWORD             dwCount, i;

    Query.dwVarId         = IF_TABLE;
    Query.rgdwVarIndex[0] = 0;

    dwErr = MibGet(             PID_IP,
                                IPRTRMGR_PID,
                                (PVOID) &Query,
                                sizeof(Query),
                                (PVOID *) &pRpcInfo,
                                &dwOutEntrySize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pIfTable = (PMIB_IFTABLE)(pRpcInfo->rgbyData);

    dwCount = pIfTable->dwNumEntries;

    *pdwIfIndex = 0;

    for (i=0; i<dwCount; i++) 
    {
        if (!wcscmp(pIfTable->table[i].wszName, pwszGuid))
        {
            *pdwIfIndex = pIfTable->table[i].dwIndex;

            break;
        }
    }

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return NO_ERROR;
}

DWORD
GetGuidFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
{
    MIB_OPAQUE_QUERY  Query;
    PMIB_IFROW        pIfRow;
    DWORD             dwErr, dwOutEntrySize;
    PMIB_OPAQUE_INFO  pRpcInfo;

    Query.dwVarId         = IF_ROW;
    Query.rgdwVarIndex[0] = dwIfIndex;

    dwErr = MibGet(             PID_IP,
                                IPRTRMGR_PID,
                                (PVOID) &Query,
                                sizeof(Query),
                                (PVOID *) &pRpcInfo,
                                &dwOutEntrySize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    pIfRow = (PMIB_IFROW)(pRpcInfo->rgbyData);

    wcscpy( pwszBuffer, pIfRow->wszName );

    MprAdminMIBBufferFree( (PVOID) pRpcInfo );

    return NO_ERROR;
}

DWORD
IpmontrGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    )
/*++

Routine Description:

    Gets friendly Interface name from Interface index

Arguments:

    hMibServer      - Handle to the MIB server
    dwIfIndex       - Interface index
    pwszBuffer      - Buffer that will be holding the friendly interface name
    dwBufferSize    - Size (in Bytes) of the pwszBuffer

--*/
{
    WCHAR        wszGuid[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        dwErr;

    dwErr = GetGuidFromIfIndex(hMibServer, dwIfIndex, wszGuid, sizeof(wszGuid));

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    return IpmontrGetFriendlyNameFromIfName( wszGuid, pwszBuffer, &dwBufferSize );
}

DWORD
IpmontrGetIfIndexFromFriendlyName(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszFriendlyName,
    OUT PDWORD            pdwIfIndex
    )
{
    WCHAR        wszGuid[MAX_INTERFACE_NAME_LEN + 1];
    DWORD        dwErr, dwSize = sizeof(wszGuid);
    
    dwErr = IpmontrGetIfNameFromFriendlyName( pwszFriendlyName,
                                       wszGuid,
                                       &dwSize );

    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    return GetIfIndexFromGuid( hMibServer, wszGuid, pdwIfIndex );
}

DWORD 
IpmontrGetFriendlyNameFromIfName(
    IN  LPCWSTR pwszName, 
    OUT LPWSTR  pwszBuffer, 
    IN  PDWORD  pdwBufSize
    )
/*++
Description:
    Defines function to map a guid interface name to an unique descriptive
    name describing that interface.

Arguments:

    pwszName        - Buffer holding a Guid Interface Name 
    pwszBuffer      - Buffer to hold the Friendly Name
    pdwBufferSize   - pointer to the Size (in Bytes) of the pwszBuffer
--*/
{
    return NsGetFriendlyNameFromIfName( g_hMprConfig,
                                        pwszName,
                                        pwszBuffer,
                                        pdwBufSize );
}

DWORD
IpmontrGetIfNameFromFriendlyName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    )
/*++
Description:
    Defines function to map a friendly interface name to a guid interface
    name.

Arguments:

    pwszName        - Buffer holding a Friendly Interface Name 
    pwszBuffer      - Buffer to hold Guid Interface Name
    pdwBufferSize   - pointer to the Size (in Bytes) of the pwszBuffer

Returns:
    NO_ERROR, ERROR_NO_SUCH_INTERFACE
--*/
{
    return NsGetIfNameFromFriendlyName( g_hMprConfig,
                                        pwszName,
                                        pwszBuffer,
                                        pdwBufSize );
}

DWORD
IpmontrCreateInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName,
    IN  DWORD   dwLocalAddress,
    IN  DWORD   dwRemoteAddress,
    IN  BYTE    byTtl
    )
/*++

Description: TODO This function is really really really ugly and does
    not belong in Netsh.  There needs to be a system API to do this,
    but there isn't one right now so we have to workaround it by copying
    all this crud here.  This code is stolen from netsh\if\routerdb.c
    RtrInterfaceAddIpip() which is also really really really ugly.
--*/
{
    DWORD                   dwErr = ERROR_CAN_NOT_COMPLETE;
    GUID                    Guid; 
    GUID                   *pGuid = &Guid;
    MPR_IPINIP_INTERFACE_0  NameInfo;
    MPR_INTERFACE_0         IfInfo;
    HANDLE                  hIfCfg;
    HANDLE                  hIfAdmin;
    IPINIP_CONFIG_INFO      info;

    // Initialize
    //
    ZeroMemory(&IfInfo, sizeof(IfInfo));
    IfInfo.fEnabled = TRUE;
    IfInfo.dwIfType = ROUTER_IF_TYPE_TUNNEL1;

    wcscpy(IfInfo.wszInterfaceName, pwszInterfaceName);

    info.dwLocalAddress  = dwLocalAddress;
    info.dwRemoteAddress = dwRemoteAddress;
    info.byTtl           = byTtl;
    dwErr = AddSetIpIpTunnelInfo(pwszInterfaceName, &info);

    if(dwErr isnot NO_ERROR)
    {
        //
        // Tear down the mapping
        //

        MprSetupIpInIpInterfaceFriendlyNameDelete(NULL, pGuid);
    }

    return dwErr;
}

DWORD
IpmontrDeleteInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName
    )
/*++
Description: TODO This function is really really really ugly and does
    not belong in Netsh.  There needs to be a system API to do this,
    but there isn't one right now so we have to workaround it by copying
    all this crud here.  This code is stolen from netsh\if\routerdb.c
    RtrInterfaceDelete() which is also really really really ugly.
Called by: HandleMsdpDeletePeer()
--*/
{
    DWORD              dwErr = ERROR_CAN_NOT_COMPLETE;
    DWORD              dwSize;
    HANDLE             hIfCfg, hIfAdmin;
    GUID               Guid;
    MPR_INTERFACE_0   *pIfInfo;

    do {
        dwErr = MprConfigInterfaceGetHandle(g_hMprConfig,
                                            (LPWSTR)pwszInterfaceName,
                                            &hIfCfg);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = MprConfigInterfaceGetInfo(g_hMprConfig,
                                          hIfCfg,
                                          0,
                                          (PBYTE *)&pIfInfo,
                                          &dwSize);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        if(pIfInfo->dwIfType isnot ROUTER_IF_TYPE_TUNNEL1)
        {
            MprConfigBufferFree(pIfInfo);

            dwErr = ERROR_INVALID_PARAMETER;

            break;
        }

        dwErr = MprConfigInterfaceDelete(g_hMprConfig,
                                         hIfCfg);

        MprConfigBufferFree(pIfInfo);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = ConvertStringToGuid(pwszInterfaceName,
                                    (USHORT)(wcslen(pwszInterfaceName) * sizeof(WCHAR)),
                                    &Guid);

        if(dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = MprSetupIpInIpInterfaceFriendlyNameDelete((LPWSTR)pwszMachineName,
                                                          &Guid);

        if(IsRouterRunning())
        {
            dwErr = MprAdminInterfaceGetHandle(g_hMprAdmin,
                                               (LPWSTR)pwszInterfaceName,
                                               &hIfAdmin,
                                               FALSE);

            if(dwErr isnot NO_ERROR)
            {
                break;
            }

            dwErr = MprAdminInterfaceDelete(g_hMprAdmin,
                                            hIfAdmin);
        }

    } while (FALSE);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\utils.h ===
DWORD
GetMibTagToken(
    IN  LPWSTR *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    );

DWORD
GetIpAddress(
    IN  LPCWSTR       pptcArg,
    OUT PIPV4_ADDRESS ipAddress
    );

DWORD
GetIpMask(
    IN  LPCWSTR       pptcArg,
    OUT PIPV4_ADDRESS ipMask
    );

DWORD
GetIpPrefix(
    IN  LPCWSTR       pptcArg,
    OUT PIPV4_ADDRESS ipAddress,
    OUT PIPV4_ADDRESS ipMask
    );

#define DispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)

BYTE
MaskToMaskLen(
    IPV4_ADDRESS dwMask
    );

VOID
MakeAddressStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr
    );

VOID
MakePrefixStringW(
    OUT LPWSTR       pwcPrefixStr,
    IN  IPV4_ADDRESS ipAddr,
    IN  IPV4_ADDRESS ipMask
    );

DWORD
GetGuidFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD
IpmontrGetFriendlyNameFromIfIndex(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  DWORD             dwIfIndex,
    OUT LPWSTR            pwszBuffer,
    IN  DWORD             dwBufferSize
    );

DWORD
GetIfIndexFromGuid(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszGuid,
    OUT PDWORD            pdwIfIndex
    );

DWORD
IpmontrGetIfIndexFromFriendlyName(
    IN  MIB_SERVER_HANDLE hMibServer,
    IN  LPCWSTR           pwszFriendlyName,
    OUT PDWORD            pdwIfIndex
    );

DWORD
IpmontrGetFriendlyNameFromIfName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD  pdwBufSize
    );

DWORD
IpmontrGetIfNameFromFriendlyName(
    IN  LPCWSTR pwszName,
    OUT LPWSTR  pwszBuffer,
    IN  PDWORD pdwBufSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\ipmon\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    NOTE - DONT USE 15000-15999    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

    V Raman         05/15/1996      Rearranged stringtable ids.
        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__

#define MSG_NULL                                1001

#define HLP_IP_HELP1                            8301
#define HLP_IP_HELP1_EX                         8302
#define HLP_IP_HELP2                            8301
#define HLP_IP_HELP2_EX                         8302
#define HLP_IP_RESET                            8309
#define HLP_IP_RESET_EX                         8310
#define HLP_IP_INSTALL                          8313
#define HLP_IP_INSTALL_EX                       8314
#define HLP_IP_UNINSTALL                        8315
#define HLP_IP_UNINSTALL_EX                     8316
#define HLP_IP_DUMP                             8317
#define HLP_IP_DUMP_EX                          8318
#define HLP_IP_UPDATE                           8319
#define HLP_IP_UPDATE_EX                        8320
#define HLP_GROUP_ADD                           8321
#define HLP_GROUP_DELETE                        8323
#define HLP_GROUP_SET                           8325
#define HLP_GROUP_SHOW                          8327


#define HLP_IP_ADD_PROTOPREF                    9200
#define HLP_IP_ADD_PROTOPREF_EX                 9201
#define HLP_IP_DEL_PROTOPREF                    9202
#define HLP_IP_DEL_PROTOPREF_EX                 9203
#define HLP_IP_SET_PROTOPREF                    9204
#define HLP_IP_SET_PROTOPREF_EX                 9205
#define HLP_IP_SHOW_PROTOPREF                   9206
#define HLP_IP_SHOW_PROTOPREF_EX                9207

#define HLP_IP_ADD_IF_FILTER                    9210
#define HLP_IP_ADD_IF_FILTER_EX                 9211
#define HLP_IP_DEL_IF_FILTER                    9212
#define HLP_IP_DEL_IF_FILTER_EX                 9213
#define HLP_IP_SET_IF_FILTER                    9214
#define HLP_IP_SET_IF_FILTER_EX                 9215
#define HLP_IP_SHOW_IF_FILTER                   9216
#define HLP_IP_SHOW_IF_FILTER_EX                9217

#define HLP_IP_ADD_PERSISTENTROUTE              9220
#define HLP_IP_ADD_PERSISTENTROUTE_EX           9221
#define HLP_IP_DEL_PERSISTENTROUTE              9222
#define HLP_IP_DEL_PERSISTENTROUTE_EX           9223
#define HLP_IP_SET_PERSISTENTROUTE              9224
#define HLP_IP_SET_PERSISTENTROUTE_EX           9225
#define HLP_IP_SHOW_PERSISTENTROUTE             9226
#define HLP_IP_SHOW_PERSISTENTROUTE_EX          9227

#define HLP_IP_ADD_IPIPTUNNEL                   9230
#define HLP_IP_ADD_IPIPTUNNEL_EX                9231
#define HLP_IP_SET_IPIPTUNNEL                   9234
#define HLP_IP_SET_IPIPTUNNEL_EX                9235

#define HLP_IP_SET_LOGLEVEL                     9244
#define HLP_IP_SET_LOGLEVEL_EX                  9245
#define HLP_IP_SHOW_LOGLEVEL                    9246
#define HLP_IP_SHOW_LOGLEVEL_EX                 9247

#define HLP_IP_ADD_INTERFACE                    9250
#define HLP_IP_ADD_INTERFACE_EX                 9251
#define HLP_IP_DEL_INTERFACE                    9252
#define HLP_IP_DEL_INTERFACE_EX                 9253
#define HLP_IP_SET_INTERFACE                    9254
#define HLP_IP_SET_INTERFACE_EX                 9255
#define HLP_IP_SHOW_INTERFACE                   9256
#define HLP_IP_SHOW_INTERFACE_EX                9257

#define HLP_IP_SHOW_PROTOCOL                    9266
#define HLP_IP_SHOW_PROTOCOL_EX                 9267

#define HLP_IP_ADD_SCOPE                        9270
#define HLP_IP_ADD_SCOPE_EX                     9271
#define HLP_IP_DEL_SCOPE                        9272
#define HLP_IP_DEL_SCOPE_EX                     9273
#define HLP_IP_SET_SCOPE                        9274
#define HLP_IP_SET_SCOPE_EX                     9275
#define HLP_IP_SHOW_SCOPE                       9276
#define HLP_IP_SHOW_SCOPE_EX                    9277

#define HLP_IP_ADD_BOUNDARY                     9280
#define HLP_IP_ADD_BOUNDARY_EX                  9281
#define HLP_IP_DEL_BOUNDARY                     9282
#define HLP_IP_DEL_BOUNDARY_EX                  9283
#define HLP_IP_SHOW_BOUNDARY                    9286
#define HLP_IP_SHOW_BOUNDARY_EX                 9287

#define HLP_IP_SHOW_HELPER                      9296
#define HLP_IP_SHOW_HELPER_EX                   9297

#define HLP_IPMIB_SHOW_RTMDEST                  9316
#define HLP_IPMIB_SHOW_RTMDEST_EX               9317
#define HLP_IPMIB_SHOW_MFESTATS                 9318
#define HLP_IPMIB_SHOW_MFESTATS_EX              9319
#define HLP_IPMIB_SHOW_MFE                      9320
#define HLP_IPMIB_SHOW_MFE_EX                   9321
#define HLP_IPMIB_SHOW_RTMROUTE                 9326
#define HLP_IPMIB_SHOW_RTMROUTE_EX              9327
#define HLP_IPMIB_SHOW_BOUNDARY                 9330
#define HLP_IPMIB_SHOW_BOUNDARY_EX              9331
#define HLP_IPMIB_SHOW_SCOPE                    9332
#define HLP_IPMIB_SHOW_SCOPE_EX                 9333

#define HLP_IP_ADD_RTMROUTE                     9340
#define HLP_IP_ADD_RTMROUTE_EX                  9341
#define HLP_IP_DEL_RTMROUTE                     9342
#define HLP_IP_DEL_RTMROUTE_EX                  9343
#define HLP_IP_SET_RTMROUTE                     9344
#define HLP_IP_SET_RTMROUTE_EX                  9345

//
// Messages used to dump config - these closely follow the
// set/add help messages
//

#define DMP_IP_HEADER_COMMENTS                  9411
#define DMP_IP_FOOTER_COMMENTS                  9412
#define DMP_ROUTING_HEADER_COMMENTS             9413

// Output messages
    // Router messages
        // interface messages
#define MSG_RTR_INTERFACE_HDR                   20001
#define MSG_RTR_INTERFACE_PROTOCOL_HDR          20003
#define MSG_RTR_INTERFACE_IPIP_INFO             20005
#define MSG_RTR_ROUTE_HDR                       20006
#define MSG_RTR_ROUTE_INFO                      20007

        // Filter messages
#define MSG_RTR_FILTER_HDR                      20101
#define MSG_RTR_FILTER_INFO                     20102
#define MSG_RTR_FILTER_HDR1                     20103
#define MSG_RTR_FILTER_HDR2                     20104
#define MSG_RTR_FILTER_INFO2                    20105

        // Multicast scope boundary messages
#define MSG_RTR_SCOPE_HDR                       20251
#define MSG_RTR_SCOPE_INFO                      20252
#define MSG_RTR_BOUNDARY_HDR                    20253
#define MSG_RTR_BOUNDARY_INFO_0                 20254
#define MSG_RTR_BOUNDARY_INFO_1                 20255
#define MSG_RTR_BOUNDARY_INFO_2                 20256

#define MSG_RTR_PRIO_INFO_HDR                   20304
#define MSG_RTR_PRIO_INFO                       20305


    // MIB messages
#define MSG_MIB_MFE_HDR                         21025
#define MSG_MIB_MFE                             21026

#define MSG_MIB_MFESTATS_HDR                    21028
#define MSG_MIB_MFESTATS_ALL_HDR                21029
#define MSG_MIB_MFESTATS                        21030


#define MSG_MIB_BOUNDARY_HDR                    21055
#define MSG_MIB_BOUNDARY_INFO                   21056
#define MSG_MIB_SCOPE_HDR                       21057
#define MSG_MIB_SCOPE_INFO                      21058

#define MSG_IP_BAD_IP_ADDR                      21503
#define MSG_IP_BAD_IP_MASK                      21505
#define MSG_CANT_FIND_EOPT                      21507
#define MSG_NO_INTERFACE                        21512
#define MSG_IP_NO_FILTER_FOR_FRAG               21521
#define MSG_SHOW_HELPER_HDR                     21528
#define MSG_SHOW_HELPER_INFO                    21529

#define MSG_IP_FRAG_CHECK                       21601
#define MSG_IP_GLOBAL_HDR                       21602
#define MSG_IP_LOG_LEVEL                        21603
#define MSG_IP_PROTOCOL_HDR                     21604
#define MSG_IP_NO_PROTOCOL                      21605
#define MSG_IP_INTERFACE_HDR                    21606
#define MSG_IP_NO_INTERFACE                     21607
#define MSG_IP_IF_STATUS                        21608
#define MSG_IP_INTERFACE_INFO                   21609
#define MSG_IP_IF_ENTRY                         21610
#define MSG_IP_IF_HEADER                        21611
#define MSG_IP_PERSISTENT_ROUTER                21612
#define MSG_IP_PERSISTENT_CONFIG                21613

#define EMSG_IP_NO_STATUS_INFO                  25005
#define EMSG_IP_NO_PRIO_INFO                    25006
#define EMSG_IP_NO_FILTER_INFO                  25007
#define EMSG_IP_NO_IF_STATUS_INFO               25009
#define EMSG_IP_NO_ROUTE_INFO                   25010
#define EMSG_NEED_NHOP                          25011
#define EMSG_SCOPE_NAME_TOO_LONG                25016
#define EMSG_CANT_CREATE_IF                     25020
#define EMSG_CANT_SET_IF_INFO                   25021
#define EMSG_CANT_GET_IF_INFO                   25023
#define EMSG_AMBIGUOUS_SCOPE_NAME               25024
#define EMSG_INVALID_ADDR                       25025
#define EMSG_PREFIX_ERROR                       25026
#define EMSG_CANT_FIND_NAME                     25027
#define EMSG_CANT_MATCH_NAME                    25028
#define EMSG_CANT_FIND_INDEX                    25029
#define EMSG_INTERFACE_INVALID_OR_DISC          25030
#define EMSG_CANT_FIND_NAME_OR_NHOP             25031
#define EMSG_AMBIGUOUS_INDEX_FROM_NHOP          25032
#define ERROR_CONFIG                            25033
#define ERROR_ADMIN                             25034

// Strings
    // Router if types
#define STRING_DEDICATED                        26001
#define STRING_HOME_ROUTER                      26002
#define STRING_FULL_ROUTER                      26003
#define STRING_CLIENT                           26004
#define STRING_INTERNAL                         26005

    // Interface types
#define STRING_OTHER                            30001
#define STRING_LOOPBACK                         30006
#define STRING_TUNNEL                           30131

    // Protocol types
#define STRING_UNICAST                          32500
#define STRING_MULTICAST                        32501
#define STRING_GENERAL                          32503

    // Router info block types
#define STRING_IN_FILTER                        32511
#define STRING_OUT_FILTER                       32512
#define STRING_GLOBAL_INFO                      32513
#define STRING_IF_STATUS                        32514
#define STRING_ROUTE_INFO                       32515
#define STRING_PROT_PRIORITY                    32516
#define STRING_RTRDISC                          32517
#define STRING_DD_FILTER                        32518
#define STRING_MC_HEARTBEAT                     32519
#define STRING_MC_BOUNDARY                      32520
#define STRING_IPIP                             32521
#define STRING_IF_FILTER                        32522
#define STRING_MC_LIMIT                         32523

    //  Protocols
#define STRING_LOCAL                            33002
#define STRING_NETMGMT                          33003
#define STRING_ICMP                             33004
#define STRING_EGP                              33005
#define STRING_GGP                              33006
#define STRING_HELLO                            33007
#define STRING_RIP                              33008
#define STRING_IS_IS                            33009
#define STRING_ES_IS                            33010
#define STRING_CISCO                            33011
#define STRING_BBN                              33012
#define STRING_OSPF                             33013
#define STRING_BGP                              33014
#define STRING_BOOTP                            33015
#define STRING_TCP                              33016
#define STRING_TCP_ESTAB                        33017
#define STRING_UDP                              33018
#define STRING_IGMP                             33019
#define STRING_STATIC                           33020
#define STRING_NT_AUTOSTATIC                    33021
#define STRING_NONDOD                           33022
#define STRING_PROTO_ANY                        33023
#define STRING_PROTO_UNKNOWN                    33024
#define STRING_NAT                              33025
#define STRING_DNS_PROXY                        33026
#define STRING_DHCP_ALLOCATOR                   33027
#define STRING_DIFFSERV                         33028
#define STRING_VRRP                             33029

#define STRING_INVALID                          34002
#define STRING_DIRECT                           34003
#define STRING_INDIRECT                         34004

    // Miscellaneous strings
#define STRING_ENABLED                          38003
#define STRING_DISABLED                         38004

#define STRING_INPUT                            38031
#define STRING_OUTPUT                           38032
#define STRING_DIAL                             38033

#define STRING_DROP                             38041
#define STRING_FORWARD                          38042

#define STRING_LOGGING_NONE                     38051
#define STRING_LOGGING_ERROR                    38052
#define STRING_LOGGING_WARN                     38053
#define STRING_LOGGING_INFO                     38054

// Error messages
#define MSG_IP_NO_ROUTE_INFO                    60003
#define MSG_IP_DIM_ERROR                        60005
#define MSG_IP_IF_IS_TUNNEL                     60010
#define MSG_IP_LOCAL_ROUTER_NOT_RUNNING         60011
#define MSG_IP_REMOTE_ROUTER_NOT_RUNNING        60013
#define MSG_IP_CAN_NOT_CONNECT_DIM              60014
#define MSG_IP_NO_ENTRIES                       60015
#define MSG_IP_CORRUPT_INFO                     60016
#define MSG_IP_RESTART_ROUTER                   60017
#define MSG_IP_NOT_ENOUGH_MEMORY                60024
#define MSG_IP_BAD_OPTION_VALUE                 60025
#define MSG_IP_BAD_INTERFACE_TYPE               60032


#define MSG_IP_NO_INPUT_FILTER                  60026
#define MSG_IP_NO_OUTPUT_FILTER                 60027
#define MSG_IP_NO_FILTER_INFO                   60029
#define MSG_IP_NO_DIAL_FILTER                   60030
#define MSG_IP_BAD_OPTION_ENUMERATION           60031
#define MSG_CTRL_C_TO_QUIT                      60062
#define MSG_IP_CANT_DISABLE_INTERFACE           60063

#define MSG_IP_NO_PREF_FOR_PROTOCOL_ID          60121       
#define MSG_IP_PROTO_PREF_LEVEL_EXISTS          60122
#define MSG_IP_PROTO_PREF_LEVEL_NOT_FOUND       60123

//
// Error messages for mib calls
//

#define MSG_MIB_NO_MFES                         62001


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\common.c ===
#include "precomp.h"
#pragma hdrstop

// {8854ff10-d504-11d2-b1ff-00104bc54139}
static const GUID g_MyGuid = 
{ 0x8854ff10, 0xd504, 0x11d2, { 0xb1, 0xff, 0x0, 0x10, 0x4b, 0xc5, 0x41, 0x39 } };

static const GUID g_IpGuid = IPMONTR_GUID;

#define IPPREVIEW_HELPER_VERSION 1

// shell functions

HANDLE g_hModule;
MIB_SERVER_HANDLE g_hMibServer;

VALUE_STRING CommonBooleanStringArray[] = {
    TRUE,  STRING_ENABLED,
    FALSE, STRING_DISABLED
};

VALUE_TOKEN CommonBooleanTokenArray[] = {
    TRUE,  TOKEN_OPT_VALUE_ENABLE,
    FALSE, TOKEN_OPT_VALUE_DISABLE
};

VALUE_STRING CommonLoggingStringArray[] = {
    VRRP_LOGGING_NONE,  STRING_LOGGING_NONE,
    VRRP_LOGGING_ERROR, STRING_LOGGING_ERROR,
    VRRP_LOGGING_WARN,  STRING_LOGGING_WARN,
    VRRP_LOGGING_INFO,  STRING_LOGGING_INFO
};

VALUE_TOKEN CommonLoggingTokenArray[] = {
    VRRP_LOGGING_NONE,  TOKEN_OPT_VALUE_NONE,
    VRRP_LOGGING_ERROR, TOKEN_OPT_VALUE_ERROR,
    VRRP_LOGGING_WARN,  TOKEN_OPT_VALUE_WARN,
    VRRP_LOGGING_INFO,  TOKEN_OPT_VALUE_INFO
};

BOOL WINAPI
DllMain(
    HINSTANCE hInstDll,
    DWORD fdwReason,
    LPVOID pReserved
    )
{
    HANDLE     hDll;
    
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            // printf("Trying to attach\n");
            
            g_hModule = hInstDll;

            DisableThreadLibraryCalls(hInstDll);

            break;
        }
        case DLL_PROCESS_DETACH:
        {
            //
            // Clean up any structures used for commit
            //
            
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;
}

DWORD WINAPI
IpprvwmonStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr;
    IP_CONTEXT_ATTRIBUTES attMyAttributes;

    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    // If you add any more contexts, then this should be converted
    // to use an array instead of duplicating code!

    attMyAttributes.pwszContext = L"vrrp";
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = VrrpDump;
    attMyAttributes.ulNumTopCmds= g_VrrpTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_VrrpTopCmdTable;
    attMyAttributes.ulNumGroups = g_VrrpCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_VrrpCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );

    attMyAttributes.pwszContext = L"msdp";
    attMyAttributes.dwVersion   = 1;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.pfnDumpFn   = MsdpDump;
    attMyAttributes.ulNumTopCmds= g_MsdpTopCmdCount;
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])&g_MsdpTopCmdTable;
    attMyAttributes.ulNumGroups = g_MsdpCmdGroupCount;
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])&g_MsdpCmdGroupTable;

    dwErr = RegisterContext( &attMyAttributes );
    
    return dwErr;
}

DWORD WINAPI
InitHelperDll(
    IN  DWORD              dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES pDllTable
    )
{
    DWORD dwErr;
    NS_HELPER_ATTRIBUTES attMyAttributes;

    pDllTable->dwVersion = NETSH_VERSION_50;
    pDllTable->pfnStopFn = NULL;

    // Register helpers.  We could either register 1 helper which
    // registers three contexts, or we could register 3 helpers
    // which each register one context.  There's only a difference
    // if we support sub-helpers, which this DLL does not.
    // If we later support sub-helpers, then it's better to have
    // 3 helpers so that sub-helpers can register with 1 of them,
    // since it registers with a parent helper, not a parent context.
    // For now, we just use a single 3-context helper for efficiency.

    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );

    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.dwVersion          = IPPREVIEW_HELPER_VERSION;
    attMyAttributes.pfnStart           = IpprvwmonStartHelper;
    attMyAttributes.pfnStop            = NULL;

    dwErr = RegisterHelper( &g_IpGuid, &attMyAttributes );

    return dwErr;
}

BOOL
IsProtocolInstalled(
    DWORD  dwProtoId,
    WCHAR *pwszName
    )
{
    PVOID       pvStart;
    DWORD       dwCount, dwBlkSize, dwRes;

    dwRes = IpmontrGetInfoBlockFromGlobalInfo(dwProtoId,
                                       (PBYTE *) NULL,
                                       &dwBlkSize,
                                       &dwCount);

    if (dwRes isnot NO_ERROR)
    {
        DisplayError(g_hModule, EMSG_PROTO_NOT_INSTALLED, pwszName);
        return FALSE;
    }

    return TRUE;
}

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    )
/*++

Routine Description:

    Gets the interface index.

Arguments:

    pptcArguments  - Argument array
    dwCurrentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command

Return Value:

    NO_ERROR

--*/
{
    DWORD dwErr = NO_ERROR;

    *pdwNumParsed = 1;

    // If index was specified just use it

    if (iswdigit(pptcArguments[dwCurrentIndex][0]))
    {
        pdwIndices[0] = _tcstoul(pptcArguments[dwCurrentIndex],NULL,10);

        return NO_ERROR;
    }

    // Try converting a friendly name to an ifindex

    return IpmontrGetIfIndexFromFriendlyName( g_hMibServer,
                                       pptcArguments[dwCurrentIndex],
                                       &pdwIndices[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\ipprodefs.h ===
#define ptszDelimiter L"="

//-----------------------------------------------------------------------------
//  Macros to faciltate address list (DWORD list) access
//-----------------------------------------------------------------------------

#define     GET_SERVER_INDEX( list, count, addr, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( list[ __dwInd ] == addr ) { break; }                           \
    index = __dwInd;                                                        \
}

#define     DELETE_SERVER_ADDR( list1, list2, count, index )                \
{                                                                           \
    DWORD   __dwInd1 = 0, __dwInd2 = 0;                                     \
    for ( ; __dwInd1 < count; __dwInd1++ )                                  \
    {                                                                       \
        if ( __dwInd1 == index ) { continue; }                              \
        list2[ __dwInd2++ ] = list1[ __dwInd1 ];                            \
    }                                                                       \
}

//-----------------------------------------------------------------------------
//  Macros to faciltate RIP filter list access
//-----------------------------------------------------------------------------

#define     GET_FILTER_INDEX( list, count, filt, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( ( list[ __dwInd ].RF_LoAddress == filt.RF_LoAddress ) &&       \
             ( list[ __dwInd ].RF_HiAddress == filt.RF_HiAddress ) )        \
        {                                                                   \
            break;                                                          \
        }                                                                   \
    index = __dwInd;                                                        \
}

#define     DELETE_FILTER( list1, list2, count, index )                     \
    DELETE_SERVER_ADDR( list1, list2, count, index )

#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, CMD_HELP1)  \
    || MatchToken(pwszToken, CMD_HELP2))

#define     GetDispString(gModule, val, str, count, table)                  \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );            \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); } \
}

//
// mcast addr: 224.0.0.0 < group <240.0.0.0
//

#define IS_MCAST_ADDR(Group) \
    ( (0x000000E0!=(Group))  \
      && (0x000000E0 <= ((Group)&0x000000FF) ) \
      && (0x000000F0 >  ((Group)&0x000000FF) ) )

#define HEAP_FREE_NOT_NULL(ptr) {\
    if (ptr) HeapFree(GetProcessHeap(), 0, (ptr));}

#define HEAP_FREE(ptr) { \
    HeapFree(GetProcessHeap(), 0, ptr);}

#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define MAX_NUM_INDICES 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\ipprvwdefs.h ===
#define ptszDelimiter L"="

//-----------------------------------------------------------------------------
//  Macros to faciltate address list (DWORD list) access
//-----------------------------------------------------------------------------

#define     GET_SERVER_INDEX( list, count, addr, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( list[ __dwInd ] == addr ) { break; }                           \
    index = __dwInd;                                                        \
}

#define     DELETE_SERVER_ADDR( list1, list2, count, index )                \
{                                                                           \
    DWORD   __dwInd1 = 0, __dwInd2 = 0;                                     \
    for ( ; __dwInd1 < count; __dwInd1++ )                                  \
    {                                                                       \
        if ( __dwInd1 == index ) { continue; }                              \
        list2[ __dwInd2++ ] = list1[ __dwInd1 ];                            \
    }                                                                       \
}

//-----------------------------------------------------------------------------
//  Macros to faciltate RIP filter list access
//-----------------------------------------------------------------------------

#define     GET_FILTER_INDEX( list, count, filt, index )                    \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for ( ; __dwInd < count; __dwInd++ )                                    \
        if ( ( list[ __dwInd ].RF_LoAddress == filt.RF_LoAddress ) &&       \
             ( list[ __dwInd ].RF_HiAddress == filt.RF_HiAddress ) )        \
        {                                                                   \
            break;                                                          \
        }                                                                   \
    index = __dwInd;                                                        \
}

#define     DELETE_FILTER( list1, list2, count, index )                     \
    DELETE_SERVER_ADDR( list1, list2, count, index )

#define IsHelpToken(pwszToken)\
    (MatchToken(pwszToken, CMD_HELP1)  \
    || MatchToken(pwszToken, CMD_HELP2))

#define     GetDispString(gModule, val, str, count, table)                  \
{                                                                           \
    DWORD   __dwInd = 0;                                                    \
    for( ; __dwInd < (count); __dwInd += 2 )                                \
    {                                                                       \
        if ( (val) != (table)[ __dwInd ] ) { continue; }                    \
        (str) = MakeString( (gModule), (table)[ __dwInd + 1 ] );            \
        break;                                                              \
    }                                                                       \
    if ( __dwInd >= (count) ) { (str) = MakeString( (gModule), STRING_UNKNOWN ); } \
}

//
// mcast addr: 224.0.0.0 < group <240.0.0.0
//

#define IS_MCAST_ADDR(Group) \
    ( (0x000000E0!=(Group))  \
      && (0x000000E0 <= ((Group)&0x000000FF) ) \
      && (0x000000F0 >  ((Group)&0x000000FF) ) )

#define HEAP_FREE_NOT_NULL(ptr) {\
    if (ptr) HeapFree(GetProcessHeap(), 0, (ptr));}

#define HEAP_FREE(ptr) { \
    HeapFree(GetProcessHeap(), 0, ptr);}

#define GET_TOKEN_PRESENT(tokenMask) (dwBitVector & tokenMask)
#define SET_TOKEN_PRESENT(tokenMask) (dwBitVector |= tokenMask)

#define MAX_NUM_INDICES 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdp.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdphlp.h

Abstract:

    MSDP Command dispatcher declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_MSDPHLP_H_
#define _NETSH_MSDPHLP_H_

extern CMD_ENTRY g_MsdpAddCmdTable[];
extern CMD_ENTRY g_MsdpDelCmdTable[];
extern CMD_ENTRY g_MsdpSetCmdTable[];
extern CMD_ENTRY g_MsdpShowCmdTable[];


extern CMD_GROUP_ENTRY g_MsdpCmdGroupTable[];
extern ULONG g_MsdpCmdGroupCount;
extern CMD_ENTRY g_MsdpTopCmdTable[];
extern ULONG g_MsdpTopCmdCount;

NS_CONTEXT_DUMP_FN  MsdpDump;

extern VALUE_STRING MsdpEncapsStringArray[];
extern VALUE_TOKEN  MsdpEncapsTokenArray[];
#define MSDP_ENCAPS_SIZE 1

#endif // _NETSH_MSDPHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\common.h ===
extern ULONG StartedCommonInitialization, CompletedCommonInitialization ;
extern HANDLE g_hModule;
extern MIB_SERVER_HANDLE g_hMibServer;

typedef
DWORD
(GET_OPT_FN)(
    IN    LPCWSTR  *ppwcArguments,
    IN    DWORD    dwCurrentIndex,
    IN    DWORD    dwArgCount,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    );

typedef GET_OPT_FN *PGET_OPT_FN;

typedef struct _MIB_OBJECT_PARSER
{
    PWCHAR         pwszMIBObj;
    DWORD          dwMinOptArg;
    DWORD          dwNumArgs;
    PGET_OPT_FN    pfnMIBObjParser;
//  DWORD          dwShortCmdHelpToken;
//  DWORD          dwCmdHelpToken;
} MIB_OBJECT_PARSER,*PMIB_OBJECT_PARSER;

#define CREATE_MIB_ENTRY(t,m,f)   {TOKEN_##t, HLP_##t, HLP_##t##_EX, m,f}

BOOL
IsProtocolInstalled(
    DWORD  dwProtoId,
    WCHAR *pwszName
    );

DWORD
GetMIBIfIndex(
    IN    PTCHAR   *pptcArguments,
    IN    DWORD    dwCurrentIndex,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed
    );

typedef DWORD IPV4_ADDRESS;

extern VALUE_STRING CommonBooleanStringArray[];
extern VALUE_TOKEN  CommonBooleanTokenArray[];
#define COMMON_BOOLEAN_SIZE 2

extern VALUE_STRING CommonLoggingStringArray[];
extern VALUE_TOKEN  CommonLoggingTokenArray[];
#define COMMON_LOGGING_SIZE 4

#define VERIFY_INSTALLED(x,y) \
        if (!IsProtocolInstalled(x,y))  \
        { \
            return NO_ERROR; \
        }

#define \
IP_TO_TSTR(str,addr) \
    swprintf( \
        (str), \
        TEXT("%d.%d.%d.%d"), \
        ((PUCHAR)addr)[0], \
        ((PUCHAR)addr)[1], \
        ((PUCHAR)addr)[2], \
        ((PUCHAR)addr)[3] \
        )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdp.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdp.c

Abstract:

    This module contains code for dispatching commands
    received for the Multicast Source Discovery Protocol.
    The implementation of the commands is elsewhere,
    in msdpopt.c.

Author

    Dave Thaler (dthaler)  21-May-1999

Revision History:

    Based loosely on net\routing\netsh\ip\protocols\nathlp.c by AboladeG

--*/

#include "precomp.h"
#pragma hdrstop


CMD_ENTRY g_MsdpAddCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_ADD_PEER, HandleMsdpAddPeer),
};

CMD_ENTRY g_MsdpDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_DELETE_PEER, HandleMsdpDeletePeer),
};

CMD_ENTRY g_MsdpSetCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_SET_GLOBAL, HandleMsdpSetGlobal),
    CREATE_CMD_ENTRY(MSDP_SET_PEER,   HandleMsdpSetPeer)
};

CMD_ENTRY g_MsdpShowCmdTable[] =
{
    CREATE_CMD_ENTRY(MSDP_SHOW_SA,          HandleMsdpMibShowObject),
    CREATE_CMD_ENTRY(MSDP_SHOW_GLOBAL,      HandleMsdpShowGlobal),
    CREATE_CMD_ENTRY(MSDP_SHOW_GLOBALSTATS, HandleMsdpMibShowObject),
    CREATE_CMD_ENTRY(MSDP_SHOW_PEER,        HandleMsdpShowPeer),
    CREATE_CMD_ENTRY(MSDP_SHOW_PEERSTATS,   HandleMsdpMibShowObject)
};

CMD_GROUP_ENTRY g_MsdpCmdGroupTable[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,    g_MsdpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_MsdpDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,    g_MsdpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,   g_MsdpShowCmdTable)
};

ULONG g_MsdpCmdGroupCount =
    sizeof(g_MsdpCmdGroupTable) / sizeof(g_MsdpCmdGroupTable[0]);

CMD_ENTRY g_MsdpTopCmdTable[] =
{
    CREATE_CMD_ENTRY(INSTALL,   HandleMsdpInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleMsdpUninstall),
};

ULONG g_MsdpTopCmdCount =
    sizeof(g_MsdpTopCmdTable) / sizeof(g_MsdpTopCmdTable[0]);

DWORD
MsdpDump(
    PWCHAR  pwszMachine,
    WCHAR   **ppwcArguments,
    DWORD   dwArgCount,
    PVOID   pvData
    )
{
    g_hMibServer = (MIB_SERVER_HANDLE)pvData;

    DisplayMessage(g_hModule,DMP_MSDP_HEADER);
    DisplayMessageT(DMP_MSDP_PUSHD);
    DisplayMessageT(DMP_UNINSTALL);

    //
    // Show the global info commands
    //

    ShowMsdpGlobalInfo(FORMAT_DUMP);

    ShowMsdpPeerInfo(FORMAT_DUMP, NULL, NULL);

    DisplayMessageT(DMP_POPD);
    DisplayMessage(g_hModule, DMP_MSDP_FOOTER);

    return NO_ERROR;
} // MSDPDump
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdpcfg.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdpcfg.h

Abstract:

    MSDP configuration declarations

Author:

    Dave Thaler (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_MSDPCFG_H_
#define _NETSH_MSDPCFG_H_

#define MSDP_IPADDR_LENGTH  16
#define MAX_MESSAGE_SIZE    256

#define MSDP_INTF_VRID_MASK     0x00000001
#define MSDP_INTF_IPADDR_MASK   0x00000002
#define MSDP_INTF_AUTH_MASK     0x00000004
#define MSDP_INTF_PASSWD_MASK   0x00000008
#define MSDP_INTF_ADVT_MASK     0x00000010
#define MSDP_INTF_PRIO_MASK     0x00000020
#define MSDP_INTF_PREEMPT_MASK  0x00000040

DWORD
GetMsdpGlobalConfig(
    OUT PMSDP_GLOBAL_CONFIG *ppGlobalInfo
    );

DWORD
SetMsdpGlobalConfig(
    OUT PMSDP_GLOBAL_CONFIG pGlobalInfo
    );

DWORD
MakeMsdpGlobalConfig(
    OUT PUCHAR* GlobalInfo,
    OUT PULONG GlobalInfoSize
    );

DWORD
CreateMsdpGlobalConfig(
    OUT PMSDP_GLOBAL_CONFIG* GlobalInfo,
    IN  DWORD LoggingLevel
    );

ULONG
MakeMsdpIPv4PeerConfig(
    PMSDP_IPV4_PEER_CONFIG *ppPeer
    );

DWORD
SetMsdpInterfaceConfig(
    PWCHAR                 pwszInterfaceName,
    PMSDP_IPV4_PEER_CONFIG pConfigInfo
    );

DWORD
GetMsdpInterfaceConfig(
    PWCHAR                  pwszInterfaceName,
    PMSDP_IPV4_PEER_CONFIG *ppConfigInfo
    );

DWORD
ShowMsdpGlobalInfo(
    IN DWORD dwFormat
    );

DWORD
ShowMsdpPeerInfo(
    DWORD  dwFormat,
    PWCHAR pwszPeerAddress,
    PWCHAR pwszPeerName
    );

DWORD
UpdateMsdpGlobalInfo(
    PMSDP_GLOBAL_CONFIG GlobalInfo
    );

DWORD
UpdateMsdpPeerInfo(
    PWCHAR                 PeerName,
    PMSDP_IPV4_PEER_CONFIG PeerInfo,
    ULONG                  BitVector,
    BOOL                   AddPeer
    );

DWORD
MsdpAddIPv4PeerInterface(
    IN LPCWSTR                pwszMachineName,
    IN LPCWSTR                pwszInterfaceName, 
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    );

DWORD
MsdpDeletePeerInterface(
    IN  LPCWSTR pwszMachineName,
    IN  LPCWSTR pwszInterfaceName
    );

DWORD
GetMsdpPeerInfoSize(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    );

//
// IP address conversion macros:
//    
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//
#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )

#define FORMAT_TABLE       1
#define FORMAT_VERBOSE     2
#define FORMAT_DUMP        3

#endif  // _NETSH_MSDPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdpcfg.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    routing\netsh\ip\protocols\msdpcfg.c

Abstract:

    Multicast Source Discovery Protocol configuration implementation.
    This module contains configuration routines which are relied upon
    by msdpopt.c. The routines retrieve, update, and display
    the configuration for the MSDP protocol.

    This file also contains default configuration settings
    for MSDP.

    N.B. The display routines require special attention since display
    may result in a list of commands sent to a 'dump' file, or in a
    textual presentation of the configuration to a console window.
    In the latter case, we use non-localizable output routines to generate
    a script-like description of the configuration. In the former case,
    we use localizable routines to generate a human-readable description.

Author:

    Dave Thaler (dthaler)  21-May-1999

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#ifndef HAVE_INTSOCK
# include <nhapi.h>
# include <rpc.h>
#endif

#define MSDP_DEFAULT_KEEPALIVE       30  // suggested value in RFC 1771
#define MSDP_DEFAULT_SAHOLDDOWN      30  // should be 30 per MSDP spec
#define MSDP_DEFAULT_CONNECTRETRY   120  // suggested value in RFC 1771
#define MSDP_DEFAULT_CACHE_LIFETIME 120  // should be >=90 seconds per MSDP spec
#define MSDP_DEFAULT_ENCAPSULATION  MSDP_ENCAPS_NONE // XXX

#define MALLOC(x)    HeapAlloc(GetProcessHeap(), 0, (x))
#define REALLOC(x,y) HeapReAlloc(GetProcessHeap(), 0, (x), (y))
#define FREE(x)      HeapFree(GetProcessHeap(), 0, (x))

static  MSDP_GLOBAL_CONFIG g_MsdpGlobalDefault =
{
    MSDP_LOGGING_ERROR,
    0, // flags
    MSDP_DEFAULT_KEEPALIVE,
    MSDP_DEFAULT_CONNECTRETRY,
    MSDP_DEFAULT_CACHE_LIFETIME,
    MSDP_DEFAULT_SAHOLDDOWN
};

typedef enum {
    CommonLoggingIndex = 0,
    CommonBooleanIndex,
    MsdpEncapsIndex
} DISPLAY_VALUE_INDEX;

VALUE_STRING MsdpEncapsStringArray[] = {
    MSDP_ENCAPS_NONE,  STRING_NONE,
};

VALUE_TOKEN MsdpEncapsTokenArray[] = {
    MSDP_ENCAPS_NONE,  TOKEN_OPT_VALUE_NONE,
};

static PUCHAR g_pMsdpGlobalDefault = (PUCHAR)&g_MsdpGlobalDefault;

static MSDP_IPV4_PEER_CONFIG g_MsdpPeerDefault = 
{ 
    0, 0, 0, 0, 0, MSDP_ENCAPS_DEFAULT
};

//
// Forward declarations
//
ULONG
ValidateMsdpPeerInfo(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    );

//
// What follows are the arrays used to map values to strings and
// to map values to tokens. These, respectively, are used in the case
// where we are displaying to a 'dump' file and to a console window.
//
VALUE_STRING MsdpGlobalLoggingStringArray[] = {
    MSDP_LOGGING_NONE,  STRING_LOGGING_NONE,
    MSDP_LOGGING_ERROR, STRING_LOGGING_ERROR,
    MSDP_LOGGING_WARN,  STRING_LOGGING_WARN,
    MSDP_LOGGING_INFO,  STRING_LOGGING_INFO
};

VALUE_TOKEN MsdpGlobalLoggingTokenArray[] = {
    MSDP_LOGGING_NONE,  TOKEN_OPT_VALUE_NONE,
    MSDP_LOGGING_ERROR, TOKEN_OPT_VALUE_ERROR,
    MSDP_LOGGING_WARN,  TOKEN_OPT_VALUE_WARN,
    MSDP_LOGGING_INFO,  TOKEN_OPT_VALUE_INFO
};

//
// Allocate a global info block containing the default information
//
// Called by: HandleMsdpInstall()
//
ULONG
MakeMsdpGlobalConfig(
    OUT PUCHAR* ppGlobalInfo,
    OUT PULONG  pulGlobalInfoSize
    )
{
    *pulGlobalInfoSize = sizeof(MSDP_GLOBAL_CONFIG);
    *ppGlobalInfo = MALLOC(*pulGlobalInfoSize);
    if (!*ppGlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*ppGlobalInfo, g_pMsdpGlobalDefault, sizeof(MSDP_GLOBAL_CONFIG));
    return NO_ERROR;
}

#if 0
//
// Update global parameters
//
// Called by: HandleMsdpSetGlobal()
//
ULONG
CreateMsdpGlobalInfo(
    OUT PMSDP_GLOBAL_CONFIG* pGlobalInfo,
    IN  DWORD                dwLoggingLevel
    )
{
    DWORD dwGlobalInfoSize;
    dwGlobalInfoSize = sizeof(PMSDP_GLOBAL_CONFIG);
    *pGlobalInfo = MALLOC(dwGlobalInfoSize);
    if (!*pGlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*pGlobalInfo, g_pMsdpGlobalDefault, dwGlobalInfoSize);
    (*pGlobalInfo)->dwLoggingLevel = dwLoggingLevel;

    return NO_ERROR;
}
#endif

//
// Called by: MsdpHandleAddPeer()
//
ULONG
MakeMsdpIPv4PeerConfig(
    OUT PMSDP_IPV4_PEER_CONFIG *ppPeer
    )
{
    ULONG ulSize = sizeof(MSDP_IPV4_PEER_CONFIG);

    *ppPeer = MALLOC(ulSize);
    if (!*ppPeer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*ppPeer, &g_MsdpPeerDefault, ulSize);
    return NO_ERROR;
}

DWORD
MsdpAddIPv4PeerInterface(
    IN  LPCWSTR                pwszMachineName,
    IN  LPCWSTR                pwszInterfaceName,
    IN  PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    DWORD               dwErr = NO_ERROR;
    
    do {
        dwErr = IpmontrCreateInterface(pwszMachineName, pwszInterfaceName,
                                       pPeer->ipLocalAddress,
                                       pPeer->ipRemoteAddress,
                                       1);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = SetMsdpInterfaceConfig( pwszInterfaceName, pPeer );
    } while (FALSE);

    return dwErr;
}

#if 0
DWORD
MsdpAddIPv4PeerConfig(
    IN  PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    PMSDP_GLOBAL_CONFIG pGlobal = NULL, pNewGlobal;
    DWORD               dwErr;
    ULONG               ulV4PeerCount, ulSize, i;
    PMSDP_FAMILY_CONFIG pFamily;
    
    do {
        dwErr = GetMsdpGlobalConfig( &pGlobal );
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        pFamily = MSDP_FIRST_FAMILY(pGlobal);

        // Check for duplicate
        for (i=0; (i<pFamily->usNumPeers) and 
        (pFamily->pPeer[i].ipRemoteAddress isnot pPeer->ipRemoteAddress); i++);
        if (i<pFamily->usNumPeers)
        {
            dwErr = ERROR_OBJECT_ALREADY_EXISTS;
            break;
        }

        ulV4PeerCount = pFamily->usNumPeers++;
        ulSize = MSDP_GLOBAL_CONFIG_SIZE(ulV4PeerCount+1);
        pNewGlobal = REALLOC( pGlobal, ulSize );
        if (!pNewGlobal)
        {
            dwErr = GetLastError();
            break;
        }
        pGlobal = pNewGlobal;
        pFamily = MSDP_FIRST_FAMILY(pGlobal);

        memcpy( &pFamily->pPeer[ulV4PeerCount], 
                pPeer, 
                sizeof(MSDP_IPV4_PEER_CONFIG) );

        // DisplayMessageT(L"remoteaddr=%1!x!\n", 
        // pFamily->pPeer[ulV4PeerCount].ipRemoteAddress);

        dwErr = SetMsdpGlobalConfig( pGlobal );
    } while (FALSE);

    if (pGlobal)
    {
        FREE(pGlobal);
    }

    return dwErr;
}
#endif

#if 0
// 
// Called by: XXX
//
ULONG
MakeMsdpFamilyInfo(
    IN OUT PUCHAR pFamily
    )
{
    //
    // Always assume that the space has been preassigned
    //
    if (!pFamily) {
        return ERROR_INVALID_PARAMETER;
    }
    CopyMemory(pFamily,&g_MsdpFamilyDefault,sizeof(g_MsdpFamilyDefault));
    return NO_ERROR;    
}
#endif

PTCHAR
MsdpQueryValueString(
    DWORD               dwFormat,
    DISPLAY_VALUE_INDEX Index,
    ULONG               Value
    )
{
    ULONG         Count;
    DWORD         dwErr;
    PTCHAR        String = NULL;
    PVALUE_STRING StringArray;
    PVALUE_TOKEN  TokenArray;
    switch (Index) {
        case CommonLoggingIndex:
            Count = COMMON_LOGGING_SIZE;
            StringArray = CommonLoggingStringArray;
            TokenArray = CommonLoggingTokenArray;
            break;
        case CommonBooleanIndex:
            Count = COMMON_BOOLEAN_SIZE;
            StringArray = CommonBooleanStringArray;
            TokenArray = CommonBooleanTokenArray;
            break;
        case MsdpEncapsIndex:
            Count = MSDP_ENCAPS_SIZE;
            StringArray = MsdpEncapsStringArray;
            TokenArray = MsdpEncapsTokenArray;
            break;
        default:
            return NULL;
    }
    dwErr = GetAltDisplayString( g_hModule,
                                 (HANDLE)(dwFormat is FORMAT_DUMP),
                                 Value,
                                 TokenArray,
                                 StringArray,
                                 Count,
                                 &String );
    return (dwErr)? NULL : String;
}

DWORD
GetMsdpInterfaceConfig(
    IN  LPCWSTR                 pwszInterfaceName,
    OUT PMSDP_IPV4_PEER_CONFIG *ppConfigInfo
    )
{
    DWORD dwErr, dwIfType;
    ULONG ulSize, ulCount;

    //
    // Retrieve the interface configuration for MSDP
    //
    dwErr = IpmontrGetInfoBlockFromInterfaceInfo( pwszInterfaceName,
                                                  MS_IP_MSDP,
                                                  (PUCHAR*)ppConfigInfo,
                                                  &ulSize,
                                                  &ulCount,
                                                  &dwIfType );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    } else if (!(ulCount * ulSize)) {
        return ERROR_NOT_FOUND; 
    }

    return NO_ERROR;
}

DWORD
GetMsdpGlobalConfig(
    PMSDP_GLOBAL_CONFIG *ppGlobalInfo
    )
{
    DWORD dwErr;
    ULONG ulSize, ulCount;

    //
    // Retrieve the global configuration for MSDP,
    //
    dwErr = IpmontrGetInfoBlockFromGlobalInfo( MS_IP_MSDP,
                                        (PUCHAR*)ppGlobalInfo,
                                        &ulSize,
                                        &ulCount );
    if (dwErr isnot NO_ERROR) {
        return dwErr;
    } else if (!(ulCount * ulSize)) {
        return ERROR_NOT_FOUND; 
    }

    return NO_ERROR;
}

DWORD
SetMsdpInterfaceConfig(
    PWCHAR                 pwszInterfaceName,
    PMSDP_IPV4_PEER_CONFIG pConfigInfo
    )
{
    DWORD dwErr;
    ULONG ulSize, ulV4PeerCount;
    WCHAR wszIfName[MAX_INTERFACE_NAME_LEN+1];
    
    ulSize = sizeof(wszIfName);
    dwErr = IpmontrGetIfNameFromFriendlyName(pwszInterfaceName,
                                             wszIfName,
                                             &ulSize);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    //
    // Save the interface configuration for MSDP
    //
    ulSize = sizeof(MSDP_IPV4_PEER_CONFIG);
    dwErr = IpmontrSetInfoBlockInInterfaceInfo( wszIfName,
                                                MS_IP_MSDP,
                                                (PUCHAR)pConfigInfo,
                                                ulSize,
                                                1 );
    return dwErr;
}

DWORD
SetMsdpGlobalConfig(
    PMSDP_GLOBAL_CONFIG pGlobalInfo
    )
{
    DWORD dwErr;
    ULONG ulSize;

    //
    // Save the global configuration for MSDP,
    //
    ulSize = sizeof(MSDP_GLOBAL_CONFIG);
    dwErr = IpmontrSetInfoBlockInGlobalInfo( MS_IP_MSDP,
                                      (PUCHAR)pGlobalInfo,
                                      ulSize,
                                      1 );
    return dwErr;
}

ULONG
ShowMsdpGlobalInfo(
    DWORD dwFormat
    )
{
    ULONG               ulCount = 0;
    DWORD               dwErr;
    PMSDP_GLOBAL_CONFIG pGlobalInfo = NULL;
    ULONG               i;
    PWCHAR              pwszLoggingLevel = NULL,
                        pwszAcceptAll = NULL;
    ULONG               ulSize;

    do {
        dwErr = GetMsdpGlobalConfig(&pGlobalInfo);
        if (dwErr) {
            break;
        }

        pwszLoggingLevel = MsdpQueryValueString( dwFormat, 
                                                 CommonLoggingIndex,
                                                 pGlobalInfo->dwLoggingLevel );

        pwszAcceptAll    = MsdpQueryValueString( dwFormat, 
                                                 CommonBooleanIndex,
                        (pGlobalInfo->dwFlags & MSDP_GLOBAL_FLAG_ACCEPT_ALL) );

        if (dwFormat is FORMAT_DUMP) 
        {
            DisplayMessageT( DMP_INSTALL );
            DisplayMessageT( DMP_MSDP_SET_GLOBAL );

            if (pwszLoggingLevel) {
                DisplayMessageT( DMP_MSDP_STRING_ARGUMENT,
                                 TOKEN_OPT_LOGGINGLEVEL, pwszLoggingLevel );
            }

            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_KEEPALIVE, pGlobalInfo->ulDefKeepAlive);
            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_SAHOLDDOWN,pGlobalInfo->ulSAHolddown);
            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_CONNECTRETRY, 
                             pGlobalInfo->ulDefConnectRetry);
            DisplayMessageT( DMP_MSDP_STRING_ARGUMENT,
                             TOKEN_OPT_ACCEPTALL, 
                             pwszAcceptAll);
            DisplayMessageT( DMP_MSDP_INTEGER_ARGUMENT,
                             TOKEN_OPT_CACHELIFETIME,
                             pGlobalInfo->ulCacheLifetime);
            DisplayMessageT( MSG_NEWLINE );
        } 
        else 
        {
            DisplayMessage( g_hModule,
                            MSG_MSDP_GLOBAL_INFO,
                            pwszLoggingLevel,
                            pGlobalInfo->ulDefKeepAlive,     
                            pGlobalInfo->ulSAHolddown,     
                            pGlobalInfo->ulDefConnectRetry,
                            pwszAcceptAll,
                            pGlobalInfo->ulCacheLifetime );
        }
    } while(FALSE);
    
    if (pwszLoggingLevel) { FREE(pwszLoggingLevel); }
    if (pGlobalInfo) { FREE(pGlobalInfo); }
    if ((dwFormat isnot FORMAT_DUMP) and (dwErr isnot NO_ERROR)) 
    {
        if (dwErr == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
        } else {
            DisplayError(g_hModule, dwErr);
        }
    }
    return dwErr;
}

ULONG
MsdpPeerKeepAlive(
    IN PMSDP_GLOBAL_CONFIG    pGlobal, 
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_KEEPALIVE)
    {
        return pPeer->ulKeepAlive;
    }
    return pGlobal->ulDefKeepAlive;
}

ULONG
MsdpPeerConnectRetry(
    IN PMSDP_GLOBAL_CONFIG    pGlobal, 
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CONNECTRETRY)
    {
        return pPeer->ulConnectRetry;
    }
    return pGlobal->ulDefConnectRetry;
}

PWCHAR
MsdpPeerFlags(
    IN PMSDP_IPV4_PEER_CONFIG pPeer
    )
{
    static WCHAR wszString[33];

    wszString[0] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CONNECTRETRY)? L'R' : L' ';
    wszString[1] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_KEEPALIVE)   ? L'K' : L' ';
    wszString[2] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CACHING)     ? L'C' : L' ';
    wszString[3] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_DEFAULTPEER) ? L'D' : L' ';
    wszString[4] = (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_PASSIVE)     ? L'P' : L' ';
    wszString[5] = 0;

    return wszString;
}

//
// Called by: HandleMsdpShowPeer()
//
DWORD
ShowMsdpPeerInfo(
    IN DWORD  dwFormat,
    IN LPCWSTR pwszPeerAddress OPTIONAL,
    IN LPCWSTR pwszPeerName    OPTIONAL
    )
{
    DWORD                  dwErr, dwTotal;
    PMSDP_IPV4_PEER_CONFIG pPeer;
    ULONG                  i, ulNumInterfaces, ulCount = 0;
    WCHAR                  wszRemoteAddress[20];
    WCHAR                  wszLocalAddress[20];
    PWCHAR                 pwszEncapsMethod;
    PMPR_INTERFACE_0       pmi0 = NULL;
    PMSDP_GLOBAL_CONFIG    pGlobalInfo = NULL;
    WCHAR                  wszFriendlyName[MAX_INTERFACE_NAME_LEN+1];
    DWORD                  dwSize = sizeof(wszFriendlyName);

    dwErr = GetMsdpGlobalConfig(&pGlobalInfo);
    if (dwErr isnot NO_ERROR) 
    {
        return dwErr;
    }

    do {
        //
        // Retrieve the peer's configuration
        // and format it to the output file or console.
        //
        dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, 
                                     &ulNumInterfaces,
                                     &dwTotal);
        if (dwErr isnot NO_ERROR)
        {
            return dwErr;
        }

        for (i=0; i<ulNumInterfaces; i++)
        {
            dwErr = IpmontrGetFriendlyNameFromIfName(pmi0[i].wszInterfaceName,
                        wszFriendlyName, &dwSize);

            if (pwszPeerName
             and wcscmp(pwszPeerName, wszFriendlyName)) 
            {
                continue;
            }

            dwErr = GetMsdpInterfaceConfig(pmi0[i].wszInterfaceName, &pPeer);
            if (dwErr isnot NO_ERROR)
            {
                continue;
            }

            IP_TO_TSTR(wszRemoteAddress, &pPeer->ipRemoteAddress);

            if (pwszPeerAddress
             and wcscmp(pwszPeerAddress, wszRemoteAddress)) 
            {
                FREE(pPeer);
                continue;
            }

            if ((ulCount is 0) and (dwFormat is FORMAT_TABLE))
            {
                DisplayMessage( g_hModule, MSG_MSDP_PEER_HEADER );
            }

            IP_TO_TSTR(wszLocalAddress,  &pPeer->ipLocalAddress);

            pwszEncapsMethod = MsdpQueryValueString( dwFormat, 
                                                     MsdpEncapsIndex,
                                                     pPeer->dwEncapsMethod );

            if (dwFormat is FORMAT_DUMP) {
                DisplayMessageT(DMP_MSDP_ADD_PEER);
                DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                TOKEN_OPT_NAME, wszFriendlyName);
                DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                TOKEN_OPT_REMADDR,   wszRemoteAddress);
                if (pPeer->ipLocalAddress)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_LOCALADDR, wszLocalAddress);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_KEEPALIVE)
                {
                    DisplayMessageT(DMP_MSDP_INTEGER_ARGUMENT,
                                    TOKEN_OPT_KEEPALIVE, pPeer->ulKeepAlive);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CONNECTRETRY)
                {
                    DisplayMessageT(DMP_MSDP_INTEGER_ARGUMENT,
                                    TOKEN_OPT_CONNECTRETRY, 
                                    pPeer->ulConnectRetry);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_CACHING)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_CACHING, 
                                    TOKEN_OPT_VALUE_YES);
                }
                if (pPeer->dwConfigFlags & MSDP_PEER_CONFIG_DEFAULTPEER)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_DEFAULTPEER, 
                                    TOKEN_OPT_VALUE_YES);
                }
                if (pPeer->dwEncapsMethod isnot MSDP_DEFAULT_ENCAPSULATION)
                {
                    DisplayMessageT(DMP_MSDP_STRING_ARGUMENT,
                                    TOKEN_OPT_ENCAPSMETHOD,
                                    pwszEncapsMethod);
                }
                DisplayMessageT(MSG_NEWLINE);
            } else {
                DWORD dwId = (dwFormat is FORMAT_TABLE)? MSG_MSDP_PEER_INFO :
                                                         MSG_MSDP_PEER_INFO_EX;
                DisplayMessage( g_hModule, 
                                dwId,
                                wszRemoteAddress,
                                wszLocalAddress,
                                MsdpPeerKeepAlive(pGlobalInfo, pPeer),
                                MsdpPeerConnectRetry(pGlobalInfo, pPeer),
                                MsdpPeerFlags(pPeer),
                                pwszEncapsMethod,
                                wszFriendlyName);
            }
            FREE(pPeer);

            ulCount++;
        }
    } while(FALSE);

    FREE(pGlobalInfo);

    if ((dwFormat isnot FORMAT_DUMP) && dwErr) {
        if (dwErr == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
        } else {
            DisplayError(g_hModule, dwErr);
        }
    }
    if (pmi0)
    {
        FREE(pmi0);
    }
    if ((dwFormat is FORMAT_TABLE) and (ulCount is 0) and (dwErr is NO_ERROR))
    {
        DisplayMessage(g_hModule, MSG_MSDP_NO_PEER_INFO);
    }
    return dwErr;
}

#if 0
ULONG
UpdateMsdpGlobalInfo(
    PMSDP_GLOBAL_CONFIG GlobalInfo    
    )
{
    ULONG Count;
    ULONG Error;
    PMSDP_GLOBAL_CONFIG NewGlobalInfo = NULL;
    PMSDP_GLOBAL_CONFIG OldGlobalInfo = NULL;
    ULONG Size;
    
    do {
        //
        // Retrieve the existing global configuration.
        //
        Error =
            IpmontrGetInfoBlockFromGlobalInfo(
                MS_IP_MSDP,
                (PUCHAR*)&OldGlobalInfo,
                &Size,
                &Count
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }

        //
        // Allocate a new structure, copy to it the original configuration,
        //

        NewGlobalInfo = MALLOC(Count * Size);
        if (!NewGlobalInfo) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        CopyMemory(NewGlobalInfo, OldGlobalInfo, Count * Size);
        
        //
        // Based on the changes requested, change the NewGlobalInfo.
        // Since for MSDP there is only the logging level to change, we just set that.
        //
        
        NewGlobalInfo->dwLoggingLevel = GlobalInfo->dwLoggingLevel;
        
        Error =
            IpmontrSetInfoBlockInGlobalInfo(
                MS_IP_MSDP,
                (PUCHAR)NewGlobalInfo,
                FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
                Size,
                1
                );
    } while(FALSE);
    if (NewGlobalInfo) { FREE(NewGlobalInfo); }
    if (OldGlobalInfo) { FREE(OldGlobalInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}
#endif

#if 0
ULONG
UpdateMsdpPeerInfo(
    PWCHAR              PeerName,
    PMSDP_FAMILY_CONFIG pFamily,
    ULONG               BitVector,
    BOOL                AddPeer
    )
{
    ULONG Count;
    ULONG Error;
    PMSDP_IPV4_PEER_CONFIG NewPeerInfo = NULL;
    PMSDP_IPV4_PEER_CONFIG OldPeerInfo = NULL;
    ULONG Size;
    ROUTER_INTERFACE_TYPE Type;
    ULONG i;

    if (!AddPeer && !BitVector) { return NO_ERROR; }
    do {
        //
        // Retrieve the existing interface configuration.
        // We will update this block below, as well as adding to or removing
        // from it depending on the flags specified in 'BitVector'.
        //
        Error =
            GetInfoBlockFromPeerInfo(
                PeerName,
                MS_IP_MSDP,
                (PUCHAR*)&OldPeerInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            //
            // No existing configuration is found. This is an error unless
            // we are adding the interface anew, in which case we just
            // create for ourselves a block containing the default settings.
            //
            if (!AddPeer) {
                break;
            } else {
                Error = GetPeerType(PeerName, &Type);
                if (Error) {
                    break;
                } else {
                    Count = 1;
                    Error =
                        MakeMsdpPeerInfo(
                            Type, (PUCHAR*)&OldPeerInfo, &Size
                            );
                    if (Error) { break; }
                }
            }
        } else {
            //
            // There is configuration on the interface. If it is empty this is
            // an error. If this is an add interface, and the info exists, it is
            // an error.
            //
            if (!(Count * Size) && !AddPeer) {
                Error = ERROR_NOT_FOUND; break;
            }
            else if (AddPeer) {
                //
                // We were asked to add an interface which already exists
                //
                DisplayMessage(g_hModule, EMSG_INTERFACE_EXISTS, PeerName);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
                    
        }

        if (!BitVector) {
            //
            // Just add this interface without any additional info.
            //
            DWORD OldSize;
            if (NewPeerInfo == NULL){
                NewPeerInfo = MALLOC((OldSize=GetMsdpPeerInfoSize(OldPeerInfo))+
                                          sizeof(MSDP_VROUTER_CONFIG));
                if (!NewPeerInfo) {
                    DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;                        
                }
            }
            CopyMemory(NewPeerInfo,OldPeerInfo,OldSize);
        }
        else{
            if (!AddPeer || (OldPeerInfo->VrouterCount != 0)) {
                //
                // There is a prexisting VRID set. Check for this VRID in the list and then
                // update it if required.
                //
                ASSERT(BitVector & MSDP_INTF_VRID_MASK);
                for (i = 0, PVrouter = MSDP_FIRST_VROUTER_CONFIG(OldPeerInfo);
                     i < OldPeerInfo->VrouterCount; 
                     i++, PVrouter = MSDP_NEXT_VROUTER_CONFIG(PVrouter)) {
                    if (PVrouter->VRID == VRouterInfo->VRID) {
                        break;
                    }
                }
                if (i == OldPeerInfo->VrouterCount) {
                    //
                    // This is a new VRID, Add it.
                    //
                    DWORD OldSize;

                    //
                    // The IP address should be valid or else this is a set op.
                    //
                    if (!(BitVector & MSDP_INTF_IPADDR_MASK)){
                        DisplayMessage(
                            g_hModule, EMSG_INVALID_VRID,
                            VRouterInfo->VRID
                            );
                        Error = ERROR_INVALID_PARAMETER;
                        break;
                    }

                    if (NewPeerInfo == NULL){
                        NewPeerInfo = MALLOC((OldSize=GetMsdpPeerInfoSize(
                                                OldPeerInfo))+
                                                sizeof(MSDP_VROUTER_CONFIG));
                        if (!NewPeerInfo) {
                            DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                            Error = ERROR_NOT_ENOUGH_MEMORY;
                            break;                        
                        }
                    }
                    CopyMemory(NewPeerInfo, OldPeerInfo, OldSize);
                    PVrouter = (PMSDP_VROUTER_CONFIG)((PBYTE)NewPeerInfo+OldSize);
                    CopyMemory(PVrouter,VRouterInfo,sizeof(MSDP_VROUTER_CONFIG));
                    NewPeerInfo->VrouterCount++;

                    //
                    // Check if we own the IP address given. If yes, set the priority.
                    //
                    PVrouter->ConfigPriority = 
                        FoundIpAddress(PVrouter->IPAddress[0]) ? 255 : 100;
                } 
                else{
                    //
                    //  This is an old VRID. Its priority should not need to be changed.
                    //
                    DWORD Offset, OldSize;

                    if(BitVector & MSDP_INTF_IPADDR_MASK) {
                        if ( ((PVrouter->ConfigPriority != 255) && 
                              (FoundIpAddress(VRouterInfo->IPAddress[0]))
                             )
                             ||
                             ((PVrouter->ConfigPriority == 255) && 
                              (!FoundIpAddress(VRouterInfo->IPAddress[0])))
                             ) {
                            DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE);
                            Error = ERROR_INVALID_PARAMETER;
                            break;                        
                        }
                        //
                        // Add this IP address to the VRID specified.
                        //
                        if (NewPeerInfo == NULL){
                            NewPeerInfo = MALLOC((OldSize = GetMsdpPeerInfoSize(
                                                        OldPeerInfo))+
                                                        sizeof(DWORD));
                            if (!NewPeerInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        //
                        // Shift all the VROUTER configs after the PVrouter by 1 DWORD.
                        //
                        Offset = (PUCHAR) MSDP_NEXT_VROUTER_CONFIG(PVrouter) - 
                                 (PUCHAR) OldPeerInfo;
                        CopyMemory(NewPeerInfo, OldPeerInfo, OldSize);
                        for (i = 0, PVrouter = MSDP_FIRST_VROUTER_CONFIG(NewPeerInfo);
                             i < NewPeerInfo->VrouterCount; 
                             i++, PVrouter = MSDP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewPeerInfo->VrouterCount);
                        PVrouter->IPAddress[PVrouter->IPCount++] = VRouterInfo->IPAddress[0];
    
                        ASSERT(((PUCHAR)NewPeerInfo+Offset+sizeof(DWORD)) == 
                               (PUCHAR) MSDP_NEXT_VROUTER_CONFIG(PVrouter));
    
                        CopyMemory(MSDP_NEXT_VROUTER_CONFIG(PVrouter), 
                                   OldPeerInfo+Offset, OldSize-Offset);
                    } else {
                        //
                        // Set the new info block as the old info block and point to the
                        // vrouter block
                        //
                        if (NewPeerInfo == NULL){
                            NewPeerInfo = MALLOC((OldSize = GetMsdpPeerInfoSize(
                                                        OldPeerInfo)));
                            if (!NewPeerInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        CopyMemory(NewPeerInfo, OldPeerInfo, OldSize);
                        for (i = 0, PVrouter = MSDP_FIRST_VROUTER_CONFIG(NewPeerInfo);
                             i < NewPeerInfo->VrouterCount; 
                             i++, PVrouter = MSDP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewPeerInfo->VrouterCount);
                    }

                    if (BitVector & MSDP_INTF_AUTH_MASK) {
                        PVrouter->AuthenticationType = VRouterInfo->AuthenticationType;
                    }
                    if (BitVector & MSDP_INTF_PASSWD_MASK) {
                        CopyMemory(PVrouter->AuthenticationData, 
                                   VRouterInfo->AuthenticationData, 
                                   MSDP_MAX_AUTHKEY_SIZE);
                    }
                    if (BitVector & MSDP_INTF_ADVT_MASK) {
                        PVrouter->AdvertisementPeer= VRouterInfo->AdvertisementPeer
                    }
                    if (BitVector & MSDP_INTF_PRIO_MASK) {
                        PVrouter->ConfigPriority = VRouterInfo->ConfigPriority;
                    }
                    if (BitVector & MSDP_INTF_PREEMPT_MASK) {
                        PVrouter->PreemptMode = VRouterInfo->PreemptMode;
                    }
                }
            }
        }

        ValidateMsdpPeerInfo(NewPeerInfo);

        Error =
            SetInfoBlockInPeerInfo(
                PeerName,
                MS_IP_MSDP,
                (PUCHAR)NewPeerInfo,
                GetMsdpPeerInfoSize(NewPeerInfo),
                1
                );
    } while(FALSE);
    if (NewPeerInfo) { FREE(NewPeerInfo); }
    if (OldPeerInfo) { FREE(OldPeerInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}
#endif

#if 0
DWORD
MsdpDeleteIPv4PeerConfig(
    IPV4_ADDRESS ipAddr
    )
/*++
Called by: HandleMsdpDeletePeer()
--*/
{
    DWORD                  dwErr   = NO_ERROR;
    ULONG                  ulV4PeerCount;

    PMSDP_IPV4_PEER_CONFIG NewPeerInfo = NULL;
    PMSDP_IPV4_PEER_CONFIG OldPeerInfo = NULL;
    ULONG Size;
    ULONG i;

    do {
        dwErr = GetMsdpGlobalConfig(&pGlobal);
        if (dwErr isnot NO_ERROR) {
            break;
        }

        pFamily = MSDP_FIRST_FAMILY(pGlobal);
        for (i=0; (i < pFamily->usNumPeers) 
               && (pFamily->pPeer[i].ipRemoteAddress isnot ipAddr); i++);
        if (i is pFamily->usNumPeers)
        {
            return ERROR_NOT_FOUND;        
        }

        // Shift every after 'i' up one position (overlapping copy)
        i++;
        memcpy( &pFamily->pPeer[i-1], 
                &pFamily->pPeer[i],
                (pFamily->usNumPeers-i) * sizeof(MSDP_IPV4_PEER_CONFIG) );

        pFamily->usNumPeers--;

        dwErr = SetMsdpGlobalConfig( pGlobal );
    } while (FALSE);

    if (pGlobal)
    {
        FREE(pGlobal);
    }

    return dwErr;
}
#endif

ULONG
ValidateMsdpPeerInfo(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    )
{
    return NO_ERROR;
}

#if 0
DWORD
GetMsdpPeerInfoSize(
    PMSDP_IPV4_PEER_CONFIG PeerInfo
    )
{
    DWORD Size = 0;
    ULONG i;
    PMSDP_VROUTER_CONFIG pvr;

    Size += sizeof(PeerInfo->VrouterCount);

    for (i = 0, pvr = MSDP_FIRST_VROUTER_CONFIG(PeerInfo);
         i < PeerInfo->VrouterCount;
         i++,pvr = MSDP_NEXT_VROUTER_CONFIG(pvr)) {
        Size += MSDP_VROUTER_CONFIG_SIZE(pvr);
    }

    return Size;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdpmib.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\protocols\msdpmib.c    

Abstract:

     Functions to get and display MSDP MIB information.

Author:

     Dave Thaler   11/03/99

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop

#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

ULONG
QueryTagArray(
    PTCHAR ArgumentArray[],
    ULONG ArgumentCount,
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount,
    OUT PULONG* TagArray
    );

//
// Flag for printing header
//
BOOL    g_bMsdpFirst = TRUE;
HANDLE  g_hConsole, g_hStdOut;

// This can have the other fields pfn etc
MIB_OBJECT_PARSER   MsdpMIBObjectMap[] =
{
    {TOKEN_MSDP_MIB_OBJECT_GLOBALSTATS,0,0,NULL},
    {TOKEN_MSDP_MIB_OBJECT_PEERSTATS,  1,1,GetMsdpMIBIpAddress},
    {TOKEN_MSDP_MIB_OBJECT_SA,         0,2,GetMsdpMIBSAIndex},
};
#define MAX_MSDP_MIB_OBJECTS (sizeof(MsdpMIBObjectMap)/sizeof(MIB_OBJECT_PARSER))

MSDP_MAGIC_TABLE    MsdpMIBVar[] = {
    {MIBID_MSDP_GLOBAL,            PrintMsdpGlobalStats, 0},
    {MIBID_MSDP_IPV4_PEER_ENTRY,   PrintMsdpPeerStats,   4},
    {MIBID_MSDP_SA_CACHE_ENTRY,    PrintMsdpSA,          8},
};

DWORD
GetMsdpMIBIpAddress(
    IN    LPCWSTR *ppwcArguments,
    IN    ULONG    ulArgumentIndex,
    IN    ULONG    ulArgumentCount,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
/*++

Routine Description:

    Gets the index IP address for peer Mib variable.

Arguments:

    ppwcArguments  - Argument array
    ulArgumentIndex - Index of the first argument in array
    pdwIndices     - Indices specified in command
    pdwNumParsed   - Number of indices in command
    
Return Value:

    NO_ERROR
    
--*/
{
    DWORD    dwErr;
    ULONG    i;
    PULONG   pulTagArray;
    ULONG    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_REMADDR, FALSE, FALSE }
                              };

    *pdwNumParsed = 0;

    if (ulArgumentsLeft < 1) 
    {
        return NO_ERROR;
    }

    dwErr = QueryTagArray( &ppwcArguments[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );

    if (dwErr is NO_ERROR) {
        for (i=0; i<ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // remaddr
                    pdwIndices[0] = GetIpAddress(ppwcArguments[i+
                                     ulArgumentIndex]);
                    (*pdwNumParsed)++;
                    break;
                }
            }
        }
    } else {
        dwErr = ERROR_SHOW_USAGE;
    }

    if (pulTagArray) { FREE(pulTagArray); }
    return dwErr;
}

DWORD
GetMsdpMIBSAIndex(
    IN    LPCWSTR *ppwcArguments,
    IN    ULONG    ulArgumentIndex,
    IN    ULONG    ulArgumentCount,
    OUT   PDWORD   pdwIndices,
    OUT   PDWORD   pdwNumParsed 
    )
{
    DWORD    dwErr;
    ULONG    i;
    ULONG    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;
    PULONG   pulTagArray;
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_GROUPADDR, FALSE, FALSE },
                                { TOKEN_OPT_SOURCEADDR, FALSE, FALSE },
                              };

    *pdwNumParsed = 0;

    if (ulArgumentsLeft < 1) 
    {
        return NO_ERROR;
    }

    dwErr = QueryTagArray( &ppwcArguments[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );

    if (dwErr is NO_ERROR) {
        for (i=0; i<ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // grpaddr
                    pdwIndices[0] = GetIpAddress(ppwcArguments[i+
                                     ulArgumentIndex]);
                    (*pdwNumParsed)++;
                    break;
                }
                case 1: { // srcaddr
                    pdwIndices[1] = GetIpAddress(ppwcArguments[i+
                                     ulArgumentIndex]);
                    (*pdwNumParsed)++;
                    break;
                }
            }
        }
    }

    if (pulTagArray) { FREE(pulTagArray); }
    return dwErr;
}

PWCHAR
GetTceStateString(
    DWORD     dwState
    )
{
    PWCHAR        pwszStr;
    static WCHAR  buff[80];
    VALUE_STRING  ppsList[] = {{MSDP_STATE_IDLE,        STRING_IDLE},
                               {MSDP_STATE_CONNECT,     STRING_CONNECT},
                               {MSDP_STATE_ACTIVE,      STRING_ACTIVE},
                               {MSDP_STATE_OPENSENT,    STRING_OPENSENT},
                               {MSDP_STATE_OPENCONFIRM, STRING_OPENCONFIRM},
                               {MSDP_STATE_ESTABLISHED, STRING_ESTABLISHED},
                              };
    DWORD         dwNum = sizeof(ppsList)/sizeof(VALUE_STRING), i;
    DWORD         dwMsgId = 0;

    for (i=0; i<dwNum; i++)
    {
        if (dwState is ppsList[i].dwValue)
        {
            dwMsgId = ppsList[i].dwStringId;
            break;
        }
    }

    if (dwMsgId)
    {
        pwszStr = MakeString( g_hModule, dwMsgId);
        wcscpy(buff, pwszStr);
        FreeString(pwszStr);
    }
    else
    {
        wsprintf(buff, L"%d", dwState);
    }

    return buff;
}

DWORD
HandleMsdpMibShowObject(
    PWCHAR    pwszMachine,
    PWCHAR    *ppwcArguments,
    DWORD     dwCurrentIndex,
    DWORD     dwArgCount,
    DWORD     dwFlags,
    MIB_SERVER_HANDLE hMibServer,
    BOOL      *pbDone
    )
/*++

Routine Description:

    Parses command to get MIB object and optional parameters

Arguments:

Return Value:

--*/
{
    DWORD                dwIndices[MAX_NUM_INDICES];
    DWORD                dwNumParsed = 0;
    MIB_OPAQUE_QUERY     rgQueryBuff[2];
    PMIB_OPAQUE_QUERY    pQuery = rgQueryBuff;
    PMIB_OPAQUE_INFO     pRpcInfo;
    DWORD                dwQuerySize;
    BOOL                 bFound = FALSE,bOptPresent = FALSE;
    DWORD                dwRefreshRate;
    DWORD                dwOutEntrySize;
    DWORD                i,dwResult,dwErr;
    DWORD                dwMIBIndex, dwIndex;
    BOOL                 bIndex = FALSE, dwType;
    DWORD                dwRR = 0, dwInd = 0;
    HANDLE               hMib;
    DWORD                dwDisplayInfoId, dwDisplayInfoType, dwOptVar;
    DWORD                dwOutSize;

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    //
    // Match MIB object
    //

    g_hMibServer = hMibServer;

    ppwcArguments += (dwCurrentIndex-1);
    dwArgCount    -= (dwCurrentIndex-1);
    dwCurrentIndex = 1;

    DEBUG1("In MSDP MIB Show : %s\n",ppwcArguments[0]);

    for (i = 0; i < MAX_MSDP_MIB_OBJECTS; i++)
    {
        if (MatchToken(ppwcArguments[0],MsdpMIBObjectMap[i].pwszMIBObj))
        {
            dwIndex = i;
            bFound = TRUE;
        
            DEBUG("found");
            
            break;
        }
    
    }
    
    if (!bFound)
    {
        return ERROR_CMD_NOT_FOUND;
    }

#if 0
    if ((dwArgCount > 1) && IsHelpToken(ppwcArguments[1]))
    {
        DisplayMessage(g_hModule,
                       MsdpMIBObjectMap[i].dwCmdHelpToken,
                       MsdpMIBObjectMap[i].pwszMIBObj);
        return NO_ERROR;
    }
#endif

    if (MsdpMIBObjectMap[dwIndex].pfnMIBObjParser)
    {
        dwErr = (*MsdpMIBObjectMap[dwIndex].pfnMIBObjParser)(ppwcArguments,
                                                             1 + dwInd,
                                                             dwArgCount,
                                                             dwIndices,
                                                             &dwNumParsed);
    
        if (dwErr isnot NO_ERROR) 
        {
            return dwErr;
        }
    }

    //
    // Convert refresh rate to msec
    //
    
    dwRR *= 1000;
    
    dwMIBIndex = dwIndex;
    
    pQuery->dwVarId = MsdpMIBVar[dwMIBIndex].dwId;

    if (!InitializeConsole(&dwRR, &hMib, &g_hConsole))
    {
        return ERROR_INIT_DISPLAY;
    }

    for ( ; ; )
    {
        if(dwRR)
        {
            DisplayMessageToConsole(g_hModule, g_hConsole, MSG_CTRL_C_TO_QUIT);
        }

        // See if we just need to do a GET
        if (dwNumParsed is MsdpMIBObjectMap[dwIndex].dwNumArgs) 
        {
            pQuery->rgdwVarIndex[0] = 0;
            for (i=0; i<MsdpMIBObjectMap[dwIndex].dwNumArgs; i++)
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
            
            dwResult = MprAdminMIBEntryGet(hMibServer,
                                           PID_IP,
                                           MS_IP_MSDP,
                                           (LPVOID) pQuery,
                                           sizeof(MIB_OPAQUE_QUERY)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                           (LPVOID *) &pRpcInfo,
                                           &dwOutSize );
    
            if (( dwResult isnot NO_ERROR ) and (dwResult isnot ERROR_NOT_FOUND))
            {
                DisplayMessageToConsole( g_hModule, g_hConsole, MSG_IP_DIM_ERROR, dwResult );
                break;
            }
    
            if ( pRpcInfo is NULL )
            {
                break;
            }

            (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_VERBOSE);
    
            MprAdminMIBBufferFree( (PVOID) pRpcInfo );
        }
        else if (dwNumParsed is 0)
        {
            // Display All
            g_bMsdpFirst = TRUE;
    
            dwResult = MprAdminMIBEntryGetFirst(hMibServer,
                                                PID_IP,
                                                MS_IP_MSDP,
                                                (LPVOID) pQuery,
                                                sizeof(MIB_OPAQUE_INFO)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                                (LPVOID *) &pRpcInfo,
                                                &dwOutSize );
    
            if (( dwResult isnot NO_ERROR ) and (dwResult isnot ERROR_NO_MORE_ITEMS))
            {
                DisplayMessageToConsole( g_hModule, g_hConsole, MSG_IP_DIM_ERROR, dwResult );
                break;
            }
    
            if ( pRpcInfo is NULL )
            {
                DisplayMessageToConsole( g_hModule, g_hConsole, MSG_IP_NO_ENTRIES );
                break;
            }

            (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_TABLE);

            g_bMsdpFirst = FALSE;

            do
            {
                // pQuery->rgdwVarIndex[0] = pRpcInfo->IMGOD_IfIndex;

                //
                // prepare for next request
                //

                CopyMemory(pQuery->rgdwVarIndex, pRpcInfo->rgbyData, 
                           MsdpMIBVar[dwMIBIndex].ulIndexBytes );
            
                MprAdminMIBBufferFree( (PVOID) pRpcInfo );
                pRpcInfo = NULL;
    
                DEBUG2("calling next with index %d", pQuery->rgdwVarIndex[0]);

                dwResult = MprAdminMIBEntryGetNext(hMibServer,
                                                   PID_IP,
                                                   MS_IP_MSDP,
                                                   (LPVOID) pQuery,
                                                   sizeof(MIB_OPAQUE_QUERY)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                                   (LPVOID *) &pRpcInfo,
                                                   &dwOutSize );
        
                if (dwResult is ERROR_NO_MORE_ITEMS)
                {
                    g_bMsdpFirst = TRUE;
                    return dwResult;
                }


                if ( dwResult isnot NO_ERROR )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
    
                if ( pRpcInfo is NULL )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }

                if (pQuery->dwVarId isnot pRpcInfo->dwId)
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
        
                (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_TABLE);
        
            } while (1);
        } 
        else 
        {
            // partially-specified index
    
            g_bMsdpFirst = TRUE;

            pQuery->rgdwVarIndex[0] = 0;
            for (i=0; i<dwNumParsed; i++)
            {
                pQuery->rgdwVarIndex[i] = dwIndices[i];
            }
            for (; i<MsdpMIBObjectMap[dwIndex].dwNumArgs; i++)
            {
                pQuery->rgdwVarIndex[i] = 0;
            }

            do
            {
                dwResult = MprAdminMIBEntryGetNext(hMibServer,
                                                   PID_IP,
                                                   MS_IP_MSDP,
                                                   (LPVOID) pQuery,
                                                   sizeof(MIB_OPAQUE_QUERY)
                            + MsdpMIBVar[dwMIBIndex].ulIndexBytes-sizeof(DWORD),
                                                   (LPVOID *) &pRpcInfo,
                                                   &dwOutSize );

                if (dwResult is NO_ERROR)
                {
                    // See if we've gone too far
                    for (i=0; i<dwNumParsed; i++) 
                    {
                        // All index fields are DWORDs
                        if (memcmp(pQuery->rgdwVarIndex, pRpcInfo->rgbyData,
                                   dwNumParsed * sizeof(DWORD)))
                        {
                            dwResult = ERROR_NO_MORE_ITEMS;
                            break;
                        }
                    }
                }
        
                if (dwResult is ERROR_NO_MORE_ITEMS)
                {
                    g_bMsdpFirst = TRUE;
                    return dwResult;
                }


                if ( dwResult isnot NO_ERROR )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
    
                if ( pRpcInfo is NULL )
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }

                if (pQuery->dwVarId isnot pRpcInfo->dwId)
                {
                    g_bMsdpFirst = TRUE;
                    break;
                }
        
                (*MsdpMIBVar[dwMIBIndex].pfnPrintFunction)(pRpcInfo, FORMAT_TABLE);

                //
                // prepare for next request
                //

                CopyMemory(pQuery->rgdwVarIndex, pRpcInfo->rgbyData, 
                           MsdpMIBVar[dwMIBIndex].ulIndexBytes );

                MprAdminMIBBufferFree( (PVOID) pRpcInfo );
                pRpcInfo = NULL;
                g_bMsdpFirst = FALSE;
        
            } while (1);
        }

        if (!RefreshConsole(hMib, g_hConsole, dwRR))
        {
            break;
        }
    }

    return dwResult;
}
    
VOID 
PrintMsdpGlobalStats(
    PMIB_OPAQUE_INFO pRpcInfo,
    DWORD            dwFormat
    )
/*++

Routine Description:

    Prints msdp global statistics

Arguments:

Return Value:

--*/
{
    WCHAR wszRouterId[20];

    PMSDP_GLOBAL_ENTRY pEntry = (PMSDP_GLOBAL_ENTRY)(pRpcInfo->rgbyData);
    
    IP_TO_TSTR(wszRouterId, &pEntry->dwRouterId);

    DisplayMessageToConsole(g_hModule,g_hConsole,MSG_MSDP_GLOBAL_STATS,
                      pEntry->ulNumSACacheEntries,
                      wszRouterId);
}

VOID 
PrintMsdpSA(
    PMIB_OPAQUE_INFO pRpcInfo,
    DWORD            dwFormat
    )
{
    PMSDP_SA_CACHE_ENTRY psa;
    WCHAR wszGroupAddress[20];
    WCHAR wszSourceAddress[20];
    WCHAR wszOriginAddress[20];
    WCHAR wszLearnedFromAddress[20];
    WCHAR wszRPFPeerAddress[20];
    DWORD dwId = (dwFormat is FORMAT_TABLE)? MSG_MSDP_SA_INFO :
                                             MSG_MSDP_SA_INFO_EX;

    if (g_bMsdpFirst && (dwFormat is FORMAT_TABLE))
    {
        DisplayMessageToConsole(g_hModule,g_hConsole,MSG_MSDP_SA_INFO_HEADER);
    }

    psa = (PMSDP_SA_CACHE_ENTRY)(pRpcInfo->rgbyData);

    IP_TO_TSTR(wszGroupAddress,       &psa->ipGroupAddr);
    IP_TO_TSTR(wszSourceAddress,      &psa->ipSourceAddr);
    IP_TO_TSTR(wszOriginAddress,      &psa->ipOriginRP);
    IP_TO_TSTR(wszLearnedFromAddress, &psa->ipPeerLearnedFrom);
    IP_TO_TSTR(wszRPFPeerAddress,     &psa->ipRPFPeer);

    DisplayMessageToConsole(g_hModule, g_hConsole, 
                      dwId,
                      wszGroupAddress,
                      wszSourceAddress,
                      wszOriginAddress,
                      wszLearnedFromAddress,
                      wszRPFPeerAddress,
                      psa->ulInSAs,
                      psa->ulUpTime/100,
                      psa->ulExpiryTime/100);
}

VOID 
PrintMsdpPeerStats(
    PMIB_OPAQUE_INFO pRpcInfo,
    DWORD            dwFormat
    )
/*++

Routine Description:

    Prints msdp neighbor stats

Arguments:

Return Value:

--*/
{
    PMSDP_IPV4_PEER_ENTRY pPeer;
    WCHAR wszAddr[ADDR_LENGTH + 1];

    if (g_bMsdpFirst && (dwFormat is FORMAT_TABLE))
    {
        DisplayMessageToConsole(g_hModule,g_hConsole,MSG_MSDP_PEER_STATS_HEADER);
    }

    pPeer = (PMSDP_IPV4_PEER_ENTRY)(pRpcInfo->rgbyData);

    MakeUnicodeIpAddr(wszAddr, inet_ntoa(*((struct in_addr *)
                                           (&pPeer->ipRemoteAddress))));

    DisplayMessageToConsole(g_hModule, g_hConsole, 
                      (dwFormat is FORMAT_TABLE)? MSG_MSDP_PEER_STATS
                                                : MSG_MSDP_PEER_STATS_EX, 
                      wszAddr,
                      GetTceStateString(pPeer->dwState),
                      pPeer->ulRPFFailures,
                      pPeer->ulInSAs,
                      pPeer->ulOutSAs,
                      pPeer->ulInSARequests,
                      pPeer->ulOutSARequests,
                      pPeer->ulInSAResponses,
                      pPeer->ulOutSAResponses,
                      pPeer->ulInControlMessages,
                      pPeer->ulOutControlMessages,
                      pPeer->ulFsmEstablishedTransitions,
                      pPeer->ulFsmEstablishedTime,
                      pPeer->ulInMessageElapsedTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdpmib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:
     net\routing\netsh\ip\protocols\msdpmib.h   

Abstract:

    Include for msdpmib.c

Author:

     Dave Thaler        11/03/99

Revision History:


--*/

#ifndef _MSDPMIB_H_
#define _MSDPMIB_H_

DWORD
GetMsdpMIBIfIndex(
    IN OUT LPWSTR  *pptcArguments,
    IN     DWORD    dwCurrentIndex,
    OUT    PDWORD   pdwIndices,
    OUT    PDWORD   pdwNumParsed 
);

DWORD
GetMsdpMIBIpAddress(
    IN OUT LPWSTR  *pptcArguments,
    IN     DWORD    dwCurrentIndex,
    IN     DWORD    dwArgCount,
    OUT    PDWORD   pdwIndices,
    OUT    PDWORD   pdwNumParsed 
);

DWORD
GetMsdpMIBSAIndex(
    IN OUT  LPWSTR  *ppwcArguments,
    IN      DWORD    dwCurrentIndex,
    IN      DWORD    dwArgCount,
    OUT     PDWORD   pdwIndices,
    OUT     PDWORD   pdwNumParsed
    );

typedef
VOID
(MSDP_PRINT_FN)(
    PMIB_OPAQUE_INFO pgodInfo,
    DWORD            dwFormat
    );

typedef MSDP_PRINT_FN *PMSDP_PRINT_FN;

MSDP_PRINT_FN PrintMsdpGlobalStats;
MSDP_PRINT_FN PrintMsdpPeerStats;
MSDP_PRINT_FN PrintMsdpSA;

typedef struct _MSDP_MAGIC_TABLE
{
    DWORD           dwId;
    PMSDP_PRINT_FN  pfnPrintFunction;
    ULONG           ulIndexBytes;
}MSDP_MAGIC_TABLE, *PMSDP_MAGIC_TABLE;

FN_HANDLE_CMD HandleMsdpMibShowObject;

#endif //_MSDPMIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdpopt.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrpopt.h

Abstract:

    MSDP Command dispatcher declarations

Author:

    Dave Thaler (dthaler)   21-May-1999

Revision History:

--*/


#ifndef _NETSH_MSDPOPT_H_
#define _NETSH_MSDPOPT_H_

FN_HANDLE_CMD HandleMsdpAddPeer;
FN_HANDLE_CMD HandleMsdpDeletePeer;
FN_HANDLE_CMD HandleMsdpSetPeer;
FN_HANDLE_CMD HandleMsdpShowPeer;
FN_HANDLE_CMD HandleMsdpSetGlobal;
FN_HANDLE_CMD HandleMsdpShowGlobal;
FN_HANDLE_CMD HandleMsdpInstall;
FN_HANDLE_CMD HandleMsdpUninstall;

#endif // _NETSH_MSDPOPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <tchar.h>
#include <winsock2.h>

#include <fltdefs.h>
#include <rtutils.h>
#include <mprerror.h>
#include <routprot.h>
#include <ipinfoid.h>
#include <iprtrmib.h>
#include <rtinfo.h>
#include <iprtinfo.h>
#include <priopriv.h>
#include <ipriprm.h>
#include <ipbootp.h>
#include <ospf_cfg.h>
#include <mprapi.h>
#include <ipinfoid.h>
#include <igmprm.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <snmp.h>

#include <macros.h>
#include <netsh.h>
#include <ipmontr.h>
#include <vrrprm.h>
#include <iphlpapi.h>

#include "ipprodefs.h"
#include "common.h"
#include "utils.h"
#include "strdefs.h"
#include "prstring.h"
#include "vrrphlp.h"
#include "vrrphlpcfg.h"
#include "vrrphlpopt.h"

#include "msdprm.h"
#include "msdp.h"
#include "msdpopt.h"
#include "msdpcfg.h"
#include "msdpmib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\msdpopt.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\msdpopt.c

Abstract:

    MSDP command options implementation.
    This module contains handlers for the configuration commands
    supported by the MSDP Protocol.

Author:

    Dave Thaler (dthaler)   21-May-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipcmp.h>

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x)   HeapFree(GetProcessHeap(), 0, (x))

//
// Forward declarations
//

ULONG
QueryTagArray(
    IN  PTCHAR   ppwszArgumentArray[],
    IN  ULONG    ululArgumentCount,
    IN  TAG_TYPE pttTagTypeArray[],
    IN  ULONG    ulTagTypeCount,
    OUT PULONG*  ppulTagArray
    );

ULONG
ValidateTagTypeArray(
    IN  TAG_TYPE pttTagTypeArray[],
    IN  ULONG    ulTagTypeCount
    );


DWORD
HandleMsdpAddPeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG    ulArgumentsLeft;
    ULONG    BitVector;
    DWORD    dwErr;
    ULONG    ulErrorIndex = 0;
    ULONG    i;
    PULONG   pulTagArray;
    ULONG    InfoSize;
    DWORD    dwBufferSize = MAX_INTERFACE_NAME_LEN + 1;
    WCHAR    wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_NAME,         NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_REMADDR,      NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_LOCALADDR,    NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_KEEPALIVE,    NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CONNECTRETRY, NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CACHING,      NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_DEFAULTPEER,  NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_ENCAPSMETHOD, NS_REQ_ZERO, FALSE },
                              };
    PMSDP_IPV4_PEER_CONFIG pPeer = NULL;

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex >= ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    BitVector = 0;

    do {
        dwErr = MakeMsdpIPv4PeerConfig(&pPeer);
        if (dwErr isnot NO_ERROR) 
        {
            break;
        }

        //
        // We now scan the argument list, converting the arguments
        // into information in our 'VrouterGiven' structure.
        //

        for (i = 0; i < ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // name
                    wcscpy(wszInterfaceName, ArgumentArray[i+ulArgumentIndex]);
                    break;
                }
                case 1: { // remaddr
                    pPeer->ipRemoteAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 2: { // localaddr
                    pPeer->ipLocalAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 3: { // keepalive
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        pPeer->ulKeepAlive = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_KEEPALIVE;
                    }
                    break;
                }
                case 4: { // connectretry
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        pPeer->ulConnectRetry = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    }
                    break;
                }
                case 5: { // caching
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    pPeer->dwConfigFlags &= ~MSDP_PEER_CONFIG_CACHING;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_CACHING;
                    }
                    break;
                }
                case 6: { // defaultpeer
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    pPeer->dwConfigFlags &= ~MSDP_PEER_CONFIG_DEFAULTPEER;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_DEFAULTPEER;
                    }
                    break;
                }
                case 7: { // encapsulation
                    DWORD dwValue;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          MSDP_ENCAPS_SIZE,
                                          (PTOKEN_VALUE)MsdpEncapsTokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    pPeer->dwEncapsMethod = dwValue;
                    break;
                }
            }
        }

        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // higher IP is passive.  Setting this bit has no effect
        // except on the "show peer" report when the router isn't running.
        if (ntohl(pPeer->ipLocalAddress) > ntohl(pPeer->ipRemoteAddress))
        {
            pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_PASSIVE;
        }
    
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        dwErr = MsdpAddIPv4PeerInterface(pwszMachineName,
                                         wszInterfaceName, pPeer );
    } while (FALSE);

    if (pPeer)
    {
        FREE(pPeer);
    }

    if (pulTagArray)
    {
        FREE(pulTagArray);
    }
    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}


DWORD
HandleMsdpDeletePeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG  ulArgumentsLeft;
    ULONG  BitVector;
    DWORD  dwErr;
    ULONG  ulErrorIndex = 0;
    ULONG  i;
    PULONG pulTagArray;
    ULONG  InfoSize;
    WCHAR  wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD  dwBufferSize = sizeof(wszInterfaceName);

    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_NAME, NS_REQ_PRESENT, FALSE }
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex >= ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    BitVector = 0;

    for (i = 0; i < ulArgumentsLeft; i++) {
        switch(pulTagArray ? pulTagArray[i] : i) {
            case 0: { // name
                IpmontrGetIfNameFromFriendlyName(
                                         ArgumentArray[i + ulArgumentIndex],
                                         wszInterfaceName,
                                         &dwBufferSize);
                break;
            }
        }
    }

    dwErr = IpmontrDeleteInterface( pwszMachineName, wszInterfaceName );
    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }
    
    return dwErr;
}

DWORD
HandleMsdpInstall(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    DWORD  dwErr = ERROR_OKAY;
    PUCHAR pGlobalInfo;
    ULONG  ulLength;

    if (ulArgumentIndex != ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }

    //
    // To install MSDP, we construct the default configuration
    // and add it to the global configuration for the router.
    //
    dwErr = MakeMsdpGlobalConfig(&pGlobalInfo, &ulLength);
    if (dwErr isnot NO_ERROR) {
        DisplayError(g_hModule, dwErr);
    } else {
        dwErr = IpmontrSetInfoBlockInGlobalInfo( MS_IP_MSDP,
                                          pGlobalInfo,
                                          ulLength,
                                          1 );
        FREE(pGlobalInfo);
        if (dwErr is NO_ERROR) {
            dwErr = ERROR_OKAY;
        } else {
            DisplayError(g_hModule, dwErr);
        }
    }

    return dwErr;
}

DWORD
HandleMsdpSetGlobal(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    ULONG   ulArgumentIndex,
    ULONG   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG               ulArgumentsLeft;
    DWORD               dwErr;
    PULONG              pulTagArray = NULL;
    DWORD               dwLoggingLevel, dwAcceptAll;
    ULONG               i, ulTemp;
    ULONG               ulErrorIndex;
    PMSDP_GLOBAL_CONFIG pGlobalInfo = NULL;
    
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_LOGGINGLEVEL, FALSE, FALSE },
                                { TOKEN_OPT_KEEPALIVE,    FALSE, FALSE },
                                { TOKEN_OPT_SAHOLDDOWN,   FALSE, FALSE },
                                { TOKEN_OPT_CONNECTRETRY, FALSE, FALSE },
                                { TOKEN_OPT_ACCEPTALL,    FALSE, FALSE },
                                { TOKEN_OPT_CACHELIFETIME,FALSE, FALSE },
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");
    
    if (ulArgumentIndex >= ulArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide us in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    do {
        dwErr = GetMsdpGlobalConfig( &pGlobalInfo );
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        for (i = 0; i < ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // loglevel
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NONE,  MSDP_LOGGING_NONE },
                        { TOKEN_OPT_VALUE_ERROR, MSDP_LOGGING_ERROR },
                        { TOKEN_OPT_VALUE_WARN,  MSDP_LOGGING_WARN },
                        { TOKEN_OPT_VALUE_INFO,  MSDP_LOGGING_INFO }
                    };
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &pGlobalInfo->dwLoggingLevel );
                    if (dwErr) {
                        dwErr = ERROR_INVALID_PARAMETER;
                        ulErrorIndex = i;
                        i = ulArgumentsLeft;
                        break;
                    }                                
                    
                    TagTypeArray[pulTagArray ? pulTagArray[i] : i].bPresent = TRUE;
                    break;
                }
                case 1: { // keepalive
                    pGlobalInfo->ulDefKeepAlive = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                    break;
                }
                case 2: { // SA holddown
                    pGlobalInfo->ulSAHolddown = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                    break;
                }
                case 3: { // connectretry
                    pGlobalInfo->ulDefConnectRetry = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                    break;
                }
                case 4: { // acceptall
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_DISABLE, FALSE },
                        { TOKEN_OPT_VALUE_ENABLE,  TRUE }
                    };
                    pGlobalInfo->dwFlags &= ~MSDP_GLOBAL_FLAG_ACCEPT_ALL;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwAcceptAll );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwAcceptAll is TRUE)
                    {
                        pGlobalInfo->dwFlags |= MSDP_GLOBAL_FLAG_ACCEPT_ALL;
                    }
                    break;
                }
                case 5: { // cachelifetime
                    ulTemp = _tcstoul( ArgumentArray[i + ulArgumentIndex],
                                       NULL, 10);

                    if ((ulTemp>0) and (ulTemp<MSDP_MIN_CACHE_LIFETIME))
                    {
                        DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE,
                                       ArgumentArray[i + ulArgumentIndex],
                                       TOKEN_OPT_CACHELIFETIME);
                        dwErr = ERROR_SUPPRESS_OUTPUT;
                        break;
                    }
                    pGlobalInfo->ulCacheLifetime = ulTemp;
                    break;
                }
            }
        }
        
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        dwErr = SetMsdpGlobalConfig(pGlobalInfo);

    } while (FALSE);

    if (pulTagArray)
    {
        FREE(pulTagArray);
    }
    if (pGlobalInfo) 
    { 
        FREE(pGlobalInfo); 
    }

    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }
    return dwErr;
}

DWORD
HandleMsdpSetPeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwCmdFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    IPV4_ADDRESS           ipLocalAddress, ipRemoteAddress;
    ULONG                  ulKeepAlive=0, ulSAPeriod=0, ulConnectRetry=0;
    DWORD                  dwEncapsMethod=0;
    DWORD                  dwErr = NO_ERROR;
    DWORD                  dwFlags = 0, dwFlagsMask = 0;
    ULONG                  ulArgumentsLeft;
    ULONG                  i;
    PMSDP_IPV4_PEER_CONFIG pPeer = NULL;
    PULONG                 pulTagArray;
    WCHAR                  wszInterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    DWORD                  dwBufferSize = sizeof(wszInterfaceName);
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_NAME,         NS_REQ_PRESENT,  FALSE },
                                { TOKEN_OPT_REMADDR,      NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_LOCALADDR,    NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_KEEPALIVE,    NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CONNECTRETRY, NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_CACHING,      NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_DEFAULTPEER,  NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_ENCAPSMETHOD, NS_REQ_ZERO, FALSE },
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex >= ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    do {
        for (i = 0; i < ulArgumentsLeft; i++) {
            switch(pulTagArray ? pulTagArray[i] : i) {
                case 0: { // name
                    IpmontrGetIfNameFromFriendlyName( 
                                             ArgumentArray[i + ulArgumentIndex],
                                             wszInterfaceName,
                                             &dwBufferSize);
                    break;
                }
                case 1: { // remaddr
                    ipRemoteAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 2: { // localaddr
                    ipLocalAddress = GetIpAddress(
                                          ArgumentArray[i + ulArgumentIndex]);
                    break;
                }
                case 3: { // keepalive
                    dwFlagsMask |= MSDP_PEER_CONFIG_KEEPALIVE;
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        ulKeepAlive = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        dwFlags     |= MSDP_PEER_CONFIG_KEEPALIVE;
                    }
                    break;
                }
                case 4: { // connectretry
                    dwFlagsMask |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    if (!MatchToken(ArgumentArray[i+ulArgumentIndex],
                                    TOKEN_OPT_VALUE_DEFAULT))
                    {
                        ulConnectRetry = _tcstoul(
                                          ArgumentArray[i + ulArgumentIndex],
                                          NULL, 10);
                        dwFlags     |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    }
                    break;
                }
                case 5: { // caching
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    dwFlagsMask |= MSDP_PEER_CONFIG_CONNECTRETRY;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        dwFlags |= MSDP_PEER_CONFIG_CACHING;
                    }
                    break;
                }
                case 6: { // defaultpeer
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NO,  FALSE },
                        { TOKEN_OPT_VALUE_YES, TRUE }
                    };
                    dwFlagsMask |= MSDP_PEER_CONFIG_DEFAULTPEER;
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    if (dwValue is TRUE)
                    {
                        dwFlags |= MSDP_PEER_CONFIG_DEFAULTPEER;
                    }
                    break;
                }
                case 7: { // encapsulation
                    DWORD dwValue;
                    TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_NONE, MSDP_ENCAPS_NONE },
                    };
                    dwErr = MatchEnumTag( g_hModule,
                                          ArgumentArray[i + ulArgumentIndex],
                                          NUM_TOKENS_IN_TABLE(TokenArray),
                                          TokenArray,
                                          &dwValue );
                    if (dwErr isnot NO_ERROR)
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    dwEncapsMethod = dwValue;
                    break;
                }
            }
        }

        if (dwErr isnot NO_ERROR)
        {
            break;
        }
        
        // Locate peer
        dwErr = GetMsdpInterfaceConfig(wszInterfaceName, &pPeer);
        if (dwErr isnot NO_ERROR)
        {
            break;
        }

        // Update fields
        if (TagTypeArray[1].bPresent)
        {
            pPeer->ipRemoteAddress = ipRemoteAddress;
        }
        if (TagTypeArray[2].bPresent)
        {
            pPeer->ipLocalAddress = ipLocalAddress;
        }
        if (TagTypeArray[3].bPresent)
        {
            pPeer->ulKeepAlive = ulKeepAlive;
        }
        if (TagTypeArray[4].bPresent)
        {
            pPeer->ulConnectRetry = ulConnectRetry;
        }
        if (TagTypeArray[5].bPresent)
        {
            pPeer->dwEncapsMethod = dwEncapsMethod;
        }
        pPeer->dwConfigFlags = (pPeer->dwConfigFlags & ~dwFlagsMask) | dwFlags;

        // higher IP is passive.  Setting bit has no effect except on
        // the "show peer" output when the router isn't running.
        if (ntohl(pPeer->ipLocalAddress) > ntohl(pPeer->ipRemoteAddress))
        {
            pPeer->dwConfigFlags |= MSDP_PEER_CONFIG_PASSIVE;
        }
        else
        {
            pPeer->dwConfigFlags &= ~MSDP_PEER_CONFIG_PASSIVE;
        }
    
        // Update the configuration with the new settings.
        dwErr = SetMsdpInterfaceConfig(wszInterfaceName, pPeer);
    } while (FALSE);

    if (pPeer)
    {
        FREE(pPeer);
    }

    if (pulTagArray)
    {
        FREE(pulTagArray);
    }

    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }

    return dwErr;
}

DWORD
HandleMsdpShowGlobal(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex != ulArgumentCount) { 
        return ERROR_SHOW_USAGE; 
    }

    ShowMsdpGlobalInfo(FORMAT_VERBOSE);

    return NO_ERROR;
}

DWORD
HandleMsdpShowPeer(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    ULONG    ulArgumentsLeft;
    DWORD    dwErr = NO_ERROR;
    PULONG   pulTagArray = NULL;
    TAG_TYPE TagTypeArray[] = { { TOKEN_OPT_REMADDR, NS_REQ_ZERO, FALSE },
                                { TOKEN_OPT_NAME,    NS_REQ_ZERO, FALSE },
                              };

    VERIFY_INSTALLED(MS_IP_MSDP, L"MSDP");

    if (ulArgumentIndex is ulArgumentCount)
    {
        return ShowMsdpPeerInfo(FORMAT_TABLE, NULL, NULL);
    }

    if (ulArgumentIndex > ulArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    ulArgumentsLeft = ulArgumentCount - ulArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags 
    // at all, in which case we assume that arguments are specified in 
    // exactly the order given in 'TagTypeArray' above.
    //

    dwErr = QueryTagArray( &ArgumentArray[ulArgumentIndex],
                           ulArgumentsLeft,
                           TagTypeArray,
                           NUM_TAGS_IN_TABLE(TagTypeArray),
                           &pulTagArray );
    if (dwErr) { return dwErr; }

    if (!pulTagArray) {
        dwErr = ShowMsdpPeerInfo(FORMAT_VERBOSE,NULL,NULL);
    } else if (pulTagArray[0] is 0) { // address
        dwErr = ShowMsdpPeerInfo(FORMAT_VERBOSE,
                                 ArgumentArray[ulArgumentIndex],
                                 NULL);
    } else if (pulTagArray[0] is 1) { // name
        dwErr = ShowMsdpPeerInfo(FORMAT_VERBOSE,
                                 NULL,
                                 ArgumentArray[ulArgumentIndex]);
    } else {
        dwErr = ERROR_SHOW_USAGE;
    }

    if (pulTagArray) { FREE(pulTagArray); }
    return dwErr;                
}

DWORD
HandleMsdpUninstall(
    PWCHAR  pwszMachineName,
    PTCHAR* ArgumentArray,
    DWORD   ulArgumentIndex,
    DWORD   ulArgumentCount,
    DWORD   dwFlags,
    PVOID   pvData,
    BOOL*   CommandDone
    )
{
    DWORD               dwErr, dwTotal;
    ULONG               ulNumInterfaces, i;
    PMPR_INTERFACE_0    pmi0 = NULL;

    if (ulArgumentIndex isnot ulArgumentCount) 
    { 
        return ERROR_SHOW_USAGE; 
    }

    // First delete all peers.  We need to do this ourselves since 
    // IpmontrDeleteProtocol won't delete the peer interfaces.

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                                 &ulNumInterfaces,
                                 &dwTotal);
    if (dwErr isnot NO_ERROR)
    {
        return dwErr;
    }

    for (i=0; i<ulNumInterfaces; i++)
    {
        dwErr = IpmontrDeleteInterface( pwszMachineName, 
                                        pmi0[i].wszInterfaceName );
    }

    if (pmi0)
    {
        FREE(pmi0);
    }

    dwErr = IpmontrDeleteProtocol(MS_IP_MSDP);
    if (dwErr is NO_ERROR)
    {
        dwErr = ERROR_OKAY;
    }
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\prstring.h ===
#define MSG_HELP_START L"%1!-14s! - "
#define MSG_NEWLINE _T("\n")


#define TOKEN_ROUTER                           _T("router")
#define TOKEN_MIB                              _T("mib")

    // tokens for commands
#define TOKEN_COMMAND_ADD                      _T("add")
#define TOKEN_COMMAND_DELETE                   _T("delete")
#define TOKEN_COMMAND_SET                      _T("set")
#define TOKEN_COMMAND_SHOW                     _T("show")
#define TOKEN_COMMAND_SHOW_HELPER              _T("show helper")
#define TOKEN_COMMAND_HELP                      _T("help")
#define TOKEN_COMMAND_INSTALL                  _T("install")
#define TOKEN_COMMAND_UNINSTALL                _T("uninstall")

#define TOKEN_COMMAND_HELP1                     _T("/?")
#define TOKEN_COMMAND_HELP2                     _T("-?")

    // Global option tokens used by multiple protocols
#define TOKEN_OPT_LOGGINGLEVEL                 L"loglevel"

    // MSDP options
#define TOKEN_OPT_KEEPALIVE                    L"keepalive"
#define TOKEN_OPT_SAHOLDDOWN                   L"saholddown"
#define TOKEN_OPT_CONNECTRETRY                 L"connectretry"
#define TOKEN_OPT_LOCALADDR                    L"localaddr"
#define TOKEN_OPT_REMADDR                      L"remoteaddr"
#define TOKEN_OPT_ACCEPTALL                    L"acceptall"
#define TOKEN_OPT_CACHELIFETIME                L"cachelifetime"
#define TOKEN_OPT_CACHING                      L"caching"
#define TOKEN_OPT_DEFAULTPEER                  L"defaultpeer"
#define TOKEN_OPT_GROUPADDR                    L"grpaddr"
#define TOKEN_OPT_SOURCEADDR                   L"srcaddr"
#define TOKEN_OPT_ENCAPSMETHOD                 L"encapsulation"

        // interface options
#define TOKEN_OPT_INTERFACE_NAME               _T("NAME")
#define TOKEN_OPT_INTERFACE_STATUS             _T("STATE")
#define TOKEN_OPT_DISCOVERY                    _T("DISC")
#define TOKEN_OPT_MIN_DISC_INTERVAL            _T("MININT")
#define TOKEN_OPT_MAX_DISC_INTERVAL            _T("MAXINT")
#define TOKEN_OPT_LIFETIME                     _T("LIFE")
#define TOKEN_OPT_LEVEL                        _T("LEVEL")
#define TOKEN_OPT_TTL                          _T("TTL")

        // protocol options
#define TOKEN_OPT_SERVER                       _T("SERVER")
#define TOKEN_OPT_LOG_LEVEL                    _T("LOGLEVEL")
#define TOKEN_OPT_AUTHENTICATION               _T("AUTH")
#define TOKEN_OPT_PASSWORD                     _T("PASSWORD")
#define TOKEN_OPT_PEER_MODE                    _T("PEERMODE")

            // VRRP Interface options
#define TOKEN_OPT_NAME                         _T("NAME=")
#define TOKEN_OPT_VRID                         _T("VRID=")
#define TOKEN_OPT_IPADDRESS                    _T("IPADDR=")
#define TOKEN_OPT_AUTH                         _T("AUTH=")
#define TOKEN_OPT_PASSWD                       _T("PASSWD=")
#define TOKEN_OPT_ADVTINTERVAL                 _T("ADVTINTERVAL=")
#define TOKEN_OPT_PRIO                         _T("PRIORITY=")
#define TOKEN_OPT_PREEMPT                      _T("PREEMPT=")
            
        // Route Options
#define TOKEN_OPT_NEXT_HOP                     _T("NEXTHOP=")

        // overloaded options
#define TOKEN_OPT_TYPE                         _T("TYPE")
#define TOKEN_OPT_METRIC                       _T("METRIC")
#define TOKEN_OPT_PROTOCOL                     _T("PROTO")
#define TOKEN_OPT_PREF_LEVEL                   _T("PREFLEVEL")

    // Miscellaneous options
#define TOKEN_OPT_INDEX                        _T("INDEX=")
#define TOKEN_OPT_HELP1                        _T("/?")
#define TOKEN_OPT_HELP2                        _T("-?")
#define TOKEN_OPT_GLOBAL                       _T("GLOBAL")


    // Option values
        // Interface types
#define TOKEN_OPT_VALUE_LAN                    _T("LAN")
#define TOKEN_OPT_VALUE_WAN                    _T("WAN")

        // Router types
#define TOKEN_OPT_VALUE_CLIENT                 _T("CLIENT")
#define TOKEN_OPT_VALUE_HOME                   _T("HOME")
#define TOKEN_OPT_VALUE_FULL                   _T("FULL")
#define TOKEN_OPT_VALUE_DEDICATED              _T("DEDICATED")
#define TOKEN_OPT_VALUE_INTERNAL               _T("INTERNAL")

        // Protocol types
#define TOKEN_OPT_VALUE_RTRMGR                 _T("ROUTERMANAGER")
#define TOKEN_OPT_VALUE_RIP                    _T("RIP")
#define TOKEN_OPT_VALUE_OSPF                   _T("OSPF")
#define TOKEN_OPT_VALUE_BOOTP                  _T("BOOTP")
#define TOKEN_OPT_VALUE_IGMP                   _T("IGMP")
#define TOKEN_OPT_VALUE_AUTO_DHCP              _T("AUTODHCP")
#define TOKEN_OPT_VALUE_DNS_PROXY              _T("DNSPROXY")
#define TOKEN_OPT_VALUE_VRRP                   _T("VRRP")

#define TOKEN_OPT_VALUE_TCP                    _T("TCP")
#define TOKEN_OPT_VALUE_UDP                    _T("UDP")
#define TOKEN_OPT_VALUE_ICMP                   _T("ICMP")
#define TOKEN_OPT_VALUE_NETMGMT                _T("SNMP")
#define TOKEN_OPT_VALUE_LOCAL                  _T("LOCAL")
#define TOKEN_OPT_VALUE_STATIC                 _T("STATIC")
#define TOKEN_OPT_VALUE_AUTOSTATIC             _T("AUTOSTATIC")
#define TOKEN_OPT_VALUE_NONDOD                 _T("NONDOD")
#define TOKEN_OPT_VALUE_ANY                    _T("ANY")


        // Igmp protocol types
#define TOKEN_OPT_VALUE_IGMPRTRV1              _T("IGMPRTRV1")
#define TOKEN_OPT_VALUE_IGMPRTRV2              _T("IGMPRTRV2")
#define TOKEN_OPT_VALUE_IGMPPROXY              _T("IGMPPROXY")

#define TOKEN_OPT_VALUE_TRUE                   _T("TRUE")
#define TOKEN_OPT_VALUE_FALSE                  _T("FALSE")
#define TOKEN_OPT_VALUE_HOST_JOIN              _T("HOSTJOIN")
#define TOKEN_OPT_VALUE_MGM_ONLY_JOIN          _T("MGMONLYJOIN")


        // Accept/Announce types
#define TOKEN_OPT_VALUE_RIP1                   _T("RIP1")
#define TOKEN_OPT_VALUE_RIP1_COMPAT            _T("RIP1COMPAT")
#define TOKEN_OPT_VALUE_RIP2                   _T("RIP2")

        // log level types
#define TOKEN_OPT_VALUE_ERROR                  _T("ERROR")
#define TOKEN_OPT_VALUE_WARN                   _T("WARN")
#define TOKEN_OPT_VALUE_INFO                   _T("INFO")

        // unicast peer modes
#define TOKEN_OPT_VALUE_ALSO                   _T("ALSO")
#define TOKEN_OPT_VALUE_ONLY                   _T("ONLY")

        // filter modes
#define TOKEN_OPT_VALUE_INCLUDE                _T("INCLUDE")
#define TOKEN_OPT_VALUE_EXCLUDE                _T("EXCLUDE")

        // Misc. option vlues
#define TOKEN_OPT_VALUE_INPUT                  _T("INPUT")
#define TOKEN_OPT_VALUE_OUTPUT                 _T("OUTPUT")
#define TOKEN_OPT_VALUE_DIAL                   _T("DIAL")

#define TOKEN_OPT_VALUE_ENABLE                 L"enable"
#define TOKEN_OPT_VALUE_DISABLE                L"disable"
#define TOKEN_OPT_VALUE_DEFAULT                L"default"

#define TOKEN_OPT_VALUE_YES                    _T("YES")
#define TOKEN_OPT_VALUE_NO                     _T("NO")

#define TOKEN_OPT_VALUE_NONE                   _T("NONE")
#define TOKEN_OPT_VALUE_PASSWORD               _T("PASSWORD")

#define TOKEN_OPT_VALUE_DROP                   _T("DROP")
#define TOKEN_OPT_VALUE_FORWARD                _T("FORWARD")
#define TOKEN_OPT_VALUE_ACCEPT                 _T("ACCEPT")

#define TOKEN_OPT_VALUE_DEMAND                 _T("DEMAND")
#define TOKEN_OPT_VALUE_PERIODIC               _T("PERIODIC")

#define TOKEN_OPT_VALUE_NBMA                   _T("NBMA")
#define TOKEN_OPT_VALUE_POINT_TO_POINT         _T("P2P")
#define TOKEN_OPT_VALUE_BROADCAST              _T("BROADCAST")

#define TOKEN_OPT_VALUE_ADDRESSONLY            _T("ADDRESSONLY")
#define TOKEN_OPT_VALUE_PRIVATE                _T("PRIVATE")

#define TOKEN_OPT_VALUE_AUTH_NONE              _T("NONE")
#define TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD    _T("SIMPLEPASSWD")
#define TOKEN_OPT_VALUE_AUTH_MD5                _T("MD5")

    // Commands for configuring the various protocols

    // tokens for commands required by most protocols

#define CMD_GROUP_ADD                          _T("add")
#define CMD_GROUP_DELETE                       _T("delete")
#define CMD_GROUP_SET                          _T("set")
#define CMD_GROUP_SHOW                         _T("show")

#define CMD_SHOW_HELPER                        _T("show helper")
#define CMD_INSTALL                            _T("install")
#define CMD_UNINSTALL                          _T("uninstall")
#define CMD_DUMP                               _T("dump")
#define CMD_HELP1                              _T("help")
#define CMD_HELP2                              _T("?")
#define CMD_MIB                                _T("mib")
#define CMD_ADD_HELPER                         _T("add helper")
#define CMD_DEL_HELPER                         _T("delete helper")

    // VRRP commands
#define CMD_VRRP_ADD_INTERFACE                 L"add interface"
#define CMD_VRRP_ADD_VRID                      L"add VRID"
#define CMD_VRRP_DELETE_INTERFACE              L"delete interface"
#define CMD_VRRP_DELETE_VRID                   L"delete VRID"
#define CMD_VRRP_SET_GLOBAL                    L"set global"
#define CMD_VRRP_SET_INTERFACE                 L"set interface"
#define CMD_VRRP_SHOW_GLOBAL                   L"show global"
#define CMD_VRRP_SHOW_INTERFACE                L"show interface"

    // MSDP commands
#define CMD_MSDP_ADD_PEER                      L"add peer"
#define CMD_MSDP_DELETE_PEER                   L"delete peer"
#define CMD_MSDP_SET_PEER                      L"set peer"
#define CMD_MSDP_SHOW_PEER                     L"show peer"
#define CMD_MSDP_SHOW_PEERSTATS                L"show peerstats"
#define CMD_MSDP_SET_GLOBAL                    L"set global"
#define CMD_MSDP_SHOW_GLOBAL                   L"show global"
#define CMD_MSDP_SHOW_GLOBALSTATS              L"show globalstats"
#define CMD_MSDP_SHOW_SA                       L"show sa"

    // Tokens for MSDP MIB
#define TOKEN_MSDP_MIB_OBJECT_PEERSTATS        L"peerstats"
#define TOKEN_MSDP_MIB_OBJECT_GLOBALSTATS      L"globalstats"
#define TOKEN_MSDP_MIB_OBJECT_SA               L"sa"

    // Common dump commands

#define DMP_POPD        L"popd\n"
#define DMP_INSTALL     L"install\n"
#define DMP_UNINSTALL   L"uninstall\n"

    // MSDP commands

#define DMP_MSDP_PUSHD             L"pushd routing ip msdp\n"
#define DMP_MSDP_SET_GLOBAL        L"set global"
#define DMP_MSDP_ADD_PEER          L"add peer"
#define DMP_MSDP_STRING_ARGUMENT   L" %1!s!=%2!s!"
#define DMP_MSDP_INTEGER_ARGUMENT  L" %1!s!=%2!d!"

    // VRRP commands
    //
#define DMP_VRRP_INSTALL _T("\
install\n")

#define DMP_VRRP_PUSHD L"\
pushd routing ip vrrp\n"

#define DMP_VRRP_SET_GLOBAL _T("\
set global %1!s!=%2!s!\n")

#define DMP_VRRP_ADD_INTERFACE _T("\
add interface %1!s!\"%2!s!\"\n")

#define DMP_VRRP_ADD_VRID _T("\
add vrid %1!s!\"%2!s!\" %3!s!%4!d! %5!s!%6!s!\n")

#define DMP_VRRP_SET_INTERFACE _T("\
set interface \
%1!s!\"%2!s!\" \
%3!s!%4!d! \
%5!s!%6!s! \
%7!s!%8!d!-%9!d!-%10!d!-%11!d!-%12!d!-%13!d!-%14!d!-%15!d! \
%16!s!%17!d! \
%18!s!%19!d! \
%20!s!%21!s! \n")

#define DMP_VRRP_UNINSTALL _T("\
uninstall\n")

    // Ospf dump commands

#define DMP_OSPF_PUSHD L"\
pushd ip ospf\n"

#define DMP_OSPF_INSTALL _T("\
install\n")

#define DMP_OSPF_UNINSTALL _T("\
uninstall\n")

#define DMP_OSPF_SET_GLOBAL _T("\
set global routerid=%1!s! asborder=%2!d! loglevel=%3!s!\n\n")

#define DMP_OSPF_DELETE_INTERFACE _T("\
delete interface name=%1!s!\n")

#define DMP_OSPF_ADD_INTERFACE _T("\
add interface name=%1!s!\n")

#define DMP_OSPF_SET_INTERFACE _T("\
set interface name=%1!s!\
 ifaddr=%2!s!\
 ifmask=%3!s!\
 iftype=%4!s!\
 prio=%5!d!\
 transdelay=%6!d!\
 retrans=%7!d!\
 hello=%8!d!\
 dead=%9!d!\
 poll=%10!d!\
 metric=%11!d!\
 password=%12!s!\
 mtu=%13!d!\n\n")

#define DMP_OSPF_ADD_AREA _T("\
add area areaid=%1!s!\n\n")

#define DMP_OSPF_DELETE_AREA _T("\
delete area areaid=%1!s!\n")

#define DMP_OSPF_SET_AREA _T("\
set area areaid=%1!s!\
 auth=%2!s!\
 importas=%3!s!\
 metric=%4!d!\
 sumad=%5!s!\n\n")

#define DMP_OSPF_ADD_NEIGHBOR _T("\
add neighbor name=%1!s! ifaddr=%2!s! nbraddr=%3!s! nbrprio=%4!d!\n")

#define DMP_OSPF_DELETE_NEIGHBOR _T("\
delete neighbor name=%1!s! ifaddr=%2!s! nbraddr=%3!s!\n")

#define DMP_OSPF_ADD_VIRTUAL_INTERFACE _T("\
add neighbor name=%1!s! ifaddr=%2!s! nbraddr=%3!s!\n")

#define DMP_OSPF_DELETE_VIRTUAL_INTERFACE _T("\
delete virtif transareaid=%1!s! virtnbrid=%2!s!\n")

#define DMP_OSPF_SET_VIRTUAL_INTERFACE _T("\
set virtif transareaid=%1!s! virtnbrid=%2!s!\
 transdelay=%3!d! retrans=%4!d! hello=%5!d!\
 dead=%6!d! password=%7!s!\n")

    // Ospf hlp commands

#define CMD_OSPF_ADD_AREA_RANGE                _T("add range")
#define CMD_OSPF_ADD_AREA                      _T("add area")
#define CMD_OSPF_ADD_VIRTIF                    _T("add virtif")
#define CMD_OSPF_ADD_IF_NBR                    _T("add neighbor")
#define CMD_OSPF_ADD_IF                        _T("add interface")
#define CMD_OSPF_ADD                       _T("add")

#define CMD_OSPF_DEL_AREA_RANGE                _T("delete range")
#define CMD_OSPF_DEL_AREA                      _T("delete area")
#define CMD_OSPF_DEL_VIRTIF                    _T("delete virtif")
#define CMD_OSPF_DEL_IF_NBR                    _T("delete neighbor")
#define CMD_OSPF_DEL_IF                        _T("delete interface")
#define CMD_OSPF_DEL                       _T("delete")

#define CMD_OSPF_SET_AREA                      _T("set area")
#define CMD_OSPF_SET_VIRTIF                    _T("set virtif")
#define CMD_OSPF_SET_IF                        _T("set interface")
#define CMD_OSPF_SET_GLOBAL                    _T("set global")

#define CMD_OSPF_SHOW_GLOBAL                   _T("show global")
#define CMD_OSPF_SHOW_AREA                     _T("show area")
#define CMD_OSPF_SHOW_VIRTIF                   _T("show virtif")
#define CMD_OSPF_SHOW_IF                       _T("show interface")
#define CMD_OSPF_SHOW                          _T("show")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\utils.h ===
#define DispTokenErrMsg(hModule, dwMsgId, pwszTag, pwszValue) \
        DisplayMessage( hModule, dwMsgId, pwszValue, pwszTag)



DWORD
GetDisplayStringT (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_TOKEN ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    );

DWORD
GetDisplayString (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_STRING ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    );

DWORD
GetAltDisplayString(
    IN  HANDLE        hModule, 
    IN  HANDLE        hFile,
    IN  DWORD         dwValue,
    IN  PVALUE_TOKEN  vtTable,
    IN  PVALUE_STRING vsTable,
    IN  DWORD         dwNumArgs,
    OUT PTCHAR       *pptszString);

DWORD
GetInfoBlockFromInterfaceInfoEx(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk,   OPTIONAL
    OUT PDWORD  pdwSize,        OPTIONAL
    OUT PDWORD  pdwCount,       OPTIONAL
    OUT PDWORD  pdwIfType       OPTIONAL
    );

DWORD
GetIpAddress(
    PTCHAR    pptcArg
    );

DWORD
GetMibTagToken(
    IN  LPWSTR *ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  DWORD   dwNumIndices,
    OUT PDWORD  pdwRR,
    OUT PBOOL   pbIndex,
    OUT PDWORD  pdwIndex
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ippromon.rc
//
#define VER_PRODUCTVER                  0074

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\monitor2\ip\utils.c

Abstract:

     Utility functions

Revision History:

    Anand Mahalingam         7/10/98  Created

--*/

#include "precomp.h"
#pragma hdrstop

#define MIB_REFRESH_EVENT   L"MIBEvent"

DWORD
GetDisplayStringT (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_TOKEN ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    )
{
    DWORD i, dwErr = NO_ERROR ;

    for (i=0;  i<dwNumArgs;  i++)
    {
        if ( dwValue == ptvTable[i].dwValue )
        {
            *ppwszString = HeapAlloc( GetProcessHeap(), 0,
                 (wcslen(ptvTable[i].pwszToken)+1) * sizeof(WCHAR) );
                                    
            wcscpy(*ppwszString, ptvTable[i].pwszToken);
            break;
        }
    }

    if (i == dwNumArgs)
        *ppwszString = MakeString( hModule, STRING_UNKNOWN ) ;

    if (!ppwszString)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        DisplayError( hModule, dwErr ) ;
    }
    
    return dwErr ;
}

DWORD
GetDisplayString (
    IN  HANDLE  hModule,
    IN  DWORD   dwValue,
    IN  PVALUE_STRING ptvTable,
    IN  DWORD   dwNumArgs,
    OUT PWCHAR  *ppwszString
    )
{
    DWORD i, dwErr = NO_ERROR ;

    for (i=0;  i<dwNumArgs;  i++)
    {
        if ( dwValue == ptvTable[i].dwValue )
        {
            *ppwszString = MakeString( hModule, ptvTable[i].dwStringId ) ;
            break;
        }
    }

    if (i == dwNumArgs)
        *ppwszString = MakeString( hModule, STRING_UNKNOWN ) ;

    if (!ppwszString)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
        DisplayError( hModule, dwErr ) ;
    }
    
    return dwErr ;
}

DWORD
GetAltDisplayString(
    HANDLE        hModule, 
    HANDLE        hFile,
    DWORD         dwValue,
    PVALUE_TOKEN  vtTable,
    PVALUE_STRING vsTable,
    DWORD         dwNumArgs,
    PTCHAR       *pptszString)
{
    if (hFile) 
    {
        return GetDisplayStringT(hModule,
                dwValue,
                vtTable,
                dwNumArgs,
                pptszString) ;
    } 
    else 
    {
        return GetDisplayString(hModule,
                dwValue,
                vsTable,
                dwNumArgs,
                pptszString) ;
    }
}
    
#if 0
DWORD
DispTokenErrMsg(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    IN  DWORD   dwTagId,
    IN  LPCWSTR pwszValue
    )
/*++

Routine Description:

    Displays error message with token arguments.

Arguments:

    dwMsgId  - Message to be printed
    dwTagId  - The tag string id
    pwszValue - the value specified for the tag in the command

Return Value:

    NO_ERROR

--*/

{
    PWCHAR    pwszTag;

    pwszTag = MakeString(hModule,
                         dwTagId);

    DisplayMessage(hModule,
                   dwMsgId,
                   pwszValue,
                   pwszTag);

    FreeString(pwszTag);

    return NO_ERROR;
}
#endif

DWORD
GetMibTagToken(
    IN    LPCWSTR   *ppwcArguments,
    IN    DWORD     dwArgCount,
    IN    DWORD     dwNumIndices,
    OUT   PDWORD    pdwRR,
    OUT   PBOOL     pbIndex,
    OUT   PDWORD    pdwIndex
    )
/*++

Routine Description:

    Looks for indices and refresh rate arguments in the command. If index
    tag is present, it would be of the form index= index1 index2 ....
    The index= is removed by this function. So is rr= if it is there in
    the command. If pdwRR is 0 then, no refresh sought.
    
Arguments:

    pptcArguments  - The argument array. Each argument has tag=value form
    dwCurrentIndex - pptcArguments[dwCurrentIndex] is first arg.
    dwArgCount     - pptcArguments[dwArgCount - 1] is last arg.
    pttTagToken    - Array of tag token ids that are allowed in the args
    dwNumTags      - Size of pttTagToken
    pdwOut         - Array identifying the type of each argument.

Return Value:

    NO_ERROR, ERROR_INVALID_PARAMETER, ERROR_INVALID_OPTION_TAG
    
--*/
{
    DWORD    i;
    BOOL     bTag;

    if (dwArgCount is 0)
    {
        *pdwRR = 0;
        *pbIndex = FALSE;
        
        return NO_ERROR;
    }

    if (dwArgCount < dwNumIndices)
    {
        //
        // No index
        //
        
        *pbIndex = FALSE;

        if (dwArgCount > 1)
        {
            *pdwRR = 0;
            
            return ERROR_INVALID_PARAMETER;
        }
        
        //
        // No Index specified. Make sure refresh rate is specified
        // with tag.
        //

        if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
        {
            //
            // remove tag and get the refresh rate
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][3]);

            *pdwRR = wcstoul(ppwcArguments[0], NULL, 10);
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        //
        // Check for index tag
        //

        if (_wcsnicmp(ppwcArguments[0],L"INDEX=",6) == 0)
        {
            *pbIndex = TRUE;
            *pdwIndex = 0;

            //
            // remove tag and see if refresh rate is specified
            //

            wcscpy(ppwcArguments[0], &ppwcArguments[0][6]);

            if (dwArgCount > dwNumIndices)
            {
                //
                // Make sure that argument has RR tag
                //

                if (_wcsnicmp(ppwcArguments[dwNumIndices],L"RR=",3) == 0)
                {
                    //
                    // remove tag and get the refresh rate
                    //

                    wcscpy(ppwcArguments[dwNumIndices],
                           &ppwcArguments[dwNumIndices][3]);

                    *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);
                }
                else
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                //
                // No refresh rate specified
                //

                *pdwRR = 0;
                return NO_ERROR;
            }
        }
        else
        {
            //
            // Not index tag, See if it has an RR tag
            // 

            if (_wcsnicmp(ppwcArguments[0],L"RR=",3) == 0)
            {
                //
                // remove tag and get the refresh rate
                //

                wcscpy(ppwcArguments[0], &ppwcArguments[0][3]);

                *pdwRR = wcstoul(ppwcArguments[0], NULL , 10);

                //
                // See if the index follows
                //

                if (dwArgCount > dwNumIndices)
                {
                    if (dwArgCount > 1)
                    {
                        if (_wcsnicmp(ppwcArguments[1],L"INDEX=",6) == 0)
                        {
                            wcscpy(ppwcArguments[1], &ppwcArguments[1][6]);
                            *pbIndex = TRUE;
                            *pdwIndex = 1;
                            
                            return NO_ERROR;
                        }
                        else
                        {
                            *pdwRR = 0;
                            return ERROR_INVALID_PARAMETER;
                        }
                    }
                    else
                    {
                        return NO_ERROR;
                    }
                }
            }
            //
            // No RR Tag either
            //
            else if (dwArgCount > dwNumIndices)
            {
                //
                // Assume ppwcArguments[dwNumIndices] is the refresh rate
                //

                *pdwRR = wcstoul(ppwcArguments[dwNumIndices], NULL , 10);

                if (dwNumIndices != 0)
                {
                    *pbIndex = TRUE;
                    *pdwIndex = 0;
                }
            }
            else
            {
                //
                // only index present with no tag
                //
                *pbIndex = TRUE;
                *pdwIndex = 0;
            }
        }
    }

    return NO_ERROR;
}

DWORD
GetIpAddress(
    PTCHAR    pptcArg
    )
/*++

Routine Description:

    Gets the ip address from the string.
    
Arguments:

    pwszIpAddr - Ip address string
    
Return Value:
    
    ip address
    
--*/
{
    CHAR     pszIpAddr[ADDR_LENGTH+1];

    WideCharToMultiByte(GetConsoleOutputCP(),
                        0,
                        pptcArg,
                        -1,
                        pszIpAddr,
                        ADDR_LENGTH,
                        NULL,
                        NULL);

    pszIpAddr[ADDR_LENGTH] = '\0';
                
    return (DWORD) inet_addr(pszIpAddr);
}          

BOOL WINAPI HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
    )
{
    HANDLE hMib;
    
    if (dwCtrlType == CTRL_C_EVENT)
    {
        hMib = OpenEvent(EVENT_ALL_ACCESS,FALSE,MIB_REFRESH_EVENT);

        SetEvent(hMib);
    }

    return TRUE;
    
}



DWORD
GetInfoBlockFromInterfaceInfoEx(
    IN  LPCWSTR pwszIfName,
    IN  DWORD   dwType,
    OUT BYTE    **ppbInfoBlk,   OPTIONAL
    OUT PDWORD  pdwSize,        OPTIONAL
    OUT PDWORD  pdwCount,       OPTIONAL
    OUT PDWORD  pdwIfType       OPTIONAL
    )
/*++

Routine Description:
    calls GetInfoBlockFromInterfaceInfo and dumps error message if there is an
    error.

--*/
{
    DWORD dwErr;
    
    //
    // get current interface config
    //
    
    dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pwszIfName,
                                            dwType,
                                            ppbInfoBlk,
                                            pdwSize,
                                            pdwCount,
                                            pdwIfType);
                                   
    switch(dwErr)
    {
        case NO_ERROR:
            break;

        case ERROR_NOT_FOUND:
            DisplayMessage(g_hModule,EMSG_PROTO_NO_IF_INFO);
            break;

        case ERROR_INVALID_PARAMETER:
            DisplayMessage(g_hModule,EMSG_CORRUPT_INFO);
            break;
            
        case ERROR_NOT_ENOUGH_MEMORY:
            DisplayMessage(g_hModule,EMSG_NOT_ENOUGH_MEMORY);
            break;

        default:
            DisplayError(g_hModule, dwErr);
            break;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\strdefs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:


Abstract:

    

Author:

    Amritansh Raghav  01/25/1996

Revision History:

    V Raman            05/15/1996        Rearranged stringtable ids.
        
--*/

#ifndef __STRDEFS_H__
#define __STRDEFS_H__


// The string table entries that are identified here are arranged  
// in a hierachy as follows

    // Command line tokens
        // command class
        // commands
        // command objects
            // Router command objects
            // MIB comand objects
        // command option tags
            // interface options
            // filter options
            // Protocol Options
                // OSPF options
                // RIP options
                // Igmp options
            // Route options
        // Micellaneous options
        // Option values
            // Interface types
            // Router discovery types
            // Protocol types
            // Accept/Announce types
            // Misc. option values

    // command usage messages
        // show command usage 
        // add command usage 
        // delete command usage 
        // set command usage 

    // Output messages
        // Router messages
            // Interface messages
            // Filter messages
            // Route messages
            // Global info. messages
            // OSPF messages
        // MIB messages

    // Strings
        // Interface Types
        // TCP constants
        // TCP states
        // Protocol types
        // IP Route types
        // IP net types
        // Interface types
        // transmission types
        // Miscellaneous strings
        
    // Error Messages

#define MSG_NULL                                1000

#define MAX_ROUTER_OBJECTS                      \
    (TOKEN_RTR_OBJECT_IPIPTUNNEL - TOKEN_RTR_OBJECT_INTERFACE + 1)

#define MAX_MIB_OBJECTS                         \
    (TOKEN_MIB_OBJECT_MFESTATS - TOKEN_MIB_OBJECT_INTERFACE + 1)

#define DMP_MSDP_HEADER                         7050
#define DMP_MSDP_FOOTER                         7051
#define DMP_MSDP_INTERFACE_HEADER               7052

#define DMP_VRRP_HEADER                         7101
#define DMP_VRRP_FOOTER                         7102
#define DMP_VRRP_INTERFACE_HEADER               7103

// commmon hlp messages

#define HLP_HELP                                8400
#define HLP_HELP_EX                             8401
#define HLP_HELP1                               HLP_HELP
#define HLP_HELP1_EX                            HLP_HELP_EX
#define HLP_HELP2                               HLP_HELP
#define HLP_HELP2_EX                            HLP_HELP_EX
#define HLP_SHOW_HELPER                         8412
#define HLP_SHOW_HELPER_EX                      8413
#define HLP_INSTALL                             8414
#define HLP_INSTALL_EX                          8415
#define HLP_UNINSTALL                           8416
#define HLP_UNINSTALL_EX                        8417
#define HLP_DUMP                                8418
#define HLP_DUMP_EX                             8419
#define HLP_GROUP_ADD                           8420
#define HLP_GROUP_DELETE                        8421
#define HLP_GROUP_SET                           8422
#define HLP_GROUP_SHOW                          8423
#define HLP_ADD_HELPER                          8424
#define HLP_ADD_HELPER_EX                       8425
#define HLP_DEL_HELPER                          8426
#define HLP_DEL_HELPER_EX                       8427


// rip add hlp

#define HLP_RIP_ADD_PF                          9000
#define HLP_RIP_ADD_PF_EX                       9001
#define HLP_RIP_ADD_IF_ACCF                     9002
#define HLP_RIP_ADD_IF_ACCF_EX                  9003
#define HLP_RIP_ADD_IF_ANNF                     9004
#define HLP_RIP_ADD_IF_ANNF_EX                  9005
#define HLP_RIP_ADD_IF_NBR                      9006
#define HLP_RIP_ADD_IF_NBR_EX                   9007
#define HLP_RIP_ADD_IF                          9008
#define HLP_RIP_ADD_IF_EX                       9009

// rip delete hlp

#define HLP_RIP_DEL_PF                          9020
#define HLP_RIP_DEL_PF_EX                       9021
#define HLP_RIP_DEL_IF_ACCF                     9022
#define HLP_RIP_DEL_IF_ACCF_EX                  9023
#define HLP_RIP_DEL_IF_ANNF                     9024
#define HLP_RIP_DEL_IF_ANNF_EX                  9025
#define HLP_RIP_DEL_IF_NBR                      9026
#define HLP_RIP_DEL_IF_NBR_EX                   9027
#define HLP_RIP_DEL_IF                          9028
#define HLP_RIP_DEL_IF_EX                       9029

// rip set hlp

#define HLP_RIP_SET_IF                          9040
#define HLP_RIP_SET_IF_EX                       9041
#define HLP_RIP_SET_GLOBAL                      9042
#define HLP_RIP_SET_GLOBAL_EX                   9043

// rip show hlp

#define HLP_RIP_SHOW_IF                         9050
#define HLP_RIP_SHOW_IF_EX                      9051
#define HLP_RIP_SHOW_GLOBAL                     9052
#define HLP_RIP_SHOW_GLOBAL_EX                  9053

#define HLP_IP_ADD_IF                           9200
#define HLP_IP_ADD_PROTO                        9201
#define HLP_IP_ADD_ROUTEPREF                    9203
#define HLP_IP_ADD_IF_FILTER                    9204

#define HLP_IP_DEL_IF                           9210
#define HLP_IP_DEL_PROTO                        9211
#define HLP_IP_DEL_ROUTEPREF                    9212
#define HLP_IP_DEL_IF_FILTER                    9213

#define HLP_IP_SET_IF                           9220
#define HLP_IP_SET_ROUTEPREF                    9221
#define HLP_IP_SET_IF_FILTER                    9222
#define HLP_IP_SET                              9223

#define HLP_IP_SHOW_IF_FILTER                   9230
#define HLP_IP_SHOW_IF                          9231
#define HLP_IP_SHOW_ROUTEPREF                   9232
#define HLP_IP_SHOW_PROTOCOL                    9233
#define HLP_IP_SHOW                             9234

// BOOTP help messages

#define HLP_BOOTP_ADD                           9401
#define HLP_BOOTP_ADD_EX                        9402
#define HLP_BOOTP_ADD_IF                        9403
#define HLP_BOOTP_ADD_IF_EX                     9404
#define HLP_BOOTP_ADD_DHCP_SERVER               9405
#define HLP_BOOTP_ADD_DHCP_SERVER_EX            9406

#define HLP_BOOTP_DEL                           9411
#define HLP_BOOTP_DEL_EX                        9412
#define HLP_BOOTP_DEL_IF                        9413
#define HLP_BOOTP_DEL_IF_EX                     9414
#define HLP_BOOTP_DEL_DHCP_SERVER               9415
#define HLP_BOOTP_DEL_DHCP_SERVER_EX            9416

#define HLP_BOOTP_SET_GLOBAL                    9421
#define HLP_BOOTP_SET_GLOBAL_EX                 9422
#define HLP_BOOTP_SET_IF                        9423
#define HLP_BOOTP_SET_IF_EX                     9424

#define HLP_BOOTP_SHOW_GLOBAL                   9431
#define HLP_BOOTP_SHOW_GLOBAL_EX                9432
#define HLP_BOOTP_SHOW_IF                       9433
#define HLP_BOOTP_SHOW_IF_EX                    9434

// DHCP allocator help messages
#define HLP_AUTODHCP_ADD_EXCLUSION              9441
#define HLP_AUTODHCP_ADD_EXCLUSION_EX           9442
#define HLP_AUTODHCP_DELETE_EXCLUSION           9443
#define HLP_AUTODHCP_DELETE_EXCLUSION_EX        9444
#define HLP_AUTODHCP_SET_GLOBAL                 9445
#define HLP_AUTODHCP_SET_GLOBAL_EX              9446
#define HLP_AUTODHCP_SET_INTERFACE              9447
#define HLP_AUTODHCP_SET_INTERFACE_EX           9448
#define HLP_AUTODHCP_SHOW_GLOBAL                9449
#define HLP_AUTODHCP_SHOW_GLOBAL_EX             9450
#define HLP_AUTODHCP_SHOW_INTERFACE             9451
#define HLP_AUTODHCP_SHOW_INTERFACE_EX          9452

// DNS proxy help messages
#define HLP_DNSPROXY_SET_GLOBAL                 9461
#define HLP_DNSPROXY_SET_GLOBAL_EX              9462
#define HLP_DNSPROXY_SET_INTERFACE              9463
#define HLP_DNSPROXY_SET_INTERFACE_EX           9464
#define HLP_DNSPROXY_SHOW_GLOBAL                9465
#define HLP_DNSPROXY_SHOW_GLOBAL_EX             9466
#define HLP_DNSPROXY_SHOW_INTERFACE             9467
#define HLP_DNSPROXY_SHOW_INTERFACE_EX          9468

// NAT help messages
#define HLP_NAT_ADD_ADDRESS_MAPPING             9471
#define HLP_NAT_ADD_ADDRESS_MAPPING_EX          9472
#define HLP_NAT_ADD_ADDRESS_RANGE               9473
#define HLP_NAT_ADD_ADDRESS_RANGE_EX            9474
#define HLP_NAT_ADD_PORT_MAPPING                9475
#define HLP_NAT_ADD_PORT_MAPPING_EX             9476
#define HLP_NAT_DELETE_ADDRESS_MAPPING          9477
#define HLP_NAT_DELETE_ADDRESS_MAPPING_EX       9478
#define HLP_NAT_DELETE_ADDRESS_RANGE            9479
#define HLP_NAT_DELETE_ADDRESS_RANGE_EX         9480
#define HLP_NAT_DELETE_PORT_MAPPING             9481
#define HLP_NAT_DELETE_PORT_MAPPING_EX          9482
#define HLP_NAT_SET_GLOBAL                      9483
#define HLP_NAT_SET_GLOBAL_EX                   9484
#define HLP_NAT_SET_INTERFACE                   9485
#define HLP_NAT_SET_INTERFACE_EX                9486
#define HLP_NAT_SHOW_GLOBAL                     9487
#define HLP_NAT_SHOW_GLOBAL_EX                  9488
#define HLP_NAT_ADD_INTERFACE                   9489
#define HLP_NAT_ADD_INTERFACE_EX                9490
#define HLP_NAT_DELETE_INTERFACE                9491
#define HLP_NAT_DELETE_INTERFACE_EX             9492
#define HLP_NAT_SHOW_INTERFACE                  9493
#define HLP_NAT_SHOW_INTERFACE_EX               9494

// VRRP help messages
#define HLP_VRRP_ADD_INTERFACE                  9501
#define HLP_VRRP_ADD_INTERFACE_EX               9502
#define HLP_VRRP_DELETE_INTERFACE               9503
#define HLP_VRRP_DELETE_INTERFACE_EX            9504
#define HLP_VRRP_SET_GLOBAL                     9505
#define HLP_VRRP_SET_GLOBAL_EX                  9506
#define HLP_VRRP_SET_INTERFACE                  9507
#define HLP_VRRP_SET_INTERFACE_EX               9508
#define HLP_VRRP_SHOW_GLOBAL                    9509
#define HLP_VRRP_SHOW_GLOBAL_EX                 9510
#define HLP_VRRP_SHOW_INTERFACE                 9511
#define HLP_VRRP_SHOW_INTERFACE_EX              9512
#define HLP_VRRP_ADD_VRID                       9513
#define HLP_VRRP_ADD_VRID_EX                    9514
#define HLP_VRRP_DELETE_VRID                    9515
#define HLP_VRRP_DELETE_VRID_EX                 9516

// MSDP help messages
#define HLP_MSDP_ADD_PEER                       9601
#define HLP_MSDP_ADD_PEER_EX                    9602
#define HLP_MSDP_DELETE_PEER                    9603
#define HLP_MSDP_DELETE_PEER_EX                 9604
#define HLP_MSDP_SET_PEER                       9605
#define HLP_MSDP_SET_PEER_EX                    9606
#define HLP_MSDP_SHOW_PEER                      9607
#define HLP_MSDP_SHOW_PEER_EX                   9608

#define HLP_MSDP_SET_GLOBAL                     9615
#define HLP_MSDP_SET_GLOBAL_EX                  9616
#define HLP_MSDP_SHOW_GLOBAL                    9617
#define HLP_MSDP_SHOW_GLOBAL_EX                 9618

#define HLP_MSDP_SHOW_PEERSTATS                 9627
#define HLP_MSDP_SHOW_PEERSTATS_EX              9628

#define HLP_MSDP_SHOW_GLOBALSTATS               9637
#define HLP_MSDP_SHOW_GLOBALSTATS_EX            9638

#define HLP_MSDP_SHOW_SA                        9647
#define HLP_MSDP_SHOW_SA_EX                     9648

// Command usage messages
#define MSG_IP_USAGE                            10001
#define MSG_ROUTER_USAGE                        10002
#define MSG_MIB_USAGE                           10003
#define MSG_HELP_USAGE                          10004
#define MSG_HELPER_USAGE                        10005

// Output messages

        // MSDP messages
#define MSG_MSDP_GLOBAL_INFO                    20501
#define MSG_MSDP_PEER_HEADER                    20502
#define MSG_MSDP_PEER_INFO                      20503
#define MSG_MSDP_PEER_INFO_EX                   20504
#define MSG_MSDP_NO_PEER_INFO                   20505
#define MSG_MSDP_GLOBAL_STATS                   20506
#define MSG_MSDP_PEER_STATS_HEADER              20507
#define MSG_MSDP_PEER_STATS                     20508
#define MSG_MSDP_PEER_STATS_EX                  20509
#define MSG_MSDP_SA_INFO_HEADER                 20510
#define MSG_MSDP_SA_INFO                        20511
#define MSG_MSDP_SA_INFO_EX                     20512

        // VRRP messages    
#define MSG_VRRP_GLOBAL_INFO                    20831
#define MSG_VRRP_INTERFACE_INFO                 20832
#define MSG_VRRP_VRID_INFO                      20833
#define EMSG_INVALID_VRID                       20834

     // !@#
#define MSG_UNIDENTIFIED_MIB                    21500
#define MSG_INSUFFICIENT_ARGS                   21501
#define MSG_IP_ADDR_NOT_FOUND                   21502
#define MSG_IP_BAD_IP_ADDR                      21503
#define MSG_CANNOT_SET_INFO                     21504
#define MSG_IF_NBR_NOT_FOUND                    21506
#define MSG_CANT_FIND_EOPT                      21507
#define MSG_ERR_UPDATE                          21508
#define MSG_BAD_CMD                             21509
#define MSG_IP_BAD_SYNTAX                       21510
#define MSG_PROTOCOL_NOT_IN_TRANSPORT           21511
#define EMSG_NO_INTERFACE                       21512
#define MSG_NO_ENTRY_PT                         21514
#define MSG_DLL_LOAD_FAILED                     21515
#define MSG_NO_HELPER                           21516
#define MSG_NO_HELPERS                          21517
#define MSG_CREATE_CONSOLE_FAILED               21518
#define MSG_IF_NAME_HDR                         21519
#define MSG_RTR_STOPPED                         21520
#define MSG_IP_NO_FILTER_FOR_FRAG               21521
#define MSG_IP_TAG_NOT_PRESENT                  21522
#define MSG_IP_INVALID_TAG                      21523
#define EMSG_TAG_ALREADY_PRESENT                21524
#define EMSG_INTERFACE_EXISTS                   21525
#define EMSG_PROTO_NOT_INSTALLED                21526
#define MSG_IP_BAD_IP_MASK                      21527
#define MSG_CTRL_C_TO_QUIT                      21530

#define MSG_RIP_MIB_OPT                         21551
#define MSG_BOOTP_MIB_OPT                       21552

#define MSG_IP_RIP_ADD_USAGE                    21750
#define MSG_IP_RIP_ADD_IF_USAGE                 21751
#define MSG_IP_RIP_ADD_PEER_USAGE               21752
#define MSG_IP_RIP_ADD_ACCFILTER_USAGE          21753 
#define MSG_IP_RIP_ADD_ANNFILTER_USAGE          21754
#define MSG_IP_RIP_ADD_NEIGHBOR_USAGE           21755
#define MSG_IP_RIP_DEL_USAGE                    21756
#define MSG_IP_RIP_DEL_IF_USAGE                 21757
#define MSG_IP_RIP_DEL_PEER_USAGE               21758
#define MSG_IP_RIP_DEL_ACCFILTER_USAGE          21759 
#define MSG_IP_RIP_DEL_ANNFILTER_USAGE          21760
#define MSG_IP_RIP_DEL_NEIGHBOR_USAGE           21761

    // RIP MIB
#define MSG_RIP_MIB_GS                          22000
#define MSG_RIP_MIB_PS                          22001
#define MSG_RIP_MIB_PS_HDR                      22002
#define MSG_RIP_MIB_IFSTATS                     22003
#define MSG_RIP_MIB_IFSTATS_HDR                 22004
#define MSG_RIP_MIB_IFBIND_HDR                  22005
#define MSG_RIP_MIB_IFBIND                      22006
#define MSG_RIP_MIB_IFBIND_ADDR                 22007
#define MSG_RIP_MIB_LINE                        22008


    // DHCP relay agent messages
    
#define MSG_BOOTP_MIB_GC                        22051
#define MSG_BOOTP_MIB_DHCP_SERVER_HEADER        22052
#define MSG_BOOTP_MIB_DHCP_SERVER               22053
#define MSG_BOOTP_MIB_IF_CONFIG                 22054
#define MSG_BOOTP_MIB_IF_BINDING                22055
#define MSG_BOOTP_MIB_IF_ADDRESS_HEADER         22056
#define MSG_BOOTP_MIB_IF_ADDRESS                22057
#define MSG_BOOTP_MIB_IF_STATS                  22058


#define EMSG_PROTO_NO_GLOBAL_INFO               25010           
#define EMSG_PROTO_NO_IF_INFO                   25011
#define EMSG_IP_INVALID_PARAMETER               25030
#define EMSG_RSVD_KEYWORD                       25031

// BOOTP msg strings

#define MSG_IP_BOOTP_ADD_USAGE                  26001
#define MSG_IP_BOOTP_DEL_USAGE                  26002
#define MSG_IP_BOOTP_ADD_IF_USAGE               26003
#define MSG_IP_BOOTP_DEL_IF_USAGE               26004
#define MSG_IP_BOOTP_ADD_DHCP_SERVER_USAGE      26005
#define MSG_IP_BOOTP_DEL_DHCP_SERVER_USAGE      26006
#define MSG_IP_BOOTP_SET_GLOBAL_USAGE           26007
#define MSG_IP_BOOTP_SET_IF_USAGE               26008
#define MSG_IP_BOOTP_SHOW_GLOBAL_USAGE          26009
#define MSG_IP_BOOTP_SHOW_IF_USAGE              26010

// Strings

    // Protocol types
#define STRING_PROTO_OTHER                      33001
#define STRING_PROTO_LOCAL                      33002
#define STRING_PROTO_NETMGMT                    33003
#define STRING_PROTO_RIP                        33008
#define STRING_PROTO_OSPF                       33013
#define STRING_PROTO_BOOTP                      33015
#define STRING_PROTO_IGMP                       33017

    // transmission types
#define STRING_BROADCAST                        37001
#define STRING_NBMA                             37002
#define STRING_PT2PT                            37003

    // Miscellaneous strings
#define STRING_CREATED                          38001
#define STRING_DELETED                          38002
#define STRING_ENABLED                          38003
#define STRING_DISABLED                         38004
#define STRING_DEFAULT_ENABLED                  38005
#define STRING_DEFAULT_DISABLED                 38006

#define STRING_ON                               38010
#define STRING_OFF                              38012
#define STRING_YES                              38013
#define STRING_NO                               38014
#define STRING_Y                                38015
#define STRING_N                                38016
#define STRING_NONE                             38017

#define STRING_INPUT                            38031
#define STRING_OUTPUT                           38032
#define STRING_DIAL                             38033

#define STRING_DROP                             38041
#define STRING_FORWARD                          38042
#define STRING_ACCEPT                           38043

#define STRING_LOGGING_NONE                     38051
#define STRING_LOGGING_ERROR                    38052
#define STRING_LOGGING_WARN                     38053
#define STRING_LOGGING_INFO                     38054

#define STRING_FILTER_INCLUDE                   38061
#define STRING_FILTER_EXCLUDE                   38062

#define STRING_BOUND                            38071
#define STRING_BOUND_ENABLED                    38072
#define STRING_UNBOUND                          38073

//rip
#define STRING_RIP1                             38081
#define STRING_RIP1COMPAT                       38082
#define STRING_RIP2                             38083

#define STRING_PEER_ALSO                        38091
#define STRING_PEER_ONLY                        38092

#define STRING_PERIODIC                         38101
#define STRING_DEMAND                           38102

#define STRING_RIP_IF_ENABLED                   38103
#define STRING_RIP_IF_BOUND                     38104

#define STRING_FULL_XLATE                       38201
#define STRING_ADDRESS_XLATE                    38202
#define STRING_PRIVATE_XLATE                    38203
#define STRING_INBOUND                          38204
#define STRING_OUTBOUND                         38205
#define STRING_DEFAULT_INTERFACE                38206
#define STRING_TCP                              38207
#define STRING_UDP                              38208

#define STRING_AUTH_NONE                        38211
#define STRING_AUTH_SIMPLEPASSWD                38212
#define STRING_AUTH_IPHEADER                    38213

// TCP Connection Engine states
#define STRING_IDLE                             40000
#define STRING_CONNECT                          40001
#define STRING_ACTIVE                           40002
#define STRING_OPENSENT                         40003
#define STRING_OPENCONFIRM                      40004
#define STRING_ESTABLISHED                      40005


#define STRING_UNKNOWN                          50001




// Error messages
#define MSG_IP_CANNOT_GET_INTERFACE_INFO        60001
#define MSG_IP_NO_INTERFACE_INFO                60002
#define MSG_IP_NO_ROUTE_INFO                    60003
#define MSG_IP_INVALID_OPTION_LENGTH            60005
#define MSG_IP_DIM_ERROR                        60006
#define MSG_IP_PARAMETER_ERROR                  60007
#define MSG_IP_NO_CMD                           60008
#define MSG_IP_NOT_ENOUGH_PARAMETERS            60009
#define MSG_IP_CAN_NOT_QUERY_ROUTER             60012
#define MSG_IP_ROUTER_NOT_RUNNING               60013
#define MSG_IP_CAN_NOT_CONNECT_DIM              60014
#define MSG_IP_NO_ENTRIES                       60015
#define EMSG_CORRUPT_INFO                       60016
#define MSG_IP_NO_GLOBAL_INFO                   60017
#define MSG_IP_CAN_NOT_GET_GLOBAL_INFO          60018
#define MSG_IP_NO_RTRPRIO_INFO                  60019
#define MSG_IP_NO_RTR_DISC_INFO                 60020
#define MSG_IP_NO_CONNECT_CONFIG                60021
#define MSG_IP_CONFIG_ERROR                     60022
#define MSG_IP_ADMIN_ERROR                      60023
#define EMSG_NOT_ENOUGH_MEMORY                  60024
#define EMSG_BAD_OPTION_VALUE                   60025
#define MSG_IP_NO_INPUT_FILTER                  60026
#define MSG_IP_NO_OUTPUT_FILTER                 60027

#define MSG_IP_SPECIFY_INTERFACE                60061
#define MSG_IP_MODE_ONLY_FOR_DNSPROXY           60062

#define MSG_IP_AREA_NOT_SPECIFIED               60101
#define MSG_IP_TRANSIT_AREA_NOT_SPECIFIED       60102
#define MSG_IP_AREA_NOT_FOUND                   60103

#define MSG_IP_INTERFACE_NOT_SPECIFIED          60111
#define MSG_IP_INTERFACE_NOT_FOUND              60112

#define MSG_IP_NEIGHBOR_NOT_SPECIFIED           60113
#define MSG_IP_NEIGHBOR_NOT_FOUND               60114

#define MSG_IP_NO_PREF_FOR_PROTOCOL_ID          60121       
#define MSG_IP_ROUTE_PREF_LEVEL_EXISTS          60122
#define MSG_IP_ROUTE_PREF_LEVEL_NOT_FOUND       60123


#define MSG_IP_AREA_NO_BACKBONE                 60201
#define MSG_IP_VI_NO_BACKBONE                   60202
#define MSG_IP_BAD_TRANSIT_AREA                 60203
#define MSG_IP_STUB_TRANSIT_AREA                60204
#define MSG_IP_TRANSIT_AREA_NOT_FOUND           60205
#define MSG_IP_BAD_RANGE                        60206
#define MSG_IP_NO_GLOBAL_PARAM                  60207
#define MSG_IP_NO_AREA                          60208

#define MSG_IP_NAT_NO_ADDRESS_POOL              60251
#define MSG_IP_NAT_NO_ADDRESS_RANGE             60252
#define MSG_IP_NAT_ADDRESS_MAPPING_NEEDS_RANGE  60253
#define MSG_IP_NAT_PORT_MAPPING_NEEDS_RANGE     60254
#define MSG_IP_NAT_BAD_RANGE_END                60255
#define MSG_IP_AUTODHCP_BAD_EXCLUSION           60256
#define MSG_IP_NAT_ADDRESS_MAPPING_INVALID      60257
#define MSG_IP_NAT_PORT_MAPPING_INVALID         60258

// igmp
#define EMSG_STATIC_MGM_GROUP_FOR_PROXY         60301
#define EMSG_STATIC_GROUP_EXISTS                60302
#define EMSG_STATIC_GROUP_NOT_FOUND             60303

#define MSG_IP_AREA_DELETED                     61001

//
// Error messages for mib calls
//

#define HLP_RIP_MIB_OBJECT_STATS                63001
#define HLP_RIP_MIB_OBJECT_STATS_EX             63002
#define HLP_RIP_MIB_OBJECT_IFSTATS              63003
#define HLP_RIP_MIB_OBJECT_IFSTATS_EX           63004
#define HLP_RIP_MIB_OBJECT_IFBINDING            63005
#define HLP_RIP_MIB_OBJECT_IFBINDING_EX         63006
#define HLP_RIP_MIB_OBJECT_PEERSTATS            63007
#define HLP_RIP_MIB_OBJECT_PEERSTATS_EX         63008

#define HLP_BOOTP_MIB_OBJECT_GLOBAL_CONFIG      63301
#define HLP_BOOTP_MIB_OBJECT_GLOBAL_CONFIG_EX   63302
#define HLP_BOOTP_MIB_OBJECT_IF_CONFIG          63303
#define HLP_BOOTP_MIB_OBJECT_IF_CONFIG_EX       63304
#define HLP_BOOTP_MIB_OBJECT_IF_BINDING         63305
#define HLP_BOOTP_MIB_OBJECT_IF_BINDING_EX      63306
#define HLP_BOOTP_MIB_OBJECT_IF_STATS           63307
#define HLP_BOOTP_MIB_OBJECT_IF_STATS_EX        63308

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\vrrphlp.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrphlp.h

Abstract:

    VRRP Command dispatcher declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_VRRPHLP_H_
#define _NETSH_VRRPHLP_H_

extern CMD_ENTRY g_VrrpAddCmdTable[];
extern CMD_ENTRY g_VrrpDelCmdTable[];
extern CMD_ENTRY g_VrrpSetCmdTable[];
extern CMD_ENTRY g_VrrpShowCmdTable[];


extern CMD_GROUP_ENTRY g_VrrpCmdGroupTable[];
extern ULONG g_VrrpCmdGroupCount;
extern CMD_ENTRY g_VrrpTopCmdTable[];
extern ULONG g_VrrpTopCmdCount;

NS_CONTEXT_DUMP_FN  VrrpDump;

#endif // _NETSH_VRRPHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\vrrphlp.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrphlp.c

Abstract:

    This module contains code for dispatching commands
    received for the Virtual Router Redundancy Protocol.
    The implementation of the commands is elsewhere,
    in vrrphlpopt.c and vrrphlpcfg.c.

Author

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

    Based loosely on net\routing\netsh\ip\protocols\nathlp.c by AboladeG

--*/

#include "precomp.h"
#pragma hdrstop



CMD_ENTRY g_VrrpAddCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_ADD_INTERFACE, HandleVrrpAddInterface),
    CREATE_CMD_ENTRY(VRRP_ADD_VRID,     HandleVrrpAddVRID)
};

CMD_ENTRY g_VrrpDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_DELETE_INTERFACE, HandleVrrpDeleteInterface),
    CREATE_CMD_ENTRY(VRRP_DELETE_VRID,      HandleVrrpDeleteVRID)
};

CMD_ENTRY g_VrrpSetCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_SET_INTERFACE, HandleVrrpSetInterface),
    CREATE_CMD_ENTRY(VRRP_SET_GLOBAL, HandleVrrpSetGlobal)
};

CMD_ENTRY g_VrrpShowCmdTable[] =
{
    CREATE_CMD_ENTRY(VRRP_SHOW_GLOBAL, HandleVrrpShowGlobal),
    CREATE_CMD_ENTRY(VRRP_SHOW_INTERFACE, HandleVrrpShowInterface)
};

CMD_GROUP_ENTRY g_VrrpCmdGroupTable[] =
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD, g_VrrpAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE, g_VrrpDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET, g_VrrpSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW, g_VrrpShowCmdTable)
};

ULONG g_VrrpCmdGroupCount =
    sizeof(g_VrrpCmdGroupTable) / sizeof(g_VrrpCmdGroupTable[0]);

CMD_ENTRY g_VrrpTopCmdTable[] =
{
    CREATE_CMD_ENTRY(INSTALL, HandleVrrpInstall),
    CREATE_CMD_ENTRY(UNINSTALL, HandleVrrpUninstall),
};

ULONG g_VrrpTopCmdCount =
    sizeof(g_VrrpTopCmdTable) / sizeof(g_VrrpTopCmdTable[0]);


DWORD
VrrpDump(
    IN  LPCWSTR     pwszRouter,
    IN  WCHAR     **ppwcArguments,
    IN  DWORD       dwArgCount,
    IN  PVOID       pvData
    )
{
    g_hMibServer = (MIB_SERVER_HANDLE)pvData;

    return DumpVrrpInformation();
} // VRRPDump
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\vrrphlpcfg.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    routing\netsh\ip\protocols\vrrphlpcfg.c

Abstract:

    Virtual Router Redundancy Protocol configuration implementation.
    This module contains configuration routines which are relied upon
    by vrrphlpopt.c. The routines retrieve, update, and display
    the configuration for the VRRP protocol.

    This file also contains default configuration settings
    for VRRP.

    N.B. The display routines require special attention since display
    may result in a list of commands sent to a 'dump' file, or in a
    textual presentation of the configuration to a console window.
    In the latter case, we use non-localizable output routines to generate
    a script-like description of the configuration. In the former case,
    we use localizable routines to generate a human-readable description.

Author:

    Peeyush Ranjan (peeyushr)   3-Mar-1999

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


#define Malloc(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define Free(x) HeapFree(GetProcessHeap(), 0, (x))

static  VRRP_GLOBAL_CONFIG
g_VrrpGlobalDefault =
{
    VRRP_LOGGING_ERROR
};

static PUCHAR g_pVrrpGlobalDefault = (PUCHAR)&g_VrrpGlobalDefault;

static VRRP_IF_CONFIG g_VrrpInterfaceDefault = 
{ 
    0
};

static VRRP_VROUTER_CONFIG g_VrrpVrouterDefault = 
{
    1,
    100,
    1,
    1,
    0,
    0,
    {0,0,0,0,0,0,0,0
    },
    0
};


//
// Forward declarations
//
ULONG
ValidateVrrpInterfaceInfo(
    PVRRP_IF_CONFIG InterfaceInfo
    );

BOOL
FoundIpAddress(
    DWORD IPAddress
    );

//
// What follows are the arrays used to map values to strings and
// to map values to tokens. These, respectively, are used in the case
// where we are displaying to a 'dump' file and to a console window.
//
VALUE_STRING VrrpGlobalLogginStringArray[] = {
    VRRP_LOGGING_NONE, STRING_LOGGING_NONE,
    VRRP_LOGGING_ERROR, STRING_LOGGING_ERROR,
    VRRP_LOGGING_WARN, STRING_LOGGING_WARN,
    VRRP_LOGGING_INFO, STRING_LOGGING_INFO
};

VALUE_TOKEN VrrpGlobalLogginTokenArray[] = {
    VRRP_LOGGING_NONE, TOKEN_OPT_VALUE_NONE,
    VRRP_LOGGING_ERROR, TOKEN_OPT_VALUE_ERROR,
    VRRP_LOGGING_WARN, TOKEN_OPT_VALUE_WARN,
    VRRP_LOGGING_INFO, TOKEN_OPT_VALUE_INFO
};

VALUE_STRING VrrpAuthModeStringArray[] = {
    VRRP_AUTHTYPE_NONE, STRING_AUTH_NONE,
    VRRP_AUTHTYPE_PLAIN, STRING_AUTH_SIMPLEPASSWD,
    VRRP_AUTHTYPE_IPHEAD, STRING_AUTH_IPHEADER
};

VALUE_TOKEN VrrpAuthModeTokenArray[] = {
    VRRP_AUTHTYPE_NONE, TOKEN_OPT_VALUE_AUTH_NONE,
    VRRP_AUTHTYPE_PLAIN, TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD,
    VRRP_AUTHTYPE_IPHEAD, TOKEN_OPT_VALUE_AUTH_MD5
};

VALUE_STRING VrrpPreemptModeStringArray[] = {
    TRUE, STRING_ENABLED,
    FALSE, STRING_DISABLED
};

VALUE_TOKEN VrrpPreemptModeTokenArray[] = {
    TRUE, TOKEN_OPT_VALUE_ENABLE,
    FALSE,TOKEN_OPT_VALUE_DISABLE
};

typedef enum {
    VrrpGlobalLoggingModeIndex,
    VrrpAuthModeIndex,
    VrrpPreemptModeIndex
} DISPLAY_VALUE_INDEX;




PTCHAR
QueryValueString(
    HANDLE FileHandle,
    DISPLAY_VALUE_INDEX Index,
    ULONG Value
    )
{
    ULONG Count;
    ULONG Error;
    PTCHAR String = NULL;
    PVALUE_STRING StringArray;
    PVALUE_TOKEN TokenArray;
    switch (Index) {
        case VrrpGlobalLoggingModeIndex:
            Count = NUM_VALUES_IN_TABLE(VrrpGlobalLogginStringArray);
            StringArray = VrrpGlobalLogginStringArray;
            TokenArray = VrrpGlobalLogginTokenArray;
            break;
        case VrrpAuthModeIndex:
            Count = NUM_VALUES_IN_TABLE(VrrpAuthModeStringArray);
            StringArray = VrrpAuthModeStringArray;
            TokenArray = VrrpAuthModeTokenArray;
            break;
        case VrrpPreemptModeIndex:
            Count = NUM_VALUES_IN_TABLE(VrrpPreemptModeStringArray);
            StringArray = VrrpPreemptModeStringArray;
            TokenArray = VrrpPreemptModeTokenArray;
            break;
         default:
            return NULL;
    }
    Error =
        GetAltDisplayString(
            g_hModule,
            FileHandle,
            Value,
            TokenArray,
            StringArray,
            Count,
            &String
            );
    return Error ? NULL : String;
}



ULONG
MakeVrrpGlobalInfo(
    OUT PUCHAR* GlobalInfo,
    OUT PULONG GlobalInfoSize
    )
{
    *GlobalInfoSize = sizeof(VRRP_GLOBAL_CONFIG);
    *GlobalInfo = Malloc(*GlobalInfoSize);
    if (!*GlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*GlobalInfo, g_pVrrpGlobalDefault, *GlobalInfoSize);
    return NO_ERROR;
}

ULONG
CreateVrrpGlobalInfo(
    OUT PVRRP_GLOBAL_CONFIG* GlobalInfo,
    IN  DWORD LoggingLevel
    )
{
    DWORD GlobalInfoSize;
    GlobalInfoSize = sizeof(PVRRP_GLOBAL_CONFIG);
    *GlobalInfo = Malloc(GlobalInfoSize);
    if (!*GlobalInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*GlobalInfo, g_pVrrpGlobalDefault, GlobalInfoSize);
    (*GlobalInfo)->LoggingLevel = LoggingLevel;

    return NO_ERROR;
}

ULONG
MakeVrrpInterfaceInfo(
    ROUTER_INTERFACE_TYPE InterfaceType,
    OUT PUCHAR* InterfaceInfo,
    OUT PULONG InterfaceInfoSize
    )
{
    //
    //Why is this check done?
    //            
    if (InterfaceType != ROUTER_IF_TYPE_DEDICATED) {
        return ERROR_INVALID_PARAMETER;
    }

    *InterfaceInfoSize = sizeof(VRRP_IF_CONFIG);
    *InterfaceInfo = Malloc(*InterfaceInfoSize);
    if (!*InterfaceInfo) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(*InterfaceInfo, &g_VrrpInterfaceDefault, *InterfaceInfoSize);
    return NO_ERROR;
}

ULONG
MakeVrrpVRouterInfo(
    IN OUT PUCHAR VRouterInfo
    )
{
    //
    // Always assumed that the space has been preassigned
    //
    if (!VRouterInfo) {
        return ERROR_INVALID_PARAMETER;
    }
    CopyMemory(VRouterInfo,&g_VrrpVrouterDefault,sizeof(g_VrrpVrouterDefault));
    return NO_ERROR;    
}


ULONG
ShowVrrpGlobalInfo(
    HANDLE FileHandle
    )
{
    ULONG Count = 0;
    ULONG Error;
    PVRRP_GLOBAL_CONFIG GlobalInfo = NULL;
    ULONG i;
    PTCHAR LoggingLevel = NULL;
    ULONG Size;
    do {
        //
        // Retrieve the global configuration for the VRRP,
        // and format its contents to the output file or console.
        //
        Error =
            IpmontrGetInfoBlockFromGlobalInfo(
                MS_IP_VRRP,
                (PUCHAR*)&GlobalInfo,
                &Size,
                &Count
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }
        LoggingLevel =
            QueryValueString(
                FileHandle, VrrpGlobalLoggingModeIndex, GlobalInfo->LoggingLevel
                );
        if (!LoggingLevel) { break; }
        if (FileHandle) {
            DisplayMessageT(DMP_VRRP_INSTALL);
            DisplayMessageT(
                DMP_VRRP_SET_GLOBAL,
                TOKEN_OPT_LOGGINGLEVEL, LoggingLevel
                );
        } else {
            DisplayMessage(
                g_hModule,
                MSG_VRRP_GLOBAL_INFO,
                LoggingLevel
                );
        }
    } while(FALSE);
    
    if (LoggingLevel) { Free(LoggingLevel); }
    if (GlobalInfo) { Free(GlobalInfo); }
    if (!FileHandle && Error) {
        if (Error == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
        } else {
            DisplayError(g_hModule, Error);
        }
    }
    return Error;
}

ULONG
ShowVrrpAllInterfaceInfo(
    HANDLE FileHandle
    )
{
    DWORD               dwErr, dwCount, dwTotal;
    DWORD               dwNumParsed, i, dwNumBlocks=1, dwSize, dwIfType;
    PBYTE               pBuffer;
    PMPR_INTERFACE_0    pmi0;
    WCHAR               wszIfDesc[MAX_INTERFACE_NAME_LEN + 1];

    //
    // dump vrrp config for all interfaces
    //

    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0,
                          &dwCount,
                          &dwTotal);

    if(dwErr != NO_ERROR)
    {
        DisplayError(g_hModule,
                     dwErr);
        return dwErr;
    }

    for(i = 0; i < dwCount; i++)
    {
        // make sure that vrrp is configured on that interface

        dwErr = IpmontrGetInfoBlockFromInterfaceInfo(pmi0[i].wszInterfaceName,
                                            MS_IP_VRRP,
                                            &pBuffer,
                                            &dwSize,
                                            &dwNumBlocks,
                                            &dwIfType);
        if (dwErr != NO_ERROR) {
            continue;
        }
        else {
            HEAP_FREE(pBuffer) ;
        }


        ShowVrrpInterfaceInfo(FileHandle, pmi0[i].wszInterfaceName);
    }
    return NO_ERROR;
}

ULONG
ShowVrrpInterfaceInfo(
    HANDLE FileHandle,
    PWCHAR InterfaceName
    )
{
    ULONG Count = 0;
    ULONG Error;
    PVRRP_IF_CONFIG InterfaceInfo;
    PTCHAR AuthType = NULL;
    ULONG Size;
    ULONG dwLength;
    TCHAR Title[MAX_INTERFACE_NAME_LEN + 1];
    ROUTER_INTERFACE_TYPE Type;
    ULONG Index;
    ULONG IPIndex;
    BYTE Password[VRRP_MAX_AUTHKEY_SIZE];
    PTCHAR IPAddresses = NULL;
    TCHAR Address[VRRP_IPADDR_LENGTH+1];
    PVRRP_VROUTER_CONFIG PVrouter;
    PTCHAR PreemptMode = NULL;

    do {
        //
        // Retrieve the interface's configuration
        // and format it to the output file or console.
        //
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR*)&InterfaceInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }
        Size = sizeof(Title);
        Error = IpmontrGetFriendlyNameFromIfName(InterfaceName, Title, &Size);
        if (Error) {
            Error = ERROR_NO_SUCH_INTERFACE;
            break;
        }             
        if (FileHandle) {
            DisplayMessage(g_hModule, DMP_VRRP_INTERFACE_HEADER, Title);
            DisplayMessageT(DMP_VRRP_ADD_INTERFACE,
                           TOKEN_OPT_NAME, Title);
            if (InterfaceInfo->VrouterCount) {                
                for (Index = 0 , PVrouter = VRRP_FIRST_VROUTER_CONFIG(InterfaceInfo);
                     Index < InterfaceInfo->VrouterCount; 
                     Index++ , PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                    for (IPIndex = 0; IPIndex < PVrouter->IPCount;
                         IPIndex++) {
                        IP_TO_TSTR(Address,
                                   &PVrouter->IPAddress[IPIndex]
                                   );
                        DisplayMessageT(
                            DMP_VRRP_ADD_VRID,
                            TOKEN_OPT_NAME, Title,
                            TOKEN_OPT_VRID, PVrouter->VRID,
                            TOKEN_OPT_IPADDRESS, Address
                            );
                    }

                    AuthType =
                        QueryValueString(
                            FileHandle, VrrpAuthModeIndex, 
                            PVrouter->AuthenticationType
                            );
                    if (!AuthType) {
                        Error = ERROR_INVALID_PARAMETER;
                        break;
                    }
                    CopyMemory(Password,PVrouter->AuthenticationData,
                               VRRP_MAX_AUTHKEY_SIZE);
                    DisplayMessageT(
                        DMP_VRRP_SET_INTERFACE,
                        TOKEN_OPT_NAME, Title,
                        TOKEN_OPT_VRID, PVrouter->VRID,
                        TOKEN_OPT_AUTH, 
                        (PVrouter->AuthenticationType == VRRP_AUTHTYPE_NONE) ? 
                        TOKEN_OPT_VALUE_AUTH_NONE : ((PVrouter->AuthenticationType 
                        == VRRP_AUTHTYPE_PLAIN) ? TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD :
                        TOKEN_OPT_VALUE_AUTH_MD5 ) ,
                        TOKEN_OPT_PASSWD, Password[0], Password[1], Password[2],
                        Password[3], Password[4], Password[5],Password[6], Password[7],
                        TOKEN_OPT_ADVTINTERVAL, PVrouter->AdvertisementInterval,
                        TOKEN_OPT_PRIO,PVrouter->ConfigPriority,
                        TOKEN_OPT_PREEMPT, PVrouter->PreemptMode? TOKEN_OPT_VALUE_ENABLE :
                                           TOKEN_OPT_VALUE_DISABLE
                        );
                }
            }
        } else {
            DisplayMessage(g_hModule, MSG_VRRP_INTERFACE_INFO,Title, 
                           InterfaceInfo->VrouterCount);
            for (Index = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(InterfaceInfo);
                 Index < InterfaceInfo->VrouterCount; 
                 Index++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
               AuthType =
                  QueryValueString(
                      FileHandle, VrrpAuthModeIndex, 
                      PVrouter->AuthenticationType
                      );
               if (!AuthType) {
                   Error = ERROR_INVALID_PARAMETER;
                   break;
               }
               CopyMemory(Password,PVrouter->AuthenticationData,
                          VRRP_MAX_AUTHKEY_SIZE);
               //
               // Allocate space for each IP address, a space+comma each and also a 
               // null terminator
               //
               IPAddresses = Malloc(dwLength = (((VRRP_IPADDR_LENGTH+2)*sizeof(TCHAR)*
                                    PVrouter->IPCount)+1));
               if (!IPAddresses) {
                   DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);

                   //
                   // Set AuthType to 0 which will cause a break from the outer loop
                   //

                   AuthType = 0;
                   Error = ERROR_NOT_ENOUGH_MEMORY;
                   break;                        
               }
               ZeroMemory(IPAddresses,dwLength);
               //
               // Now build the IP address list from the addresses given
               //
               for (IPIndex = 0; IPIndex < PVrouter->IPCount; IPIndex++ ) {
                   IP_TO_TSTR(Address,&PVrouter->IPAddress[IPIndex]);
                   wcscat(IPAddresses,Address);
                   if (IPIndex != (ULONG)(PVrouter->IPCount-1)) {
                       wcscat(IPAddresses,L", ");
                   }
               }
               PreemptMode =
               QueryValueString(
                   FileHandle,
                   VrrpPreemptModeIndex,
                   PVrouter->PreemptMode
                   );
               if (!PreemptMode) { break; }

               DisplayMessage(
                    g_hModule,
                    MSG_VRRP_VRID_INFO,
                    PVrouter->VRID,
                    IPAddresses,
                    AuthType,
                    Password[0], Password[1], Password[2], Password[3],
                    Password[4], Password[5], Password[6], Password[7],
                    PVrouter->AdvertisementInterval,
                    PVrouter->ConfigPriority,
                    PreemptMode
                    );
            }
        }
        if (!AuthType) {
            break;
        }
        Error = NO_ERROR;
    } while(FALSE);
    if (AuthType) { Free(AuthType); }
    Free(InterfaceInfo);
    if (IPAddresses) Free(IPAddresses);
    if (!FileHandle && Error) {
        if (Error == ERROR_NOT_FOUND) {
            DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
        } else {
            DisplayError(g_hModule, Error);
        }
    }
    return Error;
}

ULONG
UpdateVrrpGlobalInfo(
    PVRRP_GLOBAL_CONFIG GlobalInfo    
    )
{
    ULONG Count;
    ULONG Error;
    PVRRP_GLOBAL_CONFIG NewGlobalInfo = NULL;
    PVRRP_GLOBAL_CONFIG OldGlobalInfo = NULL;
    ULONG Size;
    
    do {
        //
        // Retrieve the existing global configuration.
        //
        Error =
            IpmontrGetInfoBlockFromGlobalInfo(
                MS_IP_VRRP,
                (PUCHAR*)&OldGlobalInfo,
                &Size,
                &Count
                );
        if (Error) {
            break;
        } else if (!(Count * Size)) {
            Error = ERROR_NOT_FOUND; break;
        }

        //
        // Allocate a new structure, copy to it the original configuration,
        //

        NewGlobalInfo = Malloc(Count * Size);
        if (!NewGlobalInfo) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        CopyMemory(NewGlobalInfo, OldGlobalInfo, Count * Size);
        
        //
        // Based on the changes requested, change the NewGlobalInfo.
        // Since for VRRP there is only the logging level to change, we just set that.
        //
        
        NewGlobalInfo->LoggingLevel = GlobalInfo->LoggingLevel;
        
        Error =
            IpmontrSetInfoBlockInGlobalInfo(
                MS_IP_VRRP,
                (PUCHAR)NewGlobalInfo,
                FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
                Count * Size,
                1
                );
    } while(FALSE);
    if (NewGlobalInfo) { Free(NewGlobalInfo); }
    if (OldGlobalInfo) { Free(OldGlobalInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_GLOBAL_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}


ULONG
UpdateVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL AddInterface
    )
{
    ULONG Count;
    ULONG Error;
    PVRRP_IF_CONFIG NewInterfaceInfo = NULL;
    PVRRP_IF_CONFIG OldInterfaceInfo = NULL;
    PVRRP_VROUTER_CONFIG PVrouter = NULL;
    ULONG Size;
    ROUTER_INTERFACE_TYPE Type;
    ULONG i;

    if (!AddInterface && !BitVector) { return NO_ERROR; }
    do {
        //
        // Retrieve the existing interface configuration.
        // We will update this block below, as well as adding to or removing
        // from it depending on the flags specified in 'BitVector'.
        //
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR*)&OldInterfaceInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            //
            // No existing configuration is found. This is an error unless
            // we are adding the interface anew, in which case we just
            // create for ourselves a block containing the default settings.
            //
            if (!AddInterface) {
                break;
            } else {
                Error = IpmontrGetInterfaceType(InterfaceName, &Type);
                if (Error) {
                    break;
                } else {
                    Count = 1;
                    Error =
                        MakeVrrpInterfaceInfo(
                            Type, (PUCHAR*)&OldInterfaceInfo, &Size
                            );
                    if (Error) { break; }
                }
            }
        } else {
            //
            // There is configuration on the interface. If it is empty this is
            // an error. If this is an add interface, and the info exists, it is
            // an error.
            //
            if (!(Count * Size) && !AddInterface) {
                Error = ERROR_NOT_FOUND; break;
            }
            else if (AddInterface) {
                //
                // We were asked to add an interface which already exists
                //
                DisplayMessage(g_hModule, EMSG_INTERFACE_EXISTS, InterfaceName);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
                    
        }

        if (!BitVector) {
            //
            // Just add this interface without any additional info.
            //
            DWORD OldSize;
            if (NewInterfaceInfo == NULL){
                NewInterfaceInfo = Malloc((OldSize=GetVrrpIfInfoSize(OldInterfaceInfo))+
                                          sizeof(VRRP_VROUTER_CONFIG));
                if (!NewInterfaceInfo) {
                    DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;                        
                }
            }
            CopyMemory(NewInterfaceInfo,OldInterfaceInfo,OldSize);
        }
        else{
            if (!AddInterface || (OldInterfaceInfo->VrouterCount != 0)) {
                //
                // There is a prexisting VRID set. Check for this VRID in the list and then
                // update it if required.
                //
                ASSERT(BitVector & VRRP_INTF_VRID_MASK);
                for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(OldInterfaceInfo);
                     i < OldInterfaceInfo->VrouterCount; 
                     i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                    if (PVrouter->VRID == VRouterInfo->VRID) {
                        break;
                    }
                }
                if (i == OldInterfaceInfo->VrouterCount) {
                    //
                    // This is a new VRID, Add it.
                    //
                    DWORD OldSize;

                    //
                    // The IP address should be valid or else this is a set op.
                    //
                    if (!(BitVector & VRRP_INTF_IPADDR_MASK)){
                        DisplayMessage(
                            g_hModule, EMSG_INVALID_VRID,
                            VRouterInfo->VRID
                            );
                        Error = ERROR_INVALID_PARAMETER;
                        break;
                    }

                    if (NewInterfaceInfo == NULL){
                        NewInterfaceInfo = Malloc((OldSize=GetVrrpIfInfoSize(
                                                OldInterfaceInfo))+
                                                sizeof(VRRP_VROUTER_CONFIG));
                        if (!NewInterfaceInfo) {
                            DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                            Error = ERROR_NOT_ENOUGH_MEMORY;
                            break;                        
                        }
                    }
                    CopyMemory(NewInterfaceInfo, OldInterfaceInfo, OldSize);
                    PVrouter = (PVRRP_VROUTER_CONFIG)((PBYTE)NewInterfaceInfo+OldSize);
                    CopyMemory(PVrouter,VRouterInfo,sizeof(VRRP_VROUTER_CONFIG));
                    NewInterfaceInfo->VrouterCount++;

                    //
                    // Check if we own the IP address given. If yes, set the priority.
                    //
                    PVrouter->ConfigPriority = 
                        FoundIpAddress(PVrouter->IPAddress[0]) ? 255 : 100;
                } 
                else{
                    //
                    //  This is an old VRID. Its priority should not need to be changed.
                    //
                    DWORD Offset, OldSize;

                    if(BitVector & VRRP_INTF_IPADDR_MASK) {
                        if ( ((PVrouter->ConfigPriority != 255) && 
                              (FoundIpAddress(VRouterInfo->IPAddress[0]))
                             )
                             ||
                             ((PVrouter->ConfigPriority == 255) && 
                              (!FoundIpAddress(VRouterInfo->IPAddress[0])))
                             ) {
                            DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE);
                            Error = ERROR_INVALID_PARAMETER;
                            break;                        
                        }
                        //
                        // Add this IP address to the VRID specified.
                        //
                        if (NewInterfaceInfo == NULL){
                            NewInterfaceInfo = Malloc((OldSize = GetVrrpIfInfoSize(
                                                        OldInterfaceInfo))+
                                                        sizeof(DWORD));
                            if (!NewInterfaceInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        //
                        // Shift all the VROUTER configs after the PVrouter by 1 DWORD.
                        //
                        Offset = (PUCHAR) VRRP_NEXT_VROUTER_CONFIG(PVrouter) - 
                                 (PUCHAR) OldInterfaceInfo;
                        CopyMemory(NewInterfaceInfo, OldInterfaceInfo, OldSize);
                        for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(NewInterfaceInfo);
                             i < NewInterfaceInfo->VrouterCount; 
                             i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewInterfaceInfo->VrouterCount);
                        PVrouter->IPAddress[PVrouter->IPCount++] = VRouterInfo->IPAddress[0];
    
                        ASSERT(((PUCHAR)NewInterfaceInfo+Offset+sizeof(DWORD)) == 
                               (PUCHAR) VRRP_NEXT_VROUTER_CONFIG(PVrouter));
    
                        CopyMemory(VRRP_NEXT_VROUTER_CONFIG(PVrouter), 
                                   OldInterfaceInfo+Offset, OldSize-Offset);
                    } else {
                        //
                        // Set the new info block as the old info block and point to the
                        // vrouter block
                        //
                        if (NewInterfaceInfo == NULL){
                            NewInterfaceInfo = Malloc((OldSize = GetVrrpIfInfoSize(
                                                        OldInterfaceInfo)));
                            if (!NewInterfaceInfo) {
                                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                                Error = ERROR_NOT_ENOUGH_MEMORY;
                                break;                        
                            }
                        }
                        CopyMemory(NewInterfaceInfo, OldInterfaceInfo, OldSize);
                        for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(NewInterfaceInfo);
                             i < NewInterfaceInfo->VrouterCount; 
                             i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                            if (PVrouter->VRID == VRouterInfo->VRID) {
                                break;
                            }
                        }
                        ASSERT(i < NewInterfaceInfo->VrouterCount);
                    }

                    if (BitVector & VRRP_INTF_AUTH_MASK) {
                        PVrouter->AuthenticationType = VRouterInfo->AuthenticationType;
                    }
                    if (BitVector & VRRP_INTF_PASSWD_MASK) {
                        CopyMemory(PVrouter->AuthenticationData, 
                                   VRouterInfo->AuthenticationData, 
                                   VRRP_MAX_AUTHKEY_SIZE);
                    }
                    if (BitVector & VRRP_INTF_ADVT_MASK) {
                        PVrouter->AdvertisementInterval = VRouterInfo->AdvertisementInterval;
                    }
                    if (BitVector & VRRP_INTF_PRIO_MASK) {
                        PVrouter->ConfigPriority = VRouterInfo->ConfigPriority;
                    }
                    if (BitVector & VRRP_INTF_PREEMPT_MASK) {
                        PVrouter->PreemptMode = VRouterInfo->PreemptMode;
                    }
                }
            }
        }

        ValidateVrrpInterfaceInfo(NewInterfaceInfo);

        Error =
            IpmontrSetInfoBlockInInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR)NewInterfaceInfo,
                GetVrrpIfInfoSize(NewInterfaceInfo),
                1
                );
    } while(FALSE);
    if (NewInterfaceInfo) { Free(NewInterfaceInfo); }
    if (OldInterfaceInfo) { Free(OldInterfaceInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}

ULONG
DeleteVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL DeleteInterface
    )
{
    ULONG Count;
    ULONG Error;
    PVRRP_IF_CONFIG NewInterfaceInfo = NULL;
    PVRRP_IF_CONFIG OldInterfaceInfo = NULL;
    PVRRP_VROUTER_CONFIG PVrouter = NULL;
    ULONG Size;
    ROUTER_INTERFACE_TYPE Type;
    ULONG i;

    if (!DeleteInterface && !BitVector) { return NO_ERROR; }
    do {
        //
        // Retrieve the existing interface configuration.
        // We will update this block below, as well as adding to or removing
        // from it depending on the flags specified in 'BitVector'.
        //
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP,
                (PUCHAR*)&OldInterfaceInfo,
                &Size,
                &Count,
                &Type
                );
        if (Error) {
            //
            // No existing configuration is found. This is an error. 
            //
            break;    
        }
        if (DeleteInterface) {
            //
            // Just delete this interface
            //
            Error = IpmontrDeleteInfoBlockFromInterfaceInfo(
                InterfaceName,
                MS_IP_VRRP
                );
            break;
        } else {
            DWORD OldSize;
            PVRRP_VROUTER_CONFIG PVrouterNew;
            //
            // Look for the VRID and delete it.
            //
            for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(OldInterfaceInfo);
                 i < OldInterfaceInfo->VrouterCount; 
                 i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                if (PVrouter->VRID == VRouterInfo->VRID) {
                    break;
                }
            }
            if (i >= OldInterfaceInfo->VrouterCount) {
                DisplayMessage(g_hModule, EMSG_BAD_OPTION_VALUE);
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
            
            NewInterfaceInfo = Malloc((OldSize=GetVrrpIfInfoSize(OldInterfaceInfo))-
                                      VRRP_VROUTER_CONFIG_SIZE(PVrouter));
            if (!NewInterfaceInfo) {
                DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
                Error = ERROR_NOT_ENOUGH_MEMORY;
                break;                        
            }
            NewInterfaceInfo->VrouterCount = OldInterfaceInfo->VrouterCount - 1;
            PVrouterNew = VRRP_FIRST_VROUTER_CONFIG(NewInterfaceInfo);
            for (i = 0, PVrouter = VRRP_FIRST_VROUTER_CONFIG(OldInterfaceInfo);
                 i < OldInterfaceInfo->VrouterCount; 
                 i++, PVrouter = VRRP_NEXT_VROUTER_CONFIG(PVrouter)) {
                if (PVrouter->VRID == VRouterInfo->VRID) {
                    continue;
                }
                CopyMemory(PVrouterNew,PVrouter,VRRP_VROUTER_CONFIG_SIZE(PVrouter));
                PVrouterNew = VRRP_NEXT_VROUTER_CONFIG(PVrouterNew);
            }
                        
            ValidateVrrpInterfaceInfo(NewInterfaceInfo);

            Error =
                IpmontrSetInfoBlockInInterfaceInfo(
                    InterfaceName,
                    MS_IP_VRRP,
                    (PUCHAR)NewInterfaceInfo,
                    GetVrrpIfInfoSize(NewInterfaceInfo),
                    1
                    );
        }
    
    } while(FALSE);
    if (NewInterfaceInfo) { Free(NewInterfaceInfo); }
    if (OldInterfaceInfo) { Free(OldInterfaceInfo); }
    if (Error == ERROR_NOT_FOUND) {
        DisplayMessage(g_hModule, EMSG_PROTO_NO_IF_INFO);
    } else if (Error) {
        DisplayError(g_hModule, Error);
    }
    return Error;
}


ULONG
ValidateVrrpInterfaceInfo(
    PVRRP_IF_CONFIG InterfaceInfo
    )
{
    return NO_ERROR;
}

DWORD
GetVrrpIfInfoSize(
    PVRRP_IF_CONFIG InterfaceInfo
    )
{
    DWORD Size = 0;
    ULONG i;
    PVRRP_VROUTER_CONFIG pvr;

    Size += sizeof(InterfaceInfo->VrouterCount);

    for (i = 0, pvr = VRRP_FIRST_VROUTER_CONFIG(InterfaceInfo);
         i < InterfaceInfo->VrouterCount;
         i++,pvr = VRRP_NEXT_VROUTER_CONFIG(pvr)) {
        Size += VRRP_VROUTER_CONFIG_SIZE(pvr);
    }

    return Size;
}

BOOL
FoundIpAddress(
    DWORD IPAddress
    )
{
    PMIB_IPADDRTABLE pTable = NULL;
    DWORD            Size  = 0;
    ULONG            i;
    BOOL             Result;

    GetIpAddrTable( pTable, &Size, TRUE);
    pTable = Malloc(Size);
    if (!pTable) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    if (GetIpAddrTable(pTable,&Size,TRUE) != NO_ERROR){
        return FALSE;
    }

    for (i = 0; i < pTable->dwNumEntries; i++) {
        if (pTable->table[i].dwAddr == IPAddress)
            break;
    }

    Result = (i < pTable->dwNumEntries);

    Free(pTable);

    return Result;

}

ULONG
SetArpRetryCount(
    DWORD Value
    )
{
    HKEY     hKey = NULL;
    DWORD    dwDisp;
    ULONG    dwErr = NO_ERROR;

    do
    {
        dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                        0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,
                        &hKey, &dwDisp);
        if (dwErr != ERROR_SUCCESS) {
            break;
        }
        dwErr = RegSetValueEx(hKey, L"ArpRetryCount", 0, REG_DWORD, (LPBYTE) &Value, 
                            sizeof(DWORD));
    } while (0);

    if (hKey) {
        RegCloseKey(hKey);
    }
    if (dwErr == ERROR_SUCCESS) {
        dwErr = NO_ERROR;
    }
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\vrrphlpopt.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrpopt.h

Abstract:

    VRRP Command dispatcher declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/


#ifndef _NETSH_VRRPHLPOPT_H_
#define _NETSH_VRRPHLPOPT_H_

FN_HANDLE_CMD HandleVrrpAddVRID;
FN_HANDLE_CMD HandleVrrpAddInterface;
FN_HANDLE_CMD HandleVrrpDeleteInterface;
FN_HANDLE_CMD HandleVrrpDeleteVRID;
FN_HANDLE_CMD HandleVrrpSetInterface;
FN_HANDLE_CMD HandleVrrpSetGlobal;
FN_HANDLE_CMD HandleVrrpShowGlobal;
FN_HANDLE_CMD HandleVrrpShowInterface;
FN_HANDLE_CMD HandleVrrpInstall;
FN_HANDLE_CMD HandleVrrpUninstall;

DWORD
DumpVrrpInformation(VOID);

#endif // _NETSH_VRRPHLPOPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\common.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\common.h

Abstract:

    The file contains the header for common.c,
    the main file for the IPSAMPLEMON helper DLL.
    
--*/

// constants...

#define SAMPLE_HELPER_VERSION       1



// globals...

// variables
extern HANDLE                       g_hModule;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\vrrphlpcfg.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrpcfg.h

Abstract:

    VRRP configuration declarations

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#ifndef _NETSH_VRRPHLPCFG_H_
#define _NETSH_VRRPHLPCFG_H_

#define VRRP_IPADDR_LENGTH  16
#define MAX_MESSAGE_SIZE    256

#define VRRP_INTF_VRID_MASK     0x00000001
#define VRRP_INTF_IPADDR_MASK   0x00000002
#define VRRP_INTF_AUTH_MASK     0x00000004
#define VRRP_INTF_PASSWD_MASK   0x00000008
#define VRRP_INTF_ADVT_MASK     0x00000010
#define VRRP_INTF_PRIO_MASK     0x00000020
#define VRRP_INTF_PREEMPT_MASK  0x00000040

ULONG
MakeVrrpGlobalInfo(
    OUT PUCHAR* GlobalInfo,
    OUT PULONG GlobalInfoSize
    );

ULONG
CreateVrrpGlobalInfo(
    OUT PVRRP_GLOBAL_CONFIG* GlobalInfo,
    IN  DWORD LoggingLevel
    );

ULONG
MakeVrrpInterfaceInfo(
    ROUTER_INTERFACE_TYPE InterfaceType,
    OUT PUCHAR* InterfaceInfo,
    OUT PULONG InterfaceInfoSize
    );

ULONG
MakeVrrpVRouterInfo(
    IN PUCHAR VRouterInfo
    );

ULONG
ShowVrrpGlobalInfo(
    HANDLE FileHandle
    );

ULONG
ShowVrrpAllInterfaceInfo(
    HANDLE FileHandle
    );

ULONG
ShowVrrpInterfaceInfo(
    HANDLE FileHandle,
    PWCHAR InterfaceName
    );

ULONG
UpdateVrrpGlobalInfo(
    PVRRP_GLOBAL_CONFIG GlobalInfo
    );

ULONG
UpdateVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL AddInterface
    );

DWORD
GetVrrpIfInfoSize(
    PVRRP_IF_CONFIG InterfaceInfo
    );

ULONG
DeleteVrrpInterfaceInfo(
    PWCHAR InterfaceName,
    PVRRP_VROUTER_CONFIG VRouterInfo,
    ULONG BitVector,
    BOOL DeleteInterface
    );

ULONG
SetArpRetryCount(
    DWORD Value
    );

//
// IP address conversion macros:
//    
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//
#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )

BOOL
FoundIpAddress(
    DWORD IPAddress
    );

#endif  // _NETSH_VRRPHLPCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\preview\vrrphlpopt.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    net\routing\netsh\ip\protocols\vrrphlpopt.c

Abstract:

    VRRP command options implementation.
    This module contains handlers for the configuration commands
    supported by the VRRP Protocol.

Author:

    Peeyush Ranjan (peeyushr)   1-Mar-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipcmp.h>

#define Malloc(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define Free(x) HeapFree(GetProcessHeap(), 0, (x))

//
// Forward declarations
//

ULONG
QueryTagArray(
    PTCHAR ArgumentArray[],
    ULONG ArgumentCount,
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount,
    OUT PULONG* TagArray
    );

ULONG
ValidateTagTypeArray(
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount
    );


DWORD
HandleVrrpAddVRID(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, TRUE, FALSE },
        { TOKEN_OPT_IPADDRESS, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;
    
    //
    // Make the default info
    //
    //
    MakeVrrpVRouterInfo((PUCHAR) &VRouterGiven);

    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 1: {
                ULONG VRIDGiven;
                VRIDGiven = _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (VRIDGiven > 255) {
                    DisplayMessage(
                        g_hModule, EMSG_INVALID_VRID,
                        VRIDGiven
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VRouterGiven.VRID = (BYTE) VRIDGiven;  
                BitVector |= VRRP_INTF_VRID_MASK;
                    
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 2: { 
                ULONG AddressSpecified;
                //
                // If the IP address has been specified, the VRID should have been
                // specified already
                //
                if (!(BitVector & VRRP_INTF_VRID_MASK)){
                    Error = ERROR_INVALID_SYNTAX;
                    i = ArgumentsLeft;
                    break;
                }

                AddressSpecified = GetIpAddress(ArgumentArray[i + ArgumentIndex]);
                if (!AddressSpecified || AddressSpecified == INADDR_NONE) {
                    DisplayMessage(
                        g_hModule,
                        MSG_IP_BAD_IP_ADDR,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }
                VRouterGiven.IPCount = 1;                           
                VRouterGiven.IPAddress[0] = AddressSpecified;
                BitVector |= VRRP_INTF_IPADDR_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }
    
    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error && (BitVector)) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            UpdateVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, FALSE
                );
    }
    
    return Error;
}

DWORD
HandleVrrpAddInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, FALSE, FALSE },
        { TOKEN_OPT_IPADDRESS, FALSE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 1: {
                ULONG VRIDGiven;
                VRIDGiven = _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (VRIDGiven > 255) {
                    DisplayMessage(
                        g_hModule, EMSG_INVALID_VRID,
                        VRIDGiven
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                VRouterGiven.VRID = (BYTE) VRIDGiven;  
                BitVector |= VRRP_INTF_VRID_MASK;
                    
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 2: { 
                ULONG AddressSpecified;
                //
                // If the IP address has been specified, the VRID should have been
                // specified already
                //
                if (!(BitVector & VRRP_INTF_VRID_MASK)){
                    Error = ERROR_INVALID_SYNTAX;
                    i = ArgumentsLeft;
                    break;
                }

                AddressSpecified = GetIpAddress(ArgumentArray[i + ArgumentIndex]);
                if (!AddressSpecified || AddressSpecified == INADDR_NONE) {
                    DisplayMessage(
                        g_hModule,
                        MSG_IP_BAD_IP_ADDR,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }
                           
                VRouterGiven.IPCount = 1;
                VRouterGiven.IPAddress[0] = AddressSpecified;
                BitVector |= VRRP_INTF_IPADDR_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }
    if ((BitVector) && (!(BitVector & VRRP_INTF_VRID_MASK) 
                     || !(BitVector & VRRP_INTF_IPADDR_MASK))) {
        //
        // You can either have no VRID, or both VRID and IP address, not only one of them
        //
        Error = ERROR_INVALID_SYNTAX;
    }

    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            UpdateVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, TRUE
                );
    }
    
    return Error;
}


DWORD
HandleVrrpDeleteInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }

    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            DeleteVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, TRUE
                );
    }
    
    return Error;
}


DWORD
HandleVrrpDeleteVRID(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VRouterGiven;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    ULONG InfoSize;

    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) { return ERROR_SHOW_USAGE; }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterGiven' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
        case 1: {
            ULONG Length = sizeof(InterfaceName);
            DWORD VRIDGiven;
            VRIDGiven = _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);

            if (VRIDGiven > 255) {
                DisplayMessage(
                    g_hModule, EMSG_INVALID_VRID,
                    VRIDGiven
                    );
                Error = ERROR_NO_SUCH_INTERFACE;
                i = ArgumentsLeft;
                break;
            }
            VRouterGiven.VRID = (BYTE) VRIDGiven;  
            BitVector |= VRRP_INTF_VRID_MASK;

            TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
            break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }

    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error && (BitVector)) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            DeleteVrrpInterfaceInfo(
                InterfaceName, &VRouterGiven, BitVector, FALSE
                );
    }
    
    return Error;
}


DWORD
DumpVrrpInformation(VOID)
{
    PMPR_INTERFACE_0 Array;
    ULONG Count = 0;
    ULONG Error;
    ULONG i;
    PUCHAR Information;
    ULONG Length;
    ULONG Total;
    ULONG Type;
        
    DisplayMessage(g_hModule,DMP_VRRP_HEADER);
    DisplayMessageT(DMP_VRRP_PUSHD);
    DisplayMessageT(DMP_VRRP_UNINSTALL);
    //
    // Show the global info commands
    //

    ShowVrrpGlobalInfo(INVALID_HANDLE_VALUE);
    //
    // Now show every interface
    //
    Error = IpmontrInterfaceEnum((PUCHAR*)&Array, &Count, &Total);
    if (Error) {
        DisplayError(g_hModule, Error);
        return NO_ERROR;
    }
    for (i = 0; i < Count; i++) {
        Error =
            IpmontrGetInfoBlockFromInterfaceInfo(
                Array[i].wszInterfaceName,
                MS_IP_VRRP,
                &Information,
                &Length,
                &Total,
                &Type
                );
        if (!Error) {
            Free(Information);
            ShowVrrpInterfaceInfo(INVALID_HANDLE_VALUE, Array[i].wszInterfaceName);
        }
    }

    DisplayMessageT(DMP_POPD);
    DisplayMessage(g_hModule, DMP_VRRP_FOOTER);
    
    Free(Array);
    return NO_ERROR;
}


DWORD
HandleVrrpInstall(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG Error;
    PUCHAR GlobalInfo;
    ULONG Length;
    if (ArgumentIndex != ArgumentCount) { return ERROR_SHOW_USAGE; }
    //
    // To install the VRRP, we construct the default configuration
    // and add it to the global configuration for the router.
    //
    Error = MakeVrrpGlobalInfo(&GlobalInfo, &Length);
    if (Error) {
        DisplayError(g_hModule, Error);
    } else {
        Error =
            IpmontrSetInfoBlockInGlobalInfo(
                MS_IP_VRRP,
                GlobalInfo,
                Length,
                1
                );
        Free(GlobalInfo);
        if (!Error) {
            DEBUG("Added VRRP");
        } else {
            DisplayError(g_hModule, Error);
        }
        Error = SetArpRetryCount(0);
    }
    return Error;
}

DWORD
HandleVrrpSetGlobal(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG Error;
    PULONG TagArray;
    PVRRP_GLOBAL_CONFIG pVrrpNewGlobalConfig;
    DWORD LoggingLevel;
    ULONG i;
    ULONG ErrorIndex;
    
    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_LOGGINGLEVEL, FALSE, FALSE }
    };
        
    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");
    
    if (ArgumentIndex >= ArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                TOKEN_VALUE TokenArray[] = {
                    { TOKEN_OPT_VALUE_NONE, VRRP_LOGGING_NONE },
                    { TOKEN_OPT_VALUE_ERROR, VRRP_LOGGING_ERROR },
                    { TOKEN_OPT_VALUE_WARN, VRRP_LOGGING_WARN },
                    { TOKEN_OPT_VALUE_INFO, VRRP_LOGGING_INFO }
                };
                Error =
                    MatchEnumTag(
                        g_hModule,
                        ArgumentArray[i + ArgumentIndex],
                        NUM_TOKENS_IN_TABLE(TokenArray),
                        TokenArray,
                        &LoggingLevel
                        );
                if (Error) {
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }                                
                
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            default: {
                i = ArgumentsLeft;
                Error = ERROR_INVALID_SYNTAX;
            }
        }
    }
        
    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error){
        Error = CreateVrrpGlobalInfo(&pVrrpNewGlobalConfig,LoggingLevel);
        
        if (!Error) {
            //
            // Update the configuration with the new settings.
            // Note that the update routine may perform additional validation
            // in the process of reconciling the new settings
            // with any existing settings.
            //
            Error = UpdateVrrpGlobalInfo(pVrrpNewGlobalConfig);
            Free(pVrrpNewGlobalConfig);
        }
    }
    return NO_ERROR;
}

DWORD
HandleVrrpSetInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG BitVector;
    ULONG Error;
    ULONG ErrorIndex = 0;
    ULONG i;
    VRRP_VROUTER_CONFIG VrouterInfo;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE },
        { TOKEN_OPT_VRID, TRUE, FALSE },
        { TOKEN_OPT_AUTH, FALSE, FALSE},
        { TOKEN_OPT_PASSWD, FALSE, FALSE},
        { TOKEN_OPT_ADVTINTERVAL, FALSE, FALSE},
        { TOKEN_OPT_PRIO, FALSE, FALSE},
        { TOKEN_OPT_PREEMPT, FALSE, FALSE}
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    BitVector = 0;
    ZeroMemory(&VrouterInfo, sizeof(VrouterInfo));

    //
    // We now scan the argument list, converting the arguments
    // into information in our 'VrouterInfo' structure.
    //

    for (i = 0; i < ArgumentsLeft; i++) {
        switch(TagArray ? TagArray[i] : i) {
            case 0: {
                ULONG Length = sizeof(InterfaceName);
                Error =
                    IpmontrGetIfNameFromFriendlyName(
                        ArgumentArray[i + ArgumentIndex], InterfaceName, &Length
                        );
                if (Error) {
                    DisplayMessage(
                        g_hModule, EMSG_NO_INTERFACE,
                        ArgumentArray[i + ArgumentIndex]
                        );
                    Error = ERROR_NO_SUCH_INTERFACE;
                    i = ArgumentsLeft;
                    break;
                }
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 1:{  
                BYTE VRIDGiven;

                VRIDGiven = 
                    (UCHAR)_tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (VRIDGiven > 255) {
                    DisplayMessage(
                        g_hModule, EMSG_INVALID_VRID,
                        VRIDGiven
                        );
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VrouterInfo.VRID = (BYTE) VRIDGiven;  
                BitVector |= VRRP_INTF_VRID_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 2:{
            TOKEN_VALUE TokenArray[] = {
                    { TOKEN_OPT_VALUE_AUTH_NONE, VRRP_AUTHTYPE_NONE },
                    { TOKEN_OPT_VALUE_AUTH_SIMPLE_PASSWORD, VRRP_AUTHTYPE_PLAIN },
                    { TOKEN_OPT_VALUE_AUTH_MD5, VRRP_AUTHTYPE_IPHEAD }
                };
            DWORD dwAuthType;     

                Error =
                    MatchEnumTag(
                        g_hModule,
                        ArgumentArray[i + ArgumentIndex],
                        NUM_TOKENS_IN_TABLE(TokenArray),
                        TokenArray,
                        &dwAuthType
                        );
                VrouterInfo.AuthenticationType = (BYTE) dwAuthType;
                if (Error) {
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }                                
                BitVector |= VRRP_INTF_AUTH_MASK;

                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 3:{
                UINT    Index;
                UINT    PassByte;
                PTCHAR  Token;
				PTCHAR  Password;

#if 0
                //
                // Allocate more space for the tokenizing NULL
                //

				Password = Malloc((2+_tcslen(ArgumentArray[i + ArgumentIndex])) * 
                                  sizeof(TCHAR));

                if (!Password) {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                _tcscpy(Password,ArgumentArray[i + ArgumentIndex]);

                ZeroMemory(VrouterInfo.AuthenticationData,VRRP_MAX_AUTHKEY_SIZE);
                Token = _tcstok(Password,L"-");
                for (Index = 0; Index < VRRP_MAX_AUTHKEY_SIZE; Index++) {
                    PassByte = _tcstoul(Token, NULL, 10);
                    if (PassByte > 255) {
                        Error = ERROR_INVALID_PARAMETER;
                        i = ArgumentsLeft;
                        break;
                    }
                    VrouterInfo.AuthenticationData[Index] = PassByte & 0xff;
                    Token = _tcstok(NULL,"-");
                    if (!Token) {
                        break;
                    }
                }
                Free(Password);
                if (Error) {
                    break;
                }
#else
				Password = ArgumentArray[i + ArgumentIndex];
                for (Index = 0; Index < VRRP_MAX_AUTHKEY_SIZE; Index++) {
                    PassByte = _tcstoul(Password, NULL, 10);
                    if (PassByte > 255) {
                        Error = ERROR_INVALID_PARAMETER;
                        i = ArgumentsLeft;
                        break;
                    }
                    VrouterInfo.AuthenticationData[Index] = PassByte & 0xff;
                    Password = _tcschr(Password,_T('-'));
                    if (!Password) {
                        break;
                    }
					Password ++;
                }
#endif

                BitVector |= VRRP_INTF_PASSWD_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 4:{
                BYTE AdvtIntvl;
                AdvtIntvl = (UCHAR)
                    _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
                
                if (AdvtIntvl > 255) {
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VrouterInfo.AdvertisementInterval = (BYTE) AdvtIntvl;  
                BitVector |= VRRP_INTF_ADVT_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 5:{
                BYTE ConfigPrio;
                ConfigPrio = (UCHAR)
                    _tcstoul(ArgumentArray[i + ArgumentIndex], NULL, 10);
    
                if (ConfigPrio > 255) {
                    Error = ERROR_INVALID_PARAMETER;
                    i = ArgumentsLeft;
                    break;
                }
                VrouterInfo.ConfigPriority = (BYTE) ConfigPrio;  
                BitVector |= VRRP_INTF_PRIO_MASK;
                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
            case 6:{
                TOKEN_VALUE TokenArray[] = {
                        { TOKEN_OPT_VALUE_ENABLE, TRUE },
                        { TOKEN_OPT_VALUE_DISABLE, FALSE }
                    };
                Error =
                    MatchEnumTag(
                        g_hModule,
                        ArgumentArray[i + ArgumentIndex],
                        NUM_TOKENS_IN_TABLE(TokenArray),
                        TokenArray,
                        &VrouterInfo.PreemptMode
                        );
                if (Error) {
                    Error = ERROR_INVALID_PARAMETER;
                    ErrorIndex = i;
                    i = ArgumentsLeft;
                    break;
                }                                
                BitVector |= VRRP_INTF_PREEMPT_MASK;

                TagTypeArray[TagArray ? TagArray[i] : i].bPresent = TRUE;
                break;
            }
        }
    }
    if (!Error) {
        //
        // Ensure that all required parameters are present.
        //
        Error =
            ValidateTagTypeArray(TagTypeArray, NUM_TAGS_IN_TABLE(TagTypeArray));
    }
    if (Error == ERROR_TAG_ALREADY_PRESENT) {
        DisplayMessage(g_hModule, EMSG_TAG_ALREADY_PRESENT);
    } else if (Error == ERROR_INVALID_PARAMETER && TagArray) {
        DispTokenErrMsg(
            g_hModule,
            EMSG_BAD_OPTION_VALUE,
            TagTypeArray[TagArray[ErrorIndex]],
            ArgumentArray[ErrorIndex + ArgumentIndex]
            );
    } else if (!Error && (BitVector)) {
        //
        // Update the configuration with the new settings.
        // Note that the update routine may perform additional validation
        // in the process of reconciling the new settings
        // with any existing settings.
        //
        Error =
            UpdateVrrpInterfaceInfo(
                InterfaceName, &VrouterInfo, BitVector, FALSE
                );
    }
    if (TagArray) { Free(TagArray); }
    return Error; 
}

DWORD
HandleVrrpShowGlobal(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    if (ArgumentIndex != ArgumentCount) { return ERROR_SHOW_USAGE; }
    ShowVrrpGlobalInfo(NULL);
    return NO_ERROR;
}

DWORD
HandleVrrpShowInterface(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG ArgumentsLeft;
    ULONG Error;
    PULONG TagArray;
    WCHAR InterfaceName[MAX_INTERFACE_NAME_LEN + 1];
    TAG_TYPE TagTypeArray[] = {
        { TOKEN_OPT_INTERFACE_NAME, TRUE, FALSE }
    };

    VERIFY_INSTALLED(MS_IP_VRRP, L"VRRP");

    if (ArgumentIndex >= ArgumentCount) {
        return ERROR_SHOW_USAGE;
    }
    ArgumentsLeft = ArgumentCount - ArgumentIndex;

    //
    // We convert the optional tags into an array of 'TagTypeArray' indices
    // which guide is in our scanning of the argument list.
    // Since the tags are optional, this process may result in no tags at all,
    // in which case we assume that arguments are specified in exactly the order
    // given in 'TagTypeArray' above.
    //

    Error =
        QueryTagArray(
            &ArgumentArray[ArgumentIndex],
            ArgumentsLeft,
            TagTypeArray,
            NUM_TAGS_IN_TABLE(TagTypeArray),
            &TagArray
            );
    if (Error) { return Error; }

    //
    // If any tags were specified, the only one present must refer
    // to the interface name which is index '0' in 'TagTypeArray'.
    // If no tags were specified, we assume the argument is an interface name,
    // and we retrieve its friendly name in order to delete it.
    //

    if (TagArray && TagArray[0] != 0) {
        Free(TagArray);
        return ERROR_SHOW_USAGE;
    } else {
        ULONG Length = sizeof(InterfaceName);
        Error =
            IpmontrGetIfNameFromFriendlyName(
                ArgumentArray[ArgumentIndex], InterfaceName, &Length
                );
    }
    if (!Error) {
           Error = ShowVrrpInterfaceInfo(NULL, InterfaceName);
    }
    if (TagArray) { Free(TagArray); }
    return Error;                
}


DWORD
HandleVrrpUninstall(
    PWCHAR MachineName,
    PTCHAR* ArgumentArray,
    DWORD ArgumentIndex,
    DWORD ArgumentCount,
    DWORD CmdFlags,
    PVOID Data,
    BOOL* CommandDone
    )
{
    ULONG Error;
    if (ArgumentIndex != ArgumentCount) { return ERROR_SHOW_USAGE; }
    Error = IpmontrDeleteProtocol(MS_IP_VRRP);
    if (!Error) { DEBUG("Deleted VRRP"); }
    Error = SetArpRetryCount(3);
    return Error;
}

ULONG
QueryTagArray(
    PTCHAR ArgumentArray[],
    ULONG ArgumentCount,
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount,
    OUT PULONG* TagArray
    )
{
    ULONG Error;
    ULONG i;

    if (!_tcsstr(ArgumentArray[0], ptszDelimiter)) {
        *TagArray = NULL;
        return NO_ERROR;
    }

    *TagArray = Malloc(ArgumentCount * sizeof(ULONG));
    if (!*TagArray) {
        DisplayMessage(g_hModule, EMSG_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = 
        MatchTagsInCmdLine(
            g_hModule,
            ArgumentArray,
            0,
            ArgumentCount,
            TagTypeArray,
            TagTypeCount,
            *TagArray
            );
    if (Error) {
        Free(*TagArray);
        *TagArray = NULL;
        if (Error == ERROR_INVALID_OPTION_TAG) {
            return ERROR_INVALID_SYNTAX;
        }
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

ULONG
ValidateTagTypeArray(
    TAG_TYPE TagTypeArray[],
    ULONG TagTypeCount
    )
{
    ULONG i;
    //
    // Verify that all required tokens are present.
    //
    for (i = 0; i < TagTypeCount; i++) {
        if ((TagTypeArray[i].dwRequired & NS_REQ_PRESENT)
         && !TagTypeArray[i].bPresent) {
            return ERROR_INVALID_SYNTAX;
        }
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\precomp.h ===
#define MAX_DLL_NAME 48

#include <windows.h>            // Include file for Windows applications
#include <winsock2.h>           // Interface to WinSock 2 API
#include <routprot.h>           // Interface to Router Manager
#include <iprtrmib.h>           // Interface to IP Router Manager's MIB
#include <netsh.h>              // Definitions needed by helper DLLs
#include <ipmontr.h>            // For helper DLLs registering under IPMONTR
#include <stdlib.h>

#include "ipsamplerm.h"         // Definitions and declarations for IPSAMPLE

#include "strdefs.h"
#include "prstring.h"
#include "common.h"
#include "utils.h"
#include "sample.h"
#include "samplecfg.h"
#include "samplegetopt.h"
#include "samplemib.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\ipsamplerm.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    ipsamplerm.h

Abstract:

    The file contains type definitions and declarations for SAMPLE, the
    sample ip protocol, used by the IP Router Manager.

--*/

#ifndef _IPSAMPLERM_H_
#define _IPSAMPLERM_H_


// useful for variable sized structs
#undef  ANY_SIZE
#define ANY_SIZE 0



//----------------------------------------------------------------------------
// CONSTANT AND MACRO DECLARATIONS
//----------------------------------------------------------------------------

#define PROTO_IP_SAMPLE 200
#define MS_IP_SAMPLE    \
PROTOCOL_ID(PROTO_TYPE_UCAST, PROTO_VENDOR_MS0, PROTO_IP_SAMPLE)

#define SAMPLE_PROTOCOL_MULTICAST_GROUP ((DWORD)0x640000E0) // 224.0.0.100
    
    
//----------------------------------------------------------------------------
// constants identifying IPSAMPLE's MIB tables
//----------------------------------------------------------------------------

#define IPSAMPLE_GLOBAL_STATS_ID        0
#define IPSAMPLE_GLOBAL_CONFIG_ID       1
#define IPSAMPLE_IF_STATS_ID            2
#define IPSAMPLE_IF_CONFIG_ID           3
#define IPSAMPLE_IF_BINDING_ID          4


//----------------------------------------------------------------------------
// constants used for the field IPSAMPLE_GLOBAL_CONFIG::dwLoggingLevel
//----------------------------------------------------------------------------

#define IPSAMPLE_LOGGING_NONE           0
#define IPSAMPLE_LOGGING_ERROR          1
#define IPSAMPLE_LOGGING_WARN           2
#define IPSAMPLE_LOGGING_INFO           3



//----------------------------------------------------------------------------
// constants used for the field IPSAMPLE_IF_CONFIG::ulMetric
//----------------------------------------------------------------------------

#define IPSAMPLE_METRIC_INFINITE        16

    
    
//----------------------------------------------------------------------------
// constants used to construct the field IPSAMPLE_IF_BINDING::dwState
//----------------------------------------------------------------------------
    
#define IPSAMPLE_STATE_ACTIVE           0x00000001
#define IPSAMPLE_STATE_BOUND            0x00000002
    


//----------------------------------------------------------------------------
// STRUCTURE DEFINITIONS
//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_GLOBAL_STATS
//
// This MIB entry stores global statistics for IPSAMPLE;
// There is only one instance, so this entry has no index.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_GLOBAL_STATS
{
    ULONG       ulNumInterfaces; // # interfaces added
} IPSAMPLE_GLOBAL_STATS, *PIPSAMPLE_GLOBAL_STATS;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_GLOBAL_CONFIG
//
// This MIB entry stores global configuration for IPSAMPLE
// There is only one instance, so this entry has no index.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_GLOBAL_CONFIG
{
    DWORD       dwLoggingLevel;
} IPSAMPLE_GLOBAL_CONFIG, *PIPSAMPLE_GLOBAL_CONFIG;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_STATS
//
// This MIB entry stores per-interface statistics for IPSAMPLE.
//
// This structure is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_STATS
{
    ULONG       ulNumPackets;   // # packets sent out this interface
} IPSAMPLE_IF_STATS, *PIPSAMPLE_IF_STATS;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_CONFIG
//
// This MIB entry describes per-interface configuration.
// All IP address fields must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_CONFIG
{
    ULONG       ulMetric;
} IPSAMPLE_IF_CONFIG, *PIPSAMPLE_IF_CONFIG;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IF_BINDING
//
// This MIB entry contains the table of IP addresses to which each
// interface is bound.  All IP addresses are in network order.
//
// THIS STRUCTURE IS VARIABLE LENGTH:
//
//  The base structure contains of the field ulCount, which gives the
//  number of IP addresses to which the indexed interface is bound.  The
//  IP addresses themselves follow the base structure, and are given as
//  IPSAMPLE_IP_ADDRESS structures.
//
// This MIB entry is read-only.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IF_BINDING
{
    DWORD       dwState;
    ULONG       ulCount;
} IPSAMPLE_IF_BINDING, *PIPSAMPLE_IF_BINDING;




//----------------------------------------------------------------------------
// struct:      IPSAMPLE_IP_ADDRESS
//
// This structure is used for storing interface bindings.  A series of
// structures of this type follows the IPSAMPLE_IF_BINDING structure
// (described above).
//
// Both fields are IP address fields in network-order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_IP_ADDRESS
{
    DWORD       dwAddress;
    DWORD       dwMask;
} IPSAMPLE_IP_ADDRESS, *PIPSAMPLE_IP_ADDRESS;



//----------------------------------------------------------------------------
// macros for manipulating the variable-length IPSAMPLE_IF_BINDING structure
//
// IPSAMPLE_IF_BINDING_SIZE computes the size of a binding structure.
//
// IPSAMPLE_IF_ADDRESS_TABLE computes the starting address in a binding
//      struct of the series of IPSAMPLE_IP_ADDRESS structures which are
//      the bindings for the interface in question.
//
// e.g.
//      PIPSAMPLE_IF_BINDING piibSource, piibDest;
//
//      piibDest = malloc(IPSAMPLE_IF_BINDING_SIZE(piibSource));
//      memcpy(piibDest, piibSource, IPSAMPLE_IF_BINDING_SIZE(piibSource));
//
// e.g.
//      ULONG                   i;
//      PIPSAMPLE_IF_BINDING    piib;
//      PIPSAMPLE_IP_ADDRESS    *piia;
//
//      piia = IPSAMPLE_IF_ADDRESS_TABLE(piib);
//      for (i = 0; i < piib->ulCount; i++)
//      {
//          printf("%s-", inet_ntoa(*(struct in_addr *)&piia->dwAddress));
//          printf("%s\n", inet_ntoa(*(struct in_addr *)&piia->dwMask));
//      }
//----------------------------------------------------------------------------

#define IPSAMPLE_IF_BINDING_SIZE(bind)                          \
    (sizeof(IPSAMPLE_IF_BINDING) +                              \
     (bind)->ulCount * sizeof(IPSAMPLE_IP_ADDRESS))

#define IPSAMPLE_IF_ADDRESS_TABLE(bind)                         \
    ((PIPSAMPLE_IP_ADDRESS)((bind) + 1))

        

//----------------------------------------------------------------------------
// The following structures are used to query the MIB and get back a
// response.  The TypeID field is one of the IDs #defined above.  The
// IfIndex is used to reference an interface table entry .  For sample
// it corresponds to an ip address, and hence is a single DWORD for now.
// In general the index could be a variable size array of DWORDs.
//----------------------------------------------------------------------------

        

//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_SET_INPUT_DATA
//
// This is passed as input data for MibSet.
// Note that only global config and interface config can be set.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_SET_INPUT_DATA
{
    DWORD       IMSID_TypeID;
    DWORD       IMSID_IfIndex;
    DWORD       IMSID_BufferSize;
    BYTE        IMSID_Buffer[ANY_SIZE];
} IPSAMPLE_MIB_SET_INPUT_DATA, *PIPSAMPLE_MIB_SET_INPUT_DATA;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_GET_INPUT_DATA
//
// This is passed as input data for MibGet, MibGetFirst, MibGetNext.  All
// tables are readable.  All IP addresses must be in network order.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_GET_INPUT_DATA
{
    DWORD   IMGID_TypeID;
    DWORD   IMGID_IfIndex;
} IPSAMPLE_MIB_GET_INPUT_DATA, *PIPSAMPLE_MIB_GET_INPUT_DATA;



//----------------------------------------------------------------------------
// struct:      IPSAMPLE_MIB_GET_OUTPUT_DATA
//
// This is written into the output data by MibGet, MibGetFirst, MibGetNext.
//----------------------------------------------------------------------------

typedef struct _IPSAMPLE_MIB_GET_OUTPUT_DATA
{
    DWORD   IMGOD_TypeID;
    DWORD   IMGOD_IfIndex;

    BYTE    IMGOD_Buffer[ANY_SIZE];
} IPSAMPLE_MIB_GET_OUTPUT_DATA, *PIPSAMPLE_MIB_GET_OUTPUT_DATA;

#endif // _IPSAMPLERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\common.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\common.c

Abstract:

    The file contains interactions with netsh and functions common across
    all contexts registered by this helper DLL (IPSAMPLEMON).

--*/

#include "precomp.h"
#pragma hdrstop

// statics
static const GUID g_IpGuid = IPMONTR_GUID;

// generate a new GUID for each helper (uuidgen)
// aedb0ad8-1496-11d3-8005-08002bc35d9c
static const GUID g_MyGuid = 
{ 0xaedb0ad8, 0x1496, 0x11d3, {0x80, 0x5, 0x8, 0x0, 0x2b, 0xc3, 0x5d, 0x9c} };



// globals...

// variables                        
HANDLE                              g_hModule;      // set by DllMain 

DWORD
WINAPI
IpsamplemonStartHelper(
    IN  CONST   GUID        *pguidParent,
    IN          DWORD       dwVersion
    )
/*++

Routine Description
    Registers contexts.  Called by netsh to start helper.

Arguments
    pguidParent         GUID of parent helper (IPMON)
    dwVersion           Version number of parent helper

Return Value

    Error code returned from registering last context.

--*/    
{
    DWORD                   dwErr;

    // the following types depend on the parent helper (IPMON)
    IP_CONTEXT_ATTRIBUTES   icaMyAttributes;
    
    // register the SAMPLE context
    SampleInitialize();         // initialize sample's global information
    ZeroMemory(&icaMyAttributes, sizeof(icaMyAttributes));
    
    icaMyAttributes.guidHelper  = g_MyGuid;             // context's helper
    icaMyAttributes.dwVersion   = g_ceSample.dwVersion;
    icaMyAttributes.pwszContext = g_ceSample.pwszName;
    icaMyAttributes.pfnDumpFn   = g_ceSample.pfnDump;
    icaMyAttributes.ulNumTopCmds= g_ceSample.ulNumTopCmds;
    icaMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])
        g_ceSample.pTopCmds;
    icaMyAttributes.ulNumGroups = g_ceSample.ulNumGroupCmds;
    icaMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])
        g_ceSample.pGroupCmds;

    dwErr = RegisterContext(&icaMyAttributes);

    return dwErr;
}



DWORD
WINAPI
InitHelperDll(
    IN  DWORD              dwNetshVersion,
    OUT PNS_DLL_ATTRIBUTES pDllTable
    )
/*++

Routine Description
    Registers helper.  Called by netsh.

Arguments
    pUtilityTable           netsh functions
    pDllTable               DLL attributes

Return Value
    Error code returned from registering helper.

--*/
{
    DWORD                   dwErr;
    NS_HELPER_ATTRIBUTES    nhaMyAttributes;

    pDllTable->dwVersion                        = NETSH_VERSION_50;
    pDllTable->pfnStopFn                        = NULL;

    // Register helper.  One option is to register a single helper that
    // registers a context for each protocol supported.  Alternatively we
    // could register a different helper for each protocol, where each
    // helper registers a single context.  There's only a difference if we
    // support sub-helpers.  Since a sub-helper registers with a parent
    // helper, not a parent context, it is valid in every context its
    // parent helper registers.

    ZeroMemory(&nhaMyAttributes, sizeof(NS_HELPER_ATTRIBUTES));

    // attributes of this helper

    // version
    nhaMyAttributes.guidHelper                  = g_MyGuid;
    nhaMyAttributes.dwVersion                   = SAMPLE_HELPER_VERSION;

    // start function
    nhaMyAttributes.pfnStart                    = IpsamplemonStartHelper;

    // define stop function if need to perform cleanup before unload
    nhaMyAttributes.pfnStop                     = NULL;
    
    dwErr = RegisterHelper(&g_IpGuid, // GUID of parent helper (IPMON)
                           &nhaMyAttributes);

    return dwErr;
}



BOOL
WINAPI
DllMain(
    IN  HINSTANCE           hInstance,
    IN  DWORD               dwReason,
    IN  PVOID               pvImpLoad
    )
/*++

Routine Description
    DLL entry and exit point handler.

Arguments
    hInstance   Instance handle of DLL
    dwReason    Reason function called
    pvImpLoad   Implicitly loaded DLL?

Return Value
    TRUE        Successfully loaded DLL

--*/
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hModule = hInstance;
            DisableThreadLibraryCalls(hInstance);
            break;

        case DLL_PROCESS_DETACH:
            break;

        default:

            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\sample.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sample.c

Abstract:

    The file contains the command dispatcher for the sample IP protocol.
    
--*/

#include "precomp.h"
#pragma hdrstop


// global information for the sample context
CONTEXT_ENTRY                   g_ceSample;

////////////////////////////////////////
// Configuration Data For Sample
////////////////////////////////////////

// default global configuration
static IPSAMPLE_GLOBAL_CONFIG   isDefaultGlobal =
{
    IPSAMPLE_LOGGING_INFO               // tag LOGLEVEL
};

// default interface configuration
static IPSAMPLE_IF_CONFIG       isDefaultInterface =
{
    0                                   // tag METRIC
};


// table of ADD commands
static CMD_ENTRY                isAddCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_ADD_IF,             HandleSampleAddIf),
};

// table of DELETE commands
static CMD_ENTRY                isDeleteCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_DEL_IF,             HandleSampleDelIf),
};

// table of SET commands
static CMD_ENTRY                isSetCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_SET_GLOBAL,         HandleSampleSetGlobal),
    CREATE_CMD_ENTRY(SAMPLE_SET_IF,             HandleSampleSetIf),
};

// table of SHOW commands
static CMD_ENTRY                isShowCmdTable[] =
{
    CREATE_CMD_ENTRY(SAMPLE_SHOW_GLOBAL,        HandleSampleShowGlobal),
    CREATE_CMD_ENTRY(SAMPLE_SHOW_IF,            HandleSampleShowIf),
    CREATE_CMD_ENTRY(SAMPLE_MIB_SHOW_STATS,     HandleSampleMibShowObject),
    CREATE_CMD_ENTRY(SAMPLE_MIB_SHOW_IFSTATS,   HandleSampleMibShowObject),
    CREATE_CMD_ENTRY(SAMPLE_MIB_SHOW_IFBINDING, HandleSampleMibShowObject),
};

// table of above group commands
static CMD_GROUP_ENTRY          isGroupCmds[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_ADD,           isAddCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_DELETE,        isDeleteCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SET,           isSetCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,          isShowCmdTable),
};


// table of top commands (non group)
static CMD_ENTRY                isTopCmds[] =
{
    CREATE_CMD_ENTRY(INSTALL,                   HandleSampleInstall),
    CREATE_CMD_ENTRY(UNINSTALL,                 HandleSampleUninstall),
};


// dump function
DWORD
WINAPI
SampleDump(
    IN  LPCWSTR pwszMachine,
    IN  WCHAR   **ppwcArguments,
    IN  DWORD   dwArgCount,
    IN  PVOID   pvData
    )
{
    DWORD   dwErr;
    HANDLE  hFile = (HANDLE)-1;

    DisplayMessage(g_hModule, DMP_SAMPLE_HEADER);
    DisplayMessageT(DMP_SAMPLE_PUSHD);
    DisplayMessageT(DMP_SAMPLE_UNINSTALL);

    // dump SAMPLE global configuration
    SgcShow(FORMAT_DUMP) ;
    // dump SAMPLE configuration for all interfaces
    SicShowAll(FORMAT_DUMP) ;

    DisplayMessageT(DMP_POPD);
    DisplayMessage(g_hModule, DMP_SAMPLE_FOOTER);

    return NO_ERROR;
}



VOID
SampleInitialize(
    )
/*++

Routine Description
    Initialize sample's information.  Called by IpsamplemonStartHelper.

Arguments
    None

Return Value
    None

--*/
{
    // context version
    g_ceSample.dwVersion        = SAMPLE_CONTEXT_VERSION;

    // context identifying string
    g_ceSample.pwszName         = TOKEN_SAMPLE;
    
    // top level (non group) commands
    g_ceSample.ulNumTopCmds     = sizeof(isTopCmds)/sizeof(CMD_ENTRY);
    g_ceSample.pTopCmds         = isTopCmds;
            
    // group commands
    g_ceSample.ulNumGroupCmds   = sizeof(isGroupCmds)/sizeof(CMD_GROUP_ENTRY);
    g_ceSample.pGroupCmds       = isGroupCmds;

    // default configuration
    g_ceSample.pDefaultGlobal   = (PBYTE) &isDefaultGlobal;
    g_ceSample.pDefaultInterface= (PBYTE) &isDefaultInterface;

    // dump function
    g_ceSample.pfnDump          = SampleDump;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\prstring.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\prstring.h

Abstract:

    The file contains definitions of command line option tag strings.

--*/

////////////////////////////////////////
// TOKENS
////////////////////////////////////////

#define TOKEN_SAMPLE                        L"sample"

#define MSG_HELP_START                      L"%1!-14s! - "

// Loglevels
#define TOKEN_NONE                          L"NONE"
#define TOKEN_ERROR                         L"ERROR"
#define TOKEN_WARN                          L"WARN"
#define TOKEN_INFO                          L"INFO"

// Tokens for sample global options
#define TOKEN_LOGLEVEL                      L"loglevel"

// Tokens for sample interface options
#define TOKEN_NAME                          L"name"
#define TOKEN_METRIC                        L"metric"

// Tokens for sample mib commands
#define TOKEN_GLOBALSTATS                   L"globalstats"
#define TOKEN_IFSTATS                       L"ifstats"
#define TOKEN_IFBINDING                     L"ifbinding"

#define TOKEN_INDEX                         L"index"
#define TOKEN_RR                            L"rr"



////////////////////////////////////////
// Configuration commands
////////////////////////////////////////

// Commands supported by most protocols
#define CMD_INSTALL                         L"install"
#define CMD_UNINSTALL                       L"uninstall"
#define CMD_DUMP                            L"dump"
#define CMD_HELP1                           L"help"
#define CMD_HELP2                           L"?"

#define CMD_GROUP_ADD                       L"add"
#define CMD_GROUP_DELETE                    L"delete"
#define CMD_GROUP_SET                       L"set"
#define CMD_GROUP_SHOW                      L"show"


// Commands supported by SAMPLE

// add commands
#define CMD_SAMPLE_ADD_IF                   L"interface"


// delete commands
#define CMD_SAMPLE_DEL_IF                   L"interface"


// set commands
#define CMD_SAMPLE_SET_GLOBAL               L"global"
#define CMD_SAMPLE_SET_IF                   L"interface"


// show commands
#define CMD_SAMPLE_SHOW_GLOBAL              L"global"
#define CMD_SAMPLE_SHOW_IF                  L"interface"
#define CMD_SAMPLE_MIB_SHOW_STATS           L"globalstats"
#define CMD_SAMPLE_MIB_SHOW_IFSTATS         L"ifstats"
#define CMD_SAMPLE_MIB_SHOW_IFBINDING       L"ifbinding"



////////////////////////////////////////
// Dump information
////////////////////////////////////////

#define DMP_POPD                            L"popd\n"
#define DMP_SAMPLE_PUSHD                    L"pushd routing ip sample\n"

#define DMP_SAMPLE_INSTALL                  L"install\n"
#define DMP_SAMPLE_UNINSTALL                L"uninstall\n"

#define DMP_SAMPLE_ADD_INTERFACE            L"\
add interface name=%1!s! metric=%2!u!\n"
#define DMP_SAMPLE_SET_GLOBAL               L"\
set global loglevel=%1!s!\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\samplecfg.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplecfg.c

Abstract:

    The file contains functions to change configuration for IP SAMPLE.

--*/

#include "precomp.h"
#pragma hdrstop


DWORD
SgcMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    )
/*++
  
Routine Description:
    Creates a SAMPLE global configuration block.
    Callee should take care to deallocate the configuration block once done.
    
Arguments:
    ppbStart                    pointer to the configuration block address
    pdwSize                     pointer to size of the configuration block
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPSAMPLE_GLOBAL_CONFIG);

    *ppbStart = MALLOC(*pdwSize);
    if (*ppbStart is NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    
    CopyMemory(*ppbStart, g_ceSample.pDefaultGlobal, *pdwSize);
    return NO_ERROR;
}



DWORD
SgcShow (
    IN  FORMAT                  fFormat
    )
/*++

Routine Description:
    Displays SAMPLE global configuration.
    Used for dump as well as show commands.

Arguments:
    hFile                       NULL, or dump file handle

Return Value:
    NO_ERROR
    
--*/
{
    DWORD                       dwErr = NO_ERROR;

    PIPSAMPLE_GLOBAL_CONFIG     pigc = NULL;
    DWORD                       dwBlockSize, dwNumBlocks;
    PWCHAR                      pwszLogLevel = NULL;

    VALUE_TOKEN                 vtLogLevelTable[] =
    {
        IPSAMPLE_LOGGING_NONE,  TOKEN_NONE,
        IPSAMPLE_LOGGING_ERROR, TOKEN_ERROR,
        IPSAMPLE_LOGGING_WARN,  TOKEN_WARN,
        IPSAMPLE_LOGGING_INFO,  TOKEN_INFO
    };
    VALUE_STRING                vsLogLevelTable[] =
    {
        IPSAMPLE_LOGGING_NONE,  STRING_LOGGING_NONE,
        IPSAMPLE_LOGGING_ERROR, STRING_LOGGING_ERROR,
        IPSAMPLE_LOGGING_WARN,  STRING_LOGGING_WARN,
        IPSAMPLE_LOGGING_INFO,  STRING_LOGGING_INFO
    };

    
    do                          // breakout loop
    {
        // get global configuration
        dwErr = GetGlobalConfiguration(MS_IP_SAMPLE,
                                       (PBYTE *) &pigc,
                                       &dwBlockSize,
                                       &dwNumBlocks);
        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_NOT_FOUND)
                dwErr = EMSG_PROTO_NO_GLOBAL_CONFIG;
            break;
        }

        // getting logging mode string
        dwErr = GetString(g_hModule,
                          fFormat,
                          pigc->dwLoggingLevel,
                          vtLogLevelTable,
                          vsLogLevelTable,
                          NUM_VALUES_IN_TABLE(vtLogLevelTable),
                          &pwszLogLevel);
        if (dwErr isnot NO_ERROR)
            break;

        // dump or show
        if (fFormat is FORMAT_DUMP)
        {
            // dump SAMPLE global configuration
            DisplayMessageT(DMP_SAMPLE_INSTALL) ;
            DisplayMessageT(DMP_SAMPLE_SET_GLOBAL,
                            pwszLogLevel);
        } else {
            // show SAMPLE global configuration
            DisplayMessage(g_hModule,
                           MSG_SAMPLE_GLOBAL_CONFIG,
                           pwszLogLevel);
        }

        dwErr = NO_ERROR;
    } while (FALSE);

    // deallocate memory
    if (pigc) FREE(pigc);
    if (pwszLogLevel) FreeString(pwszLogLevel);

    if (dwErr isnot NO_ERROR)
    {
        // display error message.  We first search for the error code in
        // the module specified by the caller (if one is specified).  If no
        // module is given, or the error code doesnt exist we look for MPR
        // errors, RAS errors and Win32 errors - in that order.
        if (fFormat isnot FORMAT_DUMP) DisplayError(g_hModule, dwErr);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }

    return dwErr;
}



DWORD
SgcUpdate (
    IN  PIPSAMPLE_GLOBAL_CONFIG pigcNew,
    IN  DWORD                   dwBitVector
    )
/*++

Routine Description:
    Updates SAMPLE global configuration

Arguments:
    pigcNew                     new values to be set
    dwBitVector                 which fields need to be modified
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    DWORD                   dwErr = NO_ERROR;
    PIPSAMPLE_GLOBAL_CONFIG pigc = NULL;
    DWORD                   dwBlockSize, dwNumBlocks;


    // no updates required
    if (dwBitVector is 0)
        return NO_ERROR;
    
    do                          // breakout loop
    {
        // get global configuration
        dwErr = GetGlobalConfiguration(MS_IP_SAMPLE,
                                       (PBYTE *) &pigc,
                                       &dwBlockSize,
                                       &dwNumBlocks);
        if (dwErr isnot NO_ERROR)
            break;

        // can be updated in place since only fixed sized fields
        if (dwBitVector & SAMPLE_LOG_MASK)
            pigc->dwLoggingLevel = pigcNew->dwLoggingLevel;

        // set the new configuration
        dwErr = SetGlobalConfiguration(MS_IP_SAMPLE,
                                       (PBYTE) pigc,
                                       dwBlockSize,
                                       dwNumBlocks);
        if (dwErr isnot NO_ERROR)
            break;
    } while (FALSE);

    // deallocate memory
    if (pigc) FREE(pigc);
    
    return dwErr;
}



DWORD
SicMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    )
/*++

Routine Description:
    Creates a SAMPLE interface configuration block.
    Callee should take care to deallocate the configuration block once done.

Arguments:
    ppbStart                    pointer to the configuration block address
    pdwSize                     pointer to size of the configuration block
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    *pdwSize = sizeof(IPSAMPLE_IF_CONFIG);

    *ppbStart = MALLOC(*pdwSize);
    if (*ppbStart is NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(*ppbStart, g_ceSample.pDefaultInterface, *pdwSize);

    return NO_ERROR;
}



DWORD
SicShowAll (
    IN  FORMAT                  fFormat
    )
/*++

Routine Description:
    Displays SAMPLE configuration for all interfaces.
    Used for dump as well as show commands.

Arguments:
    fFormat                     TABLE or DUMP
    
--*/
{
    DWORD               dwErr = NO_ERROR;
    BOOL                bSomethingDisplayed = FALSE;

    PMPR_INTERFACE_0    pmi0;
    DWORD               dwCount, dwTotal;

    ULONG               i;


    // enumerate all interfaces
    dwErr = IpmontrInterfaceEnum((PBYTE *) &pmi0, &dwCount, &dwTotal);
    if (dwErr isnot NO_ERROR)
    {
        if (fFormat isnot FORMAT_DUMP) DisplayError(g_hModule, dwErr);
        return ERROR_SUPPRESS_OUTPUT;
    }

    for(i = 0; i < dwCount; i++)
    {
        // make sure that SAMPLE is configured on that interface
        if (IsInterfaceInstalled(pmi0[i].wszInterfaceName, MS_IP_SAMPLE))
        {
            // print table header if first entry
            if (!bSomethingDisplayed and (fFormat is FORMAT_TABLE))
                DisplayMessage(g_hModule, MSG_SAMPLE_IF_CONFIG_HEADER);
            bSomethingDisplayed = TRUE;
            
            SicShow(fFormat, pmi0[i].wszInterfaceName);
        }
    }

    return bSomethingDisplayed ? NO_ERROR : ERROR_OKAY;
}




DWORD
SicShow (
    IN  FORMAT                  fFormat,
    IN  LPCWSTR                 pwszInterfaceGuid
    )
/*++

Routine Description:
    Displays SAMPLE configuration for an interface.
    Used for dump as well as show commands.

Arguments:
    pwszInterfaceGuid           interface name
    
--*/
{
    DWORD               dwErr = NO_ERROR;
    
    PIPSAMPLE_IF_CONFIG piic = NULL;
    DWORD               dwBlockSize, dwNumBlocks, dwIfType;

    PWCHAR  pwszInterfaceName = NULL;

    
    do                          // breakout loop
    {
        // get interface configuration
        dwErr = GetInterfaceConfiguration(pwszInterfaceGuid,
                                          MS_IP_SAMPLE,
                                          (PBYTE *) &piic,
                                          &dwBlockSize,
                                          &dwNumBlocks,
                                          &dwIfType);
        if (dwErr isnot NO_ERROR)
        {
            if (dwErr is ERROR_NOT_FOUND)
                dwErr = EMSG_PROTO_NO_IF_CONFIG;
            break;
        }

        // get quoted friendly name for interface
        dwErr = QuotedInterfaceNameFromGuid(pwszInterfaceGuid,
                                            &pwszInterfaceName);
        if (dwErr isnot NO_ERROR)
            break;

        // dump or show
        switch(fFormat)
        {
            case FORMAT_DUMP:   // dump SAMPLE interface configuration
                DisplayMessage(g_hModule,
                               DMP_SAMPLE_INTERFACE_HEADER,
                               pwszInterfaceName);
                DisplayMessageT(DMP_SAMPLE_ADD_INTERFACE,
                                pwszInterfaceName,
                                piic->ulMetric);
                break;

            case FORMAT_TABLE:  // show sample interface configuration
                DisplayMessage(g_hModule,
                               MSG_SAMPLE_IF_CONFIG_ENTRY,
                               pwszInterfaceName,
                               piic->ulMetric);
                break;
                
            case FORMAT_VERBOSE: // show sample interface configuration
                DisplayMessage(g_hModule,
                               MSG_SAMPLE_IF_CONFIG,
                               pwszInterfaceName,
                               piic->ulMetric);
                break;
        }
    } while (FALSE);

    // deallocate memory
    if (piic) FREE(piic);
    if (pwszInterfaceName)
        FreeQuotedString(pwszInterfaceName);

    // display error message.
    if (dwErr isnot NO_ERROR)
    {
        if (fFormat isnot FORMAT_DUMP) DisplayError(g_hModule, dwErr);
        dwErr = ERROR_SUPPRESS_OUTPUT;
    }
    
    return dwErr;
}



DWORD
SicUpdate (
    IN  LPCWSTR                 pwszInterfaceGuid,
    IN  PIPSAMPLE_IF_CONFIG     piicNew,
    IN  DWORD                   dwBitVector,
    IN  BOOL                    bAdd
    )
/*++

Routine Description:
    Updates SAMPLE interface configuration

Arguments:
    pwszInterfaceGuid           interface name
    piicNew                     the changes to be applied
    dwBitVector                 which fields need to be modified
    bAdd                        interface being added (TRUE) or set (FALSE)
    
Return Value:
    NO_ERROR, ERROR_NOT_ENOUGH_MEMORY
    
--*/
{
    DWORD               dwErr = NO_ERROR;
    PIPSAMPLE_IF_CONFIG piic = NULL;
    DWORD               dwBlockSize, dwNumBlocks, dwIfType;

    do                          // breakout loop
    {
        if (bAdd)
        {
            // create default protocol interface configuration
            dwNumBlocks = 1;
            dwErr = SicMake((PBYTE *)&piic, &dwBlockSize);
            if (dwErr isnot NO_ERROR)
                break;
        } else {
            // get current protocol interface configuration
            dwErr = GetInterfaceConfiguration(pwszInterfaceGuid,
                                              MS_IP_SAMPLE,
                                              (PBYTE *) &piic,
                                              &dwBlockSize,
                                              &dwNumBlocks,
                                              &dwIfType);
            if (dwErr isnot NO_ERROR)
            {
                if (dwErr is ERROR_NOT_FOUND)
                {
                    DisplayError(g_hModule, EMSG_PROTO_NO_IF_CONFIG);
                    dwErr = ERROR_SUPPRESS_OUTPUT;
                }
                break;
            }
        }

        // can be updated in place since only fixed sized fields
        if (dwBitVector & SAMPLE_IF_METRIC_MASK)
            piic->ulMetric = piicNew->ulMetric;

        // set the new configuration
        dwErr = SetInterfaceConfiguration(pwszInterfaceGuid,
                                          MS_IP_SAMPLE,
                                          (PBYTE) piic,
                                          dwBlockSize,
                                          dwNumBlocks);        
        if (dwErr isnot NO_ERROR)
            break;
    } while (FALSE);
    
    // deallocate memory
    if (piic) FREE(piic);
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\samplecfg.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplecfg.h

Abstract:

    The file contains the include file for samplecfg.c.

--*/

// sample global configuration

DWORD
SgcMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    );

DWORD
SgcShow (
    IN  FORMAT                  fFormat
    );

DWORD
SgcUpdate (
    IN  PIPSAMPLE_GLOBAL_CONFIG pigcNew,
    IN  DWORD                   dwBitVector
    );



// sample interface configuration

DWORD
SicMake (
    OUT PBYTE                   *ppbStart,
    OUT PDWORD                  pdwSize
    );

DWORD
SicShowAll (
    IN  FORMAT                  fFormat
    );

DWORD
SicShow (
    IN  FORMAT                  fFormat,
    IN  LPCWSTR                 pwszInterfaceGuid
    );

DWORD
SicUpdate (
    IN  PWCHAR                  pwszInterfaceGuid,
    IN  PIPSAMPLE_IF_CONFIG     piicNew,
    IN  DWORD                   dwBitVector,
    IN  BOOL                    bAdd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\sample.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\sample.h

Abstract:

    The file contains the header for sample.c,
    the command dispatcher for the sample IP protocol.

--*/

// functions...
VOID
SampleInitialize(
    );



// typedefs...
typedef struct _CONTEXT_ENTRY   // global information for a context
{
    // context' version
    DWORD               dwVersion;

    // context' identifying string
    PWSTR               pwszName;

    // top level (non group) commands
    ULONG               ulNumTopCmds;
    CMD_ENTRY           *pTopCmds;

    // group commands
    ULONG               ulNumGroupCmds;
    CMD_GROUP_ENTRY     *pGroupCmds;

    // default configuration
    PBYTE               pDefaultGlobal;
    PBYTE               pDefaultInterface;

    // dump function
    PNS_CONTEXT_DUMP_FN pfnDump;
} CONTEXT_ENTRY, *PCONTEXT_ENTRY;



// globals...

// information for the sample context
CONTEXT_ENTRY                           g_ceSample;



// constants...

// context's version
#define SAMPLE_CONTEXT_VERSION          1

// parameters passed to set global...
#define SAMPLE_LOG_MASK                 0x00000001

// parameters passed to add/set interface
#define SAMPLE_IF_METRIC_MASK           0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\samplegetopt.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplegetopt.c

Abstract:

    The file contains functions to handle SAMPLE commands.

    All command handlers take the following parameters...
    pwszMachineName     
    *ppwcArguments      argument array
    dwCurrentIndex      ppwcArguments[dwCurrentIndex] is the first argument
    dwArgCount          ppwcArguments[dwArgCount - 1] is the last argument
    dwFlags
    hMibServer
    *pbDone

    
    The handlers return the following values
    Success...
    NO_ERROR                command succeeded, don't display another message.
    ERROR_OKAY              command succeeded, display "Ok." message.

    Failure...
    ERROR_SUPPRESS_OUTPUT   command failed, don't display another message.
    ERROR_SHOW_USAGE        display extended help for the command.
    ERROR_INVALID_SYNTAX    display invalid syntax message and extended help.

    
    The command handlers call the following function to parse arguments
    PreprocessCommand(
        IN  HANDLE    hModule,          // handle passed to DllMain
        IN  PCHAR     *ppwcArguments,   // argument array
        IN  DWORD     dwCurrentIndex,   // ppwcArguments[dwCurrentIndex]: first
        IN  DWORD     dwArgCount,       // ppwcArguments[dwArgCount-1]  : last
        IN  TAG_TYPE  *pttTags,         // legal tags
        IN  DWORD     dwTagCount,       // # entries in pttTags
        IN  DWORD     dwMinArgs,        // min # arguments required
        IN  DWORD     dwMaxArgs,        // max # arguments required
        OUT DWORD     *pdwTagType       // output
        )
    The preprocessor performs the following functions
    . ensures the number of tags present is valid.
    . ensures there are no duplicate or unrecognized tags.
    . ensures every 'required' tag is present.
    . leaves the tag index of each argument in pdwTagType.
    . removes 'tag='  from each argument.

    
    For tags that take a specific set of values, this function is called
    MatchEnumTag(
        IN  HANDLE          hModule,    // handle passed to DllMain
        IN  LPWSTR          pwcArgument,// argument to process 
        IN  DWORD           dwNumValues,// number of possible values 
        IN  PTOKEN_VALUE    pEnumTable, // array of possible values
        OUT PDWORD          pdwValue    // output
        )
    This performs the following functions
    . matches argument with the set of values specified.
    . returns corresponding value.
        
--*/

#include "precomp.h"
#pragma hdrstop

DWORD
WINAPI
HandleSampleSetGlobal(
    IN      LPCWSTR                 pwszMachineName,
    IN OUT  LPWSTR                 *ppwcArguments,
    IN      DWORD                   dwCurrentIndex,
    IN      DWORD                   dwArgCount,
    IN      DWORD                   dwFlags,
    IN      MIB_SERVER_HANDLE       hMibServer,
    IN      BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SET GLOBAL

--*/
{
    DWORD                   dwErr = NO_ERROR;
    
    TAG_TYPE                pttTags[] =
    {
        {TOKEN_LOGLEVEL,    FALSE,  FALSE}  // LOGLEVEL tag optional
    };
    DWORD                   pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];
    DWORD                   dwNumArg;
    ULONG                   i;
    
    IPSAMPLE_GLOBAL_CONFIG  igcGlobalConfiguration;
    DWORD                   dwBitVector = 0;
    

    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // preprocess the command
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              NUM_TAGS_IN_TABLE(pttTags),
                              0,
                              NUM_TAGS_IN_TABLE(pttTags),
                              pdwTagType);
    if (dwErr isnot NO_ERROR)
        return dwErr;

    // process all arguments
    dwNumArg = dwArgCount - dwCurrentIndex;
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                // tag LOGLEVEL
                DWORD       dwLogLevel;
                TOKEN_VALUE rgtvEnums[] = 
                {
                    {TOKEN_NONE,    IPSAMPLE_LOGGING_NONE},
                    {TOKEN_ERROR,   IPSAMPLE_LOGGING_ERROR},
                    {TOKEN_WARN,    IPSAMPLE_LOGGING_WARN},
                    {TOKEN_INFO,    IPSAMPLE_LOGGING_INFO}
                };
                
                dwErr = MatchEnumTag(g_hModule,
                                     ppwcArguments[i + dwCurrentIndex],
                                     NUM_TOKENS_IN_TABLE(rgtvEnums),
                                     rgtvEnums,
                                     &dwLogLevel);                
                if (dwErr isnot NO_ERROR)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }    

                igcGlobalConfiguration.dwLoggingLevel = dwLogLevel;
                dwBitVector |= SAMPLE_LOG_MASK;
                break;
            }
            
            default:
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        } // switch

        if (dwErr isnot NO_ERROR)
            break ;
    } // for


    // process error
    if (dwErr isnot NO_ERROR)
    {
        ProcessError();
        return dwErr;
    }
    
    // update SAMPLE global configuration
    if (dwBitVector)
        dwErr = SgcUpdate(&igcGlobalConfiguration, dwBitVector);

    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr ;
}



DWORD
WINAPI
HandleSampleShowGlobal(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description:
    Gets options for SHOW GLOBAL
    
--*/
{
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // does not expect any arguments. report error if any specified.
    if (dwCurrentIndex isnot dwArgCount)
        return ERROR_INVALID_SYNTAX;

    // show SAMPLE global configuration
    return SgcShow(FORMAT_VERBOSE);
}



DWORD
GetInterfaceOptions(
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    OUT PWCHAR                  pwszInterfaceGuid,
    OUT PIPSAMPLE_IF_CONFIG     piicNew,
    OUT DWORD                   *pdwBitVector
    )
/*++

Routine Description:
    Gets options for SET INTERFACE and ADD INTERFACE.

Arguments:
    pwszInterfaceGuid           guid for the specified interface. Size of this
                                buffer should be
                                (MAX_INTERFACE_NAME_LEN+1)*sizeof(WCHAR)
    piicNew                     configuration containing changed values
    pdwBitVector                which values have changed

--*/
{
    DWORD                   dwErr = NO_ERROR;
    
    TAG_TYPE                pttTags[] =
    {
        {TOKEN_NAME,        TRUE,   FALSE}, // NAME tag required 
        {TOKEN_METRIC,      FALSE,  FALSE}, // METRIC tag optional
    };
    DWORD                   pdwTagType[NUM_TAGS_IN_TABLE(pttTags)];
    DWORD                   dwNumArg;
    DWORD                   dwBufferSize = MAX_INTERFACE_NAME_LEN + 1;
    ULONG                   i;
    
    // dwBufferSize is the size of the pwszInterfaceGuid buffer. 
    // All invocations of this api should pass in a 
    // (MAX_INTERFACE_NAME_LEN+1) element array of WCHARs as 
    // the pwszInterfaceGuid parameter.
    dwBufferSize = (MAX_INTERFACE_NAME_LEN + 1)*sizeof(WCHAR);

    // preprocess the command
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              NUM_TAGS_IN_TABLE(pttTags),
                              1,
                              NUM_TAGS_IN_TABLE(pttTags),
                              pdwTagType);
    if (dwErr isnot NO_ERROR)
        return dwErr;

    // process all arguments
    dwNumArg = dwArgCount - dwCurrentIndex;
    for (i = 0; i < dwNumArg; i++)
    {
        switch (pdwTagType[i])
        {
            case 0 :
            {
                // tag NAME
                dwErr = InterfaceGuidFromName(
                    ppwcArguments[i+dwCurrentIndex],
                    pwszInterfaceGuid,
                    &dwBufferSize);
                break;
            }
            
            case 1:
            {
                // tag METRIC
                piicNew->ulMetric = wcstoul(ppwcArguments[i+dwCurrentIndex],
                                            NULL,
                                            10);
                *pdwBitVector |= SAMPLE_IF_METRIC_MASK;
                break;
            }
            
            default:
            {
                dwErr = ERROR_INVALID_SYNTAX;
                break;
            }
        } // switch

        if (dwErr isnot NO_ERROR)
            break ;
    } // for

    
    // process error
    if (dwErr isnot NO_ERROR)
        ProcessError();

    return dwErr;
}



DWORD
WINAPI
HandleSampleAddIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for ADD INTERFACE 

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // get optional parameters that are also being set
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);
    if (dwErr isnot NO_ERROR)
        return dwErr;
    
    // make sure that the interface does not already exist in the config
    if (IsInterfaceInstalled(pwszInterfaceGuid, MS_IP_SAMPLE))
    {
        DisplayError(g_hModule, EMSG_INTERFACE_EXISTS, pwszInterfaceGuid);
        return ERROR_SUPPRESS_OUTPUT;
    }

    // add SAMPLE interface configuration
    dwErr = SicUpdate(pwszInterfaceGuid, &iicNew, dwBitVector, TRUE);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleDelIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for DELETE INTERFACE 

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // get interface name.
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);

    if (dwErr isnot NO_ERROR)
        return dwErr ;
    if (dwBitVector)            // ensure that no other option is set.
        return ERROR_INVALID_SYNTAX;

    // delete interface
    dwErr = DeleteInterfaceConfiguration(pwszInterfaceGuid, MS_IP_SAMPLE);

    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleSetIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SET INTERFACE 

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;


    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    // get parameters being set
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);
    if (dwErr isnot NO_ERROR)
        return dwErr;
    
    // set SAMPLE interface configuration
    dwErr = SicUpdate(pwszInterfaceGuid, &iicNew, dwBitVector, FALSE);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleShowIf(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SHOW INTERFACE

--*/
{
    DWORD               dwErr = NO_ERROR;
    WCHAR               pwszInterfaceGuid[MAX_INTERFACE_NAME_LEN + 1] = L"\0";
    IPSAMPLE_IF_CONFIG  iicNew;
    DWORD               dwBitVector = 0;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    
    // no interface specified, show SAMPLE configuration for all interfaces
    if (dwCurrentIndex is dwArgCount)
        return SicShowAll(FORMAT_TABLE) ;

    
    // get interface name.
    dwErr = GetInterfaceOptions(ppwcArguments,
                                dwCurrentIndex,
                                dwArgCount,
                                pwszInterfaceGuid,
                                &iicNew,
                                &dwBitVector);
    if (dwErr isnot NO_ERROR)
        return dwErr ;
    if (dwBitVector)            // ensure that no other option is set.
        return ERROR_INVALID_SYNTAX;

    // show SAMPLE interface configuration
    return SicShow(FORMAT_VERBOSE, pwszInterfaceGuid) ;
}



DWORD
WINAPI
HandleSampleInstall(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for INSTALL

--*/
{
    DWORD   dwErr                   = NO_ERROR;
    PBYTE   pbGlobalConfiguration   = NULL;
    DWORD   dwSize;

    // no options expected for install command.
    if (dwCurrentIndex isnot dwArgCount)
        return ERROR_INVALID_SYNTAX;
    
    do                          // breakout loop
    {
        dwErr = SgcMake(&pbGlobalConfiguration, &dwSize);
        if (dwErr isnot NO_ERROR)
            break;

        // add SAMPLE global configuration
        dwErr = SetGlobalConfiguration(MS_IP_SAMPLE,
                                       pbGlobalConfiguration,
                                       dwSize,
                                       1);
        if (dwErr isnot NO_ERROR)
            break;
    }while (FALSE);

    if (pbGlobalConfiguration) FREE(pbGlobalConfiguration);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}



DWORD
WINAPI
HandleSampleUninstall(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for UNINSTALL
    
--*/
{
    DWORD   dwErr                   = NO_ERROR;
    
    // no options expected for uninstall command.
    if (dwCurrentIndex isnot dwArgCount)
        return ERROR_INVALID_SYNTAX;

    dwErr = DeleteProtocol(MS_IP_SAMPLE);
    
    return (dwErr is NO_ERROR) ? ERROR_OKAY : dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\samplemib.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    sample\samplemib.h

Abstract:

    Header for samplemib.c

--*/

FN_HANDLE_CMD HandleSampleMibShowObject;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\samplegetopt.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplegetopt.h

Abstract:

    The file contains the include file for samplegetopt.c.

--*/

FN_HANDLE_CMD  HandleSampleAddIf;
FN_HANDLE_CMD  HandleSampleDelIf;
FN_HANDLE_CMD  HandleSampleSetGlobal;
FN_HANDLE_CMD  HandleSampleSetIf;
FN_HANDLE_CMD  HandleSampleShowGlobal;
FN_HANDLE_CMD  HandleSampleShowIf;
FN_HANDLE_CMD  HandleSampleInstall;
FN_HANDLE_CMD  HandleSampleUninstall;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\samplemib.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\samplemib.c

Abstract:

    The file contains functions to display SAMPLE ip protocol's MIB.

--*/

#include "precomp.h"
#pragma hdrstop

VOID
PrintGlobalStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

VOID
PrintIfStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

VOID
PrintIfBinding(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

MIB_OBJECT_ENTRY    rgMibObjectTable[] =
{
    {TOKEN_GLOBALSTATS, IPSAMPLE_GLOBAL_STATS_ID,   NULL,
     0,                                             PrintGlobalStats},
    {TOKEN_IFSTATS,         IPSAMPLE_IF_STATS_ID,   GetIfIndex,
     MSG_SAMPLE_MIB_IFSTATS_HEADER,                 PrintIfStats},
    {TOKEN_IFBINDING,   IPSAMPLE_IF_BINDING_ID, GetIfIndex,
     MSG_SAMPLE_MIB_IFBINDING_HEADER,               PrintIfBinding},
};

#define MAX_MIB_OBJECTS                                     \
(sizeof(rgMibObjectTable) / sizeof(MIB_OBJECT_ENTRY))

#define MAX_GLOBAL_MIB_OBJECTS                              1
    


VOID
PrintGlobalStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat    
    )
/*++

Routine Description:
    Prints sample global statistics

--*/
{
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod          = 
        ((PIPSAMPLE_MIB_GET_OUTPUT_DATA) pvOutput);
    PIPSAMPLE_GLOBAL_STATS          pGlobalStats    =
        ((PIPSAMPLE_GLOBAL_STATS) pimgod->IMGOD_Buffer);
    
    DisplayMessageToConsole(g_hModule,
                      hConsole,
                      MSG_SAMPLE_MIB_GS,
                      pGlobalStats->ulNumInterfaces);
}



VOID
PrintIfStats(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat    
    )
/*++

Routine Description:
    Prints SAMPLE interface statistics

--*/
{
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod          = 
        ((PIPSAMPLE_MIB_GET_OUTPUT_DATA) pvOutput);
    PIPSAMPLE_IF_STATS              pIfStats        =
        ((PIPSAMPLE_IF_STATS) pimgod->IMGOD_Buffer);
    WCHAR   pwszIfName[MAX_INTERFACE_NAME_LEN + 1]  = L"\0";

    InterfaceNameFromIndex(hMibServer,
                           pimgod->IMGOD_IfIndex,
                           pwszIfName,
                           sizeof(pwszIfName));

    DisplayMessageToConsole(g_hModule,
                      hConsole,
                      (fFormat is FORMAT_VERBOSE)
                      ? MSG_SAMPLE_MIB_IFSTATS
                      : MSG_SAMPLE_MIB_IFSTATS_ENTRY,
                      pwszIfName,
                      pIfStats->ulNumPackets);
}



VOID
PrintIfBinding(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat    
    )
/*++

Routine Description:
    Prints SAMPLE interface binding

--*/
{
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod          = 
        ((PIPSAMPLE_MIB_GET_OUTPUT_DATA) pvOutput);
    PIPSAMPLE_IF_BINDING            pIfBinding      =
        ((PIPSAMPLE_IF_BINDING) pimgod->IMGOD_Buffer);
    WCHAR   pwszIfName[MAX_INTERFACE_NAME_LEN + 1]  = L"\0";
    PWCHAR  pwszBindState = L"\0", pwszActiveState = L"\0";

    PIPSAMPLE_IP_ADDRESS            pBinding        = NULL;
    WCHAR                           pwszAddress[ADDR_LENGTH + 1] = L"\0",
                                    pwszMask[ADDR_LENGTH + 1] = L"\0";    
    ULONG                           i;
    
    
    InterfaceNameFromIndex(hMibServer,
                           pimgod->IMGOD_IfIndex,
                           pwszIfName,
                           sizeof(pwszIfName));

    pwszBindState = MakeString(g_hModule,
                               ((pIfBinding->dwState&IPSAMPLE_STATE_BOUND)
                                ? STRING_BOUND : STRING_UNBOUND));
    
    pwszActiveState = MakeString(g_hModule,
                                 ((pIfBinding->dwState&IPSAMPLE_STATE_ACTIVE)
                                  ? STRING_ACTIVE : STRING_INACTIVE));

    DisplayMessageToConsole(g_hModule,
                      hConsole,
                      (fFormat is FORMAT_VERBOSE)
                      ? MSG_SAMPLE_MIB_IFBINDING
                      : MSG_SAMPLE_MIB_IFBINDING_ENTRY,
                      pwszIfName,
                      pwszBindState,
                      pwszActiveState);

    pBinding = IPSAMPLE_IF_ADDRESS_TABLE(pIfBinding);

    for(i = 0; i < pIfBinding->ulCount; i++)
    {
        UnicodeIpAddress(pwszAddress, INET_NTOA(pBinding[i].dwAddress));
        UnicodeIpAddress(pwszMask, INET_NTOA(pBinding[i].dwMask));
        DisplayMessageToConsole(g_hModule,
                          hConsole,
                          MSG_SAMPLE_MIB_IFBINDING_ADDR,
                          pwszAddress,
                          pwszMask);
    }

    if (pwszBindState) FreeString(pwszBindState);
    if (pwszActiveState) FreeString(pwszActiveState);
}



DWORD
WINAPI
HandleSampleMibShowObject(
    IN  PWCHAR                  pwszMachineName,
    IN  PWCHAR                  *ppwcArguments,
    IN  DWORD                   dwCurrentIndex,
    IN  DWORD                   dwArgCount,
    IN  DWORD                   dwFlags,
    IN  MIB_SERVER_HANDLE       hMibServer,
    IN  BOOL                    *pbDone
    )
/*++

Routine Description:
    Gets options for SHOW GLOBALSTATS/IFSTATS/IFBINDING
    A single command handler is used for all MIB objects since there is a
    lot common in the way processing takes place.  However feel free to
    write a handler per object if u find the code a bit chaotic.
    
--*/
{
    DWORD                           dwErr       = NO_ERROR;
    TAG_TYPE                        pttAllTags[]   =
    {
        {TOKEN_INDEX,       FALSE,  FALSE}, // INDEX tag optional
        {TOKEN_RR,          FALSE,  FALSE}, // RR tag optional
    };
    DWORD                           pdwTagType[NUM_TAGS_IN_TABLE(pttAllTags)];
    DWORD                           dwNumArg;
    ULONG                           i;
    TAG_TYPE                        *pttTags;
    DWORD                           dwNumTags;
    BOOL                            bGlobalObject           = FALSE;
    DWORD                           dwFirstGlobalArgument   = 1;
    
    DWORD                           dwMibObject;
    BOOL                            bIndexSpecified = FALSE;
    DWORD                           dwIndex         = 0;
    DWORD                           dwRR            = 0;
    
    HANDLE                          hMib, hConsole;
    MODE                            mMode;
    IPSAMPLE_MIB_GET_INPUT_DATA     imgid;
    PIPSAMPLE_MIB_GET_OUTPUT_DATA   pimgod;
    BOOL                            bSomethingDisplayed = FALSE;

    
    // SAMPLE should be installed for this command to complete
    VerifyInstalled(MS_IP_SAMPLE, STRING_PROTO_SAMPLE);

    
    // figure mib object to display
    for (i = 0; i < MAX_MIB_OBJECTS; i++)
        if (MatchToken(ppwcArguments[dwCurrentIndex - 1],
                       rgMibObjectTable[i].pwszObjectName))
            break;

    dwMibObject = i;
    if (dwMibObject is MAX_MIB_OBJECTS)
        return ERROR_CMD_NOT_FOUND;
    bGlobalObject = (dwMibObject < MAX_GLOBAL_MIB_OBJECTS);

    // for global objects, offset tags by index of the first global arguments
    pttTags = pttAllTags
        + bGlobalObject*dwFirstGlobalArgument;
    dwNumTags  = NUM_TAGS_IN_TABLE(pttAllTags)
        - bGlobalObject*dwFirstGlobalArgument,
    dwErr = PreprocessCommand(g_hModule,
                              ppwcArguments,
                              dwCurrentIndex,
                              dwArgCount,
                              pttTags,
                              dwNumTags,
                              0,
                              dwNumTags,
                              pdwTagType);
    if (dwErr isnot NO_ERROR)
        return dwErr;


    // process all arguments
    dwNumArg = dwArgCount - dwCurrentIndex;
    for (i = 0; i < dwNumArg; i++)
    {
        // for global objects, offset tag type by first global argument index
        pdwTagType[i] += bGlobalObject*dwFirstGlobalArgument;
        switch (pdwTagType[i])
        {
            case 0:
                // tag INDEX
                bIndexSpecified = TRUE;
                dwErr = (*rgMibObjectTable[dwMibObject].pfnGetIndex)(
                    hMibServer,
                    ppwcArguments[i+dwCurrentIndex],
                    &dwIndex);
                break;

            case 1:
                // tag RR
                dwRR = wcstoul(ppwcArguments[i+dwCurrentIndex],
                               NULL,
                               10);
                dwRR *= 1000;   // convert refresh rate to milliseconds
                break;

            default:
                dwErr = ERROR_INVALID_SYNTAX;
                break;
        } // switch

        if (dwErr isnot NO_ERROR)
            break ;
    } // for


    // process errors
    if (dwErr isnot NO_ERROR)
    {
        ProcessError();
        return dwErr;
    }


    if (!InitializeConsole(&dwRR, &hMib, &hConsole))
        return ERROR_INIT_DISPLAY;

    // now display the specified mib object
    for(ever)                   // refresh loop
    {
        // initialize to default values
        bSomethingDisplayed = FALSE;
        
        imgid.IMGID_TypeID = rgMibObjectTable[dwMibObject].dwObjectId;
        imgid.IMGID_IfIndex = 0;
        mMode = GET_EXACT;

        // override defaults for interface objects
        if (!bGlobalObject)
        {
            if (bIndexSpecified)
                imgid.IMGID_IfIndex = dwIndex;
            else
                mMode = GET_FIRST;
        }

        for(ever)               // display all interfaces loop
        {
            dwErr = MibGet(hMibServer,
                           mMode,
                           (PVOID) &imgid,
                           sizeof(imgid),
                           &pimgod);
            if (dwErr isnot NO_ERROR)
            {
                if ((mMode is GET_NEXT) and (dwErr is ERROR_NO_MORE_ITEMS))
                    dwErr = NO_ERROR;   // not really an error
                break;
            }

            // print table heading
            if (!bSomethingDisplayed and (mMode isnot GET_EXACT))
            {
                DisplayMessageToConsole(
                    g_hModule,
                    hConsole,
                    rgMibObjectTable[dwMibObject].dwHeaderMessageId);
                bSomethingDisplayed = TRUE;
            }

            (*rgMibObjectTable[dwMibObject].pfnPrint)(hConsole,
                                                      hMibServer,
                                                      (PVOID) pimgod,
                                                      (mMode is GET_EXACT)
                                                      ? FORMAT_VERBOSE
                                                      : FORMAT_TABLE);

            // prepare for next request
            imgid.IMGID_IfIndex = pimgod->IMGOD_IfIndex;
            MprAdminMIBBufferFree(pimgod);
            
            if (mMode is GET_EXACT)
                break;
            else                // prepare for next request
                mMode = GET_NEXT;
        } // display all interfaces 

        if (dwErr isnot NO_ERROR)
        {
            dwErr = bSomethingDisplayed ? NO_ERROR : ERROR_OKAY;
            break;
        }

        if (!RefreshConsole(hMib, hConsole, dwRR))
            break;
    } // refresh
            
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\strdefs.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\strdefs.h

Abstract:

    The file contains definitions for strings defined in resource file.

--*/

#define IPSAMPLELOG_BASE                44000

#define HLP_INSTALL                     (IPSAMPLELOG_BASE + 1)
#define HLP_INSTALL_EX                  (IPSAMPLELOG_BASE + 2)
#define HLP_UNINSTALL                   (IPSAMPLELOG_BASE + 3)
#define HLP_UNINSTALL_EX                (IPSAMPLELOG_BASE + 4)
#define HLP_HELP                        (IPSAMPLELOG_BASE + 5)
#define HLP_HELP_EX                     (IPSAMPLELOG_BASE + 6)
#define HLP_DUMP                        (IPSAMPLELOG_BASE + 7)
#define HLP_DUMP_EX                     (IPSAMPLELOG_BASE + 8)

#define HLP_GROUP_ADD                   (IPSAMPLELOG_BASE + 9)
#define HLP_GROUP_DELETE                (IPSAMPLELOG_BASE + 10)
#define HLP_GROUP_SET                   (IPSAMPLELOG_BASE + 11)
#define HLP_GROUP_SHOW                  (IPSAMPLELOG_BASE + 12)

#define HLP_SAMPLE_ADD_IF               (IPSAMPLELOG_BASE + 13)
#define HLP_SAMPLE_ADD_IF_EX            (IPSAMPLELOG_BASE + 14)

#define HLP_SAMPLE_DEL_IF               (IPSAMPLELOG_BASE + 15)
#define HLP_SAMPLE_DEL_IF_EX            (IPSAMPLELOG_BASE + 16)

#define HLP_SAMPLE_SET_IF               (IPSAMPLELOG_BASE + 17)
#define HLP_SAMPLE_SET_IF_EX            (IPSAMPLELOG_BASE + 18)
#define HLP_SAMPLE_SET_GLOBAL           (IPSAMPLELOG_BASE + 21)
#define HLP_SAMPLE_SET_GLOBAL_EX        (IPSAMPLELOG_BASE + 22)

#define HLP_SAMPLE_SHOW_IF              (IPSAMPLELOG_BASE + 23)
#define HLP_SAMPLE_SHOW_IF_EX           (IPSAMPLELOG_BASE + 24)
#define HLP_SAMPLE_SHOW_GLOBAL          (IPSAMPLELOG_BASE + 27)
#define HLP_SAMPLE_SHOW_GLOBAL_EX       (IPSAMPLELOG_BASE + 28)

#define HLP_SAMPLE_MIB_SHOW_STATS       (IPSAMPLELOG_BASE + 29)
#define HLP_SAMPLE_MIB_SHOW_STATS_EX    (IPSAMPLELOG_BASE + 30)
#define HLP_SAMPLE_MIB_SHOW_IFSTATS     (IPSAMPLELOG_BASE + 31)
#define HLP_SAMPLE_MIB_SHOW_IFSTATS_EX  (IPSAMPLELOG_BASE + 32)
#define HLP_SAMPLE_MIB_SHOW_IFBINDING       (IPSAMPLELOG_BASE + 58)
#define HLP_SAMPLE_MIB_SHOW_IFBINDING_EX    (IPSAMPLELOG_BASE + 59)

#define DMP_SAMPLE_HEADER               (IPSAMPLELOG_BASE + 33)
#define DMP_SAMPLE_FOOTER               (IPSAMPLELOG_BASE + 34)
#define DMP_SAMPLE_INTERFACE_HEADER     (IPSAMPLELOG_BASE + 35)

#define MSG_SAMPLE_GLOBAL_CONFIG        (IPSAMPLELOG_BASE + 36)
#define MSG_SAMPLE_IF_CONFIG            (IPSAMPLELOG_BASE + 37)
#define MSG_SAMPLE_IF_CONFIG_HEADER     (IPSAMPLELOG_BASE + 70)
#define MSG_SAMPLE_IF_CONFIG_ENTRY      (IPSAMPLELOG_BASE + 71)
#define MSG_SAMPLE_MIB_GS               (IPSAMPLELOG_BASE + 39)
#define MSG_SAMPLE_MIB_IFSTATS          (IPSAMPLELOG_BASE + 41)
#define MSG_SAMPLE_MIB_IFSTATS_HEADER   (IPSAMPLELOG_BASE + 72)
#define MSG_SAMPLE_MIB_IFSTATS_ENTRY    (IPSAMPLELOG_BASE + 73)
#define MSG_SAMPLE_MIB_IFBINDING        (IPSAMPLELOG_BASE + 56)
#define MSG_SAMPLE_MIB_IFBINDING_ADDR   (IPSAMPLELOG_BASE + 57)
#define MSG_SAMPLE_MIB_IFBINDING_HEADER (IPSAMPLELOG_BASE + 74)
#define MSG_SAMPLE_MIB_IFBINDING_ENTRY  (IPSAMPLELOG_BASE + 75)

#define STRING_PROTO_SAMPLE             (IPSAMPLELOG_BASE + 60)
#define STRING_LOGGING_NONE             (IPSAMPLELOG_BASE + 42)
#define STRING_LOGGING_ERROR            (IPSAMPLELOG_BASE + 43)
#define STRING_LOGGING_WARN             (IPSAMPLELOG_BASE + 44)
#define STRING_LOGGING_INFO             (IPSAMPLELOG_BASE + 45)
#define STRING_UNKNOWN                  (IPSAMPLELOG_BASE + 46)
#define STRING_BOUND                    (IPSAMPLELOG_BASE + 62)
#define STRING_ACTIVE                   (IPSAMPLELOG_BASE + 63)
#define STRING_UNBOUND                  (IPSAMPLELOG_BASE + 64)
#define STRING_INACTIVE                 (IPSAMPLELOG_BASE + 65)

#define EMSG_PROTO_NO_GLOBAL_CONFIG     (IPSAMPLELOG_BASE + 47)
#define EMSG_PROTO_NO_IF_CONFIG         (IPSAMPLELOG_BASE + 48)
#define EMSG_INTERFACE_EXISTS           (IPSAMPLELOG_BASE + 49)
#define EMSG_PROTO_NOT_INSTALLED        (IPSAMPLELOG_BASE + 50)
#define EMSG_PROTO_INSTALLED            (IPSAMPLELOG_BASE + 51)
#define EMSG_BAD_OPTION_VALUE           (IPSAMPLELOG_BASE + 52)
#define EMSG_RRAS_ERROR                 (IPSAMPLELOG_BASE + 53)
#define EMSG_NO_ENTRIES                 (IPSAMPLELOG_BASE + 54)

#define HLP_HELP1                       HLP_HELP
#define HLP_HELP1_EX                    HLP_HELP_EX
#define HLP_HELP2                       HLP_HELP
#define HLP_HELP2_EX                    HLP_HELP_EX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\utils.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sample\utils.c

Abstract:

     The file contains utility functions

--*/

#include "precomp.h"
#pragma hdrstop

BOOL
IsProtocolInstalled(
    IN  DWORD           dwProtocolId,
    IN  DWORD           dwNameId,
    IN  DWORD           dwLogUninstalled
    )
/*++

Routine Description:
    Finds if the protocol is already installed.

Arguments:
    dwProtocolId        - protocol id
    dwNameId            - protocol name
    dwLogUninstalled    - TRUE(if not installed display error)
                          FALSE(if installed display error)
Return Value:
    TRUE if protocol already installed, else FALSE

--*/
{
    DWORD   dwErr       = NO_ERROR;
    WCHAR   *pwszName   = NULL;

    dwErr = IpmontrGetInfoBlockFromGlobalInfo(dwProtocolId,
                                              NULL,
                                              NULL,
                                              NULL);

    pwszName = MakeString(g_hModule, dwNameId);

    if ((dwErr isnot NO_ERROR) and (dwLogUninstalled is TRUE))
    {
        DisplayError(g_hModule, EMSG_PROTO_NOT_INSTALLED, pwszName);
    }
    else if ((dwErr is NO_ERROR) and (dwLogUninstalled is FALSE))
    {
        DisplayError(g_hModule, EMSG_PROTO_INSTALLED, pwszName);
    }
    
    if (pwszName) FreeString(pwszName);

    return (dwErr is NO_ERROR) ? TRUE : FALSE;
}



DWORD
GetIfIndex(
    IN  HANDLE          hMibServer,
    IN  PWCHAR          pwszArgument,
    OUT PDWORD          pdwIfIndex
    )
/*++

Routine Description:
    Gets the interface index.

Arguments:
    hMibServer      - handle to the mib server
    pwszArgument    - argument specifing interface index or name
    pdwIfIndex      - interface index

Return Value:
    NO_ERROR        success
    error code      o/w
    
--*/
{
    DWORD dwErr = NO_ERROR;

    // if index was specified just use it
    if (iswdigit(pwszArgument[0]))
    {
        *pdwIfIndex = wcstoul(pwszArgument, NULL, 10);
        return NO_ERROR;
    }

    // try converting a friendly name to an interface index
    dwErr = InterfaceIndexFromName(hMibServer,
                                   pwszArgument,
                                   pdwIfIndex);
    return (dwErr is NO_ERROR) ? dwErr : ERROR_INVALID_PARAMETER;
}



DWORD
MibGet(
    IN  HANDLE          hMibServer,
    IN  MODE            mMode,
    IN  PVOID           pvIn,
    IN  DWORD           dwInSize,
    OUT PVOID           *ppvOut
    )
/*++

Routine Description:
    Gets the specified mib object.

Arguments:
    hMibServer      - handle to the mib server
    mMode           - mode of access (exact, first, next)
    pvIn            - buffer containing input data
    dwInSize        - size of input data
    ppvOut          - pointer to address of output data buffer
    
Return Value:
    NO_ERROR        success
    error code      o/w
    
--*/
{
    DWORD dwErr         = NO_ERROR;
    DWORD dwOutSize     = 0;
    DWORD (APIENTRY *pfnMprGet) (
        IN      MIB_SERVER_HANDLE       hMibServer,
        IN      DWORD                   dwProtocolId,
        IN      DWORD                   dwRoutingPid,
        IN      LPVOID                  lpInEntry,
        IN      DWORD                   dwInEntrySize,
        OUT     LPVOID*                 lplpOutEntry,
        OUT     LPDWORD                 lpOutEntrySize
        );

    *ppvOut     = NULL;

    switch(mMode)
    {
        case GET_EXACT:
            pfnMprGet = MprAdminMIBEntryGet;
            break;
        case GET_FIRST:
            pfnMprGet = MprAdminMIBEntryGetFirst;
            break;
        case GET_NEXT:
            pfnMprGet = MprAdminMIBEntryGetNext;
            break;
    }
    
    dwErr = (*pfnMprGet) (
        hMibServer,
        PID_IP,
        MS_IP_SAMPLE,
        (LPVOID) pvIn,
        dwInSize,
        (LPVOID *) ppvOut,
        &dwOutSize);

    if (dwErr isnot NO_ERROR)
        return dwErr;
    
    if (*ppvOut is NULL)
        return ERROR_CAN_NOT_COMPLETE;

    return NO_ERROR;
}



DWORD
GetDumpString (
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  PVALUE_TOKEN    ptvTable,
    IN  DWORD           dwNumArgs,
    OUT PWCHAR          *pwszString
    )
/*
 * Do not localize display string
 */
{
    DWORD dwErr = NO_ERROR ;
    ULONG i;

    for (i = 0; i < dwNumArgs; i++)
    {
        if (dwValue is ptvTable[i].dwValue)
        {
            *pwszString = MALLOC((wcslen(ptvTable[i].pwszToken) + 1) *
                                 sizeof(WCHAR));
            if (*pwszString)
                wcscpy(*pwszString, ptvTable[i].pwszToken);
            break;
        }
    }

    if (i is dwNumArgs)
        *pwszString = MakeString(hModule, STRING_UNKNOWN) ;

    if (!pwszString)
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;

    return dwErr ;
}



DWORD
GetShowString (
    IN  HANDLE          hModule,
    IN  DWORD           dwValue,
    IN  PVALUE_STRING   ptvTable,
    IN  DWORD           dwNumArgs,
    OUT PWCHAR          *pwszString
    )
/*
 * Localize display string
 */
{
    DWORD dwErr = NO_ERROR ;
    ULONG i;

    for (i = 0; i < dwNumArgs; i++)
    {
        if (dwValue is ptvTable[i].dwValue)
        {
            *pwszString = MakeString(hModule, ptvTable[i].dwStringId) ;
            break;
        }
    }

    if (i is dwNumArgs)
        *pwszString = MakeString(hModule, STRING_UNKNOWN) ;

    if (!pwszString)
        dwErr = ERROR_NOT_ENOUGH_MEMORY ;
    
    return dwErr ;
}



DWORD
GetString (
    IN  HANDLE          hModule, 
    IN  FORMAT          fFormat,
    IN  DWORD           dwValue,
    IN  PVALUE_TOKEN    vtTable,
    IN  PVALUE_STRING   vsTable,
    IN  DWORD           dwNumArgs,
    OUT PWCHAR          *pwszString)
{
    if (fFormat is FORMAT_DUMP) 
    {
        return GetDumpString(hModule,
                                 dwValue,
                                 vtTable,
                                 dwNumArgs,
                                 pwszString) ;
    } 
    else 
    {
        return GetShowString(hModule,
                                dwValue,
                                vsTable,
                                dwNumArgs,
                                pwszString) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxgl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxgl.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_IPXGL_
#define _IPXMON_IPXGL_

int APIENTRY 
ShowIpxGl (
    IN    int                   argc,
    IN    WCHAR                *argv[],
    IN    BOOL                  bDump
    );

int APIENTRY 
SetIpxGl (
    IN    int                   argc,
    IN    WCHAR                *argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxhandle.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxhandle.c

Abstract:

    IPX Command handler.

Revision History:

    V Raman                     12/2/98  Created

--*/


#ifndef __IPXHANDLE_H__
#define __IPXHANDLE_H__


//
// Handle static route operations
//

FN_HANDLE_CMD HandleIpxAddRoute;
FN_HANDLE_CMD HandleIpxDelRoute;
FN_HANDLE_CMD HandleIpxSetRoute;
FN_HANDLE_CMD HandleIpxShowRoute;

//
// Handle static service operations
//

FN_HANDLE_CMD HandleIpxAddService;
FN_HANDLE_CMD HandleIpxDelService;
FN_HANDLE_CMD HandleIpxSetService;
FN_HANDLE_CMD HandleIpxShowService;

//
// Handle packet filter operations
//

FN_HANDLE_CMD HandleIpxAddFilter;
FN_HANDLE_CMD HandleIpxDelFilter;
FN_HANDLE_CMD HandleIpxSetFilter;
FN_HANDLE_CMD HandleIpxShowFilter;

//
// Handle interface operations
//

FN_HANDLE_CMD HandleIpxAddInterface;
FN_HANDLE_CMD HandleIpxDelInterface;
FN_HANDLE_CMD HandleIpxSetInterface;
FN_HANDLE_CMD HandleIpxShowInterface;

//
// Handle loglevel operations
//

FN_HANDLE_CMD HandleIpxSetLoglevel;
FN_HANDLE_CMD HandleIpxShowLoglevel;

//
// Other misc operations
//

FN_HANDLE_CMD HandleIpxUpdate;

//
// Route and Service Table display
//

FN_HANDLE_CMD HandleIpxShowRouteTable;
FN_HANDLE_CMD HandleIpxShowServiceTable;

NS_CONTEXT_DUMP_FN  IpxDump;

VOID
DumpIpxInformation(
    IN     LPCWSTR    pwszMachineName,
    IN OUT LPWSTR    *ppwcArguments,
    IN     DWORD      dwArgCount,
    IN     MIB_SERVER_HANDLE hMibServer
    );

//
// operations enumerations
//

typedef enum _IPX_OPERATION
{
    IPX_OPERATION_ADD,
    IPX_OPERATION_DELETE,
    IPX_OPERATION_SET,
    IPX_OPERATION_SHOW
    
} IPX_OPERATION;


#endif // __IPXHANDLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxgl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxgl.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Global configuration.

Author:

    Vadim Eydelman  06/07/1996


--*/
#include "precomp.h"
#pragma hdrstop

DWORD
CfgSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    );

DWORD
AdmSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    );

int APIENTRY 
ShowIpxGl(
    IN    int       argc,
    IN    WCHAR    *argv[],
    IN    BOOL      bDump
    ) 
{
    DWORD        rc;
    LPBYTE      pGlBlock;
    DWORD       sz;
    HANDLE      hTrCfg = NULL;
    PWCHAR      buffer = NULL;

    if ( g_hMprAdmin )
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, &pGlBlock, &sz,
                NULL, NULL
                );
        if ( rc == NO_ERROR ) { }
        else
        {
            goto GetFromCfg;
        }
    }

    else 
    {
GetFromCfg:
        rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );
        
        if ( rc == NO_ERROR )
        {
            rc = MprConfigTransportGetInfo(
                    g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                    );
        }
    }

    if ( rc == NO_ERROR )
    {
        PIPX_TOC_ENTRY pIpxGlToc;

        pIpxGlToc = GetIPXTocEntry (
                    (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                    IPX_GLOBAL_INFO_TYPE
                    );
                    
        if ( pIpxGlToc != NULL )
        {
            PIPX_GLOBAL_INFO    pIpxGlInfo;
            PWCHAR              buffer;

            pIpxGlInfo = (PIPX_GLOBAL_INFO) (pGlBlock+pIpxGlToc->Offset);


            buffer = GetEnumString(
                        g_hModule, pIpxGlInfo->EventLogMask,
                        NUM_VALUES_IN_TABLE( LogLevels ), LogLevels
                        );
                        
            if ( bDump )
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_GLOBAL_HEADER);
                    
                DisplayMessageT( DMP_IPX_SET_GLOBAL, buffer );
            }

            else
            {
                DisplayIPXMessage(
                    g_hModule, MSG_IPX_GLOBAL_FMT, buffer
                    );
            }
        }
        
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        
        if (hTrCfg!=NULL)
        {
            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            MprAdminBufferFree (pGlBlock);
        }
    }
    else if (!bDump)
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}



int APIENTRY 
SetIpxGl (
    IN    int                    argc,
    IN    WCHAR                *argv[]
    ) 
{
    DWORD        rc;

    if ( argc >= 1 )
    {
        int         i;
        unsigned    n;
        PWCHAR      buffer;
        DWORD       logLevel;
        DWORD       *pLogLevel = NULL;
        TOKEN_VALUE LogLevel[] =
        {
            { VAL_NONE, 0 },
            { VAL_ERRORS_ONLY, EVENTLOG_ERROR_TYPE },
            { VAL_ERRORS_AND_WARNINGS, EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE },
            { VAL_MAXINFO, 
                EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE }
        };

        for ( i = 0; i < argc; i++ )
        {
            if ( !_wcsicmp( argv[i], TOKEN_LOGLEVEL ) )
            {
                if ( ( pLogLevel == NULL ) && ( i < argc - 1 ) && 
                     !MatchEnumTag( 
                        g_hModule, argv[ i + 1 ], NUM_TOKENS_IN_TABLE( LogLevel ),
                        LogLevel, &logLevel ) )
                {
                    i += 1;
                    pLogLevel = &logLevel;
                }
                
                else
                {
                    break;
                }
            }
            
            else if ( pLogLevel == NULL ) 
            {
                if ( !MatchEnumTag( 
                        g_hModule, argv[ i ], NUM_TOKENS_IN_TABLE( LogLevel ),
                        LogLevel, &logLevel ) ) 
                {
                    pLogLevel = &logLevel;
                }
                else
                {
                    break;
                }
            }
        }
        
        if ( i == argc )
        {
            rc = CfgSetIpxGlInfo( pLogLevel );
            
            if ( rc == NO_ERROR ) 
            {
                if ( g_hMprAdmin )
                {
                    AdmSetIpxGlInfo( pLogLevel );
                }
            }
        }
        else 
        {
            rc = ERROR_INVALID_SYNTAX;
        }
    }
    else
    {
        rc = ERROR_INVALID_SYNTAX;
    }

    return rc;
}





DWORD
CfgSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    ) 
{
    DWORD   rc;
    HANDLE  hTrCfg;

    rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );

    if ( rc == NO_ERROR )
    {
        DWORD   sz;
        LPBYTE  pGlBlock;

        rc = MprConfigTransportGetInfo(
                g_hMprConfig, hTrCfg, &pGlBlock, &sz, NULL, NULL, NULL
                );
                
        if (rc==NO_ERROR) 
        {
            PIPX_TOC_ENTRY pIpxGlToc;

            pIpxGlToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                            IPX_GLOBAL_INFO_TYPE
                            );
                            
            if (pIpxGlToc!=NULL) 
            {
                PIPX_GLOBAL_INFO    pIpxGlInfo;

                pIpxGlInfo = (PIPX_GLOBAL_INFO) (pGlBlock+pIpxGlToc->Offset);
                
                if ( pLogLevel )
                {
                    pIpxGlInfo->EventLogMask = *pLogLevel;
                }
                
                rc = MprConfigTransportSetInfo(
                        g_hMprConfig, hTrCfg, pGlBlock, sz, NULL, 0, NULL
                        );
                        
                if (rc==NO_ERROR) 
                {
                    DisplayIPXMessage (g_hModule, MSG_IPXGL_SET_CFG);
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            else 
            {             
                DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
                rc = ERROR_INVALID_DATA;
            }

            MprConfigBufferFree (pGlBlock);
        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}




DWORD
AdmSetIpxGlInfo (
    IN DWORD    *pLogLevel OPTIONAL
    )
{
    DWORD    rc;
    LPBYTE    pGlBlock;
    DWORD   sz;

    rc = MprAdminTransportGetInfo(
            g_hMprAdmin, PID_IPX, &pGlBlock, &sz, NULL, NULL
            );

    if (rc==NO_ERROR) 
    {
        PIPX_TOC_ENTRY pIpxGlToc;

        pIpxGlToc = GetIPXTocEntry (
                        (PIPX_INFO_BLOCK_HEADER)pGlBlock,
                        IPX_GLOBAL_INFO_TYPE
                        );
                        
        if (pIpxGlToc!=NULL)
        {
            PIPX_GLOBAL_INFO    pIpxGlInfo;

            pIpxGlInfo = (PIPX_GLOBAL_INFO) (pGlBlock+pIpxGlToc->Offset);
            
            if (pLogLevel)
            {
                pIpxGlInfo->EventLogMask = *pLogLevel;
            }

            rc = MprAdminTransportSetInfo(
                    g_hMprAdmin, PID_IPX, pGlBlock, sz, NULL, 0
                    );

            if (rc==NO_ERROR) 
            {
                DisplayIPXMessage (g_hModule,
                        MSG_IPXGL_SET_ADM);
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {             
            DisplayIPXMessage (g_hModule, MSG_ROUTER_INFO_CORRUPTED);
            rc = ERROR_INVALID_DATA;
        }
        MprAdminBufferFree (pGlBlock);
    }
    else
    {
        DisplayError( g_hModule, rc);
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ip\sample\utils.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\utils.h

Abstract:

    The file contains the header for utils.c.
    
--*/


// definitions...
    
#define is      ==
#define isnot   !=
#define or      ||
#define and     &&
#define ever    ;;    

#define GetGlobalConfiguration          IpmontrGetInfoBlockFromGlobalInfo
#define SetGlobalConfiguration          IpmontrSetInfoBlockInGlobalInfo
#define DeleteGlobalConfiguration       IpmontrDeleteInfoBlockFromGlobalInfo

#define GetInterfaceConfiguration       IpmontrGetInfoBlockFromInterfaceInfo
#define SetInterfaceConfiguration       IpmontrSetInfoBlockInInterfaceInfo
#define DeleteInterfaceConfiguration    IpmontrDeleteInfoBlockFromInterfaceInfo

#define InterfaceNameFromGuid           IpmontrGetFriendlyNameFromIfName
#define InterfaceGuidFromName           IpmontrGetIfNameFromFriendlyName
#define InterfaceNameFromIndex          IpmontrGetFriendlyNameFromIfIndex
#define InterfaceIndexFromName          IpmontrGetIfIndexFromFriendlyName

#define DeleteProtocol                  IpmontrDeleteProtocol

    

// typedefs...

typedef enum { GET_EXACT, GET_FIRST, GET_NEXT } MODE;

typedef enum { FORMAT_TABLE, FORMAT_VERBOSE, FORMAT_DUMP } FORMAT;

typedef DWORD (*PGET_INDEX_FUNCTION) (
    IN  HANDLE                          hMibServer,
    IN  PWCHAR                          pwszArgument,
    OUT PDWORD                          pdwIfIndex
    );

typedef VOID (*PPRINT_FUNCTION)(
    IN  HANDLE                          hConsole,
    IN  HANDLE                          hMibServer,
    IN  PVOID                           pvOutput,
    IN  FORMAT                          fFormat
    );

typedef struct _MIB_OBJECT_ENTRY
{
    PWCHAR                              pwszObjectName;
    DWORD                               dwObjectId;
    PGET_INDEX_FUNCTION                 pfnGetIndex;
    DWORD                               dwHeaderMessageId;
    PPRINT_FUNCTION                     pfnPrint;
} MIB_OBJECT_ENTRY, *PMIB_OBJECT_ENTRY;



// macros...

#define VerifyInstalled(dwProtocolId, dwNameId)                         \
{                                                                       \
    if (!IsProtocolInstalled(dwProtocolId, dwNameId, TRUE))             \
        return ERROR_SUPPRESS_OUTPUT;                                   \
}

#define ProcessError()                                                  \
{                                                                       \
    if (dwErr is ERROR_INVALID_PARAMETER)                               \
    {                                                                   \
        DisplayError(g_hModule,                                         \
                     EMSG_BAD_OPTION_VALUE,                             \
                     ppwcArguments[dwCurrentIndex + i],                 \
                     pttTags[pdwTagType[i]].pwszTag);                   \
        dwErr = ERROR_SHOW_USAGE;                                       \
    }                                                                   \
}

#define UnicodeIpAddress(pwszUnicodeIpAddress, pszAsciiIpAddress)       \
MultiByteToWideChar(GetConsoleOutputCP(),                                             \
                    0,                                                  \
                    (pszAsciiIpAddress),                                \
                    -1,                                                 \
                    (pwszUnicodeIpAddress),                             \
                    ADDR_LENGTH + 1)

#define INET_NTOA(x)    (inet_ntoa(*(struct in_addr*)&(x)))    

#define MALLOC(x)       HeapAlloc(GetProcessHeap(), 0, x)

#define FREE(x)         HeapFree(GetProcessHeap(), 0, x)



// inline functions...

BOOL
__inline
IsInterfaceInstalled(
    IN  PWCHAR          pwszInterfaceGuid,
    IN  DWORD           dwProtocolId
    )
{
    DWORD dwErr     = NO_ERROR;
    PBYTE pbBuffer  = NULL;

    dwErr = GetInterfaceConfiguration(pwszInterfaceGuid,
                                      dwProtocolId,
                                      &pbBuffer,
                                      NULL,
                                      NULL,
                                      NULL);
    if (pbBuffer) FREE(pbBuffer);
    return (dwErr is NO_ERROR);
}

DWORD
__inline
QuotedInterfaceNameFromGuid (
    IN  PWCHAR          pwszInterfaceGuid,
    OUT PWCHAR          *ppwszQuotedInterfaceName
    )
{
    DWORD dwErr = NO_ERROR;
    DWORD dwSize = MAX_INTERFACE_NAME_LEN + 1;
    WCHAR pwszInterfaceName[MAX_INTERFACE_NAME_LEN + 1] = L"\0";

    dwErr = InterfaceNameFromGuid(pwszInterfaceGuid,
                                  pwszInterfaceName,
                                  &dwSize);
    if (dwErr is NO_ERROR)
    {
        *ppwszQuotedInterfaceName = MakeQuotedString(pwszInterfaceName);
        if (*ppwszQuotedInterfaceName is NULL)
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwErr;
}



// functions...

BOOL
IsProtocolInstalled(
    IN  DWORD           dwProtocolId,
    IN  DWORD           dwNameId,
    IN  DWORD           dwLogUninstalled
    );

DWORD
GetIfIndex(
    IN  HANDLE          hMibServer,
    IN  PWCHAR          pwszArgument,
    OUT PDWORD          pdwIfIndex
    );

DWORD
MibGet(
    IN  HANDLE          hMibServer,
    IN  MODE            mMode,
    IN  PVOID           pvIn,
    IN  DWORD           dwInSize,
    OUT PVOID           *ppvOut
    );

DWORD
GetString(
    IN  HANDLE          hModule, 
    IN  FORMAT          fFormat,
    IN  DWORD           dwValue,
    IN  PVALUE_TOKEN    vtTable,
    IN  PVALUE_STRING   vsTable,
    IN  DWORD           dwNumArgs,
    OUT PTCHAR          *pptszString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxifs.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxifs.h

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Interface configuration and monitoring. Header File

Author:

    Vadim Eydelman  06/07/1996


--*/
#ifndef _IPXMON_IPXIFS_
#define _IPXMON_IPXIFS_

DWORD
APIENTRY 
HelpIpxIf(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );


DWORD
APIENTRY 
ShowIpxIf(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv,
    IN    BOOL          bDump
    );


DWORD
APIENTRY 
SetIpxIf(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );


DWORD
APIENTRY 
InstallIpx(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );


DWORD
APIENTRY 
RemoveIpx(
    IN    DWORD         argc,
    IN    LPCWSTR      *argv
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxifs.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ipxifs.c

Abstract:

    IPX Router Console Monitoring and Configuration tool.
    IPX Interface configuration and monitoring.

Author:

    Vadim Eydelman  06/07/1996


--*/

#include "precomp.h"
#pragma hdrstop

DWORD
MIBGetIpxIf(
    PWCHAR      InterfaceNameA
    );


DWORD
CfgGetIpxIf(
    LPWSTR      InterfaceNameW
    );


DWORD
MIBEnumIpxIfs(
    BOOL bDump
    );


DWORD
CfgEnumIpxIfs(
    BOOL bDump
    );


DWORD
CfgSetIpxIf(
    LPWSTR          InterfaceNameW,
    PULONG          pAdminState     OPTIONAL,
    PULONG          pWANProtocol    OPTIONAL
    );


DWORD
AdmSetIpxIf(
    LPWSTR          InterfaceNameW,
    PULONG          pAdminState     OPTIONAL,
    PULONG          pWANProtocol    OPTIONAL
    );

DWORD
GetIpxClientIf(
    PWCHAR          InterfaceNameW,
    UINT            msg,
    BOOL            bDump
    );

DWORD
CfgGetFltNames(
    LPWSTR          InterfaceNameW,
    LPWSTR         *FltInNameW,
    LPWSTR         *FltOutNameW
    );

PIPX_IF_INFO 
GetIpxNbInterface(
    HANDLE          hIf, 
    LPBYTE          *pIfBlock,
    PIPXWAN_IF_INFO *ppIfWanBlock
    );

    

DWORD
APIENTRY 
HelpIpxIf(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This function displays help for NETSH IPX interface commands
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :

    0   - success
    
--*/
{
    DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
    return 0;
}



DWORD
APIENTRY 
ShowIpxIf (
    IN      DWORD       argc,
    IN      LPCWSTR    *argv,
    IN      BOOL        bDump
    )
/*++

Routine Description :

    This routine displays IPX interface information
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :

    
--*/
{
    DWORD   rc;
    PWCHAR  buffer = NULL;    


    //
    // if interface name specified
    //
    
    if ( argc < 1 )
    {
        PWCHAR buffer;
        
        if ( g_hMIBServer )
        {
            //
            // enumerate and display the interface via the MIB server
            //
            
            rc = MIBEnumIpxIfs ( bDump );
            
            if ( rc == NO_ERROR )
            {
                //
                // Display RAs server interface IPX info. 
                //
                
                rc = GetIpxClientIf(
                        VAL_DIALINCLIENT, MSG_CLIENT_IPXIF_MIB_TABLE_FMT,
                        bDump
                        );
            }
            else 
            {
                //
                // Router not running ?  Fallback to  router config
                //
                
                DisplayIPXMessage (g_hModule, MSG_REGISTRY_FALLBACK );
                
                goto EnumerateThroughCfg;
            }
        }
        
        else 
        {
        
EnumerateThroughCfg:

            //
            // enumerate and display the interface via the router config
            //
            
            rc = CfgEnumIpxIfs ( bDump );
            
            if ( rc == NO_ERROR )
            {
                //
                // Display RAs server interface IPX info. 
                //
                
                rc = GetIpxClientIf(
                        VAL_DIALINCLIENT, MSG_CLIENT_IPXIF_CFG_TABLE_FMT,
                        bDump
                        );
            }
        }

    }
    
    else 
    {
        //
        // Display IPX info for a specific interface
        //
        
        WCHAR       InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
        DWORD       dwSize = sizeof(InterfaceName);


        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            //
            // Display RAs server interface IPX info. 
            //

            rc = GetIpxClientIf( VAL_DIALINCLIENT, MSG_CLIENT_IPXIF_CFG_SCREEN_FMT, bDump );
        }
        
        else if ( g_hMIBServer) 
        {
            //======================================
            // Translate the Interface name
            //======================================
            
            rc = IpmontrGetIfNameFromFriendlyName(
                    argv[ 0 ], InterfaceName, &dwSize
                    );

            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc );
            }

            else
            {
                rc = MIBGetIpxIf ( InterfaceName );
            
                if ( rc != NO_ERROR )
                {
                    goto GetIfFromCfg;
                }
            }
        }
        else 
        {
        
GetIfFromCfg:
            //======================================
            // Translate the Interface Name

            //======================================
            
            rc = IpmontrGetIfNameFromFriendlyName(
                    argv[ 0 ], InterfaceName, &dwSize
                    );
                    
            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc );
            }

            else
            {
                rc = CfgGetIpxIf ( InterfaceName );
            }
        }
    }

    return rc;
}


DWORD
APIENTRY 
SetIpxIf(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This routine update the IPX settings for an interface.
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :


--*/
{
    DWORD       rc;
    PWCHAR      buffer = NULL;
    WCHAR       InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
    DWORD       dwSize = sizeof(InterfaceName);


    //
    // If interface name is specified
    //
    
    if ( argc >= 1 ) 
    {
        unsigned    count;
        BOOLEAN     client = FALSE;


        //
        // Check if the dial in interface is specified
        //
        
        if ( !_wcsicmp( argv[0], VAL_DIALINCLIENT ) )
        {
            client = TRUE;
        }
        
        else
        {
            count = wcslen( argv[ 0 ] );
        }

        if ( client || 
             ( ( count > 0 ) && ( count <= MAX_INTERFACE_NAME_LEN ) ) )
        {
            DWORD   i;
            ULONG   adminState, WANProtocol;
            PULONG  pAdminState = NULL, pWANProtocol = NULL;
            LPBYTE  pFltInBlock, pFltOutBlock;

            for ( i = 1; i < argc; i++ )
            {
                //
                // get admin state value if specified
                //
                
                if ( !_wcsicmp( argv[ i ], TOKEN_ADMINSTATE ) )
                {
                    if ( ( pAdminState == NULL ) && ( i < argc - 1 ) && 
                         !MatchEnumTag(
                            g_hModule, argv[ i + 1 ], 
                            NUM_TOKENS_IN_TABLE( AdminStates ), 
                            AdminStates, &adminState
                            ) )
                    {
                        i += 1;
                        pAdminState = &adminState;
                    }
                    
                    else
                    {
                        break;
                    }
                }


                //
                // get WAN protocol value if specified
                //
                
                else if ( !_wcsicmp( argv[ i ], TOKEN_WANPROTOCOL ) )
                {
                    if ( ( pWANProtocol == NULL ) && ( i < argc - 1 ) && 
                         !MatchEnumTag( 
                            g_hModule, argv[ i + 1 ],
                            NUM_TOKENS_IN_TABLE( WANProtocols ), 
                            WANProtocols, &WANProtocol
                            ) )
                    {
                        i += 1;
                        pWANProtocol = &WANProtocol;
                    }
                    
                    else
                    {
                        break;
                    }
                }


                //
                // Not a tag.  if Adminstate not specified then the first
                // option is Admin State
                //
                
                else if ( pAdminState == NULL )
                {
                    if ( !MatchEnumTag(
                            g_hModule, argv[ i ], 
                            NUM_TOKENS_IN_TABLE( AdminStates ), 
                            AdminStates, &adminState
                            ) )
                    {
                        pAdminState = &adminState;
                    }
                    
                    else
                    {
                        break;
                    }
                }

                //
                // Try WAN protocol last
                //
                
                else if ( pWANProtocol == NULL )
                {
                    if ( !MatchEnumTag(
                            g_hModule, argv[ i ],
                            NUM_TOKENS_IN_TABLE( AdminStates ), 
                            WANProtocols, &WANProtocol
                            ) )
                    {
                        pWANProtocol = &WANProtocol;
                    }
                    
                    else
                    {
                        break;
                    }
                }

                //
                // If none of these, quit
                //
                
                else
                {
                    break;
                }
            }


            if ( i == argc )
            {
                if ( !client )
                {
                    DWORD rc2;
                    
                    //======================================
                    // Translate the Interface Name
                    //======================================
                    
                    rc = IpmontrGetIfNameFromFriendlyName(
                            argv[ 0 ], InterfaceName, &dwSize 
                            );

                    if ( rc == NO_ERROR )
                    {
                        //
                        // Set to router config
                        //
                        
                        rc2 = CfgSetIpxIf( 
                                InterfaceName, pAdminState, pWANProtocol 
                                );
                                
                        if ( rc2 == NO_ERROR )
                        {
                            DisplayIPXMessage (g_hModule, MSG_IPXIF_SET_CFG, argv[0] );

                            //
                            // set to router service
                            //
                            
                            if ( g_hMprAdmin )
                            {
                                rc = AdmSetIpxIf( 
                                        InterfaceName, pAdminState, pWANProtocol
                                        );

                                if ( rc == NO_ERROR )
                                {
                                    DisplayIPXMessage (g_hModule, MSG_IPXIF_SET_ADM, argv[0] );
                                }
                            }
                        }
                        
                        else
                        {
                            rc = rc2;
                        }
                    }
                }
                
                else
                {
                    //
                    // set to router config and then to router service
                    //
                    
                    if ( ( rc = CfgSetIpxIf( NULL, pAdminState, pWANProtocol ) )
                            == NO_ERROR ) 
                    {
                        DisplayIPXMessage (g_hModule, MSG_CLIENT_IPXIF_SET_CFG );
                        
                        if ( g_hMprAdmin )
                        {
                            rc = AdmSetIpxIf(
                                    NULL, pAdminState, pWANProtocol
                                    );

                            if ( rc == NO_ERROR )
                            {
                                DisplayIPXMessage (g_hModule, MSG_CLIENT_IPXIF_SET_ADM );
                            }
                        }
                    }
                }
            }
            
            else 
            {
                DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
                rc = ERROR_INVALID_PARAMETER;
            }
        }
        
        else
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
        rc = ERROR_INVALID_PARAMETER;
    }

    if ( buffer )
    {
        FreeString( buffer );
    }
    
    return rc;
}




DWORD
APIENTRY 
InstallIpx(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This routine adds IPX interface configuration to an interface
    
Arguments :

    argc - Number of arguments

    argv - Argument array

Return value :

--*/

{
    DWORD        rc;

    if ( argc >= 1 )
    {
        WCHAR    InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
        unsigned count = sizeof(InterfaceName);
        

        //
        // Get If name
        //
        
        rc = IpmontrGetIfNameFromFriendlyName( argv[ 0 ], InterfaceName, &count );

        if ( rc != NO_ERROR )
        {
            count = 0;
        }
        
        if ( ( count > 0 ) && 
             ( count <= (MAX_INTERFACE_NAME_LEN+1)*sizeof(WCHAR) ) )
        {
            //
            // default interface info consists of 
            //  - IPX_IF_INFO
            //  - IPXWAN_IF_INFO
            //  - IPX_ADAPTER_INFO
            //  - RIP_IF_CONFIG
            //  - SAP_IF_CONFIG
            //
            
            LPBYTE block;
            ULONG  blockSize = 
                    FIELD_OFFSET (IPX_INFO_BLOCK_HEADER, TocEntry)
                    + sizeof (IPX_TOC_ENTRY)*5
                    + sizeof (IPX_IF_INFO)
                    + sizeof (IPXWAN_IF_INFO)
                    + sizeof (IPX_ADAPTER_INFO)
                    + FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter)
                    + FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);


            block = (LPBYTE) GlobalAlloc( GPTR, blockSize );
            
            if ( block != NULL )
            {
                HANDLE                  hIfCfg;
                PIPX_INFO_BLOCK_HEADER  hdr = (PIPX_INFO_BLOCK_HEADER)block;
                PIPX_IF_INFO            ipx = (PIPX_IF_INFO)&hdr->TocEntry[5];
                PIPXWAN_IF_INFO         wan = (PIPXWAN_IF_INFO)&ipx[1];
                PIPX_ADAPTER_INFO       adp = (PIPX_ADAPTER_INFO)&wan[1];
                PRIP_IF_CONFIG          rip = (PRIP_IF_CONFIG)&adp[1];
                PSAP_IF_CONFIG          sap = 
                    (PSAP_IF_CONFIG)&rip->RipIfFilters.RouteFilter;


                //
                // build infoblock for IPX interface info, with default values
                //
                
                hdr->Version = IPX_ROUTER_VERSION_1;
                hdr->Size = blockSize;
                hdr->TocEntriesCount = 5;

                hdr->TocEntry[0].InfoType = IPX_INTERFACE_INFO_TYPE;
                hdr->TocEntry[0].InfoSize = sizeof (IPX_IF_INFO);
                hdr->TocEntry[0].Count = 1;
                hdr->TocEntry[0].Offset = (ULONG) ((LPBYTE)ipx-block);
                ipx->AdminState = ADMIN_STATE_ENABLED;
                ipx->NetbiosAccept = ADMIN_STATE_DISABLED;
                ipx->NetbiosDeliver = ADMIN_STATE_DISABLED;

                hdr->TocEntry[1].InfoType = IPXWAN_INTERFACE_INFO_TYPE;
                hdr->TocEntry[1].InfoSize = sizeof (IPXWAN_IF_INFO);
                hdr->TocEntry[1].Count = 1;
                hdr->TocEntry[1].Offset = (ULONG) ((LPBYTE)wan-block);
                wan->AdminState = ADMIN_STATE_DISABLED;

                hdr->TocEntry[2].InfoType = IPX_ADAPTER_INFO_TYPE;
                hdr->TocEntry[2].InfoSize = sizeof (IPX_ADAPTER_INFO);
                hdr->TocEntry[2].Count = 1;
                hdr->TocEntry[2].Offset = (ULONG) ((LPBYTE)adp-block);
                adp->PacketType = AUTO_DETECT_PACKET_TYPE;
                adp->AdapterName[0] = 0;

                hdr->TocEntry[3].InfoType = IPX_PROTOCOL_RIP;
                hdr->TocEntry[3].InfoSize = FIELD_OFFSET (RIP_IF_CONFIG, RipIfFilters.RouteFilter);
                hdr->TocEntry[3].Count = 1;
                hdr->TocEntry[3].Offset = (ULONG) ((LPBYTE)rip-block);
                rip->RipIfInfo.AdminState = ADMIN_STATE_ENABLED;
                rip->RipIfInfo.UpdateMode = IPX_NO_UPDATE;
                rip->RipIfInfo.PacketType = IPX_STANDARD_PACKET_TYPE;
                rip->RipIfInfo.Supply = ADMIN_STATE_ENABLED;
                rip->RipIfInfo.Listen = ADMIN_STATE_ENABLED;
                rip->RipIfInfo.PeriodicUpdateInterval = 0;
                rip->RipIfInfo.AgeIntervalMultiplier = 0;
                rip->RipIfFilters.SupplyFilterCount = 0;
                rip->RipIfFilters.SupplyFilterAction = IPX_ROUTE_FILTER_DENY;
                rip->RipIfFilters.ListenFilterCount = 0;
                rip->RipIfFilters.ListenFilterAction = IPX_ROUTE_FILTER_DENY;

                hdr->TocEntry[4].InfoType = IPX_PROTOCOL_SAP;
                hdr->TocEntry[4].InfoSize = FIELD_OFFSET (SAP_IF_CONFIG, SapIfFilters.ServiceFilter);
                hdr->TocEntry[4].Count = 1;
                hdr->TocEntry[4].Offset = (ULONG) ((LPBYTE)sap-block);
                sap->SapIfInfo.AdminState = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.UpdateMode = IPX_NO_UPDATE;
                sap->SapIfInfo.PacketType = IPX_STANDARD_PACKET_TYPE;
                sap->SapIfInfo.Supply = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.Listen = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.GetNearestServerReply = ADMIN_STATE_ENABLED;
                sap->SapIfInfo.PeriodicUpdateInterval = 0;
                sap->SapIfInfo.AgeIntervalMultiplier = 0;
                sap->SapIfFilters.SupplyFilterCount = 0;
                sap->SapIfFilters.SupplyFilterAction = IPX_SERVICE_FILTER_DENY;
                sap->SapIfFilters.ListenFilterCount = 0;
                sap->SapIfFilters.ListenFilterAction = IPX_SERVICE_FILTER_DENY;


                //
                // Get handle to interface config
                //
                
                rc = MprConfigInterfaceGetHandle(
                        g_hMprConfig, InterfaceName, &hIfCfg
                        );
                        
                if ( rc == NO_ERROR )
                {
                    PMPR_INTERFACE_0    pRi0;
                    DWORD                sz;

                    //
                    // retrieve interface info from handle
                    //
                    
                    rc = MprConfigInterfaceGetInfo(
                            g_hMprConfig, hIfCfg, 0, (LPBYTE *)&pRi0, &sz
                            );
                            
                    if ( rc == NO_ERROR )
                    {
                        //
                        // IPX is always present on LAN interfaces.  It can
                        // only be added to WAN interfaces
                        //
                        
                        if ( pRi0->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )
                        {
                            HANDLE    hIfTrCfg;

                            //
                            // Add IPX to interface config
                            //
                            
                            rc = MprConfigInterfaceTransportAdd (
                                    g_hMprConfig,
                                    hIfCfg,
                                    PID_IPX,
                                    NULL,
                                    block, blockSize,
                                    &hIfTrCfg
                                    );
                                    
                            if ( rc == NO_ERROR )
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_IPXIF_ADD_CFG, InterfaceName
                                    );
                                    
                                if ( g_hMprAdmin )
                                {
                                    HANDLE hIfAdm;

                                    //
                                    // Router service is up.  DO the same
                                    // for it
                                    //
                                    
                                    rc = MprAdminInterfaceGetHandle(
                                            g_hMprAdmin, InterfaceName, 
                                            &hIfAdm, FALSE
                                            );
                                            
                                    if ( rc == NO_ERROR )
                                    {
                                        rc = MprAdminInterfaceTransportAdd(
                                                g_hMprAdmin,
                                                hIfAdm,
                                                PID_IPX,
                                                block, blockSize
                                                );
                                                
                                        if ( rc == NO_ERROR )
                                        {
                                            DisplayIPXMessage(
                                                g_hModule,
                                                MSG_IPXIF_ADD_ADM,
                                                InterfaceName
                                                );
                                        }
                                        
                                        else
                                        {
                                            DisplayError( g_hModule, rc );
                                        }
                                    }
                                    
                                    else
                                    {
                                        DisplayError( g_hModule, rc );
                                    }
                                }
                            }
                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        else 
                        {
                            DisplayIPXMessage (g_hModule, MSG_IPXIF_NOT_ROUTER );
                            rc = ERROR_INVALID_PARAMETER;
                        }
                        
                        MprConfigBufferFree( pRi0 );
                    }
                    else
                    {
                        DisplayError( g_hModule, rc );
                    }
                }
                
                else 
                if ( ( rc == ERROR_FILE_NOT_FOUND ) ||
                     ( rc == ERROR_NO_MORE_ITEMS ) )
                {
                    DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE);
                }
                else
                {
                    DisplayError( g_hModule, rc );
                }
                GlobalFree (block);
            }
            
            else 
            {
                rc = GetLastError ();

                if (rc != NO_ERROR )
                {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
                
                DisplayError( g_hModule, rc );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else 
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}

DWORD
APIENTRY 
RemoveIpx(
    IN      DWORD       argc,
    IN      LPCWSTR    *argv
    )
/*++

Routine Description :

    This routine removes IPX from a demand dial interface

    
Arguments :

    argc - Number of arguments

    argv - Argument array


Return value :

--*/

{
    DWORD        rc;

    if ( argc >= 1 )
    {
        WCHAR    InterfaceName[ MAX_INTERFACE_NAME_LEN + 1 ];
        unsigned count = sizeof(InterfaceName);
        

        //
        // Get interface name
        //
        
        rc = IpmontrGetIfNameFromFriendlyName( argv[ 0 ], InterfaceName, &count );

        if ( rc != NO_ERROR )
        {
            count = 0;
        }

        
        if ( ( count > 0 ) && 
             ( count <= (MAX_INTERFACE_NAME_LEN+1)*sizeof(WCHAR) ) )
        {
            //
            // remove IPX from demand-dial interface config
            //
            
            HANDLE  hIfCfg;
            
            rc = MprConfigInterfaceGetHandle(
                    g_hMprConfig, InterfaceName, &hIfCfg
                    );
                    
            if ( rc == NO_ERROR )
            {
                PMPR_INTERFACE_0    pRi0;
                DWORD                sz;

                rc = MprConfigInterfaceGetInfo(
                        g_hMprConfig,
                        hIfCfg,
                        0,
                        (LPBYTE *)&pRi0,
                        &sz
                        );
                        
                if ( rc == NO_ERROR )
                {
                    if ( pRi0->dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )
                    {
                        HANDLE    hIfTrCfg;
                        
                        rc = MprConfigInterfaceTransportGetHandle(
                                g_hMprConfig,
                                hIfCfg,
                                PID_IPX,
                                &hIfTrCfg 
                                );
                                
                        if ( rc == NO_ERROR )
                        {
                            rc = MprConfigInterfaceTransportRemove(
                                    g_hMprConfig,
                                    hIfCfg,
                                    hIfTrCfg
                                    );
                                    
                            if ( rc == NO_ERROR )
                            {
                                DisplayIPXMessage(
                                    g_hModule, MSG_IPXIF_DEL_CFG, InterfaceName
                                    );
                                    
                                if ( g_hMprAdmin )
                                {
                                    //
                                    // remove IPX from demand-dial interface 
                                    // in the router service
                                    //
            
                                    HANDLE hIfAdm;
                                    rc = MprAdminInterfaceGetHandle(
                                            g_hMprAdmin, InterfaceName, 
                                            &hIfAdm, FALSE
                                            );
                                            
                                    if ( rc == NO_ERROR )
                                    {
                                        rc = MprAdminInterfaceTransportRemove(
                                                g_hMprAdmin, hIfAdm, PID_IPX
                                                );
                                                
                                        if ( rc == NO_ERROR )
                                        {
                                            DisplayIPXMessage(
                                                g_hModule, MSG_IPXIF_DEL_ADM, 
                                                InterfaceName
                                                );
                                        }
                                        else
                                        {
                                            DisplayError( g_hModule, rc);
                                        }
                                    }
                                    else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
                                              ( rc == ERROR_NO_MORE_ITEMS ) )
                                    {
                                        DisplayIPXMessage( 
                                            g_hModule, 
                                            MSG_NO_IPX_ON_INTERFACE_ADM 
                                            );
                                    }
                                    else
                                    {
                                        DisplayError( g_hModule, rc );
                                    }
                                }
                            }
                            
                            else
                            {
                                DisplayError( g_hModule, rc );
                            }
                        }
                        
                        else 
                        if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
                             ( rc == ERROR_NO_MORE_ITEMS ) )
                        {
                            DisplayIPXMessage (g_hModule, MSG_NO_IPX_ON_INTERFACE_CFG );
                        }
                        else
                        {
                            DisplayError( g_hModule, rc);
                        }
                    }
                    
                    else 
                    {
                        DisplayIPXMessage ( g_hModule, MSG_IPXIF_NOT_ROUTER );
                        
                        rc = ERROR_INVALID_PARAMETER;
                    }
                    
                    MprConfigBufferFree( pRi0 );
                }
                else
                {
                    DisplayError( g_hModule, rc);
                }
            }
            else if ( ( rc == ERROR_FILE_NOT_FOUND ) ||
                      ( rc == ERROR_NO_MORE_ITEMS ) )
            {
                DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE );
            }
            else
            {
                DisplayError( g_hModule, rc);
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INVALID_INTERFACE_NAME );
            rc = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        DisplayIPXMessage (g_hModule, MSG_IPX_HELP_IPXIF );
        rc = ERROR_INVALID_PARAMETER;
    }
    
    return rc;
}



PIPX_IF_INFO 
GetIpxInterface(
    HANDLE hIf, 
    LPBYTE *pIfBlock
    )
/*++

Routine Description :

    This routine retrieves the IPX_INTERFACE_INFO_TYPE block in the
    interface configuration.  The interface conf. is retrieved from 
    the router.
    
Arguments :

    hIf - Handle to the interface config.

    pIfBlock - Buffer to return requested info.
    
Return value :

--*/

{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;
    
    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if ( dwErr != NO_ERROR )
    {
        return NULL;
    }

    pIpxToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)( *pIfBlock ),
                IPX_INTERFACE_INFO_TYPE
                );
                
    if ( !pIpxToc )
    {
        return NULL;
    }
    
    return (PIPX_IF_INFO)( ( *pIfBlock ) + ( pIpxToc->Offset ) );
}


BOOL 
IsIpxInterface(
    HANDLE hIf, 
    LPDWORD lpdwEnabled
    )
/*++

Routine Description :

    This routine checks if the specified interface is enabled for IPX 
    on the router.  
    
Arguments :

    hIf - Handle to the interface config. 

    lpdwEnabled - On return contains the admin state.
    
Return value :

    
--*/
{
    PIPX_INTERFACE            pIf;
    DWORD dwSize;
    DWORD dwErr;
    BOOL ret;
    
    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, (LPBYTE*)&pIf, &dwSize
                );

    if ( dwErr == NO_ERROR )
    {
        ret = TRUE;
        
        if ( lpdwEnabled )
        {
            *lpdwEnabled = pIf->AdminState;
        }
    }
    
    else
    {
        ret = FALSE;
    }
    
    MprAdminBufferFree( (LPBYTE) pIf );

    return ret;
}


DWORD
MIBGetIpxIf (
    PWCHAR      InterfaceName
    ) 
/*++

Routine Description :

    This routine retrives the interface configuration for the specified
    interface from the router.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    

Return value :

--*/
{
    INT                     i;
    DWORD                   rc;
    DWORD                   sz;
    IPX_MIB_GET_INPUT_DATA  MibGetInputData;
    PIPX_INTERFACE          pIf;
    WCHAR                   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    

    MibGetInputData.TableId = IPX_INTERFACE_TABLE;
    
    rc = GetIpxInterfaceIndex(
            g_hMIBServer, InterfaceName,
            &MibGetInputData.MibIndex.InterfaceTableIndex.InterfaceIndex
            );
            
    if ( rc == NO_ERROR )
    {
        rc = MprAdminMIBEntryGet(
                g_hMIBServer, PID_IPX, IPX_PROTOCOL_BASE, &MibGetInputData,
                sizeof( IPX_MIB_GET_INPUT_DATA ), (LPVOID *)&pIf, &sz
                );
                
        if ( rc == NO_ERROR && pIf)
        {
            PWCHAR buffer[4];
            
            //======================================
            // Translate the Interface Name
            //======================================
            sz = sizeof(IfDisplayName);
            
            rc = IpmontrGetFriendlyNameFromIfName(
                    InterfaceName, IfDisplayName, &sz
                    );

            if ( rc == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString( 
                                g_hModule, pIf->InterfaceType, 
                                NUM_VALUES_IN_TABLE( IpxInterfaceTypes ),
                                IpxInterfaceTypes 
                              );

                buffer[ 1 ] = ( pIf-> InterfaceType == IF_TYPE_LAN ) || 
                              ( pIf-> InterfaceType == IF_TYPE_INTERNAL ) ?
                              VAL_NA :
                              GetEnumString( 
                                g_hModule, pIf->EnableIpxWanNegotiation,
                                NUM_VALUES_IN_TABLE( WANProtocols ),
                                WANProtocols
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIf->AdminState, 
                                NUM_VALUES_IN_TABLE( AdminStates ),
                                AdminStates
                                );
                                
                buffer[ 3 ] = GetEnumString(
                                g_hModule, pIf->IfStats.IfOperState, 
                                NUM_VALUES_IN_TABLE( OperStates ),
                                OperStates
                                );

                if ( buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] && buffer[ 3 ] )
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_IPXIF_MIB_SCREEN_FMT, IfDisplayName,
                        buffer[ 0 ], buffer[ 1 ], buffer[ 2 ], buffer[3],
                        pIf->NetNumber[0], pIf->NetNumber[1],
                        pIf->NetNumber[2], pIf->NetNumber[3],
                        pIf->MacAddress[0], pIf->MacAddress[1],
                        pIf->MacAddress[2], pIf->MacAddress[3],
                        pIf->MacAddress[4], pIf->MacAddress[5],
                        pIf->IfStats.InHdrErrors,
                        pIf->IfStats.InFiltered,
                        pIf->IfStats.InNoRoutes, 
                        pIf->IfStats.InDiscards, 
                        pIf->IfStats.InDelivers, 
                        pIf->IfStats.OutFiltered,
                        pIf->IfStats.OutDiscards,
                        pIf->IfStats.OutDelivers
                        );
                }

                MprAdminMIBBufferFree (pIf);
            }

            else
            {
                DisplayError( g_hModule, rc );
            }

        }
        else
        {
            DisplayError( g_hModule, rc);
        }
    }
    else
    {
        DisplayError( g_hModule, rc);
    }
    
    return rc;
}


DWORD
CfgGetIpxIf(
    LPWSTR    InterfaceNameW
    ) 
/*++

Routine Description :

    This routine retrives the interface configuration for the specified
    interface from the router configuration.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    

Return value :

--*/
{
    DWORD   rc, i;
    DWORD   sz;
    HANDLE  hIfCfg;
    WCHAR   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];


    //
    // get handle to interface config
    //
    
    rc = MprConfigInterfaceGetHandle (
            g_hMprConfig, InterfaceNameW, &hIfCfg
            );
            
    if ( rc == NO_ERROR )
    {
        PMPR_INTERFACE_0    pRi0;

        
        rc = MprConfigInterfaceGetInfo(
                g_hMprConfig, hIfCfg, 0, (LPBYTE *)&pRi0, &sz
                );
                
        if ( rc == NO_ERROR )
        {
            HANDLE  hIfTrCfg;

            rc = MprConfigInterfaceTransportGetHandle(
                    g_hMprConfig, hIfCfg, PID_IPX,  &hIfTrCfg
                    );
                    
            if ( rc == NO_ERROR )
            {
                LPBYTE    pIfBlock;
                
                rc = MprConfigInterfaceTransportGetInfo (
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
                        
                if (rc == NO_ERROR)
                {
                    PIPX_TOC_ENTRY pIpxToc;
                    PIPX_TOC_ENTRY pIpxWanToc;

                    pIpxToc = GetIPXTocEntry(
                                (PIPX_INFO_BLOCK_HEADER)pIfBlock, 
                                IPX_INTERFACE_INFO_TYPE
                                );

                    pIpxWanToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPXWAN_INTERFACE_INFO_TYPE
                                    );
                                    
                    if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
                    {
                        PIPX_IF_INFO    pIpxInfo;
                        PIPXWAN_IF_INFO pIpxWanInfo;
                        PWCHAR           buffer[3];

                        pIpxInfo = (PIPX_IF_INFO)
                                (pIfBlock+pIpxToc->Offset);
                                
                        pIpxWanInfo = (PIPXWAN_IF_INFO)
                                (pIfBlock+pIpxWanToc->Offset);
                                
                        //======================================
                        // Translate the Interface Name
                        //======================================
                        sz = sizeof(IfDisplayName);
                        
                        rc = IpmontrGetFriendlyNameFromIfName(
                                InterfaceNameW, IfDisplayName, &sz
                                );

                        if ( rc == NO_ERROR )
                        {
                            buffer[ 0 ] = GetEnumString(
                                            g_hModule, pRi0->dwIfType,
                                            NUM_VALUES_IN_TABLE( RouterInterfaceTypes ),
                                            RouterInterfaceTypes
                                            );

                            buffer[ 1 ] = GetEnumString(
                                            g_hModule, pIpxInfo->AdminState,
                                            NUM_VALUES_IN_TABLE( AdminStates ),
                                            AdminStates
                                            );


                            buffer[ 2 ] = ( pRi0-> dwIfType == ROUTER_IF_TYPE_DEDICATED ) ?
                                          VAL_NA :
                                          GetEnumString( 
                                            g_hModule, pIpxWanInfo->AdminState,
                                            NUM_VALUES_IN_TABLE( WANProtocols ),
                                            WANProtocols
                                            );

                            if ( buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                            {
                                //======================================
                                DisplayIPXMessage (g_hModule,
                                    MSG_IPXIF_CFG_SCREEN_FMT, IfDisplayName,
                                    buffer[0], buffer[1], buffer[2]
                                    );
                            }
                         }
                    }
                    else 
                    {
                        DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
                        rc = ERROR_INVALID_DATA;
                    }
                }
                else 
                {
                    DisplayError( g_hModule, rc );
                }
                
                MprConfigBufferFree( pIfBlock );
            }
            
            else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
                      ( rc == ERROR_NO_MORE_ITEMS ) )
            {
                DisplayIPXMessage (g_hModule, MSG_NO_IPX_ON_INTERFACE_CFG );
            }
            else 
            {
                DisplayError( g_hModule, rc );
            }
            
            MprConfigBufferFree (pRi0);
        }
    }
    else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
              ( rc == ERROR_NO_MORE_ITEMS ) )
    {
        DisplayError( g_hModule, ERROR_NO_SUCH_INTERFACE );
    }
    else
    {
        DisplayError( g_hModule, rc );
    }
    
    return rc;
}


DWORD
GetIpxClientIf (
    PWCHAR  InterfaceName,
    UINT    msg,
    BOOL    bDump
    ) 
/*++

Routine Description :

    This routine retrives the interface configuration for the dialin
    interface from the router service/config as specified.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    
    msg - Format of display output 
    

Return value :

--*/
{
    DWORD   rc, i;
    LPBYTE  pClBlock = NULL, pAdmClBlock = NULL;
    LPWSTR  FltInNameW = NULL, FltOutNameW = NULL;
    HANDLE  hTrCfg;


    rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );
    
    if ( rc == NO_ERROR )
    {
        DWORD    sz;

        rc = MprConfigTransportGetInfo( 
                g_hMprConfig, hTrCfg, NULL, NULL, &pClBlock, &sz, NULL
                );
                
        if ( rc == NO_ERROR )
        {
            PIPX_TOC_ENTRY pIpxToc;
            PIPX_TOC_ENTRY pIpxWanToc;

            if ( g_hMprAdmin ) 
            {
                DWORD   rc1;
                DWORD   sz;
                
                rc1 = MprAdminTransportGetInfo(
                        g_hMprAdmin, PID_IPX, NULL, NULL, &pAdmClBlock, &sz
                        );
                        
                if ( rc1 == NO_ERROR ) 
                {
                    MprConfigBufferFree( pClBlock );
                    pClBlock = pAdmClBlock;
                }
                
                else 
                {
                    pAdmClBlock = NULL;
                    DisplayError( g_hModule, rc1 );
                }
            }

            
            pIpxToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER) pClBlock, IPX_INTERFACE_INFO_TYPE
                        );
                        
            pIpxWanToc = GetIPXTocEntry (
                            (PIPX_INFO_BLOCK_HEADER)pClBlock, IPXWAN_INTERFACE_INFO_TYPE
                            );
                            
            if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
            {
                PIPX_IF_INFO    pIpxInfo;
                PIPXWAN_IF_INFO pIpxWanInfo;
                PWCHAR          buffer[3];
                
                pIpxInfo = ( PIPX_IF_INFO ) ( pClBlock + pIpxToc-> Offset );
                pIpxWanInfo = ( PIPXWAN_IF_INFO ) ( pClBlock + pIpxWanToc-> Offset );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, pIpxInfo->AdminState,
                                NUM_VALUES_IN_TABLE( AdminStates ), AdminStates
                                );

                buffer[ 0 ] = GetEnumString(
                                g_hModule, ROUTER_IF_TYPE_CLIENT,
                                NUM_VALUES_IN_TABLE( RouterInterfaceTypes ), 
                                RouterInterfaceTypes
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIpxWanInfo->AdminState,
                                NUM_VALUES_IN_TABLE( WANProtocols ), 
                                WANProtocols
                                );

                if ( bDump )
                {
                    DisplayMessageT( 
                        DMP_IPX_SET_WAN_INTERFACE, InterfaceName, buffer[ 2 ],
                        buffer[ 1 ]
                        );
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, msg, buffer[2], buffer[ 0 ], buffer[ 1 ],
                        InterfaceName
                        );
                }
            }
            else 
            {
                if ( !bDump )
                {
                    DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
                }
                
                rc = ERROR_INVALID_DATA;
            }
            
            if ( pAdmClBlock != NULL )
            {
                MprAdminBufferFree( pClBlock );
            }
            else
            {
                MprConfigBufferFree( pClBlock );
            }
        }
        else
        {
             if ( !bDump )
             {
                DisplayError( g_hModule, rc );
             }
        }
    }
    else if ( ( rc == ERROR_FILE_NOT_FOUND ) || 
              ( rc == ERROR_NO_MORE_ITEMS ) )
    {
        if ( !bDump )
        {
            DisplayIPXMessage (g_hModule, MSG_NO_IPX_IN_ROUTER_CFG );
        }
    }
    else
    {
        if ( !bDump )
        {
            DisplayError( g_hModule, rc );
        }
    }

    return rc;
}

// Error reporting
void PrintErr(DWORD err)
{
    WCHAR buf[1024];
    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,0,buf,1024,NULL);
    wprintf(buf);
    wprintf(L"\n");
}



DWORD
MIBEnumIpxIfs(
    BOOL        bDump
    )
/*++

Routine Description :

    This routine enumerates the interfaces from the router service and
    displays them.

    
Arguments :

    InterfaceName - Name of interface for which config is requested.
    
    msg - Format of display output 
    

Return value :

--*/
{
    PMPR_INTERFACE_0 IfList=NULL;
    DWORD dwErr=0, dwRead, dwTot,i, j;
    PWCHAR buffer[4];
    LPBYTE pszBuf = NULL;
    WCHAR IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];
    PIPX_IF_INFO pIf;
    PIPXWAN_IF_INFO pWanIf;
    DWORD dwSize = sizeof(IfDisplayName);

    if ( !bDump )
    {
        DisplayIPXMessage (g_hModule, MSG_IPXIF_MIB_TABLE_HDR );
    }
    
    dwErr = MprAdminInterfaceEnum(
                g_hMprAdmin, 0, (unsigned char **)&IfList, MAXULONG, &dwRead,
                &dwTot,NULL
                );
                
    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    if ( dwRead && bDump )
    {
        //
        // If interface are present and this is a dump command
        // display dump header.
        //
        
        DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_IF_HEADER);
    }

    
    for ( i = 0; i < dwRead; i++ )
    {
        if ( ( pIf = GetIpxNbInterface( IfList[i].hInterface, &pszBuf, &pWanIf ) ) 
             != NULL )
        {
            //======================================
            // Translate the Interface Name
            //======================================
            
            dwErr = IpmontrGetFriendlyNameFromIfName(
                        IfList[i].wszInterfaceName,
                       IfDisplayName, &dwSize
                       );

            if ( dwErr == NO_ERROR )
            {
                buffer[ 0 ] = GetEnumString(
                                g_hModule, IfList[i].dwIfType,
                                NUM_VALUES_IN_TABLE( InterfaceTypes ),
                                InterfaceTypes
                                );

                buffer[ 1 ] = GetEnumString(
                                g_hModule, pIf->AdminState,
                                NUM_VALUES_IN_TABLE( AdminStates ),
                                AdminStates
                                );

                buffer[ 2 ] = GetEnumString(
                                g_hModule, IfList[i].dwConnectionState,
                                NUM_VALUES_IN_TABLE( InterfaceStates ),
                                InterfaceStates
                                );

                if ( bDump )
                {
                    if ( IfList[i].dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )
                    {
                        DisplayMessageT( 
                            DMP_IPX_ADD_INTERFACE, IfDisplayName
                            );

                        //
                        // Whistler bug 299007 ipxmontr.dll prefast warnings
                        //

                        buffer[ 3 ] = GetEnumString( 
                                        g_hModule, pWanIf->AdminState,
                                        NUM_VALUES_IN_TABLE( WANProtocols ),
                                        WANProtocols
                                        );

                        DisplayMessageT(
                            DMP_IPX_SET_WAN_INTERFACE, IfDisplayName, buffer[ 1 ],
                            buffer[ 3 ]
                            );
                    }

                    else
                    {
                        DisplayMessageT(
                            DMP_IPX_SET_INTERFACE, IfDisplayName, buffer[ 1 ]
                            );
                    }
                }

                else
                {
                    DisplayIPXMessage(
                        g_hModule, MSG_IPXIF_MIB_TABLE_FMT,
                        buffer[2], buffer[1], L"", buffer[0],
                        IfDisplayName
                        );
                }
            }
        }
        MprAdminBufferFree (pszBuf);
    }

    MprAdminBufferFree( IfList );
    return NO_ERROR;
}



DWORD
CfgEnumIpxIfs (
    BOOL   bDump
    ) 
/*++

Routine Description :

    This routine enumerates the interfaces from the router configuration and
    displays them.

    
Arguments :


Return value :

--*/
{
    DWORD   rc = NO_ERROR;
    DWORD   read, total, processed=0, i, j;
    DWORD   hResume = 0;
    DWORD   sz;
    WCHAR   IfDisplayName[ MAX_INTERFACE_NAME_LEN + 1 ];   
    PMPR_INTERFACE_0    pRi0;
    DWORD   dwSize = sizeof(IfDisplayName);


    if ( !bDump )
    {
        DisplayIPXMessage (g_hModule, MSG_IPXIF_CFG_TABLE_HDR );
    }
    
    
    do 
    {
        rc = MprConfigInterfaceEnum(
                g_hMprConfig,  0, (LPBYTE *)&pRi0, MAXULONG, &read, &total,
                &hResume
                );
                
        if ( rc == NO_ERROR )
        {
            if ( read && bDump )
            {
                //
                // If interface are present and this is a dump command
                // display dump header.
                //
                
                DisplayIPXMessage (g_hModule, MSG_IPX_DUMP_IF_HEADER);
            }

            
            for ( i = 0; i < read; i++ )
            {
                HANDLE        hIfTrCfg;

                rc = MprConfigInterfaceTransportGetHandle (
                        g_hMprConfig,  pRi0[i].hInterface, PID_IPX,
                        &hIfTrCfg
                        );
                        
                if ( rc == NO_ERROR )
                {
                    LPBYTE    pIfBlock;
                    rc = MprConfigInterfaceTransportGetInfo(
                            g_hMprConfig, pRi0[i].hInterface, hIfTrCfg,
                            &pIfBlock, &sz
                            );
                            
                    if (rc == NO_ERROR) 
                    {
                        PIPX_TOC_ENTRY pIpxToc;
                        PIPX_TOC_ENTRY pIpxWanToc;

                        pIpxToc = GetIPXTocEntry(
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPX_INTERFACE_INFO_TYPE
                                    );
                                    
                        pIpxWanToc = GetIPXTocEntry (
                                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                                    IPXWAN_INTERFACE_INFO_TYPE
                                    );
                                    
                        if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
                        {
                            PIPX_IF_INFO    pIpxInfo;
                            PIPXWAN_IF_INFO pIpxWanInfo;
                            PWCHAR           buffer[3];

                            pIpxInfo = (PIPX_IF_INFO) (pIfBlock+pIpxToc->Offset);
                            
                            pIpxWanInfo = (PIPXWAN_IF_INFO) (pIfBlock+pIpxWanToc->Offset);

                            //======================================
                            // Translate the Interface Name
                            //======================================
                            rc = IpmontrGetFriendlyNameFromIfName(
                                    pRi0[i].wszInterfaceName,
                                    IfDisplayName, &dwSize
                                    );

                            if ( rc == NO_ERROR )
                            {
                                //======================================
                                
                                buffer[ 0 ] = GetEnumString(
                                                g_hModule, pRi0[i].dwIfType,
                                                NUM_VALUES_IN_TABLE( RouterInterfaceTypes ),
                                                RouterInterfaceTypes
                                                );

                                buffer[ 2 ] = GetEnumString(
                                                g_hModule, pIpxInfo->AdminState,
                                                NUM_VALUES_IN_TABLE( AdminStates ),
                                                AdminStates
                                                );


                                buffer[ 1 ] = ( pRi0[i].dwIfType == ROUTER_IF_TYPE_DEDICATED ) ||
                                              ( pRi0[i].dwIfType == ROUTER_IF_TYPE_INTERNAL ) ?
                                              VAL_NA :
                                              GetEnumString( 
                                                g_hModule, pIpxWanInfo->AdminState,
                                                NUM_VALUES_IN_TABLE( WANProtocols ),
                                                WANProtocols
                                                );

                                if ( buffer[ 0 ] && buffer[ 1 ] && buffer[ 2 ] )
                                {
                                    if ( bDump )
                                    {
                                        if ( pRi0[i].dwIfType == ROUTER_IF_TYPE_FULL_ROUTER )                                            
                                        {
                                            DisplayMessageT( 
                                                DMP_IPX_ADD_INTERFACE, IfDisplayName
                                                );
                                                
                                            DisplayMessageT(
                                                DMP_IPX_SET_WAN_INTERFACE, IfDisplayName, buffer[ 2 ],
                                                buffer[ 1 ]
                                                );
                                        }

                                        else
                                        {
                                            DisplayMessageT(
                                                DMP_IPX_SET_INTERFACE, IfDisplayName, buffer[ 2 ]
                                                );
                                        }
                                    }

                                    else
                                    {
                                        DisplayIPXMessage(
                                            g_hModule, MSG_IPXIF_CFG_TABLE_FMT,
                                            buffer[2], buffer[0], buffer[1], 
                                            IfDisplayName
                                            );
                                    }
                                }
                            }
                        }
                        else
                        {
                            rc = ERROR_INVALID_DATA;

                            if ( !bDump )
                            {
                                DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
                            }
                        }
                    }
                    
                    else if ( rc != ERROR_NO_MORE_ITEMS ) 
                    {
                        if ( !bDump )
                        {
                            DisplayError( g_hModule, rc);
                        }
                    }
                }
                else 
                {
                    //DisplayError( g_hModule, rc);    // This is not needed
                }
            }
            
            processed += read;
            MprConfigBufferFree( pRi0 );
        }
        else 
        {
            DisplayError( g_hModule, rc );
            break;
        }
        
    } while ( processed < total );

    return rc;
}


DWORD
CfgSetIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pWANProtocol      OPTIONAL
    ) 
/*++

Routine Description :

    This routine updates the interface setting in the router configuration.

    
Arguments :

    InterfaceNameW - Name of interface being updated

    pAdminState - New value for adminstate

    pWANProtocol - New value for WAN protocol

Return value :

--*/

{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hTrCfg;
    HANDLE        hIfCfg;
    HANDLE        hIfTrCfg;
    LPBYTE        pIfBlock;


    if ( InterfaceNameW != NULL )
    {
        rc = MprConfigInterfaceGetHandle( 
                g_hMprConfig, InterfaceNameW, &hIfCfg 
                );
                
        if ( rc == NO_ERROR )
        {
            rc = MprConfigInterfaceTransportGetHandle(
                    g_hMprConfig, hIfCfg, PID_IPX, &hIfTrCfg
                    );
                    
            if ( rc == NO_ERROR )
            {
                rc = MprConfigInterfaceTransportGetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, &pIfBlock, &sz
                        );
            }
        }
    }
    
    else 
    {
        rc = MprConfigTransportGetHandle( g_hMprConfig, PID_IPX, &hTrCfg );
        
        if ( rc == NO_ERROR )
        {
            rc = MprConfigTransportGetInfo(
                    g_hMprConfig, hTrCfg, NULL, NULL, &pIfBlock, &sz, NULL
                    );
        }
    }

    if ( rc == NO_ERROR ) 
    {
        PIPX_TOC_ENTRY pIpxToc;
        PIPX_TOC_ENTRY pIpxWanToc;

        pIpxToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        pIpxWanToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPXWAN_INTERFACE_INFO_TYPE
                    );
                    
        if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
        {
            PIPX_IF_INFO    pIpxInfo;
            PIPXWAN_IF_INFO    pIpxWanInfo;

            pIpxInfo = (PIPX_IF_INFO) (pIfBlock+pIpxToc->Offset);
            
            pIpxWanInfo = (PIPXWAN_IF_INFO) (pIfBlock+pIpxWanToc->Offset);
            

            if ( ARGUMENT_PRESENT( pAdminState ) )
            {
                pIpxInfo->AdminState = *pAdminState;
            }
            
            if ( ARGUMENT_PRESENT( pWANProtocol ) )
            {
                pIpxWanInfo->AdminState = *pWANProtocol;
            }

            if ( InterfaceNameW != NULL )
            {
                rc = MprConfigInterfaceTransportSetInfo(
                        g_hMprConfig, hIfCfg, hIfTrCfg, pIfBlock, sz
                        );
            }
            
            else
            {
                rc = MprConfigTransportSetInfo(
                        g_hMprConfig, hTrCfg, NULL, 0, pIfBlock, sz, NULL
                        );
            }
            
            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc );
            }
        }
        else 
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
            rc = ERROR_INVALID_DATA;
        }
        
        MprConfigBufferFree( pIfBlock );
    }
    
    else
    {
        DisplayError( g_hModule, rc );
    }

    return rc;
}


DWORD
AdmSetIpxIf (
    LPWSTR        InterfaceNameW,
    PULONG        pAdminState       OPTIONAL,
    PULONG        pWANProtocol      OPTIONAL
    ) 
/*++

Routine Description :

    This routine updates the interface setting in the router service.

    
Arguments :

    InterfaceNameW - Name of interface being updated

    pAdminState - New value for adminstate

    pWANProtocol - New value for WAN protocol

Return value :

--*/

{
    DWORD        rc;
    DWORD        sz;
    HANDLE        hIfAdm;
    LPBYTE        pIfBlock;
 
    if ( InterfaceNameW != NULL )
    {
        rc = MprAdminInterfaceGetHandle(
                g_hMprAdmin, InterfaceNameW, &hIfAdm, FALSE
                );
                
        if ( rc == NO_ERROR ) 
        {
            rc = MprAdminInterfaceTransportGetInfo(
                    g_hMprAdmin, hIfAdm, PID_IPX, &pIfBlock, &sz
                    );
        }
    }
    
    else 
    {
        rc = MprAdminTransportGetInfo(
                g_hMprAdmin, PID_IPX, NULL, NULL, &pIfBlock, &sz
                );
                
        if ( rc == NO_ERROR )
        {
            if ( pIfBlock == NULL ) { return rc; }
        }
    }

    if ( rc == NO_ERROR )
    {
        PIPX_TOC_ENTRY pIpxToc;
        PIPX_TOC_ENTRY pIpxWanToc;

        pIpxToc = GetIPXTocEntry(
                    (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                    IPX_INTERFACE_INFO_TYPE
                    );
                    
        pIpxWanToc = GetIPXTocEntry(
                        (PIPX_INFO_BLOCK_HEADER)pIfBlock,
                        IPXWAN_INTERFACE_INFO_TYPE
                        );
                         
        if ( ( pIpxToc != NULL ) && ( pIpxWanToc != NULL ) )
        {
            PIPX_IF_INFO    pIpxInfo;
            PIPXWAN_IF_INFO pIpxWanInfo;
            

            pIpxInfo = (PIPX_IF_INFO) (pIfBlock + pIpxToc-> Offset);
            pIpxWanInfo = (PIPXWAN_IF_INFO) (pIfBlock + pIpxWanToc-> Offset);

            if ( ARGUMENT_PRESENT( pAdminState ) ) 
            {
                pIpxInfo->AdminState = *pAdminState;
            }
            
            if (ARGUMENT_PRESENT( pWANProtocol) )
            {
                pIpxWanInfo->AdminState = *pWANProtocol;
            }

            if ( InterfaceNameW != NULL )
            {
                rc = MprAdminInterfaceTransportSetInfo(
                        g_hMprAdmin, hIfAdm, PID_IPX, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }
            else
            {
                rc = MprAdminTransportSetInfo(
                        g_hMprAdmin, PID_IPX, NULL, 0, pIfBlock,
                        ((PIPX_INFO_BLOCK_HEADER)pIfBlock)->Size
                        );
            }

            
            if ( rc != NO_ERROR )
            {
                DisplayError( g_hModule, rc);
            }
        }
        
        else
        {
            DisplayIPXMessage (g_hModule, MSG_INTERFACE_INFO_CORRUPTED );
            rc = ERROR_INVALID_DATA;
        }
        
        MprAdminBufferFree( pIfBlock );
    }
    
    else 
    {
        DisplayError( g_hModule, rc );
    }

    return rc;
}


PIPX_IF_INFO
GetIpxNbInterface(
    HANDLE hIf, 
    LPBYTE *pIfBlock,
    PIPXWAN_IF_INFO *ppWanIf
    ) 
{
    DWORD dwSize;
    DWORD dwErr;
    PIPX_TOC_ENTRY pIpxToc;

    dwErr = MprAdminInterfaceTransportGetInfo(
                g_hMprAdmin, hIf, PID_IPX, pIfBlock, &dwSize
                );

    if ( dwErr != NO_ERROR )
    {
        return NULL;
    }


    pIpxToc = GetIPXTocEntry(
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock),
                IPXWAN_INTERFACE_INFO_TYPE
                );

    if ( pIpxToc )
    {
        *ppWanIf = (PIPXWAN_IF_INFO) ((*pIfBlock)+(pIpxToc->Offset));
    }
    
    pIpxToc = GetIPXTocEntry (
                (PIPX_INFO_BLOCK_HEADER)(*pIfBlock),
                IPX_INTERFACE_INFO_TYPE
                );
                
    if (!pIpxToc)
    {
        return NULL;
    }

    return (PIPX_IF_INFO)((*pIfBlock)+(pIpxToc->Offset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\netsh\ipx\ipxmon\ipxhandle.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    routing\netsh\ipx\ipxhandle.c

Abstract:

    IPX Command handler.

Revision History:

    V Raman                     12/2/98  Created

--*/

#include "precomp.h"
#pragma hdrstop


DWORD
HandleIpxInterface(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

DWORD
HandleIpxStaticRoute(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

DWORD
HandleIpxStaticService(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

DWORD
HandleIpxTrafficFilters(
    IN OUT  LPWSTR          *ppwcArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwArgCount,
    IN      IPX_OPERATION   ioOP
);

//
// Handle static route operations
//

DWORD
HandleIpxAddRoute(
    IN      LPCWSTR     pwszMachineName,
    IN OUT  LPWSTR      *ppwcArguments,
    IN      DWORD       dwCurrentIndex,
    IN      DWORD       dwArgCount,
    IN      DWORD       dwFlags,
    IN      LPCVOID       pvData,
    OUT     PBOOL       pbDone
    )
/*++

Routine Description :

    This function handles addition of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD
                );
}


DWORD
HandleIpxDelRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles deletion of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE
                );
}




DWORD
HandleIpxSetRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles update of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET
                );
}



DWORD
HandleIpxShowRoute(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles display of static IPX routes by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticRoute( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW
                );
}




DWORD
HandleIpxStaticRoute(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle static route operations
    
Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr) 
    {
        break;
    }


    if ( ( dwCurrentIndex < dwArgCount ) &&
           !_wcsnicmp( 
                ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName )
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = CreateStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = DeleteStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowStRt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }

  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}


//
// Handle static service operations
//

DWORD
HandleIpxAddService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles addition of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD
                );
}


DWORD
HandleIpxDelService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles deletion of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE
                );
}



DWORD
HandleIpxSetService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles update of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET
                );
}


DWORD
HandleIpxShowService(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles display of static IPX services by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxStaticService( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW
                );
}



DWORD
HandleIpxStaticService(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)

/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle static service operations
    
Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr)
    {
        break;
    }

    if ( ( dwCurrentIndex < dwArgCount ) &&
           !_wcsnicmp( 
                ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName ) 
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = CreateStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = DeleteStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowStSvc( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }

  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}



//
// Handle packet filter operations
//

DWORD
HandleIpxAddFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles addition of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_ADD
                );
}



DWORD
HandleIpxDelFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles deletion of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_DELETE
                );
}



DWORD
HandleIpxSetFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles update of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SET
                );
}



DWORD
HandleIpxShowFilter(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This function handles display of IPX traffic filters by
    mapping the parameters to those required by the corresp.
    routemon routine.


Arguments :

    ppwcArguments - list of arguments to the add route command

    dwCurrentIndex - index of current argument in the argument table

    dwArgCount - Number of arguments in the argument table

    pbDone - As yet undetermined


Return Value

    NO_ERROR - Success

--*/
{
    return HandleIpxTrafficFilters( 
                ppwcArguments, dwCurrentIndex, dwArgCount, IPX_OPERATION_SHOW
                );
}



DWORD
HandleIpxTrafficFilters(
    IN OUT  LPWSTR          *ppwcOldArguments,
    IN      DWORD           dwCurrentIndex,
    IN      DWORD           dwOldArgCount,
    IN      IPX_OPERATION   ioOP
)
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handle traffic filter operations
    
Arguments :
    ppwcArguments - command line argument array
    dwCurrentIndex - current argument under consideration
    dwArgCount - Number of arguments in ppwcArguments
    bAdd - flag indicating whether IPX is being added or deleted

Return Value :

--*/
{
    DWORD   dwErr;
    BOOL    bFreeNewArg = FALSE;
    PWCHAR  pwszIfName;
    DWORD   dwArgCount = dwOldArgCount;
    PWCHAR *ppwcArguments = NULL;
    
    //
    // Check if name= option is specified
    //

    pwszIfName = TOKEN_INTERFACE_NAME;

    if ( pwszIfName == NULL )
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

        DisplayError( g_hModule, dwErr );

        return dwErr;
    }

  do {
    // Munge arguments into old format
    dwErr = MungeArguments(
            ppwcOldArguments, dwOldArgCount, (PBYTE *) &ppwcArguments,
            &dwArgCount, &bFreeNewArg
            );
    if (dwErr)
    {
        break;
    }

    if ( ( dwCurrentIndex < dwArgCount ) &&
           !_wcsnicmp( 
             ppwcArguments[ dwCurrentIndex ], pwszIfName, wcslen( pwszIfName ) 
            ) )
    {
        //
        // ok name= option tag specified, remove it and the following space
        //

        wcscpy( 
            ppwcArguments[ dwCurrentIndex ], 
            &ppwcArguments[ dwCurrentIndex ][ wcslen( pwszIfName ) + 2 ]
            );
    }


    //
    // Now invoke the original routemon routine with what looks
    // like an appriate command line
    //

    switch ( ioOP )
    {
        case IPX_OPERATION_ADD :
        
            dwErr = CreateTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex
                        );
            break;

        
        case IPX_OPERATION_DELETE :
        
            dwErr = DeleteTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SET :
        
            dwErr = SetTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex 
                        );

            break;


        case IPX_OPERATION_SHOW :
        
            dwErr = ShowTfFlt( 
                        dwArgCount - dwCurrentIndex, 
                        ppwcArguments + dwCurrentIndex,
                        FALSE
                        );

            break;

    }
  } while (FALSE);

    if ( bFreeNewArg )
    {
        FreeArgTable( dwOldArgCount, ppwcArguments );
    }

    return dwErr;
}

//
// Handle interface operations
//

DWORD
HandleIpxAddInterface(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description :

    This routine munges the command line and invokes the appropriate
    routemon routine to handl