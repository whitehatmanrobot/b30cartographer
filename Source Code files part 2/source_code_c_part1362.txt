R)) && 
        IsBadWritePtr((void*) pError, sizeof(HH_LAST_ERROR)) &&
        pError->cbStruct >= sizeof(HH_LAST_ERROR))
    {
        return E_FAIL;
    }

    // Get the last error.
    g_LastError.Get(&pError->hr) ;

    // We got the error, now get the string to go with it.
    GetStringFromHr(pError->hr, &pError->description) ;

    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetStringFromHr
//
HRESULT 
GetStringFromHr(HRESULT hr, BSTR* pDescription)
{
    // Get the stringid for this error code.
    HRESULT hrReturn = E_FAIL ;
    *pDescription = NULL ;
    if (FAILED(hr))
    {
        // Currently we don't have any strings to return.
        int stringid = ErrorStringId(hr) ;
        if (stringid)
        {
            // Get the string from the resource table.
            PCSTR pstr = GetStringResource(stringid) ;
            if (pstr[0] != '\0')
            {
                // Convert to wide.
                CWStr wstrError(pstr) ;

                // Make it into a BSTR.
                *pDescription = ::SysAllocString(wstrError) ;

                hrReturn = S_OK ;
            }
        }
        else
        {
            *pDescription = NULL ;
            hrReturn = S_FALSE ;
        }
    }

    // Only return a description if the call failed. 
    return hrReturn;
}

///////////////////////////////////////////////////////////
//
// ErrorStringId - returns the resource id for a HRESULT.
//
int 
ErrorStringId(HRESULT hr)
{
    int iReturn ;
    switch(hr)
    {
        case HH_E_NOCONTEXTIDS:
            iReturn = IDS_HH_E_NOCONTEXTIDS;
            break ;
        case HH_E_FILENOTFOUND:
            iReturn = IDS_HH_E_FILENOTFOUND;
            break ;
        case HH_E_INVALIDHELPFILE:
            iReturn = IDS_HH_E_INVALIDHELPFILE;
            break ;
        case HH_E_CONTEXTIDDOESNTEXIT:
            iReturn = IDS_HH_E_CONTEXTIDDOESNTEXIT;
            break ;
        default:
            iReturn = 0;
            break ;
    };

    return iReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\localobj.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.
//
// this file is used by automation servers to delcare things that their objects
// need other parts of the server to see.

#ifndef _LOCALOBJECTS_H_
#define _LOCALOBJECTS_H_

//=--------------------------------------------------------------------------=
// these constants are used in conjunction with the g_ObjectInfo table that
// each inproc server defines.  they are used to identify a given  object
// within the server.
//
// **** ADD ALL NEW OBJECTS TO THIS LIST ****

#define OBJECT_TYPE_CTLHHCTRL			  0
#define OBJECT_TYPE_PPGHHCTRLGENERAL	  1

#endif // _LOCALOBJECTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\localsrv.h ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// global routines that are specific to the inproc server itself, such as
// registration, object creation, object specification, etc...

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _LOCALSRV_H_
#define _LOCALSRV_H_

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN		 0
#define OI_AUTOMATION	 1
#define OI_CONTROL		 2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS		 0xffff

#define OBJECTISCREATABLE(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid != NULL)
#define ISEMPTYOBJECT(index)	  (g_ObjectInfo[index].usType == OI_BOGUS)

// these are the macros you should use to fill in the table.  Note that the name
// must be exactly the same as that used in the global structure you created
// for this object.
//
#define UNKNOWNOBJECT(name)    { OI_UNKNOWN,	  (void *)&(name##Object) }
#define AUTOMATIONOBJECT(name) { OI_AUTOMATION,   (void *)&(name##Object) }
#define CONTROLOBJECT(name)    { OI_CONTROL,	  (void *)&(name##Control) }
#define PROPERTYPAGE(name)	   { OI_PROPERTYPAGE, (void *)&(name##Page) }
#define EMPTYOBJECT 		   { OI_BOGUS, NULL }

#endif // _LOCALSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\lockout.h ===
///////////////////////////////////////////////////////////
//
//
// lockout.h    - Header file for CLockOut
//
//
/*
	Before creating any dialog box. Create and instance of this class.

	This class will disable all toplevel windows which are in the same process.
	This prevents the user from distroying the window while a dialog box is up.
*/


#ifndef __LOCKOUT_H__
#define __LOCKOUT_H__

///////////////////////////////////////////////////////////
//
// constants
//
const int c_MaxWindows = 256 ;

///////////////////////////////////////////////////////////
//
//
class CLockOut
{
public:
    // Construction
    CLockOut() ;
    virtual ~CLockOut() ;

    // Main function.
    void LockOut(HWND hwndOwner) ;

    // Enable the windows.
    void Unlock() ;

//--- Callbacks
private:
    // Member callback
    BOOL EnumWindowProc(HWND hwnd) ;

    // Static callback
    static BOOL CALLBACK s_EnumWindowProc(HWND hwnd, LPARAM lparam) ;

//--- Member Variables.
private:
    // Array which holds the disabled top level windows.
    HWND m_HwndDisabled[c_MaxWindows] ; //TODO: This array needs to grow.

    // Status flag
    bool m_bLocked ;

    //--- Variables used in the EnumWindows Proc.
    // Number of windows disabled.
    int m_CountDisabled ;

    // The process id of the dialogs app.
    DWORD m_ProcessId ;
};

#endif // __LOCKOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\lockout.cpp ===
///////////////////////////////////////////////////////////
//
//
// lockout.cpp    - Implementation file for CLockOut
//
//
#include "header.h"

// Our header file
#include "lockout.h"


///////////////////////////////////////////////////////////
//
// Construction
//
CLockOut::CLockOut()
:m_bLocked(false)
{
}

///////////////////////////////////////////////////////////
//
// Destructor
//
CLockOut::~CLockOut()
{
    Unlock() ;
}

///////////////////////////////////////////////////////////
//
// Main function.
//
void 
CLockOut::LockOut(HWND hwndOwner)
{
    if (!m_bLocked)
    {
        // Determine if we are parented by the desktop?

        // Initialize our varaibles.
        m_CountDisabled = 0 ;
        GetWindowThreadProcessId(hwndOwner, &m_ProcessId) ;

        // Enumerate the windows
        BOOL b = EnumWindows(s_EnumWindowProc, reinterpret_cast<LPARAM>(this)) ;

    }
}

///////////////////////////////////////////////////////////
//
// Main function.
//
void 
CLockOut::Unlock()
{

    if (m_bLocked)
    {
        // We only set m_bLocked if m_CountDisabled is incremented.
        ASSERT(m_CountDisabled > 0) ;

        for (int i = 0 ; i < m_CountDisabled ; i++)
        {
            if (::IsValidWindow(m_HwndDisabled[i]))
            {
                EnableWindow(m_HwndDisabled[i], TRUE);
            }
        }

        m_bLocked = false ;
        m_CountDisabled = 0 ;
    }
}

///////////////////////////////////////////////////////////
//
//                  Callbacks
//
///////////////////////////////////////////////////////////
//
// EnumWindowProc
//
BOOL 
CLockOut::EnumWindowProc(HWND hwnd)
{
    ASSERT(IsValidWindow(hwnd)) ;// Window should be guarenting this.

    // Only need to disable if window is enabled.
    if (IsWindowEnabled(hwnd))
    {
        // Make sure window is in the same process.
        DWORD procid = NULL;
        GetWindowThreadProcessId(hwnd, &procid) ;
        if (procid == m_ProcessId)
        {
            //Disable the window.
            ASSERT(m_CountDisabled < c_MaxWindows) ; //TODO Make the array grow
            if (m_CountDisabled >= c_MaxWindows)
            {
                // Don't crash, just quit.
                return FALSE ;
            }

            // Add the window to the array.
            m_HwndDisabled[m_CountDisabled++] = hwnd ;

            // Disable the window
            EnableWindow(hwnd, FALSE) ;

            m_bLocked = TRUE ;
        }
    }

    return TRUE ;
}

///////////////////////////////////////////////////////////
//
// Static callback
//
BOOL CALLBACK 
CLockOut::s_EnumWindowProc(HWND hwnd, LPARAM lparam)
{
    CLockOut* p = reinterpret_cast<CLockOut*>(lparam) ;
    return p->EnumWindowProc(hwnd) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\module.h ===
//////////////////////////////////////////////////////////////////////////
//
//
// module.h - CHtmlHelpModule
//
//
/*
    HTMLHelp specific module class.
    * Implements support for satellite DLL resources.
*/

#ifndef __CHtmlHelpModule__
#define __CHtmlHelpModule__

// Declaration of CLanguage
#include "language.h"

// array of global window type names
#include "gwintype.h"

//////////////////////////////////////////////////////////////////////////
//
// CHtmlHelpModule
//
class CHtmlHelpModule : public CComModule
{
public:
    // Construction
    CHtmlHelpModule()
        : m_bResourcesInitialized(false)
    {
       szCurSS[0] = '\0';
       m_cp = -1;
    }

    // Destructor
    ~CHtmlHelpModule() {}

public:
    //
    // Operations
    //
    // Blocks CComModule's version. This isn't a virtual.
    HINSTANCE GetResourceInstance() { InitResources() ; return CComModule::GetResourceInstance(); }
    UINT GetCodePage() { return ((m_cp == -1)?CP_ACP:m_cp); }
    void SetCodePage(UINT cp) { if ( m_cp == -1 ) m_cp = cp; }

private:
    // Self initialize the resources
    void InitResources() { if (!m_bResourcesInitialized) LoadSatellite(); }

    // Load the satellite dll.
    void LoadSatellite() ;

private:
    //
    // Member Variables
    //

    bool m_bResourcesInitialized;
    UINT m_cp;

public:
    // UI Language information.
    CLanguage m_Language ;

    // Contains an array of global window type names.
    CGlobalWinTypes m_GlobalWinTypes ;

    // Current subset name (?)
    TCHAR szCurSS[51];
} ;
#endif //__CHtmlHelpModule__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\module.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//
// Module.cpp - Implementation of CHtmlHelpModule
//
//

// Get the precompiled header file.
#include "header.h"

// Get out header file.
#include "module.h"

//////////////////////////////////////////////////////////////////////////
//
// CHtmlHelpModule
//
//////////////////////////////////////////////////////////////////////////
//
// Operations
//

//////////////////////////////////////////////////////////////////////////
//
// Load the satellite dll.
//
void 
CHtmlHelpModule::LoadSatellite()
{
    // We do not allow reloading the satellite. Once loaded we are done.
    ASSERT(m_bResourcesInitialized == false) ;

    // CLanguage is in charge of loading the correct satellite.
    HINSTANCE hInst = m_Language.LoadSatellite() ;
    if (hInst)
    {
        m_hInstResource = hInst ; // If its null, we didn't load a satellite. We are using the English resources.
    }

    // We've been initialized.
    m_bResourcesInitialized = true ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)(void) PURE;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum _ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ECompactionLev;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\mshtmhst.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Mon Nov 17 12:03:53 1997
 */
/* Compiler settings for mshtmhst.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mshtmhst_h__
#define __mshtmhst_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDocHostUIHandler_FWD_DEFINED__
#define __IDocHostUIHandler_FWD_DEFINED__
typedef interface IDocHostUIHandler IDocHostUIHandler;
#endif 	/* __IDocHostUIHandler_FWD_DEFINED__ */


#ifndef __ICustomDoc_FWD_DEFINED__
#define __ICustomDoc_FWD_DEFINED__
typedef interface ICustomDoc ICustomDoc;
#endif 	/* __ICustomDoc_FWD_DEFINED__ */


#ifndef __IDocHostShowUI_FWD_DEFINED__
#define __IDocHostShowUI_FWD_DEFINED__
typedef interface IDocHostShowUI IDocHostShowUI;
#endif 	/* __IDocHostShowUI_FWD_DEFINED__ */


#ifndef __ICSSFilterSite_FWD_DEFINED__
#define __ICSSFilterSite_FWD_DEFINED__
typedef interface ICSSFilterSite ICSSFilterSite;
#endif 	/* __ICSSFilterSite_FWD_DEFINED__ */


#ifndef __ICSSFilter_FWD_DEFINED__
#define __ICSSFilter_FWD_DEFINED__
typedef interface ICSSFilter ICSSFilter;
#endif 	/* __ICSSFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "docobj.h"
#include "mshtml.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_mshtmhst_0000
 * at Mon Nov 17 12:03:53 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// mshtmhst.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// MSTHML Advanced Host Interfaces.

#ifndef MSHTMHST_H
#define MSHTMHST_H
#define CONTEXT_MENU_DEFAULT        0
#define CONTEXT_MENU_IMAGE          1
#define CONTEXT_MENU_CONTROL        2
#define CONTEXT_MENU_TABLE          3
// in browse mode
#define CONTEXT_MENU_TEXTSELECT     4
#define CONTEXT_MENU_ANCHOR         5
#define CONTEXT_MENU_UNKNOWN        6
#define MENUEXT_SHOWDIALOG           0x1
#define DOCHOSTUIFLAG_BROWSER       DOCHOSTUIFLAG_DISABLE_HELP_MENU | DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE 
EXTERN_C const GUID CGID_MSHTML;
#define CMDSETID_Forms3 CGID_MSHTML
#define SZ_HTML_CLIENTSITE_OBJECTPARAM L"{d4db6850-5385-11d0-89e9-00a0c90a90ac}"
typedef HRESULT STDAPICALLTYPE SHOWHTMLDIALOGFN (HWND hwndParent, IMoniker *pmk, VARIANT *pvarArgIn, TCHAR* pchOptions, VARIANT *pvArgOut);
typedef
enum tagDOCHOSTUIDBLCLK
    {	DOCHOSTUIDBLCLK_DEFAULT	= 0,
	DOCHOSTUIDBLCLK_SHOWPROPERTIES	= 1,
	DOCHOSTUIDBLCLK_SHOWCODE	= 2
    }	DOCHOSTUIDBLCLK;

typedef 
enum tagDOCHOSTUIFLAG
    {	DOCHOSTUIFLAG_DIALOG	= 1,
	DOCHOSTUIFLAG_DISABLE_HELP_MENU	= 2,
	DOCHOSTUIFLAG_NO3DBORDER	= 4,
	DOCHOSTUIFLAG_SCROLL_NO	= 8,
	DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE	= 16,
	DOCHOSTUIFLAG_OPENNEWWIN	= 32,
	DOCHOSTUIFLAG_DISABLE_OFFSCREEN	= 64,
	DOCHOSTUIFLAG_FLAT_SCROLLBAR	= 128,
	DOCHOSTUIFLAG_DIV_BLOCKDEFAULT	= 256,
	DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY	= 512,
	DOCHOSTUIFLAG_DISABLE_COOKIE	= 1024
    }	DOCHOSTUIFLAG;



extern RPC_IF_HANDLE __MIDL_itf_mshtmhst_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mshtmhst_0000_v0_0_s_ifspec;

#ifndef __IDocHostUIHandler_INTERFACE_DEFINED__
#define __IDocHostUIHandler_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDocHostUIHandler
 * at Mon Nov 17 12:03:53 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local][unique][uuid][object] */ 


typedef struct  _DOCHOSTUIINFO
    {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwDoubleClick;
    }	DOCHOSTUIINFO;


EXTERN_C const IID IID_IDocHostUIHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("bd3f23c0-d43e-11cf-893b-00aa00bdce1a")
    IDocHostUIHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            /* [in] */ DWORD dwID,
            /* [in] */ POINT __RPC_FAR *ppt,
            /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
            /* [in] */ IDispatch __RPC_FAR *pdispReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostInfo( 
            /* [out][in] */ DOCHOSTUIINFO __RPC_FAR *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowUI( 
            /* [in] */ DWORD dwID,
            /* [in] */ IOleInPlaceActiveObject __RPC_FAR *pActiveObject,
            /* [in] */ IOleCommandTarget __RPC_FAR *pCommandTarget,
            /* [in] */ IOleInPlaceFrame __RPC_FAR *pFrame,
            /* [in] */ IOleInPlaceUIWindow __RPC_FAR *pDoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HideUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateUI( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate( 
            /* [in] */ BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate( 
            /* [in] */ BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResizeBorder( 
            /* [in] */ LPCRECT prcBorder,
            /* [in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
            /* [in] */ BOOL fRameWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ LPMSG lpMsg,
            /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath( 
            /* [out] */ LPOLESTR __RPC_FAR *pchKey,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterDataObject( 
            /* [in] */ IDataObject __RPC_FAR *pDO,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDocHostUIHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDocHostUIHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDocHostUIHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowContextMenu )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [in] */ POINT __RPC_FAR *ppt,
            /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
            /* [in] */ IDispatch __RPC_FAR *pdispReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHostInfo )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [out][in] */ DOCHOSTUIINFO __RPC_FAR *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowUI )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ DWORD dwID,
            /* [in] */ IOleInPlaceActiveObject __RPC_FAR *pActiveObject,
            /* [in] */ IOleCommandTarget __RPC_FAR *pCommandTarget,
            /* [in] */ IOleInPlaceFrame __RPC_FAR *pFrame,
            /* [in] */ IOleInPlaceUIWindow __RPC_FAR *pDoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HideUI )( 
            IDocHostUIHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateUI )( 
            IDocHostUIHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableModeless )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDocWindowActivate )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnFrameWindowActivate )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResizeBorder )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ LPCRECT prcBorder,
            /* [in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
            /* [in] */ BOOL fRameWindow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateAccelerator )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ LPMSG lpMsg,
            /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOptionKeyPath )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [out] */ LPOLESTR __RPC_FAR *pchKey,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDropTarget )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExternal )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TranslateUrl )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ DWORD dwTranslate,
            /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterDataObject )( 
            IDocHostUIHandler __RPC_FAR * This,
            /* [in] */ IDataObject __RPC_FAR *pDO,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet);
        
        END_INTERFACE
    } IDocHostUIHandlerVtbl;

    interface IDocHostUIHandler
    {
        CONST_VTBL struct IDocHostUIHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocHostUIHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocHostUIHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDocHostUIHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDocHostUIHandler_ShowContextMenu(This,dwID,ppt,pcmdtReserved,pdispReserved)	\
    (This)->lpVtbl -> ShowContextMenu(This,dwID,ppt,pcmdtReserved,pdispReserved)

#define IDocHostUIHandler_GetHostInfo(This,pInfo)	\
    (This)->lpVtbl -> GetHostInfo(This,pInfo)

#define IDocHostUIHandler_ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc)	\
    (This)->lpVtbl -> ShowUI(This,dwID,pActiveObject,pCommandTarget,pFrame,pDoc)

#define IDocHostUIHandler_HideUI(This)	\
    (This)->lpVtbl -> HideUI(This)

#define IDocHostUIHandler_UpdateUI(This)	\
    (This)->lpVtbl -> UpdateUI(This)

#define IDocHostUIHandler_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#define IDocHostUIHandler_OnDocWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnDocWindowActivate(This,fActivate)

#define IDocHostUIHandler_OnFrameWindowActivate(This,fActivate)	\
    (This)->lpVtbl -> OnFrameWindowActivate(This,fActivate)

#define IDocHostUIHandler_ResizeBorder(This,prcBorder,pUIWindow,fRameWindow)	\
    (This)->lpVtbl -> ResizeBorder(This,prcBorder,pUIWindow,fRameWindow)

#define IDocHostUIHandler_TranslateAccelerator(This,lpMsg,pguidCmdGroup,nCmdID)	\
    (This)->lpVtbl -> TranslateAccelerator(This,lpMsg,pguidCmdGroup,nCmdID)

#define IDocHostUIHandler_GetOptionKeyPath(This,pchKey,dw)	\
    (This)->lpVtbl -> GetOptionKeyPath(This,pchKey,dw)

#define IDocHostUIHandler_GetDropTarget(This,pDropTarget,ppDropTarget)	\
    (This)->lpVtbl -> GetDropTarget(This,pDropTarget,ppDropTarget)

#define IDocHostUIHandler_GetExternal(This,ppDispatch)	\
    (This)->lpVtbl -> GetExternal(This,ppDispatch)

#define IDocHostUIHandler_TranslateUrl(This,dwTranslate,pchURLIn,ppchURLOut)	\
    (This)->lpVtbl -> TranslateUrl(This,dwTranslate,pchURLIn,ppchURLOut)

#define IDocHostUIHandler_FilterDataObject(This,pDO,ppDORet)	\
    (This)->lpVtbl -> FilterDataObject(This,pDO,ppDORet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDocHostUIHandler_ShowContextMenu_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [in] */ POINT __RPC_FAR *ppt,
    /* [in] */ IUnknown __RPC_FAR *pcmdtReserved,
    /* [in] */ IDispatch __RPC_FAR *pdispReserved);


void __RPC_STUB IDocHostUIHandler_ShowContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_GetHostInfo_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [out][in] */ DOCHOSTUIINFO __RPC_FAR *pInfo);


void __RPC_STUB IDocHostUIHandler_GetHostInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_ShowUI_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ DWORD dwID,
    /* [in] */ IOleInPlaceActiveObject __RPC_FAR *pActiveObject,
    /* [in] */ IOleCommandTarget __RPC_FAR *pCommandTarget,
    /* [in] */ IOleInPlaceFrame __RPC_FAR *pFrame,
    /* [in] */ IOleInPlaceUIWindow __RPC_FAR *pDoc);


void __RPC_STUB IDocHostUIHandler_ShowUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_HideUI_Proxy( 
    IDocHostUIHandler __RPC_FAR * This);


void __RPC_STUB IDocHostUIHandler_HideUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_UpdateUI_Proxy( 
    IDocHostUIHandler __RPC_FAR * This);


void __RPC_STUB IDocHostUIHandler_UpdateUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_EnableModeless_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IDocHostUIHandler_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_OnDocWindowActivate_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ BOOL fActivate);


void __RPC_STUB IDocHostUIHandler_OnDocWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_OnFrameWindowActivate_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ BOOL fActivate);


void __RPC_STUB IDocHostUIHandler_OnFrameWindowActivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_ResizeBorder_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ LPCRECT prcBorder,
    /* [in] */ IOleInPlaceUIWindow __RPC_FAR *pUIWindow,
    /* [in] */ BOOL fRameWindow);


void __RPC_STUB IDocHostUIHandler_ResizeBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_TranslateAccelerator_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ LPMSG lpMsg,
    /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
    /* [in] */ DWORD nCmdID);


void __RPC_STUB IDocHostUIHandler_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_GetOptionKeyPath_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [out] */ LPOLESTR __RPC_FAR *pchKey,
    /* [in] */ DWORD dw);


void __RPC_STUB IDocHostUIHandler_GetOptionKeyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_GetDropTarget_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
    /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget);


void __RPC_STUB IDocHostUIHandler_GetDropTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_GetExternal_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IDocHostUIHandler_GetExternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_TranslateUrl_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ DWORD dwTranslate,
    /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut);


void __RPC_STUB IDocHostUIHandler_TranslateUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostUIHandler_FilterDataObject_Proxy( 
    IDocHostUIHandler __RPC_FAR * This,
    /* [in] */ IDataObject __RPC_FAR *pDO,
    /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet);


void __RPC_STUB IDocHostUIHandler_FilterDataObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDocHostUIHandler_INTERFACE_DEFINED__ */


#ifndef __ICustomDoc_INTERFACE_DEFINED__
#define __ICustomDoc_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICustomDoc
 * at Mon Nov 17 12:03:53 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local][unique][uuid][object] */ 



EXTERN_C const IID IID_ICustomDoc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3050f3f0-98b5-11cf-bb82-00aa00bdce0b")
    ICustomDoc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUIHandler( 
            /* [in] */ IDocHostUIHandler __RPC_FAR *pUIHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICustomDocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICustomDoc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICustomDoc __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICustomDoc __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUIHandler )( 
            ICustomDoc __RPC_FAR * This,
            /* [in] */ IDocHostUIHandler __RPC_FAR *pUIHandler);
        
        END_INTERFACE
    } ICustomDocVtbl;

    interface ICustomDoc
    {
        CONST_VTBL struct ICustomDocVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICustomDoc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICustomDoc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICustomDoc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICustomDoc_SetUIHandler(This,pUIHandler)	\
    (This)->lpVtbl -> SetUIHandler(This,pUIHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICustomDoc_SetUIHandler_Proxy( 
    ICustomDoc __RPC_FAR * This,
    /* [in] */ IDocHostUIHandler __RPC_FAR *pUIHandler);


void __RPC_STUB ICustomDoc_SetUIHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICustomDoc_INTERFACE_DEFINED__ */


#ifndef __IDocHostShowUI_INTERFACE_DEFINED__
#define __IDocHostShowUI_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDocHostShowUI
 * at Mon Nov 17 12:03:53 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local][unique][uuid][object] */ 



EXTERN_C const IID IID_IDocHostShowUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("c4d244b0-d43e-11cf-893b-00aa00bdce1a")
    IDocHostShowUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ShowMessage( 
            /* [in] */ HWND hwnd,
            /* [in] */ LPOLESTR lpstrText,
            /* [in] */ LPOLESTR lpstrCaption,
            /* [in] */ DWORD dwType,
            /* [in] */ LPOLESTR lpstrHelpFile,
            /* [in] */ DWORD dwHelpContext,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowHelp( 
            /* [in] */ HWND hwnd,
            /* [in] */ LPOLESTR pszHelpFile,
            /* [in] */ UINT uCommand,
            /* [in] */ DWORD dwData,
            /* [in] */ POINT ptMouse,
            /* [out] */ IDispatch __RPC_FAR *pDispatchObjectHit) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDocHostShowUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDocHostShowUI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDocHostShowUI __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDocHostShowUI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowMessage )( 
            IDocHostShowUI __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ LPOLESTR lpstrText,
            /* [in] */ LPOLESTR lpstrCaption,
            /* [in] */ DWORD dwType,
            /* [in] */ LPOLESTR lpstrHelpFile,
            /* [in] */ DWORD dwHelpContext,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowHelp )( 
            IDocHostShowUI __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ LPOLESTR pszHelpFile,
            /* [in] */ UINT uCommand,
            /* [in] */ DWORD dwData,
            /* [in] */ POINT ptMouse,
            /* [out] */ IDispatch __RPC_FAR *pDispatchObjectHit);
        
        END_INTERFACE
    } IDocHostShowUIVtbl;

    interface IDocHostShowUI
    {
        CONST_VTBL struct IDocHostShowUIVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDocHostShowUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDocHostShowUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDocHostShowUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDocHostShowUI_ShowMessage(This,hwnd,lpstrText,lpstrCaption,dwType,lpstrHelpFile,dwHelpContext,plResult)	\
    (This)->lpVtbl -> ShowMessage(This,hwnd,lpstrText,lpstrCaption,dwType,lpstrHelpFile,dwHelpContext,plResult)

#define IDocHostShowUI_ShowHelp(This,hwnd,pszHelpFile,uCommand,dwData,ptMouse,pDispatchObjectHit)	\
    (This)->lpVtbl -> ShowHelp(This,hwnd,pszHelpFile,uCommand,dwData,ptMouse,pDispatchObjectHit)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDocHostShowUI_ShowMessage_Proxy( 
    IDocHostShowUI __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ LPOLESTR lpstrText,
    /* [in] */ LPOLESTR lpstrCaption,
    /* [in] */ DWORD dwType,
    /* [in] */ LPOLESTR lpstrHelpFile,
    /* [in] */ DWORD dwHelpContext,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IDocHostShowUI_ShowMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDocHostShowUI_ShowHelp_Proxy( 
    IDocHostShowUI __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ LPOLESTR pszHelpFile,
    /* [in] */ UINT uCommand,
    /* [in] */ DWORD dwData,
    /* [in] */ POINT ptMouse,
    /* [out] */ IDispatch __RPC_FAR *pDispatchObjectHit);


void __RPC_STUB IDocHostShowUI_ShowHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDocHostShowUI_INTERFACE_DEFINED__ */


#ifndef __ICSSFilterSite_INTERFACE_DEFINED__
#define __ICSSFilterSite_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICSSFilterSite
 * at Mon Nov 17 12:03:53 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ICSSFilterSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3050f3ed-98b5-11cf-bb82-00aa00bdce0b")
    ICSSFilterSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetElement( 
            /* [out][retval] */ IHTMLElement __RPC_FAR *__RPC_FAR *ppElem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireOnFilterChangeEvent( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICSSFilterSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICSSFilterSite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICSSFilterSite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICSSFilterSite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetElement )( 
            ICSSFilterSite __RPC_FAR * This,
            /* [out][retval] */ IHTMLElement __RPC_FAR *__RPC_FAR *ppElem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FireOnFilterChangeEvent )( 
            ICSSFilterSite __RPC_FAR * This);
        
        END_INTERFACE
    } ICSSFilterSiteVtbl;

    interface ICSSFilterSite
    {
        CONST_VTBL struct ICSSFilterSiteVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICSSFilterSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICSSFilterSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICSSFilterSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICSSFilterSite_GetElement(This,ppElem)	\
    (This)->lpVtbl -> GetElement(This,ppElem)

#define ICSSFilterSite_FireOnFilterChangeEvent(This)	\
    (This)->lpVtbl -> FireOnFilterChangeEvent(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICSSFilterSite_GetElement_Proxy( 
    ICSSFilterSite __RPC_FAR * This,
    /* [out][retval] */ IHTMLElement __RPC_FAR *__RPC_FAR *ppElem);


void __RPC_STUB ICSSFilterSite_GetElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICSSFilterSite_FireOnFilterChangeEvent_Proxy( 
    ICSSFilterSite __RPC_FAR * This);


void __RPC_STUB ICSSFilterSite_FireOnFilterChangeEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICSSFilterSite_INTERFACE_DEFINED__ */


#ifndef __ICSSFilter_INTERFACE_DEFINED__
#define __ICSSFilter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICSSFilter
 * at Mon Nov 17 12:03:53 1997
 * using MIDL 3.02.88
 ****************************************/
/* [object][uuid][dual][oleautomation] */ 



EXTERN_C const IID IID_ICSSFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("3050f3ec-98b5-11cf-bb82-00aa00bdce0b")
    ICSSFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSite( 
            /* [in] */ ICSSFilterSite __RPC_FAR *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnAmbientPropertyChange( 
            /* [in] */ LONG dispid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICSSFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICSSFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICSSFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICSSFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSite )( 
            ICSSFilter __RPC_FAR * This,
            /* [in] */ ICSSFilterSite __RPC_FAR *pSink);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnAmbientPropertyChange )( 
            ICSSFilter __RPC_FAR * This,
            /* [in] */ LONG dispid);
        
        END_INTERFACE
    } ICSSFilterVtbl;

    interface ICSSFilter
    {
        CONST_VTBL struct ICSSFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICSSFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICSSFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICSSFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICSSFilter_SetSite(This,pSink)	\
    (This)->lpVtbl -> SetSite(This,pSink)

#define ICSSFilter_OnAmbientPropertyChange(This,dispid)	\
    (This)->lpVtbl -> OnAmbientPropertyChange(This,dispid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICSSFilter_SetSite_Proxy( 
    ICSSFilter __RPC_FAR * This,
    /* [in] */ ICSSFilterSite __RPC_FAR *pSink);


void __RPC_STUB ICSSFilter_SetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICSSFilter_OnAmbientPropertyChange_Proxy( 
    ICSSFilter __RPC_FAR * This,
    /* [in] */ LONG dispid);


void __RPC_STUB ICSSFilter_OnAmbientPropertyChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICSSFilter_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_mshtmhst_0350
 * at Mon Nov 17 12:03:53 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_mshtmhst_0350_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mshtmhst_0350_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\multimon.h ===
#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)

//=============================================================================
//
// MULTIMON
// stub module that fakes multiple monitor apis on pre Memphis Win32 OSes
//
// By using this header your code will work unchanged on Win95,
// you will get back default values from GetSystemMetrics() for new metrics
// and the new APIs will act like only one display is present.
//
// exactly one source must include this with COMPILE_MULTIMON_STUBS defined
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// if we are building on Win95/NT4 headers we need to declare this stuff ourselves
//
#ifndef SM_CMONITORS

#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81

DECLARE_HANDLE(HMONITOR);

#define MONITOR_DEFAULTTONULL       0x00000000
#define MONITOR_DEFAULTTOPRIMARY    0x00000001
#define MONITOR_DEFAULTTONEAREST    0x00000002

#define MONITORINFOF_PRIMARY        0x00000001

typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;

#define CCHDEVICENAME 32

#ifdef __cplusplus
typedef struct tagMONITORINFOEX : public tagMONITORINFO
{
    TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#else
typedef struct
{
    MONITORINFO;
    TCHAR       szDevice[CCHDEVICENAME];
} MONITORINFOEX, *LPMONITORINFOEX;
#endif

typedef BOOL (CALLBACK* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

#endif  // SM_CMONITORS

#undef GetMonitorInfo
#undef GetSystemMetrics
#undef MonitorFromWindow
#undef MonitorFromRect
#undef MonitorFromPoint
#undef EnumDisplayMonitors

//
// define this to compile the stubs
// otherwise you get the declarations
//
#ifdef COMPILE_MULTIMON_STUBS

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

int      (WINAPI* g_pfnGetSystemMetrics)(int);
HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, BOOL);
HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, BOOL);
HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, BOOL);
BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO);
BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM);

BOOL InitMultipleMonitorStubs(void)
{
    HMODULE hUser32;
    static BOOL fInitDone;

    if (fInitDone)
    {
        return g_pfnGetMonitorInfo != NULL;
    }

    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &&
        (*(FARPROC*)&g_pfnGetSystemMetrics    = GetProcAddress(hUser32,"GetSystemMetrics")) &&
        (*(FARPROC*)&g_pfnMonitorFromWindow   = GetProcAddress(hUser32,"MonitorFromWindow")) &&
        (*(FARPROC*)&g_pfnMonitorFromRect     = GetProcAddress(hUser32,"MonitorFromRect")) &&
        (*(FARPROC*)&g_pfnMonitorFromPoint    = GetProcAddress(hUser32,"MonitorFromPoint")) &&
        (*(FARPROC*)&g_pfnEnumDisplayMonitors = GetProcAddress(hUser32,"EnumDisplayMonitors")) &&
#ifdef UNICODE
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoW")) &&
#else
        (*(FARPROC*)&g_pfnGetMonitorInfo      = GetProcAddress(hUser32,"GetMonitorInfoA")) )
#endif
    {
        fInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnGetSystemMetrics    = NULL;
        g_pfnMonitorFromWindow   = NULL;
        g_pfnMonitorFromRect     = NULL;
        g_pfnMonitorFromPoint    = NULL;
        g_pfnGetMonitorInfo      = NULL;
        g_pfnEnumDisplayMonitors = NULL;

        fInitDone = TRUE;
        return FALSE;
    }
}

//-----------------------------------------------------------------------------
//
// fake implementations of Monitor APIs that work with the primary display
// no special parameter validation is made since these run in client code
//
//-----------------------------------------------------------------------------

int WINAPI
xGetSystemMetrics(int nIndex)
{
    if (InitMultipleMonitorStubs())
        return g_pfnGetSystemMetrics(nIndex);

    switch (nIndex)
    {
    case SM_CMONITORS:
    case SM_SAMEDISPLAYFORMAT:
        return 1;

    case SM_XVIRTUALSCREEN:
    case SM_YVIRTUALSCREEN:
        return 0;

    case SM_CXVIRTUALSCREEN:
        nIndex = SM_CXSCREEN;
        break;

    case SM_CYVIRTUALSCREEN:
        nIndex = SM_CYSCREEN;
        break;
    }

    return GetSystemMetrics(nIndex);
}

#define xPRIMARY_MONITOR ((HMONITOR)0x42)

HMONITOR WINAPI
xMonitorFromRect(LPCRECT lprcScreenCoords, UINT uFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromRect(lprcScreenCoords, uFlags);

    if ((uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((lprcScreenCoords->right > 0) &&
        (lprcScreenCoords->bottom > 0) &&
        (lprcScreenCoords->left < GetSystemMetrics(SM_CXSCREEN)) &&
        (lprcScreenCoords->top < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

HMONITOR WINAPI
xMonitorFromWindow(HWND hWnd, UINT uFlags)
{
    RECT rc;

    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromWindow(hWnd, uFlags);

    if (uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST))
        return xPRIMARY_MONITOR;

    if (GetWindowRect(hWnd, &rc))
        return xMonitorFromRect(&rc, uFlags);

    return NULL;
}



HMONITOR WINAPI
xMonitorFromPoint(POINT ptScreenCoords, UINT uFlags)
{
    if (InitMultipleMonitorStubs())
        return g_pfnMonitorFromPoint(ptScreenCoords, uFlags);

    if ((uFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) ||
        ((ptScreenCoords.x >= 0) &&
        (ptScreenCoords.x < GetSystemMetrics(SM_CXSCREEN)) &&
        (ptScreenCoords.y >= 0) &&
        (ptScreenCoords.y < GetSystemMetrics(SM_CYSCREEN))))
    {
        return xPRIMARY_MONITOR;
    }

    return NULL;
}

BOOL WINAPI
xGetMonitorInfo(HMONITOR hMonitor, LPMONITORINFO lpMonitorInfo)
{
    RECT rcWork;

    if (InitMultipleMonitorStubs())
        return g_pfnGetMonitorInfo(hMonitor, lpMonitorInfo);

    if ((hMonitor == xPRIMARY_MONITOR) && lpMonitorInfo &&
        (lpMonitorInfo->cbSize >= sizeof(MONITORINFO)) &&
        SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0))
    {
        lpMonitorInfo->rcMonitor.left = 0;
        lpMonitorInfo->rcMonitor.top  = 0;
        lpMonitorInfo->rcMonitor.right  = GetSystemMetrics(SM_CXSCREEN);
        lpMonitorInfo->rcMonitor.bottom = GetSystemMetrics(SM_CYSCREEN);
        lpMonitorInfo->rcWork = rcWork;
        lpMonitorInfo->dwFlags = MONITORINFOF_PRIMARY;

        if (lpMonitorInfo->cbSize >= sizeof(MONITORINFOEX))
            lstrcpy(((MONITORINFOEX*)lpMonitorInfo)->szDevice, TEXT("DISPLAY"));

        return TRUE;
    }

    return FALSE;
}

BOOL WINAPI
xEnumDisplayMonitors(
    HDC     hdc,
    LPCRECT lprcIntersect,
    MONITORENUMPROC lpfnEnumProc,
    LPARAM  lData)
{
    RECT rcCallback, rcLimit;

    if (InitMultipleMonitorStubs())
        return g_pfnEnumDisplayMonitors(hdc,
            lprcIntersect, lpfnEnumProc, lData);
    
    if (!lpfnEnumProc)
        return FALSE;

    rcLimit.left   = 0;
    rcLimit.top    = 0;
    rcLimit.right  = GetSystemMetrics(SM_CXSCREEN);
    rcLimit.bottom = GetSystemMetrics(SM_CYSCREEN);

    if (hdc)
    {
        RECT rcClip;
        HWND hWnd;

        if ((hWnd = WindowFromDC(hdc)) == NULL)
            return FALSE;

        switch (GetClipBox(hdc, &rcClip))
        {
        default:
            MapWindowPoints(NULL, hWnd, (LPPOINT)&rcLimit, 2);
            if (IntersectRect(&rcCallback, &rcClip, &rcLimit))
                break;
            //fall thru
        case NULLREGION:
             return TRUE;
        case ERROR:
             return FALSE;
        }

        rcLimit = rcCallback;
    }

    if (!lprcIntersect ||
        IntersectRect(&rcCallback, lprcIntersect, &rcLimit))
    {
        lpfnEnumProc(xPRIMARY_MONITOR, hdc, &rcCallback,lData);
    }

    return TRUE;
}

#undef xPRIMARY_MONITOR
#undef COMPILE_MULTIMON_STUBS

#else	// COMPILE_MULTIMON_STUBS

extern int	WINAPI xGetSystemMetrics(int);
extern HMONITOR WINAPI xMonitorFromWindow(HWND, UINT);
extern HMONITOR WINAPI xMonitorFromRect(LPCRECT, UINT);
extern HMONITOR WINAPI xMonitorFromPoint(POINT, UINT);
extern BOOL	WINAPI xGetMonitorInfo(HMONITOR, LPMONITORINFO);
extern BOOL	WINAPI xEnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM);

#endif	// COMPILE_MULTIMON_STUBS

//
// build defines that replace the regular APIs with our versions
//
#define GetSystemMetrics    xGetSystemMetrics
#define MonitorFromWindow   xMonitorFromWindow
#define MonitorFromRect     xMonitorFromRect
#define MonitorFromPoint    xMonitorFromPoint
#define GetMonitorInfo      xGetMonitorInfo
#define EnumDisplayMonitors xEnumDisplayMonitors

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif  /* !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\navpane.h ===
#ifndef __NAVPANE_H__
#define __NAVPANE_H__
///////////////////////////////////////////////////////////
//
//
// navpane.h --- Structures used by the nav panes.
//
//
//
/*
    Currently the structures in this file are used by AdvFTS
    and the bookmarks tab for resizing the window.

*/

///////////////////////////////////////////////////////////
//
// Forwards
//
interface INavUI ;

///////////////////////////////////////////////////////////
//
// CDlgItemInfo - Contains information about each control
// in the pane. Used for enabling/disabling controls and
// for sizing.
//

namespace Justify
{
    typedef enum Vertical
    {
        Bottom,
        Top
    };
    typedef enum Horizontal
    {
        Left,
        Right
    };
};

namespace ItemInfo
{
    typedef enum Type
    {
        Generic,
        Button,
        CheckBox
    };
};

struct CDlgItemInfo
{
    // Window Info
    HWND m_hWnd ;               // hWnd Cache.
    int m_id ;                  // ctrl id.
    CHAR m_accelkey ;            // accelerator key.

    // Control Type Information
    ItemInfo::Type  m_Type;     //Used when processing menu keys.

    // Status bits
    bool m_bIgnoreEnabled:1 ;   // Ignore the following.
    bool m_bEnabled:1 ;         // Is the control enabled?
    bool m_bIgnoreMax:1 ;       // Ignore the Max parameter.
    bool m_bGrowH:1 ;           // Grow Horizontally.
    bool m_bGrowV:1 ;           // Grow Vertically.

    Justify::Vertical m_JustifyV ;        // Do we stick to the top or the bottom.
    int m_iOffsetV ;            // Distance from our justification point.
    Justify::Horizontal m_JustifyH ;        // Do we stick to the right or the left
    int m_iOffsetH ;
    int m_iPadH ;               // Right Horizontal Padding.
    int m_iPadV ;               // Bottom Vertical Padding.

    RECT m_rectMin ;        // Defined in the RC file.
    RECT m_rectCur ;
    RECT m_rectMax ;        // Max size.
};



///////////////////////////////////////////////////////////
//
// Utility Functions
//

// Convert a rect from screen to client.
void ScreenRectToClientRect(HWND hWnd, RECT* prect) ;

// Get an accelerator key for the appropriate control.
int     GetAcceleratorKey(HWND hwndctrl) ;
inline int     GetAcceleratorKey(HWND hWndDlg, int ctrlid) {return GetAcceleratorKey(::GetDlgItem(hWndDlg, ctrlid)) ; }

//TODO: Put this into a base class
// Process the menu character.
bool ProcessMenuChar(   INavUI* pNavUI,
                        HWND hwndParent,                 
                        CDlgItemInfo* DlgItems, // Array of dialog items
                        int NumDlgItems,        // Number of items in the array
                        int ch                  // accelerator to act on.
                        ) ;

#endif //__NAVPANE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\navui.h ===
#ifndef __NAVUI_H__
#define __NAVUI_H__

class CTreeNode;

///////////////////////////////////////////////////////////
//
//
// NavUI.h - Defines naviagation UI interface
//
//
/*
This class defines the interface for a navigation pane. All navigation
panes must inherit and implement these functions. An array of nav panes
are stored in CHHWinType. These functions are called virtually.
*/

///////////////////////////////////////////////////////////
//
// INavUI Interface
//
interface INavUI
{
    virtual ~INavUI() {} // Destructor doesn't get called if this is missing?!?!?

    // Interface
      virtual BOOL
    Create(HWND hwndParent) = 0;

   virtual LRESULT
    OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam) = 0; //Search

   virtual void
    ResizeWindow() = 0;

   virtual void
    HideWindow() = 0;

   virtual void
    ShowWindow() = 0;

      virtual void
    SetPadding(int pad) = 0 ;

   virtual void
    SetTabPos(int tabpos) = 0 ;

    //--- New functions

    // Handles activating
    //virtual void
    //Activate() = 0;

    // Set focus to the most expected control, usually edit combo.
    virtual void
    SetDefaultFocus() = 0 ;

    // Process accelerator keys.
    virtual bool
    ProcessMenuChar(HWND hwndParent, int ch) = 0 ;

    // Process WM_NOTIFY messages. Used by embedded Tree and List view controls.
    virtual LRESULT
    OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam) = 0;

    // Process WM_DRAWITEM messages.
    virtual void
    OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) = 0 ;

    // Seed the nav ui with a search term or keyword.
    virtual void
    Seed(LPCSTR pszSeed) = 0 ;

    virtual void OnVKListNotify(NMHDR* pNMHdr) = 0;

    virtual BOOL Synchronize(PSTR pszUrl, CTreeNode* pSyncNode = NULL) {return FALSE;}

    virtual void Refresh(void) { return; }

    /* The following are not called externally.
    virtual void
    SetFont(HFONT hfont) = 0 ;

   virtual HWND
    GetParentSize(RECT* prcParent, HWND hwndParent) = 0; // Move to util.h

   virutal void
    FillListBox(BOOL fReset = FALSE) = 0;
    */

    /* Member funcitons in other UI panes.
    //Index
   void  ChangeOuter(IUnknown* pUnkOuter) { m_pOuter = pUnkOuter; }
   BOOL  ReadIndexFile(PCSTR pszFile);

    // Toc
    void    ChangeOuter(IUnknown* pUnkOuter) { m_pOuter = pUnkOuter; }
    BOOL    CreateContentsWindow(HWND hwndParent);
    BOOL    InitTreeView(void);
    BOOL    ReadFile(PCSTR pszFile);

    void    SetStyles(DWORD exStyles, DWORD dwStyles) { m_exStyles = exStyles; m_dwStyles = dwStyles; }

    BOOL    Synchronize(PCSTR pszName, PSTR pszUrl);
    void    SaveCurUrl(void);

    */

};


#endif //__NAVUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\mvopsys.h ===
/*************************************************************************
*                                                                        *
*  MVOPSYS.H                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Include platform dependent include files                             *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
*************************************************************************/

#ifndef __MVOPSYS_H_
#define __MVOPSYS_H_

/*   There is C and C++ code, use these defines for interfaces between the 2 */
#if defined( __cplusplus ) // {
#define EXTC extern "C"
#define EXTCSTART EXTC {
#define EXTCEND }
#else // } {
#define	EXTC
#define EXTCSTART
#define EXTCEND
#endif // }


#include <windows.h>
#include <windowsx.h>
#include <string.h>

#if defined(_WIN32) && !defined(_32BIT)
#define _32BIT
#endif

#ifdef _32BIT // {
#include <wincon.h>

/*****************************************************
 *            32-BIT SPECIFIC DEFINITIONS
 *
 *   All 32-bit platforms related definitions should be
 *   placed here, eg. _MAC, _NT, etc
 *****************************************************/

/*  Some _32BIT specific bits & pieces */

#define _loadds
#define __loadds
#define far
#define _far
#define huge
#define _huge
#define _export
#define __export
#define EXPORT_API
#define PRIVATE

// These old macros are still used in some places.
#define WRITE OF_WRITE
#define READ OF_READ

// Define PAGE_SIZE (this is processor dependent)
#ifdef ALPHA
#define PAGE_SIZE 8192
#else
#define PAGE_SIZE 4096
#endif

/**************************************************
 *    FUNCTIONS SPECIFIC TO 32-BIT ONLY
 **************************************************/

#ifdef _MAC
#define LOCKSEMAPHORE(pl)  ((*(pl)==0) ? (*(pl)=1,0) : 1)
#define UNLOCKSEMAPHORE(pl) (*(pl)=0)
#else
#define LOCKSEMAPHORE(pl)   InterlockedExchange((pl),1)
#define UNLOCKSEMAPHORE(pl)   InterlockedExchange((pl),0)
#endif
 
/* GetProfileString */
#define GETPROFILESTRING(a,b,c,d,e)

/* MakeProcInstance is not needed for Win32 */

#define MAKEPROCINSTANCE(a,b) a
#define FREEPROCINSTANCE(a)

/* DLL currently not supported */

#define FREELIBRARY(a)

/* Function calls changes between 16 and 32 bit */

#define SETVIEWPORTORG(a,b,c) SetViewportOrgEx(a,b,c,NULL)
#define SETVIEWPORTEXT(a,b,c) SetViewportExtEx(a,b,c,NULL)
#define SETWINDOWEXT(a,b,c) SetWindowExtEx(a,b,c,NULL)
#define SETWINDOWORG(a,b,c) SetWindowOrgEx(a,b,c,NULL)
#define MOVETO(a,b,c) MoveToEx(a,b,c,NULL)
#define SETBRUSHORG(a,b,c) SetBrushOrgEx(a,b,c,NULL)
#define ENUMFONTFAMILIES(a,b,c,d)     EnumFontFamilies(a,b,c,(LPARAM)d)
#define GETCWD( addr, len )     (GetCurrentDirectory( len, addr ) ? addr : NULL)
#define MAKEPOINT(l) { (LONG)(WORD)(l) , (LONG)(WORD)(l >> 16)}

// Can't have NULL as path... must be a string
#define GETTEMPFILENAME GetTempFileNameEx

WORD EXPORT_API PASCAL FAR GetTempFileNameEx(
	LPCSTR lpszPath,        /* address of name of dir. where temp. file is created  */
	LPCSTR lpszPrefix,      /* address of prefix of temp. filename  */
	WORD uUnique,   /* number used to create temp. filename */
	LPSTR lpszTempFile) ;	/* address buffer that will receive temp. filename	*/

#define MEMCPY    memmove
#define MEMSET    memset
#define MEMCMP	  memcmp
#define FREE      free
#define MALLOC    malloc
#define REALLOC   realloc
#define MEMMOVE   memmove
#define QVCOPY    memmove
#define	VSNPRINTF	_vsnprintf
#define SPRINTF	  wsprintf
#define ITOA	  _itoa
#define ATOI	  atoi
#define ATOL	  atol
#define ISDIGIT	  isdigit
#define ISXDIGIT  isxdigit
#define QvCopy	  memmove
#define STRLEN    strlen
#define STRCPY    strcpy
#define STRDUP    _strdup
#define STRCHR    strchr
#define STRCAT    strcat
#define STRTOK    strtok
#define STRUPR    _strupr
#define STRCMP    strcmp
#define STRICMP   _stricmp
#define STRNICMP  _strnicmp 
#define STRNCPY   strncpy
#define STRNCAT	  strncat

// Define some new macros
// I'm afraid of just defining the ones
// above to the appropriate UNICODE versions
// since the B-tree code (for example) is not
// yet UNICODE
 
#define WSTRLEN    wcslen
#define WSTRCPY    wcscpy
#define WSTRDUP    _wcsdup
#define WSTRCHR    wcschr
#define WSTRCAT    wcscat
#define WSTRTOK    wcstok
#define WSTRUPR    _wcsupr
#define WSTRCMP    wcscmp
#define WSTRICMP   _wcsicmp
#define WSTRNICMP  _wcsnicmp
#define WSTRNCPY   wcsncpy
#define WSTRNCAT   wcsncat
#define WTOI		_wtoi
#define WTOL		_wtol


#define GETINSTANCE(h)  ((HINSTANCE)GetWindowLong(h,GWL_HINSTANCE))
/***********************************************
 *    MAC SPECIFIC DEFINITIONS & DECLARATIONS
 ***********************************************/
    
#ifdef _MAC // {

/* Currently, Pascal convention is inefficient on the MAC, becuase:
 *   - Returned value are passed back on the stack instead of using register
 *   - For earlier CPU (<68910), the return code is less efficient
 *         movel	(a7)+, a0
 *         adda.w #cbParams, a7
 *         jmp    (a0)
 */
//#undef	PASCAL
//#define	PASCAL
#endif // }

#ifdef _BIG_E // BigEndian {

/* The below defines are needed to handle difference in architectures between
 * Motorola's 68K and Intel's x86 memory mappings
 */
 
#ifdef __cplusplus
extern "C"
{
	WORD  PASCAL FAR SwapWord (WORD);
	DWORD PASCAL FAR SwapLong (DWORD);
	WORD  PASCAL FAR GetMacWord (BYTE FAR *);
	VOID  PASCAL FAR SetMacWord (BYTE FAR *, WORD);
	DWORD PASCAL FAR GetMacLong (BYTE FAR *);
	VOID  PASCAL FAR SetMacLong (BYTE FAR *, DWORD);
};
#endif


#define GETWORD(p)    GetMacWord((BYTE FAR *)(p))
#define SETWORD(p,w)  SetMacWord((BYTE FAR *)(p),(w))
#define SWAPWORD(p)   SwapWord((p))
#define GETLONG(p)    GetMacLong((BYTE FAR *)(p))
#define SETLONG(p,l)  SetMacLong((BYTE FAR *)(p),(l))
#define SWAPLONG(p)   SwapLong((p))
#define GETVA(p)      GetMacVA((p))
#define SWAPVA(p)     GetMacVA((p))
#define GETMBHD(p,q)  GetMacMBHD((p),(q))
#define GETMFCP(p,q)  GetMacMFCP((p),(q))
#define HI_BYTE 1
#define LO_BYTE 0

#else	 // regular 32 bit }{
#define	GETWORD(p)	(*((USHORT UNALIGNED FAR *)(p)))
#define SETWORD(a, b)   (*((USHORT UNALIGNED FAR *)(a))=(b))
#define GETLONG(p)	(*((DWORD UNALIGNED FAR *)(p)))
#define SETLONG(p,l) ((*((DWORD UNALIGNED FAR *)(p))) = (l))


#define SWAPWORD(p)	((p))
#define SWAPLONG(p)	((p))
#define GETVA(p)     ((p))
#define SWAPVA(p)    ((p))
#define GETMBHD(p,q) QvCopy((p),(q), sizeof(MBHD))
#define GETMFCP(p,q) QvCopy((p),(q), sizeof(MFCP))
#define HI_BYTE 0
#define LO_BYTE 1

#endif   // _BIG_E}


/*********************************************************************
 *    Typecast to get rid of the unalignment problems on the RISC
 *********************************************************************/
typedef USHORT UNALIGNED FAR * LPUW;
typedef DWORD  UNALIGNED FAR * LPUL;

#else

/***************************************************
 *    16-BITS DEFINITIONS & DECLARATIONS
 ***************************************************/
 
#define EXPORT_API _export
#define UNALIGNED

#define GETWORD(p)   (*((USHORT FAR UNALIGNED *)(p)))
#define SWAPWORD(p)  (p)
#define GETLONG(p)   (*((DWORD FAR UNALIGNED *)(p)))
#define SETLONG(p,l) ((*((DWORD FAR UNALIGNED *)(p))) = l)
#define SWAPLONG(p)  (p)
#define GETVA(p)     (p)
#define SWAPVA(p)    (p)
#define GETMBHD(p,q) QvCopy((p),(q), sizeof(MBHD))
#define GETMFCP(p,q) QvCopy((p),(q), sizeof(MFCP))
#define HI_BYTE 0
#define LO_BYTE 1

#define LOCKSEMAPHORE(pl)  ((*(pl)==0) ? (*(pl)=1,0) : 1)
#define UNLOCKSEMAPHORE(pl) (*(pl)=0)

/* GetProfileString */
#define GETPROFILESTRING(a,b,c,d,e) GetProfileString(a,b,c,d,e)

/* DLL currently not supported */

#define FREELIBRARY(a) FreeLibrary(a)

/* Viewport calls */

#define SETVIEWPORTORG(a,b,c) SetViewportOrg(a,b,c)
#define SETVIEWPORTEXT(a,b,c) SetViewportExt(a,b,c)
#define SETWINDOWEXT(a,b,c) SetWindowExt(a,b,c)
#define SETWINDOWORG(a,b,c) SetWindowOrg(a,b,c)
#define MOVETO(a,b,c) MoveTo(a,b,c)
#define SETBRUSHORG(a,b,c) SetBrushOrg(a,b,c)
#define ENUMFONTFAMILIES(a,b,c,d)     EnumFontFamilies(a,b,c,(LPSTR)d)
#define GETCWD( addr, len )     getcwd( addr, len )

#define MEMCPY    _fmemmove
#define MEMSET    _fmemset
#define MEMCMP	  _fmemcmp
#define STRLEN    _fstrlen
#define STRCPY    _fstrcpy
#define STRDUP    _fstrdup
#define STRCHR    _fstrchr
#define STRCAT    _fstrcat
#define STRTOK    _fstrtok
#define STRUPR    _fstrupr
#define STRCMP    _fstrcmp
#define STRICMP   _fstricmp
#define STRNICMP  _fstrnicmp 
#define FREE      _ffree
#define MALLOC    _fmalloc
#define REALLOC   _frealloc
#define STRNCPY   _fstrncpy
#define MEMMOVE   _fmemmove
#define QVCOPY    _fmemmove
#define	VSNPRINTF	_vsnprintf
#define STRNCAT	  _fstrncat
#define SPRINTF	  wsprintf
#define ITOA	  itoa

#define MAKEPROCINSTANCE(a,b) MakeProcInstance(a,b)
#define FREEPROCINSTANCE(a) FreeProcInstance(a)
#define GETTEMPFILENAME GetTempFileName

#define GETINSTANCE(h)  ((HINSTANCE)GetWindowWord(h,GWW_HINSTANCE))
#endif  // } _32BIT
#endif // __MVOPSYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\navpane.cpp ===
#include "header.h"
#include "navpane.h"

#include "navui.h"

// Common Control Macros
#include <windowsx.h>

///////////////////////////////////////////////////////////
//
// Non-Member helper functions.
//
///////////////////////////////////////////////////////////
//
// Convert a rect from screen to client.
//
void ScreenRectToClientRect(HWND hWnd, RECT* prect)
{
    // Save the size.
    SIZE size ;
    size.cx = prect->right - prect->left ;
    size.cy = prect->bottom - prect->top ;

    // Convert the origin.
    ::ScreenToClient(hWnd, reinterpret_cast<POINT*>(prect)) ; 

    // Add the size back.
    prect->right = prect->left + size.cx ;
    prect->bottom = prect->top + size.cy; 
}

///////////////////////////////////////////////////////////
//
// GetAcceleratorKey - Find the accelerator key from the ctrl.
//
int
GetAcceleratorKey(HWND hwndctrl)
{
    int iReturn = 0 ;
    char text[256] ;
    ::GetWindowText(hwndctrl, text, 256) ;

    int len = (int)strlen(text) ;
    if (len != 0)
    {
        // Find the '&' key.
        char* p = strchr(text, '&') ;
        if (p != NULL) 
        {
            iReturn = tolower(*(p+1)) ;
        }
    }
    return iReturn ;
}


///////////////////////////////////////////////////////////
//
// ProcessMenuChar --- Process accelerator keys.
//
// REVIEW: NavPanes need base class.
//
//
bool
ProcessMenuChar(INavUI* pNavUI,
                HWND hwndParent, 
                CDlgItemInfo* DlgItems, // Array of dialog items
                int NumDlgItems,        // Number of items in the array
                int ch                  // accelerator to act on.
                )
{
    bool iReturn = false ;
    for (int i = 0 ; i < NumDlgItems  ; i++)
    {
        if (DlgItems[i].m_accelkey == ch)
        {
            if (DlgItems[i].m_Type == ItemInfo::Button)
            {
                // Its a button so do the command.
                ASSERT(pNavUI != NULL) ;
                pNavUI->OnCommand(hwndParent, DlgItems[i].m_id, BN_CLICKED, 0) ;
            }
            else if (DlgItems[i].m_Type == ItemInfo::CheckBox)
            {
                // Its a checkbox, so select/unselect it.
                int state = Button_GetCheck(DlgItems[i].m_hWnd) ;
                Button_SetCheck(DlgItems[i].m_hWnd, (state == BST_CHECKED) ? BST_UNCHECKED : BST_CHECKED) ;

                // Set focus.
                ::SetFocus(DlgItems[i].m_hWnd) ;
            }
            else
            {
                // Set focus.
                ::SetFocus(DlgItems[i].m_hWnd) ;
            }

            // Found it!
            iReturn = true ;
            // Finished
            break ;
        }
    }

    return iReturn ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\onclick.h ===
// Copyright  1996-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _HHCTRL_H_
#include "hhctrl.h"
#endif

#ifndef _CDLG_H_
#include "cdlg.h"
#endif


class CAboutBox : public CDlg
{
public:
	CAboutBox(CHtmlHelpControl* phhCtrl)
            : CDlg(phhCtrl, IDDLG_ABOUTBOX) { };
	BOOL OnBeginOrEnd(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\onclick.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "hhctrl.h"
#include "strtable.h"
#include "resource.h"
#include "hha_strtable.h"
#include "onclick.h"
#include "index.h"
#include "toc.h"
#include "wwheel.h"
#include "web.h"
#include <shellapi.h>
#include <wininet.h>

#include "sample.h"
#include "subset.h"
#include "secwin.h"     //For extern CHHWinType** pahwnd;

#undef WINUSERAPI
#define WINUSERAPI
#include "htmlhelp.h"

#include "lasterr.h"    // Support for reporting the last error.

#define NOTEXT_BTN_HEIGHT 12
#define NOTEXT_BTN_WIDTH  12
#define CXBUTTONEXTRA  8    // spacing between text and button
#define CYBUTTONEXTRA  8

static const char txtOpen[] = "open";
static const char txtCplOpen[] = "cplopen";
static const char txtRegSection[] = "Software\\Microsoft\\HtmlHelp\\";
static const char txtShortcut[] = "shortcut";

static DWORD GetTextDimensions(HWND hwnd, PCSTR psz, HFONT hfont = NULL);

HRESULT OSLangMatchesChm(CExCollection *pCollection);

HRESULT GetWordWheelHits( PSTR pszKeyword, CWordWheel* pWordWheel,
                          CTable* ptblURLs, CWTable* ptblTitles,
                          CWTable *ptblLocations, BOOL bTestMode,
                          BOOL bSkipCurrent, BOOL bFullURL = FALSE );

HRESULT GetWordWheelHits( CExCollection* pCollection,
                          CTable* ptblItems, CTable* ptblURLs,
                          CWTable* ptblTitles, CWTable *ptblLocations,
                          BOOL bKLink, BOOL bTestMode, BOOL bSkipCurrent );

HRESULT OnWordWheelLookup( CTable* ptblItems, CExCollection* pExCollection,
                           PCSTR pszDefaultTopic = NULL, POINT* ppt = NULL,
                           HWND hWndParent = NULL, BOOL bDialog = TRUE,
                           BOOL bKLink = TRUE,
                           BOOL bTestMode = FALSE, BOOL bSkipCurrent = FALSE,
                           BOOL bAlwaysShowList = FALSE, BOOL bAlphaSortHits = TRUE,
                     PCSTR pszWindow = NULL);

BOOL g_HackForBug_HtmlHelpDB_1884 = 0;

/***************************************************************************

    FUNCTION:   OnWordWheelLookup

    PURPOSE:    Given a keyword, or semi-colon delimited list of keywords,
                find the hits.  If no hits found display a "not found" message;
                if one hit found then just jump to the topic, otherwise
                display a list of topics for the user to choose from.

    PARAMETERS:
        pszKeywords     - word(s) to lookup

    ... the rest the same as OnWordWheelLookup( CTable* ... )

    RETURNS:

      TRUE if there is at least one match.  FALSE otherwise.

    COMMENTS:

      No support for external titles with this API.

    MODIFICATION DATES:
        09-Jan-1998 [paulti]

***************************************************************************/

HRESULT OnWordWheelLookup( PSTR pszKeywords, CExCollection* pExCollection,
                           PCSTR pszDefaultTopic, POINT* ppt,
                           HWND hWndParent, BOOL bDialog, BOOL bKLink,
                           BOOL bTestMode, BOOL bSkipCurrent,
                           BOOL bAlwaysShowList, BOOL bAlphaSortHits,
                     PCSTR pszWindow)
{
  // trim leading and trailing spaces
  char* pszKeywords2 = new char[strlen(pszKeywords)+1];
  strcpy( pszKeywords2, pszKeywords );
  SzTrimSz( pszKeywords2 );

  // create our lists
  CTable tblItems;

  // initialize our item list
  tblItems.AddString( "" ); // set item1 to NULL -- no external titles
  PSTR pszKeyword = StrToken( pszKeywords2, ";" );
  while( pszKeyword ) {
    CHAR szKeyword[HHWW_MAX_KEYWORD_LENGTH+1];
    lstrcpyn( szKeyword, pszKeyword, sizeof(szKeyword)-1 );
    SzTrimSz( szKeyword );
    tblItems.AddString( szKeyword );
    pszKeyword = StrToken(NULL, ";");
  }
  delete [] pszKeywords2;

  return OnWordWheelLookup( &tblItems, pExCollection,
                            pszDefaultTopic, ppt, hWndParent, bDialog,
                            bKLink, bTestMode, bSkipCurrent,
                            bAlwaysShowList, bAlphaSortHits, pszWindow );
}


/***************************************************************************

    FUNCTION:   OnWordWheelLookup

    PURPOSE:    Given a list of keywords find the hits.  If no hits found
                display a "not found" message if one hit found then just
                jump to the topic, otherwise display a list of topics for
                the user to choose from.

    PARAMETERS:
        ptblItems       - word(s) to lookup (first item is semi-colon delimited
                          list of external titles to check).
        pCollection     - collection pointer, needed to access word wheels.
        pszDefaultTopic - default topic to jump to.
        ppt             - pointer to a point to center the window on.  If NULL
                          then we will use the current mouse pointer position.
        hWndParent      - window to parent the "Topics Found" dialog/menu to.
                          If NULL, then use the active window.
        bDialog         - dialog based?  If not, use a menu.
        bKLink          - is this a keyword lookup? if not, use the ALink list.
        bTestMode       - test existence only (dont' show a UI).
        bSkipCurrent    - skip the current URL in the returned list.
        bAlwaysShowList - always show the hit list even if only one topic is found.
        bAlphaSortHits  - alpha sort the title list or not.


    RETURNS:

      TRUE if there is at least one match.  FALSE otherwise.

    COMMENTS:

    MODIFICATION DATES:
        09-Jan-1998 [paulti]

***************************************************************************/

HRESULT OnWordWheelLookup( CTable* ptblItems, CExCollection* pCollection,
                           PCSTR pszDefaultTopic, POINT* ppt,
                           HWND hWndParent, BOOL bDialog, BOOL bKLink,
                           BOOL bTestMode, BOOL bSkipCurrent,
                           BOOL bAlwaysShowList, BOOL bAlphaSortHits, PCSTR pszWindow)
{
  HRESULT hr = S_OK;

  UINT CodePage = pCollection ? pCollection->GetMasterTitle()->GetInfo()->GetCodePage() : CP_ACP;

  // create our lists
  CWTable tblTitles( CodePage );
  CWTable tblLocations( CodePage );
  CTable  tblURLs;

  if( pCollection ) {

    // get the active window if non specified
    if( !hWndParent )
      hWndParent = GetActiveWindow();

    // get current mouse pointer position if non-specified
    POINT pt;
    if( !ppt ) {
      GetCursorPos( &pt );
      ppt = &pt;
#if 1 // reverted bug fix #5516
      HWND hwnd = GetFocus();
      if ( hwnd ) {
        DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE );
        if ( dwStyle & BS_NOTIFY )
        {

            RECT rc;
            if( GetWindowRect(hwnd, &rc) ) {
              pt.y = rc.top+(RECT_WIDTH(rc)/2);
              pt.x = rc.left + ((RECT_HEIGHT(rc)/3)*2); // two-thirds of the height of the button
            }
        }
      }
#endif
    }

    hr = GetWordWheelHits( pCollection,
                           ptblItems, &tblURLs, &tblTitles, &tblLocations,
                           bKLink, bTestMode, bSkipCurrent );
  }
  else {
    hr = HH_E_KEYWORD_NOT_SUPPORTED;
  }

  // we are all done if we are just in test mode
  if( bTestMode )
    return hr;

  int iIndex = 0;
  char szURL[INTERNET_MAX_URL_LENGTH];

  // if we get no topics then display the default message
  // othewise an "error" message
  if( FAILED(hr) || tblURLs.CountStrings() < 1) {

    if( pCollection && pszDefaultTopic ) {
      if( pCollection && StrRChr( pszDefaultTopic, ':' ) == NULL ) {
        CStr szCurrentURL;
        GetCurrentURL( &szCurrentURL, hWndParent );
        CStr szFileName;
        LPSTR pszColon = StrRChr( szCurrentURL.psz, ':' );
        LPSTR pszSlash = StrRChr( szCurrentURL.psz, '/' );
        LPSTR pszTail = max( pszColon, pszSlash );
        lstrcpyn( szURL, szCurrentURL.psz, (int)(pszTail - szCurrentURL.psz +2) );
        strcat( szURL, pszDefaultTopic );
      }
      else
        strcpy( szURL, pszDefaultTopic );
      hr = S_OK; // set to S_OK so the jump below will work
    }
    else {
      int iStr = 0;

      switch( hr ) {

        case HH_E_KEYWORD_NOT_FOUND:
          iStr = IDS_HH_E_KEYWORD_NOT_FOUND;
          break;

        case HH_E_KEYWORD_IS_PLACEHOLDER:
          iStr = IDS_HH_E_KEYWORD_IS_PLACEHOLDER;
          break;

        case HH_E_KEYWORD_NOT_IN_SUBSET:
          iStr = IDS_HH_E_KEYWORD_NOT_IN_SUBSET;
          break;

        case HH_E_KEYWORD_NOT_IN_INFOTYPE:
          iStr = IDS_HH_E_KEYWORD_NOT_IN_INFOTYPE;
          break;

        case HH_E_KEYWORD_EXCLUDED:
          iStr = IDS_HH_E_KEYWORD_EXCLUDED;
          break;

        case HH_E_KEYWORD_NOT_SUPPORTED:
          iStr = IDS_REQUIRES_HTMLHELP;
          break;

        default:
          iStr = IDS_IDH_MISSING_CONTEXT;
          break;

      }
      MsgBox(iStr, MB_OK | MB_ICONWARNING | MB_SETFOREGROUND);
    }
  }
  else {
    // if only one topic then jump to it
    if( !bAlwaysShowList && tblURLs.CountStrings() == 1 ) {
      tblURLs.GetString( szURL, 1 );
    }
    else {

      // we can sort the title table since it contains the index value
      // of the associated URL so just make sure to always fetch the
      // URL index from the selected title string and use that to get the URL
      if( bAlphaSortHits ) {
        tblTitles.SetSorting(GetSystemDefaultLCID());
        tblTitles.SortTable(sizeof(HASH));
      }
      if( !bDialog && tblURLs.CountStrings() < 20 ) {
        HMENU hMenu = CreatePopupMenu();
        if( hMenu ) {
          for( int i = 1; i <= tblURLs.CountStrings(); i++ ) {
            LPSTR psz = tblTitles.GetHashStringPointer(i);
            // if title too long, truncate it (511 seems like a good max)
            if( psz && *psz ) {
              int iLen = (int)strlen(psz);
              #define MAX_LEN 511
              char sz[MAX_LEN+1];
              if( iLen >= MAX_LEN ) {
                strncpy( sz, psz, MAX_LEN-1 );
                sz[MAX_LEN] = 0;
                psz = sz;
              }
            }
            HxAppendMenu(hMenu, MF_STRING, IDM_RELATED_TOPIC + i, psz );
          }
          int iCmd = TrackPopupMenu(hMenu,
                       TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON |
                       TPM_NONOTIFY | TPM_RETURNCMD,
                       ppt->x, ppt->y, 0, hWndParent, NULL);
          DestroyMenu( hMenu );
          if( iCmd ) {
            iIndex = tblTitles.GetInt( iCmd - IDM_RELATED_TOPIC );
            tblURLs.GetString( szURL, iIndex );
          }
          else {
            hr = HH_E_KEYWORD_NOT_FOUND; // Means we have nothing to jump to
          }
        }
      }
      else
      {
        HFONT hfont;
        if ( pCollection )
           hfont = pCollection->m_phmData->GetContentFont();
        else
           hfont = _Resource.GetUIFont();   // Not ideal but will have to do.

        UINT CodePage = pCollection ? pCollection->GetMasterTitle()->GetInfo()->GetCodePage() : CP_ACP;

        CTopicList TopicList( hWndParent, &tblTitles, hfont, &tblLocations );
        if( TopicList.DoModal() ) {
          iIndex = tblTitles.GetInt( TopicList.m_pos );
          tblURLs.GetString( szURL, iIndex );
        }
        else {
          hr = HH_E_KEYWORD_NOT_FOUND; // Means we have nothing to jump to
        }
      }
    }
  }

  // if we found something to jump to then jump to it
  if( !FAILED(hr) )
  {
     if (pCollection && pszWindow && pszWindow[0])
     {
      CStr cszPrefix = szURL;

        // Is the window we are attempting to open defined by the master CHM?
        CHHWinType* phh = FindWindowType(pszWindow, NULL, pCollection->GetPathName());
        // Does this window actually exist?
        if (phh && IsWindow(phh->hwndHelp))
        {
           doHHWindowJump(cszPrefix, phh->hwndHelp);
         return hr;
        }

        cszPrefix += ">";
        cszPrefix += pszWindow;
        OnDisplayTopic(hWndParent, cszPrefix, 0);
    }
    else
       doHHWindowJump( szURL, hWndParent );
  }
  return hr;
}

/***************************************************************************

    FUNCTION:   GetWordWheelHits

    PURPOSE:    Given a single keyword, find the hits
                Return S_OK if there is at least one found hit

    PARAMETERS:
        pWordWheel   - word wheel to look in
        ptblURLS     - URL list
        ptblTitles   - title list
        bTestMode    - test existence only (replaces old TestAKLink code)
        bSkipCurrent - skip the current URL in the returned list
        bFullURL     - return a URL with a full pathname to the title or (default)
                       just return the URL with just the filename of the title

    RETURNS:

        S_OK                         - hits were found.
        HH_E_KEYWORD_NOT_FOUND       - no hits found.
        HH_E_KEYWORD_IS_PLACEHOLDER  - keyword is a placeholder or
                                       a "runaway" see also.
        HH_E_KEYWORD_NOT_IN_SUBSET   - no hits found due to subset
                                       exclusion.
        HH_E_KEYWORD_NOT_IN_INFOTYPE - no hits found due to infotype
                                       exclusion.
        HH_E_KEYWORD_EXCLUDED        - no hits found due to infotype
                                       and subset exclusion.

        HH_E_KEYWORD_NOT_SUPPORTED   - keywords not supported in this mode.

    COMMENTS:

    HH_E_KEYWORD_EXCLUDED is returned only when no hits are found due to
    *both* removal by subsetting and infotype

    MODIFICATION DATES:
        13-Apr-1998 [paulti]

***************************************************************************/

HRESULT GetWordWheelHits( PSTR pszKeyword, CWordWheel* pWordWheel,
                          CTable* ptblURLs, CWTable* ptblTitles, CWTable *ptblLocations,
                          BOOL bTestMode, BOOL bSkipCurrent, BOOL bFullURL )
{
  HRESULT hr = S_OK;
  BOOL bExcludedBySubset = FALSE;
  BOOL bExcludedByInfoType = FALSE;
  BOOL bPlaceHolder = FALSE;

  CStructuralSubset* pSubset;

  if( pszKeyword ) {

    DWORD dwIndexLast = HHWW_ERROR;
    DWORD dwIndexFirst = pWordWheel->GetIndex( pszKeyword, FALSE, &dwIndexLast );

    if( dwIndexFirst == HHWW_ERROR )
      return HH_E_KEYWORD_NOT_FOUND;

    for( DWORD dwIndex = dwIndexFirst; dwIndex <= dwIndexLast; dwIndex++ ) {

      // skip over the placeholders
      if( pWordWheel->IsPlaceHolder( dwIndex ) ) {
        bPlaceHolder = TRUE;
        continue;
      }

      // follow the see also links
      CHAR szSeeAlso[HHWW_MAX_KEYWORD_LENGTH+1];
      if( pWordWheel->GetSeeAlso( dwIndex, szSeeAlso, sizeof(szSeeAlso) ) ) {
        if( pWordWheel->AddRef() >= HHWW_MAX_LEVELS ) {
          pWordWheel->Release();
          return HH_E_KEYWORD_IS_PLACEHOLDER;
        }
        hr = GetWordWheelHits( szSeeAlso, pWordWheel, ptblURLs, ptblTitles, ptblLocations,
                               bTestMode, bSkipCurrent, bFullURL );
        pWordWheel->Release();

        switch( hr ) {
          case HH_E_KEYWORD_EXCLUDED:
            bExcludedBySubset = TRUE;
            bExcludedByInfoType = TRUE;
            break;

          case HH_E_KEYWORD_NOT_IN_SUBSET:
            bExcludedBySubset = TRUE;
            break;

          case HH_E_KEYWORD_NOT_IN_INFOTYPE:
            bExcludedByInfoType = TRUE;
            break;

          case HH_E_KEYWORD_IS_PLACEHOLDER:
            bPlaceHolder = TRUE;
            break;
        }
        continue;
      }

      // fetch the hits
      CStr cszCurrentURL;
      GetCurrentURL( &cszCurrentURL );
      DWORD dwHitCount = pWordWheel->GetHitCount(dwIndex);
      if (dwHitCount != HHWW_ERROR) {
        for (DWORD i = 0; i < dwHitCount; i++) {
          CExTitle* pTitle = NULL;
          DWORD dwURLId = pWordWheel->GetHit(dwIndex, i, &pTitle);
          if (pTitle && dwURLId != HHWW_ERROR) {

           #if 0 // we do not support infotypes currently
            CSubSet* pSS;
            const unsigned int *pdwITBits;
            //
            // Do we need to filter based on infotypes ?
            //
            if ( pTitle->m_pCollection && pTitle->m_pCollection->m_pSubSets &&
                 (pSS = pTitle->m_pCollection->m_pSubSets->GetIndexSubset()) && !pSS->m_bIsEntireCollection )
            {
              //
              // Yep, do the filter thang.
              //
              pdwITBits = pTitle->GetTopicITBits(dwURLId);
              if (! pTitle->m_pCollection->m_pSubSets->fIndexFilter(pdwITBits) ) {
                 bExcludedByInfoType = TRUE;
                 continue;
              }
            }
           #endif
            //
            // Do we need to filter based on structural subsets?
            //
            if( pTitle->m_pCollection && pTitle->m_pCollection->m_pSSList &&
                (pSubset = pTitle->m_pCollection->m_pSSList->GetF1()) && !pSubset->IsEntire() )
            {
               // Yes, filter using the current structural subset for F1.
               //
               if (! pSubset->IsTitleInSubset(pTitle) ) {
                 bExcludedBySubset = TRUE;
                 continue;
               }
            }

            // if we make it this far and we are in test mode
            // we can bail out and return S_OK
            if( bTestMode )
              return S_OK;

            char szTitle[1024];
            szTitle[0] = 0;
            pTitle->GetTopicName( dwURLId, szTitle, sizeof(szTitle) );
            if( !szTitle[0] )
              strcpy( szTitle, GetStringResource( IDS_UNTITLED ) );

            char szLocation[INTERNET_MAX_PATH_LENGTH]; // 2048 should be plenty
            szLocation[0] = 0;
            if( pTitle->GetTopicLocation(dwURLId, szLocation, INTERNET_MAX_PATH_LENGTH) != S_OK )
              strcpy( szLocation, GetStringResource( IDS_UNKNOWN ) );

            char szURL[INTERNET_MAX_URL_LENGTH];
            szURL[0] = 0;
            pTitle->GetTopicURL( dwURLId, szURL, sizeof(szURL), bFullURL );

            char szFullURL[INTERNET_MAX_URL_LENGTH];
            szFullURL[0] = 0;
            pTitle->ConvertURL( szURL, szFullURL );

            if( szURL[0] ) {
              if( !ptblURLs->IsStringInTable(szURL) ) {
                if( cszCurrentURL.IsEmpty()
                    || !(bSkipCurrent && (lstrcmpi( cszCurrentURL, szURL ) == 0) ||(lstrcmpi( cszCurrentURL, szFullURL ) == 0 ) )) {
                  int iIndex = ptblURLs->AddString(szURL);
                  ptblTitles->AddIntAndString(iIndex, szTitle[0]?szTitle:"");
                  ptblLocations->AddString( *szLocation?szLocation:"" );
                }
              }
            }

          }
        }
      }
    }
  }

  // determine the proper return value
  if( ptblURLs->CountStrings() < 1 ) {
    if( bExcludedBySubset && bExcludedByInfoType )
      hr = HH_E_KEYWORD_EXCLUDED;
    else if( bExcludedBySubset )
      hr = HH_E_KEYWORD_NOT_IN_SUBSET;
    else if( bExcludedByInfoType )
      hr = HH_E_KEYWORD_NOT_IN_INFOTYPE;
    else if( bPlaceHolder )
      hr = HH_E_KEYWORD_IS_PLACEHOLDER;
    else
      hr = HH_E_KEYWORD_NOT_FOUND;
  }
  else
    hr = S_OK;

  return hr;
}

/***************************************************************************

    FUNCTION:   GetWordWheelHits

    PURPOSE:    Get all the links for the specified keywords
                Return TRUE if there is at least one match

    PARAMETERS:
        pCollection - point to the collection
        ptblItems   - item table, item 1 is the list of external titles
                      and items 2 thru N are the list of keywords
        ptblURLs    - URL list
        ptblTitles  - title list
        bKLink      - is this a klink (defaults to alink)
        bTestMode   - test existence only (replaces old TestAKLink code)
        bSkipCurrent - skip the current URL in the returned list

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        14-Nov-1997 [paulti]

***************************************************************************/

HRESULT GetWordWheelHits( CExCollection* pCollection,
                          CTable* ptblItems, CTable* ptblURLs, CWTable* ptblTitles, CWTable *ptblLocations,
                          BOOL bKLink, BOOL bTestMode, BOOL bSkipCurrent )
{
  int pos;
  CWordWheel* pWordWheel = NULL;
  HRESULT hr = S_OK;
  HRESULT hrReturn = HH_E_KEYWORD_NOT_FOUND;  // assume the worst

  if( pCollection ) {
    pWordWheel = (bKLink ? pCollection->m_pDatabase->GetKeywordLinks() :
       pCollection->m_pDatabase->GetAssociativeLinks());
  }

  // if we did not get a word wheel pointer then skip the internal
  // word wheels and fall back to just the external ones
  if( pWordWheel ) {

    // add in the internal hits first
    for( pos = 2; pos <= ptblItems->CountStrings(); pos++ ) {
      CStr cszKeywords(ptblItems->GetPointer(pos)); // copy so StrToken can modify
      PSTR pszKeyword = StrToken(cszKeywords, ";");

      while( pszKeyword ) {
        hr = GetWordWheelHits( pszKeyword, pWordWheel,
                               ptblURLs, ptblTitles, ptblLocations,
                               bTestMode, bSkipCurrent, TRUE  );

        if( bTestMode && !FAILED(hr) )
          return hr;

        // if we failed again, then collate the resultant error
        if( FAILED( hrReturn ) && FAILED( hr ) ) {

          switch( hrReturn ) {

            case HH_E_KEYWORD_NOT_IN_INFOTYPE:
              if( hr == HH_E_KEYWORD_NOT_IN_SUBSET )
                hrReturn = HH_E_KEYWORD_EXCLUDED;
              else
                hrReturn = hr;
              break;

            case HH_E_KEYWORD_NOT_IN_SUBSET:
              if( hr == HH_E_KEYWORD_NOT_IN_INFOTYPE )
                hrReturn = HH_E_KEYWORD_EXCLUDED;
              else
                hrReturn = hr;
              break;

            case HH_E_KEYWORD_EXCLUDED:
              hrReturn = HH_E_KEYWORD_EXCLUDED;
              break;

            default:
              hrReturn = hr;
              break;

          }

        }
        else if( !FAILED( hr ) )
          hrReturn = hr;

        pszKeyword = StrToken(NULL, ";");
        if( pszKeyword )
          pszKeyword = FirstNonSpace(pszKeyword);
      }
    }

  }

  // create a list of the external titles
  // skip those titles that are already in the collection
  CStr cszTitle(ptblItems->GetPointer(1));
  if( !IsEmptyString(cszTitle) ) {

    PSTR pszTitle = StrToken(cszTitle, ";");
    CWTable* ptblTitleFiles = new CWTable(ptblTitles->GetCodePage());  // REVIEW: external titles must have the same codepage!
    while( pszTitle ) {
      if( *pszTitle ) {
        TCHAR szTitle[MAX_PATH];
        PSTR pszTitle2 = szTitle;
        strcpy( szTitle, pszTitle );
        pszTitle2 = FirstNonSpace( szTitle );
        RemoveTrailingSpaces( pszTitle2 );
        CExTitle* pTitle = NULL;
        if( *pszTitle2 && pCollection && FAILED(pCollection->URL2ExTitle(pszTitle2,&pTitle ) ) ) {
          CStr Title;
          // check if the file lives where the master file lives
          if( pszTitle2 ) {
            char szPathName[_MAX_PATH];
            char szFileName[_MAX_FNAME];
            char szExtension[_MAX_EXT];
            SplitPath((LPSTR)pszTitle2, NULL, NULL, szFileName, szExtension);
            char szMasterPath[_MAX_PATH];
            char szMasterDrive[_MAX_DRIVE];
            SplitPath((LPSTR)pCollection->m_csFile, szMasterDrive, szMasterPath, NULL, NULL);
            strcpy( szPathName, szMasterDrive );
            CatPath( szPathName, szMasterPath );
            CatPath( szPathName, szFileName );
            strcat( szPathName, szExtension );
            Title = szPathName;
            if( (GetFileAttributes(szPathName) != HFILE_ERROR) || FindThisFile( NULL, pszTitle2, &Title, FALSE ) ) {
              if( Title.IsNonEmpty() )
                ptblTitleFiles->AddString( Title );
            }
          }
        }
      }
      pszTitle = StrToken(NULL, ";");
    }

    // add in the external hits last
    int iTitleCount = ptblTitleFiles->CountStrings();
    for( int iTitle = 1; iTitle <= iTitleCount; iTitle++ ) {
      char szTitle[MAX_PATH];
      ptblTitleFiles->GetString( szTitle, iTitle );

      // get title objects
      CExTitle* pTitle = new CExTitle( szTitle, NULL );
      CTitleDatabase* pDatabase = new CTitleDatabase( pTitle );

      CWordWheel* pWordWheel = NULL;
      if( bKLink )
        pWordWheel = pDatabase->GetKeywordLinks();
      else
        pWordWheel = pDatabase->GetAssociativeLinks();

      for (int pos = 2; pos <= ptblItems->CountStrings(); pos++) {
          CStr cszKeywords(ptblItems->GetPointer(pos));     // copy so StrToken can modify
          PSTR pszKeyword = StrToken(cszKeywords, ";");

        while( pszKeyword ) {
          hr = GetWordWheelHits( pszKeyword, pWordWheel,
                                 ptblURLs, ptblTitles, ptblLocations,
                                 bTestMode, bSkipCurrent, TRUE );

          if( bTestMode && !FAILED(hr) ) {
            hrReturn = hr;
            break;
          }

          // if we failed again, then collate the resultant error
          if( FAILED( hrReturn ) && FAILED( hr ) ) {

            switch( hrReturn ) {

              case HH_E_KEYWORD_NOT_IN_INFOTYPE:
                if( hr == HH_E_KEYWORD_NOT_IN_SUBSET )
                  hrReturn = HH_E_KEYWORD_EXCLUDED;
                else
                  hrReturn = hr;
                break;

              case HH_E_KEYWORD_NOT_IN_SUBSET:
                if( hr == HH_E_KEYWORD_NOT_IN_INFOTYPE )
                  hrReturn = HH_E_KEYWORD_EXCLUDED;
                else
                  hrReturn = hr;
                break;

              case HH_E_KEYWORD_EXCLUDED:
                hrReturn = HH_E_KEYWORD_EXCLUDED;
                break;

              default:
                hrReturn = hr;
                break;

            }

          }
          else if( !FAILED( hr ) )
            hrReturn = hr;

          pszKeyword = StrToken(NULL, ";");
          if( pszKeyword )
            pszKeyword = FirstNonSpace(pszKeyword);
        }

        if( bTestMode && !FAILED(hr) ) {
          hrReturn = hr;
          break;
        }
      }

      // free title objects
      delete pDatabase;
      delete pTitle;

      if( bTestMode && !FAILED(hr) ) {
        hrReturn = hr;
        break;
      }
    }

    // free our title list
    delete ptblTitleFiles;
  }

  return hrReturn;
}

/***************************************************************************

    FUNCTION:   CHtmlHelpControl::OnAKLink

    PURPOSE:    Return TRUE if there is at least one match

    PARAMETERS:
        fKLink    - is this a klink? (defaults to alink)
        bTestMode - test for existence only

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        28-JAN-1998 [paulti] major rewrite

***************************************************************************/

BOOL CHtmlHelpControl::OnAKLink( BOOL fKLink, BOOL bTestMode )
{
  if( !m_ptblItems )
    return FALSE;

  // get our cursor position first since the merge prompt
  // may change our current position
  //
  // BUGBUG: what if the use tabbed to this link and then pressed ENTER?
  //         We should then anchor the menu to the bottom-left of the parent
  //         window.  Right?
  POINT pt;

  GetCursorPos(&pt);

  HWND hwnd = GetFocus();
  if ( hwnd ) {
     DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE );
     if ( dwStyle & BS_NOTIFY )
     {
        RECT rc;
        if( GetWindowRect(hwnd, &rc) ) {
          pt.y = rc.top+((rc.bottom-rc.top)/2);
          pt.x = rc.left + ((RECT_HEIGHT(rc)/3)*2); // two-thirds of the height of the button
        }
     }
  }

  // get the parent window
  HWND hWndParent = NULL ;
  if( m_fButton && m_hwndDisplayButton )
    hWndParent = m_hwndDisplayButton;
  else if( m_hwnd && IsWindow(m_hwnd) )
    hWndParent = m_hwnd;
  else
  {
    // Tunnel through IE to get the HWND of HTML Help's frame window.
    hWndParent = GetHtmlHelpFrameWindow() ;
  }

  // If nothing else works, try the actice window. Eck!
  if( !hWndParent )
    hWndParent = GetActiveWindow();

  // Worse, try the desktop window!
  if( !hWndParent )
    hWndParent = GetDesktopWindow();

  //
  // <mc> Find a CExCollection pointer...
  //
  CExCollection* pExCollection = NULL;
  CStr cstr;

  if ( m_pWebBrowserApp )
  {
     m_pWebBrowserApp->GetLocationURL(&cstr);
     pExCollection = GetCurrentCollection(NULL, (PCSTR)cstr);
  }

  // should we always display the jump list even on one hit?
  BOOL bAlwaysShowList = FALSE;
  if( m_flags[0] == 1 )
    bAlwaysShowList = TRUE;

  // call our shared "Topics Found" handler

  BOOL fPopupMenu = m_fPopupMenu;

  if (fPopupMenu == TRUE && OSLangMatchesChm(pExCollection) != S_OK)
    fPopupMenu = FALSE;
  
  HRESULT hr = OnWordWheelLookup( m_ptblItems, pExCollection, m_pszDefaultTopic, &pt, hWndParent,
                                  !fPopupMenu, fKLink, bTestMode, TRUE, bAlwaysShowList, TRUE, m_pszWindow);

  if( FAILED( hr ) )
    return FALSE;

  return TRUE;
}

LRESULT CHtmlHelpControl::StaticTextControlSubWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC hDC;
    RECT rc;

    CHtmlHelpControl* pThis = (CHtmlHelpControl*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    switch (msg)
    {
       case WM_KILLFOCUS:
       case WM_SETFOCUS:
          if ( pThis && pThis->m_imgType == IMG_TEXT )
          {
             hDC = ::GetDC(hwnd);
             GetClientRect(hwnd, &rc);
             ::DrawFocusRect(hDC, &rc);
             ReleaseDC(hwnd, hDC);
             return 0;
          }
          break;

      case WM_KEYDOWN:
          if ( wParam == VK_RETURN || (wParam == VK_SPACE && (pThis->m_imgType == IMG_TEXT)) )
          {
             PostMessage(GetParent(hwnd), WM_COMMAND, MAKELONG(IDBTN_DISPLAY, BN_CLICKED), (LPARAM)hwnd);
             return 0;
          }
          break;
    }
    if ( pThis )
       return CallWindowProc(pThis->m_lpfnlStaticTextControlWndProc, hwnd, msg, wParam, lParam);
    else
       return 0;
}

BOOL CHtmlHelpControl::CreateOnClickButton(void)
{
    // First create the window, then size it to match text and/or bitmap
    PSTR pszClassName;
    char szWindowText[MAX_PATH];

    if ( m_imgType == IMG_BUTTON )
    {
       pszClassName = "button";
       WideCharToMultiByte( m_CodePage, 0, m_pwszButtonText, -1, szWindowText, sizeof(szWindowText), NULL, NULL );
    }
    else
    {
       pszClassName = "static";
       *szWindowText = '\0';
    }
    m_hwndDisplayButton = CreateWindowEx(0, pszClassName, szWindowText, WS_CHILD | m_flags[1] | WS_VISIBLE | BS_NOTIFY,
                                         0, 0, NOTEXT_BTN_WIDTH, NOTEXT_BTN_WIDTH, m_hwnd, (HMENU) IDBTN_DISPLAY,
                                         _Module.GetModuleInstance(), NULL);

    if (!m_hwndDisplayButton)
        return FALSE;
    //
    // <mc>
    // I'm subclassing the static text controls only for the purpose of implementing proper
    // focus and UI activation. I have to do this because I don't have any other way to be notified
    // of loss and acquisition of focus. A much better way to do this would be to implement these
    // controls as window-less.
    // </mc>
    //
    // 4/27/98 - <mc> Changed to also subclass buttons so we can have enter key support.
    //
    m_lpfnlStaticTextControlWndProc = (WNDPROC)GetWindowLongPtr(m_hwndDisplayButton, GWLP_WNDPROC);
    SetWindowLongPtr(m_hwndDisplayButton, GWLP_USERDATA, (LONG_PTR)this);
    SetWindowLongPtr(m_hwndDisplayButton, GWLP_WNDPROC, (LONG_PTR)StaticTextControlSubWndProc);

    if (m_pszBitmap) {
        char szBitmap[MAX_PATH];
        BOOL m_fBuiltInImage = (IsSamePrefix(m_pszBitmap, txtShortcut, -2));
        if (!m_fBuiltInImage) {
            if (!ConvertToCacheFile(m_pszBitmap, szBitmap)) {
                AuthorMsg(IDS_CANT_OPEN, m_pszBitmap);

                // REVIEW: better default?

                if (m_fIcon)
                    goto NoImage;
                m_hImage = LoadBitmap(_Module.GetResourceInstance(), txtShortcut);
                goto GotImage;
            }
        }

        if (m_fBuiltInImage)
            m_hImage = LoadBitmap(_Module.GetResourceInstance(), m_pszBitmap);
        else
            m_hImage = LoadImage(_Module.GetResourceInstance(), szBitmap,
                (m_fIcon ? IMAGE_ICON : IMAGE_BITMAP), 0, 0,
                LR_LOADFROMFILE);
        if (!m_hImage) {
            AuthorMsg(IDS_CANT_OPEN, m_pszBitmap);
            // REVIEW: we should use a default bitmap
            goto NoImage;
        }

GotImage:
        if (m_fIcon) {

            // We use IMAGE_ICON for both cursors and icons. Internally,
            // the only significant difference is that a cursor could be
            // forced to monochrome if we used the IMAGE_CURSOR command.

            if (m_imgType == IMG_BUTTON) {
                // REVIEW: should check actual ICON/CURSOR size
                MoveWindow(m_hwndDisplayButton, 0, 0,
                    32 + CXBUTTONEXTRA,
                    32 + CYBUTTONEXTRA, FALSE);

                SendMessage(m_hwndDisplayButton, BM_SETIMAGE,
                    IMAGE_ICON, (LPARAM) m_hImage);
            }
            else
                SendMessage(m_hwndDisplayButton, STM_SETIMAGE, IMAGE_CURSOR,
                    (LPARAM) m_hImage);
        }
        else {
            if (m_imgType == IMG_BUTTON) {
                BITMAP bmp;
                GetObject(m_hImage, sizeof(bmp), &bmp);
                MoveWindow(m_hwndDisplayButton, 0, 0,
                    bmp.bmWidth + CXBUTTONEXTRA,
                    bmp.bmHeight + CYBUTTONEXTRA, FALSE);

                SendMessage(m_hwndDisplayButton, BM_SETIMAGE,
                    IMAGE_BITMAP, (LPARAM) m_hImage);
            }
        }
    }
    else
        SendMessage(m_hwndDisplayButton, WM_SETFONT,
            m_hfont ? (WPARAM) m_hfont : (WPARAM) _Resource.GetUIFont(), FALSE);

NoImage:
    if ( m_pwszButtonText && *m_pwszButtonText )
    {
        HDC hdc = GetDC(m_hwndDisplayButton);

        if (hdc == NULL)
            return FALSE;

        HFONT hfontOld = (HFONT) SelectObject(hdc,
            m_hfont ? m_hfont : _Resource.GetUIFont());

        SIZE size;
        IntlGetTextExtentPoint32W(hdc, m_pwszButtonText, lstrlenW(m_pwszButtonText), &size);

        SelectObject(hdc, hfontOld);
        ReleaseDC(m_hwndDisplayButton, hdc);

        if (m_imgType == IMG_TEXT)
            MoveWindow(m_hwndDisplayButton, 0, 0, size.cx, size.cy, FALSE);
        else
            MoveWindow(m_hwndDisplayButton, 0, 0, size.cx + CXBUTTONEXTRA,
                size.cy + CYBUTTONEXTRA, FALSE);
    }
    GetWindowRect(m_hwndDisplayButton, &m_rcButton);

    // REVIEW: will this set ALL static windows to use this cursor?

    // change the cursor to the hand icon
    if (m_imgType == IMG_TEXT) {
        SetClassLongPtr(m_hwndDisplayButton, GCLP_HCURSOR,
            (LONG_PTR) LoadCursor(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDCUR_HAND)));
    }

    // set the text color -- default to visited link color if not specified
    if( m_imgType == IMG_TEXT  ) {
      if( m_clrFont == CLR_INVALID )
          m_clrFont = m_clrFontLink;
    }

    // enable/disable dynalinks
    if( (m_action == ACT_KLINK || m_action == ACT_ALINK) && m_flags[2] == 1 ) {
      if( !OnAKLink((m_action == ACT_KLINK),TRUE) ) {
        EnableWindow( m_hwndDisplayButton, FALSE );   // disable the window
        if( m_imgType == IMG_TEXT )
          m_clrFont = m_clrFontDisabled;
      }
    }

    return TRUE;
}

/***************************************************************************

    FUNCTION:   GetTextDimensions

    PURPOSE:

    PARAMETERS:
        hwnd
        psz
        hfont   -- may be NULL

    RETURNS:

    COMMENTS:
        If hfont is NULL, font in the window's DC will be used

    MODIFICATION DATES:
        01-Sep-1997 [ralphw]

***************************************************************************/

static DWORD GetTextDimensions(HWND hwnd, PCSTR psz, HFONT hfont)
{
    HDC hdc = GetDC(hwnd);

    if (hdc == NULL)
        return 0L;

    HFONT hfontOld;
    if (hfont)
        hfontOld = (HFONT) SelectObject(hdc, hfont);
    SIZE size;
    GetTextExtentPoint(hdc, psz, (int)strlen(psz), &size);
    DWORD dwRet = MAKELONG(size.cx, size.cy) +
        MAKELONG(CXBUTTONEXTRA, CYBUTTONEXTRA);
    if (hfont)
        SelectObject(hdc, hfontOld);
    ReleaseDC(hwnd, hdc);
    return dwRet;
}

// undocumented WinHelp API commands

#define HELP_HASH           0x095      // Jump to file and topic based on hash
#define HELP_HASH_POPUP     0x096      // Put up glossary based on hash
#define MAX_WINHELP	247

void STDCALL CHtmlHelpControl::OnClick(void)
{
    switch (m_action) {
        case ACT_ABOUT_BOX:
            {
                CAboutBox aboutbox(this);
                aboutbox.DoModal();
            }
            break;

        case ACT_HHCTRL_VERSION:
            ModalDialog(TRUE);
            MsgBox(IDS_VERSION);
            ModalDialog(FALSE);
            break;

        case ACT_RELATED_TOPICS:
			{
				if (m_pSiteMap->Count() == 0)  // don't allow zero items
					break;

				CExCollection* pExCollection = NULL;
				CStr cstr;

				if ( m_pWebBrowserApp )
				{
					m_pWebBrowserApp->GetLocationURL(&cstr);
					pExCollection = GetCurrentCollection(NULL, (PCSTR)cstr);
				}

			    if (m_pSiteMap->Count() == 1 && !m_flags[0])
		        {
	                SITEMAP_ENTRY *pSiteMapEntry = m_pSiteMap->GetSiteMapEntry(1);
					if(pSiteMapEntry)
				        JumpToUrl(pSiteMapEntry, m_pSiteMap);
			    }
		        else if (m_fPopupMenu && OSLangMatchesChm(pExCollection) == S_OK)
	                OnRelatedMenu();
				else
			    {
		            UINT CodePage = GetCodePage();
	                CWTable tblTitles( CodePage );
					TCHAR szURL[INTERNET_MAX_URL_LENGTH];
				    for (int i = 0; i < m_pSiteMap->Count(); i++)
			        {
		                strcpy(szURL, m_pSiteMap->GetSiteMapEntry(i+1)->pszText );
	                    tblTitles.AddIntAndString(i+1, szURL);
					}
					CTopicList TopicList(this, &tblTitles, m_hfont);
					if (TopicList.DoModal() > 0) {
						int iIndex = tblTitles.GetInt( TopicList.m_pos );
						JumpToUrl(m_pSiteMap->GetSiteMapEntry(iIndex), m_pSiteMap);
					}
				}
			}
            break;

        case ACT_WINHELP:
            if (!m_ptblItems || m_ptblItems->CountStrings() < 1) {
                AuthorMsg(IDS_ACT_WINHELP_NO_HELP);
                break;
            }
            if (m_ptblItems->CountStrings() < 2) {
                AuthorMsg(IDS_ACT_WINHELP_NO_ID);
                break;
            }

            // Note that we don't track this, and therefore don't force
            // the help file closed.
            {
            PSTR pc = m_ptblItems->GetPointer(1);
            PSTR pcMax = NULL;
            if ( strlen( pc ) > MAX_WINHELP )
            {
                pcMax = new char[MAX_WINHELP];
                strncpy( pcMax, pc, MAX_WINHELP-1 );
                pcMax[MAX_WINHELP-1] = 0;
            }
            else
                pcMax = pc;
            ::WinHelp(m_hwnd, pcMax,
                IsDigit(*(m_ptblItems->GetPointer(2))) ?
                    (m_fWinHelpPopup ? HELP_CONTEXTPOPUP : HELP_CONTEXT) :
                    (m_fWinHelpPopup ? HELP_HASH_POPUP : HELP_HASH),
                IsDigit(*(m_ptblItems->GetPointer(2))) ?
                    Atoi(m_ptblItems->GetPointer(2)) :
                    WinHelpHashFromSz(m_ptblItems->GetPointer(2)));
            if ( pcMax != pc )
                delete [] pcMax;
            }
            if ( m_fWinHelpPopup )
               g_HackForBug_HtmlHelpDB_1884 = 1;
            break;

        case ACT_SHORTCUT:
            // don't allow if running in IE
            if( !GetCurrentCollection(NULL, (PCSTR)NULL) ) {
              HWND hWndParent;
              if (!IsValidWindow(m_hwnd))  // in case we are windowless
                  hWndParent = FindTopLevelWindow(GetActiveWindow());
              else
                 hWndParent = FindTopLevelWindow(GetParent(m_hwnd));
              char szMsg[1024];
              strcpy( szMsg, GetStringResource( IDS_REQUIRES_HTMLHELP ) );
              MessageBox( hWndParent, szMsg, _Resource.MsgBoxTitle(),
                  MB_OK | MB_ICONWARNING | MB_SETFOREGROUND );
              break;
            }
            if (m_ptblItems && m_ptblItems->CountStrings()) {
                ShortCut(this, m_ptblItems->GetPointer(1),
                    (m_ptblItems->CountStrings() > 1 ?
                    m_ptblItems->GetPointer(2) : ""),
                    m_hwndParent);
            }
            else
                AuthorMsg(IDS_SHORTCUT_ARGULESS);
            break;

        case ACT_HHWIN_PRINT:
        case ACT_CLOSE:
        case ACT_MAXIMIZE:
        case ACT_MINIMIZE:
            {
                HWND hwndParent;
                if (!IsValidWindow(m_hwnd))  // in case we are windowless
                    hwndParent = FindTopLevelWindow(GetActiveWindow());
                else
                    hwndParent = FindTopLevelWindow(GetParent(m_hwnd));
                switch (m_action) {
                    case ACT_CLOSE:
                        PostMessage(hwndParent, WM_CLOSE, 0, 0);
                        return;

                    case ACT_MINIMIZE:
                        ShowWindow(hwndParent, SW_MINIMIZE);
                        return;

                    case ACT_MAXIMIZE:
                        ShowWindow(hwndParent,
                            IsZoomed(hwndParent) ? SW_RESTORE : SW_SHOWMAXIMIZED);
                        return;

                    case ACT_HHWIN_PRINT:
                        {
                            char szClass[256];
                            GetClassName(hwndParent, szClass, sizeof(szClass));
                            if (IsSamePrefix(szClass, txtHtmlHelpWindowClass, -2)) {
                                PostMessage(hwndParent, WM_COMMAND, IDTB_PRINT, 0);
                            }
                        }
                        break;
                }
            }
            break;

        case ACT_TCARD:
            {
                if (IsEmptyString(m_pszActionData))
                    break; // REVIEW: nag the help author
                WPARAM wParam = Atoi(m_pszActionData);
                LPARAM lParam = 0;
                PCSTR psz = StrChr(m_pszActionData, ',');
                if (psz) {
                    psz = FirstNonSpace(psz + 1);
                    if (IsDigit(*psz))
                        lParam = Atoi(psz);
                    else
                        lParam = (LPARAM) psz;
                }
                HWND hwndParent;
                if (!IsValidWindow(m_hwnd))  // in case we are windowless
                    hwndParent = FindTopLevelWindow(GetActiveWindow());
                else
                    hwndParent = FindTopLevelWindow(GetParent(m_hwnd));
                if (hwndParent)
                    SendMessage(hwndParent, WM_TCARD, wParam, lParam);
            }
            break;

        case ACT_KLINK:
            OnAKLink(TRUE);
            break;

        case ACT_ALINK:
            OnAKLink(FALSE);
            break;

        case ACT_SAMPLE:
            if(!OnCopySample())
                MsgBox(IDS_SAMPLE_ERROR);
            break;

        default:
            // REVIEW: nag the help author
            break;
    }
}

/***************************************************************************

    FUNCTION:   OSLangMatchesChm()

    PURPOSE:    Checks lang of os verses the lang of this title
    
	PARAMETERS:
    
    RETURNS:    S_OK, S_FALSE

    MODIFICATION DATES:
        11-Nov-1998

***************************************************************************/
HRESULT OSLangMatchesChm(CExCollection *pCollection)
{
	if (pCollection == NULL)
    {
		return S_OK;
	}

	CTitleInformation *pInfo = pCollection->GetMasterTitle()->GetInfo();
	LANGID MasterLangId;

	if (pInfo)
		MasterLangId = LANGIDFROMLCID(pInfo->GetLanguage());
	else
		return S_FALSE;

	CLanguage cLang;
	if (cLang.GetUiLanguage() == MasterLangId)
		return S_OK;

	return S_FALSE;
}
 
/***************************************************************************

    FUNCTION:   HashFromSz

    PURPOSE:    Convert a string into a WinHelp hash number

    PARAMETERS:
        pszKey  -- string to convert

    RETURNS:    WinHelp-compatible hash number

    COMMENTS:
        This is the same algorithm that WinHelp and Help Workshop uses. The
        result can be used to jump to a topic in a help file.

    MODIFICATION DATES:
        14-Jun-1997 [ralphw]

***************************************************************************/

static const HASH MAX_CHARS = 43L;

extern "C" HASH WinHelpHashFromSz(PCSTR pszKey)
{
    HASH  hash = 0;

    int cch = (int)strlen(pszKey);

    // REVIEW: 14-Oct-1993 [ralphw] -- Note lack of check for a hash collision.

    for (int ich = 0; ich < cch; ++ich) {
        if (pszKey[ich] == '!')
            hash = (hash * MAX_CHARS) + 11;
        else if (pszKey[ich] == '.')
            hash = (hash * MAX_CHARS) + 12;
        else if (pszKey[ich] == '_')
            hash = (hash * MAX_CHARS) + 13;
        else if (pszKey[ich] == '0')
            hash = (hash * MAX_CHARS) + 10;

        else if (pszKey[ich] <= 'Z')
            hash = (hash * MAX_CHARS) + (pszKey[ich] - '0');
        else
            hash = (hash * MAX_CHARS) + (pszKey[ich] - '0' - ('a' - 'A'));
    }

    /*
     * Since the value 0 is reserved as a nil value, if any topic id
     * actually hashes to this value, we just move it.
     */

    return (hash == 0 ? 0 + 1 : hash);
}

VOID (WINAPI* pSHHelpShortcuts_RunDLL)(HWND hwndStub, HINSTANCE hAppInstance, LPCSTR lpszCmdLine, int nCmdShow);
static const char txtShellShortCut[] = "shell32.dll,SHHelpShortcuts_RunDLL";
static const char txtShell32Dll[] = "shell32.dll";

BOOL ShortCut(CHtmlHelpControl* phhctrl, LPCSTR pszString1, LPCSTR pszString2,
    HWND hwndMsgOwner)
{
    HWND hwndApp;
    HINSTANCE hinstRet;
    CHourGlass hourglass;

    // Make a copy so we can modify it

    if (IsEmptyString(pszString1))
        return FALSE;

    CStr csz(pszString1);
    PSTR pszComma = StrChr(csz.psz, ',');
    if (!pszComma) {
        AuthorMsg(IDS_INVALID_SHORTCUT_ITEM1, pszString1, hwndMsgOwner, phhctrl);
        return FALSE;
    }
    *pszComma = '\0';
    RemoveTrailingSpaces(csz.psz);
    PCSTR pszClass = csz.psz;
    PSTR pszApplication = FirstNonSpace(pszComma + 1);
    pszComma = StrChr(pszApplication, ',');
    if (pszComma)
        *pszComma = '\0';
    RemoveTrailingSpaces(pszApplication);
    PSTR pszParams = "";
    if (pszComma) {
        pszParams = FirstNonSpace(pszComma + 1);
        RemoveTrailingSpaces(pszParams);
    }

    PSTR pszUrl;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    if (!IsEmptyString(pszString2)) {
        CStr cszArg;
        pszUrl = cszArg.GetArg(pszString2, TRUE);
        msg = Atoi(cszArg.psz);
        pszUrl = cszArg.GetArg(pszUrl, TRUE);
        wParam = Atoi(cszArg.psz);
        pszUrl = cszArg.GetArg(pszUrl, TRUE);
        lParam = Atoi(cszArg.psz);
        pszUrl = FirstNonSpace(pszUrl);
    }
    else {
        pszUrl = (PSTR) txtZeroLength;
        msg = 0;
    }

    CStr strUrl;

    ASSERT(phhctrl->m_pWebBrowserApp != NULL);
    phhctrl->m_pWebBrowserApp->GetLocationURL(&strUrl);

    // check for NULL pointer
    //
    if(strUrl.IsEmpty())
        goto Fail;

    // Execute the shortcut only if we're in a local CHM file.
	//
    if(strstr(strUrl, "\\\\") || strstr(strUrl, "//"))
        goto Fail;

    if (IsEmptyString(pszClass) || !(hwndApp = FindWindow(pszClass, NULL))) {

        // 27-Sep-1997  [ralphw] We special-case shell32.dll,SHHelpShortcuts_RunDLL"
        // in order to run the shortcut without having to load rundll32.

        if (IsSamePrefix(pszParams, txtShellShortCut)) {
            if (!pSHHelpShortcuts_RunDLL) {
                HINSTANCE hmod = LoadLibrary(txtShell32Dll);
                if (hmod) {
                    (FARPROC&) pSHHelpShortcuts_RunDLL = GetProcAddress(hmod,
                        "SHHelpShortcuts_RunDLL");
                }
            }
            if (pSHHelpShortcuts_RunDLL) {
                pSHHelpShortcuts_RunDLL(NULL, _Module.GetModuleInstance(),
                    FirstNonSpace(pszParams + sizeof(txtShellShortCut)),
                    SW_SHOW);
                return TRUE;
            }
        }
        hinstRet = ShellExecute(hwndMsgOwner,
            ((strstr(pszApplication, ".cpl") || strstr(pszApplication, ".CPL")) ? txtCplOpen : txtOpen),
            pszApplication, pszParams, "", SW_SHOW);
        if ( hinstRet != (HANDLE)-1 &&  hinstRet <= (HANDLE)32) {
            AuthorMsg(IDS_CANNOT_RUN, pszApplication, hwndMsgOwner, phhctrl);
Fail:
            if (phhctrl->m_pszWindow) {
                if (IsCompiledHtmlFile(phhctrl->m_pszWindow, NULL))
                    OnDisplayTopic(hwndMsgOwner, phhctrl->m_pszWindow, 0);
                else {
                    CWStr cwJump(phhctrl->m_pszWindow);
                    HlinkSimpleNavigateToString(cwJump, NULL,
                        NULL, phhctrl->GetIUnknown(), NULL, NULL, 0, NULL);
                }
            }
            return FALSE;
        }
    }
    else {
        if (IsIconic(hwndApp))
            ShowWindow(hwndApp, SW_RESTORE); // Must restore minimized app
        SetForegroundWindow(hwndApp);
    }

    if (msg > 0) {
        int i;

        if (!hwndApp) {

            // Wait for up to 7 seconds for the process to initialize

            for (i = 0; i < 70; i++) {
                if ((hwndApp = FindWindow(pszClass, NULL)))
                    break;
                Sleep(100);
            }
        }
        if (!hwndApp) {

            // Probably means the window class has changed.

            AuthorMsg(IDS_CLASS_NOT_FOUND, pszClass, hwndMsgOwner, phhctrl);

            if (phhctrl->m_pszWindow) {
                if (IsCompiledHtmlFile(phhctrl->m_pszWindow, NULL))
                    OnDisplayTopic(hwndMsgOwner, phhctrl->m_pszWindow, 0);
                else {
                    CWStr cwJump(phhctrl->m_pszWindow);
                    HlinkSimpleNavigateToString(cwJump, NULL,
                        NULL, phhctrl->GetIUnknown(), NULL, NULL, 0, NULL);
                }
            }

            return FALSE;
        }
        SetForegroundWindow(hwndApp);

        if (msg)
            PostMessage(hwndApp, msg, wParam, lParam);
    }
    return TRUE;
}



BOOL CAboutBox::OnBeginOrEnd(void)
{
    if (m_fInitializing) {

        if (m_phhCtrl && m_phhCtrl->m_ptblItems && m_phhCtrl->m_ptblItems->CountStrings())
            SetWindowText(m_phhCtrl->m_ptblItems->GetPointer(1));

        for (int id = IDC_LINE1; id <= IDC_LINE3; id++) {

            // -2 because CTable is 1-based, and we skip over the title

         if (m_phhCtrl->m_ptblItems == NULL)
            break;

            if (id - IDC_LINE1 > m_phhCtrl->m_ptblItems->CountStrings() - 2)
                break;

             SetWindowText(id,
                m_phhCtrl->m_ptblItems->GetPointer((id - IDC_LINE1) + 2));
        }

        // Hide any unused controls

        while (id <= IDC_LINE3)
            HideWindow(id++);
    }
    return TRUE;
}

void CHtmlHelpControl::OnDrawStaticText(DRAWITEMSTRUCT* pdis)
{
    if (!m_pwszButtonText || !*m_pwszButtonText )
        return;

    // REVIEW: since we are the only ones drawing into this DC, do we really
    // need to restore the previous background mode and foreground text color?

    int iBack = SetBkMode(pdis->hDC, TRANSPARENT);
    COLORREF clrLast = CLR_INVALID;
    if (m_clrFont != CLR_INVALID)
        clrLast = SetTextColor(pdis->hDC, m_clrFont);
    RECT rc;

    GetClientRect(pdis->hwndItem, &rc);
    IntlExtTextOutW(pdis->hDC, rc.left, rc.top, ETO_RTLREADING, &rc, m_pwszButtonText, lstrlenW(m_pwszButtonText), NULL);

//    DrawTextEx(pdis->hDC, (PSTR) m_pszButtonText, -1, &rc, DT_BOTTOM | DT_LEFT | DT_NOCLIP | DT_SINGLELINE | DT_NOPREFIX | DT_RTLREADING, NULL);

    if ( pdis->hwndItem == ::GetFocus() )
       ::DrawFocusRect(pdis->hDC, &rc);
    SetBkMode(pdis->hDC, iBack);
    if (clrLast != CLR_INVALID)
        SetTextColor(pdis->hDC, clrLast);
}

void CHtmlHelpControl::OnRelatedMenu()
{
    POINT pt;

    GetCursorPos(&pt);

#if 1 // reverted bug fix #5516
    HWND hwnd=GetFocus();
    if ( hwnd )
    {
        DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE );
        if ( dwStyle & BS_NOTIFY )
        {

            RECT rc;
            if( GetWindowRect(hwnd, &rc) ) {
           pt.y = rc.top+((rc.bottom-rc.top)/2);
              pt.x = rc.left + ((RECT_HEIGHT(rc)/3)*2); // two-thirds of the height of the button
            }
        }
    }
#endif

    HMENU hMenu = CreatePopupMenu();
    if (!hMenu)
        return; // BUGBUG: nag the help author

   for (int i = 1; i <= m_pSiteMap->Count(); i++) {
        HxAppendMenu(hMenu, MF_STRING, i,
            m_pSiteMap->GetSiteMapEntry(i)->pszText);
    }

    int iIndex = TrackPopupMenu(hMenu,
        TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
        pt.x, pt.y, 0, (m_hwnd == NULL ? hwnd : m_hwnd), NULL);

   if (iIndex)
      JumpToUrl(m_pSiteMap->GetSiteMapEntry(iIndex), m_pSiteMap);

    DestroyMenu(hMenu);
}

void CHtmlHelpControl::OnRelatedCommand(int idCommand)
{
   if (idCommand <= IDM_RELATED_TOPIC)
      return;

    if (m_action != ACT_RELATED_TOPICS) {
        if (!m_ptblTitles)
            return;

        char szURL[INTERNET_MAX_URL_LENGTH];

        int iIndex = m_ptblTitles->GetInt(idCommand - IDM_RELATED_TOPIC);
        m_ptblURLs->GetString( szURL, iIndex );

        if (m_pszWindow) {
            CStr csz(">");
            csz += m_pszWindow;
            OnDisplayTopic(m_hwnd, csz, (DWORD_PTR) szURL);
            return;
        }

        CWStr cwJump(szURL);
        CWStr cwFrame(m_pszFrame ? m_pszFrame : txtZeroLength);
        HlinkSimpleNavigateToString(cwJump, NULL,
            cwFrame, GetIUnknown(), NULL, NULL, 0, NULL);

        delete m_ptblTitles;
        m_ptblTitles = NULL;
        delete m_ptblURLs;
        m_ptblURLs = NULL;
        delete m_ptblLocations;
        m_ptblLocations = NULL;
        return;
    }

    if (idCommand >= ID_VIEW_ENTRY) {
        DisplayAuthorInfo(m_pSiteMap,
            m_pSiteMap->GetSiteMapEntry(idCommand - ID_VIEW_ENTRY));
        return;
    }

#ifdef _DEBUG
    int pos = (idCommand - IDM_RELATED_TOPIC);
    SITEMAP_ENTRY* pSiteMapEntry = m_pSiteMap->GetSiteMapEntry(pos);
#endif

    JumpToUrl(m_pSiteMap->GetSiteMapEntry(idCommand - IDM_RELATED_TOPIC),
        m_pSiteMap);
}

void CHtmlHelpControl::OnKeywordSearch(int idCommand)
{
    CSiteMap* pWebMap;

    if (IsEmptyString(m_pszWebMap)) {
        // BUGBUG: nag the author
        return;
    }
    else {  // use brace to enclose CHourGlass

        // REVIEW: should we capture the mouse?

        CHourGlass hourglass;

        TCHAR szPath[MAX_PATH];
        if (!ConvertToCacheFile(m_pszWebMap, szPath)) {
            CStr cszMsg(IDS_CANT_FIND_FILE, m_pszWebMap);
            MsgBox(cszMsg);
            return;
        }

        if (m_pindex && isSameString(szPath, m_pindex->GetSiteMapFile()))
            pWebMap = m_pindex;
        else {
            UINT CodePage = 0;
            if( m_pindex && m_pindex->m_phh && m_pindex->m_phh->m_phmData ) {
              CodePage = m_pindex->m_phh->m_phmData->GetInfo()->GetCodePage();
            }
            if (!m_pSiteMap->ReadFromFile(szPath, TRUE, this, CodePage))
                return; // we assume author has already been notified
            pWebMap = m_pSiteMap;
        }
    }

    int end = m_ptblItems->CountStrings();
    int endWebMap = pWebMap->CountStrings();
    UINT CodePage = m_pSiteMap->GetCodePage();
    CWTable tblTitles( CodePage );
    for (int pos = 1; pos <= end; pos++) {
        PCSTR pszKeyword = m_ptblItems->GetPointer(pos);
        for (int posSite = 1; posSite <= endWebMap; posSite++) {
            SITEMAP_ENTRY* pWebMapEntry = pWebMap->GetSiteMapEntry(posSite);
            if (lstrcmpi(pszKeyword, pWebMapEntry->GetKeyword()) == 0) {
                SITE_ENTRY_URL* pUrl = (SITE_ENTRY_URL*) pWebMapEntry->pUrls;
                for (int url = 0; url < pWebMapEntry->cUrls; url++) {
                    tblTitles.AddString(posSite, pWebMapEntry->GetTitle(pUrl));
                    pUrl = pWebMap->NextUrlEntry(pUrl);
                }
            }
        }
    }

    // we can sort the title table since it contains the index value
    // of the associated URL so just make sure to always fetch the
    // URL index from the selected title string and use that to get the URL
    if( /*bAlphaSortHits*/ TRUE ) {
      tblTitles.SetSorting(GetSystemDefaultLCID());
      tblTitles.SortTable(sizeof(HASH));
    }

    CTopicList TopicList(this, &tblTitles, m_hfont);
    if (TopicList.DoModal())
    {
        PCSTR pszTitle = tblTitles.GetHashStringPointer(TopicList.m_pos);
        SITEMAP_ENTRY* pWebMapEntry = pWebMap->GetSiteMapEntry(
            tblTitles.GetInt(TopicList.m_pos));

        // Now find the actual URL that matches the title

        // BUGBUG: fails with duplicate titles

        for (int url = 0; url < pWebMapEntry->cUrls; url++) {
            if (strcmp(pszTitle, pWebMap->GetUrlTitle(pWebMapEntry, url)) == 0)
                break;
        }
        ASSERT(url < pWebMapEntry->cUrls);
        JumpToUrl(pWebMapEntry, pWebMap, pWebMap->GetUrlEntry(pWebMapEntry, url));
    }
}

// for bug #3681 -- don't use this new function for any other reason under any circumstances.
HWND OnDisplayTopicWithRMS(HWND hwndCaller, LPCSTR pszFile, DWORD_PTR dwData)
{
  BOOL bCollection = IsCollectionFile(pszFile);
  CExTitle* pTitle = NULL;
  CExCollection* pCollection = NULL;
  BOOL bCompiled;
  if( bCollection )
    bCompiled = IsCompiledURL( (PCSTR) dwData );
  else
    bCompiled = IsCompiledURL( pszFile );

  if( bCompiled ) {
    CExCollection* pCollection = GetCurrentCollection(NULL, pszFile);
    if( pCollection )
      if( (PCSTR) dwData )
        HRESULT hr = pCollection->URL2ExTitle( (PCSTR) dwData, &pTitle );
  }

  if( pCollection && bCompiled && (!pTitle || FAILED( EnsureStorageAvailability( pTitle, HHRMS_TYPE_TITLE, TRUE, TRUE, FALSE )) ) ) {
    g_LastError.Set(HH_E_FILENOTFOUND) ;
    return NULL;
  }

  return OnDisplayTopic(hwndCaller, pszFile, dwData );
}

///////////////////////////////////////////////////////////
//
// OnKeywordSearch - Handles HH_KEYWORD_LOOKUP Command
//
HWND OnKeywordSearch(HWND hwndCaller, PCSTR pszFile, HH_AKLINK* pakLink, BOOL fKLink)
{
    CStr cszKeywords;   // Use so StrToken can modify them. Declared here so JumpNotFound can use.
    CStr cszCompressed;
    BOOL bCollection = IsCollectionFile(pszFile);

    // We need the following in a bunch of locations in the code below. However, I have no
    // idea which of the following functions may cause side affects which affect this line.
    // Therefore, I can't with any assurance improve the performace of this code.
    //      CHHWinType* phh = FindCurProccesWindow(idProcess);

    if (bCollection || IsCompiledHtmlFile(pszFile, &cszCompressed))
    {
        if (bCollection)
            cszCompressed = pszFile;

        CHmData* phmData = FindCurFileData(cszCompressed);

        if (!phmData)
            goto JumpNotFound;

        UINT CodePage = phmData->m_pTitleCollection->GetMasterTitle()->GetInfo()->GetCodePage();

        CTable tblItems;
        CWTable tblTitles( CodePage );
        CWTable tblLocations( CodePage );
        CTable tblURLs;

        if (IsEmptyString(pakLink->pszKeywords))
            goto JumpNotFound;
        if (pakLink->fReserved)
            cszKeywords = (WCHAR*) pakLink->pszKeywords;
        else
            cszKeywords = pakLink->pszKeywords;

        tblItems.AddString( "" ); // set item1 to NULL -- no external titles
        tblItems.AddString( cszKeywords );

        GetWordWheelHits( phmData->m_pTitleCollection, &tblItems,
                          &tblURLs, &tblTitles, &tblLocations,
                          fKLink, FALSE, FALSE );

        if (tblURLs.CountStrings() < 1)
        {
            // No links found.
            goto JumpNotFound ;
        }

        // if only one topic then jump to it
        if( tblURLs.CountStrings() == 1 )
        {
            char szURL[INTERNET_MAX_URL_LENGTH];

            tblURLs.GetString( szURL, 1 );

            //TODO: This code is repeated below. Share.
            if (pakLink->pszWindow)
            {
                strcat(szURL, ">");
                strcat(szURL, (*pakLink->pszWindow == '>' ?
                    pakLink->pszWindow + 1 : pakLink->pszWindow));
            }
            else if (bCollection && phmData->GetDefaultWindow()) // Use the default window for the collection. HH 3428
            {
                strcat(szURL, ">");
                strcat(szURL, (*phmData->GetDefaultWindow() == '>' ?
                    phmData->GetDefaultWindow() + 1 : phmData->GetDefaultWindow()));

            }
            else //REVIEW: Can we find other possible default windows?
            {
                // Pick a random window type. Its unlikely that this is the one you really want, since you get the first one for this process.
                CHHWinType* phh = FindCurWindow();
                if (phh)
                {
                    strcat(szURL, ">");
                    strcat(szURL, phh->pszType);
                }
            }
            if( bCollection )
              return OnDisplayTopicWithRMS(hwndCaller, pszFile, (DWORD_PTR) szURL);
            return OnDisplayTopicWithRMS(hwndCaller, szURL, 0);
        }

        // Determine the dialogs parent.
        HWND hwndDlgParent = hwndCaller ;
        CHHWinType* phh = FindCurWindow();
        if (phh)
        {
            // If there is an existing help window, use it for the dialog parent instead of
            // the hwnd passed from the caller. The reason is that the disambiguator will not be
            // modal with the help window, but with the calling app.
            HWND hwnd = phh->GetHwnd();
            if (hwnd && ::IsValidWindow(hwnd))
            {
                hwndDlgParent = hwnd ;
                if (hwnd != GetForegroundWindow())
                {
                    BOOL b = SetForegroundWindow(hwnd) ;
                    ASSERT(b) ;
                }
            }
        }

        // we can sort the title table since it contains the index value
        // of the associated URL so just make sure to always fetch the
        // URL index from the selected title string and use that to get the URL
        if( /*bAlphaSortHits*/ TRUE ) {
          tblTitles.SetSorting(GetSystemDefaultLCID());
          tblTitles.SortTable(sizeof(HASH));
        }

        // Display a dialog containing the links to the user.
        CTopicList TopicList(hwndDlgParent, &tblTitles, phmData->GetContentFont(), &tblLocations);
        if (TopicList.DoModal())
        {
            char szURL[INTERNET_MAX_URL_LENGTH];
            int iIndex = tblTitles.GetInt(TopicList.m_pos);
            tblURLs.GetString( szURL, iIndex );

            //TODO: This code is repeated above. Share.
            if (pakLink->pszWindow)
            {
                strcat(szURL, ">");
                strcat(szURL, (*pakLink->pszWindow == '>' ?
                    pakLink->pszWindow + 1 : pakLink->pszWindow));
            }
            else if (bCollection && phmData->GetDefaultWindow()) // Use the default window for the collection.  HH 3428
            {
                strcat(szURL, ">");
                strcat(szURL, (*phmData->GetDefaultWindow() == '>' ?
                    phmData->GetDefaultWindow() + 1 : phmData->GetDefaultWindow()));

            }
            else
            {
                // Pick a random window type. Its unlikely that this is the one you really want, since you get the first one for this process.
                CHHWinType* phh = FindCurWindow();
                if (phh)
                {
                    strcat(szURL, ">");
                    strcat(szURL, phh->pszType);
                }
            }
            if( bCollection )
              return OnDisplayTopicWithRMS(hwndCaller, pszFile, (DWORD_PTR) szURL);
            return OnDisplayTopicWithRMS(hwndCaller, szURL, 0);

        }
        else //REVIEW: Can we find other possible default windows?
        {
            // Signal that we succeeded, but didn't do anything.
            g_LastError.Set(S_FALSE) ;

            // User canceled dialog box. Don't go to JumpNotFound.
            return NULL ;
        }
    }

// Error handling.
JumpNotFound:
        if (pakLink->fIndexOnFail)  // Display index if the keyword is not found.
        {
            // We only seed the edit control with the characters to the ';'.
            // The StrToken command happens to repalce the ';' with a \0.
            // So we can use cszKeywords, directly as the first keyword.
            // Also, note that cszKeywords.psz is set to NULL during initialization.
            return doDisplayIndex(hwndCaller, pszFile,  cszKeywords);
        }
        else if (pakLink->pszUrl)   // Display the page pointered to by pszUrl when keyword is not found.
        {
            if (pakLink->pszWindow)
            {
                cszCompressed += ">";
                cszCompressed += (*pakLink->pszWindow == '>' ?
                    pakLink->pszWindow + 1 : pakLink->pszWindow);
            }
            else
            {
                CHHWinType* phh = FindCurWindow();
                if (phh)
                {
                    cszCompressed += ">";
                    cszCompressed += phh->pszType;
                }
            }
            return OnDisplayTopicWithRMS(hwndCaller, cszCompressed, (DWORD_PTR) pakLink->pszUrl);
        }
        else if (pakLink->pszMsgText) // Display a message box with the callers messages.
        {
            MessageBox(hwndCaller, pakLink->pszMsgText,
                IsEmptyString(pakLink->pszMsgTitle) ? "" : pakLink->pszMsgTitle,
                MB_OK | MB_ICONEXCLAMATION);
        }

        return NULL;
}

///////////////////////////////////////////////////////////
//
// OnSample - Handles HH_COPY_SAMPLE Command
//
BOOL CHtmlHelpControl::OnCopySample()
{
    if (!m_ptblItems)
        return FALSE;

    // Get the SFL name from "item2"
    //
    CStr cszSFLFileName;
    if (!IsEmptyString(m_ptblItems->GetPointer(2)))
        cszSFLFileName = m_ptblItems->GetPointer(2);
    else
        return FALSE;

    // Compute the SFL base name
    //
    char szSFLBaseName[_MAX_FNAME];
    strncpy(szSFLBaseName,cszSFLFileName, _MAX_FNAME-1);
   szSFLBaseName[_MAX_FNAME-1] = NULL;

    cszSFLFileName = szSFLBaseName;
    cszSFLFileName+=".SFL";

    // Get the dialog title from "item1"
    //
    CStr cszDialogTitle;
    if (!IsEmptyString(m_ptblItems->GetPointer(1)))
        cszDialogTitle = m_ptblItems->GetPointer(1);
    else
        cszDialogTitle = "Sample Application";

    // Get the current URL
    //
    CStr cszCurUrl;
    if (m_pWebBrowserApp != NULL)
        m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
    else
        return FALSE;

    char szSflRelativeUrl[INTERNET_MAX_URL_LENGTH];
    char szSflUrl[INTERNET_MAX_URL_LENGTH];
    DWORD dwLength = sizeof(szSflUrl);

    // Create URL to SFL file
    //
    wsprintf(szSflRelativeUrl,"/samples/%s/%s",szSFLBaseName,cszSFLFileName);

    strcpy(szSflUrl,cszCurUrl);

    char *pszTemp = szSflUrl;

    // Locate the :: in the URL
    //
    while(*pszTemp && !(*pszTemp == ':' && *(pszTemp+1) == ':'))
        ++pszTemp;

    // return if no :: was found
    //
    if(!*pszTemp)
        return FALSE;

    pszTemp+=2;

    // place a null after ::
    //
    *pszTemp = 0;

    strcat(szSflUrl,szSflRelativeUrl);

    // download the SFL file
    //
    char szPath[MAX_PATH],szSFLFilePath[MAX_PATH];

    GetTempPath(sizeof(szPath),szPath);
    GetTempFileName(szPath,"SFL",0, szSFLFilePath);

    HRESULT hr = URLDownloadToFile(NULL, szSflUrl, szSFLFilePath, 0, NULL);

   if (FAILED(hr))
      DeleteFile(szSFLFilePath);

    if(!FAILED(hr))
    {
        // Process compressed sample
        //
        // Create URL to SFL file
        //

        // Null after the :: again in szSflUrl
        //
        *pszTemp = 0;

        char szSampleBaseUrl[INTERNET_MAX_URL_LENGTH];
        dwLength = sizeof(szSampleBaseUrl);
        wsprintf(szSampleBaseUrl,"%s/samples/%s/",szSflUrl,szSFLBaseName);

        // call sample UI
        //
        return ProcessSample(szSFLFilePath, szSampleBaseUrl, cszDialogTitle, this, TRUE);

        // delete the copy of the SFL file

        DeleteFile(szSFLFilePath);
    }
    else
    {
        CStr cstr;
        PSTR psz = NULL;
        if ( m_pWebBrowserApp )
        {
           m_pWebBrowserApp->GetLocationURL(&cstr);
           psz = (PSTR)cstr;
        }
        // Process uncompressed sample

        CExCollection *pCurCollection = GetCurrentCollection(NULL, (LPCSTR)psz);

        if(!pCurCollection)
            return FALSE;

        CExTitle *pExTitle = NULL;

        // Get the CExTitle object associated to this URL
        //
        pCurCollection->URL2ExTitle(cszCurUrl, &pExTitle);

        if(!pExTitle)
            return FALSE;

        // Make sure the title is open
        // BUGBUG: what do we do if this fails?
        pExTitle->Init();

        TCHAR *pszSampleLocation = NULL;

        // Make sure the CTitle object is initialized
        //
        if(pExTitle->m_pTitle)
        {
            // Get the sample location from the CTitle object
            //
            if (pExTitle->GetUsedLocation())
                pszSampleLocation = pExTitle->GetUsedLocation()->SampleLocation;
        }

        if(!pszSampleLocation)
        {
            // get sample location from CCollection if get from CTitle failed
            pszSampleLocation = pCurCollection->m_Collection.GetSampleLocation();
        }

        // Make sure we got a sample location
        //
        if(!pszSampleLocation)
            return FALSE;

        CLocation *pLocation = pCurCollection->m_Collection.FindLocation(pszSampleLocation);

        if(!pLocation)
            return FALSE;

        char szSampleBasePath[MAX_PATH],szSFLFilePath[MAX_PATH];

        // construct full path to uncompressed sample directory
        //
        strcpy(szSampleBasePath,pLocation->GetPath());
//      CatPath(szSampleBasePath,szSFLBaseName);
//      strcat(szSampleBasePath,"\\");

        // construct full path to SFL
        //
        strcpy(szSFLFilePath,szSampleBasePath);
        CatPath(szSFLFilePath,"\\SFL\\");
        CatPath(szSFLFilePath,cszSFLFileName);

        // make sure the sample (CD) is available
        if( pExTitle ) {
          pExTitle->SetCurrentAttachmentName( szSFLFilePath );
          if( FAILED(hr = EnsureStorageAvailability( pExTitle, HHRMS_TYPE_ATTACHMENT ) ) ) {
            if( hr == HHRMS_E_SKIP ||  hr == HHRMS_E_SKIP_ALWAYS )
              return TRUE;
            return FALSE;
          }
        }

        // if the user updated the CD location then we need to update the SFL file location
        // before we process the sample
        if( hr == HHRMS_S_LOCATION_UPDATE ) {
          strcpy(szSampleBasePath,pLocation->GetPath());
          strcpy(szSFLFilePath,szSampleBasePath);
          CatPath(szSFLFilePath,"\\SFL\\");
          CatPath(szSFLFilePath,cszSFLFileName);
        }

        // call sample UI
        //
        return ProcessSample(szSFLFilePath, szSampleBasePath, cszDialogTitle, this, FALSE);

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\objext.h ===
//=------------------------------------------------------------------------=
// ObjExt.h
//=------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header file for Object Extensions interfaces
//  

#ifndef _OBJEXT_H
#define _OBJEXT_H

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

///////////////////////////////////////////////////////////////////////////
//
// forward declares
//
///////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
interface IFilterMembers;
#else  // __cplusplus
typedef interface IFilterMembers IFilterMembers;
#endif  // __cplusplus

///////////////////////////////////////////////////////////////////////////
//
// Object Extension Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  IServiceProvider Interface
//    This interface is implemented by an object that wish to provide "services"
//
//-------------------------------------------------------------------------
#ifndef __IServiceProvider_INTERFACE_DEFINED
#define __IServiceProvider_INTERFACE_DEFINED

// { 6d5140c1-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IServiceProvider, 0x6d5140c1, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IServiceProvider
DECLARE_INTERFACE_(IServiceProvider, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IServiceProvider methods ***
    STDMETHOD(QueryService)(THIS_
                /* [in]  */ REFGUID rsid,
                /* [in]  */ REFIID iid,
                /* [out] */ void ** ppvObj) PURE;
};

#endif // __IServiceProvider_INTERFACE_DEFINED

//-------------------------------------------------------------------------
//  IClassDesigner Interface
//    This interface is implemented by a class object that can be customized
//
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IClassDesigner, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

typedef DWORD ACTFLAG;
#define ACT_DEFAULT 0x00000000
#define ACT_SHOW    0x00000001

#undef  INTERFACE
#define INTERFACE  IClassDesigner
DECLARE_INTERFACE_(IClassDesigner, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IClassDesigner methods ***
    STDMETHOD(SetSite)(THIS_
               /* [in]  */ IServiceProvider * pSP) PURE;
    STDMETHOD(GetSite)(THIS_
               /* [out] */ IServiceProvider** ppSP) PURE;
    STDMETHOD(GetCompiler)(THIS_
               /* [in]  */ REFIID iid,
               /* [out] */ void **ppvObj) PURE;
    STDMETHOD(ActivateObject)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(IsObjectShowable)(THIS) PURE;
    STDMETHOD(GetExtensibilityObject)(THIS_ 
                      /* [out] */ IDispatch ** ppDisp) PURE;
};

//-------------------------------------------------------------------------
//  IProvideUnmergedClassInfo Interface
//    This interface is implemented by an object that is composed of two
//    objects. This interface is used to get the typeinfo of the two objects.
//
//-------------------------------------------------------------------------
// { 6d5140da-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IProvideUnmergedClassInfo, 0x6d5140da, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IProvideUnmergedClassInfo
DECLARE_INTERFACE_(IProvideUnmergedClassInfo, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProvideUnmergedClassInfo methods ***
    STDMETHOD(GetClassInfos)(THIS_
                 /* [out] */ ITypeInfo **pptinfoBase, 
                 /* [out] */ ITypeInfo **pptinfoExtender,
		 /* [out] */ DWORD *pdwCookie) PURE;
};

//UNDONE UNDONE: rip this
// { 6d5140dd-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IProvideUnmergedClassInfoOLD, 0x6d5140dd, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IProvideUnmergedClassInfoOLD
DECLARE_INTERFACE_(IProvideUnmergedClassInfoOLD, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProvideUnmergedClassInfo methods ***
    STDMETHOD(GetClassInfos)(THIS_
                 /* [out] */ ITypeInfo **pptinfoBase, 
                 /* [out] */ ITypeInfo **pptinfoExtender) PURE;
};


//-------------------------------------------------------------------------
//  IUnmergedClassFactory Interface
//    This interface is implemented by an object that is composed of two
//    objects. This interface is used to create instances of the two objects.
//
//-------------------------------------------------------------------------
// { 6d5140d5-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IUnmergedClassFactory, 0x6d5140d5, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IUnmergedClassFactory
DECLARE_INTERFACE_(IUnmergedClassFactory, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IUnmergedClassFactory methods ***
    STDMETHOD(CreateInstance)(THIS_
                  /* [in]  */ IUnknown *punkOuter,
                  /* [out] */ IUnknown **ppunkBase, 
                  /* [out] */ IUnknown **ppunkExtender) PURE;
};

///////////////////////////////////////////////////////////////////////////
//
// Standard Services and Interfaces
//
///////////////////////////////////////////////////////////////////////////

//-------------------------------------------------------------------------
//  SLicensedClassManager
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILicensedClassManager
//-------------------------------------------------------------------------
// { 6d5140d0-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IRequireClasses, 0x6d5140d0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IRequireClasses
DECLARE_INTERFACE_(IRequireClasses, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IRequireClasses methods ***
    STDMETHOD(CountRequiredClasses)(THIS_
                    /* [out] */ ULONG * pcClasses ) PURE;
    STDMETHOD(GetRequiredClasses)(THIS_
                  /* [in]  */ ULONG index,
                  /* [out] */ CLSID * pclsid ) PURE;
};

// { 6d5140d4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILicensedClassManager, 0x6d5140d4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLicensedClassManager  IID_ILicensedClassManager

#undef  INTERFACE
#define INTERFACE  ILicensedClassManager
DECLARE_INTERFACE_(ILicensedClassManager, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILicensedClassManager methods ***
    STDMETHOD(OnChangeInRequiredClasses)(THIS_
                     /* [in] */ IRequireClasses *pRequireClasses) PURE;
};

//-------------------------------------------------------------------------
//  IFilterMembers
//    This interface is used during processing of typeinfos
//-------------------------------------------------------------------------
// MX ON
#if 0
// MX OFF
// {49F21D20-1870-11cf-80E8-00AA004BA1C8}
DEFINE_GUID(IID_IFilterMembers,0x49f21d20L, 0x1870, 0x11cf, 0x80, 0xe8, 0x00, 0xaa, 0x00, 0x4b, 0xa1, 0xc8);

// used in IFilterMembers indicating the passed in ptinfo is a source or not
#define FILTERMEMBERS_FSOURCE       0x0001

// used in IFilterMembers indicating the passed in ptinfo is an extender or not
#define FILTERMEMBERS_FEXTENDER     0x0002

#undef  INTERFACE
#define INTERFACE IFilterMembers
DECLARE_INTERFACE(IFilterMembers)
{
    BEGIN_INTERFACE
    // IUnknown methods
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IVbaProvideStorage methods
    STDMETHOD(FilterVarDesc)(THIS_ DWORD dwFlags,
                             ITypeInfo *ptinfo,
                             UINT index,
                             VARDESC *pvardesc,
                             DWORD dwReserved) PURE;
    STDMETHOD(FilterFuncDesc)(THIS_ DWORD dwFlags,
                             ITypeInfo *ptinfo,
                             UINT index,
                             FUNCDESC *pfuncdesc,
                             DWORD dwReserved) PURE;
    STDMETHOD(BeginMerge)(THIS_ DWORD dwFlags,
                          ITypeInfo *ptinfo) PURE;
    STDMETHOD(EndMerge)(THIS) PURE;
    STDMETHOD(UpdateMergedCoClass)(THIS_ ICreateTypeInfo *pictinfo) PURE;
};
// MX ON
#endif
// MX OFF

//-------------------------------------------------------------------------
//  SCreateExtendedTypeLib Service
//    This service is used by components to create a typelib
//    describing controls merged with their extender
//
//  interfaces implemented:
//    ICreateExtendedTypeLib
//-------------------------------------------------------------------------
// { 6d5140d6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IExtendedTypeLib, 0x6d5140d6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SExtendedTypeLib IID_IExtendedTypeLib

#undef  INTERFACE
#define INTERFACE  IExtendedTypeLib
DECLARE_INTERFACE_(IExtendedTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IExtendedTypeLib ***
    STDMETHOD(CreateExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ IFilterMembers *pfilter,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;

    STDMETHOD(AddRefExtendedTypeLib)(THIS_
                     /* [in]  */ LPCOLESTR lpstrCtrlLibFileName,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ IFilterMembers *pfilter,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeLib  **pptlib) PURE;
    STDMETHOD(AddRefExtendedTypeLibOfClsid)(THIS_
                     /* [in]  */ REFCLSID rclsidControl,
                     /* [in]  */ LPCOLESTR lpstrLibNamePrepend,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ IFilterMembers *pfilter,
                     /* [in]  */ DWORD     dwFlags,
                     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [out] */ ITypeInfo **pptinfo) PURE;
    STDMETHOD(SetExtenderInfo)(THIS_ 
		     /* [in]  */ LPCOLESTR lpstrDirectoryName,
                     /* [in]  */ ITypeInfo *ptinfoExtender,
                     /* [in]  */ IFilterMembers *pfilter) PURE;
};

//-------------------------------------------------------------------------
//  SCreateExtension Service
//    This service is used by Instance customized objects to 
//    create the VBA extension
//
//  interfaces implemented:
//    ICreateExtension
//-------------------------------------------------------------------------

// { 6d5140d2-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ICreateExtension, 0x6d5140d2, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SCreateExtension IID_ICreateExtension

#undef  INTERFACE
#define INTERFACE  ICreateExtension
DECLARE_INTERFACE_(ICreateExtension, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICreateExtension methods ***
    STDMETHOD(CreateExtension)(THIS_
                   /* [in]  */ IUnknown *punkOuter,
                   /* [in]  */ IUnknown *punkBase,
                   /* [in]  */ IUnknown *punkExtender,
                   /* [out] */ IUnknown **ppunkExtension) PURE;
};

//-------------------------------------------------------------------------
//  SCodeNavigate Service.
//    This service let's an extended object show the code module
//    behind it.
//
//  interfaces implemented:
//    ICodeNavigate
//-------------------------------------------------------------------------

// { 6d5140c4-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ICodeNavigate, 0x6d5140c4, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SCodeNavigate IID_ICodeNavigate

#undef  INTERFACE
#define INTERFACE  ICodeNavigate
DECLARE_INTERFACE_(ICodeNavigate, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICodeNavigate methods ***
    STDMETHOD(DisplayDefaultEventHandler)(THIS_ /* [in] */ LPCOLESTR lpstrObjectName) PURE;
};

//-------------------------------------------------------------------------
//  STrackSelection Service
//    This service is used by the VBA host to help VBA track the
//    currently selected object in the host
//
//  interfaces implemented:
//    ITrackSelection
//-------------------------------------------------------------------------
#define GETOBJS_ALL         1
#define GETOBJS_SELECTED    2

#define SELOBJS_ACTIVATE_WINDOW   1

// { 6d5140c6-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ISelectionContainer, 0x6d5140c6, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  ISelectionContainer
DECLARE_INTERFACE_(ISelectionContainer, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ISelectionContainer methods ***
    STDMETHOD(CountObjects)(THIS_
                /* [in]  */ DWORD dwFlags, 
                /* [out] */ ULONG * pc) PURE;
    STDMETHOD(GetObjects)(THIS_
              /* [in]  */ DWORD dwFlags, 
              /* [in]  */ ULONG cObjects,
              /* [out] */ IUnknown **apUnkObjects) PURE;
    STDMETHOD(SelectObjects)(THIS_
              /* [in] */ ULONG cSelect,
              /* [in] */ IUnknown **apUnkSelect,
              /* [in] */ DWORD dwFlags) PURE;
};

// { 6d5140c5-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ITrackSelection, 0x6d5140c5, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_STrackSelection IID_ITrackSelection

#undef  INTERFACE
#define INTERFACE  ITrackSelection
DECLARE_INTERFACE_(ITrackSelection, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ITrackSelection methods ***
    STDMETHOD(OnSelectChange)(THIS_ 
                  /* [in] */ ISelectionContainer * pSC) PURE;
};

//-------------------------------------------------------------------------
//  SLocalRegistry Service
//    VBA provides this service to it's components and hosts to optimize
//    registry access and to insulate them from licensing concerns
//
//  interfaces implemented:
//    ILocalRegistry
//-------------------------------------------------------------------------

// { 6d5140d3-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_ILocalRegistry, 0x6d5140d3, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SLocalRegistry IID_ILocalRegistry

#undef  INTERFACE
#define INTERFACE  ILocalRegistry
DECLARE_INTERFACE_(ILocalRegistry, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ILocalRegistry methods ***
    STDMETHOD(CreateInstance)(THIS_
                  /* [in]  */ CLSID      clsid,     
                  /* [in]  */ IUnknown * punkOuter,
                  /* [in]  */ REFIID     riid,
                  /* [in]  */ DWORD      dwFlags,
                  /* [out] */ void **    ppvObj ) PURE;
    STDMETHOD(GetTypeLibOfClsid)(THIS_
                 /* [in]  */ CLSID       clsid,
                 /* [out] */ ITypeLib ** ptlib ) PURE;
    STDMETHOD(GetClassObjectOfClsid)(THIS_
                     /* [in]  */ REFCLSID clsid,
                                 /* [in]  */ DWORD    dwClsCtx,
                     /* [in]  */ LPVOID   lpReserved,
                     /* [in]  */ REFIID   riid,
                     /* [out] */ void **  ppcClassObject ) PURE;
};

//-------------------------------------------------------------------------
//  IUIElement interface
//    components can implement services to allow external control of pieces 
//    of their UI by implementing this interface
//
//-------------------------------------------------------------------------
// { 759d0500-d979-11ce-84ec-00aa00614f3e }
DEFINE_GUID(IID_IUIElement, 0x759d0500, 0xd979, 0x11ce, 0x84, 0xec, 0x00, 0xaa, 0x00, 0x61, 0x4f, 0x3e);

#undef  INTERFACE
#define INTERFACE  IUIElement
DECLARE_INTERFACE_(IUIElement, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ****
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IUIElement methods ****
    STDMETHOD(Show)(THIS) PURE;
    STDMETHOD(Hide)(THIS) PURE;
    STDMETHOD(IsVisible)(THIS) PURE;
};

//-------------------------------------------------------------------------
//  SProfferService Service
//    VBA provides this service to it's components and hosts to allow
//    them to dynamically provide services.
//
//  interfaces implemented:
//    IProfferService
//-------------------------------------------------------------------------

// {CB728B20-F786-11ce-92AD-00AA00A74CD0}
DEFINE_GUID(IID_IProfferService, 0xcb728b20, 0xf786, 0x11ce, 0x92, 0xad, 0x0, 0xaa, 0x0, 0xa7, 0x4c, 0xd0);
#define SID_SProfferService IID_IProfferService

#undef  INTERFACE
#define INTERFACE  IProfferService
DECLARE_INTERFACE_(IProfferService, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferService methods ***
    STDMETHOD(ProfferService)(THIS_ 
                  /* [in]  */ REFGUID rguidService,
                  /* [in]  */ IServiceProvider * psp,
                  /* [out] */ DWORD *pdwCookie) PURE;

    STDMETHOD(RevokeService)(THIS_ /* [in]  */ DWORD dwCookie) PURE;
};

//-------------------------------------------------------------------------
//  SProfferTypelib Service
//    VBA provides this service to it's components and hosts to allow
//    them to add typelibs to the project
//
//  interfaces implemented:
//    IProfferTypelib
//-------------------------------------------------------------------------

// { 718cc500-0a76-11cf-8045-00aa006009fa }
DEFINE_GUID(IID_IProfferTypeLib, 0x718cc500, 0x0A76, 0x11cf, 0x80, 0x45, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);
#define SID_SProfferTypeLib IID_IProfferTypeLib

#define CONTROLTYPELIB	(0x00000001)

#undef  INTERFACE
#define INTERFACE  IProfferTypeLib
DECLARE_INTERFACE_(IProfferTypeLib, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProfferTypelib methods ***
    STDMETHOD(ProfferTypeLib)(THIS_ 
              /* [in]  */ REFGUID guidTypeLib,
              /* [in]  */ UINT    uVerMaj,
              /* [in]  */ UINT    uVerMin,
              /* [in]  */ DWORD   dwFlags) PURE;
};

// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE
//   These interfaces need to be moved to the new olectl.h
//
// UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE UNDONE

// { 6d5140c0-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IGangConnectWithDefault, 0x6d5140c0, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IGangConnectWithDefault
DECLARE_INTERFACE_(IGangConnectWithDefault, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IGangConnectWithDefault ***
    STDMETHOD(AdviseWithDefault)(THIS_
            ULONG   cSinks, 
            DISPID *    adispid,
            IUnknown ** apUnkSink,
            IUnknown ** apUnkDefaultBO) PURE;
};

// { 6d5140d1-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IProvideDynamicClassInfo, 0x6d5140d1, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IProvideDynamicClassInfo
DECLARE_INTERFACE_(IProvideDynamicClassInfo, IProvideClassInfo)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IProvideDynamicClassInfo ***
    STDMETHOD(GetDynamicClassInfo_RIP)(THIS_ ITypeInfo ** ppTI) PURE;
    STDMETHOD(GetDynamicClassInfo)(THIS_ ITypeInfo ** ppTI, DWORD * pdwCookie) PURE;
    STDMETHOD(FreezeShape)(void) PURE;
};



// {4D07FC10-F931-11ce-B001-00AA006884E5}
DEFINE_GUID(IID_ICategorizeProperties, 0x4d07fc10, 0xf931, 0x11ce, 0xb0, 0x1, 0x0, 0xaa, 0x0, 0x68, 0x84, 0xe5);

// NOTE : CATID should no longer be used.  Use PROPCAT instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new typedef.
#ifdef OBJEXT_OLD_CATID
typedef int CATID;
#else
typedef int PROPCAT;
#endif

#undef  INTERFACE
#define INTERFACE  ICategorizeProperties
DECLARE_INTERFACE_(ICategorizeProperties, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** ICategorizeProperties ***
    STDMETHOD(MapPropertyToCategory)(THIS_ 
                                     /* [in]  */ DISPID dispid,
                                     /* [out] */ PROPCAT* ppropcat) PURE;
    STDMETHOD(GetCategoryName)(THIS_
                               /* [in]  */ PROPCAT propcat, 
                               /* [in]  */ LCID lcid,
                               /* [out] */ BSTR* pbstrName) PURE;
};

typedef ICategorizeProperties FAR* LPCATEGORIZEPROPERTIES;

// category ID: negative values are 'standard' categories,  positive are control-specific
// Note! This is a temporary list!
#ifdef OBJEXT_OLD_CATID
// NOTE : The following #defines should no longer be used.  Use PROPCAT_ instead.
// UNDONE,erikc,1/22/96 : remove #ifdef when all components have updated to new #defines.
#define CI_Nil -1
#define CI_Misc -2
#define CI_Font -3
#define CI_Position -4
#define CI_Appearance -5
#define CI_Behavior -6
#define CI_Data -7
#define CI_List -8
#define CI_Text -9
#define CI_Scale -10
#define CI_DDE -11
#else
#define PROPCAT_Nil -1
#define PROPCAT_Misc -2
#define PROPCAT_Font -3
#define PROPCAT_Position -4
#define PROPCAT_Appearance -5
#define PROPCAT_Behavior -6
#define PROPCAT_Data -7
#define PROPCAT_List -8
#define PROPCAT_Text -9
#define PROPCAT_Scale -10
#define PROPCAT_DDE -11
#endif

//
//  Extra interfaces (chrisz)
//

//+-------------------------------------------------------------------------
//
//  Help service. (robbear)
//
//--------------------------------------------------------------------------

#define HELPINFO_WHATS_THIS_MODE_ON     1

// { 6d5140c7-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(SID_SHelp, 0x6d5140c7, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

// { 6d5140c8-7436-11ce-8034-00aa006009fa }
DEFINE_GUID(IID_IHelp, 0x6d5140c8, 0x7436, 0x11ce, 0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa);

#undef  INTERFACE
#define INTERFACE  IHelp
DECLARE_INTERFACE_(IHelp, IUnknown)
{
    BEGIN_INTERFACE
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IHelp methods ***
    STDMETHOD(GetHelpFile) (THIS_ BSTR * pbstr) PURE;
    STDMETHOD(GetHelpInfo) (THIS_ DWORD * pdwHelpInfo) PURE;
    STDMETHOD(ShowHelp) (THIS_
                         LPOLESTR szHelp,
                         UINT fuCommand,
                         DWORD dwHelpContext) PURE;
};


//-------------------------------------------------------------------------
//  SApplicationObject Service
//    Host applications proffer their application object as this service.  
//    Various objects implement the "Application" property by returning 
//    this service.
//      
//-------------------------------------------------------------------------

// { 0c539790-12e4-11cf-b661-00aa004cd6d8 }
DEFINE_GUID(SID_SApplicationObject, 0x0c539790, 0x12e4, 0x11cf, 0xb6, 0x61, 0x00, 0xaa, 0x00, 0x4c, 0xd6, 0xd8);

#endif // _OBJEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\parser.cpp ===
//*********************************************************************************************************************************************
//
//      File: Parser.cpp
//  Author: Donald Drake
//  Purpose: Implements classes to support parsing tokens from a xml file

#include "header.h"
#include "stdio.h"
#include "string.h"
#include "TCHAR.h"
#include "windows.h"
#include "parser.h"

DWORD CParseXML::Start(const CHAR *szFile)
{
	m_fh = fopen(szFile,  "r");

	if (m_fh == NULL)
		return F_NOFILE;

	if (SetError(Read()) != F_OK)
			return GetError();

	return F_OK;
}

void CParseXML::End()
{
	if (m_fh != NULL)
	{
		fclose(m_fh);
		m_fh = NULL;
	}
}


DWORD CParseXML::Read()
{
	if (fgets(m_cCurBuffer, MAX_LINE_LEN, m_fh) == NULL)
	{
		if (feof(m_fh))
			return F_EOF;
		return F_READ;
	}
	m_pCurrentIndex = m_cCurBuffer;
	return F_OK;
}

CHAR * CParseXML::GetFirstWord(CHAR *sz)
{
	if (sz == NULL)
		return NULL;

	// ignore starting white space
	for (CHAR *pChar = sz; *pChar && *pChar== ' ';  pChar = CharNext(pChar));

	memset(m_cCurWord, 0, MAX_LINE_LEN);

	CHAR *pWord = m_cCurWord;
	for (;*pChar && *pChar != ' ' && *pChar != '=' && *pChar != '\n' && *pChar != '\t' ;pChar = CharNext(pChar), pWord = CharNext(pWord))
	{
		*pWord = *pChar;
		if (IsDBCSLeadByte(*pChar))
		{
			*(pWord+1) = *(pChar+1);
		}
	}
	*pWord = NULL;
	return m_cCurWord;
}

CHAR * CParseXML::GetValue(CHAR *sz)
{
	// get location of word value then find = sign
	CHAR *pChar;
	CHAR *p;

	p = sz;

	// BUGBUG temp hack to fix build, parser.cpp and parserhh.cpp will 
	// soon be merged
	pChar = NULL;
	while (*p)
	{
		if ((*p == 'v' || *p == 'V') &&
			(*(p+1) == 'a' || *(p+1) == 'A') &&
			(*(p+2) == 'l' || *(p+2) == 'L') &&
			(*(p+3) == 'u' || *(p+3) == 'U') &&
			(*(p+4) == 'e' || *(p+4) == 'E'))
		{
			pChar = p;
			break;
		}
		p = CharNext(p);
	}
	
	// did not find the value tag
	if (pChar == NULL)
		return NULL;

	for (; *pChar && *pChar != '='; pChar = CharNext(pChar));

	if (*pChar == '=')
	{
		memset(m_cCurWord, 0, MAX_LINE_LEN);
		CHAR *pWord = m_cCurWord;
		// ignore white space
		pChar = CharNext(pChar);
		for (; *pChar && *pChar == ' '; pChar = CharNext(pChar));
		for ( ; *pChar ; pChar = CharNext(pChar))
		{
			if (*pChar == '/' && *(pChar+1) == NULL)
				break;
			if (*pChar != 34)
			{
				*pWord = *pChar;
				if (IsDBCSLeadByte(*pChar))
				{
					*(pWord+1) = *(pChar+1);
				}
				pWord = CharNext(pWord);
			}
		}
		*pWord = NULL;
		return m_cCurWord;
	}
	return NULL; // did not find the = sign
}

CHAR *CParseXML::GetToken()
{
	// start looking for <
	while (TRUE)
	{
		if (*m_pCurrentIndex == NULL)
		{
			if (SetError(Read()) != F_OK)
				return NULL;
		}
	
		if (*m_pCurrentIndex != '<')
		{
			m_pCurrentIndex = CharNext(m_pCurrentIndex);
			continue;
		}

		// found a < skip it and start building the token
		memset(m_cCurToken, 0, MAX_LINE_LEN);
		CHAR *pWord  = m_cCurToken;
		while (TRUE)
		{
			m_pCurrentIndex = CharNext(m_pCurrentIndex);
			if (*m_pCurrentIndex == NULL)
				if (SetError(Read()) != F_OK)
					return NULL;

			if (*m_pCurrentIndex == '>')
			{
				m_pCurrentIndex = CharNext(m_pCurrentIndex);
				return m_cCurToken;
			}
			*pWord = *m_pCurrentIndex;
			if (IsDBCSLeadByte(*m_pCurrentIndex))
			{
				*(pWord+1) = *(m_pCurrentIndex+1);
			}
			pWord = CharNext(pWord);
		}
	}
}

// class to support a FIFO queue of strings

void CFIFOString::RemoveAll()
{
	FIFO *prev;
	while (m_fifoTail)
	{
		prev = m_fifoTail->prev;
		delete [] m_fifoTail->string;
		delete m_fifoTail;
		m_fifoTail = prev;
	}
}

CFIFOString::~CFIFOString()
{
	RemoveAll();
}

DWORD CFIFOString::AddTail(CHAR *sz)
{
FIFO *entry;
int len;

	entry = new FIFO;
	if (entry == NULL)
		return F_MEMORY;

	len = (int)_tcslen(sz) + 1;

	entry->string = new CHAR[len];

	_tcscpy(entry->string, sz);

	entry->prev = NULL;

	if (m_fifoTail)
	{
		entry->prev  = m_fifoTail;
	}
	m_fifoTail = entry;
	return F_OK;
}

DWORD CFIFOString::GetTail(CHAR **sz)
{
int len;
FIFO *entry;

	if (m_fifoTail == NULL)
		return F_END;

	len = (int)_tcslen(m_fifoTail->string) + 1;

	*sz= new CHAR[len];

	if (*sz == NULL)
		return F_MEMORY;

	_tcscpy(*sz, m_fifoTail->string);

	entry = m_fifoTail->prev;

	delete [] m_fifoTail->string;
	delete m_fifoTail;
	m_fifoTail = entry;
	return F_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\objcnt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//
//  objcnt.h    --- Support for counting object instances.
//
//
#ifndef __OBJCNT_H__
#define __OBJCNT_H__

/*
    This class catches class instance leaks. If you new a class, but do
    not delete it, this class will find it.

    The nice thing about this class is that it is very simple to use.

    Simple Instructions
    -------------------

    Assume X is the name of the class you want to count objects:

    1. Inherit your class X from SI_COUNT(X). 
    2. Add the following line to a .CPP file in global scope:
        AUTO_CLASS_COUNT_CHECK(X) ;

    For more information refer to the detailed directions below.

    Detailed Instructions
    ---------------------

    1. Inherit from one of the *_COUNT macros passing the name of the class your are tracking.

        If your class does not inherit from another class use SI_COUNT (Single Inheritance Count):

            class CHmData SI_COUNT(CHmData) // No ':'.
            {
                ....
            };
           

            // Notice that you do not use the ':' between the class name and the SI_COUNT macros.

        If your class inherits from another class use MI_COUNT (Multiple Inheritances) instead of
        SI_COUNT:

            class CExMergedTitleNode : MI_COUNT(CExMergerTitleNode)
                                        public CTitleNode
            {
                ...
            } ;
        

            // Notice that you need the ':' when using MI_COUNT. However, DO NOT use the ending comma ','.


        If your class has to inherit from another class first, for example CHHWinType, use MI2_COUNT and
        place it last on the inheritance chain:

            class CHHWinType :  public HH_WINTYPE
                                MI2_COUNT(CHHWinType)
            {
                ...
            };

            // Notice that there isn't a comma before MI2_COUNT.

  
    2.  If you want to automatically, check the allocation/deallocation count at CRT shutdown, 
        use the AUTO_CLASS_COUNT_CHECK macro. In a .CPP file outside the scope of a function, 
        place the following line:

            AUTO_CLASS_COUNT_CHECK(CExNode);

        where CExNode is the name of the class you want to automatically count.
    
        This macro creates a class which will call the check routine when it goes out of scope. 
        This will happen when the CRTs are unloaded.


    3. If you want to check the class object count at a specific instance, use the CHECK_CLASS_COUNT macro.

            CHECK_CLASS_COUNT(CExNode) ;

        This creates a function call to the Check function.

        This was used in the CloseWindow function in secwin.cpp to find out what was and wasn't cleaned up
        after closing a window.


    4.  The best way to catch the messages is to place a break point on the line below with the DebugBreak call.
    
        A message box will normally be displayed showing the count. However, due to the threading issues
        sometimes the thread goes away before the Messsage box is visible. 



*/
///////////////////////////////////////////////////////////////////////////////
//
// Global Helper function
//

///////////////////////////////////////////////////////////////////////////////
//
// Forwards
//
template <typename X> class CAutoClassCountCheck;

///////////////////////////////////////////////////////////////////////////////
//
// CClassObjectCount
//
template <typename X>
class CClassObjectCount
{
  
    friend class CAutoClassCountCheck<X> ;

public:
    
    // Constructor
    CClassObjectCount()
    {
        m_construct++ ;
    }

    // Destructor
    ~CClassObjectCount()
    {
        m_destruct++ ;
    }

    // Dump the statistics.
    static void Dump(const char* szName)
    {
#if 0
        char buf[256] ;
        wsprintf(buf, "construct:%d\ndestruct:%d", m_construct, m_destruct) ;
        MessageBox(NULL, buf, szName, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
#else
        char buf2[1024];
        wsprintf( buf2, "*** Memory Leak: %s class, construct:%d, destruct:%d\r\n", szName, m_construct, m_destruct );
        OutputDebugString( buf2 );
#endif
    }

    // Check to see if everything was deallocated.
    static void Check(const char* szName)
    {
        if (m_construct != m_destruct)
        {
            //--- PLACE BREAK POINT HERE ---
            //DebugBreak() ;
            Dump(szName) ;
        }
    }

private:
    // Member variables.
    static int m_construct;
    static int m_destruct;
};

///////////////////////////////////////////////////////////////////////////////
//
// statics
//
template <typename X>
int CClassObjectCount<X>::m_construct = 0;

template <typename X>
int CClassObjectCount<X>::m_destruct = 0;


///////////////////////////////////////////////////////////////////////////////
//
// CAutoClassCountCheck
//
template <typename X>
class CAutoClassCountCheck
{
public:
    CAutoClassCountCheck(const char* name)
    {
        m_name = name ;
    }

    virtual ~CAutoClassCountCheck() 
    {
        CClassObjectCount<X>::Check(m_name);
    }

public:
    const char* m_name ;
};




///////////////////////////////////////////////////////////////////////////////
//
// Macros
//
#ifdef _DEBUG 

/////////////////// DEBUG MACROS /////////////////// 

// Don't use this macro directly
#define COUNT(x) private CClassObjectCount<x>

// Use with multiple inheritance. Always first.
#define MI_COUNT(x) COUNT(x),

// Use with single inheritance. Always first.
#define SI_COUNT(x) : COUNT(x)

// Use with multiple inheritance. Always last.
#define MI2_COUNT(x) ,COUNT(x)

// Create a class which calls check on exit.
#define AUTO_CLASS_COUNT_CHECK(x) \
    CAutoClassCountCheck<x> _dumpclass_##x(#x) 

// Check the class count.
#define CHECK_CLASS_COUNT(x) \
    CClassObjectCount<x>::Check(#x) 

// Dump the class count
#define DUMP_CLASS_COUNT(x)\
    CClassObjectCount<x>::Dump(#x) 

#else

/////////////////// RELEASE MACROS /////////////////// 

#define COUNT(x) 
#define MI_COUNT(x) 
#define SI_COUNT(x)
#define MI2_COUNT(x)

#define AUTO_CLASS_COUNT_CHECK(x) 

#define CHECK_CLASS_COUNT(x) 
#define DUMP_CLASS_COUNT(x)
#endif

#endif __OBJCNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\parser.h ===
//*********************************************************************************************************************************************
//
//      File: Parser.h
//  Author: Donald Drake
//  Purpose: Defines classes to support parsing tokens from a xml file

#ifndef _PARSER_H
#define _PARSER_H

#include <stdio.h>

#undef CLASS_IMPORT_EXPORT
#ifdef HHCTRL // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#define MAX_LINE_LEN 1024

#define F_OK 0
#define F_NOFILE 1
#define F_READ 2
#define F_WRITE 3
#define F_MEMORY 4
#define F_EOF 5
#define F_END 6
#define F_TAGMISSMATCH 7
#define F_MISSINGENDTAG 8
#define F_NOTFOUND 9
#define F_NOPARENT 10
#define F_NULL 11
#define F_NOTITLE 12
#define F_LOCATION 13
#define F_REFERENCED 14
#define F_DUPLICATE 15
#define F_DELETE 16
#define F_CLOSE 17
#define F_EXISTCHECK 19

class CParseXML {
private: // data

	CHAR m_cCurToken[MAX_LINE_LEN];
	CHAR m_cCurWord[MAX_LINE_LEN];
	CHAR m_cCurBuffer[MAX_LINE_LEN];
	FILE *m_fh;
	CHAR * m_pCurrentIndex;
	DWORD m_dwError;

private: // functions
	DWORD Read();
	DWORD SetError(DWORD dw) { m_dwError = dw; return m_dwError; }
public:

	CParseXML() {
		m_fh = NULL;
		m_cCurBuffer[0] = '\0';
		m_pCurrentIndex = NULL;
		m_dwError = F_OK;
	}

	~CParseXML() {
		End();
	}

	CHAR * GetFirstWord(CHAR *);
	CHAR * GetValue(CHAR *);

	DWORD Start(const CHAR *szFile);
	void End();
	CHAR *GetToken();
	DWORD GetError() { return m_dwError; }
};

// class to support a FIFO queue of strings
typedef struct  fifo {
	CHAR *string;
	fifo *prev;
} FIFO;

class CLASS_IMPORT_EXPORT  CFIFOString {
private:

	FIFO *m_fifoTail;

public:

	CFIFOString() { m_fifoTail = NULL; }
	~CFIFOString();
	void RemoveAll();

	DWORD AddTail(CHAR *sz);
	DWORD GetTail(CHAR **sz);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\parserhh.h ===
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.
//*********************************************************************************************************************************************
//
//      File: Parser.h
//  Author: Donald Drake
//  Purpose: Defines classes to support parsing tokens from a xml file

#ifndef _PARSER_H
#define _PARSER_H

#include "cinput.h"

#define MAX_LINE_LEN 1024

#define F_OK 0
#define F_NOFILE 1
#define F_READ 2
#define F_WRITE 3
#define F_MEMORY 4
#define F_EOF 5
#define F_END 6
#define F_TAGMISSMATCH 7
#define F_MISSINGENDTAG 8
#define F_NOTFOUND 9
#define F_NOPARENT 10
#define F_NULL 11
#define F_NOTITLE 12
#define F_LOCATION 13
#define F_REFERENCED 14
#define F_DUPLICATE 15
#define F_DELETE 16
#define F_CLOSE 17
#define F_EXISTCHECK 19

class CParseXML {
private: // data
	CInput* m_pin;
	CStr    m_cszLine;

	TCHAR m_cCurToken[MAX_LINE_LEN];
	TCHAR m_cCurWord[MAX_LINE_LEN];
	TCHAR m_cCurBuffer[MAX_LINE_LEN];
	TCHAR * m_pCurrentIndex;
	DWORD m_dwError;
	
private: // functions
	DWORD Read();
	DWORD SetError(DWORD dw) { m_dwError = dw; return m_dwError; }
public:

	CParseXML() {
		m_pin = NULL;
		m_cCurBuffer[0] = '\0';
		m_pCurrentIndex = NULL;
		m_dwError = F_OK;
	}

	~CParseXML() {
		End();
	}

	TCHAR * GetFirstWord(const TCHAR *);
	TCHAR * GetValue(const TCHAR *);

	DWORD Start(const TCHAR *szFile);
	void End();
	TCHAR *GetToken();
	DWORD GetError() { return m_dwError; }
};

// class to support a FIFO queue of strings
typedef struct  fifo {
	CHAR *string;
	fifo *prev;
} FIFO;

class CFIFOString {
private:

	FIFO *m_fifoTail;

public:

	CFIFOString() { m_fifoTail = NULL; }
	~CFIFOString();
	void RemoveAll();
	DWORD AddTail(PCSTR psz);
	DWORD GetTail(CHAR **sz);
};

#endif _PARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\parserhh.cpp ===
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.
//*********************************************************************************************************************************************
//
//  File: Parser.cpp
//  Author: Donald Drake
//  Purpose: Implements classes to support parsing tokens from a xml file

#include "header.h"
#include "TCHAR.h"
#include "string.h"
#include <winnls.h>
#include "parserhh.h"

DWORD CParseXML::Start(const TCHAR *szFile)
{
    ASSERT(!m_pin);
    m_pin = new CInput(szFile);
    if (!m_pin->isInitialized())
        return F_NOFILE;
    if (SetError(Read()) != F_OK)
        return GetError();
    return F_OK;
}

void CParseXML::End()
{
    if (m_pin) {
        delete m_pin;
        m_pin = NULL;
    }
}

DWORD CParseXML::Read()
{
    if (!m_pin->getline(&m_cszLine))
        return F_EOF;
    _tcscpy(m_cCurBuffer, m_cszLine);
    m_pCurrentIndex = m_cCurBuffer;
    return F_OK;
}

TCHAR * CParseXML::GetFirstWord(const TCHAR *sz)
{
    if (sz == NULL)
        return NULL;

    // ignore starting white space
    for (const TCHAR *pChar = sz; *pChar && *pChar== ' ';  pChar = CharNext(pChar));

    memset(m_cCurWord, 0, MAX_LINE_LEN);

    TCHAR *pWord = m_cCurWord;
    for (;*pChar && *pChar != ' ' && *pChar != '=' && *pChar != '\n' && *pChar != '\t' ;pChar = CharNext(pChar), pWord = CharNext(pWord))
    {
        *pWord = *pChar;
        if (IsDBCSLeadByte(*pChar))
        {
            *(pWord+1) = *(pChar+1);
        }
    }
    *pWord = NULL;
    return m_cCurWord;}

static const char txtValue[] = "value";

TCHAR * CParseXML::GetValue(const TCHAR *sz)
{
    // get location of word value then find = sign
    TCHAR *pChar;

    pChar = stristr(sz, txtValue);

    // did not find the value tag
    if (pChar == NULL)
        return NULL;

    for (; *pChar && *pChar != '='; pChar = CharNext(pChar));

    if (*pChar == '=')
    {
        memset(m_cCurWord, 0, MAX_LINE_LEN);
        TCHAR *pWord = m_cCurWord;
        // ignore white space
        pChar = CharNext(pChar);
        for (; *pChar && *pChar == ' '; pChar = CharNext(pChar));
        for ( ; *pChar ; pChar = CharNext(pChar))
        {
            if (*pChar == '/' && *(pChar+1) == NULL)
                break;
            if (*pChar != 34)
            {
                *pWord = *pChar;
                if (IsDBCSLeadByte(*pChar))
                {
                    *(pWord+1) = *(pChar+1);
                }
                pWord = CharNext(pWord);
            }
        }
        *pWord = NULL;
        return m_cCurWord;
    }
    return NULL; // did not find the = sign
}

TCHAR *CParseXML::GetToken()
{
    // start looking for <
    while (TRUE)
    {
        if (*m_pCurrentIndex == NULL)
        {
            if (SetError(Read()) != F_OK)
                return NULL;
        }

        if (*m_pCurrentIndex != '<')
        {
            m_pCurrentIndex = CharNext(m_pCurrentIndex);
            continue;
        }

        // found a < skip it and start building the token
        memset(m_cCurToken, 0, MAX_LINE_LEN);
        TCHAR *pWord  = m_cCurToken;
        while (TRUE)
        {
            m_pCurrentIndex = CharNext(m_pCurrentIndex);
            if (*m_pCurrentIndex == NULL)
                if (SetError(Read()) != F_OK)
                    return NULL;

            if (*m_pCurrentIndex == '>')
            {
                m_pCurrentIndex = CharNext(m_pCurrentIndex);
                return m_cCurToken;
            }
            *pWord = *m_pCurrentIndex;
            if (IsDBCSLeadByte(*m_pCurrentIndex))
            {
                *(pWord+1) = *(m_pCurrentIndex+1);
            }
            pWord = CharNext(pWord);
        }
    }
}

// class to support a queue of strings

void CFIFOString::RemoveAll()
{
    FIFO *prev;
    while (m_fifoTail)
    {
        prev = m_fifoTail->prev;
        delete [] m_fifoTail->string;
        delete m_fifoTail;
        m_fifoTail = prev;
    }
}

CFIFOString::~CFIFOString()
{
    RemoveAll();
}

DWORD CFIFOString::AddTail(PCSTR psz)
{
FIFO *entry;

    entry = new FIFO;   // won't return if out of memory

    entry->string = new CHAR[strlen(psz) + 1];

    strcpy(entry->string, psz);

    entry->prev = NULL;

    if (m_fifoTail)
    {
        entry->prev  = m_fifoTail;
    }
    m_fifoTail = entry;
    return F_OK;
}

DWORD CFIFOString::GetTail(CHAR **sz)
{
FIFO *entry;

    if (m_fifoTail == NULL)
        return F_END;

    *sz = new CHAR[strlen(m_fifoTail->string) + 1]; // doesn't return if out of memory

    strcpy(*sz, m_fifoTail->string);

    entry = m_fifoTail->prev;

    delete [] m_fifoTail->string;
    delete m_fifoTail;
    m_fifoTail = entry;
    return F_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\progress.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _CPROGRESS_H_
#define _CPROGRESS_H_

#include <commctrl.h>

// Creates a progress window

class CProgress
{
public:
    CProgress(PCSTR pszTitle, HWND hwndParent = NULL, int steps = -1, int cHowOften = 1);
    ~CProgress();
    void CreateTheWindow(void); // called automatically after 1.5 seconds

    void SetPosition(int position) {
        if (hwndProgress)
            SendMessage(hwndProgress, PBM_SETPOS, (WPARAM) position, 0);
    };

    void Progress(void);

    HWND hwndFrame;
    HWND hwndProgress;

protected:
    RECT rc;
    DWORD dwStartTime;
    HWND hwndParent;
    int steps;
    PSTR pszTitle;
    BOOL fWindowCreationFailed;

    int cProgress;
    int cFrequency;
    int counter;
};

#endif // _CPROGRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\popup.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _POPUP_H_
#define _POPUP_H_

#include "htmlhelp.h"
#include "fsclient.h"
#include "cinput.h"

/////////////////////////////////////////////////////////////////////
//
// Global Function Prototypes
//
HWND doDisplayTextPopup(HWND hwndMain, LPCSTR pszFile, HH_POPUP* pPopup);

/////////////////////////////////////////////////////////////////////
//
// CPopupWindow
//
class CPopupWindow
{
public:
	CPopupWindow();
	~CPopupWindow();
	HWND CreatePopupWindow(HWND hwndCaller, PCSTR pszFile, HH_POPUP* pPopup);
	void CleanUp(void);
	BOOL ReadTextFile(PCSTR pszFile);

protected:
	HWND doPopupWindow(void);
	void CalculateRect(POINT pt);  // assumes text in m_mem, result in m_rcWindow
	void SetColors(COLORREF clrForeground, COLORREF clrBackground);

	CFSClient*	m_pfsclient;
	CInput* 	m_pin;
	RECT		m_rcWindow;
	HWND		m_hwndCaller;
	COLORREF	m_clrForeground;
	COLORREF	m_clrBackground;
	HWND		m_hwnd;
	PSTR		m_pszText;
	HFONT		m_hfont;
	RECT		m_rcMargin;
	CTable* 	m_ptblText;
	PCSTR		m_pszTextFile;

	friend LRESULT CALLBACK PopupWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
};

extern CPopupWindow* g_pPopupWindow;

#endif // _POPUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\proppage.h ===
//=--------------------------------------------------------------------------=
// PropPage.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for CPropertyPage.
//
#ifndef _PROPPAGE_H_

// things we really need
//
#include "Unknown.H"
#include <olectl.h>
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// messages that we'll send to property pages to instruct them to accomplish
// tasks.
//
#define PPM_NEWOBJECTS    (WM_USER + 100)
#define PPM_APPLY         (WM_USER + 101)
#define PPM_EDITPROPERTY  (WM_USER + 102)
#define PPM_FREEOBJECTS   (WM_USER + 103)

//=--------------------------------------------------------------------------=
// structure that control writers will use to define property pages.
//
typedef struct tagPROPERTYPAGEINFO {

    UNKNOWNOBJECTINFO unknowninfo;
    WORD    wDlgResourceId;
    WORD    wTitleId;
    WORD    wDocStringId;
    LPCSTR  szHelpFile;
    DWORD   dwHelpContextId;

} PROPERTYPAGEINFO;

#ifndef INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    extern PROPERTYPAGEINFO name##Page \

#else // INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, pfn }, wr, wt, wd, pszhf, dwhci } \

#endif // INITOBJECTS


#define TEMPLATENAMEOFPROPPAGE(index)    MAKEINTRESOURCE(((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDlgResourceId)
#define TITLEIDOFPROPPAGE(index)         (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wTitleId)
#define DOCSTRINGIDOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDocStringId)
#define HELPCONTEXTOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->dwHelpContextId)
#define HELPFILEOFPROPPAGE(index)        (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->szHelpFile)

//=--------------------------------------------------------------------------=
//
class CPropertyPage : public CUnknownObject, public IPropertyPage2 {

  public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IPropertyPage methods
    //
    STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
    STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHOD(Deactivate)(void);
    STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
    STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHOD(Show)(UINT nCmdShow);
    STDMETHOD(Move)(LPCRECT prect);
    STDMETHOD(IsPageDirty)(void);
    STDMETHOD(Apply)(void);
    STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

    // IPropertyPage2 methods
    //
    STDMETHOD(EditProperty)(THIS_ DISPID dispid);

    // constructor destructor
    //
    CPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CPropertyPage();

  protected:
    IPropertyPageSite *m_pPropertyPageSite;       // pointer to our ppage site.
    void     MakeDirty();                         // makes the property page dirty.
    HWND     m_hwnd;                              // our hwnd.

    // the following two methods allow a property page implementer to get at all the
    // objects that we need to set here.
    //
    IUnknown *FirstControl(DWORD *dwCookie);
    IUnknown *NextControl(DWORD *dwCookie);

  private:
    IUnknown **m_ppUnkObjects;                    // objects that we're working with.

    unsigned m_fActivated:1;
    unsigned m_fDirty:1;
    int      m_ObjectType;                        // what type of object we are
    UINT     m_cObjects;                          // how many objects we're holding on to

    void     m_ReleaseAllObjects(void);           // clears out all objects we've got.
    HRESULT  m_EnsureLoaded(void);                // forces the load of the page.

    virtual HRESULT InternalQueryInterface(REFIID, void **);

    // default dialog proc for a page.
    //
    static BOOL CALLBACK PropPageDlgProc(HWND, UINT, WPARAM, LPARAM);

    // all page implementers MUST implement the following function.
    //
    virtual INT_PTR DialogProc(HWND, UINT, WPARAM, LPARAM) PURE;
};

#define _PROPPAGE_H_
#endif // _PROPPAGE_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\print.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#define DLG_CLASS 0x00008002

HHOOK g_hHook = NULL;				// Handle to the WH_CALLWNDPROC hook.
HHOOK g_hCBTHook = NULL;			// Handle to the WH_CBT hook.
BOOL  g_bPrintDlgDisplayed = FALSE;	// Flag that's set when the WebBrowser print dialog has been displayed once.
BOOL  g_bCancel = FALSE;			// Flag that's set when a dialog's cancel button has been clicked.

// This is the hook procedure for the WH_CALLWNDPROC hook.

LRESULT CALLBACK CHTMLPrintDlg::HookProc(int code, WPARAM wParam, LPARAM lParam)
{
	// Call the next hook if code is less than 0.  (Standard hook stuff.)

	if (code < 0)
		return ::CallNextHookEx(g_hHook, code, wParam, lParam);

	LPCWPSTRUCT lpMsg = (LPCWPSTRUCT) lParam;

	switch (lpMsg->message)
	{
		// Watch for the WebBrowser's print dialog to be initialized.

		case WM_INITDIALOG:
		{
			// If the print dialog has been displayed once,
			// simulate a click on the OK button.  The CBT hook procedure
			// will move the dialog off of the screen, so the user
			// won't be able to click it.

			if (g_bPrintDlgDisplayed)
			{
				// Get the window handle for the OK button.

				HWND hOKButton = ::GetDlgItem(lpMsg->hwnd, IDOK);

				// Post a message to the OK button to make it 
				// think it's been clicked.

				if (hOKButton != NULL)
				{
					::PostMessage(hOKButton, WM_LBUTTONDOWN, 0, 0);
					::PostMessage(hOKButton, WM_LBUTTONUP, 0, 0);
				}
			}
			else

				// If this is the first time the print dialog is being
				// displayed (g_bPrintDlgDisplayed == FALSE), don't simulate
				// the button click.  The CBT hook procedure won't move the
				// dialog off the screen.  Now that the dialog has been displayed
				// once, set g_bPrintDlgDisplayed to TRUE.

				g_bPrintDlgDisplayed = TRUE;
		}
			break;

		case WM_COMMAND:

			// If g_bPrintDlgDisplayed is TRUE (the user can see the print dialog), 
			// watch for a click on the Cancel button.  The control should stop
			// printing if the user clicks cancel.

			if (HIWORD(lpMsg->wParam) == BN_CLICKED && LOWORD(lpMsg->wParam) == IDCANCEL)
				g_bCancel = TRUE;
	}

	return 0;
}

// This is the hook procedure for the WH_CBT hook.

LRESULT CALLBACK CHTMLPrintDlg::CBTHookProc(int code, WPARAM wParam, LPARAM lParam)
{
	// Call the next hook if code is less than 0.  (Standard hook stuff.)

	if (code < 0)
		return ::CallNextHookEx(g_hCBTHook, code, wParam, lParam);

	// Watch for the WebBrowser print dialog to be created.

	if (code == HCBT_CREATEWND)
	{
		LPCBT_CREATEWND lpcbtcw = (LPCBT_CREATEWND) lParam;

		// Make sure that it's a dialog box that's being created.
		// The only dialog that should be hooked is the print dialog
		// because the hook is installed after the main dialog and
		// the progress dialog have been created.  Of course, if
		// the WebBrowser displays a message box, this would probably
		// hook it, so that could be a problem.

		if ((DWORD)lpcbtcw->lpcs->lpszClass == DLG_CLASS)
		{
			//  Move the dialog off of the screen unless it's being 
			//  displayed for the first time.

			// BUGBUG: 13-Oct-1997	[ralphw] Check the window name to be
			// sure we have the right dialog box.

			if (g_bPrintDlgDisplayed)
				lpcbtcw->lpcs->x = -(lpcbtcw->lpcs->cx);
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\popup.cpp ===
// Copyright (C) Microsoft Corporation 1996, All Rights reserved.

#include "header.h"
#include "popup.h"
#include "cinput.h"
#include "hha_strtable.h"
#include "strtable.h"
#include "hhshell.h" // g_hwndApi.

#include "resource.h"
/////////////////////////////////////////////////////////////////////
//
// Constants
//
static const char txtComment[] = ".comment";
static const char txtTopicID[] = ".topic";
static const char txtCrLf[] = "\r\n";
static const char txtSpace[] = " ";
static const char txtDefaultFileName[] = "/cshelp.txt" ;

const int TEXT_PADDING = 5; // padding around the text.
const int SHADOW_WIDTH = 6;
const int SHADOW_HEIGHT = 6;

/////////////////////////////////////////////////////////////////////
//
// Globals
//
CPopupWindow* g_pPopupWindow;


/////////////////////////////////////////////////////////////////////
//
// Constructor
//
CPopupWindow::CPopupWindow()
{
    ZERO_INIT_CLASS(CPopupWindow);
    m_pfsclient = NULL; // doesn't get cleared, don't know why

}

/////////////////////////////////////////////////////////////////////
//
// Constructor
//
CPopupWindow::~CPopupWindow()
{
    CleanUp();
}

/////////////////////////////////////////////////////////////////////
//
// Constructor Helper - Allows reusing window, but breaks caching.
//
void CPopupWindow::CleanUp(void)
{
    if (IsValidWindow(m_hwnd))
        DestroyWindow(m_hwnd);

    if (m_pfsclient)
        delete m_pfsclient;
    if (m_pszText)
        lcClearFree(&m_pszText);
    if (m_hfont)
        DeleteObject(m_hfont);
    if (m_ptblText)
        delete m_ptblText;
    if (m_pszTextFile)
        lcClearFree((void**) &m_pszTextFile);

    m_pfsclient = NULL;
    m_ptblText = NULL;
    m_hfont = NULL;
}

void CPopupWindow::SetColors(COLORREF clrForeground, COLORREF clrBackground)
{
    if (clrForeground != (COLORREF) -1)
        m_clrForeground = clrForeground;
    else
        m_clrForeground = GetSysColor(COLOR_WINDOWTEXT);

    if (clrBackground != (COLORREF) -1)
        m_clrBackground = clrBackground;
    else
        m_clrBackground = RGB(255, 255, 238); // dithered yellow

    // If the colors are the same, then use standard window colors

    HDC hdc = GetWindowDC(m_hwndCaller);

    if (GetHighContrastFlag() ||
            GetNearestColor(hdc, m_clrBackground) ==
            GetNearestColor(hdc, m_clrForeground)) {
        m_clrForeground = GetSysColor(COLOR_WINDOWTEXT);
        m_clrBackground = GetSysColor(COLOR_WINDOW);
    }

    ReleaseDC(m_hwndCaller, hdc);
}

// assumes text in m_pszText, result in m_rcWindow

#define DEFAULT_DT_FLAGS (DT_EXPANDTABS | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK | DT_RTLREADING)

void CPopupWindow::CalculateRect(POINT pt)
{
    RECT rc; // BUGBUG: Broken on multiple monitor systems
    GetClientRect(GetDesktopWindow(), &rc);   // get desktop area
    int cyScreen = RECT_HEIGHT(rc);
    int cxScreen = RECT_WIDTH(rc);

    HDC hdc = CreateDC("DISPLAY", NULL, NULL, NULL);
    HFONT hfontOld;
    if (m_hfont)
        hfontOld = (HFONT) SelectObject(hdc, m_hfont);

    DrawText(hdc, m_pszText, -1, &rc, DEFAULT_DT_FLAGS | DT_CALCRECT);

    // Check for an overly wide but short popup

    if (rc.bottom * 12 < rc.right) {
        rc.right = rc.bottom * 12;
        DrawText(hdc, m_pszText, -1, &rc, DEFAULT_DT_FLAGS | DT_CALCRECT);
    }

    if (m_hfont)
         SelectObject(hdc, hfontOld);

    m_rcWindow.left = pt.x - (RECT_WIDTH(rc) / 2);
    m_rcWindow.right = m_rcWindow.left + RECT_WIDTH(rc);
    m_rcWindow.top = pt.y;
    m_rcWindow.bottom = m_rcWindow.top + RECT_HEIGHT(rc);

    m_rcWindow.left -= m_rcMargin.left;
    m_rcWindow.top -= m_rcMargin.top;
    m_rcWindow.right += m_rcMargin.right;
    m_rcWindow.bottom += m_rcMargin.bottom;

    if (m_rcWindow.left < 0)
        OffsetRect(&m_rcWindow, -m_rcWindow.left, 0);
    if (m_rcWindow.bottom > cyScreen)
        OffsetRect(&m_rcWindow, 0, cyScreen - m_rcWindow.bottom);
}

static BOOL s_fRegistered;
const char txtPopupClass[] = "hh_popup";

HWND CPopupWindow::doPopupWindow(void)
{
    if (!s_fRegistered) {
        WNDCLASS wndclass;
        ZeroMemory(&wndclass, sizeof(WNDCLASS));
        wndclass.style          = CS_VREDRAW | CS_HREDRAW;
        wndclass.lpfnWndProc    = PopupWndProc;
        wndclass.hInstance      = _Module.GetModuleInstance();
        wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
        wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpszClassName = txtPopupClass;
        s_fRegistered = RegisterClass(&wndclass);
    }
    ASSERT_COMMENT(m_clrForeground != (COLORREF) -1, "Forgot to call SetColors()");

    char pszPopupTitle[128];
    lstrcpyn(pszPopupTitle, m_pszText, 128);

    // t-jzybur 4-3-99: Added WS_EX_TOOLWINDOW to prevent a taskbar entry for the
    // popup text.
    m_hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, txtPopupClass, pszPopupTitle, WS_POPUP,
        m_rcWindow.left, m_rcWindow.top, RECT_WIDTH(m_rcWindow) + SHADOW_WIDTH,
        RECT_HEIGHT(m_rcWindow) + SHADOW_HEIGHT,
        m_hwndCaller, NULL, _Module.GetModuleInstance(), NULL);

    if (IsValidWindow(m_hwnd)) {
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR) this);
		ShowWindow(m_hwnd, SW_SHOW);

        // t-jzybur 4-3-99: Added SetForegroundWindow to activate the popup text.  It could
        // be inactive if the previous popup text was closed by clicking the mouse somwhere
        // outside of the popup window.
        SetForegroundWindow(m_hwnd);

        // t-jzybur 4-3-99: Instead of capturing the focus and responding to click events,
        // we'll respond to click events and deactivate messages.  Its a cleaneer event model,
        // and we won't have the possibility of locking in the hour glass cursor.
//        SetCapture(m_hwnd);
    }

    return m_hwnd;
}

LRESULT CALLBACK PopupWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc;
    CPopupWindow* pThis;
    RECT rc;
    PAINTSTRUCT ps;
    HFONT hfontOld;

    switch (msg) {
        case WM_ERASEBKGND:
            hdc = (HDC) wParam;
            pThis = (CPopupWindow*) GetWindowLongPtr(hwnd, GWLP_USERDATA);
            GetClipBox(hdc, &rc);

            return PaintShadowBackground(hwnd, (HDC) wParam, pThis->m_clrBackground);
            break;

        case WM_PAINT:
            pThis = (CPopupWindow*) GetWindowLongPtr(hwnd, GWLP_USERDATA);
            hdc = BeginPaint(hwnd, &ps);
            GetClientRect(hwnd, &rc);
            rc.left += pThis->m_rcMargin.left;
            rc.top += pThis->m_rcMargin.top;
            rc.right -= pThis->m_rcMargin.right;
            rc.bottom -= pThis->m_rcMargin.bottom;
            rc.right -= SHADOW_WIDTH;
            rc.bottom -= SHADOW_HEIGHT;
            if (pThis->m_hfont)
                hfontOld = (HFONT) SelectObject(hdc, pThis->m_hfont);
            SetTextColor(hdc, pThis->m_clrForeground);
            SetBkColor(hdc, pThis->m_clrBackground);
            SetBkMode(hdc, TRANSPARENT);
            DrawText(hdc, pThis->m_pszText, -1, &rc, DEFAULT_DT_FLAGS);
            if (pThis->m_hfont)
                SelectObject(hdc, hfontOld);
            EndPaint(hwnd, &ps);
            break;

        // t-jzybur 4-3-99: Added WndProc handler to close popup text on
		// window deactivation messages.
        case WM_ACTIVATE:
            if (LOWORD(wParam) != WA_INACTIVE) break;

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_SYSKEYDOWN:
        case WM_KEYDOWN:
            pThis = (CPopupWindow*) GetWindowLongPtr(hwnd, GWLP_USERDATA);
            pThis->m_hwnd = NULL;
            PostMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        // t-jzybur 4-3-99: Removed ReleaseCapture along with SetCapture.
//        case WM_DESTROY:
//            ReleaseCapture();
//            return DefWindowProc(hwnd, msg, wParam, lParam);

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

/***************************************************************************

    FUNCTION:   PaintShadowBackground

    PURPOSE:    Draws a border and a shadow around a window

    PARAMETERS:
        hwnd
        hdc

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        02-Mar-1997 [ralphw]

***************************************************************************/

static const WORD rgwPatGray[] =
    { 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA };
const DWORD PATMERGE = 0x00A000C9;

BOOL PaintShadowBackground(HWND hwnd, HDC hdc, COLORREF clrBackground)
{
    BOOL    fStockBrush;    // Whether hBrush is a stock object

    /*
     * First the background of the "fake" window is erased leaving the
     * desktop where the shadow will be.
     */

    RECT    rcClient;       // Will always be client rectangle
    GetClientRect(hwnd, &rcClient);
    RECT rct = rcClient;
    rct.bottom = max(0, rct.bottom - SHADOW_HEIGHT);
    rct.right  = max(0, rct.right - SHADOW_WIDTH);

    HBRUSH hBrush = CreateSolidBrush((clrBackground == (COLORREF) -1 ?
        GetSysColor(COLOR_WINDOW) : clrBackground));
    if (!hBrush)
        return FALSE;

    UnrealizeObject(hBrush);
    POINT pt;
    pt.x = pt.y = 0;
    ClientToScreen(hwnd, &pt);
    SetBrushOrgEx(hdc, pt.x, pt.y, NULL);
    FillRect(hdc, &rct, hBrush);
    DeleteObject(hBrush);

    // Next we create the "window" border

    rct = rcClient;
    rct.bottom = max(0, rct.bottom - SHADOW_HEIGHT);
    rct.right = max(0, rct.right - SHADOW_WIDTH);

    FrameRect(hdc, &rct, (HBRUSH) GetStockObject(BLACK_BRUSH));
    InflateRect(&rct, -1, -1);
    FrameRect(hdc, &rct, (HBRUSH) GetStockObject(LTGRAY_BRUSH));

    // Now we create the brush for the the shadow

    hBrush = 0;
    HBITMAP hbmGray;
    if ((hbmGray = CreateBitmap(8, 8, 1, 1, rgwPatGray)) != NULL) {
        hBrush = CreatePatternBrush(hbmGray);
        DeleteObject(hbmGray);
        fStockBrush = FALSE;
    }

    // If we cannot create the pattern brush, we try to use a black brush.

    if (hBrush == 0) {
        if (!(hBrush == GetStockObject(BLACK_BRUSH)))
            return FALSE;
        fStockBrush = TRUE;
    }

    SetROP2(hdc, R2_MASKPEN);
    SetBkMode(hdc, TRANSPARENT);
    HPEN hpen;
    if ((hpen = (HPEN) GetStockObject(NULL_PEN)) != 0)
        SelectObject(hdc, hpen);              // We do not care if this fails
    HBRUSH hbrushTemp = (HBRUSH) SelectObject(hdc, hBrush);   // or if this fails, since the
                                              // paint behavior will be okay.

    rct = rcClient;   // Paint the right side rectangle
    rct.top = rct.top + SHADOW_HEIGHT;
    rct.left = max(0, rct.right - SHADOW_WIDTH);
    PatBlt(hdc, rct.left, rct.top, rct.right - rct.left,
        rct.bottom - rct.top, PATMERGE);

    rct = rcClient;   // Paint the bottom rectangle
    rct.top = max(0, rct.bottom - SHADOW_HEIGHT);
    rct.left = rct.left + SHADOW_WIDTH;

    // Note overlap by one pixel!

    rct.right = max(0, rct.right - SHADOW_WIDTH + 1);
    PatBlt(hdc, rct.left, rct.top, rct.right - rct.left,
        rct.bottom - rct.top, PATMERGE);

    // Cleanup brush

    if (hbrushTemp != NULL)
        SelectObject(hdc, hbrushTemp);
    if (!fStockBrush)
        DeleteObject(hBrush);

    return TRUE;
}

BOOL CPopupWindow::ReadTextFile(PCSTR pszFile)
{
    // If the string pointer is NULL or empty we have to bail.
    if (!pszFile || pszFile[0] == '\0')
        return FALSE ;

    // Now, verify that we have a text file specified. Urg! More parsing of URL's
    CStr cszFileName;
    PCSTR pszSubFile = GetCompiledName(pszFile, &cszFileName) ;
    if (!pszSubFile || pszSubFile[0] == '\0')
    {
        pszSubFile = txtDefaultFileName ;
    }
    cszFileName += txtDoubleColonSep ;
    cszFileName += pszSubFile ;

#if 0//REVIEW:: This never works, because CleanUp resets everything. Removed for safety.
    // Check to see if its cached.
    if (lstrcmpi(cszFileName, m_pszTextFile) == 0)
        return TRUE; // we've cached this file
#endif

    CInput input;
    if (!input.Open(cszFileName))
        return FALSE;
    if (m_ptblText)
        delete m_ptblText;
    // Allocate a text buffer.
    CStr cszText;
    if (m_pszTextFile)
        lcFree(m_pszTextFile);
    m_pszTextFile = lcStrDup(cszFileName);
    m_ptblText = new CTable;
    while (input.getline(&cszText)) {
        if (!IsSamePrefix(cszText, txtComment))
            m_ptblText->AddString(cszText);
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// CreatePopupWindow.
//
HWND CPopupWindow::CreatePopupWindow(HWND hwndCaller, PCSTR pszFile,
    HH_POPUP* pPopup)
{
    if (!pPopup) // TODO: Validate pPopup pointer.
        return NULL ;

    m_hwndCaller = hwndCaller;

    //--- Getting the string to display. We can get the string to display in three ways:
    // 1. From a string contained in the HH_POPUP structure.
    // 2. From a string resource in a module.
    // 3. From a txt file embedded in the CHM.
    // This order is the order of least complicated to most complicated. We start with the
    // least complicated method to save loading extra working set.
    // NOTE: A future possibility would be to search in the reverse order. This would allow
    // using a string in the HH_POPUP structure if one wasn't found in the embedded txt file.
    bool bFoundString = false ;
    if ((pPopup->idString == 0) && IsNonEmptyString(pPopup->pszText))        // 1. Get string from HH_POPUP. Only if idString is 0! See HH 3532.
    {
        m_pszText = lcStrDup(pPopup->pszText);
        bFoundString = true ;
    }
    else if (pPopup->idString && pPopup->hinst)     // 2. From a string resource in a module.
    {
        m_pszText = (PSTR) lcMalloc(MAX_STRING_RESOURCE_LEN);
		char *pszText = NULL;
		
        if ((pszText =(char *) GetStringResource(pPopup->idString, pPopup->hinst)) && *pszText )
        {
		    strcpy(m_pszText,pszText);
            bFoundString = true ;
        }
    }
    else if (IsNonEmptyString(pszFile))             // 3. From a txt file embedded in the CHM.
    {
        // Try to read the text file.
        if (ReadTextFile(pszFile))
        {
            ASSERT(m_ptblText);
            for (int pos = 1; pos <= m_ptblText->CountStrings(); pos++) {
                if (IsSamePrefix(m_ptblText->GetPointer(pos), txtTopicID)) {
                    PSTR pszNumber = FirstNonSpace(m_ptblText->GetPointer(pos) +
                        strlen(txtTopicID));
                    if (pszNumber && pPopup->idString == (UINT) Atoi(pszNumber))
                        break;
                }
            }

            // Do we have enough strings?
            if (pos <= m_ptblText->CountStrings())
            {
                CStr cszText(txtZeroLength);
                BOOL fAddSpace = FALSE;
                for (++pos; pos <= m_ptblText->CountStrings(); pos++) {
                    PCSTR pszLine = m_ptblText->GetPointer(pos);
                    if (*pszLine == '.')
                        break;
                    if (!*pszLine) {
                        if (pos + 1 <= m_ptblText->CountStrings()) {
                            pszLine = m_ptblText->GetPointer(pos + 1);
                            if (*pszLine != '.')
                                cszText += txtCrLf;
                        }
                        fAddSpace = FALSE;
                        continue;
                    }
                    else if (fAddSpace)
                        cszText += txtSpace;
                    cszText += pszLine;
                    fAddSpace = TRUE;
                }
                cszText.TransferPointer(&m_pszText);
                bFoundString = true ;
            }
            else
            {
                if (IsHelpAuthor(NULL))
                {
                    char szMsgBuf[256];
                    wsprintf(szMsgBuf, pGetDllStringResource(IDS_HHA_MISSING_TP_TXT),
                        pPopup->idString, pszFile);
                    doAuthorMsg(IDS_IDH_GENERIC_STRING, szMsgBuf);
                }
            }
        }
        else
        {
            // We couldn't read the text file in. Will display error popup...
            doAuthorMsg(IDS_CANT_OPEN, pszFile);
        }
    }

    // This needs to be true when displaying static strings loaded from the resource
    // because the font specified by the user might not be appropriate for the 
    // string loaded from the resource.
    //
    BOOL bUseDefaultFont = FALSE; 

    //--- Do we have a string?
    if (!bFoundString)
    {
        if (m_pszText)
        {
            lcClearFree(&m_pszText);
            m_pszText = NULL ;
        }

        m_pszText = (PSTR) lcMalloc(MAX_STRING_RESOURCE_LEN);
	
	    char *pszText; 
		
        if ((pszText = (char *) GetStringResource(IDS_IDH_MISSING_CONTEXT)) )
        {
		    strcpy(m_pszText,pszText);
            bUseDefaultFont = TRUE;
        }
		else
		{
            // Dang it! We can't even get our own string.
            CleanUp() ;
            return NULL ;
        }
    }

    //--- Okay, now we can display the string.
    m_rcMargin.left = (pPopup->rcMargins.left >= 0 ?
        pPopup->rcMargins.left : TEXT_PADDING);
    m_rcMargin.top = (pPopup->rcMargins.top >= 0 ?
        pPopup->rcMargins.top : TEXT_PADDING);
    m_rcMargin.right = (pPopup->rcMargins.right >= 0 ?
        pPopup->rcMargins.right : TEXT_PADDING);
    m_rcMargin.bottom = (pPopup->rcMargins.bottom >= 0 ?
        pPopup->rcMargins.bottom : TEXT_PADDING);
    if (IsNonEmptyString(pPopup->pszFont) && !bUseDefaultFont) {
        if (m_hfont)
            DeleteObject(m_hfont);
        m_hfont = CreateUserFont(pPopup->pszFont);
    }
    else if (!m_hfont)
        m_hfont = CreateUserFont(GetStringResource(IDS_DEFAULT_RES_FONT));

    // Get a default location to display.
    POINT pt = pPopup->pt;
    if (pt.x == -1 && pt.x == -1 && IsWindow(hwndCaller))
    {
        RECT rcWindow;
        GetWindowRect(hwndCaller, &rcWindow);
        pt.x = rcWindow.left + (RECT_WIDTH(rcWindow) / 2);
        pt.y = rcWindow.top;
    }

    CalculateRect(pt);
    SetColors(pPopup->clrForeground, pPopup->clrBackground);

    return doPopupWindow();
}

//////////////////////////////////////////////////////////////////////////
//
// Handle the HH_TP_HELP_CONTEXTMENU command. Display the What's this menu.
//
HWND
doTpHelpContextMenu(HWND hwndMain, LPCSTR pszFile, DWORD_PTR ulData)
{
    /*
    In WinHelp we put up a little menu for this message. In HTML Help we don't.
    So we remove the menu and just handle this like HH_TP_HELP_WM_HELP.
    */
    return doTpHelpWmHelp(hwndMain, pszFile, ulData) ;
/*
    ASSERT(IsWindow(hwndMain)) ;

    // Create the menu.
    HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_WHATSTHIS_MENU)) ;
    ASSERT(hMenu) ;

    // Get the Popup Menu
    HMENU hPopupMenu = GetSubMenu(hMenu, 0) ;

    //--- Get the location to display the menu
    POINT pt ;
    // Use the mouse cursor position.
    GetCursorPos(&pt) ;

    // Set the style of the menu.
    DWORD style = TPM_LEFTALIGN  | TPM_TOPALIGN | TPM_NONOTIFY | TPM_RETURNCMD ;

    // Display the menu.
    int iCmd = TrackPopupMenuEx(hPopupMenu,
                                style ,
                                pt.x, pt.y,
                                g_hwndApi ? g_hwndApi : hwndMain, // We have to have a window in the current thread!
                                NULL) ;
#ifdef _DEBUG
        DWORD err ;
        if (iCmd == 0)
        {
            err = ::GetLastError() ;
        }
#endif

    // Cleanup
    DestroyMenu(hMenu) ;

    // Act on the item.
    if (iCmd == IDM_WHATSTHIS)
    {
        return doTpHelpWmHelp(hwndMain, pszFile, ulData) ;
    }
    else
    {
        return NULL ;
    }
*/
}

///////////////// Dialog control parsing from helpcall.c in user32 ///////

const int MAX_ATTEMPTS = 5;       // maximum -1 id controls to search through

HWND doTpHelpWmHelp(HWND hwndMain, LPCSTR pszFile, DWORD_PTR ulData)
{
    int id = GetDlgCtrlID(hwndMain);   // get control id
    int idSave = id;

    DWORD* pid = (DWORD*) ulData;

    if ((short) id == -1)
    {   // static control?
        HWND hwndCtrl = hwndMain;
        int cAttempts = 0;

        // For non-id controls (typically static controls), step
        // through to the next tab item. Keep finding the next tab
        // item until we find a valid id, or we have tried
        // MAX_ATTEMPTS times.

        do
        {
            hwndCtrl = GetNextWindow(hwndCtrl, GW_HWNDNEXT);

            // hwndCtrl will be NULL if hwndMain doesn't have a parent,
            // or if there are no tab stops.

            if (!hwndCtrl)
            {
                DBWIN("GetNextDlgHelpItem failed.");
                return NULL;
            }

            id = GetDlgCtrlID(hwndCtrl);
        }
        while ((id == -1) && (++cAttempts < MAX_ATTEMPTS));
    }

    // Find the id value in array of id/help context values

    for (int i = 0; pid[i]; i += 2)
    {
        if ((int) pid[i] == id)
            break;
    }

    // Create a popup structure to pass to doDisplayTextPopup.
    HH_POPUP popup ;
    memset(&popup, 0, sizeof(popup)) ;

    // We want the default window size.
    popup.pt.x = -1 ;
    popup.pt.y = -1 ;

    // We want the default margins.
    popup.rcMargins.top =
    popup.rcMargins.bottom =
    popup.rcMargins.left =
    popup.rcMargins.right = -1 ;

    if (!pid[i])
    {
        popup.hinst = _Module.GetResourceInstance();

        switch (id) {
            case IDOK:
                popup.idString = IDS_IDH_OK;
                break;

            case IDCANCEL:
                popup.idString = IDS_IDH_CANCEL;
                break;

            case IDHELP:
                popup.idString = IDS_IDH_HELP;
                break;

            default:
                if (IsHelpAuthor(NULL))
                {
                    char szMsgBuf[256];
                    wsprintf(szMsgBuf,
                        pGetDllStringResource(IDS_HHA_MISSING_HELP_ID), idSave);
                    doAuthorMsg(IDS_IDH_GENERIC_STRING, szMsgBuf);
                }
                popup.idString = IDS_IDH_MISSING_CONTEXT;
                break;
        }
        return doDisplayTextPopup(hwndMain, NULL, &popup) ;
    }
    else
    {
        ulData = pid[i + 1];
        if (ulData == (DWORD) -1)
            return NULL;   // caller doesn't want help after all
        if (IsHelpAuthor(NULL))
        {
            char szMsgBuf[256];
            wsprintf(szMsgBuf, pGetDllStringResource(IDS_HHA_HELP_ID),
                (int) pid[i], (int) pid[i + 1], pszFile);
            SendStringToParent(szMsgBuf);
        }

        // Set the id of the string that we want.
        popup.idString = (UINT)ulData;

        return doDisplayTextPopup(hwndMain, pszFile, &popup) ;
    }
}

/////////////////////////////////////////////////////////////////////
//
// doDisplaytextPopup
//
HWND
doDisplayTextPopup(HWND hwndMain, LPCSTR pszFile, HH_POPUP* pPopup)
{
    if (!g_pPopupWindow)
    {
        g_pPopupWindow = new CPopupWindow;
    }
    g_pPopupWindow->CleanUp();

    return g_pPopupWindow->CreatePopupWindow(hwndMain, pszFile, pPopup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sampinit.h ===
#ifndef _SAMPINIT_H_
#define _SAMPINIT_H_

// IT GUID for parsing URLs (used for sample download)
//
// {9D148290-B9C8-11d0-A4CC-0000F80149F6}
DEFINE_GUID(CLSID_PARSE_URL, 
0x9d148290, 0xb9c8, 0x11d0, 0xa4, 0xcc, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

#endif //_SAMPINIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hhctrl.RC
//
#define ID_BROWSE                       3
#define ICONHTMLHELP                    5
#define IDC_COLLAPSE                    99
#define IDC_EDIT                        100
#define IDC_LIST                        101
#define IDDLG_JUMP_URL                  101
#define IDICO_HTMLHELP                  103
#define RESID_TOOLBOX_BITMAP            104
#define IDCUR_HAND                      105
#define IDDLG_ABOUTBOX                  106
#define IDDLG_RELATED_TOPICS            107
#define IDBMP_CNT_IMAGE_LIST            108
#define IDDLG_CUSTOMIZE_BOTH_INFOTYPES  108
#define IDPAGE_CONTENTS                 109
#define IDPAGE_TAB_INDEX                110
#define IDEDIT_JUMP_URL                 111
#define IDDLG_CUSTOMIZE_INFOTYPES       111
#define IDEDIT_CUR_URL                  112
#define IDDLG_DUP_INFOTYPE              112
#define IDPAGE_INFOTYPE_INTRO           113
#define IDPAGE_INFOTYPE_FINISH          114
#define IDPAGE_INFOTYOE_CUSTOM_INCLUSIVE 115
#define IDWIZ_INFOTYPE_INTRO            116
#define IDWIZ_INFOTYPE_FINISH           117
#define IDWIZ_INFOTYPE_CUSTOM_INCLUSIVE 118
#define IDWIZ_INFOTYPE_CUSTOM_EXCLUSIVE 119
#define IDDLG_PROGRESS                  120
#define ID_PROGRESS                     121
#define IDC_SAMPLE_LB                   201
#define IDD_SAMPLE_DLG                  202
#define IDC_SAMPLE_COPYALL              203
#define IDC_SAMPLE_VIEW                 204
#define IDC_SAMPLE_COPY                 205
#define IDBMP_IMAGE_LIST_BIDI           206
#define IDD_SAMPLE_COPY_DLG             300
#define IDD_DRIVELIST                   302
#define IDD_DIRNAME                     304
#define IDD_DIRLIST                     305
#define IDD_FILELIST                    306
#define IDD_COPYING_TO                  307
#define IDD_NETWORK                     308
#define IDD_FOLD_POINT                  310
#define IDD_HELP_TEXT                   311
#define DISKTREE                        312
#define DISKTREEM                       313
#define IDS_SAMPLE_COPY_COMPLETE        400
#define IDS_SAMPLE_COPY_ERRORS          401
#define IDS_SAMPLE_CAPTION              402
#define IDS_CONFIRM_MKDIR               403
#define IDS_WHY_COPY                    404
#define IDS_SAMPLE_VIEW_ERRORS          407
#define IDS_SAMPLE_LOAD_ERROR           408
#define IDS_SAMPLE_DATA_NOT_FOUND       409
#define IDS_IV_AUTOMATION               410
#define IDS_IV_NOT_RUNNING              411
#define IDS_SHARE_VIOLATION             412
#define IDS_ERROR_COPYING               413
#define IDS_SAMPLE_ERROR                414
#define IDS_SAMPLE_OVERWRITE            415
#define IDS_FILE_COPY                   416
#define IDS_NO_SPACE                    417
#define IDS_CREATING_INDEX              450
#define IDS_CHECKING_INDEX              451
#define IDS_COMPILEDHTMLFILE            452
#define IDBMP_CHECK                     500
#define IDBMP_TOOLBAR                   501
#define IDBMP_INFOTYPE_WIZARD           505
#define IDBMP_BOOK                      510
#define IDBMP_PENS                      511
#define IDB_TOOLBAR16G                  512
#define IDB_TOOLBAR16                   513
#define IDD_BROWSE                      514
#define IDC_CONTENTS_INSTRUCTIONS       1000
#define IDC_IMAGE                       1000
#define IDC_DEFINE_SUBSET               1000
#define IDC_ADVSRC_SUBSET_BTN           1000
#define ID_TREEVIEW                     1001
#define IDC_LINE1                       1001
#define IDC_TOPIC_LIST                  1001
#define IDC_SEARCHTERM_COMBO            1001
#define IDC_ADVSRC_KEYWORD_COMBO        1001
#define IDC_LINE2                       1002
#define IDC_DUP_TEXT                    1002
#define IDC_SUBSET_COMBO                1002
#define IDC_ADVSRC_SUBSET_COMBO         1002
#define IDC_LINE3                       1003
#define IDM_WINDOW_INFO                 1004
#define IDM_VERSION                     1005
#define ID_TOOLBAR                      1006
#define IDC_START_SEARCH                1006
#define IDC_ADVSRC_SEARCH_BTN           1006
#define ID_TAB_CONTROL                  1007
#define IDC_OPTIONS_CHECK_SIMILAR       1007
#define IDC_ADVSRC_SIMILAR_CHECK        1007
#define IDC_OPTIONS_CHECK_TITLESONLY    1008
#define IDC_ADVSRC_TITLESONLY_CHECK     1008
#define IDC_DISPLAY_TOPC                1009
#define IDC_ADVSRC_DISPLAY_BTN          1009
#define IDC_CONJUNCTIONS                1010
#define IDC_ADVSRC_CONJUNCTIONS_BTN     1010
#define IDC_HELP_TEXT                   1089
#define IDC_TREE1                       1090
#define IDC_CLOSE                       1092
#define IDC_SAVE                        1093
#define IDC_REMOVE                      1094
#define IDC_LIST_SUBSETS                1095
#define IDC_SUBSET_NAME                 1096
#define IDTXT_INTRODUCTION              1100
#define IDTXT_INCLUSIVE                 1101
#define IDLB_INCLUSIVE                  1102
#define IDBTN_SELECT_ALL                1103
#define IDTXT_DESCRIPTION               1104
#define IDC_LIST2                       1105
#define IDLB_INFO_TYPES                 1106
#define IDBTN_CUSTOMIZE                 1107
#define IDRADIO_ALL                     1108
#define IDRADIO_TYPICAL                 1109
#define IDRADIO_CUSTOM                  1110
#define IDC_SUBSET_TEXT                 1323
#define IDDLG_TOC_PRINT                 2000
#define IDPAGE_HISTORY                  2001
#define IDPAGE_SIMPLE_SEARCH            2001
#define IDDLG_CANCEL_PRINT              2003
#define IDD_REMOVEABLE_MEDIA_PROMPT     2004
#define IDPAGE_TAB_ADVANCED_SEARCH      2005
#define IDI_CDROM                       2006
#define IDI_DISK350                     2007
#define IDI_DISK525                     2008
#define IDDLG_HH_DEFINESUBSET           2013
#define IDB_BITMAP1                     2017
#define IDBMP_HH_SS_IMAGE_LIST          2017
#define IDD_SUBSET_NAME                 2018
#define IDDLG_CHOOSE_SUBSETS            2019
#define IDPAGE_TAB_BOOKMARKS            2020
#define IDM_BOOKMARKS_OPTIONS_MENU      2023
#define IDD_DIALOG1                     2024
#define IDB_ABOUT                       2026
#define IDD_ABOUT                       2027
#define IDR_WHATSTHIS_MENU              2028
#define IDD_SAMPLE_EXIST                2029
#define IDD_SEARCH_CANCEL               2030
#define IDRADIO_PRINT_CURRENT           3000
#define IDRADIO_PRINT_BOOK              3001
#define IDRADIO_PRINT_ALL               3002
#define IDEDIT_INDEX                    3003
#define IDLB_INDEX                      3004
#define IDEDIT_URL                      3005
#define IDBTN_DISPLAY                   3006
#define IDSTATIC_URL                    3007
#define IDBTN_ADD                       3008
#define IDSEARCH_EDIT                   3011
#define IDSEARCH_LIST                   3013
#define ID_BTN_LIST_TOPICS              3014
#define IDBTN_LIST_TOPICS               3015
#define ID_STATIC_SELECT_TOPIC          3017
#define ID_STATIC_KEYWORDS              3018
#define IDSIMPLESEARCH_COMBO            3024
#define IDC_LOCATION_PATH               3025
#define IDC_LOCATION_NAME               3026
#define IDC_REMOVABLE_MEDIA_ICON        3027
#define IDC_RESULTS_LIST                3028
#define IDC_ADVSRC_RESULTS_LIST         3028
#define IDC_STATIC_SELECT               3030
#define IDC_ADVSRC_STATIC_SELECT        3030
#define IDC_STATIC_FOUND                3031
#define IDC_ADVSRC_FOUND_STATIC         3031
#define IDC_STATIC_SEARCH               3032
#define IDC_ADVSRC_STATIC_SEARCH        3032
#define IDC_ADVSRC_SEARCHIN_STATIC      3032
#define IDCOMBO_TOC                     3033
#define IDCOMBO_INDEX                   3034
#define IDCOMBO_SEARCH                  3035
#define IDC_BOOKMARKS_TOPICS_STATIC     3036
#define IDC_BOOKMARKS_TOPICS_LISTVIEW   3037
#define IDC_BOOKMARKS_DELETE_BTN        3038
#define IDC_BOOKMARKS_DISPLAY_BTN       3039
#define IDC_BOOKMARKS_CURRENTTOPIC_STATIC 3040
#define IDC_BOOKMARKS_CURRENTTOPIC_EDIT 3041
#define IDC_BOOKMARKS_ADDBOOKMARK_BTN   3042
#define IDC_VERSION                     3043
#define IDC_LIST1                       3044
#define IDC_TOPICS                      3044
#define IDC_SUBSET_GROUP                3045
#define IDC_APPLY                       3046
#define IDC_NAME_SUBSET                 3048
#define IDC_DEFINED                     3049
#define IDC_TOC                         3053
#define IDC_LINKS                       3054
#define IDC_FTS                         3055
#define IDC_ADVSRC_PREVIOUS_CHECK       3056
#define IDC_OVERWRITE_YN                3059
#define IDF_SAVE_EC                     3060
#define IDC_BOOKMARKS_EDIT_BTN          4001
#define ID_TOOLS_FAVORITES              4003
#define IDTB_ZOOM_LARGEST               4005
#define IDTB_ZOOM_LARGER                4006
#define IDTB_ZOOM_MEDIUM                4007
#define IDTB_ZOOM_SMALLER               4008
#define IDTB_ZOOM_SMALLEST              4009
#define IDM_WHATSTHIS                   4010
#define IDGA_NEXT_NAV_TAB               4011
#define IDGA_PREV_NAV_TAB               4012
#define HH_MENU                         6000
#define HHM_PRINT                       6001
#define HHM_EXIT                        6002
#define HHM_COPY                        6003
#define HHM_FIND                        6004
#define HHM_SYNC                        6005
#define HHM_HOMEPAGE                    6006
#define HHM_CONTENTS                    6007
#define HHM_INDEX                       6008
#define HHM_SEARCH                      6009
#define HHM_DEFINE_ITP                  6010
#define HHM_SELECT_ITP                  6011
#define HHM_OPTIONS                     6012
#define HHM_ABOUT                       6013
#define HHM_JUMP_URL                    6014
#define HHM_HIDE_SHOW                   6015
#define HH_ACCELERATORS                 6017
#define HHM_FAVORITES                   6018
#define HHM_LIB_HELP                    6019
#define HHM_DEV_ONLINE                  6020
#define HHM_SELECTALL                   6021
#define HHM_VIEWSOURCE                  6022
#define IDGA_TOGGLE_PANE                6023
#define HHM_SEARCHHILITE                6024
#define IDGA_F1_LOOKUP                  6025
#define HHM_DEFINE_SUBSET               6026
#define DLG_FILTERS                     6180
#define IDF_RANGES                      6181
#define IDF_CLOSE                       6182
#define IDF_SAVE                        6183
#define IDF_DELETE                      6184
#define IDF_AVAIL                       6185
#define IDF_ADD                         6186
#define IDF_ADDALL                      6187
#define IDF_REMOVE                      6188
#define IDF_REMOVEALL                   6189
#define IDF_RANGE                       6190
#define IDF_NEW                         6191
#define IDS_PERSIST_SUBSET_ERR          6192
#define IDC_SS_PICKER                   6193
#define IDC_SS_COMBO                    6194
#define IDS_CONFIRM_SSDELETE            6195
#define IDC_STATIC                      -1
#define IDC_ADVSRC_KEYWORD_STATIC       65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        2031
#define _APS_NEXT_COMMAND_VALUE         4014
#define _APS_NEXT_CONTROL_VALUE         3062
#define _APS_NEXT_SYMED_VALUE           5000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\prthook.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __PRTHOOK_H__
#define __PRTHOOK_H__

class CContainer;                       // forward reference
class CSiteMap;                         // forward reference
class IWebBrowserAppImpl;       // forward reference
class CHHWinType;                       // forward reference

class CPrintHook : public IDispatch
{
public:
    CPrintHook(PCSTR pszFirstUrl, CToc* pToc, HWND hWndHelp = NULL);
    ~CPrintHook();
    void BeginPrinting(int action);
    inline BOOL IsPrinting() {return m_fIsPrinting;}
    inline void IsPrinting(BOOL bNewValue) {m_fIsPrinting = bNewValue;}

    STDMETHOD(QueryInterface)(
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void  **ppvObject);

    STDMETHOD_(ULONG, AddRef)(void);

    STDMETHOD_(ULONG, Release)(void);

    // IDispatch methods.

    STDMETHOD(GetTypeInfoCount)(
        /* [out] */ UINT *pctinfo);

    STDMETHOD(GetTypeInfo)(
        /* [in] */ UINT iTInfo,
        /* [in] */ LCID lcid,
        /* [out] */ ITypeInfo **ppTInfo);

    STDMETHOD(GetIDsOfNames)(
        /* [in] */ REFIID riid,
        /* [size_is][in] */ LPOLESTR *rgszNames,
        /* [in] */ UINT cNames,
        /* [in] */ LCID lcid,
        /* [size_is][out] */ DISPID *rgDispId);

    STDMETHOD(Invoke)(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID riid,
        /* [in] */ LCID lcid,
        /* [in] */ WORD wFlags,
        /* [out][in] */ DISPPARAMS *pDispParams,
        /* [out] */ VARIANT  *pVarResult,
        /* [out] */ EXCEPINFO  *pExcepInfo,
        /* [out] */ UINT  *puArgErr);

protected:
    BOOL CreatePrintWindow(CStr* pcszUrl = NULL);
    void DestroyPrintWindow();
    BOOL PumpMessages();
    BOOL BuildPrintTable();
    HRESULT Print();
    BOOL ConstructFile(PCSTR pszCurrentUrl, CTable* pFileTable, CStr* pcszPrintFile);
    BOOL TranslateUrl(PSTR pszFullUrl, PSTR pszRelUrl);

    void OnProgressChange(LONG lProgress, LONG lProgressMax);

    CToc* m_pToc;
    CStr m_cszFirstUrl, m_cszPath, m_cszRoot, m_cszPrintFile;
    CHHWinType* m_phh;
    LPCONNECTIONPOINT m_pcp;
    DWORD m_dwCookie;
    ULONG m_ref;
    HWND m_hWndHelp;
    int m_pos, m_action;
    BOOL m_fIsPrinting, m_fFirstHeading, m_fDestroyHelpWindow, m_fIsIE3;
    BYTE m_level;
    TCHAR m_szPrintFile[_MAX_PATH];
    HWND m_hwndParent;
};

#endif // __PRTHOOK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\rescache.h ===
#ifndef __RESCACHE_H__
#define __RESCACHE_H__
//////////////////////////////////////////////////////////////////////////
//
//
// rescache.h --- Header file for CResourceCache
//
//
/*
   CResourceCache is a class which contains functions for all the globally cached resources
   such as fonts, accelerators etc.

    All of these functions initialize on demand.
*/

//////////////////////////////////////////////////////////////////////////
//
// Constants
//

// Number of global accelerators. Is the number of tabs, plus 1 for the options button.
const int c_NumTabCtrlKeys = (HH_MAX_TABS+1) + 1 ;

enum {
    ACCEL_KEY_OPTIONS = HH_MAX_TABS+1 // The index into the TabCtrlKeys arrary for the options btn.
};

//////////////////////////////////////////////////////////////////////////
//
// CResourceCache
//
class CResourceCache
{
public:

    // Constuctor
    CResourceCache() ;

    // Destruct
    ~CResourceCache() ;

public:
    //--- Access Functions
    char*   MsgBoxTitle() ; // title for author message boxes
    HFONT   GetUIFont() ; // default font to use for listbox, buttons, etc.
    HFONT   GetAccessableUIFont() ; // A UI font that respects current accessability settings.
    HFONT   DefaultPrinterFont(HDC hDC);
    HACCEL  AcceleratorTable();
    char    TabCtrlKeys(int TabIndex) ; // tab ctrl accelerator keys.

    //--- Other functions.
    void  TabCtrlKeys(int TabIndex, char) ; //Sets an accelerator key. Only used for custom tabs.
    void  InitRichEdit();                   // Loads Riched20.dll, needed for multilingual (wide edit controls).


private:
    //--- Initialization functions
    void InitMsgBoxTitle() ;
    void InitDefaultUIFont(HDC hDC = NULL, HFONT* hFont = NULL) ;
    void InitAcceleratorTable();
    void InitTabCtrlKeys() ;

private:
    //--- Member variables.
    char*     m_pszMsgBoxTitle ;
    HFONT     m_hUIFontDefault ;
    HFONT     m_hUIAccessableFontDefault;
    HACCEL    m_hAccel;
    HINSTANCE m_hInstRichEdit;

    bool    m_bInitTabCtrlKeys ; // Controls initializing the tab ctrl keys.
    char    m_TabCtrlKeys[c_NumTabCtrlKeys]; // Will IsDialogMessage fix this?
};

//////////////////////////////////////////////////////////////////////////
//
// globals.
//
extern CResourceCache _Resource ;

//////////////////////////////////////////////////////////////////////////
//
//          Inline Functions
//
//////////////////////////////////////////////////////////////////////////
//
//  MsgBoxTitle
//
inline char*
CResourceCache::MsgBoxTitle()
{
    if (!m_pszMsgBoxTitle)
        InitMsgBoxTitle() ;
    return m_pszMsgBoxTitle ;
}

inline HFONT
CResourceCache::GetUIFont()
{
    if (!m_hUIFontDefault)
        InitDefaultUIFont() ;
    return m_hUIFontDefault;
}

inline HFONT
CResourceCache::GetAccessableUIFont()
{
    if (!m_hUIAccessableFontDefault)
        InitDefaultUIFont() ;
    return m_hUIAccessableFontDefault;
}

inline HFONT
CResourceCache::DefaultPrinterFont(HDC hDC)
{
    HFONT hFont;
    InitDefaultUIFont(hDC, &hFont);
    return hFont;
}

inline HACCEL
CResourceCache::AcceleratorTable()
{
    if (!m_hAccel)
        InitAcceleratorTable();
    return m_hAccel ;
}

inline char
CResourceCache::TabCtrlKeys(int TabIndex)
{
    if (TabIndex < 0 || TabIndex > c_NumTabCtrlKeys)
    {
        return 0 ;
    }

    if (!m_bInitTabCtrlKeys)
        InitTabCtrlKeys() ;
    return m_TabCtrlKeys[TabIndex] ;
}


#endif //__RESCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\rescache.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//
// rescache.cpp --- Implementation file for CResourceCache
//
//
/*
*/
//////////////////////////////////////////////////////////////////////////
//
// Includes
//
#include "header.h"

// String Ids.
#include "strtable.h"

// Resource IDs
#include "resource.h"

//Our header
//#include "rescache.h"

//////////////////////////////////////////////////////////////////////////
//
// Globals
//
CResourceCache _Resource ;

//////////////////////////////////////////////////////////////////////////
//
// CResourceCache
//
//////////////////////////////////////////////////////////////////////////
//
// Constuctor
//
CResourceCache::CResourceCache()
: m_pszMsgBoxTitle(NULL),
    m_hUIFontDefault(NULL),
    m_hAccel(NULL),
    m_bInitTabCtrlKeys(false),
    m_hInstRichEdit(0),
    m_hUIAccessableFontDefault(NULL)
{
}

//////////////////////////////////////////////////////////////////////////
//
// Destruct
//
CResourceCache::~CResourceCache()
{
    CHECK_AND_FREE( m_pszMsgBoxTitle );

    if ( m_hUIAccessableFontDefault && (m_hUIAccessableFontDefault != m_hUIFontDefault) )
    {
        DeleteObject(m_hUIAccessableFontDefault);
    }

    if (m_hUIFontDefault)
    {
        DeleteObject(m_hUIFontDefault);
    }

    // Get rid of our accelerator table.
    if (m_hAccel)
    {
        DestroyAcceleratorTable(m_hAccel);
    }

    if (m_hInstRichEdit)
    {
       FreeLibrary(m_hInstRichEdit);
    }
}

//////////////////////////////////////////////////////////////////////////
//
//                  Initialization Functions
//
//////////////////////////////////////////////////////////////////////////
//
// InitMsgBoxTitle
//
void
CResourceCache::InitMsgBoxTitle()
{
    ASSERT(m_pszMsgBoxTitle == NULL) ;
    m_pszMsgBoxTitle = lcStrDup(GetStringResource(IDS_MSGBOX_TITLE));
}

/////////////////////////////////////////////////////////////////////////
//
//  Init the RichEdit control if we need it.
//
void
CResourceCache::InitRichEdit()
{
   if ( (m_hInstRichEdit == 0) && (GetVersion() > 0x80000000) )
      m_hInstRichEdit = LoadLibrary("riched20.dll");
}

//////////////////////////////////////////////////////////////////////////
//
// InitAcceleratorTable
//
void
CResourceCache::InitAcceleratorTable()
{
    // Create the accelerator table.
    ASSERT(m_hAccel == NULL) ;
    m_hAccel = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(HH_ACCELERATORS));
    ASSERT(m_hAccel) ;
}

#if 0

//////////////////////////////////////////////////////////////////////////
//
// InitDefaultFont
//
void
CResourceCache::InitDefaultFont(HDC hDC, HFONT* phFont)
{
    HFONT hFont;

    if (! phFont )
    {
       ASSERT(m_hfontDefault == NULL) ;
       if ( m_hfontDefault )
          return;
    }

    // Create a default font from our resource file
    int dyHeight = 0;
    PSTR pszFontName = (PSTR) GetStringResource(IDS_DEFAULT_RES_FONT);

    HWND hwndDesktop = GetDesktopWindow();
    HDC hdc = GetDC(hwndDesktop);
    int YAspectMul;
    if (!hdc)
    {
        ASSERT(0) ; //TODO: Fix
        return ;
    }

    // Get current text metrics
    TEXTMETRIC tm;
    GetTextMetrics(hdc, &tm);
    WORD defcharset = (WORD) tm.tmCharSet;
    YAspectMul = GetDeviceCaps(hDC?hDC:hdc, LOGPIXELSY);
    ReleaseDC(hwndDesktop, hdc);

    PSTR pszPoint = StrChr(pszFontName, ',');
    if (pszPoint)
    {
        *pszPoint = '\0';
        pszPoint = FirstNonSpace(pszPoint + 1);
        if (IsDigit((BYTE) *pszPoint))
        {
            dyHeight = MulDiv(YAspectMul, Atoi(pszPoint) * 2, 144);
        }
    }

    if (!dyHeight)
        dyHeight = YAspectMul / 6;

    if(g_langSystem == LANG_RUSSIAN)
       defcharset = RUSSIAN_CHARSET;

    // For non-localized OCX on DBCS platforms, we need to increase font size by one point
    //
    if (g_fDBCSSystem && CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE, pszFontName,-1,"Arial",-1) == 2)
        dyHeight++; // increase size by one point

    if (g_langSystem == LANG_THAI &&
        CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE, pszFontName,-1,"Arial",-1) == 2)
    {
      LONG dyHeightThai = MulDiv(YAspectMul, dyHeight * 2, 144);
        hFont = CreateFont(-(dyHeightThai+1), 0, 0, 0, 0, 0, 0, 0,
            THAI_CHARSET, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
            DEFAULT_PITCH | FF_DONTCARE, "Angsana New"); //"AngsanaUPC");
    }
    else
    if (g_langSystem == LANG_JAPANESE &&
        CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE, pszFontName,-1,"Arial",-1) == 2)
    {
        hFont = CreateFont(-dyHeight, 0, 0, 0, 0, 0, 0, 0,
            SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
            VARIABLE_PITCH | FF_MODERN, "MS P-Gothic");
    }
   else
    if (g_langSystem == LANG_CHINESE &&
        CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE, pszFontName,-1,"Arial",-1) == 2)
    {
        hFont = CreateFont(-dyHeight, 0, 0, 0, 0, 0, 0, 0,
            defcharset, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
            VARIABLE_PITCH | FF_MODERN, "");
    }
    else
    {
        hFont = CreateFont(-dyHeight, 0, 0, 0, 0, 0, 0, 0,
            defcharset, OUT_DEFAULT_PRECIS,
            CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
            VARIABLE_PITCH | FF_MODERN, pszFontName);
    }
    ASSERT(hFont);
    if ( phFont )
       *phFont = hFont;
    else
       m_hfontDefault = hFont;

#ifdef _DEBUG
    LOGFONT lf ;
    int r = GetObject(m_hfontDefault, sizeof(lf), &lf) ;
#endif
}

#endif

//////////////////////////////////////////////////////////////////////////
//
// InitDefaultUIFont
//
// Init the font that will be used to render all strings that come from hhctrl.ocx resources.
//
void
CResourceCache::InitDefaultUIFont(HDC hDC, HFONT* phFont)
{
    HFONT hFont;
    HDC hdc;
    int dyHeight = 0;
    int YAspectMul;
    WORD CharsetSpec = 0;
    WORD DefCharset;
    int iFontSpecResID = IDS_DEFAULT_RES_FONT;
    PSTR pszFontName;
    WCHAR *pwsFontName;

    if (! phFont )
    {
       ASSERT(m_hUIFontDefault == NULL) ;
       if ( m_hUIFontDefault )
          return;
    }
    // Create a default font from our resource file. We use a different resource font spec depending
    // on OS...
    //
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);

#ifdef _DEBUG
    char* sz1, *sz2, *sz3;
    char szBuf[256];
    char szBuf2[256];
    if ( (GetKeyState(VK_SHIFT) < 0) )
    {
       sz1 = (PSTR)GetStringResource(IDS_DEFAULT_RES_FONT_NT5_WIN98);
       sz2 = (PSTR)GetStringResource(IDS_DEFAULT_RES_FONT);
       if ( _Module.m_Language.LoadSatellite() )
       {
           LANGID lid = _Module.m_Language.GetUiLanguage();
           wsprintf(szBuf2, "Operating from Satalite DLL resources: mui\\%04x", lid);
           sz3 = szBuf2;
       }
       else
          sz3 = "Operating from hhctrl.ocx reources";
       wsprintf(szBuf, "NT5/Win98 UIFont = %s\nNT4/Win95 UIFont = %s\n%s\n", sz1, sz2, sz3);
       MsgBox(szBuf, MB_OK);
    }
#endif

    if ( (osvi.dwMajorVersion) == 5 || ((osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) && (osvi.dwMinorVersion == 10)) )
       iFontSpecResID = IDS_DEFAULT_RES_FONT_NT5_WIN98;

    if (g_bWinNT5)	
    {
        if (! (pwsFontName = (WCHAR *) GetStringResourceW(iFontSpecResID)) || *pwsFontName == '\0' )
        {
            if (! (pwsFontName = (WCHAR *)GetStringResourceW(IDS_DEFAULT_RES_FONT)) || *pwsFontName == '\0' )
                pwsFontName = L"MS Shell Dlg,8,0";
        }
        if (! (hdc = GetDC(NULL)) )
        {
            ASSERT(0) ;
            return ;
        }
        // Get current text metrics
        //
        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        DefCharset = (WORD) tm.tmCharSet;
        YAspectMul = GetDeviceCaps(hDC?hDC:hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
        
        WCHAR *pwsComma = StrChrW(pwsFontName, ',');          // Get point size specification.
        if (pwsComma)
        {
            *pwsComma = '\0';
            pwsComma = FirstNonSpaceW(pwsComma + 1);
            if (IsDigit((BYTE) *pwsComma))
            {
                int hx = _wtoi(pwsComma);
                
                dyHeight = MulDiv(YAspectMul, hx * 2, 144);
            }
        }
        if ( (pwsComma = StrChrW(pwsComma, ',')) )          // Get charset specification.
        {
            pwsComma = FirstNonSpaceW(pwsComma + 1);
            if (iswdigit((BYTE) *pwsComma))
            {
                // This indicates we are using a satalite DLL which means we want to trust the charset spec.
                //
                if ( _Module.m_Language.LoadSatellite() )
                    DefCharset = (CHAR)_wtoi(pwsComma);
            }
        }
    }
    else
    {
        if (! (pszFontName = (PSTR) GetStringResource(iFontSpecResID)) || *pszFontName == '\0' )
        {
            if (! (pszFontName = (PSTR)GetStringResource(IDS_DEFAULT_RES_FONT)) || *pszFontName == '\0' )
                pszFontName = "MS Shell Dlg,8,0";
        }
        if (! (hdc = GetDC(NULL)) )
        {
            ASSERT(0) ;
            return ;
        }
        // Get current text metrics
        //
        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        DefCharset = (WORD) tm.tmCharSet;
        YAspectMul = GetDeviceCaps(hDC?hDC:hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
        
        PSTR pszComma = StrChr(pszFontName, ',');          // Get point size specification.
        if (pszComma)
        {
            *pszComma = '\0';
            pszComma = FirstNonSpace(pszComma + 1);
            if (IsDigit((BYTE) *pszComma))
            {
                int hx = Atoi(pszComma);
                
                dyHeight = MulDiv(YAspectMul, hx * 2, 144);
            }
        }
        if ( (pszComma = StrChr(pszComma, ',')) )          // Get charset specification.
        {
            pszComma = FirstNonSpace(pszComma + 1);
            if (IsDigit((BYTE) *pszComma))
            {
                // This indicates we are using a satalite DLL which means we want to trust the charset spec.
                //
                if ( _Module.m_Language.LoadSatellite() )
                    DefCharset = (CHAR)Atoi(pszComma);
            }
        }
    }
    if (!dyHeight)
        dyHeight = YAspectMul / 6;

    // Why is this here? We should have the correct defcharset from GetTextMetrics above correct?
    //
    if( g_langSystem == LANG_RUSSIAN )
       DefCharset = RUSSIAN_CHARSET;

    NONCLIENTMETRICS ncm;    

    // If we need to detect non-localized OCX on DBCS platforms, we need can use DefCharset vs CharsetSpec
    // to see if they differ. <mikecole>
    //
    if (g_bWinNT5)	
    {
        
        hFont = CreateFontW(-dyHeight, 0, 0, 0, 0, 0, 0, 0, DefCharset, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
            DEFAULT_QUALITY, VARIABLE_PITCH | FF_MODERN, pwsFontName);
        
        ncm.cbSize = sizeof(NONCLIENTMETRICS);
        BOOL bRet = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), (void*)&ncm, 0);
        if ( bRet && (ncm.lfMenuFont.lfHeight < (-dyHeight)) )
        {
            m_hUIAccessableFontDefault = CreateFontW(ncm.lfMenuFont.lfHeight, 0, 0, 0, 0, 0, 0, 0, DefCharset,
                OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                VARIABLE_PITCH | FF_MODERN, pwsFontName);
        }
        else
            m_hUIAccessableFontDefault = hFont;
    }
    else
    {
        hFont = CreateFont(-dyHeight, 0, 0, 0, 0, 0, 0, 0, DefCharset, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
            DEFAULT_QUALITY, VARIABLE_PITCH | FF_MODERN, pszFontName);
        
        ncm.cbSize = sizeof(NONCLIENTMETRICS);
        BOOL bRet = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), (void*)&ncm, 0);
        if ( bRet && (ncm.lfMenuFont.lfHeight < (-dyHeight)) )
        {
            m_hUIAccessableFontDefault = CreateFont(ncm.lfMenuFont.lfHeight, 0, 0, 0, 0, 0, 0, 0, DefCharset,
                OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                VARIABLE_PITCH | FF_MODERN, pszFontName);
        }
        else
            m_hUIAccessableFontDefault = hFont;
    }
    ASSERT(hFont);
    if ( phFont )
       *phFont = hFont;
    else
       m_hUIFontDefault = hFont;

#ifdef _DEBUG
    LOGFONT lf ;
    int r = GetObject(m_hUIFontDefault, sizeof(lf), &lf) ;
#endif
}


//////////////////////////////////////////////////////////////////////////
//
//  InitTabCtrlKeys
//
void
CResourceCache::InitTabCtrlKeys()
{
#ifndef CHIINDEX
    ASSERT(!m_bInitTabCtrlKeys) ;

    // Zero out array
    memset(m_TabCtrlKeys, NULL, c_NumTabCtrlKeys);

    // Get the accelerators for the standard tabs
    PCSTR psz = StrChr(GetStringResource(IDS_TAB_CONTENTS), '&');
    if (psz)
        m_TabCtrlKeys[HHWIN_NAVTYPE_TOC] = ToLower(psz[1]);

    psz = StrChr(GetStringResource(IDS_TAB_INDEX), '&');
    if (psz)
        m_TabCtrlKeys[HHWIN_NAVTYPE_INDEX] = ToLower(psz[1]);

    psz = StrChr(GetStringResource(IDS_TAB_SEARCH), '&');
    if (psz)
        m_TabCtrlKeys[HHWIN_NAVTYPE_SEARCH] = ToLower(psz[1]);

    psz = StrChr(GetStringResource(IDS_TAB_HISTORY), '&');
    if (psz)
        m_TabCtrlKeys[HHWIN_NAVTYPE_HISTORY] = ToLower(psz[1]);

    psz = StrChr(GetStringResource(IDS_TAB_FAVORITES), '&');
    if (psz)
        m_TabCtrlKeys[HHWIN_NAVTYPE_FAVORITES] = ToLower(psz[1]);

    // Get the accelerators for menus and other none tab things.
    psz = StrChr(GetStringResource(IDTB_OPTIONS), '&');
    if (psz)
        m_TabCtrlKeys[ACCEL_KEY_OPTIONS] = ToLower(psz[1]);

    // Custom tab keys are initialized when the tabs are loaded.

    // Finished initialization
    m_bInitTabCtrlKeys = true ;
#endif
}

//////////////////////////////////////////////////////////////////////////
//
//                          Other Functions
//
//////////////////////////////////////////////////////////////////////////
//
// TabCtrlKeys -- Sets the tab accel keys for custom tabs
//
void
CResourceCache::TabCtrlKeys(int TabIndex, char ch)  //Sets an accelerator key. Only used for custom tabs.
{
    // Initialize, if needed.
    if (!m_bInitTabCtrlKeys)
    {
        InitTabCtrlKeys() ;
    }

    if (TabIndex >= HH_TAB_CUSTOM_FIRST && TabIndex <= HH_TAB_CUSTOM_LAST)
    {
        m_TabCtrlKeys[TabIndex] = ch ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sample.cpp ===
///////////////////////////////////////////////////////////
//
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.
//
// HIGHLITE.CPP : implementation file
//
// by DougO
//
#include "header.h"
#include "hhctrl.h"
#include "strtable.h"
#include "resource.h"
#include "hha_strtable.h"
#include "toc.h"
#include "wwheel.h"
#include "web.h"
#include <shellapi.h>
#include <wininet.h>

#include "urlmon.h"
// #include "stdlib.h"
#include "direct.h"
// #include "io.h"
#include "cdlg.h"
#include "sample.h"

// Used to lock toplevel windows before displaying a dialog.
#include "lockout.h"
#include "urlmon.h"
#include "sampinit.h"

static long GetFreeDiskSpaceInKB(LPSTR pFile);
HRESULT DownloadURL(char *pszURL, char *pszDest);

///////////////////////////////////////////////////////////
//
//                  Functions
//
///////////////////////////////////////////////////////////
//
// ProcessSample
//
BOOL ProcessSample(PCSTR szSFLFilePath,PCSTR szSampleBaseUrl,PCSTR szDialogTitle, CHtmlHelpControl* pCtl, BOOL bCompressed)
{
   CSampleDialog SD;
   HWND hwnd;

   SD.m_bCompressed = bCompressed;
   SD.m_pHtmlHelpCtl = pCtl;
   strcpy(SD.m_szDialogTitle,szDialogTitle);
   strcpy(SD.m_szSmplPath,szSampleBaseUrl);
   SetCursor(LoadCursor(NULL,IDC_WAIT));
   if(!SD.ParseDatFile((char *)szSFLFilePath))
   {
      SetCursor(LoadCursor(NULL,IDC_ARROW));
      return FALSE;
   }
   if ( pCtl->m_hwnd )
      hwnd = pCtl->m_hwnd;
   else
      hwnd = GetActiveWindow();

   // Disable all of the toplevel application windows, before we bring up the dialog.
   CLockOut LockOut ;
   LockOut.LockOut(hwnd) ;

   if(g_bWinNT5)
   {
       DialogBoxParamW(_Module.GetResourceInstance(), MAKEINTRESOURCEW(IDD_SAMPLE_DLG), hwnd,
          (DLGPROC) SampleDlgProc,(LPARAM)(&SD));
   }
   else
   {
       DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SAMPLE_DLG), hwnd,
          (DLGPROC) SampleDlgProc,(LPARAM)(&SD));
   }

#ifdef _DEBUG
    DWORD dw=GetLastError();

    dw = dw;
#endif

    return TRUE;
}

void GetSamplesDir( LPSTR lpszPath )
{
  char szPathname[_MAX_PATH];
  char szPath[_MAX_PATH];
  char szDrive[_MAX_DRIVE];

  GetModuleFileName( 0, szPathname, _MAX_PATH );
  _splitpath( szPathname, szDrive, szPath, 0, 0 );
  strcpy(lpszPath,szDrive);
  strcat(lpszPath,"\\Samples\\");
  OemToAnsi(lpszPath,lpszPath);
  AnsiLower(lpszPath);
}

CSampleDialog::CSampleDialog()
{
   TEXTMETRIC tm;
   HDC hDC;
   HBITMAP hBM,hBM2;


   m_pFirstSample = NULL;
   m_bCopyAllSamples = FALSE;
   m_szDefSamplePath[0] = 0;
   m_szURL[0] = 0;
   m_szSmplPath[0] = 0;
   m_bCompressed = TRUE;
   m_szBaseDir[0] = 0;
   m_szOemPath[0] = 0;
   m_hJapaneseFont = 0;
   m_bSetDefPath = FALSE;
   hDC = GetDC(NULL);
   GetTextMetrics(hDC,&tm);
   m_TextCharWidth = tm.tmMaxCharWidth;
   ReleaseDC(NULL,hDC);

   InitCommonControls();
   m_hImageList = ImageList_Create(16,16,ILC_COLOR4 | ILC_MASK,6,0);
   if (m_hImageList)
   {
      hBM = LoadBitmap(_Module.GetResourceInstance() ,MAKEINTRESOURCE(DISKTREE));
      hBM2 = LoadBitmap(_Module.GetResourceInstance() ,MAKEINTRESOURCE(DISKTREEM));

      ImageList_Add(m_hImageList,hBM,hBM2);
      DeleteObject(hBM);
      DeleteObject(hBM2);
   }
   if (PRIMARYLANGID(GetSystemDefaultLangID()) == LANG_JAPANESE)
   {
      HDC hDC;

      hDC = GetDC(NULL);
      if (hDC)
      {
         LOGFONT lf;

         lf.lfHeight = MulDiv(-9,GetDeviceCaps(hDC,LOGPIXELSY),72);
         lf.lfWidth = 0;
         lf.lfEscapement = 0;
         lf.lfOrientation = 0;
         lf.lfWeight = FW_NORMAL;
         lf.lfItalic = FALSE;
         lf.lfUnderline = FALSE;
         lf.lfStrikeOut = FALSE;
         lf.lfCharSet = SHIFTJIS_CHARSET;
         lf.lfOutPrecision = OUT_STRING_PRECIS;
         lf.lfClipPrecision = CLIP_STROKE_PRECIS;
         lf.lfQuality = DRAFT_QUALITY;
         lf.lfPitchAndFamily = FF_MODERN | VARIABLE_PITCH;
         strncpy(lf.lfFaceName, "lr oSVbN", LF_FACESIZE-1);
         m_hJapaneseFont= CreateFontIndirect(&lf);
      }

   }
}

CSampleDialog::~CSampleDialog()
{
   SAMPLE_DATA *ps,*qs;

   if (m_pFirstSample)
   {
      for (ps = m_pFirstSample,qs = 0;ps ; )
      {
         if (ps->pszFileName)
            lcFree(ps->pszFileName);
         qs = ps;
         ps = ps->pNext;
         lcFree(qs);
      }
      m_pFirstSample = NULL;
   }
   if (m_hImageList)
   {
      ImageList_Destroy(m_hImageList);
      m_hImageList = NULL;
   }
}

VOID CSampleDialog::AddSample(SAMPLE_DATA *p)
{
   static SAMPLE_DATA *pLast = NULL;

   if (!m_pFirstSample)
      m_pFirstSample = p;
   else
      pLast->pNext = p;
   pLast = p;

   return;
}

VOID CSampleDialog::SetAllFonts(HWND hWnd)
{
   HWND hwndT;

   for (hwndT = GetWindow(hWnd,GW_CHILD);
      hwndT;
      hwndT = GetWindow(hwndT,GW_HWNDNEXT))
      SendMessage(hwndT, WM_SETFONT, (WPARAM)_Resource.GetUIFont(), 0L);
}

BOOL CSampleDialog::ParseDatFile(char *pszSFLFile)
{
    SAMPLE_DATA * pNew;
    char szDefaultDir[MAX_PATH], szSampleDir[MAX_PATH];
    LPSTR pszFileKeys, pszTemp;
    BOOL bRet = FALSE;

    if(!m_bCompressed)
    {
        if(!GetPrivateProfileString("options","SampleDir","",szSampleDir,sizeof(szSampleDir),pszSFLFile))
        {
            return FALSE;
        }
        else
        {
            if(szSampleDir[0])
                CatPath(m_szSmplPath,szSampleDir);
            else
                return FALSE;
        }
    }

    if(!GetPrivateProfileString("options","DefaultPath","",szDefaultDir,sizeof(szDefaultDir),pszSFLFile))
    {
        // no DefaultDirectory set, use a default
        //
        strcpy(m_szDefSamplePath,"sample");
    }
    else
    {
        char *pBuffer = szDefaultDir;

        // removing leading white space
        //
        while(*pBuffer && isspace(*(unsigned char*)pBuffer))
            pBuffer = CharNext(pBuffer);

        // copy the path
        //
        strcpy(m_szDefSamplePath,pBuffer);

        pBuffer = szDefaultDir;

        // remove trailing white space
        //
        while(*pBuffer && !isspace(*(unsigned char*)pBuffer))
            pBuffer = CharNext(pBuffer);

        *pBuffer = 0;
    }

    // Get the list of sample files. Compute an appropiate buffer size based upon the size of the .SFL file.
    //
    WIN32_FIND_DATA file;
    if ( FindFirstFile(pszSFLFile, &file) == INVALID_HANDLE_VALUE )
       return FALSE;
    pszFileKeys = (LPSTR)lcMalloc(file.nFileSizeLow);

    if(!GetPrivateProfileString("files", NULL,"", pszFileKeys, file.nFileSizeLow, pszSFLFile))
        goto cleanup;
    pszTemp = pszFileKeys;
    //
    // parse each file entry
    //
    while(*pszTemp)
    {
        char szFlag[10];

        pNew = (SAMPLE_DATA*) lcMalloc(sizeof(SAMPLE_DATA));
        if (!pNew)
        {
            goto cleanup;
        }

        memset(pNew,0,sizeof(SAMPLE_DATA));
        szFlag[0] = 0;

        if(!GetPrivateProfileString("files",pszTemp,"",szFlag,sizeof(szFlag),pszSFLFile))
            pNew->iFlags = 0;
        else
        {
            char *pBuffer = szFlag;

            while(*pBuffer && isspace(*(unsigned char*)pBuffer))
                pBuffer= CharNext(pBuffer);

            if(*pBuffer == '1')
                pNew->iFlags = 1;
            else if(*pBuffer == '2')
                pNew->iFlags = 2;
            else
                pNew->iFlags = 0;
        }

        pNew->pszFileName = lcStrDup(pszTemp);

        AddSample(pNew);

        while(*pszTemp++)
            ;
    }
    bRet = TRUE;

cleanup:
    lcFree(pszFileKeys);
    return bRet;
}

UINT GetOneSel(HWND hWnd, BOOL fAny)
{
   UINT i,c,s;

   s = (UINT) LB_ERR;

   c = (UINT) SendMessage(hWnd,LB_GETCOUNT,0,0L);

   if (c == (UINT)LB_ERR)
      return((UINT)LB_ERR);

   for (i = 0; i< c; i++)
   {
      if (SendMessage(hWnd,LB_GETSEL,i,0L))
      {
         if (fAny)
            return(i);

         if (s == (UINT)LB_ERR)
            s = i;
         else
            return(UINT)LB_ERR;
      }
   }
   return(s);
}

void ECSelect(HWND hWnd, WORD id, INT type)
{
   WPARAM wParam;
   LPARAM lParam;

   if (id)
      hWnd = GetDlgItem(hWnd,id);
   if (type)
      lParam = 0x7FFFFFFF;
   else
      lParam = 0;
   if (type == 2)
      wParam = 0x7FFFFFFF;
   else
      wParam = 0;
   SendMessage(hWnd,EM_SETSEL,wParam,lParam);
}

void BackSlashToSlash(char *sz)
{
   char *p;

   for (p = sz; *p ; p = CharNext(p))  //bugbug DBCS?
   {
      if (*p == '\\')
         *p = '/';
   }
}

INT_PTR  SampleCopyProcStub(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
   CSampleDialog *pSD;

   pSD = (CSampleDialog *) GetWindowLongPtr(hWnd,GWLP_USERDATA);
   if (pSD)
      return (INT_PTR)(pSD->SampleCopyProc(hWnd,uiMsg,wParam,lParam));

   switch (uiMsg)
   {
      case WM_INITDIALOG:
           SetWindowLongPtr(hWnd,GWLP_USERDATA,lParam);
           pSD = (CSampleDialog *)lParam;
           return (INT_PTR)(pSD->SampleCopyProc(hWnd,uiMsg,wParam,lParam));

      default:
         return (INT_PTR)(FALSE);
   }
   return (INT_PTR)(TRUE);
}


void CSampleDialog::FillDrives(HWND hWnd)
{
   INT i,k;
   DWORD dw;
   char szDrive[10];
   char szTempDrive[] = "A:\\";
   char szVolumeLabel[128];
   UINT errmode = SetErrorMode(SEM_FAILCRITICALERRORS);

   SendMessage(hWnd,CB_SETEXTENDEDUI,TRUE,0);
   for (i = 0;i < 26 ;i++ )
   {
      m_szDrive[0] = i + 'A';
      m_szDrive[1] = ':';
      m_szDrive[2] = 0;


      szTempDrive[0] = i+'A';
      switch(GetDriveType(szTempDrive))
      {
         case DRIVE_CDROM:
         case DRIVE_RAMDISK:
         case DRIVE_FIXED:
            m_drivetypes[i] = 3;
            m_szDrive[0] = 'A' + i;
            strcat(m_szDrive,"\\*.*");
            szVolumeLabel[0] = 0;
            GetVolumeInformation(szTempDrive,szVolumeLabel,128,NULL,NULL,
                                 NULL,NULL,0);
            if (!szTempDrive[0])
               m_szDrive[2] = 0;
            else
            {
               m_szDrive[2] = ' ';
               m_szDrive[3] = '[';
               strcpy(m_szDrive + 4, szVolumeLabel);
               strcat(m_szDrive,"]");
            }
            break;

         case DRIVE_REMOVABLE:
            m_drivetypes[i] = 4;
            break;

         case DRIVE_REMOTE:
            strcpy(szDrive,m_szDrive);
            m_drivetypes[i] = 5;
            k = 64;
            m_szDrive[2] = ' ';
            m_szDrive[3] = 0;
            dw = sizeof(szVolumeLabel);
            WNetGetConnection(szDrive,szVolumeLabel,&dw);
            strcat(m_szDrive,szVolumeLabel);
            k = (INT)dw;
            break;
         default:
            m_drivetypes[i] = 0;
            break;

      }
      OemToAnsi(m_szDrive,m_szDrive);
      AnsiLower(m_szDrive);
      if (m_drivetypes[i])
          k = (INT)SendMessage(hWnd,CB_ADDSTRING,0,(LPARAM)(LPSTR)m_szDrive);
      if (i + 'a' == m_szDir[0])
         SendMessage(hWnd,CB_SETCURSEL,k,0L);
   }
   SetErrorMode(errmode);
}


BOOL  SampleDlgProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
   HWND hWndLB = GetDlgItem(hWnd,IDC_SAMPLE_LB);
   BOOL bCopyAll = FALSE;
   CSampleDialog * pSD;

   pSD = (CSampleDialog*) GetWindowLongPtr(hWnd,GWLP_USERDATA);
   if (pSD)
      return (pSD->SampleDlgProc(hWnd,uiMsg,wParam,lParam));

    switch (uiMsg)
    {
      case WM_INITDIALOG:
         SetWindowLongPtr(hWnd,GWLP_USERDATA,lParam);
         pSD = (CSampleDialog*) lParam;
         return(pSD->SampleDlgProc(hWnd,uiMsg,wParam,lParam));

      default:
       return(FALSE);
    }
    return(TRUE);
}

void CSampleDialog::FillDirs(HWND hWnd, HWND hWndStatic)
{
   LPSTR lp, lpDir, p;
   char szDirName[MAX_PATHLEN * 2],szDirT[MAX_PATHLEN * 2],szAnsi[MAX_PATHLEN * 2];
   char szTmp[MAX_PATHLEN * 2], *pOem;
   WORD iDir;
   int i,t;
   BOOL fResetOemPtr;
   WIN32_FIND_DATA lpFD;
   HANDLE hSearch;
   int length = 0,length2 = 0,index;
   HDC hDC = NULL;
   SIZE size;
   RECT rc;

   hDC = GetDC(hWnd);
   GetWindowRect(hWnd,&rc);
   SendMessage(hWnd,WM_SETREDRAW,FALSE,0L);
   index = (int)SendMessage(hWnd,LB_GETCOUNT,0,0L);
   for (i = 0; i< index;i++)
   {
      p = (char*)SendMessage(hWnd,LB_GETITEMDATA,i,0L);
      if (p)
         lcFree(p);
   }
   SendMessage(hWnd,LB_RESETCONTENT,0,0L);
   OemToAnsi(m_szDir,szAnsi);
   SetWindowText(hWndStatic,szAnsi);
   strcpy(m_szOemPath,m_szDir);
   ASSERT(strlen(m_szOemPath) < sizeof(m_szOemPath));
   ASSERT(strlen(m_szDir) < sizeof(m_szDir));

   BOOL bAnsi = AreFileApisANSI();
   SetFileApisToOEM();

   lp = m_szOemPath + strlen(m_szOemPath);
   p = CharPrev(m_szOemPath,lp);
   if (*p != '\\')
   {
      *lp = '\\';
      lp = CharNext(lp);
      *lp = 0;
   }
   strcat(m_szOemPath,"*.*");


   for (hSearch = FindFirstFile(m_szOemPath,&lpFD), t = 1 ;
        hSearch != INVALID_HANDLE_VALUE && t;
        t = FindNextFile(hSearch,&lpFD))
   {
      if (!(lpFD.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
         continue;

      if (lpFD.cFileName[0] == '.')
         continue;

      strcpy(szTmp,lpFD.cFileName);
      OemToAnsi(lpFD.cFileName,lpFD.cFileName);
      AnsiLower(lpFD.cFileName);

      for (t = 0;
         SendMessage(hWnd,LB_GETTEXT,t,(DWORD_PTR)(LPSTR)szDirT) != LB_ERR;
         t++)
      {
         if (_strcmpi(lpFD.cFileName,szDirT) < 0)
            break;
      }
      SendMessage(hWnd,LB_INSERTSTRING,t,(DWORD_PTR)(LPSTR)lpFD.cFileName);
      p = (char*)lcMalloc(strlen(szTmp) + 1);
      if (!p)
      {

      }
      memset(p,0,strlen(szTmp) + 1);
      memcpy(p,szTmp,strlen(szTmp));
      SendMessage(hWnd,LB_SETITEMDATA,t,(LPARAM) p);
      GetTextExtentPoint32(hDC,lpFD.cFileName,(int)strlen(lpFD.cFileName),&size);
      if (size.cx > length)
         length = size.cx;
   }
   *lp = 0;

   //
   // Note last component is *.*... we don't want it anyway
   //

   // Parse up the current string into dir components and add to
   // list box.

   fResetOemPtr = FALSE;
   OemToAnsi(m_szOemPath,szAnsi);
   for (iDir = 0, lp = szAnsi, lpDir = szDirName, pOem = m_szOemPath ;

        *lp;)
   {
      if (fResetOemPtr == TRUE)
      {
         pOem += strlen(szDirName);
         if (*pOem == '\\')
            pOem = CharNext(pOem);
         fResetOemPtr = FALSE;
      }
      if (*lp == '\\')
      {
         if (!iDir)
            *lpDir++ = '\\';
         if (lpDir != szDirName)
         {
            *lpDir = 0;
            SendMessage(hWnd,LB_INSERTSTRING,iDir,(DWORD_PTR)(LPSTR)szDirName);
            p = (char*)lcMalloc(strlen(szDirName) + 1);
            if (!p)
            {

            }
            memset(p,0,strlen(szDirName) + 1);
            memcpy(p,pOem,strlen(szDirName));

            SendMessage(hWnd,LB_SETITEMDATA,iDir,(LPARAM) p);

            GetTextExtentPoint32(hDC,szDirName,(int)strlen(szDirName),&size);
            if (size.cx + (iDir * (m_TextCharWidth/2)) + 1 + 16> length2)
            {
               length2 = size.cx + (iDir * (m_TextCharWidth/2)) + 1 + 16;
            }
            lpDir = szDirName;
            iDir++;
            fResetOemPtr = TRUE;
            lp++;
         }
      }
      else
      {
         if (IsDBCSLeadByte(*lp))
            *lpDir++ = *lp++;
         *lpDir++ = *lp++;
      }
   }
   // Determine if we're going to need an HScrollbar.  Figure out the length
   // of the string with the indenting and the folder icon (16 pels)
   length +=  iDir*(m_TextCharWidth/2) + 1 + 16;
   if (length2 > length)
      length = length2;
   SendMessage(hWnd,LB_SETHORIZONTALEXTENT,length,0L);
   if (rc.right - rc.left <= length)
   {
       ShowScrollBar(hWnd,SB_HORZ,TRUE);
   }
   else
       ShowScrollBar(hWnd,SB_HORZ,FALSE);
   m_iDir = iDir - 1;
   SendMessage(hWnd,LB_SETCURSEL,m_iDir,0L);
   SendMessage(hWnd,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hWnd,NULL,TRUE);
   ReleaseDC(hWnd,hDC);
   if(bAnsi)
    SetFileApisToANSI();
}

void CSampleDialog::SelectDrive(HWND hWnd)
{
   int i;
   char szDrive[80];

   i = (int)SendMessage(hWnd,CB_GETCURSEL,0,0L);
   if (i == LB_ERR)
      return;
   SendMessage(hWnd,CB_GETLBTEXT,i,(DWORD_PTR)(LPSTR)szDrive);
   AnsiLower(szDrive);
   i = szDrive[0] - 'a' + 1;
   _getdcwd(i,m_szDir,sizeof(m_szDir));
   OemToAnsi(m_szDir,m_szDir);
   AnsiLower(m_szDir);
}

void CSampleDialog::SelectDirectory(HWND hWnd)
{
   WORD  i, iSub;
   WORD  c;
   LPSTR lp;
   TCHAR *p;

   iSub = 0;
   c = (WORD)SendMessage(hWnd,LB_GETCURSEL,0,0L);
   if (c > m_iDir)
   {
      iSub = c;
      c = (WORD)m_iDir;
   }

   for (lp = m_szDir,i = 0; i <= c ;i++ )
   {
      if ( i > 1)
      {
         *lp++ = '\\';
      }
      p = (char*) SendMessage(hWnd,LB_GETITEMDATA,i,0L);
      if (!p)
         SendMessage(hWnd,LB_GETTEXT,i,(DWORD_PTR)lp);
      else
         strcpy(lp,p);
      lp += strlen(lp);
   }
   if (iSub)
   {
      if (i > 1)
         *lp++ = '\\';
      p = (char*) SendMessage(hWnd,LB_GETITEMDATA,iSub,0L);
      strcpy(lp,p);
   }
}

BOOL  CSampleDialog::SampleDlgProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
   HWND hWndLB = GetDlgItem(hWnd,IDC_SAMPLE_LB);
   SAMPLE_DATA *p;
   int i,cItems,iCurSel;
   UINT_PTR s;
   char szTmp[MAX_PATH],szMsg[256],szURL[256];
   WCHAR wszTmp[MAX_PATH],wszMsg[256];
   BOOL bCopyAll = FALSE;
   char *pStart,*pTemp;
   HRESULT hr;
   SIZE size;
   HDC hDC;
   INT width = 0;
   BOOL fHorz = FALSE;
   RECT rc;

   switch (uiMsg)
   {
      case WM_INITDIALOG:
           //
           // Get the right fonts selected into the right controls on the dialog...
           //
           SetAllFonts(hWnd);  // First the UI font...
           SendDlgItemMessage(hWnd, IDC_SAMPLE_LB, WM_SETFONT, (WPARAM)m_pHtmlHelpCtl->GetContentFont(), FALSE);  // Now, Content font...
           //
           // set the dialog caption text
           //
//           SetWindowText(hWnd,m_szDialogTitle);
           GetWindowRect(hWndLB,&rc);
           hDC = GetDC(hWndLB);
           SendDlgItemMessage(hWnd,IDC_SAMPLE_LB,LB_RESETCONTENT,0,(LPARAM)0);
           for (p = m_pFirstSample;p;p = p->pNext)
           {
              i = (int)SendDlgItemMessage(hWnd,IDC_SAMPLE_LB,LB_ADDSTRING,0,(LPARAM)p->pszFileName);
              SendDlgItemMessage(hWnd,IDC_SAMPLE_LB,LB_SETITEMDATA,i,(LPARAM)p);
              GetTextExtentPoint32(hDC,p->pszFileName,(int)strlen(p->pszFileName),&size);
              if (size.cx > width)
                 width = size.cx;
           }
           if (rc.right - rc.left <= width)
              SendMessage(hWndLB,LB_SETHORIZONTALEXTENT,width,0L);
           else
              ShowScrollBar(hWndLB,SB_HORZ,FALSE);
           ReleaseDC(hWndLB,hDC);
           hDC = NULL;
           EnableWindow(GetDlgItem(hWnd,IDC_SAMPLE_VIEW),FALSE);
           EnableWindow(GetDlgItem(hWnd,IDC_SAMPLE_COPY),FALSE);
           SetCursor(LoadCursor(NULL,IDC_ARROW));
           break;


      case WM_CLOSE:
           PostMessage(hWnd, WM_COMMAND,IDCANCEL,0L);
           break;

      case WM_COMMAND:
          switch(LOWORD(wParam))
          {
            case IDCANCEL:
            case IDOK:
                  EndDialog(hWnd,0);
                  break;

            case IDC_SAMPLE_LB:
               if (HIWORD(wParam) == LBN_SELCHANGE)
               {
                  if ( ((iCurSel = GetOneSel(hWndLB,FALSE)) == LB_ERR))
                  {
                     EnableWindow(GetDlgItem(hWnd,IDC_SAMPLE_VIEW),FALSE);
                  }
                  else
                  {
                     SendMessage(hWndLB,LB_GETTEXT,iCurSel,(LPARAM)(LPSTR)szTmp);

                     p = (SAMPLE_DATA*) SendMessage(hWndLB,LB_GETITEMDATA,
                                                    iCurSel,(LPARAM)0);

                     if (p->iFlags & SAMP_VIEWABLE)
                        EnableWindow(GetDlgItem(hWnd,IDC_SAMPLE_VIEW),TRUE);
                     else
                        EnableWindow(GetDlgItem(hWnd,IDC_SAMPLE_VIEW),FALSE);
                  }

                  if (GetOneSel(hWndLB,TRUE) == LB_ERR)
                     EnableWindow(GetDlgItem(hWnd,IDC_SAMPLE_COPY),FALSE);
                  else
                     EnableWindow(GetDlgItem(hWnd,IDC_SAMPLE_COPY),TRUE);
                  break;
               }
               else if (HIWORD(wParam) != LBN_DBLCLK)
                  break;

               // fall through intended
             case IDC_SAMPLE_VIEW:

                 if ( ((iCurSel = GetOneSel(hWndLB,FALSE)) != LB_ERR) )
                    SendMessage(hWndLB,LB_GETTEXT,iCurSel,(LPARAM)(LPSTR)szTmp);

                 GetTempPath(sizeof(szTmp),szTmp);

                 // copy it first.
                 i = (int)SendMessage(hWndLB,LB_GETCURSEL,0,0);
                 if (i == LB_ERR)
                 {
                    if(g_bWinNT5)
                    {
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszTmp,sizeof(wszTmp));
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_ERRORS,wszMsg,sizeof(wszMsg));
                        MessageBoxW(hWnd,wszMsg,wszTmp,MB_OK);
                    }
                    else
                    {
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szTmp,sizeof(szTmp));
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_ERRORS,szMsg,sizeof(szMsg));
                        MessageBox(hWnd,szMsg,szTmp,MB_OK);
                    }
                    break;
                 }
                 p = (SAMPLE_DATA*) SendMessage(hWndLB,LB_GETITEMDATA,i,
                                                (LPARAM)0);

//                 wsprintf(szURL,"%s%s",m_szSmplPath,p->pszFileName);
                 strcpy(szURL,m_szSmplPath);
                 CatPath(szURL,p->pszFileName);
                 if (m_bCompressed)
                    BackSlashToSlash(szURL);

                 pStart = p->pszFileName;
                 pTemp  = p->pszFileName;

                 while(*pTemp)
                 {
                     if(*pTemp == '\\')
                         pStart = pTemp+1;
                     pTemp = CharNext(pTemp);
                 }

                 CatPath(szTmp,pStart);

                 // BUGBUG - insert code here to view uncompressed samples

                 if (m_bCompressed)
                     hr = DownloadURL(szURL,szTmp);
                 else
                     CopyFile(szURL,szTmp,FALSE);

                 if (FAILED(hr))
                 {
                    if(g_bWinNT5)
                    {
                        DeleteFile(szTmp);
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszTmp,sizeof(wszTmp));
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_ERRORS,wszMsg,sizeof(wszMsg));
                        MessageBoxW(hWnd,wszMsg,wszTmp,MB_OK|MB_ICONEXCLAMATION);
                    }
                    else
                    {
                        DeleteFile(szTmp);
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szTmp,sizeof(szTmp));
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_ERRORS,szMsg,sizeof(szMsg));
                        MessageBox(hWnd,szMsg,szTmp,MB_OK|MB_ICONEXCLAMATION);
                    }
                     break;
                 }
                 // View the file
                 //
                 char szBuffer[MAX_PATH];
                 wsprintf(szBuffer, "notepad %s", szTmp);
                 WinExec(szBuffer,SW_SHOW);

                 if (FAILED(hr))
                 {
                    if(g_bWinNT5)
                    {
                        DeleteFile(szTmp);
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszTmp,sizeof(wszTmp));
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_VIEW_ERRORS,wszMsg,sizeof(wszMsg));
                        MessageBoxW(hWnd,wszMsg,wszTmp,MB_OK|MB_ICONEXCLAMATION);
                    }
                    else
                    {
                        DeleteFile(szTmp);
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szTmp,sizeof(szTmp));
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_VIEW_ERRORS,szMsg,sizeof(szMsg));
                        MessageBox(hWnd,szMsg,szTmp,MB_OK|MB_ICONEXCLAMATION);
                    }        
                 }
                 break;

            case IDC_SAMPLE_COPYALL:
                 m_bCopyAllSamples = TRUE;
                    // fall through intended

            case IDC_SAMPLE_COPY:
                 cItems = (int)SendMessage(hWndLB,LB_GETCOUNT,0,0);
                 for (i = 0; i < cItems ;i++ )
                 {
                    p = (SAMPLE_DATA *) SendDlgItemMessage(hWnd,IDC_SAMPLE_LB,
                                            LB_GETITEMDATA,i,(LPARAM)0);

                    s = (int)SendMessage(hWndLB, LB_GETSEL,i,0);
                    if (s != 0 && s != LB_ERR)
                        p->bCopy = TRUE;
                    else
                        p->bCopy = FALSE;
                 }

                 // Disable all of the toplevel application windows, before we bring up the dialog.
                 CLockOut LockOut ;
                 LockOut.LockOut(hWnd) ;

                 // Display dialog.
                 if(g_bWinNT5)
                 {
                    s = DialogBoxParamW(_Module.GetResourceInstance(), MAKEINTRESOURCEW(IDD_SAMPLE_COPY_DLG),
                                       hWnd,(DLGPROC)SampleCopyProcStub,(LPARAM)this);
                 }
                 else
                 {
                    s = DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SAMPLE_COPY_DLG),
                                       hWnd,(DLGPROC)SampleCopyProcStub,(LPARAM)this);
                 }
                // Enable all of the windows which we disabled.
                LockOut.Unlock() ;

                 if (s == SAMPLE_COPY_ERRORS)
                 {
                    if(g_bWinNT5)
                    {
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszTmp,sizeof(wszTmp));
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_ERRORS,wszMsg,sizeof(wszMsg));
                        MessageBoxW(hWnd,wszMsg,wszTmp,MB_OK);
                    }
                    else
                    {
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szTmp,sizeof(szTmp));
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_ERRORS,szMsg,sizeof(szMsg));
                        MessageBox(hWnd,szMsg,szTmp,MB_OK);
                    }
                 }
                 else if (s == SAMPLE_COPY_SUCCESS)
                 {
                    if(g_bWinNT5)
                    {
                         LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszTmp,sizeof(wszTmp));
                         LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_COMPLETE,wszMsg,sizeof(wszMsg));
                         MessageBoxW(hWnd,wszMsg,wszTmp,MB_OK);
                    }
                    else
                    {
                         LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szTmp,sizeof(szTmp));
                         LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_COPY_COMPLETE,szMsg,sizeof(szMsg));
                         MessageBox(hWnd,szMsg,szTmp,MB_OK);
                    }
                 }
                 break;

          }
          break;
      default:
         return(FALSE);
   }
   return(TRUE);
}

BOOL CSampleDialog::SampleCopyProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
   HWND hWndParent;
   INT i,f;
   SAMPLE_DATA *pData;
   char szTmp[MAX_PATHLEN],*lp;
   char szURL[MAX_PATHLEN];
   char szDest[MAX_PATHLEN * 2];
   WCHAR wszDest[MAX_PATHLEN * 2];
   char szSrc[MAX_PATHLEN];
   char szMsg[MAX_PATHLEN * 2],szMsg2[MAX_PATHLEN * 2],szAnsiPath[MAX_PATHLEN * 2];
   WCHAR wszMsg[MAX_PATHLEN * 2];
   WCHAR wszMsg2[MAX_PATHLEN * 2];
   WCHAR wszCaption[32];
   char szCaption[32];
   unsigned short wszPath[MAX_PATHLEN * 2];
   char *q;
   HANDLE hFile = INVALID_HANDLE_VALUE;
   HRESULT hr;
   BOOL bCopyErrors = FALSE;
   HCURSOR hOldCursor = NULL;
   static BOOL init = 0;

   switch (uiMsg)
   {
      case WM_DRAWITEM:
         wParam = ((LPDRAWITEMSTRUCT)lParam)->CtlID;
         if (wParam == IDD_DIRLIST)
            DirectoryDrawItem((LPDRAWITEMSTRUCT)lParam);
         else if (wParam == IDD_DRIVELIST)
            DriveDrawItem((LPDRAWITEMSTRUCT)lParam);
         break;

      case WM_INITDIALOG:
         // For some reason, retail builds on NT 4 get 2 INITDIALOG msgs, so
         // we'll make sure we only do this once (same is true for SampleDlgProc)
         if (init)
            break;
         SetAllFonts(hWnd);
         SendDlgItemMessage(hWnd, IDD_FILELIST, WM_SETFONT, (WPARAM)m_pHtmlHelpCtl->GetContentFont(), FALSE);
         hWndParent = GetWindow(hWnd,GW_OWNER);
         if (m_bCompressed)
         {
            if(g_bWinNT5)
            {
                LoadStringW(_Module.GetResourceInstance() ,IDS_WHY_COPY,wszMsg,sizeof(wszMsg));
                SetDlgItemTextW(hWnd,IDD_HELP_TEXT,wszMsg);
            }
            else
            {
                LoadString(_Module.GetResourceInstance() ,IDS_WHY_COPY,szMsg,sizeof(szMsg));
                SetDlgItemText(hWnd,IDD_HELP_TEXT,szMsg);
            }
         }

         // GetInstall dir and cat it with default sample dest
         SetWindowText(GetDlgItem(hWnd,IDD_DIRNAME),m_szDefSamplePath);
         for (i = 0; ;i++)
         {
            if (!m_bCopyAllSamples)
            {
               f = (INT)SendDlgItemMessage(hWndParent,IDC_SAMPLE_LB,LB_GETSEL,i,0L);
               if (f == LB_ERR)
                  break;
               if (!f)
                  continue;
            }
            if ( SendDlgItemMessage(hWndParent,IDC_SAMPLE_LB,LB_GETTEXT,i,(LPARAM)szTmp) == LB_ERR)
               break;
            if (i)
            {
               ECSelect(hWnd,IDD_FILELIST,2);
               SendDlgItemMessage(hWnd,IDD_FILELIST,EM_REPLACESEL,0,(DWORD_PTR)((LPSTR) " "));
            }
            ECSelect(hWnd,IDD_FILELIST,2);
            SendDlgItemMessage(hWnd,IDD_FILELIST,EM_REPLACESEL,0,(DWORD_PTR) ((LPSTR)szTmp));
         }

         // Get the last known sample dest
         if (!m_szBaseDir[0])
         {
             // set the base dir here - I think this includes the drive letter
             //
             GetSamplesDir(m_szBaseDir);
         }
         CharToOem(m_szBaseDir,m_szDir);
         if(!m_bSetDefPath)
         {
            CatPath(m_szDir,m_szDefSamplePath);
            m_bSetDefPath = TRUE;
         }
         SendMessage(GetDlgItem(hWnd,IDD_DIRLIST),LB_SETHORIZONTALEXTENT,0,0L);
         FillDrives(GetDlgItem(hWnd,IDD_DRIVELIST));
         FillDirs(GetDlgItem(hWnd,IDD_DIRLIST),GetDlgItem(hWnd,IDD_DIRNAME));
         init = TRUE;
         break;

      case WM_CLOSE:
         init = FALSE;
         PostMessage(hWnd, WM_COMMAND,IDCANCEL,0L);
           break;

      case WM_COMMAND:
         switch (LOWORD(wParam))
      {
            case IDCANCEL:
               m_bCopyAllSamples = FALSE;
               EndDialog(hWnd,0);
               init = FALSE;
               break;

            case IDD_DRIVELIST:
               if (HIWORD(wParam) != CBN_SELCHANGE)
                  break;
ChangeDrive:
               SelectDrive(GetDlgItem(hWnd,IDD_DRIVELIST));
               FillDirs(GetDlgItem(hWnd,IDD_DIRLIST),GetDlgItem(hWnd,
                        IDD_DIRNAME));
               break;

            case IDD_DIRLIST:
               if (HIWORD(wParam) != LBN_DBLCLK)
                  break;
ChangeDir:
               SelectDirectory(GetDlgItem(hWnd,IDD_DIRLIST));
               FillDirs(GetDlgItem(hWnd,IDD_DIRLIST),GetDlgItem(hWnd,
                        IDD_DIRNAME));
               break;

            case IDD_NETWORK:
               if (WNetConnectionDialog(hWnd,RESOURCETYPE_DISK) == NO_ERROR)
               {
                  SendDlgItemMessage(hWnd,IDD_DRIVELIST,CB_RESETCONTENT,0,0L);
                  FillDrives(GetDlgItem(hWnd,IDD_DRIVELIST));
               }
               break;

            case IDOK:

               init = FALSE;

               BOOL bYesToAll = FALSE;
               BOOL bCancel = FALSE;

               if (GetFocus() == GetDlgItem(hWnd,IDD_DRIVELIST))
                  goto ChangeDrive;
               else if (GetFocus() == GetDlgItem(hWnd,IDD_DIRLIST))
                  goto ChangeDir;

               EnableWindow(GetDlgItem(hWnd,IDOK),FALSE);

               GetWindowText(GetDlgItem(hWnd,IDD_DIRNAME),szAnsiPath,sizeof(szAnsiPath));

               // Now, check to see if the edit box text is the same as the tree control
               // path.  If so, use the OEM path we're storing, if not, use the path in
               // the edit control.  Note, that will be an ansi path

               OemToAnsi(m_szOemPath,szTmp);

               if (!_strnicmp(szAnsiPath,szTmp,(int)strlen(szAnsiPath)))
               {
                  strcpy(szDest,szTmp);
                  strcpy(m_szBaseDir,szTmp);

               }
               else
               {
                  strcpy(m_szDir, szAnsiPath);
                  strcpy(m_szBaseDir,m_szDir);
               }

               lp = m_szBaseDir + strlen(m_szBaseDir);
               lp = CharPrev(m_szBaseDir,lp);
               if (*lp == '\\')
                  *lp = 0;

               ASSERT(strlen(m_szBaseDir) < sizeof(m_szBaseDir));

               // Create the base dir if it doesn't exist
               if (IsDirectory(m_szBaseDir) == FALSE)
               {
                    if(g_bWinNT5)
                    {
                        LoadStringW(_Module.GetResourceInstance() ,IDS_CONFIRM_MKDIR,wszMsg,sizeof(wszMsg));
                        LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszCaption,sizeof(wszCaption));

                        WCHAR wszAnsiPath[MAX_PATH];

                        MultiByteToWideChar(CP_ACP, 0, szAnsiPath, -1, (PWSTR) wszAnsiPath, sizeof(wszAnsiPath)/2);
                        wsprintfW(wszMsg2,wszMsg,wszAnsiPath);
                        if (MessageBoxW(hWnd,wszMsg2,wszCaption,MB_OKCANCEL) == IDCANCEL)
                        {
                            EnableWindow(GetDlgItem(hWnd,IDOK),TRUE);
                            return(FALSE);
                        }
                    }
                    else
                    {
                        LoadString(_Module.GetResourceInstance() ,IDS_CONFIRM_MKDIR,szMsg,sizeof(szMsg));
                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szCaption,sizeof(szCaption));

                        wsprintf(szMsg2,szMsg,szAnsiPath);
                        if (MessageBox(hWnd,szMsg2,szCaption,MB_OKCANCEL) == IDCANCEL)
                        {
                            EnableWindow(GetDlgItem(hWnd,IDOK),TRUE);
                            return(FALSE);
                        }
                    }
               }

               hOldCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));
               for (pData = m_pFirstSample;pData;pData = pData->pNext)
               {
                  if (m_bCopyAllSamples || pData->bCopy)
                  {
                     // Get a base source location
                     strcpy(szSrc,m_szSmplPath);
                     CatPath(szSrc,pData->pszFileName);

                     strcpy(szURL,szSrc);
                     strcpy(szDest,m_szBaseDir);
                     CatPath(szDest,pData->pszFileName);
                     ASSERT(strlen(szDest) < sizeof(szDest));

                     // Create the path to the file
                     strcpy(szTmp,szDest);
                     q = szTmp + strlen(szTmp) ;
                     while (*q != '/' && q > szTmp && *q != '\\')
                        q = CharPrev(szTmp,q);
                     *q = 0;

                     if (CreatePath(szTmp))
                     {
                        // Directory creation barf.
                        bCopyErrors = TRUE;
                        m_szBaseDir[0] = 0;
                        break;
                     }

                     if (m_bCompressed)
                         BackSlashToSlash(szURL);
copyagain:
                     // check for existing file
                     //
                     hFile = ::CreateFile(szDest,GENERIC_READ,NULL,NULL,OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,NULL);

                    ::CloseHandle(hFile);

                     if (hFile != INVALID_HANDLE_VALUE && !bYesToAll)
                     {

//                        char szString[80],szTemp[MAX_PATH+80],szCaption[50];
//                        LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_OVERWRITE,szString,sizeof(szString));
//                        LoadString(_Module.GetResourceInstance() ,IDS_FILE_COPY,szCaption,sizeof(szCaption));

//                        wsprintf(szTemp,szString,pData->pszFileName);
                        COverwriteDlg overwrite(hWnd, pData->pszFileName);
                        int Ret = overwrite.DoModal();

                        if(Ret == IDNO)
                            continue;

                        if(Ret == 0)
                        {
                            bCancel = TRUE;
                            goto ack;
                        }

                        if(Ret == IDRETRY)
                            bYesToAll = TRUE;
                     }

                     if (m_bCompressed)
                        hr = DownloadURL(szURL,szDest);
                     else
                     {
                        CopyFile(szURL,szDest,FALSE);
                     }

                     // URLDownloadToFile is braindead in that it doesn't
                     // necessarily return a proper error code, so we gotta
                     // check each file to see if it really copied.  BOUGS!
                     hFile = ::CreateFile(szDest,GENERIC_READ,NULL,NULL,OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,NULL);

                     DWORD dwFileSize = 0;
                     BOOL bZeroSizeFile = FALSE;

                     char szDestDrive[]="C:";
                     szDestDrive[0] = szDest[0];

                     if(hFile)
                        dwFileSize = GetFileSize(hFile,NULL);

                     CloseHandle(hFile);

                     if(!m_bCompressed)
                     {
                        HANDLE hFile2 = ::CreateFile(szURL,GENERIC_READ,NULL,NULL,OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,NULL);
                        if(hFile2)
                        {
                            if(!GetFileSize(hFile2,NULL))
                                bZeroSizeFile = TRUE;
                            CloseHandle(hFile2);
                        }
                     }

                // take off the read only attributes
                DWORD dwAtr = GetFileAttributes(szDest);
                 if (dwAtr != 0xFFFFFFFF)
                {
                  dwAtr = dwAtr & (~FILE_ATTRIBUTE_READONLY);
                  SetFileAttributes(szDest, dwAtr);
                }

                if (hFile != INVALID_HANDLE_VALUE && !dwFileSize && !bZeroSizeFile)
                     {
                         LONG lFreeSpace = GetFreeDiskSpaceInKB(szDest);

                         if(lFreeSpace < 1024)
                         {
                            if(g_bWinNT5)
                            {
                                DeleteFile(szDest);
                                WCHAR wszFmt[64];
                                LoadStringW(_Module.GetResourceInstance() ,IDS_NO_SPACE,wszFmt,sizeof(wszFmt));
                                LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszCaption,sizeof(wszCaption));

                                WCHAR wszDestDrive[10];
                                MultiByteToWideChar(CP_ACP, 0, szDestDrive, -1, (PWSTR) wszDestDrive, 10);

                                wsprintfW(wszMsg,wszFmt,wszDestDrive);
                                if (MessageBoxW(NULL,wszMsg,wszCaption,MB_YESNO) == IDYES)
                                {
                                    goto copyagain;
                                }
                                bCopyErrors = TRUE;
                                goto ack;
                            }
                            else
                            {
                                DeleteFile(szDest);
                                char szFmt[64];
                                LoadString(_Module.GetResourceInstance() ,IDS_NO_SPACE,szFmt,sizeof(szFmt));
                                LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szCaption,sizeof(szCaption));
                                wsprintf(szMsg,szFmt,szDestDrive);
                                if (MessageBox(NULL,szMsg,szCaption,MB_YESNO) == IDYES)
                                {
                                    goto copyagain;
                                }
                                bCopyErrors = TRUE;
                                goto ack;
                            }
                         }
                     }
                     else
                     {
                         if (hFile == INVALID_HANDLE_VALUE)
                         {
                            DWORD dwErr = GetLastError();

                            if (dwErr== ERROR_SHARING_VIOLATION)
                            {
                                if(g_bWinNT5)
                                {
                                    WCHAR wszFmt[64];
                                    LoadStringW(_Module.GetResourceInstance() ,IDS_SHARE_VIOLATION,wszFmt,sizeof(wszFmt));
                                    LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszCaption,sizeof(wszCaption));
                                    wsprintfW(wszMsg,wszFmt,wszDest);
                                    if (MessageBoxW(NULL,wszMsg,wszCaption,MB_YESNO) == IDYES)
                                    {
                                        goto copyagain;
                                    }
                                    bCopyErrors = TRUE;
                                }
                                else
                                {
                                    char szFmt[64];
                                    LoadString(_Module.GetResourceInstance() ,IDS_SHARE_VIOLATION,szFmt,sizeof(szFmt));
                                    LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szCaption,sizeof(szCaption));
                                    wsprintf(szMsg,szFmt,szDest);
                                    if (MessageBox(NULL,szMsg,szCaption,MB_YESNO) == IDYES)
                                    {
                                        goto copyagain;
                                    }
                                    bCopyErrors = TRUE;
                                }
                            }
                            else
                            {
                                if(g_bWinNT5)
                                {
                                    bCopyErrors = TRUE;
                                    WCHAR wszFmt[64];
                                    LoadStringW(_Module.GetResourceInstance() ,IDS_ERROR_COPYING,wszFmt,sizeof(wszFmt));
                                    LoadStringW(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,wszCaption,sizeof(wszCaption));
                                    wsprintfW(wszMsg,wszFmt,wszDest);
                                    if (MessageBoxW(NULL,wszMsg,wszCaption,MB_YESNO) == IDNO)
                                    {
                                        goto ack;
                                    }
                                }
                                else
                                {
                                    bCopyErrors = TRUE;
                                    char szFmt[64];
                                    LoadString(_Module.GetResourceInstance() ,IDS_ERROR_COPYING,szFmt,sizeof(szFmt));
                                    LoadString(_Module.GetResourceInstance() ,IDS_SAMPLE_CAPTION,szCaption,sizeof(szCaption));
                                    wsprintf(szMsg,szFmt,szDest);
                                    if (MessageBox(NULL,szMsg,szCaption,MB_YESNO) == IDNO)
                                    {
                                        goto ack;
                                    }
                                }
                            }
                         }
                  }
                     hFile = INVALID_HANDLE_VALUE;
                  }
               }
ack:
               SetCursor(hOldCursor);
               m_bCopyAllSamples = FALSE;

               // if m_szDefSamplePath is \foo\bar and m_szBaseDir is
               // d:\tmp\foo\bar, we only wanna save d:\tmp
               char *p = m_szBaseDir + strlen (m_szBaseDir) -
                         strlen(m_szDefSamplePath);
               if (!strcmp(p,m_szDefSamplePath) && *(p-1) == '\\')
                  *p = 0;


               if (bCopyErrors)
                  EndDialog(hWnd,SAMPLE_COPY_ERRORS);
               else
               {
                  MultiByteToWideChar(CP_ACP,0,m_szBaseDir,-1,wszPath,sizeof(wszPath));
                  if(bCancel)
                    EndDialog(hWnd,SAMPLE_COPY_CANCEL);
                  else
                    EndDialog(hWnd,SAMPLE_COPY_SUCCESS);
               }
               break;
         }
         break;
      default:
         return(FALSE);
   }
   return(TRUE);

}

void CSampleDialog::DirectoryDrawItem(LPDRAWITEMSTRUCT lpdi)
{
   INT   indent;
   INT   bitmap;
   INT   sel;
   char  szDir[MAX_PATHLEN];
   INT   cx,cy;

   if (lpdi->itemID > m_iDir)
   {
      indent = m_iDir + 1;
      bitmap = 0;
   }
   else
   {
      indent = lpdi->itemID;
      if (lpdi->itemID == m_iDir)
         bitmap = 1;
      else
         bitmap = 2;
   }
   indent++;

   if (lpdi->itemAction == ODA_FOCUS)
      goto drawfocus;

   if (lpdi->itemState & ODS_SELECTED)
   {
      SetBkColor(lpdi->hDC,GetSysColor(COLOR_HIGHLIGHT));
      SetTextColor(lpdi->hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
      sel = 1;
   }
   else
   {
      SetBkColor(lpdi->hDC,GetSysColor(COLOR_WINDOW));
      SetTextColor(lpdi->hDC,GetSysColor(COLOR_WINDOWTEXT));
      sel = 0;
   }

   ImageList_GetIconSize(m_hImageList,&cx,&cy);
   SendMessage(lpdi->hwndItem,LB_GETTEXT,lpdi->itemID,(DWORD_PTR)(LPSTR)szDir);

   ExtTextOut(lpdi->hDC,
              lpdi->rcItem.left + indent * (m_TextCharWidth/2) + 1 + cy,
              lpdi->rcItem.top + 1, ETO_OPAQUE,&lpdi->rcItem,
              szDir,(int)strlen(szDir),NULL);

   ImageList_Draw(m_hImageList,bitmap,lpdi->hDC,
                  lpdi->rcItem.left + ((2*indent)-1) * (m_TextCharWidth/2)/2,
                  lpdi->rcItem.top,ILD_TRANSPARENT);
   if (lpdi->itemState & ODS_FOCUS)
   {
drawfocus:
      DrawFocusRect(lpdi->hDC,&lpdi->rcItem);
   }
}

void CSampleDialog::DriveDrawItem(LPDRAWITEMSTRUCT lpdi)
{
   int drive;
   char szDrive[100];
   int sel;
   INT   cx,cy;

   if (lpdi->itemAction & ODA_FOCUS)
      goto focus;

   if (lpdi->itemID == -1)
      return;
   SendMessage(lpdi->hwndItem,CB_GETLBTEXT,lpdi->itemID,(DWORD_PTR)(LPSTR)szDrive);

   drive = (szDrive[0] - 'A') & 31;

   if (lpdi->itemState & ODS_SELECTED)
   {
      SetBkColor(lpdi->hDC,GetSysColor(COLOR_HIGHLIGHT));
      SetTextColor(lpdi->hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
      sel = 1;
   }
   else
   {
      SetBkColor(lpdi->hDC,GetSysColor(COLOR_WINDOW));
      SetTextColor(lpdi->hDC,GetSysColor(COLOR_WINDOWTEXT));
      sel = 0;
   }

   ImageList_GetIconSize(m_hImageList,&cx,&cy);
   ExtTextOut(lpdi->hDC,
              lpdi->rcItem.left + m_TextCharWidth + cx,
              lpdi->rcItem.top + 1, ETO_OPAQUE,&lpdi->rcItem,
              szDrive,(int)strlen(szDrive),NULL);

   ImageList_Draw(m_hImageList,m_drivetypes[drive],lpdi->hDC,
                  lpdi->rcItem.left + m_TextCharWidth /2,
                  lpdi->rcItem.top,ILD_TRANSPARENT);

   if (lpdi->itemState & ODS_FOCUS)
   {
focus:
      DrawFocusRect(lpdi->hDC,&lpdi->rcItem);
   }

}

BOOL CSampleDialog::CheckCD(TCHAR *lpFileName)
{
   return(TRUE);
}

BOOL COverwriteDlg::OnBeginOrEnd()
{
    if (m_fInitializing) 
    {
        char szTmp[512],szTmp2[600];
        WCHAR wszTmp[512],wszTmp2[600];

        if(g_bWinNT5)
        {
            LoadStringW(_Module.GetResourceInstance() , IDS_SAMPLE_OVERWRITE, wszTmp,  512);

            WCHAR wszFileName[MAX_PATH];
            MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, (PWSTR) wszFileName, MAX_PATH);

            wsprintfW(wszTmp2,wszTmp,wszFileName);
            ::SendMessageW(::GetDlgItem(m_hWnd,IDC_OVERWRITE_YN), WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);
            SetWindowTextW(GetDlgItem(IDC_OVERWRITE_YN), wszTmp2);
        }
        else
        {
            LoadString(_Module.GetResourceInstance() , IDS_SAMPLE_OVERWRITE, szTmp,  512);
            wsprintf(szTmp2,szTmp,pszFileName);
            ::SendMessage(::GetDlgItem(m_hWnd,IDC_OVERWRITE_YN), WM_SETFONT, (WPARAM) _Resource.GetUIFont(), FALSE);
            SetWindowText(IDC_OVERWRITE_YN, szTmp2);
        }
    }
    return TRUE;
}


// GetFreeDiskSpace: Function to Measure Available Disk Space
//
static long GetFreeDiskSpaceInKB(LPSTR pFile)
{
    DWORD dwFreeClusters, dwBytesPerSector, dwSectorsPerCluster, dwClusters;
    char RootName[MAX_PATH];
    LPSTR ptmp;    //required arg
    ULARGE_INTEGER ulA, ulB, ulFreeBytes;

    // need to find path for root directory on drive containing
    // this file.

    GetFullPathName(pFile, sizeof(RootName), RootName, &ptmp);

    // truncate this to the name of the root directory (god how tedious)
    if (RootName[0] == '\\' && RootName[1] == '\\') {

      // path begins with  \\server\share\path so skip the first
      // three backslashes
      ptmp = &RootName[2];
      while (*ptmp && (*ptmp != '\\')) {
          ptmp++;
      }
      if (*ptmp) {
          // advance past the third backslash
          ptmp++;
      }
    } else {
      // path must be drv:\path
      ptmp = RootName;
    }

    // find next backslash and put a null after it
    while (*ptmp && (*ptmp != '\\')) {
      ptmp++;
    }
    // found a backslash ?
    if (*ptmp) {
      // skip it and insert null
      ptmp++;
      *ptmp = '\0';
    }

    // the only real way of finding out free disk space is calling
    // GetDiskFreeSpaceExA, but it doesn't exist on Win95

    HINSTANCE h = LoadLibraryA("kernel32.dll");
    if (h) {
      typedef BOOL (WINAPI *MyFunc)(LPCSTR RootName, PULARGE_INTEGER pulA, PULARGE_INTEGER pulB, PULARGE_INTEGER pulFreeBytes);
      MyFunc pfnGetDiskFreeSpaceEx = (MyFunc)GetProcAddress(h, "GetDiskFreeSpaceExA");
      FreeLibrary(h);
      if (pfnGetDiskFreeSpaceEx) {
        if (!pfnGetDiskFreeSpaceEx(RootName, &ulA, &ulB, &ulFreeBytes))
        return -1;
        return (long)(ulFreeBytes.QuadPart / 1024);
      }
    }

    if (!GetDiskFreeSpace(RootName, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
      return (-1);
    return(MulDiv(dwSectorsPerCluster * dwBytesPerSector, dwFreeClusters,1024));
}


HRESULT DownloadURL(char *pszURL, char *pszDest)
{
    char pszCachedFile[MAX_PATH];
    char Buffer[1024];
   pszCachedFile[0] = 0;

    IStream* pStream;

    // open the stream
    //
    IBindCtx *pbc = NULL;
   CreateBindCtx(0, &pbc);

   IMoniker* pMoniker = NULL;

   OLECHAR wFSName[_MAX_PATH];
   mbstowcs(wFSName, pszURL, strlen(pszURL) + 1);

   IParseDisplayName* pDisplay = NULL;

   HRESULT hr = CoCreateInstance(CLSID_PARSE_URL, NULL, CLSCTX_INPROC_SERVER,
                   IID_IParseDisplayName, (void **) &pDisplay);
   if (FAILED(hr))
       return hr;

   ULONG lEaten;
   hr = pDisplay->ParseDisplayName(pbc, wFSName, &lEaten, &pMoniker);

   if (FAILED(hr))
       return hr;

   hr = pMoniker->BindToStorage(pbc, NULL, IID_IStream, (void**) &pStream);
   if (FAILED(hr))
       return hr;

   pMoniker->Release();
   pDisplay->Release();
   pbc->Release();

   ULONG dwBytesRead = 0;

   HANDLE hOutputFile;

    if ((hOutputFile = CreateFile(pszDest, GENERIC_WRITE, 0,  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE)
        return E_FAIL;

   do
    {
       DWORD dwBytesWritten = 0;
        Buffer[0] = 0;

        // read from the stream
        //
        hr = pStream->Read( Buffer, sizeof(Buffer), &dwBytesRead);

        if (FAILED(hr))
          return hr;

        // dump the text to the screen for now.
        //
        if(!(FAILED(hr) && dwBytesRead))
      {
            if(!WriteFile(hOutputFile, Buffer, dwBytesRead, &dwBytesWritten, NULL))
             return E_FAIL;

         if(dwBytesRead != dwBytesWritten)
             return E_FAIL;
      }
    } while( SUCCEEDED(hr) && dwBytesRead == sizeof(Buffer));

    CloseHandle(hOutputFile);

   pStream->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sample.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.
//
// SAMPLE.H
//
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __SAMPLE_H__
#define __SAMPLE_H__

#ifndef CHIINDEX
BOOL ProcessSample(PCSTR szSFLFilePath,PCSTR szSampleBaseUrl,PCSTR cszDialogTitle, CHtmlHelpControl* pCtl, BOOL bCompressed);
#else
#define ProcessSample
#endif

BOOL  SampleDlgProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
LPSTR CatPath(LPSTR lpTop, LPCSTR lpTail);

#define SAMPLE_ROOT "samples"
#define MAX_PATHLEN 256
#define SAMPLE_COPY_SUCCESS 1
#define SAMPLE_COPY_ERRORS 2
#define SAMPLE_COPY_CANCEL 3
#define COPY_BUFFER_SIZE 32768

typedef struct _SampleData
{
   char*            pszFileName;
   unsigned long    dwSize;
   BOOL             bCopy;
   BOOL             bRun;
   INT              iFlags;
   _SampleData*     pNext;
}SAMPLE_DATA;

#define SAMP_BINARY 1
#define SAMP_VIEWABLE 2

extern HINSTANCE ghInstance;

class CSampleDialog
{
   public:
   CSampleDialog();
   ~CSampleDialog();

   // Sample copy dialog helpers
   void FillDrives(HWND hWnd);
   void FillDirs(HWND hWnd, HWND hWndStatic);
   void SelectDrive(HWND hWnd);
   void SelectDirectory(HWND hWnd);
   void DirectoryDrawItem(LPDRAWITEMSTRUCT lpDS);
   void DriveDrawItem(LPDRAWITEMSTRUCT lpDS);
   void SetAllFonts(HWND hWnd);

   // dlgprocs
   BOOL SampleCopyProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
   BOOL SampleDlgProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

   // Initial data setup
   VOID AddSample (SAMPLE_DATA *p);
   BOOL ParseDatFile(char *p);

   // Misc functions
   void FoldWindow(HWND hWnd);
   BOOL CheckCD(TCHAR *lpFileName);

   // CIvAutoObject * m_IvAutoObj;
   UINT  m_iDir;
   UINT  m_drivetypes[26];
   TCHAR  m_szDir[MAX_PATHLEN * 2];
   TCHAR  m_szOemPath[MAX_PATHLEN * 2];
   TCHAR m_szDrive[26];
   INT   m_TextCharWidth;
   TCHAR  m_szBaseDir[MAX_PATHLEN * 2];
   BOOL m_bSetDefPath;
   SAMPLE_DATA* m_pFirstSample;
   TCHAR    m_szDefSamplePath[MAX_PATHLEN * 2];
   BOOL     m_bCopyAllSamples;
   BOOL     m_bCompressed;
   TCHAR    m_szURL[INTERNET_MAX_URL_LENGTH];
   TCHAR    m_szSmplPath[MAX_PATHLEN * 2];
   TCHAR    m_szDialogTitle[100];

   HIMAGELIST m_hImageList;
   HFONT m_hJapaneseFont;
   CHtmlHelpControl* m_pHtmlHelpCtl;
};

class COverwriteDlg : public CDlg
{
public:
    COverwriteDlg(HWND hwndParent, char *pszName) : CDlg(hwndParent, IDD_SAMPLE_EXIST)
    {
        if(pszName)
            pszFileName = pszName;
        else
            pszFileName = "";
    }
    BOOL OnBeginOrEnd();

private:
    char* pszFileName;
};

#endif // __SAMPLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\search.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CSEARCH_H__
#define __CSEARCH_H__

#ifndef __SITEMAP_H__
#include "sitemap.h"
#endif

#include "clistbox.h"
#include "fts.h"
#include "listview.h"
#include "secwin.h"

#include "navui.h" // Clean up headers.

// Common navpane functions. Used for processing accelerators.
#include "navpane.h"

///////////////////////////////////////////////////////////
//
// Forward References
//
class CHtmlHelpControl; // forward reference


///////////////////////////////////////////////////////////
//
// CSearch Declaration
//
class CSearch : public INavUI
{
public:
        //--- Internal Contants
    typedef enum DlgItemInfoIndex
    {
        c_KeywordEdit,
        c_ListTopicBtn,
        c_ResultsList,
        c_DisplayBtn,

        c_NumDlgItems
    };

    //--- Construction
    CSearch(CHHWinType* phh);
   virtual ~CSearch();

    //--- INavUI Interface
   BOOL  Create (HWND hwndParent);
   LRESULT OnCommand (HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam);
   void  ResizeWindow ();
   void  SetPadding (int pad) { m_padding = pad; }
   void  SetTabPos (int tabpos) { m_NavTabPos = tabpos; }
   void  HideWindow (void);
   void  ShowWindow (void);

    //--- INavUI Interface functions - NEW
    void    SetDefaultFocus () ;
    bool    ProcessMenuChar (HWND hwndParent, int ch);
    LRESULT OnNotify (HWND hwnd, WPARAM wParam, LPARAM lParam) ;
    void OnDrawItem(UINT id, LPDRAWITEMSTRUCT pdis) {/*Not Implemented*/}
    void    Seed(LPCSTR pszSeed) {/*Not Implemented*/}
    void OnVKListNotify(NMHDR* pNMHdr) {/*Not Implemented*/}

    //--- Helper functions.
protected:
    // Returns the font to be used.
    HFONT GetContentFont() { return m_phh->GetContentFont(); }

    void    InitDlgItemArray() ;


    //--- Calbacks
private:
    static LRESULT WINAPI ComboProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT WINAPI ListViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT WINAPI ListBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static LRESULT WINAPI DisplayBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    static WNDPROC s_lpfnlComboWndProc;
    static WNDPROC s_lpfnlListViewWndProc;

    // Member data.
protected:
   int   m_cFonts;

    CHHWinType* m_phh;
    CExCollection* m_pTitleCollection;

    HPALETTE    m_hpalBackGround;
    HBRUSH      m_hbrBackGround;     // background brush
    HBITMAP     m_hbmpBackGround;
    int         m_cxBackBmp;
    int         m_cyBackBmp;
    HWND        m_hwndComboBox; //TODO: This isn't a combobox.
    HWND        m_hwndListBox;
    HWND        m_hwndDisplayButton;
    HWND        m_hwndListTopicsButton;
    HWND        m_hwndStaticKeyword;
    HWND        m_hwndStaticTopic;
    CFTSListView    *m_plistview;           // class to manage the list view control
    int         m_padding;
    int         m_NavTabPos;    // location of parent tabs

    // The window passed into create is not the actual parent window of the
   // controls. Instead, the controls are always parented to the Navigation window
   // which owns the tabs. For resizing, we need to have a pointer to the
   // tabctrl window. So, we save this pointer here.
   HWND m_hwndResizeToParent ;

    // Array of dlgitems
    CDlgItemInfo m_aDlgItems[c_NumDlgItems] ;

};

#endif  // __CSEARCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\secwin.cpp ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

// Precompiled header
#include "header.h"
#include "state.h"
#include "cctlww.h"
#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif
///////////////////////////////////////////////////////////
//
// Includes
//
#include "secwin.h"  // Header for this file.
#include "hha_strtable.h"
#include "contain.h"
#include "highlite.h"
#include "resource.h"            // needed for subset picker combo control ID.
#include "subset.h"                 // Needed to dealing with CStructucturalSubset object.
// Advanced Search UI header.
#include "adsearch.h"
#include "search.h"

// Bookmarks Nav Pane
#include "bookmark.h"

// Custom NavPane
#include "custmtab.h"

// Sizebar class
#include "sizebar.h"

#define ACCESS_KEY  '&'

static const char txtAccessKey[] = "&";

BOOL HxInsertMenuItem(HMENU, UINT, BOOL, MENUITEMINFOA *);

///////////////////////////////////////////////////////////
//
// Globals
//
// Pointer to global array of window types.
CHHWinType** pahwnd = NULL;


AUTO_CLASS_COUNT_CHECK( CHHWinType );

///////////////////////////////////////////////////////////
//
// Function Implementation
//

/***************************************************************************

    FUNCTION:   GetCurrentCollection

    PURPOSE:    Returns the currect collection

    PARAMETERS:
        None.

    RETURNS:    Pointer to the currect collection (CExCollection)

    COMMENTS:
        This function returns the current collection based on the
        current active window and window type.  Use this function
        anytime you need a pointer to the currect active collection
        when you can assume that the collection is already loaded.

    MODIFICATION DATES:
        15-Sept-1997 [paulti]

        29-April-1998 [mikecole]
            As per agreement of all hhctrl devs I am adding a .CHM filespec argument
            to this function. Since it is possible for a single task to utilize hhctrl
            services on multiple CExCollections we will distinguish CExCollections
            from one another by using a .CHM filespec.

***************************************************************************/
CExCollection* GetCurrentCollection( HWND hwnd, LPCSTR lpszChmFilespec )
{
   CExCollection* pCExCol;
   PSTR psz;
   TCHAR szFN[MAX_PATH];
   TCHAR szFN2[MAX_PATH];
   int i = 0;

   szFN[0] = '\0';
   if ( lpszChmFilespec )
   {
      //
      // First, we need to normalize the filespec. This thing can come to us in any number of
      // forms, it could be a URL, it could be an unqualified  filename, a fully qualified path...
      //
      if ( psz = stristr(lpszChmFilespec, txtDefExtension) )
      {
         while ( *psz != ' ' && *psz != '/' && *psz != '\\' && *psz != '@' && *psz != '\0' && *psz != ':' && (psz != lpszChmFilespec) )
         {
            psz = CharPrev(lpszChmFilespec, psz);
            i++;
            if(IsDBCSLeadByte(*CharNext(psz)))
              i++;
         }
         if ( psz != lpszChmFilespec )
            psz++;
         else
            i++;
         lstrcpyn(szFN, psz, i);
      }
      //
      // Next, see if the filespec matches a single title .CHM or and merged .CHMs of a single title .CHM.
      //
      if ( szFN[0] )
      {
         for (int i = 0; i < g_cHmSlots; i++)
         {
            if ( g_phmData[i] && g_phmData[i]->m_pTitleCollection && g_phmData[i]->m_pTitleCollection->IsSingleTitle() )
            {
               //
               // Search title list for a match.
               //
               CExTitle* pTitle;
               pCExCol = g_phmData[i]->m_pTitleCollection;
               pTitle = pCExCol->GetFirstTitle();
               while ( pTitle )
               {
                  _splitpath((LPCSTR)pTitle->GetContentFileName(), NULL, NULL, szFN2, NULL);
                  if (! lstrcmpi(szFN, szFN2) )
                    return g_phmData[i]->m_pTitleCollection;
                  pTitle = pTitle->GetNext();
               }
            }
         }
      }
   }
   //
   // Last resort...
   //
   if ( g_pCurrentCollection )
      return g_pCurrentCollection;
   else if ( g_phmData && g_phmData[0] )
      return g_phmData[0]->m_pTitleCollection;
   else return NULL;                               // Ohhh, very bad!
}

/***************************************************************************

    FUNCTION:   GetCurrentURL

    PURPOSE:    Returns the currect URL

    PARAMETERS:
        None.

    RETURNS:    TRUE if found with pcszCurrentURL filed in, otherwise FALSE.

    COMMENTS:
        This function returns the current URL based on the
        current active window and window type.

    MODIFICATION DATES:
        10-Dec-1997 [paulti]

***************************************************************************/
BOOL GetCurrentURL( CStr* pcszCurrentURL, HWND hwnd )
{
  ASSERT(pahwnd);
  CHHWinType* phh = NULL;
  BOOL bFound = FALSE;

  // if anyone can find a guarenteed way to get the current
  // URL please modify the code below [paulti]
  if( !hwnd )
    hwnd = GetActiveWindow();
  phh = FindHHWindowIndex(hwnd);
  if( phh && phh->m_pCIExpContainer &&
      phh->m_pCIExpContainer->m_pWebBrowserApp ) {
    phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL( pcszCurrentURL );
    bFound = TRUE;
  }

  return bFound;
}

HFONT CHHWinType::GetContentFont()
{
   if ( m_phmData )
   {
      CExTitle* pTitle = m_phmData->m_pTitleCollection->GetMasterTitle();
      return (pTitle->GetInfo()->GetContentFont());
   }
   else
      return _Resource.GetUIFont();  // This would be highly unusual!
 }

HFONT CHHWinType::GetAccessableContentFont()
{
   if ( m_phmData )
   {
      CExTitle* pTitle = m_phmData->m_pTitleCollection->GetMasterTitle();
      return (pTitle->GetInfo()->GetAccessableContentFont());
   }
   else
      return _Resource.GetUIFont();  // This would be highly unusual!
 }

INT CHHWinType::GetContentCharset()
{
   if ( m_phmData )
   {
      CExTitle* pTitle = m_phmData->m_pTitleCollection->GetMasterTitle();
      return (pTitle->GetInfo()->GetTitleCharset());
   }
   else
      return ANSI_CHARSET; // This would be highly unusual!
 }

UINT CHHWinType::GetCodePage(void)
{
   if ( m_phmData )
   {
      CExTitle* pTitle = m_phmData->m_pTitleCollection->GetMasterTitle();
      return (pTitle->GetInfo()->GetCodePage());
   }
   else
      return 0; // This would be highly unusual!
}

/***************************************************************************

    FUNCTION:   CHHWinType::SetString

    PURPOSE:    Set a window type string

    PARAMETERS:
        pszSrcString
        ppszDst

    RETURNS:

    COMMENTS:
        If string is non-NULL and non-empty, frees any previous string memory
        and allocates and copies the string.

    MODIFICATION DATES:
        09-Sep-1997 [ralphw]

***************************************************************************/

void CHHWinType::SetString(PCSTR pszSrcString, PSTR* ppszDst)
{
    if (!pszSrcString)
        return;

    CStr csz ;
    if (IsUniCodeStrings())
        csz = (WCHAR*) pszSrcString;
    else
        csz = pszSrcString;
    if (csz.IsNonEmpty())
    {
        if (*ppszDst)
            lcFree(*ppszDst);
        csz.TransferPointer(ppszDst);
    }
}

/***************************************************************************

    FUNCTION:   CHHWinType::SetUrl

    PURPOSE:    Set a window type URL

    PARAMETERS:
        pszSrcString
        ppszDst

    RETURNS:

    COMMENTS:
        If string is non-NULL and non-empty, frees any previous string memory
        and allocates and copies the string.

        If the string contains a compiled HTML filename, then the URL
        is converted into a full path.

    MODIFICATION DATES:
        09-Sep-1997 [ralphw]

***************************************************************************/

void CHHWinType::SetUrl(PCSTR pszSrcString, PSTR* ppszDst)
{
    if (!pszSrcString)
        return;

    CStr csz;
    if (IsUniCodeStrings())
        csz = (WCHAR*) pszSrcString;
    else
        csz = pszSrcString;
    if (csz.IsNonEmpty())
    {
        if (*ppszDst)
            lcFree(*ppszDst);
        CStr cszFull;
        if (IsCompiledHtmlFile(csz, &cszFull))
            cszFull.TransferPointer(ppszDst);
        else
            csz.TransferPointer(ppszDst);
    }
}

void CHHWinType::SetTypeName(HH_WINTYPE* phhWinType)
{
    SetString(phhWinType->pszType, (PSTR*) &pszType);
    if (pszType && *pszType == '>')
        strcpy((PSTR) pszType, pszType + 1);
}

/**********************************************************
    FUNCTION    SetJump1

    NOTES
                The button caption pszJump1 can be empty.
                The URL cannot.
***********************************************************/
void CHHWinType::SetJump1(HH_WINTYPE* phhWinType)
{
    if (!(fsToolBarFlags & HHWIN_BUTTON_JUMP1) || (phhWinType->pszUrlJump1 == NULL))
        return;

    SetString(phhWinType->pszJump1, (PSTR*) &pszJump1);
    SetUrl(phhWinType->pszUrlJump1, (PSTR*) &pszUrlJump1);
}

/**********************************************************
    FUNCTION    SetJump2

    NOTES
                The button caption pszJump1 can be empty.
                The URL cannot.
***********************************************************/
void CHHWinType::SetJump2(HH_WINTYPE* phhWinType)
{
    if (!(fsToolBarFlags & HHWIN_BUTTON_JUMP2) || (phhWinType->pszUrlJump2 == NULL))
        return;
    SetString(phhWinType->pszJump2, (PSTR*) &pszJump2);
    SetUrl(phhWinType->pszUrlJump2, (PSTR*) &pszUrlJump2);
}

/**********************************************************
    FUNCTION    SetTabOrder

    NOTES
***********************************************************/
void CHHWinType::SetTabOrder(HH_WINTYPE* phhWinType)
{
    // REVIEW: We need to be able to loop true this array and find tabs.
    // This means that we need some way to determine the upper most array entry.
    // This is harder in the user defined case...[14 Jan 98]
    if (IsValidMember(HHWIN_PARAM_TABORDER))
        memcpy(tabOrder, phhWinType->tabOrder, sizeof(tabOrder));
    else {
        for (int j = HH_TAB_FAVORITES + 1; j < HH_TAB_CUSTOM_FIRST; j++)
            tabOrder[j] = -1;   // clear empty slots

        tabOrder[HH_TAB_CONTENTS]  = HH_TAB_CONTENTS;
        tabOrder[HH_TAB_INDEX]     = HH_TAB_INDEX;
        tabOrder[HH_TAB_SEARCH]    = HH_TAB_SEARCH;
        tabOrder[HH_TAB_HISTORY]   = HH_TAB_HISTORY;
        tabOrder[HH_TAB_FAVORITES] = HH_TAB_FAVORITES;
#ifdef __TEST_CUSTOMTAB__
        tabOrder[HH_TAB_AUTHOR] = HH_TAB_AUTHOR;    // hha.dll supplied tab
#endif

        // Setup the default tab order for the custom tabs.

        for (int i = HH_TAB_CUSTOM_FIRST; i <= HH_TAB_CUSTOM_LAST; i++)
            tabOrder[i] = (BYTE)i;

        // This member is now valid. Mark it as such.
        fsValidMembers |= HHWIN_PARAM_TABORDER ;
    }
}
//////////////////////////////////////////////////////////////////////////
//
//
//
DWORD
CHHWinType::GetStyles() const
{
    DWORD style = NULL ;
    if (IsValidMember(HHWIN_PARAM_STYLES))
    {
          style = dwStyles ;
    }

    if (!IsProperty(HHWIN_PROP_NODEF_STYLES))
    {
        style |= DEFAULT_STYLE ;
    }

    if (!IsProperty(HHWIN_PROP_NOTITLEBAR))
    {
        style |= WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX ;
    }

    return style ;
}

void CHHWinType::GetClientRect(RECT* prc)
{
    ::GetClientRect(hwndHelp, prc);

    if (IsValidWindow(hwndToolBar)) {
        RECT rc;
        ::GetWindowRect(hwndToolBar, &rc);
        prc->top += RECT_HEIGHT(rc);
    }
}

void CHHWinType::CalcHtmlPaneRect(void)
{
    ::GetClientRect(hwndHelp, &rcHTML);  // the total size of the help window

    if (IsValidWindow(hwndToolBar))
    {
        ::GetWindowRect(hwndToolBar, &rcToolBar);
        rcHTML.top += RECT_HEIGHT(rcToolBar);
        if (m_fNotesWindow)
        {
            int height = RECT_HEIGHT(rcNotes);
            CopyRect(&rcNotes, &rcHTML);
            if (!height)
                height = DEFAULT_NOTES_HEIGHT;
            rcNotes.bottom = rcNotes.top + height;
            rcHTML.top = rcNotes.bottom;
            if (IsExpandedNavPane())
                rcNotes.left += RECT_WIDTH(rcNav);
        }
    }

    if (IsExpandedNavPane() && !IsProperty(HHWIN_PROP_NAV_ONLY_WIN))
    {
        if( hwndNavigation )
          ::GetClientRect(hwndNavigation, &rcNav);
        if (m_pSizeBar)
        {
            rcHTML.left += m_pSizeBar->Width() + RECT_WIDTH(rcNav);
        }
        else
        {
            rcHTML.left += RECT_WIDTH(rcNav);
        }
    }

    rcNav.top = m_fNotesWindow ? rcNotes.top : rcHTML.top;

    if ( m_hWndSSCB )
       rcNav.top += m_iSSCBHeight;

    rcNav.bottom = rcHTML.bottom;
}

    // Wrap the toolbar
void CHHWinType::WrapTB()
{
extern SHORT    g_tbRightMargin;
extern SHORT    g_tbLeftMargin;
int             cRows, cButtons;
RECT            btnRc;
int             btnWidth=0;
int             btnspace;
int             btnsperrow;

    cButtons = (int)SendMessage(hwndToolBar, TB_BUTTONCOUNT, 0, 0);
    if (cButtons == 0)
    {
        ASSERT(cButtons != 0) ; // Should never happen.
        return ;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_EXPAND)
        cButtons--;
    ::GetWindowRect(hwndHelp, &rcWindowPos);

    for ( int i=0; (btnWidth==0)&&(i<cButtons); i++)
    {
        if ( SendMessage(hwndToolBar, TB_GETITEMRECT, (WPARAM)i, (LPARAM)&btnRc) )
            btnWidth = RECT_WIDTH(btnRc);
    }
    if ( btnWidth == 0 )
            btnWidth = TB_BTN_CX;

        // How many buttons per row??
    btnspace = RECT_WIDTH(rcWindowPos) -(g_tbLeftMargin+g_tbRightMargin);
    btnsperrow = btnspace / btnWidth;
    if( btnsperrow == 0 )
        btnsperrow = 1;
    cRows =  cButtons / btnsperrow;
    if ( cButtons % btnsperrow )
        cRows++;

    if (RECT_HEIGHT(btnRc) == 0)
    {
        ASSERT(RECT_HEIGHT(btnRc) != 0) ;
        return ; // Avoid divide by zero.
    }

    if ( cRows < RECT_HEIGHT(rcToolBar)/RECT_HEIGHT(btnRc))
    {
        WPARAM wParam = MAKEWPARAM( cRows, FALSE);
        SendMessage(hwndToolBar, TB_SETROWS, wParam, (LPARAM)&rcToolBar);
    } 
	else if ( cRows > RECT_HEIGHT(rcToolBar)/RECT_HEIGHT(btnRc)  )
    {
        WPARAM wParam = MAKEWPARAM( cRows, TRUE);
        SendMessage(hwndToolBar, TB_SETROWS, wParam, (LPARAM)&rcToolBar);
    }

    ::GetClientRect(hwndToolBar, &rcToolBar);
    rcToolBar.bottom = rcToolBar.top + cRows*RECT_HEIGHT(btnRc);
    rcToolBar.right = RECT_WIDTH(rcWindowPos);
    MoveWindow(hwndToolBar, rcToolBar.top+g_tbLeftMargin, rcToolBar.left, RECT_WIDTH(rcToolBar)-(g_tbLeftMargin+g_tbRightMargin), RECT_HEIGHT(rcToolBar), TRUE);

}


void CHHWinType::ToggleExpansion(bool bNotify /*=true*/)
{
    if (!IsValidWindow(GetHwnd()))
    {
        return ;
    }

    if (bNotify)
    {
        // Review: Should we check the return value? [dalero: 21 Sep 98]
        OnTrackNotifyCaller(IsExpandedNavPane() ? HHACT_CONTRACT : HHACT_EXPAND) ;
    }

    RECT rc;
    if (RECT_WIDTH(rcNav) <= 0)
    {
        rcNav.right = (iNavWidth ? iNavWidth : DEFAULT_NAV_WIDTH);
    }

    if (fNotExpanded)
    {
        fNotExpanded = FALSE;  // now expanding
        if (IsProperty(HHWIN_PROP_NAV_ONLY_WIN))
        {
            if (IsValidWindow(hwndHTML) )
            {
                ShowWindow(hwndHTML, SW_HIDE);
            }
        }
        else
        {  // normal tri-pane window
            // Expand the window to the left to make room

            ::GetWindowRect(GetHwnd(), &rc);
            rc.left -= RECT_WIDTH(rcNav) + m_pSizeBar->Width() ;
            GetWorkArea(); // Multiple Monitor support.
            if (rc.left < g_rcWorkArea.left)
            {
                rc.left = g_rcWorkArea.left;
            }

            /*
                BUG 3463 --- the MoveWindow call below was not sending a WM_SIZE message, when
                RECT_WIDTH(rc) > the width of the screen. Adjusting the width fixes this issue.nn
            */
            // Don't make the window wider than the screen width.
            if (rc.right > g_rcWorkArea.right)
            {
                rc.right = g_rcWorkArea.right;
            }

            // create a size bar window between the Nav pane and the HTML pane
            CreateSizeBar(); // Moved because the function below resizes...

            if (!m_fLockSize)
            {
                MoveWindow(GetHwnd(), rc.left, rc.top, RECT_WIDTH(rc), RECT_HEIGHT(rc), TRUE);
            }
        }
        CreateOrShowNavPane();
        if (GetToolBarHwnd())
        {
            SendMessage(GetToolBarHwnd(), TB_HIDEBUTTON, IDTB_EXPAND, TRUE);
            SendMessage(GetToolBarHwnd(), TB_HIDEBUTTON, IDTB_CONTRACT, FALSE);
            SendMessage(GetToolBarHwnd(), TB_ENABLEBUTTON, IDTB_CONTRACT, TRUE);
        }
    }
    else
    {
        fNotExpanded = TRUE;

        DestroySizeBar();

        if ( m_hWndST )
           ShowWindow(m_hWndST, SW_HIDE);

        if ( m_hWndSSCB )
           ShowWindow(m_hWndSSCB, SW_HIDE);

        if (IsValidWindow(hwndNavigation))
        {
            ShowWindow(hwndNavigation, SW_HIDE);
        }
        if (IsProperty(HHWIN_PROP_NAV_ONLY_WIN))
        {
            ShowWindow(hwndHTML, SW_SHOW);
        }
        else
        {
            ::GetWindowRect(GetHwnd(), &rc);
            if (!m_fLockSize)
                rc.left += RECT_WIDTH(rcNav) + m_pSizeBar->Width() ;

         // make sure we are not going off the screen Bug 6611
            GetWorkArea(); // Multiple Monitor support.
         if (rc.left > g_rcWorkArea.right)
         {
            int min = GetSystemMetrics(SM_CXHTHUMB);
            rc.left = g_rcWorkArea.right - min*2;
         }

            MoveWindow(GetHwnd(), rc.left, rc.top, RECT_WIDTH(rc), RECT_HEIGHT(rc), TRUE);
        }

        if (GetToolBarHwnd())
        {
            SendMessage(GetToolBarHwnd(), TB_HIDEBUTTON, IDTB_CONTRACT, TRUE);
            SendMessage(GetToolBarHwnd(), TB_HIDEBUTTON, IDTB_EXPAND, FALSE);
            SendMessage(GetToolBarHwnd(), TB_ENABLEBUTTON, IDTB_EXPAND, TRUE);
        }
    }
}

void CHHWinType::CreateSizeBar( void )
{
    if (!m_pSizeBar && IsValidWindow(GetHTMLHwnd()))
    {
        m_pSizeBar = new CSizeBar ;
        ASSERT(m_pSizeBar) ;
        m_pSizeBar->Create(this) ;
    }
}


void CHHWinType::DestroySizeBar( void )
{
    if (m_pSizeBar)
    {
        delete m_pSizeBar ;
        m_pSizeBar = NULL ;
    }
}

void CHHWinType::CreateOrShowNavPane(void)
{
    if (IsProperty(HHWIN_PROP_NAV_ONLY_WIN))
        rcNav.right = rcHTML.right;

    if (!IsValidWindow(hwndNavigation)/* && !IsProperty(HHWIN_PROP_NO_TOOLBAR)*/) {
        rcNav.left = 0;
        if (RECT_WIDTH(rcNav) <= 0)
        {
            rcNav.right = (iNavWidth ? iNavWidth : DEFAULT_NAV_WIDTH);
        }
        CalcHtmlPaneRect();
        //
        // Create the structural subset picker combo if necessary.
        //

        if (m_phmData && // BUG 5214
            m_phmData->m_sysflags.fDoSS && !
            m_phmData->m_pTitleCollection->IsSingleTitle() )
        {
           HFONT         hFont, hFontOld;
           TEXTMETRIC    tm;
           HDC           hDC;
           RECT          rc;

           hFont =  _Resource.GetAccessableUIFont(); // GetUIFont();
           hDC = GetDC(NULL);
           hFontOld = (HFONT)SelectObject(hDC, hFont);
           GetTextMetrics(hDC, &tm);
           SelectObject(hDC, hFontOld);
           ReleaseDC(NULL, hDC);
           rcNav.top += 5;
           m_iSSCBHeight = 5;
           if ( (m_hWndST = CreateWindow("STATIC", GetStringResource(IDS_SUBSET_UI), WS_CHILD , rcNav.left + 6, rcNav.top,
                                   RECT_WIDTH(rcNav) - 8, tm.tmHeight, GetHwnd(), NULL, _Module.GetModuleInstance(), NULL)) )
           {
              SendMessage(m_hWndST, WM_SETFONT, (WPARAM)hFont, 0L);
              rcNav.top += tm.tmHeight + 2;
              m_iSSCBHeight += tm.tmHeight + 2;
              rc.left = rcNav.left + 6;
              rc.top = rcNav.top;
              rc.right = rcNav.right - 10;
              rc.bottom = rcNav.top + tm.tmHeight + 10;

              if(g_bWinNT5)
              {
				  SetWindowTextW(m_hWndST,GetStringResourceW(IDS_SUBSET_UI));
			  }


              m_hWndSSCB = CreateWindow("COMBOBOX", NULL, (WS_CHILD | CBS_DROPDOWNLIST | CBS_SORT | WS_VSCROLL), rc.left, rc.top,
                                        RECT_WIDTH(rc), RECT_HEIGHT(rc) + 80, GetHwnd(), (HMENU)IDC_SS_PICKER,
                                        _Module.GetModuleInstance(), NULL);

              SendMessage(m_hWndSSCB, WM_SETFONT, (WPARAM)GetAccessableContentFont(), 0L);
              rcNav.top += tm.tmHeight + 11;
              m_iSSCBHeight += tm.tmHeight + 11;
              ShowWindow(m_hWndST, SW_SHOW);
              ShowWindow(m_hWndSSCB, SW_SHOW);
              //
              // Populate the combo.
              //
              if ( m_phmData->m_pTitleCollection->m_pSSList )
              {
                 CStructuralSubset* pSSSel = NULL, *pSS = NULL;
                 while ( pSS = m_phmData->m_pTitleCollection->m_pSSList->GetNextSubset(pSS) )
                 {
                    if (! pSS->IsEmpty() )                                                 // Don't put "new" here.
					 {
						 if(g_bWinNT5)
						 {
                             CExTitle *pTitle = m_phmData->m_pTitleCollection->GetFirstTitle();

                             DWORD cp;
							 
                             if(pSS->IsEntire() == TRUE)
                                cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
                             else
                                cp = CodePageFromLCID((pTitle->GetInfo())->GetLanguage());
							 
							 DWORD dwSize = (DWORD)(sizeof(WCHAR) * strlen(pSS->GetName())) + 4;
							 WCHAR *pwcString = (WCHAR *) lcMalloc(dwSize);
							 
							 if(pwcString)
							 {
								 MultiByteToWideChar(cp, MB_PRECOMPOSED, pSS->GetName(), -1, pwcString, dwSize);
								 
								 SendMessageW(m_hWndSSCB, CB_ADDSTRING, 0, (LPARAM)pwcString);
								 
								 lcFree(pwcString);	
							 }
						 }
						 else
						 {
							 SendMessage(m_hWndSSCB, CB_ADDSTRING, 0, (LPARAM)pSS->GetName());
						 }
					 }
                    if ( pSS->IsTOC() )
                       pSSSel = pSS;
                 }
                 // Select as appropiate...
                 //
                 if (! pSSSel )
                    pSSSel = m_phmData->m_pTitleCollection->m_pSSList->GetEC();

                 if(g_bWinNT5 && pSSSel->IsEntire())
                 {
                    // This code special cases the selection of the "Entire Collection" subset in the combobox.
                    //
                    WCHAR pszUnicodeSubsetName[MAX_SS_NAME_LEN];

                    pszUnicodeSubsetName[0] = 0;

                    // Get the UI language codepage
                    //
                    DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));	 

                    // convert subset name to Unicode using UI codepage
                    //
                    MultiByteToWideChar(cp, MB_PRECOMPOSED, pSSSel->GetName(), -1, pszUnicodeSubsetName, sizeof(pszUnicodeSubsetName));

                    // select the subset in the combobox
                    //
                    SendMessageW(m_hWndSSCB, CB_SELECTSTRING, -1, (LPARAM)pszUnicodeSubsetName);
                 }
                 else
                    SendMessage(m_hWndSSCB, CB_SELECTSTRING, -1, (LPARAM)pSSSel->GetName());


                 m_phmData->m_pTitleCollection->m_pSSList->SetFTS(pSSSel);
                 m_phmData->m_pTitleCollection->m_pSSList->SetF1(pSSSel);
                 m_phmData->m_pTitleCollection->m_pSSList->SetTOC(pSSSel);
                 pSSSel->SelectAsTOCSubset(m_phmData->m_pTitleCollection);
              }
           }
        }
        //
        // Create the HH CHILD window on which the SysTabCtrl32 window will sit.
        //txtHtmlHelpChildWindowClass
        hwndNavigation = W_CreateWindow(L"HH Child", NULL, WS_CHILD, rcNav.left, rcNav.top, RECT_WIDTH(rcNav),
                                      RECT_HEIGHT(rcNav), GetHwnd(), NULL, _Module.GetModuleInstance(), NULL);

        // How many tabs do we have?
        int cTabs = GetValidNavPaneCount();
        if (cTabs > 1)
        {
            // Remove the non-existant tabs from the tab order.

            int max = HH_MAX_TABS ;
            for (int i = 0; i < max; i++)  // Don't have to move last if invalid So don't add 1 to HH_MAX_TABS
            {
                if (!IsValidNavPane(tabOrder[i]))
                {
                    // Collapse the array.
                    MemMove(&tabOrder[i], &tabOrder[i + 1], max - i);
                    // Decrement the count so we do this index again.
                    i-- ;
                    max-- ;
                }
            }

            // Now create the tab.
            m_pTabCtrl = new CTabControl(hwndNavigation, tabpos, this);
        }
        ResizeWindow(this);
    }
    if (!IsProperty(HHWIN_PROP_NO_TOOLBAR))
        ShowWindow(hwndNavigation, SW_SHOW);
    if (m_pTabCtrl)
        ShowWindow(m_pTabCtrl->hWnd(), SW_SHOW);
    if ( m_hWndST )
       ShowWindow(m_hWndST, SW_SHOW);
    if ( m_hWndSSCB )
       ShowWindow(m_hWndSSCB, SW_SHOW);

    //Validate the current nav pane.
    if (!IsValidNavPane(curNavType))
    {
        // The current nav pane doesn't exist. Pick another.
        curNavType = GetValidNavPane() ;
        if (curNavType < 0)
        {
            ASSERT(0) ; // Should never happen.
            return; // hopeless...
        }
    }

    // Create the nav pane if needed.
    CreateNavPane(curNavType) ;

    // Show the pane.
    if (m_aNavPane[curNavType])
    {
        if (curNavType != 0 && m_pTabCtrl)
            TabCtrl_SetCurSel(m_pTabCtrl->hWnd(), GetTabIndexFromNavPaneIndex(curNavType));
        m_aNavPane[curNavType]->ShowWindow() ;

        // BUG HH 16685 - The current tab is now persisted. So we come along and
        // create this new tab. However, resize is never called. So, we will call
        // resize here to make sure that we resize the window.
        m_aNavPane[curNavType]->ResizeWindow() ;
    }
    if ( m_pSizeBar )
       m_pSizeBar->ResizeWindow();
}

void CHHWinType::CreateOrShowHTMLPane(void)
{
    if (!IsValidWindow(hwndNavigation))
        hwndHTML = CreateWindow(txtHtmlHelpChildWindowClass, NULL,
            WS_CHILD | WS_CLIPCHILDREN, rcHTML.left, rcHTML.top,
            RECT_WIDTH(rcHTML), RECT_HEIGHT(rcHTML), GetHwnd(), NULL,
            _Module.GetModuleInstance(), NULL);
    ShowWindow(hwndHTML, SW_SHOW);
}

void CHHWinType::CreateToc(void)
{
    if (IsEmptyString(pszToc))
        return;
    TCHAR szPath[MAX_URL];
    if (!ConvertToCacheFile(pszToc, szPath)) {
        AuthorMsg(IDS_CANT_OPEN, pszToc);
        strcpy(szPath, pszToc);
    }

    CToc* ptoc = new CToc(NULL, NULL, this);
    m_aNavPane[HH_TAB_CONTENTS] = ptoc ;
    ptoc->SetTabPos(tabpos);
    ptoc->SetPadding(TAB_PADDING);
    ptoc->ReadFile(szPath);

        // populate the InfoType member object of the CToc
    if ( !ptoc->m_pInfoType )
    {
        if (ptoc->m_phh && ptoc->m_phh->m_phmData && ptoc->m_phh->m_phmData->m_pdInfoTypes  )
        {   // load from the global IT store
            ptoc->m_pInfoType = new CInfoType;
            ptoc->m_pInfoType->CopyTo( ptoc->m_phh->m_phmData );
#if 0   // for subset testing purposes
#include "csubset.h"
            CSubSets *pSubSets = new CSubSets( ptoc->m_pInfoType->InfoTypeSize(), ptoc->m_pInfoType, TRUE );
            pSubSets->CopyTo( ptoc->m_phh->m_phmData );
#endif
        }
        else {
                // no global IT's; load from the .hhc IT store
            ptoc->m_pInfoType = new CInfoType;
            *ptoc->m_pInfoType = ptoc->m_sitemap;
        }
    }

    ptoc->SetStyles(WS_EX_CLIENTEDGE,
        ptoc->m_sitemap.m_tvStyles == (DWORD) -1 ?
        DEFAULT_TOC_STYLES : ptoc->m_sitemap.m_tvStyles);
    ptoc->Create((m_pTabCtrl ? m_pTabCtrl->hWnd() :
        (IsValidWindow(hwndNavigation) ? hwndNavigation : hwndHelp)));
    ptoc->m_fHack = FALSE;

    ptoc->InitTreeView();

}

void CHHWinType::UpdateInformationTypes(void)
{
    if ( m_aNavPane[HH_TAB_CONTENTS] )
    {
        m_aNavPane[HH_TAB_CONTENTS]->Refresh();
        if (IsProperty(HHWIN_PROP_AUTO_SYNC) && IsExpandedNavPane())
        {
            CStr cszUrl;
            m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);
            m_aNavPane[HH_TAB_CONTENTS]->Synchronize(cszUrl);
        }
        // Next/Prev command UI updates...
        //
        UpdateCmdUI();
    }
    if ( m_aNavPane[HH_TAB_INDEX] && curNavType == HHWIN_NAVTYPE_INDEX )
       m_aNavPane[HH_TAB_INDEX]->Refresh();
}

void CHHWinType::UpdateCmdUI(void)
{
   HMENU hMenu;
   BOOL bEnable, ptoc;

   ptoc = (m_aNavPane[HH_TAB_CONTENTS] != NULL);
   if ( IsValidWindow(hwndToolBar) )
   {
      if ( hwndHelp )
         hMenu = GetMenu(hwndHelp);
      //
      //   Does TOCNext or TOCPrev need to be enabled/disabled ?
      //
      if ( (fsToolBarFlags & HHWIN_BUTTON_TOC_PREV) || (fsToolBarFlags & HHWIN_BUTTON_TOC_NEXT) || hMenu )
      {
         bEnable = ptoc ? OnTocPrev(FALSE) : FALSE ; // If no TOC, disable.
         if ( fsToolBarFlags & HHWIN_BUTTON_TOC_PREV )
            SendMessage(hwndToolBar, TB_ENABLEBUTTON, IDTB_TOC_PREV, bEnable);
         if ( hMenu )
            EnableMenuItem(hMenu, IDTB_TOC_PREV, (MF_BYCOMMAND | (bEnable?MF_ENABLED:MF_GRAYED)));

         bEnable = ptoc ? OnTocNext(FALSE) : FALSE; // If no TOC, disable.
         if ( fsToolBarFlags & HHWIN_BUTTON_TOC_NEXT )
           SendMessage(hwndToolBar, TB_ENABLEBUTTON, IDTB_TOC_NEXT, bEnable);
         if ( hMenu )
           EnableMenuItem(hMenu, IDTB_TOC_NEXT, (MF_BYCOMMAND | (bEnable?MF_ENABLED:MF_GRAYED)));
      }
      if (NoRun() == TRUE)
      {
         if (hMenu)
            EnableMenuItem(hMenu, HHM_JUMP_URL, MF_BYCOMMAND|MF_GRAYED);
      }
   }
}

///////////////////////////////////////////////////////////
//
// CreateIndex
//
void CHHWinType::CreateIndex(void)
{
    if (IsEmptyString(pszIndex))
        return;
    TCHAR szPath[MAX_URL];
    if (!ConvertToCacheFile(pszIndex, szPath)) {
        AuthorMsg(IDS_CANT_OPEN, pszIndex);
        strcpy(szPath, pszIndex);
    }

    if (!m_aNavPane[HH_TAB_INDEX])
    {
        CIndex* pIndex = new CIndex(NULL, NULL, this);
        m_aNavPane[HH_TAB_INDEX] = pIndex ;
        pIndex->SetPadding(TAB_PADDING);
        pIndex->SetTabPos(tabpos);
        pIndex->ReadIndexFile(szPath); // A CIndex function, but not a INavUI function.
    }
    m_aNavPane[HH_TAB_INDEX]->Create(GetTabCtrlHwnd());
}

///////////////////////////////////////////////////////////
//
// CreateSearchTab
//
void CHHWinType::CreateSearchTab(void)
{
    if (!
       m_phmData || !m_phmData->m_pTitleCollection->m_pFullTextSearch)
        return; // no compiled information

    if (!m_aNavPane[HH_TAB_SEARCH])
    {
        if (IsProperty(HHWIN_PROP_TAB_ADVSEARCH))
        {
            //---Create the Advanced Search Navigation Pane.
            m_aNavPane[HH_TAB_SEARCH] = new CAdvancedSearchNavPane(this);
        }
        else
        {
            //---Create the simple Search Navigation Pane.
            m_aNavPane[HH_TAB_SEARCH] = new CSearch(this);
        }
        m_aNavPane[HH_TAB_SEARCH]->SetPadding(TAB_PADDING);
        m_aNavPane[HH_TAB_SEARCH]->SetTabPos(tabpos);
    }

    m_aNavPane[HH_TAB_SEARCH]->Create(GetTabCtrlHwnd());
}

///////////////////////////////////////////////////////////
//
// CreateBookmarksTab
//
void
CHHWinType::CreateBookmarksTab()
{
    if (!m_aNavPane[HH_TAB_FAVORITES])
    {
        CBookmarksNavPane* p= new CBookmarksNavPane(this);
        m_aNavPane[HH_TAB_FAVORITES] = p;
        p->SetPadding(TAB_PADDING);
        p->SetTabPos(tabpos);
    }
    m_aNavPane[HH_TAB_FAVORITES]->Create(GetTabCtrlHwnd());
}

///////////////////////////////////////////////////////////
//
// CreatesCustomTab - Creates a tab defined by the client.
//
void
CHHWinType::CreateCustomTab(int iPane, LPCOLESTR pszProgId)
{
    // REVIEW: The lines marked with [chm] assume that the information can be found in the chm file.
    if (!m_aNavPane[iPane])
    {
        CCustomNavPane* p= new CCustomNavPane(this);
        m_aNavPane[iPane] = p;
        p->SetPadding(TAB_PADDING);
        p->SetTabPos(tabpos);

        p->SetControlProgId(pszProgId); //[chm] We could also use the GUID instead/in addition.
    }
    m_aNavPane[iPane]->Create(GetTabCtrlHwnd());
}

///////////////////////////////////////////////////////////
//
// Destructor
//
CHHWinType::~CHHWinType()
{
    CloseWindow();
}

extern BOOL    g_fThreadCall;
extern HWND    g_hwndApi;

//
// This member can be called from DllMain at process detach time. Note that this is only a partial cleanup but
// it's the best we can do at process detach time.
//
//
void CHHWinType::ProcessDetachSafeCleanup()
{
   if (m_pTabCtrl) {
       delete m_pTabCtrl;
       m_pTabCtrl = NULL;
   }

   // Get rid of the sizebar.
   DestroySizeBar() ;

   if (m_ptblBtnStrings) {
       delete m_ptblBtnStrings;
       m_ptblBtnStrings = NULL;
   }
}

void CHHWinType::CloseWindow()
{
    // Save the state..
    SaveState() ;

    // Things we can cleanup a process shutdown.
    ProcessDetachSafeCleanup() ;

    // Things we cleanup when we are reloading the nav panes.
    ReloadCleanup() ;

    // Free here and not in ReloadCleanup.
    CHECK_AND_FREE( pszHome );
    CHECK_AND_FREE( pszCustomTabs );
    CHECK_AND_FREE( pszType );
    CHECK_AND_FREE( pszCaption );

    if (m_pCIExpContainer)
    {
        m_pCIExpContainer->ShutDown();     // This call WILL end up doing the delete m_pCIExpContainer;
        m_pCIExpContainer = NULL;
    }

    if ( m_phmData && !m_phmData->Release() )     // Cleanup ChmData
    {
       //
       // Find this instance of the ChmData in the global array, null out it's entry and clean this one up.
       //
       for (int n = 0; n < g_cHmSlots; n++)
       {
           if ( g_phmData && (g_phmData[n] == m_phmData) )
           {
              g_phmData[n] = NULL;
           }
       }
    }
    m_phmData = NULL;

    if (IsProperty(HHWIN_PROP_POST_QUIT))
    {
        PostQuitMessage(0);
    }

    // Null out our window from the window list.
    for (int i = 0; i < g_cWindowSlots; i++)
    {
        if (pahwnd[i] != NULL && pahwnd[i]->hwndHelp == hwndHelp)
        {
            pahwnd[i] = NULL ;
        }
    }

    curNavType = 0;
    hwndHelp = NULL;

    // Do other windows exist?
    for (i = 0; i < g_cWindowSlots; i++)
    {
        if (pahwnd[i] != NULL && pahwnd[i]->hwndHelp != NULL)
        {
            // If other windows exist exit.
            return ;
        }
    }

    for(int j=0; i< c_NUMNAVPANES; i++)
    {
       if ( m_aNavPane[j] )
       {
           delete m_aNavPane[j];
           m_aNavPane[j] = NULL;
       }
    }
    if ( m_pTabCtrl )
    {
        delete m_pTabCtrl;
        m_pTabCtrl = NULL;
    }
    if ( m_pSizeBar )
    {
        delete m_pSizeBar;
        m_pSizeBar = NULL;
    }

    if (m_hAccel)
    {
        DestroyAcceleratorTable(m_hAccel) ;
        m_hAccel = NULL ;
    }

    if( m_hMenuOptions ) {
      DestroyMenu( m_hMenuOptions );
      m_hMenuOptions = NULL;
    }

    if( m_hImageListGray ) {
      ImageList_Destroy( m_hImageListGray );
      m_hImageListGray = NULL;
    }
   
    if( m_hImageList ) {
      ImageList_Destroy( m_hImageList );
      m_hImageList = NULL;
    }

    if( hwndToolBar ) {
      DestroyWindow( hwndToolBar );
      hwndToolBar = NULL;
    }

    // If we got here, all windows have been closed

    DeleteAllHmData();

#ifdef _CHECKMEM_ON_CLOSEWINDOW_
  _CrtMemDumpAllObjectsSince(&m_MemState) ;
#endif

    if (g_fThreadCall && g_hwndApi)
        PostQuitMessage(0);
}

////////////////////////////////////////////////////////////////
//
// ReloadCleanUp --- This is the things we have to clean up before we reload the nav pane.
//
void
CHHWinType::ReloadCleanup()
{
   // Delete all of the navigation panes.
   for(int j = 0 ; j < c_NUMNAVPANES ; j++)
   {
       if (m_aNavPane[j])
       {
           delete m_aNavPane[j] ;
           m_aNavPane[j] = NULL ;
       }
   }

    CHECK_AND_FREE( pszToc );
    CHECK_AND_FREE( pszIndex );
    CHECK_AND_FREE( pszFile );
    CHECK_AND_FREE( pszJump1 );
    CHECK_AND_FREE( pszJump2 );
    CHECK_AND_FREE( pszUrlJump1 );
    CHECK_AND_FREE( pszUrlJump2 );

    // Don't free this here. Because we need to keep this around.
    // CHECK_AND_FREE( pszHome );
    //CHECK_AND_FREE( pszCustomTabs );
    //CHECK_AND_FREE( pszType );
    //CHECK_AND_FREE( pszCaption );
}

void
CHHWinType::SaveState()
{
    WINDOW_STATE wstate;
    WINDOWPLACEMENT  winPlace;

    wstate.cbStruct = sizeof(wstate);

    winPlace.length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(GetHwnd(), &winPlace);

    if (winPlace.showCmd == SW_SHOWMINIMIZED)
    {
        wstate.rcPos = winPlace.rcNormalPosition;
    }
    else
   {
        ::GetWindowRect(GetHwnd(), &wstate.rcPos);
   }
    wstate.iNavWidth = rcNav.right;
    wstate.fHighlight = (m_phmData&&m_phmData->m_pTitleCollection->m_pSearchHighlight)?m_phmData->m_pTitleCollection->m_pSearchHighlight->m_bHighlightEnabled:TRUE;
    wstate.fLockSize = m_fLockSize;
    wstate.fNoToolBarText = m_fNoToolBarText;
    wstate.curNavType = curNavType;
    wstate.fNotExpanded = fNotExpanded;

    if( m_phmData ) {
      CState* pstate = m_phmData->m_pTitleCollection->GetState();
      if (SUCCEEDED(pstate->Open(GetTypeName(), STGM_WRITE))) {
          pstate->Write(&wstate, sizeof(wstate));
          pstate->Close();
      }
    }
}

int CHHWinType::CreateToolBar(TBBUTTON* pabtn)
{
        // create a dropdown menu for the options button to display
    int     cMenuItems=0;
    const int MENUITEMSTRINGLEN = 80;
    CStr    cszMenuItem;
    m_hMenuOptions = CreatePopupMenu();
    cszMenuItem.ReSize(MENUITEMSTRINGLEN);

    ASSERT(!IsProperty(HHWIN_PROP_NO_TOOLBAR));
    if (m_ptblBtnStrings)
        delete m_ptblBtnStrings;
    m_ptblBtnStrings = new CTable(256); // room for 256 bytes

    int cButtons = 0;

    MENUITEMINFO mii;
    ZERO_STRUCTURE ( mii );
    mii.cbSize      = sizeof(MENUITEMINFO);
    mii.fMask       = MIIM_TYPE|MIIM_STATE|MIIM_ID|MIIM_SUBMENU|MIIM_CHECKMARKS;
    mii.fType       = MFT_STRING;

    if (fsToolBarFlags & HHWIN_BUTTON_EXPAND) {
        pabtn[cButtons].iBitmap = 12;
        pabtn[cButtons].idCommand = IDTB_EXPAND;
        pabtn[cButtons].fsState = (IsExpandedNavPane() ? TBSTATE_HIDDEN : TBSTATE_ENABLED);
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_EXPAND));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_EXPAND) {
        pabtn[cButtons].iBitmap = 13;
        pabtn[cButtons].idCommand = IDTB_CONTRACT;
        pabtn[cButtons].fsState = (IsExpandedNavPane() ? TBSTATE_ENABLED : TBSTATE_HIDDEN);
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_CONTRACT));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_SYNC) {
        if (!IsEmptyString(pszToc)) {
            pabtn[cButtons].iBitmap = 9;
            pabtn[cButtons].idCommand = IDTB_SYNC;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_SYNC));
            cButtons++;
        }
    }

    if (fsToolBarFlags & HHWIN_BUTTON_TOC_PREV) {
        pabtn[cButtons].iBitmap = 14;
        pabtn[cButtons].idCommand = IDTB_TOC_PREV;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_TOC_PREV));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_TOC_NEXT) {
        pabtn[cButtons].iBitmap = 8;
        pabtn[cButtons].idCommand = IDTB_TOC_NEXT;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_TOC_NEXT));
        cButtons++;
    }


    if (g_fBiDi)
    {
        if (fsToolBarFlags & HHWIN_BUTTON_FORWARD) {
            pabtn[cButtons].iBitmap = 0;
            pabtn[cButtons].idCommand = IDTB_FORWARD;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_FORWARD));
            cButtons++;
        }

        if (fsToolBarFlags & HHWIN_BUTTON_BACK) {
            pabtn[cButtons].iBitmap = 1;
            pabtn[cButtons].idCommand = IDTB_BACK;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_BACK));
            cButtons++;
        }

    }
   else
   {
        if (fsToolBarFlags & HHWIN_BUTTON_BACK) {
            pabtn[cButtons].iBitmap = 0;
            pabtn[cButtons].idCommand = IDTB_BACK;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_BACK));
            cButtons++;
        }

        if (fsToolBarFlags & HHWIN_BUTTON_FORWARD) {
            pabtn[cButtons].iBitmap = 1;
            pabtn[cButtons].idCommand = IDTB_FORWARD;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_FORWARD));
            cButtons++;
        }
   }

    if (fsToolBarFlags & HHWIN_BUTTON_STOP) {
        pabtn[cButtons].iBitmap = 2;
        pabtn[cButtons].idCommand = IDTB_STOP;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_STOP));
        cButtons++;
    }

    if ( fsToolBarFlags & HHWIN_BUTTON_REFRESH) {
        pabtn[cButtons].iBitmap = 3;
        pabtn[cButtons].idCommand = IDTB_REFRESH;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_REFRESH));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_HOME) {
        if (pszHome) {
            pabtn[cButtons].iBitmap = 4;
            pabtn[cButtons].idCommand = IDTB_HOME;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_HOME));
            cButtons++;
        }
    }

    if (fsToolBarFlags & HHWIN_BUTTON_BROWSE_FWD) {
        if (pszHome) {
            pabtn[cButtons].iBitmap = 14;
            pabtn[cButtons].idCommand = IDTB_BROWSE_FWD;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_BROWSE_FWD));
            cButtons++;
        }
    }

    if (fsToolBarFlags & HHWIN_BUTTON_BROWSE_BCK) {
        if (pszHome) {
            pabtn[cButtons].iBitmap = 8;
            pabtn[cButtons].idCommand = IDTB_BROWSE_BACK;
            pabtn[cButtons].fsState = TBSTATE_ENABLED;
            pabtn[cButtons].iString = cButtons;
            m_ptblBtnStrings->AddString(GetStringResource(IDTB_BROWSE_BACK));
            cButtons++;
        }
    }

    if (fsToolBarFlags & HHWIN_BUTTON_ZOOM) {
        pabtn[cButtons].iBitmap = 16; // BUGBUG: We need a zoom glyph in toolb16g.bmp
        pabtn[cButtons].idCommand = IDTB_ZOOM;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_ZOOM));
        cButtons++;
    }

    if ( fsToolBarFlags & HHWIN_BUTTON_PRINT) {
        pabtn[cButtons].iBitmap = 7;
        pabtn[cButtons].idCommand = IDTB_PRINT;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_PRINT));
        cButtons++;
    }

//--- hard-coded menu
    CTable tblMenus(8 * 1024);

    mii.cbSize      = sizeof(MENUITEMINFO);
    mii.fMask       = MIIM_TYPE | MIIM_STATE | MIIM_ID;
    mii.fType       = MFT_STRING;
    mii.fState      = MFS_ENABLED;

    mii.hSubMenu    = NULL;
    mii.hbmpChecked = NULL;     // bitmap tp display when checked
    mii.hbmpUnchecked = NULL;   // bitmap to display when not checked
    mii.dwItemData  = NULL;         // data associated with the menu item

    mii.wID         = IDTB_CONTRACT;    // Menu Item ID
    cszMenuItem     = GetStringResource(IDS_OPTION_HIDE);  // the string to display for the menu item
    tblMenus.AddString(cszMenuItem.psz);
    mii.dwTypeData  = cszMenuItem.psz;
    mii.cch         = (DWORD)strlen(mii.dwTypeData);   // length of the string.
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

    if (fsToolBarFlags & HHWIN_BUTTON_SYNC)
    {
        if (!IsEmptyString(pszToc))
        {
            mii.wID         = IDTB_SYNC;    // Menu Item ID
            cszMenuItem     = GetStringResource(IDS_OPTION_SYNC);  // the string to display for the menu item
            tblMenus.AddString(cszMenuItem.psz);
            mii.dwTypeData  = cszMenuItem.psz;
            mii.cch         = (DWORD)strlen(mii.dwTypeData);   // length of the string.
            HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);
        }
    }

    mii.wID         = IDTB_BACK;    // Menu Item ID
    cszMenuItem     = GetStringResource(IDS_OPTION_BACK);  // the string to display for the menu item
    tblMenus.AddString(cszMenuItem.psz);
    mii.dwTypeData  = cszMenuItem.psz;
    mii.cch         = (DWORD)strlen(mii.dwTypeData);   // length of the string.
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

    mii.wID         = IDTB_FORWARD;    // Menu Item ID
    cszMenuItem     =   GetStringResource(IDS_OPTION_FORWARD);  // the string to display for the menu item
    tblMenus.AddString(cszMenuItem.psz);
    mii.dwTypeData  = cszMenuItem.psz;
    mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

    if (pszHome) {
        mii.wID         = IDTB_HOME;    // Menu Item ID
        cszMenuItem     =   GetStringResource(IDS_OPTION_HOME);  // the string to display for the menu item
        tblMenus.AddString(cszMenuItem.psz);
        mii.dwTypeData  = cszMenuItem.psz;
        mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
        HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);
    }

    mii.wID         = IDTB_STOP;    // Menu Item ID
    cszMenuItem     =   GetStringResource(IDS_OPTION_STOP);  // the string to display for the menu item
    tblMenus.AddString(cszMenuItem.psz);
    mii.dwTypeData  = cszMenuItem.psz;
    mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

    mii.wID         = IDTB_REFRESH; // Menu Item ID
    cszMenuItem     =   GetStringResource(IDS_OPTION_REFRESH);  // the string to display for the menu item
    tblMenus.AddString(cszMenuItem.psz);
    mii.dwTypeData  = cszMenuItem.psz;
    mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

    mii.wID         = HHM_OPTIONS; // Menu Item ID
    cszMenuItem     =   GetStringResource(IDS_OPTION_IE_OPTIONS);  // the string to display for the menu item
    tblMenus.AddString(cszMenuItem.psz);
    mii.dwTypeData  = cszMenuItem.psz;
    mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

    mii.fMask       = MIIM_TYPE;
    mii.fType       = MFT_SEPARATOR;
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

    // Now restore the mast and type

    mii.fMask       = MIIM_TYPE | MIIM_STATE | MIIM_ID;
    mii.fType       = MFT_STRING;
    BOOL fSeperatorNeeded = FALSE;

    /*
     * At this point, we need to add any custom Jump buttons, and to do
     * that we need to know all of the hard-coded menu items so that we can
     * adjust the accelerators as needed.
     */

    if ((fsToolBarFlags & HHWIN_BUTTON_JUMP1 && pszJump1) ||
            (fsToolBarFlags & HHWIN_BUTTON_JUMP2 && pszJump2)) {
        tblMenus.AddString(GetStringResource(IDS_OPTION_CUSTOMIZE));
        tblMenus.AddString(GetStringResource(IDS_OPTION_PRINT));
        if (!g_fIE3 && m_phmData && m_phmData->m_pTitleCollection && m_phmData->m_pTitleCollection->m_pSearchHighlight)
            tblMenus.AddString(GetStringResource(IDS_OPTION_HILITING_OFF));
    }

    if (fsToolBarFlags & HHWIN_BUTTON_JUMP1 && pszJump1) {
        mii.wID         = IDTB_JUMP1;    // Menu Item ID
        cszMenuItem     = "&1 ";
        cszMenuItem     +=   pszJump1;
        tblMenus.AddString(cszMenuItem.psz);
        mii.dwTypeData  = cszMenuItem.psz;
        mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
        HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);
        fSeperatorNeeded = TRUE;
    }
    if (fsToolBarFlags & HHWIN_BUTTON_JUMP2 && pszJump2) {
        mii.wID         = IDTB_JUMP2;    // Menu Item ID
        cszMenuItem     = "&2 ";
        cszMenuItem     +=   pszJump2;
        tblMenus.AddString(cszMenuItem.psz);
        mii.dwTypeData  = cszMenuItem.psz;
        mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
        HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);
        fSeperatorNeeded = TRUE;
    }

    if (fSeperatorNeeded) {
        mii.fMask       = MIIM_TYPE;
        mii.fType       = MFT_SEPARATOR;
        HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);

        // Now restore the mast and type

        mii.fMask       = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType       = MFT_STRING;
    }

    if (m_phmData && m_phmData->m_pInfoType && m_phmData->m_pInfoType->HowManyInfoTypes() > 0)
    {
        mii.wID         = IDTB_CUSTOMIZE; // Menu Item ID
        cszMenuItem     =   GetStringResource(IDS_OPTION_CUSTOMIZE);  // the string to display for the menu item
        mii.dwTypeData  = cszMenuItem.psz;
        mii.cch         =   (DWORD)strlen( mii.dwTypeData );        // length of the string.
        HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);
    }

    mii.wID         = IDTB_PRINT;   // Menu Item ID
    cszMenuItem     = GetStringResource(IDS_OPTION_PRINT);  // the string to display for the menu item
    mii.dwTypeData  = cszMenuItem.psz;
    mii.cch         = (DWORD)strlen( mii.dwTypeData );        // length of the string.
    HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);
// --- end fixed menu

    if (!g_fIE3 && m_phmData && m_phmData->m_pTitleCollection && m_phmData->m_pTitleCollection->m_pSearchHighlight) {

        // Add search term hiliting to the options menu.

        mii.wID         = IDTB_HILITE;  // Menu Item ID
        cszMenuItem     = GetStringResource(IDS_OPTION_HILITING_OFF);  // the string to display for the menu item
        mii.dwTypeData  = cszMenuItem.psz;
        mii.cch         = (DWORD)strlen( mii.dwTypeData );      // length of the string.

        HxInsertMenuItem(m_hMenuOptions, cMenuItems++, TRUE, &mii);
    }

    if ( fsToolBarFlags & HHWIN_BUTTON_OPTIONS && cMenuItems) {
        pabtn[cButtons].iBitmap = 10;
        pabtn[cButtons].idCommand = IDTB_OPTIONS;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].fsStyle = TBSTYLE_DROPDOWN;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_OPTIONS));

        if ( cMenuItems )
            pabtn[cButtons].dwData = (DWORD_PTR)m_hMenuOptions;

        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_NOTES) {
        pabtn[cButtons].iBitmap = 11;
        pabtn[cButtons].idCommand = IDTB_NOTES;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_NOTES));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_CONTENTS) {
        pabtn[cButtons].iBitmap = 15;
        pabtn[cButtons].idCommand = IDTB_CONTENTS;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_CONTENTS));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_INDEX) {
        pabtn[cButtons].iBitmap = 16;
        pabtn[cButtons].idCommand = IDTB_INDEX;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_INDEX));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_SEARCH) {
        pabtn[cButtons].iBitmap = 5;
        pabtn[cButtons].idCommand = IDTB_SEARCH;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_SEARCH));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_HISTORY) {
        pabtn[cButtons].iBitmap = 19;
        pabtn[cButtons].idCommand = IDTB_HISTORY;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_HISTORY));
        cButtons++;
    }

    if (fsToolBarFlags & HHWIN_BUTTON_FAVORITES) {
        pabtn[cButtons].iBitmap = 6;
        pabtn[cButtons].idCommand = IDTB_FAVORITES;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(GetStringResource(IDTB_FAVORITES));
        cButtons++;
    }

    if ((fsToolBarFlags & HHWIN_BUTTON_JUMP1) && !(IsProperty(HHWIN_PROP_MENU))) {
        pabtn[cButtons].iBitmap = 17;
        pabtn[cButtons].idCommand = IDTB_JUMP1;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(pszJump1 ? pszJump1 : "");
        cButtons++;
    }

    if ((fsToolBarFlags & HHWIN_BUTTON_JUMP2) && !(IsProperty(HHWIN_PROP_MENU))) {
        pabtn[cButtons].iBitmap = 18;
        pabtn[cButtons].idCommand = IDTB_JUMP2;
        pabtn[cButtons].fsState = TBSTATE_ENABLED;
        pabtn[cButtons].iString = cButtons;
        m_ptblBtnStrings->AddString(pszJump2 ? pszJump2 : "");
        cButtons++;
    }

    return cButtons;
}

// No longer used, but we'll keep in around awhile just in case

/*
static void FixDupMenuAccelerator(const CTable* ptbl, PSTR pszMenu)
{
    int i;
    PSTR pszOrg;
    PSTR pszTmp = StrChr(pszMenu, ACCESS_KEY);

    if (!pszTmp) {
        MoveMemory(pszMenu + 1, pszMenu, strlen(pszMenu) + 1);
        *pszMenu = ACCESS_KEY;
        pszTmp = pszMenu;
    }
    pszOrg = pszTmp;

    SHORT ch = VkKeyScan((BYTE) CharLower((LPSTR) pszTmp[1]));

    for (i = 1; i <= ptbl->CountStrings(); i++) {

        // check for a duplicate accelerator key

        PCSTR psz = StrChr(ptbl->GetPointer(i), ACCESS_KEY);
        if (VkKeyScan((BYTE) CharLower((LPSTR) psz[1])) == ch) {
            strcpy(pszTmp, pszTmp + 1); // remove the accelerator
            pszTmp++;
            if (!*pszTmp) {

                // End of string, nothing we can do

                MoveMemory(pszOrg + 1, pszOrg, strlen(pszOrg) + 1);
                *pszOrg = ACCESS_KEY;
                return;
            }
            else {
                MoveMemory(pszTmp + 1, pszTmp, strlen(pszTmp) + 1);
                *pszTmp = ACCESS_KEY;
                ch = VkKeyScan((BYTE) CharLower((LPSTR) pszTmp[1]));
                i = 0; // start over
            }
        }
    }
}
*/

#ifndef TCS_FLATBUTTONS
#define TCS_FLATBUTTONS         0x0008
#endif

//////////////////////////////////////////////////////////////////////////////////
//
// IsValidTab(int iTab) --- Index returned from tabOrder.
//
BOOL
CHHWinType::IsValidNavPane(int iTab)
{

    //REVIEW:: Assumes that the tabs have not been re-ordered!

    BOOL bResult = FALSE ;

    // We only have valid tabs if we are a TRI_PANE.
    if (IsProperty(HHWIN_PROP_TRI_PANE))
    {
        switch(iTab)
        {

        case HH_TAB_CONTENTS:
            if (!IsEmptyString(pszToc) && tabOrder[HH_TAB_CONTENTS] != 255)
                bResult = TRUE ;
            break;

        case HH_TAB_INDEX:
            if (!IsEmptyString(pszIndex) && tabOrder[HH_TAB_INDEX] != 255)
                bResult = TRUE ;
            break;

        case HH_TAB_SEARCH:
            if ((fsWinProperties & HHWIN_PROP_TAB_SEARCH) /*&& m_phmData && m_phmData->m_sysflags.fFTI*/)
            {
                //BUGBUG: m_phmdata isn't always valid when we are getting called. See HH_SET_WIN_TYPE
                bResult = TRUE ;
            }
            break;

        case HH_TAB_HISTORY:
            if (fsWinProperties & HHWIN_PROP_TAB_HISTORY)
                bResult = TRUE ;
            break;

        case HH_TAB_FAVORITES:
            if (fsWinProperties & HHWIN_PROP_TAB_FAVORITES)
                bResult = TRUE ;
            break;

    #ifdef __TEST_CUSTOMTAB__
        case HH_TAB_AUTHOR:
            return IsHelpAuthor(GetHwnd());
    #endif

        default:
            if (iTab >= HH_TAB_CUSTOM_FIRST && iTab <= HH_TAB_CUSTOM_LAST)
            {
                if (fsWinProperties & (HHWIN_PROP_TAB_CUSTOM1 << (iTab - HH_TAB_CUSTOM_FIRST)))
                {
                       bResult = TRUE;
                }
            }
        }
    }
    return bResult;
}

//////////////////////////////////////////////////////////////////////////////////
//
// GetValidNavPane --- Returns the index of the first valid tab it finds. -1 if no valid tabs.
//
int
CHHWinType::GetValidNavPane()
{
    for (int i = 0 ; i < HH_MAX_TABS+1 ; i++)
    {
        if (IsValidNavPane(i))
        {
            return i;
        }
    }

    return -1 ;
}

//////////////////////////////////////////////////////////////////////////////////
//
// GetNavPaneCount --- Counts the number of valid navigation panes
//
int CHHWinType::GetValidNavPaneCount()
{

    int count = 0 ;
    for (int i = 0 ; i < HH_MAX_TABS+1 ; i++)
    {
        if (IsValidNavPane(i))
        {
            count++;
        }
    }

    return count;

}


void CHHWinType::OnNavigateComplete(LPCTSTR pszUrl)
{
    // Update the Bookmark pane if it exists.
    if (curNavType == HH_TAB_FAVORITES && m_aNavPane[HH_TAB_FAVORITES])
    {
        // Here we are synchronizing the current topic edit control in the bookmarks pane
        // witht he current topic.
        m_aNavPane[HH_TAB_FAVORITES]->Synchronize(NULL) ;
    }

    // Get a pointer to the toc if it exists.
    CToc* ptoc = NULL ;
    if (m_aNavPane[HH_TAB_CONTENTS])
    {
        ptoc = reinterpret_cast<CToc*>(m_aNavPane[HH_TAB_CONTENTS]) ; // HACKHACK: Should use dynamic cast, but no RTTI.
    }
    //
    //  Check if zooming is supported on this page.
    //
    if ( IsValidWindow(hwndToolBar) )
    {
        if ( IsProperty(HHWIN_PROP_MENU) || fsToolBarFlags & HHWIN_BUTTON_ZOOM )
        {
          HRESULT hr = GetZoomMinMax();
          if( fsToolBarFlags & HHWIN_BUTTON_ZOOM ) {
            if ( hr == S_OK )
                 SendMessage(hwndToolBar, TB_ENABLEBUTTON, IDTB_ZOOM, TRUE);
            else
                 SendMessage(hwndToolBar, TB_ENABLEBUTTON, IDTB_ZOOM, FALSE);
          }
        }
    }
    if (idNotify) {
        HHN_NOTIFY hhcomp;
        hhcomp.hdr.hwndFrom = hwndHelp;
        hhcomp.hdr.idFrom = idNotify;
        hhcomp.hdr.code = HHN_NAVCOMPLETE;
        hhcomp.pszUrl = pszUrl;
        if (IsWindow(hwndCaller))
        {
            SendMessage(hwndCaller, WM_NOTIFY, idNotify, (LPARAM) &hhcomp);
        }
    }
}

// NOTE - call the following in your OnNavigateComplete event handler to update the minmax.  Do not do
// it when you navigate, do it when the control fires the OnNavigate event - by then you
// should be able to get the minmax stuff.

//***************************************************************************
//
//  Member:     CHHWinType:::GetZoomMinMax
//
//  Synopsis:   sets m_iZoomMin, and Most - gets called whenever we
//              navigate to a document.  Note that many document types
//              do not support Zoom, and so this fails.  This is OK,
//              and expected.
//
//  Returns:    HRESULT
//
//***************************************************************************
HRESULT CHHWinType::GetZoomMinMax(void)
{
    VARIANT            vararg;
    HRESULT            hr;

    ::VariantInit(&vararg);
    V_VT(&vararg) = VT_I4;
    V_I4(&vararg) = 0;

    m_iZoom = m_iZoomMin = m_iZoomMax = 0;
    hr = m_pCIExpContainer->m_pIE3CmdTarget->Exec(0, OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER,
                                                  0, &vararg);
#if 0
    if (hr)
    {
        OLECMDTEXT oct;
        OLECMD olecmd;
        olecmd.cmdID = OLECMDID_ZOOM;
        olecmd.cmdf = 0;
       hr = m_pCIExpContainer->m_pIE3CmdTarget->QueryStatus(NULL, 1, &olecmd, &oct);
    }
#endif

    if (hr)
        return hr;

    if (VT_I4 == V_VT(&vararg))
        m_iZoom = V_I4(&vararg);

    ::VariantClear(&vararg);
    V_VT(&vararg) = VT_I4;
    V_I4(&vararg) = 0;

    hr = m_pCIExpContainer->m_pIE3CmdTarget->Exec(0, OLECMDID_GETZOOMRANGE, OLECMDEXECOPT_DONTPROMPTUSER,
                                                  0, &vararg);
    if (hr)
        return hr;

    if (VT_I4 == V_VT(&vararg))
    {
        // I looked at the IE code for this - this cast is necessary.
        m_iZoomMin = (INT)(SHORT)LOWORD(V_I4(&vararg));
        m_iZoomMax = (INT)(SHORT)HIWORD(V_I4(&vararg));
    }
    return hr;
}

//***************************************************************************
//
//  Member:     CHHWinType::ZoomIn
//
//  Synopsis:   Zooms in one - whenever we navigate to a new document,
//              we get the zoom range for that document.  ZoomIn will
//              cycle thru that zoom range, from small to large, wrapping
//              back to smallest again.
//
//  Returns:    nothing, fails quietly (by design).
//
//***************************************************************************
void CHHWinType::ZoomIn(void)
{
    INT iZoomNew = m_iZoom + 1;

    if (iZoomNew > m_iZoomMax)
        iZoomNew = m_iZoomMin;

    Zoom(iZoomNew);
}

//***************************************************************************
//
//  Member:     CHHWinType::ZoomOut
//
//  Synopsis:   Zooms out one - whenever we navigate to a new document,
//              we get the zoom range for that document.  ZoomOut will
//              cycle thru that zoom range, from large to small, wrapping
//              back to largest again.
//
//  Returns:    nothing, fails quietly (by design).
//
//***************************************************************************
void CHHWinType::ZoomOut(void)
{
    INT iZoomNew = m_iZoom - 1;

    if (iZoomNew < m_iZoomMin)
        iZoomNew = m_iZoomMax;

    Zoom(iZoomNew);
}

//***************************************************************************
//
//  Member:     CHHWinType::_Zoom
//
//  Synopsis:   helper function that manages zoomin and zoomout.
//
//  Arguments:  [iZoom] -- value for new zoom.
//
//  Requires:   iZoom needs to be in a valid range for the current docobj.
//              current docobj must support IOleCommandTarget
//              it will fail if current docobj doesn't respond to
//              OLECMDID_ZOOM.
//
//  Returns:    HRESULT
//
//***************************************************************************
HRESULT CHHWinType::Zoom(int iZoom)
{
    HRESULT            hr;
    VARIANTARG         varIn;
    VARIANTARG         varOut;

    // initialize the argument to Exec.
    ::VariantInit(&varIn);
    V_VT(&varIn) = VT_I4;
    V_I4(&varIn) = iZoom;

    // init the out variant.  This probably isn't necessary, but
    // doesn't hurt - it's defensive as opposed to passing 0.
    //
    ::VariantInit(&varOut);
    hr = m_pCIExpContainer->m_pIE3CmdTarget->Exec(0, OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER,
                                                  &varIn, &varOut);

    if (SUCCEEDED(hr))
        m_iZoom = iZoom;

    return hr;
}

//***************************************************************************
//
//  Member:     CHHWinType::OnNext
//
//  Synopsis:   Executes a next in TOC navigation.
//
//  Arguments:  bDoJump - BOOL value indicates weather to execute a jump or not.
//
//  Returns:    BOOL - TRUE on success, FALSE on failure.
//
//***************************************************************************
BOOL CHHWinType::OnTocNext(BOOL bDoJump)
{
    CExTitle *pTitle= NULL;
    CStr cszUrl;
    char szURL[MAX_URL];
    CTreeNode* pTreeNode = NULL, *pTocNext = NULL, *pTocKid = NULL;
    CToc* pToc = NULL;
    DWORD dwSlot;
    BOOL bReturn = FALSE;

    if ( !m_phmData || !m_phmData->m_pTitleCollection )
       return FALSE;

    if (! SUCCEEDED(m_phmData->m_pTitleCollection->GetCurrentTocNode(&pTreeNode)) )
    {
       m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);
      if (cszUrl.psz != NULL)
      {
          strcpy(szURL, cszUrl);
          if ( SUCCEEDED(m_phmData->m_pTitleCollection->URL2ExTitle(szURL, &pTitle)) )
             pTitle->GetURLTreeNode(szURL, &pTreeNode);
      }
    }
    if ( pTreeNode )
    {
       if ( pTocNext = m_phmData->m_pTitleCollection->GetNextTopicNode(pTreeNode, &dwSlot) )
       {
          //  Ok now we can execute the jump and sync!
          //
          if ( bDoJump )
          {
             pTocNext->GetURL(szURL, sizeof(szURL));
             m_phmData->m_pTitleCollection->URL2ExTitle(szURL, &pTitle);
             m_phmData->m_pTitleCollection->SetTopicSlot(dwSlot, ((CExNode*)pTocNext)->m_Node.dwOffsTopic, pTitle);
             ChangeHtmlTopic(szURL, *this);
             if (! IsProperty(HHWIN_PROP_AUTO_SYNC) && (pToc = (CToc*)m_aNavPane[HH_TAB_CONTENTS]) )
                pToc->Synchronize(szURL);
          }
          delete pTocNext;
          bReturn = TRUE;
       }
       delete pTreeNode;
    }
    return bReturn;
}

//***************************************************************************
//
//  Member:     CHHWinType::OnPrev
//
//  Synopsis:   Executes a previous in TOC navigation.
//
//  Arguments:  bDoJump - BOOL value indicates weather to execute a jump or not.
//
//  Returns:    BOOL - TRUE on success, FALSE on failure.
//
//***************************************************************************
BOOL CHHWinType::OnTocPrev(BOOL bDoJump)
{
    CExTitle *pTitle = NULL;
    CStr cszUrl;
    char szURL[MAX_URL];
    CTreeNode* pTreeNode = NULL, *pTocPrev = NULL;
    CToc* pToc = NULL;
    DWORD dwSlot;
    BOOL bReturn = FALSE;

    if ( !m_phmData || !m_phmData->m_pTitleCollection )
       return FALSE;

    if (! SUCCEEDED(m_phmData->m_pTitleCollection->GetCurrentTocNode(&pTreeNode)) )
    {
       m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);
      if (cszUrl.psz != NULL)
      {
        strcpy(szURL, cszUrl);
          if ( SUCCEEDED(m_phmData->m_pTitleCollection->URL2ExTitle(szURL, &pTitle)) )
             pTitle->GetURLTreeNode(szURL, &pTreeNode);
      }
    }
    if ( pTreeNode )
    {
       //  We have the TOC node, now get it's next.
       //
       if ( pTocPrev = m_phmData->m_pTitleCollection->GetPrev(pTreeNode, &dwSlot) )
       {
          //
          //  Ok now, we can execute the jump and sync!
          //
          if ( bDoJump )
          {
             pTocPrev->GetURL(szURL, sizeof(szURL));
             m_phmData->m_pTitleCollection->URL2ExTitle(szURL, &pTitle);
             m_phmData->m_pTitleCollection->SetTopicSlot(dwSlot, ((CExNode*)pTocPrev)->m_Node.dwOffsTopic, pTitle);
             ChangeHtmlTopic(szURL, *this);
             if (! IsProperty(HHWIN_PROP_AUTO_SYNC) && (pToc = (CToc*)m_aNavPane[HH_TAB_CONTENTS]) )
                pToc->Synchronize(szURL);
          }
          bReturn = TRUE;
          delete pTocPrev;
       }
       delete pTreeNode;
    }
    return bReturn;
}

/***************************************************************************

    FUNCTION:   FindWindowType

    PURPOSE:    Find whether the window type exists and has already created
                a window

    PARAMETERS:
        pszType         -- window type to look for.
        hwndCaller      -- who the caller is
        pszOwnerFile    -- CHM file which defines this window type.

    RETURNS:
        -1 if window type not found, or found but no window created
        position in pahwnd if window found

    COMMENTS:

    MODIFICATION DATES:
        27-Feb-1996 [ralphw]
        27-Apr-1998 [dalero]    Added pszOwnerFile parameter

***************************************************************************/

CHHWinType* FindWindowType(PCSTR pszType, HWND hwndCaller, LPCTSTR pszOwnerFile)
{
    if (IsEmptyString(pszType))
    {
        return NULL;
    }

    // Skip window separator if present.
    if (*pszType == WINDOW_SEPARATOR)
    {
        pszType++;
        if (IsEmptyString(pszType))
        {
            return NULL;
        }
    }

    // We ignore the owner file if the file is URL or the window type is global.
    bool bIgnoreOwnerFile = IsGlobalWinType(pszType) || IsHttp(pszOwnerFile) ;
    if (!bIgnoreOwnerFile )
    {
        // If its not global, we need a filename.
        if (IsEmptyString(pszOwnerFile))
        {
            return NULL ;
        }
    }

    for (int i = 0; i < g_cWindowSlots; i++)
    {
        if (pahwnd[i] && pahwnd[i]->pszType != NULL
            && lstrcmpi(pszType, pahwnd[i]->pszType) == 0)
        {
            // Found the window type.

            // If its a global window type, we are done.
            if (bIgnoreOwnerFile)
            {
                break ;
            }
            else
            {
                // Call IsCompiledHtmlFile to get the filename into a consistant format.
                CStr cszCompiled(pszOwnerFile);
                if (NormalizeFileName(cszCompiled))
                {
                    // Is this window type in the correct CHM file.
                    ASSERT(pahwnd[i]->GetOwnerFile());
                    if (pahwnd[i]->GetOwnerFile()
                        && lstrcmpi(cszCompiled, pahwnd[i]->GetOwnerFile()) == 0)
                    {
                        break;
                    }
                }
            }
        }
    }
    if (i >= g_cWindowSlots)
    {
        return NULL;
    }

    //REVIEW: 28-Apr-98 [dalero] This seems dangerous...
    if (hwndCaller)
    {
        pahwnd[i]->hwndCaller = hwndCaller; // In case it changed
    }
    return pahwnd[i];
}

/***************************************************************************

    FUNCTION:   FindOrCreateWindowSlot

    PURPOSE:    Find whether the window type exists and create it if not.

    PARAMETERS:
        pszType         -- window type to look for.
        hwndCaller      -- who the caller is
        pszOwnerFile    -- the file which defines this window type.

        if pszType has the GLOBAL_WINDOWTYPE_PREFIX, the pszOwnerFile is not used.

    RETURNS:
        Return a pointer to the window type. May be an empty one just created.

    COMMENTS:

    MODIFICATION DATES:
        27 Apr 98   [DaleRo]    Added pszOwnerFile parameter

***************************************************************************/

CHHWinType* FindOrCreateWindowSlot(LPCTSTR pszType, LPCTSTR pszOwnerFile)
{
    ASSERT(pahwnd != NULL) ;

    // pszType cannot be NULL or emptry.
    if (IsEmptyString(pszType))
    {
        return NULL;
    }

    // Skip window type pointer if present.
    if (*pszType == WINDOW_SEPARATOR)
    {
        pszType++;
        if (IsEmptyString(pszType))
        {
            return NULL ;
        }
    }

    // We ignore the owning file if...
    bool bIgnoreOwnerFile = IsGlobalWinType(pszType) // Its a global window type
                            || IsHttp(pszOwnerFile);    // or an Http address. Ideally, the window type has been registered to a particular chm...
    const char* pOwner = ""; // Empty string is stored in the cases where we ignore wintypes... CHHWinType will copy...
    CStr cszOwner(pszOwnerFile);
    if (!bIgnoreOwnerFile)
    {
        // If its not a global window type, it must have a valid file.
        if (!NormalizeFileName(cszOwner))
        {
            return NULL ;
        }

        // pOwner is NULL if its a global wintype. Its non-null otherwise.
        pOwner = cszOwner;
    }

    // Check to see if this window type already exists.
    CHHWinType* phh = FindWindowType(pszType, NULL, cszOwner);
    if (phh)
    {
        return phh;
    }

    // The window type did not exist. So, find an empty slot to put it in.
    for (int i = 0; i < g_cWindowSlots; i++)
    {
        if (pahwnd[i] == NULL)
        {
            break;
        }
    }

    // Allocate more space for the array if we are out of room.
    if (i >= g_cWindowSlots)
    {
        g_cWindowSlots += 5;

        CHHWinType** paNew = (CHHWinType**) lcReAlloc(pahwnd,
                g_cWindowSlots * sizeof(CHHWinType*));
        memset( paNew + (g_cWindowSlots-5), 0, 5 * sizeof(CHHWinType*) );
        if (paNew == NULL)
        {
            OOM();
            return FALSE;
        }
        pahwnd = paNew;
    }

    // Create the new window type object. Note that it is not initialized.
    pahwnd[i] = new CHHWinType(pOwner);
    return pahwnd[i];
}

/***************************************************************************

    FUNCTION:   FindCurWindow

    PURPOSE:    Find a current window displayed

    PARAMETERS:

    RETURNS:

    COMMENTS:

          This function is random. It picks the first window displayed.
          Depending on how HHCTRL has been called any window could be first.

    MODIFICATION DATES:
        09-Nov-1997 [ralphw]
        03-Mar-1998 [dalero]

***************************************************************************/

CHHWinType* FindCurWindow()
{
    ASSERT(pahwnd != NULL) ;

    for (int i = 0; i < g_cWindowSlots; i++)
    {
        if (pahwnd[i] != NULL)
        {
            return pahwnd[i];
        }
    }
    return NULL;
}

///////////////////////////////////////////////////////////
//
// Delete all of the CHHWinType structures for this process.
//
void DeleteWindows()
{
    ASSERT(pahwnd != NULL) ;

    for (int i = 0; i < g_cWindowSlots; i++)
    {
        if (pahwnd[i] != NULL)
        {
            CHHWinType* phh = pahwnd[i] ;
            //pahwnd[i] = NULL ; --- Set to null in the destructor...
            if (IsWindow(phh->hwndHelp))
            {
                DestroyWindow(phh->hwndHelp) ;
            }
            else
            {
                delete phh ;
            }
        }
    }
}
///////////////////////////////////////////////////////////
//
// Functions which operate on the m_aNavPane array.
//
///////////////////////////////////////////////////////////
//
// CreateNavPane
//

static const WCHAR txtAuthorTab[] = L"HHAuthorTab.CustPane";

void
CHHWinType::CreateNavPane(int iPane)
{

    // Is this a valid pane number?
    if (iPane > c_NUMNAVPANES || iPane < 0)
    {
        ASSERT(0) ;
        return ;
    }

    // Has pane already been created?
    if (m_aNavPane[iPane])
    {
        return ; // Already created.
    }

    // Create the pane.
    switch(iPane)
    {
    case HHWIN_NAVTYPE_TOC:
        CreateToc();
        break ;
    case HHWIN_NAVTYPE_INDEX:
        CreateIndex();
        break ;
    case HHWIN_NAVTYPE_SEARCH:
        CreateSearchTab();
        break;
    case HHWIN_NAVTYPE_FAVORITES:
        CreateBookmarksTab() ;
        break ;

#if 0
    case HHWIN_NAVTYPE_HISTORY:
        //CreateHistoryTab();
        ItDoesntWork() ;
        break ;
#endif


#ifdef __TEST_CUSTOMTAB__
    case HHWIN_NAVTYPE_AUTHOR:
        CreateCustomTab(iPane, txtAuthorTab);
        break;
#endif

    default:
        if (iPane < HH_MAX_TABS+1 && iPane >= HHWIN_NAVTYPE_CUSTOM_FIRST)
        {
            // We have a custom tab.
         EXTENSIBLE_TAB* pExtTab = GetExtTab(iPane - HH_TAB_CUSTOM_FIRST);
         if (pExtTab)
         {
            CWStr cwsz(pExtTab->pszProgId);
            CreateCustomTab(iPane, cwsz);
         }
        }
        else
        {
            ASSERT_COMMENT(0, "illegal tab index");
        }
    }
}

/***************************************************************************

    FUNCTION: doSelectTab

    PURPOSE:    changes the current navigation tab

    PARAMETERS:

    RETURNS:
        TODO


    COMMENTS:

    MODIFICATION DATES:
        27-Feb-1996 [ralphw]
        09-Nov-1997 [ralphw] Moved to CHHWinType

***************************************************************************/

void
CHHWinType::doSelectTab(int newTabIndex)
{
    if ( newTabIndex < 0 )
        return ;

    // Make sure we have tabs before we switch or toggle.
    if (!IsValidNavPane(curNavType))
        return ;

    // make sure the nav pane is shown
    if (IsExpandedNavPane() == FALSE)
         ToggleExpansion();
    //
    // <mc> 4/10/98 Bug 4701 - I've moved the m_pTabCtrl == NULL check to after the ToggleExpansion() call
    // done above because it's legitimate to have a NULL m_pTabCtrl pointer if we get to this code and the
    // nav pane has never been shown. The ToggleExpansion() call will instantiate m_pTabCtrl if the nav
    // pane is hidden and has never been shown.
    //
    if ( m_pTabCtrl == NULL )
       return;                 // REVIEW: This is null when there isn't an FTS. See BUG 462 in RAID database.

    // Get the index of the currently selected tab.
    int oldTabIndex = GetCurrentNavPaneIndex() ;

    // Only change the tab if its not the current one.
    if (oldTabIndex != newTabIndex)
    {
        // This code was copied from WM_NOTIFY in wndproc.cpp. This should become common.

        ASSERT(curNavType >= 0 && curNavType < c_NUMNAVPANES) ;

        // Hide the current tab.
        if (m_aNavPane[curNavType])
        {
            m_aNavPane[curNavType]->HideWindow();
        }

        // Code throughout HHCtrl assumes that HH_NAVTYPE_* == HH_TAB_*.
        //  but doesn't assert it anywhere. So I'm going to assert it here.
        ASSERT(HHWIN_NAVTYPE_SEARCH == HH_TAB_SEARCH) ;
        ASSERT(HHWIN_NAVTYPE_TOC == HH_TAB_CONTENTS) ;
        ASSERT(HHWIN_NAVTYPE_INDEX == HH_TAB_INDEX);
        ASSERT(HHWIN_NAVTYPE_FAVORITES == HH_TAB_FAVORITES);
#ifdef _INTERNAL
        ASSERT(HHWIN_NAVTYPE_HISTORY == HH_TAB_HISTORY);
#endif

        // Select the new navigation method.
        curNavType = newTabIndex;

        // Select the new current tab.
        int iNewTabCtrlIndex = GetTabIndexFromNavPaneIndex(newTabIndex) ;
        ASSERT(iNewTabCtrlIndex >= 0) ;
        int iRet = TabCtrl_SetCurSel(m_pTabCtrl->hWnd(), iNewTabCtrlIndex) ;
        ASSERT(iRet >= 0) ;
        ASSERT(tabOrder[iRet] == oldTabIndex) ;

        //REVIEW: If I've ever seen a use for virtual functions...

        // Create the new pane for the new current tab if necessary.
        CreateNavPane(newTabIndex) ;
        if (m_aNavPane[newTabIndex])
   {
      m_aNavPane[newTabIndex]->ResizeWindow();
           m_aNavPane[newTabIndex]->ShowWindow();
   }

        // Update the tab window
        ::UpdateWindow(m_pTabCtrl->hWnd()) ;
    } //if
    if (m_aNavPane[newTabIndex]) m_aNavPane[newTabIndex]->SetDefaultFocus();
    if ( m_pCIExpContainer )
       m_pCIExpContainer->UIDeactivateIE();     // shdocvw is loosing focus need to uideactivate here.
}

///////////////////////////////////////////////////////////////////////////////
//
// Restore if minimzied window, and set focus to the window
//
void CHHWinType::SetActiveHelpWindow(void)
{
    if (IsIconic(*this))
        ShowWindow(*this, SW_RESTORE);
    SetForegroundWindow(*this);
//    SetFocus(*this);
}

///////////////////////////////////////////////////////////////////////////////
//
// Finds the currently selected tab in the tab control. It then looks in the
// tabOrder array to find out the index into the array of nav panes for this control.
//
int
CHHWinType::GetCurrentNavPaneIndex()
{
    if( !m_pTabCtrl )
      return -1;

    // REVIEW: All of this mapping between tabctrl index and nav pane index should be
    // hidden inside of the tabctrl...
    int index = -1 ;
    if (m_pTabCtrl && IsWindow(m_pTabCtrl->hWnd()))
    {
        index = (int)::SendMessage(m_pTabCtrl->hWnd(), TCM_GETCURSEL, 0, 0);
        index = tabOrder[index] ;
    }

    return index ;
}

///////////////////////////////////////////////////////////////////////////////
//
// Finds the index of the tab on the tabctrl which co-responds to a particular
// nav pane.
//
int
CHHWinType::GetTabIndexFromNavPaneIndex(int iNavPaneIndex)
{
    for(int i = 0 ; i < HH_MAX_TABS+1 ; i++)
    {
        //REVIEW: Not all of these entries are valid. Possible to get a bogus hit. See reorder tab.
        if( tabOrder[i] == iNavPaneIndex)
        {
            return i ;
        }
    }

    return -1 ;
}


///////////////////////////////////////////////////////////////////////////////
//
// Translate the accelerators for the tabs. These are not in the global accelerator table.
//
bool
CHHWinType::ManualTranslateAccelerator(char iChar)
{
    CHAR ch =  ToLower(iChar) ;

    // The Options menu button.
    if (ch == _Resource.TabCtrlKeys(ACCEL_KEY_OPTIONS)
         && GetToolBarHwnd())
    {
        PostMessage( GetHwnd(), WM_COMMAND, IDTB_OPTIONS, 0);
        return true;
    }
/*
    else if()
    // When adding in new cases, make sure not to eat a key. If you UI doesn't exist.
    // Let someone else have the key.
*/
    else
    {
        // Handle the tab accelerator keys
        for (int i= 0 ; i < HH_MAX_TABS+1  ; i++)
        {
            if (ch == _Resource.TabCtrlKeys(i) && IsValidNavPane(i))
            {
                doSelectTab(i) ;
                return true ;
            }
        }

        // Handle the nav panes accelerator keys
        if (m_aNavPane[curNavType])
        {
            if (m_aNavPane[curNavType]->ProcessMenuChar(GetHwnd(),ch) )
            {
                 if ( m_pCIExpContainer )
                    m_pCIExpContainer->UIDeactivateIE();     // shdocvw is loosing focus need to uideactivate here.
                return true ;
            }
        }
    }
    return false ;
}

///////////////////////////////////////////////////////////////////////////////
//
// Dynamically build an accelerator table for this window...
//
bool
CHHWinType::DynamicTranslateAccelerator(MSG* pMsg)
{
    bool bReturn = false ;
    if (IsWindow(GetHwnd()))
    {
        if (!m_hAccel)
        {

            // Get the static accelerators table;
            HACCEL hAccelStatic = _Resource.AcceleratorTable() ;
            // Get number of accelerator table entries.
            int cStaticAccelEntries = CopyAcceleratorTable(hAccelStatic, NULL, 0);

            // Add on the options menu and the tabs...
            int cAccelEntries = cStaticAccelEntries + HH_MAX_TABS + 2 ;

            // Allocate structure to hold accelerator table.
            ACCEL* accel = new ACCEL[cAccelEntries] ;
            if (!accel)
                return false ;

            // Copy the table into the structure:
            CopyAcceleratorTable(hAccelStatic, accel, cStaticAccelEntries ) ;

            // Add on dynamic accelerators.
            int index = cStaticAccelEntries;

            // Add on options menu.
            if (fsToolBarFlags & HHWIN_BUTTON_OPTIONS)
            {
                accel[index].fVirt = FALT | FNOINVERT | FVIRTKEY  ;
                accel[index].key = (WORD)ToUpper(_Resource.TabCtrlKeys(ACCEL_KEY_OPTIONS)) ;
                accel[index].cmd = IDTB_OPTIONS ;
                index++ ;
            }

            // Add on accelerators for each tab.
            for (int i= 0 ; i < HH_MAX_TABS+1  ; i++)
            {
                if (IsValidNavPane(i))
                {
                    accel[index].fVirt = FALT | FNOINVERT | FVIRTKEY;
                    accel[index].key = (WORD)ToUpper(_Resource.TabCtrlKeys(i)) ;
                    accel[index].cmd = IDC_SELECT_TAB_FIRST + i ;
                    index++ ;
                }
            }

            // Create the accelerator table.
            m_hAccel = CreateAcceleratorTable(accel, index) ;


            // Cleanup
            delete [] accel ;
        }

        bReturn = (TranslateAccelerator(GetHwnd(), m_hAccel, pMsg) != 0 ) ;

    }
    if (bReturn)
    {
        DBWIN("--- Translated Accelerator ---") ;
    }
    return bReturn ;
}
///////////////////////////////////////////////////////////////////////////////
//
// Stolen from System.cpp...readsystemfiles. Should be shared.
//
LPSTR _MakeItFullPath(LPCTSTR name, CHmData* phmData)
{
    LPSTR pszReturn = NULL ;
    CStr csz(name) ;
   if (csz.IsNonEmpty())
   {
      if (!stristr(csz, txtDoubleColonSep) &&
            !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader))
      {
         CStr cszCompiledFile ;
         cszCompiledFile = phmData->GetCompiledFile();
         cszCompiledFile += txtSepBack;
         cszCompiledFile += csz.psz;

         //Transfer pointer.
         pszReturn = cszCompiledFile.psz ;
         cszCompiledFile.psz = NULL ;
      }
      else
      {
         // Transfer pointer.
         pszReturn = csz.psz ;
         csz.psz = NULL ;
      }
   }

    return pszReturn ;
}

///////////////////////////////////////////////////////////////////////////////
//
// Kills all of the nav panes and then re-fills them with the new CHM data.
//
bool
CHHWinType::ReloadNavData(CHmData* phmdata)
{
    if (!phmdata)
        return false;

   //--- Do we have valid data?
   char* pszTocNew      = NULL ;
    char* pszIndexNew    = NULL ;

   // Only if we currently have a TOC, will we get the new toc.
   if (IsNonEmptyString(pszToc))
   {
      pszTocNew      = _MakeItFullPath(phmdata->GetDefaultToc(), phmdata) ;
   }

   // Only if we currently have an INDEX, will we get the new index.
   if (IsNonEmptyString(pszIndex))
   {
      pszIndexNew    = _MakeItFullPath(phmdata->GetDefaultIndex(), phmdata) ;
   }


   // CHM doesn't have a default TOC or CHM which we need. So look up one in the default window type.
   if ((IsNonEmptyString(pszToc) && IsEmptyString(pszTocNew)) ||
      (IsNonEmptyString(pszIndex) && IsEmptyString(pszIndexNew)))
   {
      CHECK_AND_FREE(pszTocNew) ;
      CHECK_AND_FREE(pszIndexNew) ;

      // Office Beta work around: Less attempt looking in the default window type.
      if (IsNonEmptyString(phmdata->GetDefaultWindow()))
      {
         CHHWinType* pDefWinTypeNew = FindWindowType(phmdata->GetDefaultWindow(), NULL, phmdata->GetCompiledFile()) ;
         if (pDefWinTypeNew)
         {
            if (IsNonEmptyString(pszToc))
            {
               pszTocNew = _MakeItFullPath(pDefWinTypeNew->pszToc, phmdata) ;
            }

            if (IsNonEmptyString(pszIndex))
            {
               pszIndexNew = _MakeItFullPath(pDefWinTypeNew->pszIndex, phmdata) ;
            }
         }
      }

      // If we still aren't in sync, fail.
      if ((IsNonEmptyString(pszToc) && IsEmptyString(pszTocNew)) ||
         (IsNonEmptyString(pszIndex) && IsEmptyString(pszIndexNew)))
      {
         CHECK_AND_FREE(pszTocNew) ;
         CHECK_AND_FREE(pszIndexNew) ;

         return false ;
      }
   }

    //--- Kill all nav panes and cleanup other infomation
    ReloadCleanup() ;

    //--- Clean up some more stuff...

    //--- Start re-initializing...
    m_phmData   = phmdata;
    pszToc      = pszTocNew ;
    pszIndex    = pszIndexNew ;
    pszFile     = lcStrDup(phmdata->GetDefaultHtml()); //_MakeItFullPath(phmdata->m_pszDefHtml, phmdata);

    //TODO: I think we need to get a window name to read from....ick
    pszJump1    = NULL;
    pszJump2    = NULL;
    pszUrlJump1 = NULL;
    pszUrlJump2 = NULL;


    //--- Okay, lets start up the first current tab...
   if (IsExpandedNavPane())
   {
      // We have a naviation pane which we need to re-create.
      fNotExpanded = TRUE ; // Force a re-creation.
      ToggleExpansion(false) ;
   }

    return true ;
}

//////////////////////////////////////////////////////////////////////////
//
// Restores the focus to the ctrl which had it focus during the last WM_ACTIVATE.
//
bool
CHHWinType::RestoreCtrlWithFocus()
{
    if (m_hwndLastFocus)
    {
        SetFocus(m_hwndLastFocus) ;
        m_hwndLastFocus = NULL ;
        return true ;
    }
    else
    {
        return false ;
    }
}

//////////////////////////////////////////////////////////////////////////
//
// Saves hwnd of ctrl with focus during WM_ACTVIATE (INACTIVATE).
//
void
CHHWinType::SaveCtrlWithFocus()
{
    m_hwndLastFocus = GetFocus() ;
}

//////////////////////////////////////////////////////////////////////////
//
// GetExtTabCount
//
int
CHHWinType::GetExtTabCount()
{
    // If we have an original, pre-reload navdata ChmData. Use that to get the custom tab information.
    if (m_phmDataOrg)
        return m_phmDataOrg->GetExtTabCount();
    else if (m_phmData)
        return m_phmData->GetExtTabCount();  // Review: Will this ever happen?
    else
        return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// GetExtTab
//
EXTENSIBLE_TAB*
CHHWinType::GetExtTab(int pos)
{
    if (m_phmDataOrg)
        return m_phmDataOrg->GetExtTab(pos);
    else if (m_phmData)
        return m_phmData->GetExtTab(pos); // Review:: will this ever happen?
    else
        return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// MUI support
//
// This InsertMenuItem wrapper will translate the MENUITEMINFOA structure 
// to a MENUITEMINFOW and call InsertMenuItemW when running under Windows 2000.
//
BOOL HxInsertMenuItem(HMENU hMenu, UINT uItem, BOOL fByPosition, MENUITEMINFOA *lpmii)
{
    if(g_bWinNT5 && (lpmii->fMask | MIIM_TYPE) && lpmii->fType == MFT_STRING)
    {
        	
        DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
		
		DWORD dwSize = (sizeof(WCHAR) * lpmii->cch) + 4;
		WCHAR *pwcString = (WCHAR *) lcMalloc(dwSize);
		
		if(!pwcString || !(lpmii->cch))
		    return FALSE;
		
		MultiByteToWideChar(cp, MB_PRECOMPOSED, lpmii->dwTypeData, -1, pwcString, dwSize);
		
		lpmii->dwTypeData = (CHAR *) pwcString;
		lpmii->cch = wcslen((WCHAR *)lpmii->dwTypeData);

        BOOL ret = InsertMenuItemW(hMenu, uItem, fByPosition, (LPMENUITEMINFOW) lpmii);
		
        lcFree(pwcString);	
		
		return ret;
	}
	else
    {
        return InsertMenuItem(hMenu, uItem, fByPosition, lpmii);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\search.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "strtable.h"
#include "hhctrl.h"
#include "resource.h"
#include "secwin.h"
#include "htmlhelp.h"
#include "cpaldc.h"
#include "system.h"
#include "fts.h"
#include "TCHAR.h"
#include "parserhh.h"
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"
#include "search.h"
#include "csubset.h"
#include "cctlww.h"

// Common Control Macros
#include <windowsx.h>

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////
//
// Contants
//
//TODO: Sizes and spaces should not be hard coded!
const int BUTTON_WIDTH = 80;
const int BUTTON_HEIGHT = 24;
const int S_BOX_HEIGHT = 17;
const int BOX_HEIGHT = 24;
const int c_MaxSearchKeywordLength=256 ;

const int c_StaticControlSpacing = 3; // Space between text and static control.
const int c_ControlSpacing  = 8 ; // Space between two controls.

///////////////////////////////////////////////////////////
//
// Static Member functions
//

WNDPROC CSearch::s_lpfnlComboWndProc = NULL;
WNDPROC CSearch::s_lpfnlListViewWndProc = NULL;
WNDPROC lpfnlSearchDisplayBtnWndProc = NULL;
WNDPROC lpfnlSearchListBtnWndProc = NULL;

///////////////////////////////////////////////////////////
//
//                  Construction
//
///////////////////////////////////////////////////////////
//
// Constructor
//
CSearch::CSearch(CHHWinType* phh)
: m_hwndResizeToParent(NULL)
{
    ASSERT(phh) ;

    m_phh = phh;

    m_pTitleCollection = phh->m_phmData->m_pTitleCollection;
    ASSERT(m_pTitleCollection);
    m_padding = 2;      // padding to put around the window
    m_NavTabPos = phh->tabpos ;
    m_plistview = NULL;
}

///////////////////////////////////////////////////////////
//
// Destructor
//
CSearch::~CSearch()
{
    DESTROYIFVALID(m_hwndListBox);
    DESTROYIFVALID(m_hwndDisplayButton);
    DESTROYIFVALID(m_hwndListTopicsButton);
    DESTROYIFVALID(m_hwndComboBox);
    DESTROYIFVALID(m_hwndStaticKeyword);
    DESTROYIFVALID(m_hwndStaticTopic);

    if(m_plistview && m_plistview->m_pResults != NULL )
    {
        // Free the results list
        //
        m_pTitleCollection->m_pFullTextSearch->FreeResults(m_plistview->m_pResults);
    }

    if( m_plistview )
      delete m_plistview;

}

///////////////////////////////////////////////////////////
//
// Create
//

static const char txtHHSearchClass[] = "HH FTSearch";

BOOL CSearch::Create(HWND hwndParent)
{
    /* Note: hwndParent is either the Naviagtion Frame or its the tab ctrl.
        This class does not parent to the tab ctrl, but to the navigation frame.
        GetParentSize will always return the hwndNaviation, if hwndParent is the
        tabctrl.
        The reason that it doesn't parent to the tab ctrl is that the tab ctrl
        steals commands. What should really have happened is that all of the windows
        in this control should be contained in another window. However, its too late to
        change this now.
    */

    RECT rcParent, rcChild, rcStatic, rcButton;
    DWORD dwExt;
    PCSTR psz;
    HFONT hfUI = _Resource.GetUIFont();
    BOOL fUnicodeWindow;

    // Save the hwndParent for ResizeWindow.
    m_hwndResizeToParent = hwndParent ;
    // Note: GetParentSize will return hwndNavigation if hwndParent is the tab ctrl.
    hwndParent = GetParentSize(&rcParent, hwndParent, m_padding, m_NavTabPos);
    rcParent.top += GetSystemMetrics(SM_CYSIZEFRAME)*2 ; //HACK: Fudge the top since we are not parented to the tabctrl.

    CopyRect(&rcChild, &rcParent);

    // Place the "Keyword" static text on top of the edit control
    m_hwndStaticKeyword = CreateWindowEx(WS_EX_TRANSPARENT, "STATIC", "",
        WS_CHILD , rcChild.left, rcChild.top,
        RECT_WIDTH(rcChild), S_BOX_HEIGHT, hwndParent,
        (HMENU) ID_STATIC_KEYWORDS, _Module.GetModuleInstance(), NULL);
    // set the font
    SendMessage(m_hwndStaticKeyword, WM_SETFONT, (WPARAM)hfUI, FALSE);
    // Get the dimensions of the text for sizing and spacing needs.
    if(g_bWinNT5)
	{
        WCHAR *pwz = (WCHAR *) GetStringResourceW(IDS_TYPE_KEYWORD);
        dwExt = GetStaticDimensionsW( m_hwndStaticKeyword, hfUI, pwz, RECT_WIDTH(rcChild) );
        rcChild.bottom = rcChild.top + HIWORD(dwExt) ;
        MoveWindow(m_hwndStaticKeyword, rcChild.left, rcChild.top,
                   RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), FALSE );
        SetWindowTextW(m_hwndStaticKeyword, pwz);
    }
    else
	{
        psz = GetStringResource(IDS_TYPE_KEYWORD);
        dwExt = GetStaticDimensions( m_hwndStaticKeyword, hfUI, psz, RECT_WIDTH(rcChild) );
        rcChild.bottom = rcChild.top + HIWORD(dwExt) ;
        MoveWindow(m_hwndStaticKeyword, rcChild.left, rcChild.top,
                   RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), FALSE );
        SetWindowText(m_hwndStaticKeyword, psz);
    }

    rcChild.top = rcChild.bottom + c_StaticControlSpacing; // Add space between static and control.
    rcChild.bottom = rcChild.top + BOX_HEIGHT;

    // create the edit control for entering the search text
    // leave room for the static text on top
    m_hwndComboBox = W_CreateWindowEx(WS_EX_CLIENTEDGE | g_RTL_Style, L"EDIT", L"",
        WS_CHILD | WS_BORDER | WS_TABSTOP | ES_AUTOHSCROLL, rcChild.left, rcChild.top,
        RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), hwndParent,
        (HMENU) IDSIMPLESEARCH_COMBO, _Module.GetModuleInstance(), NULL, &fUnicodeWindow);

    if (!m_hwndComboBox)
        goto _Error;

    // Sub-class the combo box
    if (NULL == s_lpfnlComboWndProc)
        s_lpfnlComboWndProc = (WNDPROC) W_GetWndProc(m_hwndComboBox, fUnicodeWindow);
    W_SubClassWindow(m_hwndComboBox, (LONG_PTR) ComboProc, fUnicodeWindow);
    SETTHIS(m_hwndComboBox);

    // Limit the amount of text which can be typed in.
    Edit_LimitText(m_hwndComboBox, c_MaxSearchKeywordLength-1) ;

    // set the font
    SendMessage(m_hwndComboBox, WM_SETFONT, (WPARAM)  m_phh->GetContentFont(), FALSE);

    // create the "List Topics" button and place it
    // below the edit control and to the parent's right edge
    rcChild.top = rcChild.bottom + c_ControlSpacing;
    rcChild.bottom = rcChild.top + BUTTON_HEIGHT;

    if(g_bWinNT5)
	{
        m_hwndListTopicsButton = CreateWindowW(L"BUTTON",
            GetStringResourceW(IDS_LIST_TOPICS),
            WS_CHILD | WS_TABSTOP, rcChild.right-(BUTTON_WIDTH+2), rcChild.top,
            BUTTON_WIDTH, BUTTON_HEIGHT, hwndParent,
            (HMENU) IDBTN_LIST_TOPICS, _Module.GetModuleInstance(), NULL);
	}
	else
	{
        m_hwndListTopicsButton = CreateWindow("BUTTON",
            GetStringResource(IDS_LIST_TOPICS),
            WS_CHILD | WS_TABSTOP, rcChild.right-(BUTTON_WIDTH+2), rcChild.top,
            BUTTON_WIDTH, BUTTON_HEIGHT, hwndParent,
            (HMENU) IDBTN_LIST_TOPICS, _Module.GetModuleInstance(), NULL);
	}
	
    if (!m_hwndListTopicsButton)
        goto _Error;
    if (NULL == lpfnlSearchListBtnWndProc)
        lpfnlSearchListBtnWndProc= (WNDPROC) GetWindowLongPtr(m_hwndListTopicsButton, GWLP_WNDPROC);
    SetWindowLongPtr(m_hwndListTopicsButton, GWLP_WNDPROC, (LONG_PTR) ListBtnProc);
    SETTHIS(m_hwndListTopicsButton);

    rcChild.top = rcChild.bottom + c_ControlSpacing;
    rcChild.bottom = rcChild.top + S_BOX_HEIGHT;

    m_hwndStaticTopic = CreateWindowEx(WS_EX_TRANSPARENT, "STATIC", "",
                            WS_CHILD , rcChild.left, rcChild.top - S_BOX_HEIGHT,
                            RECT_WIDTH(rcChild), S_BOX_HEIGHT, hwndParent,
                            (HMENU) ID_STATIC_SELECT_TOPIC, _Module.GetModuleInstance(), NULL);
    if (!m_hwndStaticTopic)
        goto _Error;
    GetWindowRect(m_hwndStaticTopic, &rcStatic);
    if(g_bWinNT5)
    {	
        WCHAR *pwz = (WCHAR *) GetStringResourceW(IDS_SELECT_TOPIC);
        dwExt = GetStaticDimensionsW(m_hwndStaticTopic, hfUI, pwz, RECT_WIDTH(rcStatic) );
        rcStatic.bottom = rcStatic.top+HIWORD(dwExt);
        MoveWindow(m_hwndStaticTopic, rcStatic.left, rcStatic.top,
            RECT_WIDTH(rcStatic), RECT_HEIGHT(rcStatic), FALSE);
        SendMessage(m_hwndStaticTopic, WM_SETFONT, (WPARAM) hfUI, FALSE);
        SetWindowTextW(m_hwndStaticTopic, pwz);
    }
	else
    {	
        psz = GetStringResource(IDS_SELECT_TOPIC);
        dwExt = GetStaticDimensions( m_hwndStaticTopic, hfUI, psz, RECT_WIDTH(rcStatic) );
        rcStatic.bottom = rcStatic.top+HIWORD(dwExt);
        MoveWindow(m_hwndStaticTopic, rcStatic.left, rcStatic.top,
            RECT_WIDTH(rcStatic), RECT_HEIGHT(rcStatic), FALSE);
        SendMessage(m_hwndStaticTopic, WM_SETFONT, (WPARAM) hfUI, FALSE);
        SetWindowText(m_hwndStaticTopic, psz);
    }

    // create the list view control and place it
    // +BOX_HEIGHT for combo box and adjust for spacing.
    // Note: leave space for the static text on top of the list box control
    rcChild.top = rcChild.bottom + c_StaticControlSpacing; // Space between static and control.
    rcChild.bottom = rcParent.bottom - (c_ControlSpacing) - BUTTON_HEIGHT; // BUG 2204: Also subtract off the space for the display button.

    m_hwndListBox = W_CreateControlWindow (
        WS_EX_CLIENTEDGE | g_RTL_Style,
        WS_CHILD | WS_BORDER | WS_TABSTOP | WS_VSCROLL |
        LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_NOCOLUMNHEADER,
        W_ListView,
        L"HH FTSearch",
        rcChild.left, rcChild.top, RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild),
        hwndParent,
        (HMENU)IDSEARCH_LIST,
        _Module.GetModuleInstance(),
        NULL
        );
    if (!m_hwndListBox)
        goto _Error;

    W_ListView_SetExtendedListViewStyle( m_hwndListBox, LVS_EX_FULLROWSELECT | g_RTL_Style);
    m_plistview = new CFTSListView(m_pTitleCollection, m_hwndListBox );

    // Sub-class the list view
    fUnicodeWindow = IsWindowUnicode(m_hwndListBox);
    if (NULL == s_lpfnlListViewWndProc)
        s_lpfnlListViewWndProc = W_GetWndProc(m_hwndListBox, fUnicodeWindow);
    W_SubClassWindow(m_hwndListBox, reinterpret_cast<LONG_PTR>(ListViewProc), fUnicodeWindow);
    SETTHIS(m_hwndListBox);

    // BUG 3204 ---
    // In 3204, the listview control was painting BEFORE the tabctrl which was then painting over the top of it.
    // Therefore, I've added code here and in resize to force the listbox to be the top most window in this grouping.
    if (hwndParent != m_hwndResizeToParent )
    {
        SetWindowPos(m_hwndListBox, m_hwndResizeToParent, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE );
    }

    SendMessage(m_hwndListBox,  WM_SETFONT, (WPARAM) m_phh->GetAccessableContentFont(), FALSE);

    // create the "Display" button and place it
    rcChild.bottom = rcParent.bottom;
    rcChild.top = rcChild.bottom - BUTTON_HEIGHT;

    if(g_bWinNT5)
	{
        m_hwndDisplayButton = CreateWindowW(L"BUTTON",
            GetStringResourceW(IDS_ENGLISH_DISPLAY),
            WS_CHILD | WS_TABSTOP, rcChild.right-BUTTON_WIDTH-2, rcChild.top,
            BUTTON_WIDTH, BUTTON_HEIGHT, hwndParent,
            (HMENU) IDBTN_DISPLAY, _Module.GetModuleInstance(), NULL);
	}
	else
	{
        m_hwndDisplayButton = CreateWindow("BUTTON",
            GetStringResource(IDS_ENGLISH_DISPLAY),
            WS_CHILD | WS_TABSTOP, rcChild.right-BUTTON_WIDTH-2, rcChild.top,
            BUTTON_WIDTH, BUTTON_HEIGHT, hwndParent,
            (HMENU) IDBTN_DISPLAY, _Module.GetModuleInstance(), NULL);
	}
    if (!m_hwndDisplayButton)
        goto _Error;
   EnableWindow(m_hwndDisplayButton, FALSE);
    if (NULL == lpfnlSearchDisplayBtnWndProc)
      lpfnlSearchDisplayBtnWndProc = (WNDPROC) GetWindowLongPtr(m_hwndDisplayButton, GWLP_WNDPROC);
    SetWindowLongPtr(m_hwndDisplayButton, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(DisplayBtnProc));
    SETTHIS(m_hwndDisplayButton);
    SendMessage(m_hwndDisplayButton,    WM_SETFONT, (WPARAM) hfUI, FALSE);
    GetWindowRect(m_hwndDisplayButton, &rcButton);
    dwExt = GetButtonDimensions(m_hwndDisplayButton, hfUI, GetStringResource(IDS_ENGLISH_DISPLAY));
    MoveWindow(m_hwndDisplayButton, rcChild.right - LOWORD(dwExt), rcButton.top,
        LOWORD(dwExt), HIWORD(dwExt), FALSE);

    SendMessage(m_hwndListTopicsButton, WM_SETFONT, (WPARAM) hfUI, FALSE);
    GetWindowRect(m_hwndListTopicsButton, &rcButton);
    dwExt = GetButtonDimensions(m_hwndListTopicsButton, hfUI, GetStringResource(IDS_LIST_TOPICS));
    MoveWindow(m_hwndListTopicsButton, rcChild.right - LOWORD(dwExt), rcButton.top,
        LOWORD(dwExt), HIWORD(dwExt), FALSE);
    ShowWindow();
    SetFocus( m_hwndComboBox );
   EnableWindow(m_hwndListTopicsButton, W_HasText(m_hwndComboBox));

    // Initialize the array containing the dialog information.
    InitDlgItemArray() ;

    return TRUE;

_Error:
    DESTROYIFVALID(m_hwndComboBox);
    DESTROYIFVALID(m_hwndListTopicsButton);
    DESTROYIFVALID(m_hwndListBox);
    DESTROYIFVALID(m_hwndStaticKeyword);
    DESTROYIFVALID(m_hwndStaticTopic);
    DESTROYIFVALID(m_hwndDisplayButton);
    return FALSE;
}

///////////////////////////////////////////////////////////
//
// ResizeWindow
//
    // if the parent window size changes, resize and place the child windows.
void CSearch::ResizeWindow()
{
    ASSERT(::IsValidWindow(m_hwndStaticKeyword)) ;

    // Resize to fit the client area of the tabctrl if it exists.
    ASSERT(::IsValidWindow(m_hwndResizeToParent )) ;


    RECT rcParent, rcChild;
    DWORD dwExt;
    HFONT hfUI = _Resource.GetUIFont();

    GetParentSize(&rcParent, m_hwndResizeToParent, m_padding, m_NavTabPos);
    rcParent.top += GetSystemMetrics(SM_CYSIZEFRAME)*2 ; //HACK: Fudge the top since we are not parented to the tabctrl.

    CopyRect(&rcChild, &rcParent);
            // Resize the Static above the combo control
    dwExt = GetStaticDimensions( m_hwndStaticKeyword, hfUI, GetStringResource(IDS_TYPE_KEYWORD), RECT_WIDTH(rcChild) );
    rcChild.bottom = rcChild.top+HIWORD(dwExt);

    if (g_fDBCSSystem || g_langSystem == LANG_ARABIC || g_langSystem == LANG_HEBREW)
    {
       PCSTR pszTabVertSize = GetStringResource(IDS_TAB_VERT_PADDING);
       DWORD dwPad = 2;

      if(pszTabVertSize && IsDigit((BYTE) *pszTabVertSize))
            dwPad = Atoi(pszTabVertSize);

        MoveWindow(m_hwndStaticKeyword, rcParent.left, rcParent.top+dwPad,
                    RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);
    }
    else
        MoveWindow(m_hwndStaticKeyword, rcParent.left, rcParent.top,
            RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);

            // Resize the Combo control
    rcChild.top = rcChild.bottom + c_StaticControlSpacing; //space for the static

    dwExt = GetStaticDimensions(m_hwndComboBox, GetContentFont(),"Test", RECT_WIDTH(rcChild) );
    rcChild.bottom = rcChild.top+HIWORD(dwExt) + GetSystemMetrics(SM_CYSIZEFRAME)*2 ;
    MoveWindow(m_hwndComboBox, rcChild.left, rcChild.top,
                RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);

            // Resize the List Topics Button
    rcChild.top = rcChild.bottom + c_ControlSpacing;
    dwExt = GetButtonDimensions(m_hwndListTopicsButton, hfUI, GetStringResource(IDS_LIST_TOPICS));
    rcChild.bottom = rcChild.top + HIWORD(dwExt);
    MoveWindow(m_hwndListTopicsButton, rcChild.right - LOWORD(dwExt), rcChild.top,
        LOWORD(dwExt), RECT_HEIGHT(rcChild), TRUE);
            // Resize the Static text above the list box
    rcChild.top = rcChild.bottom+ c_ControlSpacing;
    dwExt = GetStaticDimensions( m_hwndStaticTopic, hfUI, GetStringResource(IDS_SELECT_TOPIC), RECT_WIDTH(rcChild) );
    rcChild.bottom = rcChild.top+HIWORD(dwExt);
    MoveWindow(m_hwndStaticTopic, rcChild.left, rcChild.top,
                RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);
            // Resize the List Box
    rcChild.top = rcChild.bottom + c_StaticControlSpacing;
    dwExt = GetButtonDimensions(m_hwndDisplayButton, hfUI, GetStringResource(IDS_ENGLISH_DISPLAY) );
    rcChild.bottom = rcParent.bottom - (HIWORD(dwExt) + c_ControlSpacing);
    MoveWindow(m_hwndListBox, rcChild.left, rcChild.top,
                RECT_WIDTH(rcChild), RECT_HEIGHT(rcChild), TRUE);

    // BUG 3204 ---
    // In 3204, the listview control was painting BEFORE the tabctrl which was then painting over the top of it.
    // Therefore, I've added code here and in create to force the listbox to be the top most window in this grouping.
    SetWindowPos(m_hwndListBox, HWND_TOP, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE );

            // Resize the Display Button
    rcChild.bottom = rcParent.bottom ;
    rcChild.top = rcChild.bottom - HIWORD(dwExt);
    MoveWindow(m_hwndDisplayButton, rcChild.right - LOWORD(dwExt), rcChild.top,
        LOWORD(dwExt), RECT_HEIGHT(rcChild), TRUE);
		
    m_plistview->SizeColumns();				
}

void CSearch::HideWindow(void)
{

    ::ShowWindow(m_hwndListBox, SW_HIDE);
    ::ShowWindow(m_hwndDisplayButton, SW_HIDE);
    ::ShowWindow(m_hwndListTopicsButton, SW_HIDE);
    ::ShowWindow(m_hwndComboBox, SW_HIDE);
    ::ShowWindow(m_hwndStaticKeyword, SW_HIDE);
    ::ShowWindow(m_hwndStaticTopic, SW_HIDE);

}

void CSearch::ShowWindow(void)
{
    ::ShowWindow(m_hwndListBox, SW_SHOW);
    ::ShowWindow(m_hwndDisplayButton, SW_SHOW);
    ::ShowWindow(m_hwndListTopicsButton, SW_SHOW);
    ::ShowWindow(m_hwndComboBox, SW_SHOW);
    ::ShowWindow(m_hwndStaticKeyword, SW_SHOW);
    ::ShowWindow(m_hwndStaticTopic, SW_SHOW);
    SetFocus(m_hwndComboBox);
}
///////////////////////////////////////////////////////////
//
// OnCommand
//
LRESULT CSearch::OnCommand(HWND hwnd, UINT id, UINT uNotifiyCode, LPARAM lParam)
{

    switch (id) {
        case IDSIMPLESEARCH_COMBO:
            if (uNotifiyCode == CBN_EDITCHANGE)
                m_plistview->ResetQuery();
          return 0;

        case IDSEARCH_LIST:  // the list view control
            return 0;

        case IDBTN_LIST_TOPICS:     // The List Topics button
            WCHAR szQuery[500];
            int cResultCount;
            HRESULT hr;

            // Get the query text
            //
            W_GetWindowText(m_hwndComboBox, szQuery, 500);
            if ( lstrlenW(szQuery) <= 0 )
                return 0;
            {
                SEARCH_RESULT *pTempResults;
                // Submit the query
                //
                CHourGlass HourGlass;
                hr = m_pTitleCollection->m_pFullTextSearch->SimpleQuery(szQuery,&cResultCount, &pTempResults);

                // Check for search failure
                //
                if (FAILED(hr)) {
                    BOOL bContinue = FALSE;
                    UINT idMsg = IDS_SEARCH_FAILURE;
                    switch (hr)
                    {
                    case FTS_NO_INDEX:        idMsg = IDS_NO_FTS_DATA; break;
                    case FTS_NOT_INITIALIZED: idMsg = IDS_BAD_ITIRCL;  break;
                    case FTS_E_SKIP_TITLE: // bContinue = TRUE;
                    case FTS_E_SKIP_VOLUME:// bContinue = TRUE;
                    case FTS_E_SKIP_ALL:      bContinue = TRUE; break;
                    case FTS_INVALID_SYNTAX:  idMsg = IDS_INCORRECT_SYNTAX; break;
                    }
                    if( !bContinue )
                    {
                        MsgBox(idMsg);
                        SetFocus(m_hwndComboBox);
                        return 0;
                    }
                    SetFocus(m_hwndComboBox);
                }
                // Check for no results
                //
                if(!cResultCount)
                {
                    MsgBox(IDS_NO_TOPICS_FOUND);
                    SetFocus(m_hwndComboBox);
                    return 0;
                }
                else
                {
                    m_plistview->ResetQuery();
                    m_plistview->SetResults(cResultCount, pTempResults) ;
                    m_plistview->AddItems();
               EnableWindow(m_hwndDisplayButton, TRUE);
                }
            }
#if 0
            // For testing purposes, I'm going to display a message box containing a
            // comma delmited list of topic numbers that contained the search term(s).
            //
            char szResultList[1000],szTemp[20];
            szResultList[0]=0;
            int c;
            for(c=0;c<cResultCount;c++)
            {
                wsprintf(szTemp,"%d,",m_plistview->m_pResults[c].dwTopicNumber);
                strcat(szResultList,szTemp);
            }

            szResultList[strlen(szResultList)-1] = 0;

            // Show the list of resulting topic numbers
            //
            MessageBox(NULL,szResultList,"Full-Text Search Results",MB_OK|MB_TASKMODAL);
#endif
            return 0;

        case IDBTN_DISPLAY:
            if( (m_plistview->m_pResults != NULL) && (m_plistview->m_ItemNumber!= -1))
            {
                DWORD dwtemp = m_plistview->m_pResults[m_plistview->m_ItemNumber].dwTopicNumber;
                CExTitle* pTitle = m_plistview->m_pResults[m_plistview->m_ItemNumber].pTitle;

                if ( pTitle )
                {
                    char szURL[MAX_URL];
                    if ((pTitle->GetTopicURL(dwtemp, szURL, sizeof(szURL)) == S_OK))
                        ChangeHtmlTopic(szURL, GetParent(m_plistview->m_hwndListView), 1);
                }
            }
            return 0;

#ifdef _DEBUG
        case ID_VIEW_MEMORY:
            OnReportMemoryUsage();
            return 0;
#endif
    }
    return 0;
}

///////////////////////////////////////////////////////////
//
//                      CALLBACKS
//
///////////////////////////////////////////////////////////
//
// ComboProc
//
LRESULT WINAPI
CSearch::ComboProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {

    case WM_CHAR:
      {
        if (wParam == VK_TAB) // The virt code is the same as the tab character.
        {
            // Not handling this message was causing a beep.
            return 0 ;
        }
      }
        break ;

   case WM_KEYUP:
      EnableWindow(GETTHIS(CSearch, hwnd)->m_hwndListTopicsButton, W_HasText(GETTHIS(CSearch, hwnd)->m_hwndComboBox));
      break;
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            SendMessage(FindMessageParent(hwnd), WM_COMMAND, MAKELONG(IDBTN_LIST_TOPICS, BN_CLICKED), 0);
            return 0;

        case VK_TAB:
            if (GetKeyState(VK_SHIFT) < 0)
            {
            if (IsWindowEnabled(GETTHIS(CSearch, hwnd)->m_hwndDisplayButton))
               SetFocus(GETTHIS(CSearch, hwnd)->m_hwndDisplayButton);
            else
               SetFocus(GETTHIS(CSearch, hwnd)->m_hwndListBox);
         }
            else
            {
            if (IsWindowEnabled(GETTHIS(CSearch, hwnd)->m_hwndListTopicsButton))
                   SetFocus(GETTHIS(CSearch, hwnd)->m_hwndListTopicsButton);
            else
               SetFocus(GETTHIS(CSearch, hwnd)->m_hwndListBox);
         }
            return 0;
        }
        // fall through
    }
    return W_DelegateWindowProc(s_lpfnlComboWndProc, hwnd, msg, wParam,lParam);
}

///////////////////////////////////////////////////////////
//
// ListViewProc
//
LRESULT WINAPI
CSearch::ListViewProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_KEYDOWN:
        if (wParam == VK_TAB)
        {
            if (GetKeyState(VK_SHIFT) < 0)
            {
            if (IsWindowEnabled(GETTHIS(CSearch, hwnd)->m_hwndListTopicsButton))
                   SetFocus(GETTHIS(CSearch, hwnd)->m_hwndListTopicsButton);
            else
               SetFocus(GETTHIS(CSearch, hwnd)->m_hwndComboBox);
         }
            else
            {
            if (IsWindowEnabled(GETTHIS(CSearch, hwnd)->m_hwndDisplayButton))
                   SetFocus(GETTHIS(CSearch, hwnd)->m_hwndDisplayButton);
            else
               SetFocus(GETTHIS(CSearch, hwnd)->m_hwndComboBox);
         }
            return 0;
        }
        break;
    }
    return W_DelegateWindowProc(s_lpfnlListViewWndProc, hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
// ListBtnProc
//
LRESULT WINAPI
CSearch::ListBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_RETURN:
            SendMessage(FindMessageParent(hwnd), WM_COMMAND, MAKELONG(IDBTN_LIST_TOPICS, BN_CLICKED), 0);
            return 0;

        case VK_TAB:
            if (GetKeyState(VK_SHIFT) < 0)
                SetFocus(GETTHIS(CSearch, hwnd)->m_hwndComboBox);
            else
                SetFocus(GETTHIS(CSearch, hwnd)->m_hwndListBox);
            return 0;
        }
        break;
    }
    return W_DelegateWindowProc(lpfnlSearchListBtnWndProc, hwnd, msg, wParam, lParam);
}

///////////////////////////////////////////////////////////
//
// DisplayBtnProc
//
LRESULT WINAPI
CSearch::DisplayBtnProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg) {
        case WM_KEYDOWN:
            if (wParam == VK_RETURN) {
                SendMessage(FindMessageParent(hwnd), WM_COMMAND,
                    MAKELONG( IDBTN_DISPLAY, BN_CLICKED), 0);
                return 0;
            }
            if (wParam == VK_TAB) {
                CSearch* pThis = (CSearch*) GetWindowLongPtr(hwnd, GWLP_USERDATA);
                if (GetKeyState(VK_SHIFT) < 0)
                    SetFocus(pThis->m_hwndListBox);
            else
               SetFocus(pThis->m_hwndComboBox);
            }
            break;
    }
    return W_DelegateWindowProc(lpfnlSearchDisplayBtnWndProc, hwnd, msg, wParam, lParam);
}


///////////////////////////////////////////////////////////
//
// INavUI New Interface functions
//
///////////////////////////////////////////////////////////
//
// SetDefaultFocus
//
void
CSearch::SetDefaultFocus()
{
    if (IsValidWindow(m_hwndComboBox))
    {
        ::SetFocus(m_hwndComboBox) ;
    }
}

///////////////////////////////////////////////////////////
//
// ProcessMenuChar
//
bool
CSearch::ProcessMenuChar(HWND hwndParent, int ch)
{
    return ::ProcessMenuChar(this, hwndParent, m_aDlgItems, c_NumDlgItems, ch) ;
}


///////////////////////////////////////////////////////////
//
// OnNotify
//
LRESULT
CSearch::OnNotify(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    // Delegate all of the WM_NOTIFY messages to the listview control.
    if ((wParam == IDSEARCH_LIST) && (::IsValidWindow(m_hwndListBox)) && m_plistview)
    {
        m_plistview->ListViewMsg(m_hwndListBox, (NM_LISTVIEW*) lParam);
    }

    return 0;
}

///////////////////////////////////////////////////////////
//
// Helper Functions
//
///////////////////////////////////////////////////////////
//
// InitDlgItemArray
//
void
CSearch::InitDlgItemArray()
{
    //TODO: This the m_aDlgItems array has not been fully utilized. Yet. Currently. we
    // are only using it here for accelerator handling. See Bookmark.cpp and adsearch.cpp for
    // the complete useage.

    //RECT rectCurrent ;
    //RECT rectDlg ;
    //::GetClientRect(m_hWnd, &rectDlg) ;
    //--- Setup the dlg array for each control.

    //--- Keyword Edit
    int i = c_KeywordEdit;
    m_aDlgItems[i].m_hWnd = m_hwndComboBox; //::GetDlgItem(m_hWnd, IDSIMPLESEARCH_COMBO) ;
    //::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    //ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDSIMPLESEARCH_COMBO;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_hwndStaticKeyword);

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
/*
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV = ;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.
*/

    //--- ListTopics Btn
    i = c_ListTopicBtn;
    m_aDlgItems[i].m_hWnd = m_hwndListTopicsButton ;//::GetDlgItem(m_hWnd, IDBTN_LIST_TOPICS) ;
    //::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    //ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDBTN_LIST_TOPICS;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::Button;
/*
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV = ;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.
*/

    //--- Results List
    i = c_ResultsList;
    m_aDlgItems[i].m_hWnd = m_hwndListBox;//::GetDlgItem(m_hWnd, IDSEARCH_LIST) ;
    //::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    //ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDSEARCH_LIST;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_hwndStaticTopic);

    m_aDlgItems[i].m_Type = ItemInfo::Generic;
/*
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV = ;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.
*/

    //--- Display Button
    i = c_DisplayBtn;
    m_aDlgItems[i].m_hWnd = m_hwndDisplayButton ; //::GetDlgItem(m_hWnd, IDBTN_DISPLAY) ;
    //::GetWindowRect(m_aDlgItems[i].m_hWnd, &rectCurrent) ; // Get screen coordinates.
    //ScreenRectToClientRect(m_hWnd, &rectCurrent); // Convert to client

    m_aDlgItems[i].m_id = IDBTN_DISPLAY;
    m_aDlgItems[i].m_accelkey = (CHAR)GetAcceleratorKey(m_aDlgItems[i].m_hWnd);

    m_aDlgItems[i].m_Type = ItemInfo::Button;
/*
    m_aDlgItems[i].m_bIgnoreEnabled = TRUE ;
    //m_aDlgItems[i].m_bEnabled;              // Is the control enabled?
    m_aDlgItems[i].m_bIgnoreMax = TRUE ;       // Ignore the Max parameter.
    m_aDlgItems[i].m_bGrowH = FALSE;           // Grow Horizontally.
    m_aDlgItems[i].m_bGrowV = FALSE ;           // Grow Vertically.

    m_aDlgItems[i].m_JustifyV = Justify::Top;        // Do we stick to the top or the bottom.
    //m_aDlgItems[i].m_iOffsetV = ;            // Distance from our justification point.
    m_aDlgItems[i].m_JustifyH = Justify::Right;        // Do we stick to the right or the left
    m_aDlgItems[i].m_iOffsetH = rectDlg.right - rectCurrent.left;
    //m_aDlgItems[i].m_iPadH = ;               // Right Horizontal Padding.
    //m_aDlgItems[i].m_iPadV = ;               // Bottom Vertical Padding.

    m_aDlgItems[i].m_rectMin = rectCurrent;
    m_aDlgItems[i].m_rectCur = rectCurrent;
    //m_aDlgItems[i].m_rectMax ;        // Max size.
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\secwin.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __SECWIN_H__
#define __SECWIN_H__

#undef WINUSERAPI
#define WINUSERAPI
#include "htmlhelp.h"
#include "hhctrl.h"
#include "tabctrl.h"
#include "chistory.h"
#include "system.h"

#include "navui.h" // Replace with forward reference.

// Sizebar class.
#include "sizebar.h"

    // Tool Bar defines
    // ----------------

// Length of the text under each toolbar button
#define MAX_TB_TEXT_LENGTH      64

// Select tab commands. Used by the tab accelerator table.
#define IDC_SELECT_TAB_FIRST    0x9000 // Make sure this doesn't conflict with other WM_COMMANDS!
#define IDC_SELECT_TAB_LAST     (IDC_SELECT_TAB_FIRST + HH_MAX_TABS)

//  max number of toolbar buttons
// #define MAX_TB_BUTTONS          20
#define MAX_TB_BUTTONS          18

// Dimensions of Coolbar Glyphs ..
#define TB_BMP_CX               20
#define TB_BMP_CY               20
#define TB_BTN_CY               TB_BMP_CY  // TB button height
#define TB_BTN_CX               TB_BMP_CX  // TB button width

    // End Tool Bar defines
    // --------------------

const int c_NUMNAVPANES = HH_MAX_TABS+1 ; //REVIEW: Why not use HH_MAX_TABS instead?

#define HHFLAG_AUTOSYNC               (1 << 0)
#define HHFLAG_NOTIFY_ON_NAV_COMPLETE (1 << 1)

#define DEFAULT_STYLE       (WS_THICKFRAME | WS_OVERLAPPED)
#define DEFAULT_NAV_WIDTH   250
#define DEFAULT_NOTES_HEIGHT 100
#define SIZE_BAR_WIDTH      7

const char WINDOW_SEPARATOR = '>';

const int TAB_PADDING = 8; // UI Cleanup. Was 4 now 8.

extern RECT    g_rcWorkArea;
extern int     g_cxScreen;
extern int     g_cyScreen;
extern BOOL    g_fOleInitialized;
extern CRITICAL_SECTION g_cs;       // per-instance

typedef struct {
    int   cbStruct;
    RECT  rcPos;
    int   iNavWidth;
    BOOL  fHighlight;
    BOOL  fLockSize;
    BOOL  fNoToolBarText;
    BOOL fNotExpanded;
    int   curNavType;
} WINDOW_STATE;

///////////////////////////////////////////////////////////
//
// Forward References
//
class CContainer;   // forward reference
class CNotes;       // forward reference
class CSizeBar;     // forward reference


// WARNING! Do not add classes -- only add class members, or constructor
// for CHHWinType will trash the class.

class CHHWinType : public tagHH_WINTYPE
                   MI2_COUNT(CHHWinType)
{
public:
    CHHWinType(LPCTSTR pszOwnerFile)
        :m_hAccel(NULL)
    {
            ZERO_INIT_CLASS(CHHWinType);
            cbStruct = sizeof(HH_WINTYPE);


        // Which CHM files "owns" this window type.
        m_szOwnerFile = pszOwnerFile ;

#ifdef _CHECKMEM_ON_CLOSEWINDOW_
        _CrtMemCheckpoint(&m_MemState) ;
#endif
    }
    ~CHHWinType();

    bool ReloadNavData(CHmData* phmdata) ; // Nasty hack for mso. Reloads nav pane from new chm.

    PCSTR GetCaption() const { return pszCaption; }
    DWORD GetExStyles() const { return dwExStyles; }
    DWORD GetStyles() const ;
    PCSTR GetTypeName() const { return pszType; }
    RECT* GetWinRect() { return &rcWindowPos; }
    BOOL  IsProperty(UINT prop) const { return (fsWinProperties & prop); }
    BOOL  IsUniCodeStrings() const { return fUniCodeStrings; }
    BOOL  IsValidMember(UINT member) const { return (fsValidMembers & member); }
    void  GetWindowRect(void) { if (IsValidWindow(*this)) ::GetWindowRect(*this, &rcWindowPos); }
    void  GetClientRect(RECT* prc); // gets client area for host window
    int   GetShowState() const { return nShowState; }

    int   GetLeft() const { return rcWindowPos.left; }
    int   GetTop() const { return rcWindowPos.top; }
    int   GetRight() const { return rcWindowPos.right; }
    int   GetBottom() const { return rcWindowPos.bottom; }
    int   GetWidth() const { return RECT_WIDTH(rcWindowPos); }
    int   GetHeight() const { return RECT_HEIGHT(rcWindowPos); }

    HWND  GetHwnd() const { return hwndHelp; }
    HWND  GetCallerHwnd() const { return hwndCaller; }
    HWND  GetToolBarHwnd() const { return hwndToolBar; }
    HWND  GetNavigationHwnd() const { return hwndNavigation; }
    HWND  GetSizeBarHwnd() const { return m_pSizeBar->hWnd(); }
    HWND  GetHTMLHwnd() const { return hwndHTML; }
    HWND GetTabCtrlHwnd() const // TabCtrlHwnd doesn't always exist.
        {return (m_pTabCtrl ? m_pTabCtrl->hWnd() : GetNavigationHwnd()); }

    int GetCurrentNavPaneIndex() ;
    int GetTabIndexFromNavPaneIndex(int iNavPaneIndex);

    PCSTR GetToc() const { return pszToc; }
    PCSTR GetIndex() const { return pszIndex; }
    PCSTR GetFile() const { return pszFile; }

    // Return the CHM file which owns this window type.
    LPCTSTR GetOwnerFile() const { return m_szOwnerFile.psz; }

    BOOL  IsExpandedNavPane() const { return !fNotExpanded; }

    operator HWND() const
        { return hwndHelp; }
    operator RECT*()
        { return &rcWindowPos; }
    operator PCSTR() const
        { return pszType; }

    void SetUniCodeStrings(HH_WINTYPE* phhWinType) { fUniCodeStrings = phhWinType->fUniCodeStrings; }
    void SetTypeName(HH_WINTYPE* phhWinType);
    void SetValidMembers(HH_WINTYPE* phhWinType) { fsValidMembers = phhWinType->fsValidMembers; }
    void SetProperties(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_PROPERTIES)) fsWinProperties = phhWinType->fsWinProperties; }
    void SetStyles(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_STYLES)) dwStyles = phhWinType->dwStyles; }
    void SetExStyles(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_EXSTYLES)) dwExStyles = phhWinType->dwExStyles; }
    void SetWindowRect(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_RECT)) memcpy(&rcWindowPos, &phhWinType->rcWindowPos, sizeof(RECT)); }
    void SetDisplayState(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_SHOWSTATE)) nShowState = phhWinType->nShowState; else nShowState = SW_SHOW;  }
    void SetTabPos(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_TABPOS)) tabpos = phhWinType->tabpos; else tabpos = HHWIN_NAVTAB_TOP;    }
    void SetTabOrder(HH_WINTYPE* phhWinType);
    void SetCaption(HH_WINTYPE* phhWinType) { SetString(phhWinType->pszCaption, (PSTR*) &pszCaption); }
    void SetJump1(HH_WINTYPE* phhWinType);
    void SetJump2(HH_WINTYPE* phhWinType);
    void SetToc(HH_WINTYPE* phhWinType) { SetUrl(phhWinType->pszToc, (PSTR*) &pszToc); }
    void SetIndex(HH_WINTYPE* phhWinType) { SetUrl(phhWinType->pszIndex, (PSTR*) &pszIndex); }
    void SetFile(HH_WINTYPE* phhWinType)  { SetUrl(phhWinType->pszFile, (PSTR*) &pszFile); }
    void SetNavExpansion(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_EXPANSION)) fNotExpanded = phhWinType->fNotExpanded; }
    void SetNavWidth(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_NAV_WIDTH)) iNavWidth = phhWinType->iNavWidth; }
    void SetCaller(HH_WINTYPE* phhWinType) { hwndCaller = phhWinType->hwndCaller; }
    void SetHome(HH_WINTYPE* phhWinType)  { SetUrl(phhWinType->pszHome, (PSTR*) &pszHome); }
    void SetToolBar(HH_WINTYPE* phhWinType) { fsToolBarFlags =
        IsValidMember(HHWIN_PARAM_TB_FLAGS) ? phhWinType->fsToolBarFlags : HHWIN_DEF_BUTTONS; }
    void SetString(PCSTR pszSrcString, PSTR* ppszDst);
    void SetUrl(PCSTR pszSrcString, PSTR* ppszDst);
    void SetCurNavType(HH_WINTYPE* phhWinType) { if (IsValidMember(HHWIN_PARAM_CUR_TAB)) curNavType = phhWinType->curNavType ;}

    void SetLeft(int left) { rcWindowPos.left = left; }
    void SetTop(int top) { rcWindowPos.top = top; }
    void SetRight(int right) { rcWindowPos.right = right; }
    void SetBottom(int bottom) { rcWindowPos.bottom = bottom; }

    // General functions

    void AddExStyle(DWORD style) { dwExStyles |= style; }
    void AddStyle(DWORD style) { dwStyles |= style; }
    void AddToHistory(PCSTR pszTitle, PCSTR pszUrl);

    void AuthorMsg(UINT idStringFormatResource, PCSTR pszSubString = "") { ::AuthorMsg(idStringFormatResource, pszSubString, *this, NULL); }
    void CalcHtmlPaneRect(void);
    void CloseWindow();
    void SaveState() ;
    void ReloadCleanup() ;
    void ProcessDetachSafeCleanup();
    void CreateBookmarksTab() ;
    void CreateHistoryTab(void);
    void CreateCustomTab(int iPane, LPCOLESTR pszProgId);
    BOOL IsValidNavPane(int iTab);
    int GetValidNavPane(); // Returns the index of the first valid tab it finds. -1 if no valid tabs.
    BOOL AnyValidNavPane(void) {return GetValidNavPane() != -1; }
    int GetValidNavPaneCount() ;

    void CreateIndex(void);
    void CreateNavPane(int iPane) ; // Creates the appropriate NavPane if it doesn't already exist.
    void CreateOrShowHTMLPane(void);
    void CreateOrShowNavPane(void);
    void CreateSearchTab(void);
    void CreateSizeBar( void );
    void CreateToc(void);
    int  CreateToolBar(TBBUTTON* pabtn);
    void DestroySizeBar( void );
    void doSelectTab(int newTabIndex);
    void OnNavigateComplete(LPCTSTR pszUrl);

#ifndef CHIINDEX
    void OnPrint(void);
#endif

    BOOL OnTrackNotifyCaller(int idAction);
    void SetActiveHelpWindow(void);
    void SetChmData(CHmData* phmData) { m_phmData = phmData; }
    void SetDisplayState(int nShow) { nShowState = nShow;  }
    void SetTypeName(PCSTR pszSetType) { ASSERT(!pszType); pszType = lcStrDup(pszSetType); }
    void ToggleExpansion(bool bNotify=true);
    void UpdateInformationTypes(void);
    void WrapTB();

    bool ManualTranslateAccelerator(char iChar);
    bool DynamicTranslateAccelerator(MSG* pMsg);

    int  GetExtTabCount() ;
    EXTENSIBLE_TAB* GetExtTab(int pos) ;
    HFONT GetUIFont() const { return _Resource.GetUIFont(); }
    HFONT GetContentFont();
    HFONT GetAccessableContentFont();
    INT   GetContentCharset();
    UINT  GetCodePage(void);
    void UpdateCmdUI(void);


    //--- Save/Restore focus during WM_ACTIVATE.
    bool RestoreCtrlWithFocus();
    void SaveCtrlWithFocus();
    HWND m_hwndLastFocus ; // The window handle of the control which had focus last. See WM_ACTIVATE in wndproc.cpp

    HWND m_hwndIndexEdit;
    HWND m_hwndIndexDisplay;
    HWND m_hwndNotes;
    HWND m_hwndListBox;
    CSizeBar* m_pSizeBar ;// moveable window in TRIPANE to size the HTML and NAV panes.

    // Tab classes

    HWND m_hwndControl;

    INavUI* m_aNavPane[c_NUMNAVPANES] ;
    CToc* m_ptocDynCast ; // We need a dynamic cast, but we don't have RTTI. Use this as a temp hack.

    HH_INFOTYPE* m_paInfoTypes;  // Pointer to an array of Information Types

    RECT  rcNav;
    RECT  rcToolBar;
    RECT  rcNotes;
    BOOL  m_fNotesWindow;   // TRUE to show the notes window
    BOOL  m_fHighlight;
    BOOL  m_bCancel;
    BOOL  m_fLockSize;  // TRUE to prevent show/hide from changing window size
    CTable* m_ptblBtnStrings;
    BOOL m_fNoToolBarText;
    CTabControl* m_pTabCtrl;
    CContainer* m_pCIExpContainer;
    CHmData* m_phmData;
    CHmData* m_phmDataOrg; // The original CHM before the ReloadNavData call.
#ifdef _DEBUG
    CNotes* m_pNotes;
#endif
    BOOL  m_fActivated;
    HWND  m_hwndFocused;    // The window with the focus.
    HWND  m_hWndSSCB;
    HWND  m_hWndST;
    //
    // This is the total height in pels for margins + static text + combo-box.
    // ie. it's the distance between the bootm of the toolbar and the top of the hh child window that frames the nav pane.
    //
    int   m_iSSCBHeight;

private:
    // Filename of the CHM File which owns this window definition.
    CStr m_szOwnerFile;

    HMENU   m_hMenuOptions;

    HACCEL m_hAccel ; // The accelerator table for this window.
public:

    //  Zoom support.
    //
    int m_iZoom;
    int m_iZoomMin;
    int m_iZoomMax;
    HRESULT Zoom(int iZoom);
    HRESULT GetZoomMinMax(void);

    void ZoomOut(void);
    void ZoomIn(void);
    //
    //  Next/Prev in TOC support.
    //
    BOOL OnTocNext(BOOL bDoJump);
    BOOL OnTocPrev(BOOL bDoJump);

    // image lists
    HIMAGELIST m_hImageListGray;
    HIMAGELIST m_hImageList;

// Memory checking class.
#ifdef _DEBUG
    _CrtMemState m_MemState ;
#endif
};

extern CHHWinType** pahwnd;

__inline CHHWinType* FindWindowIndex(HWND hwnd) {
    for (int i = 0; i < g_cWindowSlots; i++) {
        if (pahwnd && pahwnd[i] != NULL && pahwnd[i]->hwndHelp == hwnd)
            return pahwnd[i];
    }
    return NULL;
}

CExCollection* GetCurrentCollection( HWND hwnd, LPCSTR lpszChmFilespec = NULL );

BOOL GetCurrentURL( CStr* pcszCurrentURL, HWND hWnd = NULL );

CHHWinType* CreateHelpWindow(PCSTR pszType, LPCTSTR pszFile, HWND hwndCaller, CHmData* phmData);
HWND        doDisplaySearch(HWND hwndCaller, LPCSTR pszFile, HH_FTS_QUERY* pFtsQuery);
CHHWinType* FindCurWindow();
CHHWinType* FindHHWindowIndex(CContainer* m_pOuter);
CHHWinType* FindHHWindowIndex(HWND hwndChild);
CHHWinType* FindOrCreateWindowSlot(LPCTSTR pszType, LPCTSTR pszOwnerFile);
CHHWinType* FindWindowType(PCSTR pszType, HWND hwndCaller, LPCTSTR pszOwnerFile);
HWND        OnKeywordSearch(HWND hwndCaller, PCSTR pszFile, HH_AKLINK* pakLink, BOOL fKLink = TRUE);

void DeleteWindows() ;

// These functions handle the HH_GET/SET_WINTYPE commands
HWND        GetWinType(HWND hwndCaller, LPCSTR pszFile,  HH_WINTYPE** pphh) ;
HWND        SetWinType(LPCSTR pszFile, HH_WINTYPE* phhWinType, CHmData* pChmDataOrg = NULL)  ;

// Helper function for resizing the window. see wndproc.cpp
void ResizeWindow(CHHWinType* phh, bool bRecalcHtmlFrame=true) ;


#endif  // __SECWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\shareres.h ===
///////////////////////////////////////////////////////////////////////////////////////////////
//
// These resources ID's are shared between hhw and hhctrl. ie. This file is included in the
// shareres.rc file which is included in .rc files that liven in BOTH hhw and hhctrl.
// This is necessary becuase we share C/C++ code between the two and that code may also
// include resouce needs.
//

#define SHARED_RANGE		7000

#define IDS_ITSS_NOT_INITIALIZED			SHARED_RANGE + 1
#define IDS_CANT_CREATE_SUBFOLDER		SHARED_RANGE + 2
#define IDS_CANT_CREATE_SUBFILE			SHARED_RANGE + 3	
#define IDS_CANT_WRITE_SUBFILE         SHARED_RANGE + 4
#define IDS_CANT_READ_SUBFILE          SHARED_RANGE + 5



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\shared.h ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

// Functions in hhctrl.ocx that are called by hh.exe

#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus

HMODULE 	LoadHHA(HWND hwnd, HINSTANCE hinst);
void		AuthorMsg(UINT idStringFormatResource, PCSTR pszSubString, HWND hwndParent, void* phhctrl);

#ifdef __cplusplus
}
#endif // __cplusplus

extern BOOL 	g_fTriedHHA;	// whether or not we tried to find HHA.dll
extern HMODULE	g_hmodHHA;		// HHA.dll module handle

__inline BOOL IsHelpAuthor(void) { return g_hmodHHA != NULL; }
__inline int RECT_WIDTH(RECT rc) { return rc.right - rc.left; };
__inline int RECT_HEIGHT(RECT rc) { return rc.bottom - rc.top; };
__inline int RECT_WIDTH(const RECT* prc) { return prc->right - prc->left; };
__inline int RECT_HEIGHT(const RECT* prc) { return prc->bottom - prc->top; };
__inline BOOL IsValidWindow(HWND hwnd) { return (BOOL) (hwnd && IsWindow(hwnd)); };
__inline BOOL IsSpace(char ch) { return (ch == ' ' || ch == '\t'); }
__inline BOOL IsDigit(char ch) { return (ch >= '0' && ch <= '9'); }
__inline BOOL IsEmptyString(PCSTR psz) { return ((psz == NULL) || (!psz[0])); }
__inline BOOL IsNonEmpty(PCSTR psz) { return (IsEmptyString(psz) == FALSE); }
__inline BOOL IsNonEmptyString(PCSTR psz) { return (IsEmptyString(psz) == FALSE); }
__inline BOOL isSameString(PCSTR psz1, PCSTR psz2) { return (psz1 && psz2 ? IsSamePrefix(psz1, psz2, -1) : FALSE); }
__inline BOOL isSameString(PCWSTR pwsz1, PCWSTR pwsz2) { return (pwsz1 && pwsz2 ? IsSamePrefix(pwsz1, pwsz2, -1) : FALSE); }
__inline UCHAR ToLower(char ch) { return (UCHAR) CharLower((LPTSTR) (DWORD_PTR) (UCHAR) ch); };
__inline UCHAR ToUpper(char ch) { return (UCHAR) CharUpper((LPTSTR) (DWORD_PTR) (UCHAR) ch); };

__inline BOOL IsEmptyStringW(LPCWSTR psz) { return ((psz == NULL) || (!psz[0])); } //REVIEW: Is this kosher?
__inline BOOL IsNonEmptyW(LPCWSTR psz) { return (IsEmptyStringW(psz) == FALSE); }
__inline BOOL IsNonEmptyStringW(LPCWSTR psz) { return (IsEmptyStringW(psz) == FALSE); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sitemap.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "sitemap.h"
#include <shlobj.h>
#include <wininet.h>

#ifndef HHCTRL
#include "hha_strtable.h"
#else
#include "hha_strtable.h"
#include "hhctrl.h"
#include "strtable.h"
#endif

#include "web.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#ifndef _DEBUG
#pragma optimize("at", on)
#endif

#include "sitechar.cpp"
#ifndef HHCTRL
static const char txtSaveTypeHidden[]    = "SaveHidden";
static const char txtSaveTypeExclusive[] = "SaveExclusive";
static const char txtSaveType[]          = "SaveType";
static const char txtSaveTypeDesc[]      = "SaveTypeDesc";
#endif

class CParseSitemap : public SITEMAP_ENTRY
{
public:
    CParseSitemap(CSiteMap* pSiteMap) {
        m_pSiteMap = pSiteMap;
        Clear();
        m_fGlobal = FALSE;
        m_cMaxTitles = 50;
        m_ppszTitles = (PCSTR*) lcCalloc(m_cMaxTitles * sizeof(PCSTR));
        m_pSiteUrl = new CSiteEntryUrl(pSiteMap->InfoTypeSize());
        }
    ~CParseSitemap() { lcFree(m_ppszTitles); delete m_pSiteUrl; }

    BOOL IsGlobal(void) { return m_fGlobal; }
    void SetGlobal(BOOL fSetting) { m_fGlobal = fSetting; }

    void AddTitle(PCSTR psz);

    PCSTR*  m_ppszTitles;
    int     m_cMaxTitles;

    CStr    m_cszValue;
    BOOL    m_fGlobal;
    CSiteMap* m_pSiteMap;
    CSiteEntryUrl* m_pSiteUrl;
    void SaveUrlEntry() { m_pSiteUrl->SaveUrlEntry(m_pSiteMap, this); }

    operator CStr*() { return &m_cszValue; }
    operator PSTR() { return m_cszValue.psz; }
    operator PCSTR() const { return m_cszValue.psz; }
};

#ifndef _DEBUG
// REVIEW: check this from time to time to see if it is necessary...
#pragma optimize("a", on)
#endif

// Function prototypes

PSTR FindDblQuote(CAInput* painput, CStr* pcsz, PSTR psz);
PSTR GetValue(CAInput* pinput, CStr* pcsz, PSTR psz, CStr* pcszValue);
PSTR FindCharacter(CAInput* pinput, CStr* pcsz, PSTR psz, char ch);
PSTR GetType(CAInput* pinput, CStr* pcsz, PSTR psz, CStr* pcszValue);


#ifdef HHCTRL
#ifdef HHA
BOOL CSiteMap::ReadFromFile(PCSTR pszFileName, BOOL fIndex, CHtmlHelpControl* phhctrl )
#else
BOOL CSiteMap::ReadFromFile(PCSTR pszFileName, BOOL fIndex, CHtmlHelpControl* phhctrl, UINT CodePage )
#endif
#else
BOOL CSiteMap::ReadFromFile(PCSTR pszFileName, BOOL fIndex, PCSTR pszBaseFile)
#endif
{

#ifdef HHCTRL
#ifndef HHA
    m_CodePage = CodePage;
#endif
#endif

    CAInput ainput;
    int curInput = 0;
    if (!ainput.Add(pszFileName)) {
#ifdef HHCTRL
        if (phhctrl)
            phhctrl->AuthorMsg(IDS_CANT_OPEN, pszFileName);

        SITEMAP_ENTRY* pSiteMapEntry = AddEntry();

        ASSERT_COMMENT(!pSiteMapEntry->iFrameName &&
                       !pSiteMapEntry->iWindowName,
                       "Add() function not returning zero'd memory");

        pSiteMapEntry->level = 1;
        CStr cszLine(IDS_CANT_FIND_FILE, pszFileName);
        pSiteMapEntry->pszText = StrDup(cszLine);
        pSiteMapEntry->SetTopic(TRUE);
#else
        MsgBox(IDS_CANT_OPEN, pszFileName);
#endif

        return FALSE;
    }
    SetSiteMapFile(pszFileName);
    m_fIndex = fIndex;

    // We don't want the first file to have a basename

#if (defined(HHCTRL) || defined(HHA))
    m_pszBase = ainput.GetBaseName();
    *m_pszBase = '\0';
#endif

    // used for indexes

    CParseSitemap cparse(this);
    CTable *ptblSubSets=NULL;    // To hold any subset declarations.
    int  curLevel = 0;

    CStr cszLine;
    BOOL fSiteMap = FALSE;
    BOOL fMergePending = FALSE;    // TRUE if we need to include another file
    CStr cszMergeFile;          // file to merge into current

#ifdef _DEBUG
    int cLoops = 0; // so we know when to set a breakpoint
#endif

    for (;;) {
#ifdef _DEBUG
        cLoops++;
//        lcHeapCheck();
#endif

        if (fMergePending) {
#if (defined(HHCTRL) || defined(HHA))
            char szUrl[INTERNET_MAX_URL_LENGTH];
#endif
#ifdef HHA
            // When compiling, find the full path to the file

            strcpy(szUrl, cszMergeFile);
            ConvertToFull(pszBaseFile, szUrl);
            ainput.Add(szUrl);
            {
#else
            if (!ainput.Add(cszMergeFile)) {
#endif
#ifdef HHCTRL
                if (ConvertToCacheFile(cszMergeFile, szUrl))
                    ainput.Add(szUrl);
                else if (phhctrl && phhctrl->m_pWebBrowserApp) {
                    CStr cszUrl;
                    phhctrl->m_pWebBrowserApp->GetLocationURL(&cszUrl);
                    PSTR psz = (PSTR) FindFilePortion(cszUrl);
                    if (psz) {
                        *psz = '\0';
                        cszUrl += cszMergeFile;
                        if (ConvertToCacheFile(cszUrl, szUrl))
                            ainput.Add(szUrl);
                    }
                }
#endif
            }
            fMergePending = FALSE;
#if (defined(HHCTRL) || defined(HHA))
            m_pszBase = ainput.GetBaseName();

            /*
             * If we are in the same location as our parent, ignore the
             * base name
             */

            if (!IsEmptyString(m_pszBase)) {
                CStr cszBase(m_pszBase);
                CStr cszSitemap(GetSiteMapFile());
                PSTR psz = (PSTR) FindFilePortion(cszSitemap);
                ASSERT(psz);
                if (psz)
                    *psz = '\0';
                ConvertBackSlashToForwardSlash(cszBase);
                ConvertBackSlashToForwardSlash(cszSitemap);
                if (lstrcmpi(cszBase, cszSitemap) == 0)
                    m_pszBase = NULL;
            }
#endif
        }

        if (curInput < 0)
            break;

        if (!ainput.getline(&cszLine)) {
            if (!ainput.Remove()) {
                if (m_fIndex)
                    return TRUE;
                break; // we're all done.
            }

            /*
             * Set parse to global so that if this was part of a merged
             * file we won't rewrite the last item when an </OBJECT> is
             * encountered.
             */

            // 16-Dec-1997  [ralphw] Don't call SetGlobal -- it deletes the
            // next folder

            // cparse.SetGlobal(TRUE);
            cparse.Clear();
#if (defined(HHCTRL) || defined(HHA))
            m_pszBase = ainput.GetBaseName();
#endif
            continue;
        }

        PSTR psz = FirstNonSpace(cszLine);
Loop:
        if ( !psz || !*psz)
            continue;   // ignore blank lines
        if (*psz == '<') {
            int cb;
            if ((cb = CompareSz(psz, txtParam))) {
                psz = FindDblQuote(&ainput, &cszLine, psz + cb);
                if (!psz)
                    goto FlushAndExit;
                PSTR pszParamType = psz;

                psz = GetValue(&ainput, &cszLine, psz, cparse);
                if (!psz)
                    goto FlushAndExit;
                if (ParseSiteMapParam(&cparse, pszParamType, ptblSubSets)) {
                    goto Loop;
                }
                else if (isSameString(pszParamType, txtParamHHI)) {
                    m_pszHHIFile = StrDup(cparse.m_cszValue.psz);
                    goto Loop;
                }
                else if (isSameString(pszParamType, txtParamMerge)) {
#if (!defined(HHCTRL) && !defined(HHA))
                    cszMergeFile = GetStringResource(IDS_INCLUDED_FILE);
                    cszMergeFile += cparse.m_cszValue.psz;
                    cparse.pszText = StrDup(cszMergeFile);
                    cparse.fInclude = TRUE;
                    cparse.iImage = IMAGE_CLOSED_FOLDER;
                    AddEntry(&cparse);
                    cparse.SetGlobal(TRUE); // so end object doesn't rewrite
#elif defined(HHA)
                    if (stristr(cparse.m_cszValue.psz, ".CHM")) {
                        cparse.pszText = StrDup(cparse.m_cszValue.psz);
                        cparse.fInclude = TRUE;
                        cparse.iImage = IMAGE_CLOSED_FOLDER;
                        AddEntry(&cparse);
                    }
                    else {
                        cszMergeFile = cparse.m_cszValue.psz;
                        fMergePending = TRUE;
                    }
#else
                    cszMergeFile = cparse.m_cszValue.psz;
                    fMergePending = TRUE;
#endif
                    goto Loop;
                }

                else if (!m_fIndex && isSameString(pszParamType, txtFavorites)) {
#if (defined(HHCTRL) || defined(HHA))
                    CreateFavorites();
                    goto Loop;
#endif
                    // REVIEW: how do we deal with this in HHW?
                }
            }
            else if ((cb = CompareSz(psz, txtBeginList))) {
                   curLevel++;
                psz = FirstNonSpace(psz + cb);
                goto Loop;
            }
            else if ((cb = CompareSz(psz, txtEndList))) {
                curLevel--;
                psz = FirstNonSpace(psz + cb);
                goto Loop;
            }
            else if ((cb = CompareSz(psz, txtBeginListItem))) {
                psz = FindCharacter(&ainput, &cszLine, psz + cb, '>');
                if (!psz)
                    goto FlushAndExit;
                if ((cb = CompareSz(psz, txtBeginObject))) {
                    psz = GetType(&ainput, &cszLine, psz + cb, cparse);

                    if (!psz) {
                        if (!ainput.getline(&cszLine))
                            goto FlushAndExit;
                        psz = GetType(&ainput, &cszLine, cszLine, cparse);
                        if (!psz)
                            goto FlushAndExit;
                    }

//////////////////// New Node /////////////////////////////////////////////

                    if (isSameString(cparse, txtSiteMapObject)) {
                        // Create a new entry

                        cparse.Clear();
                        cparse.level = (BYTE)curLevel;

                        goto Loop;
                    }

                    else if (isSameString(cparse, txtSitemapProperties)) {
                        cparse.SetGlobal(TRUE);
                    }
                }
            }
            else if ((cb = CompareSz(psz, txtEndObject))) {

//////////////////// End Node /////////////////////////////////////////////

                if (!cparse.IsGlobal()) {
                    if (m_fIndex) {
                        if (!cparse.m_pSiteUrl->m_fUrlSpecified) {

                            // BUGBUG: nag the author -- entry without a URL

                            psz += cb;
                            goto Loop;
                        }
                        cparse.SaveUrlEntry();
                        if (cparse.pszText && cparse.cUrls) {
                            AddEntry(&cparse);
                        }
                        else {
#if (defined(HHCTRL) || defined(HHA))
                            cparse.pszText = StrDup(GetStringResource(IDSHHA_INVALID_KEYWORD));
                            AddEntry(&cparse);
#endif
                            // we ignore the entry entirely in hhctrl.ocx

                        }

                        cparse.Clear();
                        cparse.level = (BYTE)curLevel;
                    }
                    else {
                        if (cparse.m_pSiteUrl->m_fUrlSpecified)
                            cparse.SaveUrlEntry();
                        AddEntry(&cparse);
                    }
                }
                else {
                    cparse.SetGlobal(FALSE);
//#ifdef HHCTRL         // having this conditional for HHCTRL causes IT declarations to not be present in HHW until the info type tab is visited
                        // bug 4762
                    if (IsNonEmpty(m_pszHHIFile)) {
                        cszMergeFile = cparse.m_cszValue.psz;
                        fMergePending = TRUE;
                        m_pszHHIFile = NULL;    // so we don't merge twice
                    }
//#endif
                }
                psz += cb;
                goto Loop;
            }
            else if (isSameString(psz, txtSitemap) ||
                    isSameString(psz, txtSitemap1) ||
                    isSameString(psz, txtSitemap2)) {
                fSiteMap = TRUE;
                psz = FindCharacter(&ainput, &cszLine, psz, '>');
                if (!psz)
                    goto FlushAndExit;
                else if (!*psz)
                    continue;
            }

            // Global properties?

            else if ((cb = CompareSz(psz, txtBeginObject))) {
                psz = GetType(&ainput, &cszLine, psz + cb, cparse);

                if (!psz) {
                    if (!ainput.getline(&cszLine))
                        goto FlushAndExit;
                    psz = GetType(&ainput, &cszLine, psz + cb, cparse);
                    if (!psz)
                        goto FlushAndExit;
                }
                if (isSameString(cparse, txtSitemapProperties)) {
                    cparse.SetGlobal(TRUE);
                    goto Loop;
                }
                else {
                    // ******** Check for Merge (include another file) *******

                    /*
                     * This is an object that appears outside of a list
                     * item. If it's a merge tag, then extract the merge
                     * information. Otherwise, ignore it.
                     */

                    psz = strstr(psz, txtEndTag);
                    if (psz)
                        psz = FirstNonSpace(psz + 1);
                    for (;;) {
                        if (!psz) {
                            if (!ainput.getline(&cszLine))
                                goto FlushAndExit;
                            psz = FirstNonSpace(cszLine.psz);
                        }
                        if ( !psz || !*psz) {
                            psz = NULL; // so we'll read the next line
                            continue;   // ignore blank lines
                        }
                        if (*psz == '<') {
                            if ((cb = CompareSz(psz, txtEndObject))) {
                                psz += cb;
                                goto Loop;
                            }
                            else if ((cb = CompareSz(psz, txtParam))) {
                                psz = FindDblQuote(&ainput, &cszLine,
                                    psz + cb);
                                if (!psz)
                                    goto FlushAndExit;
                                PSTR pszParamType = psz;

                                psz = GetValue(&ainput, &cszLine,
                                    psz, cparse);
                                if (!psz)
                                    goto FlushAndExit;
                                if (isSameString(pszParamType, txtParamMerge)) {
#if (!defined(HHCTRL) && !defined(HHA))
                                    cszMergeFile = GetStringResource(IDS_INCLUDED_FILE);
                                    cszMergeFile += cparse.m_cszValue.psz;
                                    cparse.pszText = StrDup(cszMergeFile);
                                    cparse.fInclude = TRUE;
                                    cparse.iImage = IMAGE_CLOSED_FOLDER;
                                    cparse.level = curLevel;
                                    AddEntry(&cparse);
#elif defined(HHA)
                                    if (stristr(cparse.m_cszValue.psz, ".CHM")) {
                                        cparse.pszText = StrDup(cparse.m_cszValue.psz);
                                        cparse.fInclude = TRUE;
                                        cparse.iImage = IMAGE_CLOSED_FOLDER;
                                        cparse.level = curLevel;
                                        AddEntry(&cparse);
                                    }
                                    else {
                                        cszMergeFile = cparse.m_cszValue.psz;
                                        fMergePending = TRUE;
                                    }
#else
                                    cszMergeFile = cparse.m_cszValue.psz;
                                    fMergePending = TRUE;
#endif
                                }
                            }
                        }
                    }
                }
            }
            else if (isSameString(psz, txtBeginHref)) {
                // Skip over all of HREF
                for (;;) {
                    psz = strstr(psz, txtEndTag);
                    if (psz) {
                        if (strncmp(psz, txtEndHref, (int)strlen(txtEndHref)) == 0)
                            break;
                        psz = stristr(psz, txtEndHref);
                    }
                    if (!psz) {
                        if (!ainput.getline(&cszLine))
                            goto FlushAndExit;
                        psz = cszLine.psz;
                    }
                    else
                        break;
                }
                psz = FindCharacter(&ainput, &cszLine, psz, '>');
                goto Loop;
            }
            else {
                // Ignore whatever it is
                psz = FindCharacter(&ainput, &cszLine, psz, '>');
                goto Loop;
            }
        }

        if (fSiteMap) {

            // In sitemaps, we only care about what appears inside angle
            // brackets.

            for(;;) {
                psz = StrChr(psz, '<');
                if (!psz) {
                    if (!ainput.getline(&cszLine)) {
                        psz = "";   // so Loop processing works
                        break;
                    }
                    psz = cszLine.psz;
                }
                else
                    break;
            }
            goto Loop;
        }
    }
# ifdef NOTYET
    // populate subsets
    if ( ptblSubSets )
    {
        if ( !m_pSubSets )
            m_pSubSets = new CSubSets(m_itTables.m_itSize, ptblSubSets, this, TRUE);
        delete ptblSubSets;
    }
#endif

    if (!fIndex) {
        // Now determine what is a book -- anything without a child is a topic

        curLevel = 0;
        int pos;
        for (pos = 1; pos < endpos - 1; pos++) {
            SITEMAP_ENTRY* pSiteMapEntry = GetSiteMapEntry(pos);
            if (pSiteMapEntry->level > curLevel + 1)
                pSiteMapEntry->level = curLevel + 1;
            curLevel = pSiteMapEntry->level;
            if (pSiteMapEntry->cUrls == 0)
                continue;   // if there is no URL, then it's a book
#ifdef _DEBUG
            SITEMAP_ENTRY* pSiteMapEntryNext = GetSiteMapEntry(pos + 1);
#endif
            if (pSiteMapEntry->level >= GetSiteMapEntry(pos + 1)->level)
                pSiteMapEntry->SetTopic(TRUE);
        }
        // You can never end with a book
        if (endpos > 1)
            GetSiteMapEntry(endpos - 1)->SetTopic(TRUE);
    }
    return TRUE;

FlushAndExit:
    return FALSE;
}


BOOL CSiteMap::ParseSiteMapParam(CParseSitemap* pcparse, PCSTR pszParamType, CTable *ptblSubSets)
{
    int iLastType = 0;

    // Deal with any escape sequences starting with '&'

    ReplaceEscapes(*pcparse, (PSTR) *pcparse, ESCAPE_ENTITY);

    if (pcparse->IsGlobal()) {
        int cb;
        // WARNING! Check for txtParamTypeDesc BEFORE the check for txtParamType
        // (because it's a substring search).
#ifdef NOTYET
            // parse Subset Declarations
        if ( isSameString( pszParamType, txtParamSSInclusive ) ||
             isSameString( pszParamType, txtParamSSExclusive))
        {
            if( !ptblSubSets )
                ptblSubsets = new CTable(16 * 1024);
            ptblSubSets->AddString(*pcparse);
        }else
#endif
            // parse Information Types Declarations
        if (isSameString(pszParamType, txtParamTypeExclusive)
#ifndef HHCTRL
            || isSameString(pszParamType, txtSaveTypeExclusive)
#endif
            ) {
            if (m_itTables.m_ptblInfoTypes && m_itTables.m_ptblInfoTypes->IsStringInTable(*pcparse)) {
                iLastType = GetITIndex( *pcparse );
                AddToCategory( iLastType );
                return TRUE;
            }else
            {
                iLastType = AddTypeName(*pcparse);
                AddExclusiveIT( iLastType );
                AddToCategory( iLastType );
                return TRUE;
            }
        }
        else if (isSameString(pszParamType, txtParamTypeHidden)
#ifndef HHCTRL
             || isSameString(pszParamType, txtSaveTypeHidden)
#endif
            ) {
            if (m_itTables.m_ptblInfoTypes && m_itTables.m_ptblInfoTypes->IsStringInTable(*pcparse)) {
                iLastType = GetITIndex( *pcparse );
                AddToCategory( iLastType );
                return TRUE;
            }else
            {
                iLastType = AddTypeName(*pcparse);
                AddHiddenIT( iLastType );
                AddToCategory( iLastType );
                return TRUE;
            }
        }
        else if ((cb = CompareSz(pszParamType, txtParamTypeDesc))
#ifndef HHCTRL
             || isSameString(pszParamType, txtSaveTypeDesc)
#endif
                ) {
            if (!m_itTables.m_ptblInfoTypeDescriptions)
                return TRUE;    // BUGBUG: nag author about description before type
                            // add a blank description to infotype description, description not provided for last infotype
            while (m_itTables.m_ptblInfoTypes->CountStrings() > m_itTables.m_ptblInfoTypeDescriptions->CountStrings()+1)
                m_itTables.m_ptblInfoTypeDescriptions->AddString("");
            if ( m_itTables.m_ptblInfoTypes->CountStrings() != m_itTables.m_ptblInfoTypeDescriptions->CountStrings() )
                m_itTables.m_ptblInfoTypeDescriptions->AddString(*pcparse);
            return TRUE;
        }                       // this matches anything that begins with "type"
        else if (isSameString(pszParamType, txtParamType)
#ifndef HHCTRL
             || isSameString(pszParamType, txtSaveType)
#endif
                ) {
            if (m_itTables.m_ptblInfoTypes && m_itTables.m_ptblInfoTypes->IsStringInTable(*pcparse)) {
                iLastType = GetITIndex( *pcparse );
                AddToCategory( iLastType );
                return TRUE;
            }
            else
            {
                iLastType = AddTypeName(*pcparse);
                AddToCategory( iLastType );
                return TRUE;
            }
        }

        // WARNING! Check for txtParamCategoryDesc BEFORE the check for txtParamCategory
        // (because it's a substring search).

        else if ((cb = CompareSz(pszParamType, txtParamCategoryDesc))) {
            if (!m_itTables.m_ptblCatDescription)
                return TRUE;    // BUGBUG: nag author about description before type
                // add a blank description to category description, description not provided for last Category
            while (m_itTables.m_ptblCategories->CountStrings() > m_itTables.m_ptblCatDescription->CountStrings()+1)
                m_itTables.m_ptblCatDescription->AddString("");

            m_itTables.m_ptblCatDescription->AddString(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtParamCategory)) {
            if (m_itTables.m_ptblCategories && m_itTables.m_ptblCategories->IsStringInTable(*pcparse)) {
                // BUGBUG: we should nag the help author
                return TRUE;
            }
            if (!m_itTables.m_ptblCategories)
            {
                m_itTables.m_ptblCategories = new CTable(16 * 1024);
                m_itTables.m_ptblCatDescription = new CTable(16 * 1024);
            }
            m_itTables.m_ptblCategories->AddString(*pcparse);
            return TRUE;
        }
        else
        if (isSameString(pszParamType, txtParamFrame)) {
            if (!IsFrameDefined())  // can't override in a sitemap file
                SetFrameName(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtParamWindow)) {
            if (!IsWindowDefined())
                SetWindowName(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtImageType)) {
            if (isSameString(*pcparse, txtFolderType))
                m_fFolderImages = TRUE;
        }
        else if (isSameString(pszParamType, txtImageList)) {
            m_pszImageList = StrDup(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtQueryType)) {
            m_fPromotForInfoTypes = TRUE;
            return TRUE;
        }
        else if (isSameString(pszParamType, txtBackGround)) {
            m_clrBackground = Atoi(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtBackGroundImage)) {
            m_pszBackBitmap = StrDup(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtForeGround)) {
            m_clrForeground = Atoi(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtFont)) {
            m_pszFont = StrDup(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtNumberImages)) {
            m_cImages = Atoi(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtColorMask)) {
            m_clrMask = Atoi(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtImageWidth)) {
            m_cImageWidth = Atoi(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtWindowStyles) &&
                m_tvStyles == (DWORD) -1) {
            m_tvStyles = Atoi(*pcparse);
            return TRUE;
        }
        else if (isSameString(pszParamType, txtExWindowStyles)) {
            m_exStyles = Atoi(*pcparse);
            return TRUE;
        }
#if (!defined(HHCTRL) && !defined(HHA))
        else if (isSameString(pszParamType, txtAutoGenerated)) {
            m_fAutoGenerated = YesNo(*pcparse);
            return TRUE;
        }
#endif

        return FALSE;
    }

    if (m_fIndex) {
        if (isSameString(pszParamType, txtParamSectionTitle) ||
                isSameString(pszParamType, txtParamName)) {
            if (!pcparse->pszText)
                pcparse->pszText = StrDup(*pcparse);
            else {
                if (pcparse->m_pSiteUrl->m_pUrl->pszTitle) {
                    if (pcparse->m_pSiteUrl->m_fUrlSpecified)
                        pcparse->SaveUrlEntry();
                    else
                        FreeMemory(pcparse->pszText, -1);
                }
                pcparse->AddTitle(*pcparse);
            }
            return TRUE;
        }
        else if (isSameString(pszParamType, txtParamKeyword)) {
            // BUGBUG: check for duplicates first!
            pcparse->pszText = StrDup(*pcparse);
            return TRUE;
        }
    }
    else {  // not an Index
        if (isSameString(pszParamType, txtParamName)) {
            if (pcparse->m_pSiteUrl->m_fUrlSpecified)
                pcparse->SaveUrlEntry();
            // BUGBUG: deal with duplicate names being specified
            pcparse->pszText = StrDup(*pcparse);
            return TRUE;
        }
    }

    if (isSameString(pszParamType, txtParamLocal)) {
        if (pcparse->m_pSiteUrl->m_fUrlSpecified) {
            // save previous URL entry
            pcparse->SaveUrlEntry();
        }
        URL url = AddUrl(*pcparse);
        if (pcparse->m_pSiteUrl->m_pUrl->urlSecondary == url)
            return TRUE;    // ignore duplicate URLs for primary and secondary
        pcparse->m_pSiteUrl->m_pUrl->urlPrimary = url;
        pcparse->m_pSiteUrl->m_fUrlSpecified = TRUE;
        return TRUE;
    }
    else if (isSameString(pszParamType, txtParamUrl) || isSameString(pszParamType, txtParamSecondary)) {
        if (pcparse->m_pSiteUrl->m_fUrlSpecified && pcparse->m_pSiteUrl->m_pUrl->urlSecondary) {
            // save previous URL entry
            pcparse->SaveUrlEntry();
        }
        URL url = AddUrl(*pcparse);
        if (pcparse->m_pSiteUrl->m_pUrl->urlPrimary == url)
            return TRUE;    // ignore duplicate URLs for primary and secondary
        pcparse->m_pSiteUrl->m_pUrl->urlSecondary = url;
        pcparse->m_pSiteUrl->m_fUrlSpecified = TRUE;
        return TRUE;
    }
    else if (isSameString(pszParamType, txtParamType) ||
            isSameString(pszParamType, txtParamTypeExclusive) ||
            isSameString(pszParamType, txtParamTypeHidden)) {
        if (pcparse->m_pSiteUrl->m_fUrlSpecified)
            // save previous URL entry
            pcparse->SaveUrlEntry();

        if (m_itTables.m_ptblInfoTypes)
        {
            INFOTYPE iType = GetInfoType(*pcparse);
            if (iType == (INFOTYPE) -1)
                iType = 0;
            else
                AddIT(iType, pcparse->m_pSiteUrl->m_pUrl->ainfoTypes );
        }

        return TRUE;
    }
    else if (isSameString(pszParamType, txtParamNew)) {
        pcparse->fNew = TRUE;
        return TRUE;
    }
    else if (isSameString(pszParamType, txtParamImageNumber)) {
        pcparse->iImage = (BYTE) Atoi(*pcparse);
        return TRUE;
    }
    else if (isSameString(pszParamType, txtParamDisplay)) {
        if (isSameString(*pcparse, txtNo))
            pcparse->fNoDisplay = TRUE;
        return TRUE;
    }
    else if (isSameString(pszParamType, txtParamFrame)) {
        SetEntryFrame(pcparse, *pcparse);
        return TRUE;
    }
    else if (isSameString(pszParamType, txtParamWindow)) {
        SetEntryWindow(pcparse, *pcparse);
        return TRUE;
    }
    else if (isSameString(pszParamType, txtSeeAlso)) {
        pcparse->m_pSiteUrl->m_pUrl->urlPrimary = AddUrl(*pcparse);
        pcparse->fSeeAlso = TRUE;
        pcparse->m_pSiteUrl->m_fUrlSpecified = TRUE;
        return TRUE;
    }
    else if (isSameString(pszParamType, txtSendEvent)) {
        pcparse->m_pSiteUrl->m_pUrl->urlPrimary = AddUrl(*pcparse);
        pcparse->SaveUrlEntry();
        pcparse->fSendEvent = TRUE;
        return TRUE;
    }
    else if (isSameString(pszParamType, txtSendMessage)) {
        pcparse->m_pSiteUrl->m_pUrl->urlPrimary = AddUrl(*pcparse);
        pcparse->SaveUrlEntry();
        pcparse->fSendMessage = TRUE;
        return TRUE;
    }
#if (!defined(HHCTRL) && !defined(HHA))
    else if (isSameString(pszParamType, txtParamComment)) {
        pcparse->pszComment = StrDup(*pcparse);
        return TRUE;
    }
#endif

    return FALSE;
}

URL CSiteMap::AddUrl(PCSTR pszUrl)
{
    if (IsEmptyString(pszUrl))
        return NULL;

#if (defined(HHCTRL) || defined(HHA))
    if (!IsEmptyString(m_pszBase) && !StrChr(pszUrl, ':')) {
        char szPath[INTERNET_MAX_URL_LENGTH];
        strcpy(szPath, m_pszBase);
        strcat(szPath, pszUrl);
        return (URL) StrDup(szPath);
    }
#endif

    PCSTR psz = FirstNonSpace(pszUrl);
    return (URL) StrDup(psz?psz:"");
}

void CSiteMap::AddToCategory( int iLastType )
{
        // Add the info type to the last category defined; if there is a Category
    if ( m_itTables.m_ptblCategories )
    {
        int posCat = m_itTables.m_ptblCategories->CountStrings();
        if (posCat <= 0 )
            return;
        AddITtoCategory( posCat-1, iLastType);
    }
}


int CompareSz(PCSTR psz, PCSTR pszSub)
{
    int cb;

    if (IsSamePrefix(psz, pszSub, cb = (int)strlen(pszSub)))
        return cb;
    else
        return 0;
}

void CParseSitemap::AddTitle(PCSTR psz)
{
    if (m_pSiteUrl->m_pUrl->pszTitle)
        m_pSiteMap->FreeMemory(m_pSiteUrl->m_pUrl->pszTitle, -1);
    m_pSiteUrl->m_pUrl->pszTitle = m_pSiteMap->StrDup(psz);
}

void CSiteEntryUrl::SaveUrlEntry(CSiteMap* pSiteMap, SITEMAP_ENTRY* pSiteMapEntry)
{
    SITE_ENTRY_URL* pNewUrls = (SITE_ENTRY_URL*) pSiteMap->TableMalloc(
        sizeof(SITE_ENTRY_URL) * (pSiteMapEntry->cUrls + 1));
    if (pSiteMapEntry->cUrls) {
        ASSERT(pSiteMapEntry->pUrls);
        memcpy(pNewUrls, pSiteMapEntry->pUrls,
            sizeof(SITE_ENTRY_URL) * pSiteMapEntry->cUrls);
        pSiteMap->FreeMemory((PCSTR) pSiteMapEntry->pUrls,
            sizeof(SITE_ENTRY_URL) * pSiteMapEntry->cUrls);
    }
    memcpy((PBYTE) pNewUrls + sizeof(SITE_ENTRY_URL) * pSiteMapEntry->cUrls,
        m_pUrl, sizeof(SITE_ENTRY_URL));
    pSiteMapEntry->cUrls++;
    pSiteMapEntry->pUrls = pNewUrls;
    if (!pSiteMap->AreAnyInfoTypesDefined(pSiteMapEntry))
        pSiteMapEntry->fShowToEveryOne = TRUE;

    ZeroMemory(m_pUrl, sizeof(SITE_ENTRY_URL));
    m_pUrl->ainfoTypes = (INFOTYPE*)lcCalloc( pSiteMap->InfoTypeSize() );
    m_fUrlSpecified = FALSE;
}

/***************************************************************************

    FUNCTION:   HashFromSz

    PURPOSE:    Convert a string into a hash representation

    PARAMETERS:
        pszKey

    RETURNS:    Hash number

    COMMENTS:
        Shamelessly stolen from the WinHelp code, since after 6 years
        of use by up to 1 million help authors, there were no reports
        of collisions.

    MODIFICATION DATES:
        10-Aug-1996 [ralphw] Stolen from WinHelp, removed special-case
        hash characters

***************************************************************************/

// This constant defines the alphabet size for our hash function.

static const HASH MAX_CHARS = 43;

HASH WINAPI HashFromSz(PCSTR pszKey)
{
    HASH  hash = 0;

    int cch = (int)strlen(pszKey);

    for (int ich = 0; ich < cch; ++ich) {

        // treat '/' and '\' as the same

        if (pszKey[ich] == '/')
            hash = (hash * MAX_CHARS) + ('\\' - '0');
        else if (pszKey[ich] <= 'Z')
            hash = (hash * MAX_CHARS) + (pszKey[ich] - '0');
        else
            hash = (hash * MAX_CHARS) + (pszKey[ich] - '0' - ('a' - 'A'));
    }

    /*
     * Since the value 0 is reserved as a nil value, if any context
     * string actually hashes to this value, we just move it.
     */

    return (hash == 0 ? 0 + 1 : hash);
}

int CSiteMap::AddName(PCSTR psz)
{
    if (IsEmptyString(psz))
        return 0;
    psz = FirstNonSpace(psz);
    HASH hash = HashFromSz(psz);
    if (!m_ptblStrings)
        m_ptblStrings = new CTable(16 * 1024);
    int pos = m_ptblStrings->IsHashInTable(hash);
    if (pos > 0)
        return pos;
    else {
        m_ptblStrings->AddString(hash, psz);
        return m_ptblStrings->CountStrings();
    }
}

PSTR FindCharacter(CAInput* pinput, CStr* pcsz, PSTR psz, char ch)
{
    for(;;) {
        psz = StrChr(psz, ch);
        if (!psz) {
            if (!pinput)
                return NULL;
            if (!pinput->getline(pcsz))
                return NULL;
            psz = pcsz->psz;
        }
        else
            break;
    }
    return FirstNonSpace(psz + 1);
}

PSTR FindDblQuote(CAInput* pinput, CStr* pcsz, PSTR psz)
{
    for(;;) {
        psz = StrChr(psz, '\042');
        if (!psz) {
            if (!pinput->getline(pcsz))
                return NULL;
            psz = pcsz->psz;
        }
        else
            break;
    }
    return FirstNonSpace(psz + 1);
}

/***************************************************************************

    FUNCTION:   GetValue

    PURPOSE:    Copy the value of a param type into pszValue, and return
                a pointer to the first character after the closing angle
                bracket

    PARAMETERS:
        pinput     pointer to current CInput file
        pcsz       CStr to read new line into
        psz        position in current line
        pcszValue  CStr to receive value
        pszPrefix  prefix to look for

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        24-Aug-1996 [ralphw]

***************************************************************************/

PSTR GetValue(CAInput* pinput, CStr* pcsz, PSTR psz, CStr* pcszValue)
{
    // Skip past ending quote of parameter type
    psz = FindDblQuote(pinput, pcsz, psz);
    if (!psz)
        return NULL;

    if (!isSameString(psz, txtValue)) {
        psz = stristr(psz, txtValue);
        if (!psz) {
            if (!pinput->getline(pcsz))
                return NULL;
            psz = stristr(pcsz->psz, txtValue);
            if (!psz)
                return NULL;
        }
    }

    // Now find opening quote of the value
    psz = FindDblQuote(pinput, pcsz, psz);
    if (!psz)
        return NULL;

    if (!pcszValue->psz)
        pcszValue->psz = (PSTR) lcMalloc(256);
    PSTR pszDst = pcszValue->psz;
    PSTR pszEnd = pszDst + lcSize(pcszValue->psz);

    while (*psz != '\042') {
        if (!*psz) {
            if (!pinput->getline(pcsz))
                return NULL;
            psz = pcsz->psz;
            continue;
        }
        *pszDst++ = *psz++;
        if (pszDst >= pszEnd) {

            /*
             * Our destination buffer is too small, so increase it by
             * 128 bytes.
             */

            int offset = (int)(pszDst - pcszValue->psz);
            pcszValue->ReSize((int)(pszEnd - pcszValue->psz) + 128);
            pszDst = pcszValue->psz + offset;
            pszEnd = pcszValue->psz + pcszValue->SizeAlloc();
            lcHeapCheck();
        }
    }
    *pszDst = '\0';
    return FindCharacter(pinput, pcsz, psz, '>');
}

PSTR GetType(CAInput* pinput, CStr* pcsz, PSTR psz, CStr* pcszValue)
{
    psz = FirstNonSpace(psz);
    ASSERT(strlen(txtType) == sizeof(txtType) - 1); // make sure the compiler doesn't mess this up
    if (IsSamePrefix(psz, txtType, sizeof(txtType) - 1)) {
        psz = stristr(psz, txtType);
        if (!psz) {
            if (!pinput->getline(pcsz))
                return NULL;
            psz = stristr(pcsz->psz, txtType);
            if (!psz)
                return NULL;
        }
    }

    // Now find opening quote of the value
    psz = FindDblQuote(pinput, pcsz, psz);
    if (!psz)
        return NULL;

    if (!pcszValue->psz)
        pcszValue->psz = (PSTR) lcMalloc(256);
    PSTR pszDst = *pcszValue;
    PSTR pszEnd = pszDst + lcSize(pszDst);

    while (*psz != '\042') {
        if (!*psz) {
            if (!pinput->getline(pcsz))
                return NULL;
            psz = pcsz->psz;
            continue;
        }
        *pszDst++ = *psz++;
        if (pszDst >= pszEnd) {

            /*
             * Our input buffer is too small, so increase it by
             * 128 bytes.
             */

            int offset = (int)(pszDst - pcsz->psz);
            pcsz->ReSize((int)(pszEnd - pcsz->psz) + 128);
            pszDst = pcsz->psz + offset;
            pszEnd = pcsz->psz + pcsz->SizeAlloc();
            lcHeapCheck();
        }
    }
    *pszDst = '\0';
    return FindCharacter(pinput, pcsz, psz, '>');
}


    // This is called from the code that parses the sitemap in the information type section.
    // Information types found outside of the declaration section are NOT added to the
    // information types declared.  So we don't have to worry about increasing the size of
    // SITE_ENTRY_URLs after they have been defined.  At least in this routine.  We will have to
    // deal with increasing the size of SITE_ENTRY_URLs when adding information types.

int CSiteMap::AddTypeName(PCSTR pszTypeName)
{
    ASSERT(!IsEmptyString(pszTypeName));

    if (!m_itTables.m_ptblInfoTypes) {
        m_itTables.m_ptblInfoTypes = new CTable(16 * 1024);
        ASSERT(!m_itTables.m_ptblInfoTypeDescriptions);
        m_itTables.m_ptblInfoTypeDescriptions = new CTable(64 * 1024);
    }
    ASSERT(m_itTables.m_ptblInfoTypes);

    /*
     * If we have an Information type, but the table counts don't match,
     * then we didn't get a description for the last type, so we add a blank
     * description to keep the tables in sync.
     */

    while (m_itTables.m_ptblInfoTypes->CountStrings() > m_itTables.m_ptblInfoTypeDescriptions->CountStrings())
        m_itTables.m_ptblInfoTypeDescriptions->AddString("");

    /*
      A category and type is specified as:
            category::type name
    */

    CStr cszCategory;
    CStr cszType;
    int  category = 0;
    PCSTR pszCat = strstr(pszTypeName, "::");
    if (pszCat) {   // separate category name from type name
        cszType = pszCat + 2;  // make a local copy
        cszCategory = pszTypeName;
        cszCategory.psz[pszCat - pszTypeName] = '\0';
        if (!m_itTables.m_ptblCategories) {
            m_itTables.m_ptblCategories = new CTable(16 * 1024);
        }
        category = m_itTables.m_ptblCategories->IsStringInTable(cszCategory);
        if (!category)
            category = m_itTables.m_ptblCategories->AddString(cszCategory);
        pszTypeName = cszType.psz;
    }

    int pos = m_itTables.m_ptblInfoTypes->IsStringInTable(pszTypeName);
    if (pos <= 0) {
        if ( (m_itTables.m_cTypes > 0) && ((m_itTables.m_cTypes+1) % 32 == 0)  )
            ReSizeIT();  // increase by one DWORD
        pos = m_itTables.m_ptblInfoTypes->AddString(pszTypeName);
        m_itTables.m_cTypes++;
        int offset = 0;
        int type = pos;
        while (type > 32) {
            offset++;
            type -= 32;
        }
        INFOTYPE* pInfoType = m_pInfoTypes + offset;
        *pInfoType |= (1 << type);
    }

    category--; // zero offset
    if ( category >=0 )
        AddITtoCategory(category, pos );

#if 0
    /*
     * If we have more then 32 information types, then we need to be certain
     * the size of the SITE_ENTRY_URL* structure allocated for Sitemap Entries
     * is large enough.
     */
    // BUGBUG: we need to deal with the situation where an information type
    // gets specified AFTER a sitemap entry has been specified.

    if (pos > m_pSiteUrl->m_cMaxTypes) {
        m_cUrlEntry = sizeof(SITE_ENTRY_URL) + pos / sizeof(UINT);
        m_pSiteUrl->m_pUrl = (SITE_ENTRY_URL*) lcReAlloc(m_pSiteUrl->m_pUrl, m_cUrlEntry);
        m_pSiteUrl->m_cMaxTypes += 32;
        m_cInfoTypeOffsets++;

    }
    if ( pos % 32 == 0 )
    {
    // Increase the Categories
        for(int i=0; i<m_itTables.m_max_categories; i++)
            m_itTables.m_aCategories[i].pInfoType = (INFOTYPE*)lcReAlloc(m_itTables.m_aCategories[i].pInfoType,
                                        InfoTypeSize());

    // Increase the Exclusive and Hidden IT fields.
        m_itTables.m_pExclusive = (INFOTYPE*) lcReAlloc(m_itTables.m_pExclusive,
                                InfoTypeSize() );
        m_itTables.m_pHidden = (INFOTYPE*) lcReAlloc(m_itTables.m_pHidden,
                                InfoTypeSize() );
    }
#endif

    return pos;
}

BOOL CSiteMap::AreAnyInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry)
{
    INFOTYPE *pIT;
    SITE_ENTRY_URL* pUrl = pSiteMapEntry->pUrls;

    for (int iUrl = 0; iUrl < pSiteMapEntry->cUrls; iUrl++)
    {
        pIT = pUrl->ainfoTypes;
        for (int i=0; i < InfoTypeSize()/4; i++)
        {
            if (*pIT)
                return TRUE;    // an info type was found
            else
                pIT++;
        }
        pUrl = NextUrlEntry(pUrl);
    }
    return FALSE;
}

/***************************************************************************

    FUNCTION:   CSiteMap::AreTheseInfoTypesDefined

    PURPOSE:    Find out if the specified INFOTYPES are defined

    PARAMETERS:
        pSiteMapEntry
        types   -- bit flag mask
        offset  -- offset into ainfoTypes

    RETURNS:
        A pointer to the first SITE_ENTRY_URL structure containing at
        least one of the requested information types.

    COMMENTS:
        32 Information Types may be checked on each call. This will check
        every URL defined for the current Sitemap entry, and return
        TRUE if there is any match.

        If you needed to find out if information type number 33 was
        defined, you would call this with types set to 1, and offset to 1
        (offset determines which set of 32 information types to look at).

    MODIFICATION DATES:
        25-Jan-1997 [ralphw]

***************************************************************************/

SITE_ENTRY_URL* CSiteMap::AreTheseInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry,
    INFOTYPE types, int offset) const
{
    ASSERT((UINT) offset <= m_itTables.m_cTypes / sizeof(INFOTYPE));

    SITE_ENTRY_URL* pUrl = pSiteMapEntry->pUrls;
    if (!pUrl)
        return NULL;
    for (int iUrl = 0; iUrl < pSiteMapEntry->cUrls; iUrl++)
    {
        if ( *(pUrl->ainfoTypes+offset) & types )
            return pUrl;
        pUrl = NextUrlEntry(pUrl);
    }
    return NULL;
}

// This includes all memory for URL names and sitemap entries

const int MAX_POINTERS = (1024 * 1024);         // 1 meg, 262,144 strings
const int MAX_STRINGS  = (25 * 1024 * 1024) - 4096L;   // 25 megs

CSiteMap::CSiteMap(int cMaxEntries) : CTable((cMaxEntries ? (cMaxEntries * 256)  : MAX_STRINGS))
{
    // Can't clear memory, because of our base class

    m_fTypeCopy = FALSE;
    m_fSaveIT = TRUE;
    m_pszSitemapFile = NULL;
    m_pTypicalInfoTypes = NULL;
    m_fIndex = FALSE;
    m_pszBase = NULL;
    m_pszImageList = NULL;
    m_cImages = 0;
    m_pszFont = NULL;
    m_fFolderImages = FALSE;
    m_fPromotForInfoTypes = FALSE;
    m_pszBackBitmap = NULL;
    m_fAutoGenerated = FALSE;
    m_ptblStrings = NULL;
    m_pszFrameName = NULL;
    m_pszWindowName = NULL;
    m_pszHHIFile = NULL;
    ZeroMemory(&m_itTables, sizeof(INFOTYPE_TABLES));

    m_itTables.m_max_categories = MAX_CATEGORIES;
    m_itTables.m_aCategories = (CATEGORY_TYPE*) lcMalloc(MAX_CATEGORIES*sizeof(CATEGORY_TYPE) );
    m_itTables.m_cTypes = 0;
    m_itTables.m_cITSize = 1;   // Initially allocate one DWORD to hold info type bits
    for(int i=0; i< MAX_CATEGORIES; i++)
    {
        m_itTables.m_aCategories[i].pInfoType = (INFOTYPE*)lcCalloc( sizeof(INFOTYPE) );
        memset(m_itTables.m_aCategories[i].pInfoType, '\0', InfoTypeSize() );
        m_itTables.m_aCategories[i].c_Types = 0;
    }

    m_itTables.m_pExclusive = (INFOTYPE*)lcCalloc( sizeof(INFOTYPE ) );
    m_itTables.m_pHidden = (INFOTYPE*)lcCalloc( sizeof(INFOTYPE) );

    m_clrBackground = (COLORREF) -1;
    m_clrForeground = (COLORREF) -1;
    m_exStyles = (DWORD) -1;
    m_tvStyles = (DWORD) -1;
    m_clrMask = 0xFFFFFF;
    m_cImageWidth = 20;

    m_pInfoTypes = (INFOTYPE*) lcCalloc(sizeof(INFOTYPE) );
    m_pTypicalInfoTypes = (INFOTYPE*) lcCalloc( sizeof(INFOTYPE) );

    // By default, select all information types

    memset(m_pInfoTypes, 0xFF, sizeof(INFOTYPE) );

#ifdef HHCTRL
#ifndef HHA
    m_CodePage = (UINT)-1;
#endif
#endif
}



CSiteMap::~CSiteMap()
{
    for (int pos = 1; pos < endpos - 1; pos++)
    {
       SITEMAP_ENTRY* pSiteMapEntry = GetSiteMapEntry(pos);
       if ( pSiteMapEntry && pSiteMapEntry->pUrls && pSiteMapEntry->pUrls->ainfoTypes )
          lcFree(pSiteMapEntry->pUrls->ainfoTypes);
    }

    if (m_ptblStrings)
        delete m_ptblStrings;

    if (!m_fTypeCopy) {
        if (m_itTables.m_ptblInfoTypes)
            delete m_itTables.m_ptblInfoTypes;
        if (m_itTables.m_ptblInfoTypeDescriptions)
            delete m_itTables.m_ptblInfoTypeDescriptions;
        if (m_itTables.m_ptblCategories)
            delete m_itTables.m_ptblCategories;
        if (m_itTables.m_ptblCatDescription)
            delete m_itTables.m_ptblCatDescription;
    }
    for (int i=0; i< m_itTables.m_max_categories; i++)
        lcFree( m_itTables.m_aCategories[i].pInfoType);
    lcFree (m_itTables.m_aCategories);
    lcFree (m_itTables.m_pHidden);
    lcFree (m_itTables.m_pExclusive);
    lcFree (m_pInfoTypes);
    lcFree (m_pTypicalInfoTypes);

}

void CSiteMap::ReSizeURLIT(int Size)
{
    int oldSize = InfoTypeSize();

    if ( Size == 0 )
        m_itTables.m_cITSize++;
    else
        m_itTables.m_cITSize= Size;

    //Increase each sitemap entry URL infotype
    int cEntries = Count();
    INFOTYPE *pIT;
    for (int i=1; i<=cEntries; i++)
    {
        SITEMAP_ENTRY *pSE = GetSiteMapEntry(i);
        SITE_ENTRY_URL *pSEURL = pSE->pUrls;
        for(int j=0; j<pSE->cUrls; j++)
        {
            pSEURL = pSEURL+j;
            pIT = (INFOTYPE*) lcCalloc( InfoTypeSize() );
            memcpy(pIT, pSEURL->ainfoTypes, oldSize);
            lcFree( pSEURL->ainfoTypes );
            pSEURL->ainfoTypes = pIT;
        }
    }

    SizeIT( oldSize );
}


void CSiteMap::ReSizeIT(int Size)
{
    int oldSize = InfoTypeSize();

    if ( Size == 0 )
        m_itTables.m_cITSize++;     // increase by one
    else
        m_itTables.m_cITSize = Size;

    SizeIT(oldSize);

}

void CSiteMap::SizeIT(int oldSize)
{
        // Increase each category
    INFOTYPE * pIT;
    for(int i=0; i<m_itTables.m_max_categories; i++)
    {
        pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
        memcpy(pIT, m_itTables.m_aCategories[i].pInfoType, oldSize);
        lcFree(m_itTables.m_aCategories[i].pInfoType);
        m_itTables.m_aCategories[i].pInfoType = pIT;
    }

    pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_itTables.m_pExclusive, oldSize);
    lcFree(m_itTables.m_pExclusive);
    m_itTables.m_pExclusive = pIT;

        pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_itTables.m_pHidden, oldSize);
    lcFree(m_itTables.m_pHidden);
    m_itTables.m_pHidden = pIT;

    pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_pInfoTypes, oldSize);
    lcFree(m_pInfoTypes);
    m_pInfoTypes = pIT;

    pIT = (INFOTYPE *) lcCalloc( InfoTypeSize() );
    memcpy(pIT, m_pTypicalInfoTypes, oldSize);
    lcFree(m_pTypicalInfoTypes);
    m_pTypicalInfoTypes = pIT;
}

void CSiteMap::CopyCat(INFOTYPE_TABLES *Dst_itTables, const INFOTYPE_TABLES * Src_itTables)
{
        // copy the categories table
    Dst_itTables->m_max_categories = Src_itTables->m_max_categories;
    if ( Dst_itTables->m_max_categories > MAX_CATEGORIES )
        Dst_itTables->m_aCategories = (CATEGORY_TYPE *)lcReAlloc(Dst_itTables->m_aCategories,
                                        Dst_itTables->m_max_categories * sizeof(CATEGORY_TYPE) );
    for(int i=0; i<Dst_itTables->m_max_categories; i++)
    {
        if ( Dst_itTables->m_aCategories[i].pInfoType )
            lcFree(Dst_itTables->m_aCategories[i].pInfoType);
        Dst_itTables->m_aCategories[i].pInfoType = (INFOTYPE*) lcCalloc( InfoTypeSize());
        if ( Src_itTables->m_aCategories[i].c_Types > 0 )
        {
            memcpy(Dst_itTables->m_aCategories[i].pInfoType,
                   Src_itTables->m_aCategories[i].pInfoType,
                   InfoTypeSize() );
            Dst_itTables->m_aCategories[i].c_Types = Src_itTables->m_aCategories[i].c_Types;
        }
        else
        {
            Dst_itTables->m_aCategories[i].c_Types = 0;
        }
    }
}

    // Check all the categories to see if this type is a member of any of them, return TRUE on first occurrence
BOOL CSiteMap::IsInACategory( int type ) const
{
    for (int i=0; i<HowManyCategories(); i++ )
    {
        int offset;
        INFOTYPE *pIT;
        offset = type / 32;
        ASSERT ( m_itTables.m_aCategories[i].pInfoType );
        pIT = m_itTables.m_aCategories[i].pInfoType + offset;
        if ( *pIT & (1<<(type-(offset*32))) )
            return TRUE;
    }
return FALSE;
}



int CSiteMap::GetInfoType(PCSTR pszTypeName)
{
int type;
CStr cszCat = pszTypeName;
    ASSERT(!IsEmptyString(pszTypeName));

    /*
      A category and type is specified as:
            category::type name
    */

    PSTR pszCat = strstr(cszCat.psz, "::");
    if ( !pszCat )
    {
        pszCat = StrChr(cszCat.psz, ':');
        if (pszCat != NULL)
        {
            *pszCat = '\0';
            pszCat++;   // step over the :
        }
    }
    else
    {
        *pszCat = '\0';
        pszCat+=2; // step over the ::
    }

    if ( pszCat == NULL )
        return GetITIndex(pszTypeName); // there is not category.
    else
    {
        int cat = GetCatPosition(  cszCat.psz );
        if (cat <= 0)
            return -1;
        type = GetFirstCategoryType( cat-1 );
        while( type != -1 )
        {
            if ( strcmp( pszCat, GetInfoTypeName(type) ) == 0 )
                return type;
            type = GetNextITinCategory();

        }
    }
    return -1;
}



// Reads the user's current favorites to create nodes

void CSiteMap::CreateFavorites(int level)
{
    HRESULT hr;
    LPITEMIDLIST pidl;
    char szFavoritesPath[MAX_PATH];

    hr = SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidl);
    if (SUCCEEDED(hr)) {
        BOOL fResult = SHGetPathFromIDList(pidl, szFavoritesPath);
        // SHFree(pidl); // BUGBUG: this function doesn't exist!!!
        if (!fResult)
            return; // BUGBUG: nag the author
    }
    else
        return; // BUGBUG: nag the author

    AddTrailingBackslash(szFavoritesPath);
    CStr cszSearch(szFavoritesPath);
    cszSearch += "*.*";

    CTable tblFolders;
    CTable tblFiles;

    WIN32_FIND_DATA wfd;
    HANDLE hFind = FindFirstFile(cszSearch, &wfd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (wfd.cFileName[0] != '.')    // ignore . and ..
                    tblFolders.AddString(wfd.cFileName);
            }
            else
                tblFiles.AddString(wfd.cFileName);
        } while (FindNextFile(hFind, &wfd));
        FindClose(hFind);
    }

    // Did we get at least one entry?

    if (tblFolders.CountStrings() || tblFiles.CountStrings()) {
        SITEMAP_ENTRY SiteMapEntry;
        ZERO_STRUCTURE(SiteMapEntry);

        // Add the top level book called Favorites

        SiteMapEntry.level = level++;
        SiteMapEntry.pszText = StrDup(GetStringResource(IDS_BROWSER_FAVORITES));
        AddEntry(&SiteMapEntry);

        tblFolders.SortTablei();    // BUGBUG: set lcide first
        for (int pos = 1; pos <= tblFolders.CountStrings(); pos++)
            AddFavoriteNodes(szFavoritesPath, tblFolders.GetPointer(pos), level);

        tblFiles.SortTablei();      // BUGBUG: set lcid first

        for (pos = 1; pos <= tblFiles.CountStrings(); pos++) {
            char szUrl[MAX_PATH * 4];
            char szPath[MAX_PATH];

            strcpy(szPath, szFavoritesPath);
            AddTrailingBackslash(szPath);
            strcat(szPath, tblFiles.GetPointer(pos));
            if (GetPrivateProfileString("InternetShortcut", "URL", "",
                    szUrl, sizeof(szUrl), szPath) > 0 && szUrl[0]) {
                CStr cszName(tblFiles.GetPointer(pos));
                PSTR pszExtension = StrRChr(cszName, '.');
                if (pszExtension) {
                    *pszExtension = '\0';
                    SiteMapEntry.level = (BYTE)level;
                    SiteMapEntry.pszText = StrDup(cszName);
                    CSiteEntryUrl curl( InfoTypeSize() );
                    curl.m_pUrl->urlPrimary = AddUrl(szUrl);
                    SiteMapEntry.pUrls = curl.m_pUrl;
                    SiteMapEntry.SetTopic(TRUE);
                    AddEntry(&SiteMapEntry);
                }
            }
        }
    }
}

void CSiteMap::AddFavoriteNodes(PCSTR pszRoot, PCSTR pszNewFolder, int level)
{
    CTable tblFolders;
    CTable tblFiles;

    char szPath[MAX_PATH];
    strcpy(szPath, pszRoot);
    AddTrailingBackslash(szPath);
    strcat(szPath, pszNewFolder);
    CStr cszRoot(szPath);   // save in case we need to recurse
    AddTrailingBackslash(szPath);
    strcat(szPath, "*.*");

    WIN32_FIND_DATA wfd;
    HANDLE hFind = FindFirstFile(szPath, &wfd);
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                if (wfd.cFileName[0] != '.')    // ignore . and ..
                    tblFolders.AddString(wfd.cFileName);
            }
            else
                tblFiles.AddString(wfd.cFileName);
        } while (FindNextFile(hFind, &wfd));
        FindClose(hFind);
    }

    // Did we get at least one entry?

    if (tblFolders.CountStrings() || tblFiles.CountStrings()) {
        SITEMAP_ENTRY SiteMapEntry;
        ZERO_STRUCTURE(SiteMapEntry);

        SiteMapEntry.level = level++;
        SiteMapEntry.pszText = StrDup(pszNewFolder);
        AddEntry(&SiteMapEntry);

        tblFolders.SortTablei();    // BUGBUG: set lcid first

        // Handle all nested folders

        for (int pos = 1; pos <= tblFolders.CountStrings(); pos++)
            AddFavoriteNodes(cszRoot, tblFolders.GetPointer(pos), level);

        tblFiles.SortTablei();      // BUGBUG: set lcide first

        for (pos = 1; pos <= tblFiles.CountStrings(); pos++) {
            char szUrl[MAX_PATH * 4];
            strcpy(szPath, cszRoot);
            AddTrailingBackslash(szPath);
            strcat(szPath, tblFiles.GetPointer(pos));
            if (GetPrivateProfileString("InternetShortcut", "URL", "",
                    szUrl, sizeof(szUrl), szPath) > 0 && szUrl[0]) {
                CStr cszName(tblFiles.GetPointer(pos));
                PSTR pszExtension = StrRChr(cszName, '.');
                if (pszExtension) {
                    *pszExtension = '\0';
                    SiteMapEntry.level = (BYTE)level;
                    SiteMapEntry.pszText = StrDup(cszName);
                    CSiteEntryUrl curl( InfoTypeSize() );
                    curl.m_pUrl->urlPrimary = AddUrl(szUrl);
                    SiteMapEntry.pUrls = curl.m_pUrl;
                    SiteMapEntry.SetTopic(TRUE);
                    AddEntry(&SiteMapEntry);
                }
            }
        }
    }
}

int CSiteMap::GetImageNumber(SITEMAP_ENTRY* pSiteMapEntry) const
{
    int image = pSiteMapEntry->GetImageIndex();
    if (image == 0) {
        if (pSiteMapEntry->IsTopic()) {
            image = pSiteMapEntry->fNew ?
                IMAGE_HELP_TOPIC_NEW : IMAGE_HELP_TOPIC;
            if (m_fFolderImages)
                image+= 2;  // switch to standard topic images
        }
        else {
            image = pSiteMapEntry->fNew ? IMAGE_OPEN_BOOK_NEW : IMAGE_OPEN_BOOK;

            if (m_fFolderImages)
                image += 4; // switch to standard books
        }
    }
    if (m_cImages && image > m_cImages) {

        // BUGBUG: if this really happens, nag the author

        image = IMAGE_CLOSED_BOOK;
    }
    return image;
}


BOOL CSiteMap::IsEntryInCurTypeList(SITEMAP_ENTRY* pSiteMapEntry) const
{
    int cTypes = m_itTables.m_ptblInfoTypes->CountStrings();
    if (cTypes < 32) {
        return AreTheseInfoTypesDefined(pSiteMapEntry, m_pInfoTypes[0], 0) != NULL;
    }
    else {
        for (int i = 0; cTypes > 32; i++) {
            if (AreTheseInfoTypesDefined(pSiteMapEntry, m_pInfoTypes[i], i))
                return TRUE;
            cTypes -= 32;
        }
        return AreTheseInfoTypesDefined(pSiteMapEntry, m_pInfoTypes[i], i) != NULL;
    }
}

typedef struct tagEntityMap
{
    PCSTR pszName;
    int ch;
} ENTITYMAP, * PENTITYMAP;

// ENTITY TABLE SWIPED FROM IE

const ENTITYMAP rgEntities[] =
{
        "AElig",        '\306',     // capital AE diphthong (ligature)
        "Aacute",       '\301',     // capital A, acute accent
        "Acirc",        '\302',     // capital A, circumflex accent
        "Agrave",       '\300',     // capital A, grave accent
        "Aring",        '\305',     // capital A, ring
        "Atilde",       '\303',     // capital A, tilde
        "Auml",         '\304',     // capital A, dieresis or umlaut mark
        "Ccedil",       '\307',     // capital C, cedilla
        "Dstrok",       '\320',     // capital Eth, Icelandic
        "ETH",          '\320',     // capital Eth, Icelandic
        "Eacute",       '\311',     // capital E, acute accent
        "Ecirc",        '\312',     // capital E, circumflex accent
        "Egrave",       '\310',     // capital E, grave accent
        "Euml",         '\313',     // capital E, dieresis or umlaut mark
        "Iacute",       '\315',     // capital I, acute accent
        "Icirc",        '\316',     // capital I, circumflex accent
        "Igrave",       '\314',     // capital I, grave accent
        "Iuml",         '\317',     // capital I, dieresis or umlaut mark
        "Ntilde",       '\321',     // capital N, tilde
        "Oacute",       '\323',     // capital O, acute accent
        "Ocirc",        '\324',     // capital O, circumflex accent
        "Ograve",       '\322',     // capital O, grave accent
        "Oslash",       '\330',     // capital O, slash
        "Otilde",       '\325',     // capital O, tilde
        "Ouml",         '\326',     // capital O, dieresis or umlaut mark
        "THORN",        '\336',     // capital THORN, Icelandic
        "Uacute",       '\332',     // capital U, acute accent
        "Ucirc",        '\333',     // capital U, circumflex accent
        "Ugrave",       '\331',     // capital U, grave accent
        "Uuml",         '\334',     // capital U, dieresis or umlaut mark
        "Yacute",       '\335',     // capital Y, acute accent
        "aacute",       '\341',     // small a, acute accent
        "acirc",        '\342',     // small a, circumflex accent
        "acute",        '\264',     // acute accent
        "aelig",        '\346',     // small ae diphthong (ligature)
        "agrave",       '\340',     // small a, grave accent
        "amp",          '\046',     // ampersand
        "aring",        '\345',     // small a, ring
        "atilde",       '\343',     // small a, tilde
        "auml",         '\344',     // small a, dieresis or umlaut mark
        "brkbar",       '\246',     // broken vertical bar
        "brvbar",       '\246',     // broken vertical bar
        "ccedil",       '\347',     // small c, cedilla
        "cedil",        '\270',     // cedilla
        "cent",         '\242',     // small c, cent
        "copy",         '\251',     // copyright symbol (proposed 2.0)
        "curren",       '\244',     // currency symbol
        "deg",          '\260',     // degree sign
        "die",          '\250',     // umlaut (dieresis)
        "divide",       '\367',     // divide sign
        "eacute",       '\351',     // small e, acute accent
        "ecirc",        '\352',     // small e, circumflex accent
        "egrave",       '\350',     // small e, grave accent
        "eth",          '\360',     // small eth, Icelandic
        "euml",         '\353',     // small e, dieresis or umlaut mark
        "frac12",       '\275',     // fraction 1/2
        "frac14",       '\274',     // fraction 1/4
        "frac34",       '\276',     // fraction 3/4*/
        "gt",           '\076',     // greater than
        "hibar",        '\257',     // macron accent
        "iacute",       '\355',     // small i, acute accent
        "icirc",        '\356',     // small i, circumflex accent
        "iexcl",        '\241',     // inverted exclamation
        "igrave",       '\354',     // small i, grave accent
        "iquest",       '\277',     // inverted question mark
        "iuml",         '\357',     // small i, dieresis or umlaut mark
        "laquo",        '\253',     // left angle quote
        "lt",           '\074',     // less than
        "macr",         '\257',     // macron accent
        "micro",        '\265',     // micro sign
        "middot",       '\267',     // middle dot
        "nbsp",         '\240',     // non-breaking space (proposed 2.0)
        "not",          '\254',     // not sign
        "ntilde",       '\361',     // small n, tilde
        "oacute",       '\363',     // small o, acute accent
        "ocirc",        '\364',     // small o, circumflex accent
        "ograve",       '\362',     // small o, grave accent
        "ordf",         '\252',     // feminine ordinal
        "ordm",         '\272',     // masculine ordinal
        "oslash",       '\370',     // small o, slash
        "otilde",       '\365',     // small o, tilde
        "ouml",         '\366',     // small o, dieresis or umlaut mark
        "para",         '\266',     // paragraph sign
        "plusmn",       '\261',     // plus minus
        "pound",        '\243',     // pound sterling
        "quot",         '"',        // double quote
        "raquo",        '\273',     // right angle quote
        "reg",          '\256',     // registered trademark (proposed 2.0)
        "sect",         '\247',     // section sign
        "shy",          '\255',     // soft hyphen (proposed 2.0)
        "sup1",         '\271',     // superscript 1
        "sup2",         '\262',     // superscript 2
        "sup3",         '\263',     // superscript 3
        "szlig",        '\337',     // small sharp s, German (sz ligature)
        "thorn",        '\376',     // small thorn, Icelandic
        "times",        '\327',     // times sign
        "trade",        '\231',     // trademark sign
        "uacute",       '\372',     // small u, acute accent
        "ucirc",        '\373',     // small u, circumflex accent
        "ugrave",       '\371',     // small u, grave accent
        "uml",          '\250',     // umlaut (dieresis)
        "uuml",         '\374',     // small u, dieresis or umlaut mark
        "yacute",       '\375',     // small y, acute accent
        "yen",          '\245',     // yen
        "yuml",         '\377',     // small y, dieresis or umlaut mark
        0, 0
};

BOOL ReplaceEscapes(PCSTR pszSrc, PSTR pszDst, int flags)
{
    if (IsEmptyString(pszSrc))
        return FALSE;

    ASSERT(pszDst);
    if ((flags & ESCAPE_URL)) {
        if (StrChr(pszSrc, '%'))
            goto CheckForEscape;
    }
    if ((flags & ESCAPE_C)) {
        if (StrChr(pszSrc, '\\'))
            goto CheckForEscape;
    }
    if ((flags & ESCAPE_ENTITY)) {
        if (StrChr(pszSrc, '&'))
            goto CheckForEscape;
    }

    // If we get here, there are no escape sequences, so copy the string and
    // return.

    if (pszDst != pszSrc)
        strcpy(pszDst, pszSrc);
    return FALSE;   // nothing changed

CheckForEscape:

#ifdef _DEBUG
    PSTR pszOrgDst = pszDst;
    int  cbSource = (int)strlen(pszSrc);
#endif

    while (*pszSrc) {
        if (IsDBCSLeadByte(*pszSrc))
        {
            if (pszSrc[1])
            {
                *pszDst++ = *pszSrc++;
                *pszDst++ = *pszSrc++;
            }
            else
            {
                // leadbyte followed by 0; invalid!
                *pszDst++ = '?';
                break;
            }
        }
        else if ((flags & ESCAPE_URL) && *pszSrc == '%')
        {
            // URL style hex digits
get_hex:
            int val;
            pszSrc++;
            if (IsDigit(*pszSrc))
                val = *pszSrc++ - '0';
            else if (*pszSrc >= 'a' && *pszSrc <= 'f')
                val = *pszSrc++ - 'a' + 10;
            else if (*pszSrc >= 'A' && *pszSrc <= 'F')
                val = *pszSrc++ - 'A' + 10;

            if (IsDigit(*pszSrc))
                val = val * 16 + *pszSrc++ - '0';
            else if (*pszSrc >= 'a' && *pszSrc <= 'f')
                val = val * 16 + *pszSrc++ - 'a' + 10;
            else if (*pszSrc >= 'A' && *pszSrc <= 'F')
                val = val * 16 + *pszSrc++ - 'A' + 10;

            if (val)
            {
                *pszDst++ = (CHAR)val;
            }
        }
        else if ((flags & ESCAPE_C) && *pszSrc == '\\')
        {
            // C style escape
            switch (*++pszSrc)
            {
                case 'n':
                    *pszDst++ = '\n';
                    pszSrc++;
                    break;

                case 'r':
                    *pszDst++ = '\r';
                    pszSrc++;
                    break;

                case 't':
                    *pszDst++ = '\t';
                    pszSrc++;
                    break;

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                    // octal digits
                    {
                        int val;
                        if (*pszSrc >= '0' && *pszSrc <= '7')
                            val = *pszSrc++ - '0';
                        if (*pszSrc >= '0' && *pszSrc <= '7')
                            val = val * 8 + *pszSrc++ - '0';
                        if (*pszSrc >= '0' && *pszSrc <= '7')
                            val = val * 8 + *pszSrc++ - '0';
                        if (val)
                            *pszDst++ = (CHAR)val;
                    }
                    break;

                case 'x':
                case 'X':
                    // hex digits
                    goto get_hex;
                    break;

                case 0:
                    break;

                default:
                    *pszDst++ = *pszSrc++;
                    break;
            }
        }
        else if ( (flags & ESCAPE_ENTITY) && *pszSrc == '&' && *(pszSrc+1) != ' ' )
        {
            pszSrc++;
            if (*pszSrc == '#')
            {
                // SGML/HTML character entity (decimal)
                pszSrc++;
                for (int val = 0; *pszSrc && *pszSrc != ';' && *pszSrc != ' '; pszSrc++)
                {
                    if (*pszSrc >= '0' && *pszSrc <= '9')
                        val = val * 10 + *pszSrc - '0';
                    else
                    {
                        while (*pszSrc && *pszSrc != ';' && *pszSrc != ' ')
                            pszSrc++;
                        break;
                    }
                }
                if( *pszSrc == ';' )
                  pszSrc++;

                if (val) {
                    *pszDst++ = (CHAR)val;
                }
            }
            else if (*pszSrc)
            {
                char szEntityName[256];
                int count = 0;
                // extra code was added below to handle the case where an & appears without
                // an entity name (which is an error in the HTML).  This avoids overunning
                // the szEntityName buffer.
                //
                for (PSTR p = szEntityName; *pszSrc && *pszSrc != ';' && *pszSrc != ' ' && count < sizeof(szEntityName);)
                {
                    *p++ = *pszSrc++;
                    count++;
                }
                *p = 0;

                if (*pszSrc == ';')
                    pszSrc++;

                for (int i = 0; rgEntities[i].pszName; i++)
                {
                    if (!strcmp(szEntityName, rgEntities[i].pszName)) {
                        if (rgEntities[i].ch) {
                            *pszDst++ = (CHAR)rgEntities[i].ch;
                        }
                        break;
                    }
                }
                if (!rgEntities[i].pszName) {
                    // illegal entity name, put in a block character
                    *pszDst++ = '?';
                }
            }
        }
        else {

            // just your usual character...

            *pszDst++ = *pszSrc++;
        }
    }

    *pszDst = 0;

    ASSERT(pszDst - pszOrgDst <= cbSource);
    return TRUE;
}

#ifndef HHCTRL
void STDCALL ConvertToEscapes(PCSTR pszSrc, CStr* pcszDst)
{
    int cbAlloc = pcszDst->SizeAlloc();
    if (!cbAlloc)
        pcszDst->ReSize(cbAlloc = (strlen(pszSrc) + 128));
    int dstPos = 0;
    if (!pszSrc) {
        *pcszDst = "";
        return;
    }
    int cbSrc = strlen(pszSrc);
    while (*pszSrc) {
        if( IsDBCSLeadByte(*pszSrc) )
        {
          pcszDst->psz[dstPos++] = *pszSrc++;
          if( pszSrc )
            pcszDst->psz[dstPos++] = *pszSrc++;
        }
        else {
          for (int i = 0; rgEntities[i].pszName; i++) {
              if (*pszSrc == rgEntities[i].ch) {
                  if ((size_t) cbAlloc - dstPos <= strlen(rgEntities[i].pszName) + 2)
                      pcszDst->ReSize(cbAlloc += 128);
                  pcszDst->psz[dstPos++] = '&';
                  strcpy(pcszDst->psz + dstPos, rgEntities[i].pszName);
                  strcat(pcszDst->psz, ";");
                  dstPos += strlen(rgEntities[i].pszName) + 1;
                  pszSrc++;
                  break;
              }
          }
          if (!rgEntities[i].pszName)
              pcszDst->psz[dstPos++] = *pszSrc++;
        }
        if (cbAlloc <= dstPos)
            pcszDst->ReSize(cbAlloc += 128);
    }
    pcszDst->psz[dstPos] = '\0';
}
#endif

#ifdef HHCTRL
BOOL CAInput::Add(PCSTR pszFile)
{
    m_ainput[++m_curInput].pin = new CInput(pszFile);
    m_ainput[m_curInput].pszBaseName = lcStrDup(pszFile);
    if (!m_ainput[m_curInput].pin->isInitialized()) {
        Remove();
        return FALSE;
    }

    // Strip basename down to the path

    PSTR pszFilePortion = (PSTR) FindFilePortion(m_ainput[m_curInput].pszBaseName);
    if (pszFilePortion)
        *pszFilePortion = '\0';
    ConvertBackSlashToForwardSlash(m_ainput[m_curInput].pszBaseName);
    return TRUE;
}
#endif

////////////////////////////////// non-HHCTRL code //////////////////////////////////

#ifndef HHCTRL

const int MAX_PARAM = 4096;

#pragma warning(disable:4125) // decimal digit terminates octal escape sequence

static const char txtSiteMapVersion[] = "<!-- Sitemap 1.0 -->";
static const char txtStringParam[] = "<param name=\042%s\042 value=\042%s\042>";
static const char txtSSConvString[] = "<param name=\042%s\042 value=\042%s:%s:%s\042>";
static const char txtYes[] = "Yes";
static const char txtDecimalParam[] = "<param name=\042%s\042 value=\042%u\042>";
static const char txtHexParam[] = "<param name=\042%s\042 value=\0420x%x\042>";

__inline void PadOutput(COutput* pout, int level) {
        for (int i = 0; i < level; i++)
            pout->outchar('\t');
    }

BOOL CSiteMap::SaveSiteMap(PCSTR pszPathName, BOOL fIndex)
{
    COutput output(pszPathName);
    if (!output.isFileOpen()) {
        // DO NOT USE MsgBox() as the parent window handle is invalid if we are closing
        CStr csz(IDS_CANT_WRITE, pszPathName);
        MessageBox(APP_WINDOW, csz, txtAppTitle, MB_OK | MB_ICONHAND);
        return FALSE;
    }

    CStr cszTmp;
    CMem memParam(MAX_PARAM);
    PSTR pszParam = memParam.psz;   // for notational convenience

    output.outstring(GetStringResource(IDSHHA_HTML_NEW_FILE1));
    output.outstring_eol(txtSiteMapVersion);
    output.outstring_eol("</HEAD><BODY>");

    // Write out any global properties

    if (    IsFrameDefined() ||
            IsWindowDefined() ||
            m_itTables.m_ptblInfoTypes ||
            m_itTables.m_ptblCategories ||
            m_fFolderImages ||
            m_pszImageList ||
            m_fAutoGenerated ||
            IsNonEmpty(m_pszFont) ||
            IsNonEmpty(m_pszHHIFile) ||
            m_clrBackground != (COLORREF) -1 ||
            m_clrForeground != (COLORREF) -1 ||
            m_exStyles != (DWORD) -1 ||
            m_tvStyles != (DWORD) -1) {

        output.outstring_eol("<OBJECT type=\042text/site properties\042>");

        if (m_fAutoGenerated) {
            wsprintf(pszParam, txtStringParam, txtAutoGenerated,
                txtYes);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }

        if (IsFrameDefined()) {
            ConvertToEscapes(GetFrameName(), &cszTmp);
            wsprintf(pszParam, txtStringParam, txtParamFrame, cszTmp);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }
        if (IsWindowDefined()) {
            ConvertToEscapes(GetWindowName(), &cszTmp);
            wsprintf(pszParam, txtStringParam, txtParamWindow, cszTmp);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }

        /*
         * REVIEW: we should eliminate Information Types which haven't
         * actually been used.
         */
            // output the entire list of info types to disk, without regard to their inclusion
            // in a category.  We may have ITs that are not members of a category.
        if ( m_fSaveIT && m_itTables.m_cTypes )
        {
            for(int pos=1; pos<=m_itTables.m_cTypes; pos++)
            {
                ConvertToEscapes(m_itTables.m_ptblInfoTypes->GetPointer(pos), &cszTmp);
                if ( HowManyCategories() > 0 )
                {
                    if ( IsExclusive(pos) ) // An Exclusive IT
                        wsprintf( pszParam, txtStringParam, txtSaveTypeExclusive, cszTmp);
                    else if ( IsHidden(pos) )    // A Hidden IT
                        wsprintf( pszParam, txtStringParam, txtSaveTypeHidden, cszTmp);
                    else    // A regular IT
                        wsprintf(pszParam, txtStringParam, txtSaveType, cszTmp);
                }
                else
                {
                    if ( IsExclusive(pos) ) // An Exclusive IT
                        wsprintf( pszParam, txtStringParam, txtParamTypeExclusive, cszTmp);
                    else if ( IsHidden(pos) )    // A Hidden IT
                        wsprintf( pszParam, txtStringParam, txtParamTypeHidden, cszTmp);
                    else    // A regular IT
                        wsprintf(pszParam, txtStringParam, txtParamType, cszTmp);
                }

                ASSERT(strlen(pszParam) < MAX_PARAM);
                output.outchar('\t');
                output.outstring_eol(pszParam);

                ConvertToEscapes(m_itTables.m_ptblInfoTypeDescriptions->GetPointer(pos), &cszTmp);

                if (!IsEmptyString(cszTmp))
                {
                    if (StrChr(cszTmp, '&'))
                    {
                        cszTmp = cszTmp;
                        cszTmp.AddAmpersandEscape();
                        cszTmp = cszTmp.psz;
                    }
                    if ( HowManyCategories() > 0)
                        wsprintf(pszParam, txtStringParam, txtSaveTypeDesc, cszTmp);
                    else
                        wsprintf(pszParam, txtStringParam, txtParamTypeDesc, cszTmp);
                    ASSERT(strlen(pszParam) < MAX_PARAM);
                    output.outchar('\t');
                    output.outstring_eol(pszParam);
                }
                else
                {
                    CStr cszTemp(" ");
                    cszTmp = cszTemp.psz;
                    if ( HowManyCategories() > 0)
                        wsprintf(pszParam, txtStringParam, txtSaveTypeDesc, cszTmp);
                    else
                        wsprintf(pszParam, txtStringParam, txtParamTypeDesc, cszTmp);
                    ASSERT(strlen(pszParam) < MAX_PARAM);
                    output.outchar('\t');
                    output.outstring_eol(pszParam);
                }
            }
        }

            //Output Categories and the info types, that are members of each category, to disk.
        if (m_fSaveIT && m_itTables.m_ptblCategories && m_itTables.m_ptblCategories->CountStrings() )
        {
            for(int posCat=1; posCat<=m_itTables.m_ptblCategories->CountStrings(); posCat++)
            {

            if ( IsCatDeleted( posCat ) )
               continue;
                ConvertToEscapes(GetCategoryString(posCat), &cszTmp);
                if (cszTmp.IsNonEmpty())
                {
                    wsprintf(pszParam, txtStringParam, txtParamCategory, cszTmp);
                    ASSERT(strlen(pszParam) < MAX_PARAM);
                    output.outchar('\t');
                    output.outstring_eol(pszParam);

                    ConvertToEscapes(m_itTables.m_ptblCatDescription->GetPointer(posCat), &cszTmp);
                    if (!IsEmptyString(cszTmp))
                    {
                        if (StrChr(cszTmp, '&'))
                        {
                            cszTmp = cszTmp;
                            cszTmp.AddAmpersandEscape();
                            cszTmp = cszTmp.psz;
                        }
                        wsprintf(pszParam, txtStringParam, txtParamCategoryDesc, cszTmp);
                        ASSERT(strlen(pszParam) < MAX_PARAM);
                        output.outchar('\t');
                        output.outstring_eol(pszParam);
                    }
                    else
                    {
                        CStr cszTemp(" ");
                        cszTmp = cszTemp.psz;
                        wsprintf(pszParam, txtStringParam, txtParamCategoryDesc, cszTmp);
                        ASSERT(strlen(pszParam) < MAX_PARAM);
                        output.outchar('\t');
                        output.outstring_eol(pszParam);
                    }
                }

                int posType = GetFirstCategoryType(posCat-1);
//                for(int j = 1; j <= m_itTables.m_aCategories[posCat-1].c_Types; j++)
            while( posType != -1 )
                {
                    ConvertToEscapes(GetInfoTypeName(posType), &cszTmp);
                    if ( IsExclusive( posType ) )
                        wsprintf( pszParam, txtStringParam, txtParamTypeExclusive, cszTmp);
                    else
                        if ( IsHidden(posType) )    // A Hidden IT
                            wsprintf( pszParam, txtStringParam, txtParamTypeHidden, cszTmp);
                        else    // A regular IT
                            wsprintf(pszParam, txtStringParam, txtParamType, cszTmp);

                    ASSERT(strlen(pszParam) < MAX_PARAM);
                    output.outchar('\t');
                    output.outstring_eol(pszParam);

                    ConvertToEscapes(m_itTables.m_ptblInfoTypeDescriptions->GetPointer(posType), &cszTmp);

                    if (cszTmp.IsNonEmpty())
                    {
                        if (StrChr(cszTmp, '&'))
                        {
                            cszTmp = cszTmp;
                            cszTmp.AddAmpersandEscape();
                            cszTmp = cszTmp.psz;
                        }
                        wsprintf(pszParam, txtStringParam, txtParamTypeDesc, cszTmp);
                        ASSERT(strlen(pszParam) < MAX_PARAM);
                        output.outchar('\t');
                        output.outstring_eol(pszParam);
                    }
                    else
                    {
                        CStr cszTemp(" ");
                        cszTmp = cszTemp.psz;
                        wsprintf(pszParam, txtStringParam, txtParamTypeDesc, cszTmp);
                        ASSERT(strlen(pszParam) < MAX_PARAM);
                        output.outchar('\t');
                        output.outstring_eol(pszParam);

                    }
                    posType = GetNextITinCategory();
                }   // for each IT in a category
            }   // for each category
        }   // if there are categories.
#ifdef NOTYET
    // OutPut the SubSet Declarations.
CStr cszTemp;
        for(int i=0; i<m_pSubSets->HowManySubSets(); i++)
        {
            CSubSet * cur_subset = m_pSubSets->GetSubSet(i);
            if ( cur_subset == NULL )
                continue;

                // output the Inclusive IT's in the subset
            int type = cur_subset->GetFirstIncITinSubSet();
            while ( type != -1 )
            {
                wsprintf(pszParam, txtSSConvString, txtParamSSInclusive, txtSSInclusive
                    cur_subset->m_cszSubSetName.psz,
                    cur_subset->m_pIT->m_itTables.m_ptblInfoTypes->GetPointer(type) );
                ASSERT(strlen(pszParam) < MAX_PARAM);
                output.outchar('\t');
                output.outstring_eol(pszParam);
                type = cur_subset->GetNextIncITinSubSet();
            }

                // output the Exclusive IT's of the subset
            type = cur_subset->GetFirstExcITinSubSet();
            while( type != -1 )
            {
                wsprintf(pszParam, txtSSConvString, txtParamSSExclusive, txtSSExclusive
                    cur_subset->m_cszSubSetName.psz,
                    cur_subset->m_pIT->m_itTables.m_ptblInfoTypes->GetPointer(type)  );
                ASSERT(strlen(pszParam) < MAX_PARAM);
                output.outchar('\t');
                output.outstring_eol(pszParam);
                type = cur_subset->GetNextExcITinSubSet();
            }
        }   // End OutPut SubSets
#endif

        if (m_pszImageList && m_cImageWidth) {
            ConvertToEscapes(m_pszImageList, &cszTmp);
            wsprintf(pszParam, txtStringParam, txtImageList, cszTmp);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);

            wsprintf(pszParam, txtDecimalParam, txtImageWidth, m_cImageWidth);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);

            if (m_clrMask != 0xFFFFFF) {
                wsprintf(pszParam, txtHexParam, txtColorMask, m_clrMask);
                ASSERT(strlen(pszParam) < MAX_PARAM);
                output.outchar('\t');
                output.outstring_eol(pszParam);
            }
        }
        if (m_clrBackground != (DWORD) -1) {
            wsprintf(pszParam, txtHexParam, txtBackGround, m_clrBackground);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }
        if (m_clrForeground != (DWORD) -1) {
            wsprintf(pszParam, txtHexParam, txtForeGround, m_clrForeground);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }
        if (m_exStyles != (DWORD) -1) {
            wsprintf(pszParam, txtHexParam, txtExWindowStyles, m_exStyles);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }
        if (m_tvStyles != (DWORD) -1) {
            wsprintf(pszParam, txtHexParam, txtWindowStyles, m_tvStyles);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }
        if (m_fFolderImages) {
            wsprintf(pszParam, txtStringParam, txtImageType, txtFolderType);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            output.outchar('\t');
            output.outstring_eol(pszParam);
        }
        if (IsNonEmpty(m_pszFont)) {
            ConvertToEscapes(m_pszFont, &cszTmp);
            wsprintf(pszParam, txtStringParam, txtFont, cszTmp);
            output.outstring_eol(pszParam);
        }
        if (IsNonEmpty(m_pszHHIFile)) {
            wsprintf(pszParam, txtStringParam, txtParamHHI, m_pszHHIFile);
            output.outstring_eol(pszParam);
        }

        output.outstring_eol(txtEndObject);
    }

    // Write out the actual entries

    output.outstring_eol(txtBeginList);
    int curLevel = 1;

    for (int pos = 1; pos <= CountStrings(); pos++) {
        SITEMAP_ENTRY* pSiteMapEntry = GetSiteMapEntry(pos);
        ASSERT(pSiteMapEntry->pszText);
        if (!pSiteMapEntry->pszText) // should never happen, but I'm paranoid...
            continue;

        // If level is greater, begin list item

        while (pSiteMapEntry->level > curLevel) {
            PadOutput(&output, curLevel);
            output.outstring_eol(txtBeginList);
            curLevel++;
        }

        // While level is lower, end lists

        while (pSiteMapEntry->level < curLevel) {
            curLevel--;
            PadOutput(&output, curLevel);
            output.outstring_eol(txtEndList);
        }

        PadOutput(&output, curLevel);
        if (!pSiteMapEntry->fInclude)
            output.outstring("<LI> ");
        output.outstring_eol("<OBJECT type=\042text/sitemap\042>");

        if (pSiteMapEntry->fInclude) {
            PadOutput(&output, curLevel + 1);
            output.outstring("<param name=\042Merge\042 value=\042");
            ConvertToEscapes(pSiteMapEntry->pszText + strlen(GetStringResource(IDS_INCLUDED_FILE)), &cszTmp);
            output.outstring(cszTmp);
            output.outstring_eol("\042>\r\n");
            PadOutput(&output, curLevel + 1);
            output.outstring_eol(txtEndObject);
            continue;
        }
        ConvertToEscapes(pSiteMapEntry->pszText, &cszTmp);

        wsprintf(pszParam, txtStringParam, txtParamName, cszTmp);
        ASSERT(strlen(pszParam) < MAX_PARAM);
        PadOutput(&output, curLevel + 1);
        output.outstring_eol(pszParam);

        OutputDefaultSiteMapEntry(&output, pSiteMapEntry, curLevel, fIndex);

        PadOutput(&output, curLevel + 1);
        output.outstring_eol(txtEndObject);

#if 0
        /*
         * We need to add an HREF to keep down-level sitemap readers happy
         * (makes the .hhc file readable in a browser). We pick the first
         * URL specified and use that.
         */

        for (int i = 0; i < pSiteMapEntry->cTypes; i++) {
            if (    pSiteMapEntry->aSiteInfoTypes[i].urlNumber > 0 &&
                    pSiteMapEntry->aSiteInfoTypes[i].infoNumber > 0) {
                wsprintf(pszParam, "<A HREF=\042%s\042>%s</A>",
                    m_ptoc->GetUrlString((pSiteMapEntry->aSiteInfoTypes[i].urlNumber),
                    pSiteMapEntry->pszText);
                ASSERT(strlen(pszParam) < MAX_PARAM);
                PadOutput(&output, curLevel + 1);
                output.outstring_eol(pszParam);
                break;
            }
        }
#endif
    }
    while (curLevel > 1) {
        curLevel--;
        PadOutput(&output, curLevel);
        output.outstring_eol(txtEndList);
    }

    output.outstring_eol(txtEndList);
    output.outstring_eol("</BODY></HTML>");

    return TRUE;
}


void CSiteMap::OutputDefaultSiteMapEntry(COutput* pout, SITEMAP_ENTRY* pSiteMapEntry,
    int curLevel, BOOL fIndex)
{
    CMem memParam(8 * 1024);
    PSTR pszParam = memParam.psz;   // for notational convenience

    SITE_ENTRY_URL* pUrl = pSiteMapEntry->pUrls;
    int cTypes = HowManyInfoTypes();
    for (int i = 0; i < pSiteMapEntry->cUrls; i++) {
        if (!IsEmptyString(pUrl->pszTitle)) {
            wsprintf(pszParam, txtStringParam, txtParamName, pUrl->pszTitle);
            ASSERT(strlen(pszParam) < MAX_PARAM);
            PadOutput(pout, curLevel + 1);
            pout->outstring_eol(pszParam);
        }

        if (cTypes) {
            int bitflag = 1 << 1;
            int offset = 0;
            CSiteMapEntry sitemapentry;
            sitemapentry.cUrls = 1;
            sitemapentry.pUrls = pUrl;

            for (int infotype = 1; infotype <= cTypes; infotype++) {
                if (AreTheseInfoTypesDefined(&sitemapentry, bitflag, offset)) {
                    CStr csz;
                    for (int l = 0; l < HowManyCategories(); l++) {
                        if( m_itTables.m_aCategories[l].c_Types <= 0)
                            break;
                        if( IsITinCategory( l, infotype) )
                        {
                            csz = GetCategoryString(l+1);
                            csz += "::";
                            break;
                        }
                    }
                    csz += GetInfoTypeName(infotype);
                    wsprintf(pszParam, txtStringParam, txtParamType, csz.psz);
                    ASSERT(strlen(pszParam) < MAX_PARAM);
                    PadOutput(pout, curLevel + 1);
                    pout->outstring_eol(pszParam);
                }
                bitflag = bitflag << 1;
                if (!bitflag) {     // wrap around, so switch offsets
                    offset++;
                    bitflag = 1;
                }
            }
        }

        if (pUrl->urlPrimary) {
            if (pSiteMapEntry->fSeeAlso) {
                wsprintf(pszParam, txtStringParam, txtSeeAlso, GetUrlString(pUrl->urlPrimary));
                ASSERT(strlen(pszParam) < MAX_PARAM);
                PadOutput(pout, curLevel + 1);
                pout->outstring_eol(pszParam);
                break;  // only one URL if See Also entry
            }

            wsprintf(pszParam, txtStringParam, txtParamLocal,
                GetUrlString(pUrl->urlPrimary));
            ASSERT(strlen(pszParam) < MAX_PARAM);
            PadOutput(pout, curLevel + 1);
            pout->outstring_eol(pszParam);
        }
        if (pUrl->urlSecondary) {
            wsprintf(pszParam, txtStringParam, txtParamUrl,
                GetUrlString(pUrl->urlSecondary));
            ASSERT(strlen(pszParam) < MAX_PARAM);
            PadOutput(pout, curLevel + 1);
            pout->outstring_eol(pszParam);
        }
        pUrl = NextUrlEntry(pUrl);
    }

    if (pSiteMapEntry->iFrameName) {
        wsprintf(pszParam, txtStringParam, txtParamFrame,
            GetName(pSiteMapEntry->iFrameName));
        ASSERT(strlen(pszParam) < MAX_PARAM);
        PadOutput(pout, curLevel + 1);
        pout->outstring_eol(pszParam);
    }
    if (pSiteMapEntry->iWindowName) {
        wsprintf(pszParam, txtStringParam, txtParamWindow,
            GetName(pSiteMapEntry->iWindowName));
        ASSERT(strlen(pszParam) < MAX_PARAM);
        PadOutput(pout, curLevel + 1);
        pout->outstring_eol(pszParam);
    }
    if (pSiteMapEntry->pszComment) {
        wsprintf(pszParam, txtStringParam, txtParamComment, pSiteMapEntry->pszComment);
        ASSERT(strlen(pszParam) < MAX_PARAM);
        PadOutput(pout, curLevel + 1);
        pout->outstring_eol(pszParam);
    }
    if (pSiteMapEntry->fNew) {
        wsprintf(pszParam, txtDecimalParam, txtParamNew, 1);
        ASSERT(strlen(pszParam) < MAX_PARAM);
        PadOutput(pout, curLevel + 1);
        pout->outstring_eol(pszParam);
    }
    if (pSiteMapEntry->iImage) {
        wsprintf(pszParam, txtDecimalParam, txtParamImageNumber,
            pSiteMapEntry->iImage);
        ASSERT(strlen(pszParam) < MAX_PARAM);
        PadOutput(pout, curLevel + 1);
        pout->outstring_eol(pszParam);
    }
    if (pSiteMapEntry->fNoDisplay) {
        wsprintf(pszParam, txtStringParam, txtParamDisplay, txtNo);
        ASSERT(strlen(pszParam) < MAX_PARAM);
        PadOutput(pout, curLevel + 1);
        pout->outstring_eol(pszParam);
    }
}

#endif // HHCTRL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sizebar.h ===
#ifndef __SIZEBAR_H__
#define __SIZEBAR_H__

///////////////////////////////////////////////////////////
//
//
// SIZEBAR.h -  CSizeBar control encapsulates the sizebar
//
//
//
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

///////////////////////////////////////////////////////////
//
// Forword references.
//
class CHHWinType ;

///////////////////////////////////////////////////////////
//
// CSizeBar
//
class CSizeBar
{
public:
    // Constructor
	CSizeBar();

    // Destructor
	~CSizeBar();

// Access
public:
	HWND hWnd() const
		{ return m_hWnd; }

    // Gets the width of the bar.
    static int Width();

    // The smallest width a pane can be sized.
    static int MinimumPaneWidth() {return Width()*5;}

    // The smallest width the topic can be sized.
    static int MinimumTopicWidth()  {return Width()*15;}

// Operations
public:
    // Create
    bool  Create(CHHWinType* pWinType) ;

    // Resize
    void ResizeWindow() ;

    // Register the window class
    static void RegisterWindowClass() ;

       
// Internal Helper Functions
protected:
    void CalcSize(RECT* prect) ;

    // Window Proc
    LRESULT SizeBarProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // Draw
    void Draw() ;

// Callbacks
private:
    // Window Proc
    static LRESULT WINAPI s_SizeBarProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Member variables.
protected:
    // Window handle to the sizebar
	HWND m_hWnd;

    // Window handle to our parent window.
    HWND m_hWndParent;

    // CHHWinType pointer so that we can get the handle to the HTMLHelp Window.
    CHHWinType*m_pWinType;

    // how far is the mouse away from the left edge of the sizebar.
    int m_offset ;

    // True if dragging.
    bool m_bDragging ;
};


#endif //__CSizeBar_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sizebar.cpp ===
///////////////////////////////////////////////////////////
//
//
// SIZEBAR.cpp -  CSizeBar control encapsulates the sizebar
//
//
//
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.
///////////////////////////////////////////////////////////
//
// Includes
//
#include "header.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include "system.h"
#include "secwin.h"

#include "contain.h"

// For ID_TAB_CONTROL
#include "resource.h"

#include "windowsx.h"

// For the ScreenRectToClientRect Function.
#include "navpane.h"
///////////////////////////////////////////////////////////
//
// external functions.
//

///////////////////////////////////////////////////////////
//
// Constructor
//
CSizeBar::CSizeBar()
:   m_hWnd(NULL),
    m_hWndParent(NULL),
    m_pWinType(NULL),
    m_bDragging(false)
{

}

///////////////////////////////////////////////////////////
//
// Destructor
//
CSizeBar::~CSizeBar()
{
    if ( IsValidWindow(m_hWnd) )
    {
        DestroyWindow( m_hWnd);
    }
}


///////////////////////////////////////////////////////////
//
// Operations
///////////////////////////////////////////////////////////
//
// Create
//
bool
CSizeBar::Create(CHHWinType* pWinType)
{
    // Validate
    ASSERT(pWinType) ;
    ASSERT(IsValidWindow(pWinType->GetHwnd())) ;

    // Save
    m_hWndParent = pWinType->GetHwnd();
    m_pWinType = pWinType ;

    // Calc the size
    RECT rcSizeBar ;
    CalcSize(&rcSizeBar) ;

    // Create the window.
    m_hWnd  = CreateWindow(txtSizeBarChildWindowClass, NULL,
                    WS_CHILD | WS_VISIBLE,
                    rcSizeBar.left, rcSizeBar.top,
                    RECT_WIDTH(rcSizeBar), RECT_HEIGHT(rcSizeBar),
                    m_hWndParent, NULL, _Module.GetModuleInstance(), NULL);

    if (m_hWnd)
    {
        // Set the userdata to our this pointer.
        SetWindowLongPtr(m_hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));

        return true;
    }
    else
        return false ;
}

///////////////////////////////////////////////////////////
//
// ResizeWindow
void
CSizeBar::ResizeWindow()
{
    // Validate
    ASSERT(IsValidWindow(hWnd())) ;

    // Calculate our size.
    RECT rc;
    CalcSize(&rc); // This will be the navigation window.

    // Size the window.
    MoveWindow(hWnd(), rc.left, rc.top,
                RECT_WIDTH(rc), RECT_HEIGHT(rc),
                TRUE);  // need to repaint the sizebar when their is a margin on the right
                  // end of the toolbar so the ghost of the sizebar is removed

    // Redraw the sizebar.
    Draw() ;
}

///////////////////////////////////////////////////////////
//
// RegisterWindowClass
//
void
CSizeBar::RegisterWindowClass()
{
    WNDCLASS wc;

    ZeroMemory(&wc, sizeof(WNDCLASS));  // clear all members

    wc.hInstance = _Module.GetModuleInstance();
    wc.hbrBackground = (HBRUSH) COLOR_WINDOW;
    //wc.lpszMenuName = MAKEINTRESOURCE(HH_MENU);
    wc.lpfnWndProc = s_SizeBarProc;
    wc.lpszClassName = txtSizeBarChildWindowClass;
    wc.hCursor = LoadCursor(NULL, IDC_SIZEWE);

    VERIFY(RegisterClass(&wc));
}

///////////////////////////////////////////////////////////
//
//              Access Functions
//
///////////////////////////////////////////////////////////
//
// Width
//
int
CSizeBar::Width()
{
    // Current the width is fixed, but based on metrics.
    return GetSystemMetrics(SM_CXSIZEFRAME);

}
///////////////////////////////////////////////////////////
//
// Internal Helper Functions
//
///////////////////////////////////////////////////////////
//
// CalcSize
//
void
CSizeBar::CalcSize(RECT* prect)
{
    ASSERT(m_pWinType) ;

    // Get the size of the HTML Help window.
    RECT rectHtml ;
    ::GetWindowRect(m_pWinType->GetHTMLHwnd(), &rectHtml );

    // Convert to the coordinates of help window itself.
    ScreenRectToClientRect(m_hWndParent, &rectHtml) ;

    // Now use this information to create our rectangle.
    prect->left = rectHtml.left - Width() ;
    prect->right = prect->left + Width() ;
    prect->top = rectHtml.top ;
    prect->bottom = rectHtml.bottom ;
}

///////////////////////////////////////////////////////////
//
// Draw
//
void
CSizeBar::Draw()
{
    // Get a dc to draw in.
    HDC hdc = GetDC(hWnd()) ;
        // get the rectangle to draw on.
        RECT rc ;
        GetClientRect(hWnd(), &rc) ;

        // Draw the edge.
        DrawEdge(hdc, &rc, EDGE_ETCHED,
                m_bDragging ? (BF_TOPLEFT | BF_BOTTOMRIGHT | BF_MIDDLE) :(BF_TOPLEFT | BF_BOTTOM | BF_MIDDLE)) ;
    // Clean up.
    ReleaseDC(hWnd(), hdc) ;

}

///////////////////////////////////////////////////////////
//
// Member function Window Proc
//
LRESULT
CSizeBar::SizeBarProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {

    case WM_LBUTTONDOWN:
            if ( wParam == MK_LBUTTON && m_pWinType)
            {
                SetCapture(hwnd); // capture the mouse to this window.
                m_offset =  GET_X_LPARAM(lParam) ; // The initial x position happens to be the offset.
                m_bDragging = true ;
            }
            break;
    case WM_LBUTTONUP:
         if (m_bDragging && (GetCapture() == hwnd))
         {
            ReleaseCapture(); // release the mouse capture from this window.

            //TODO - This nasty code uses to many internal members of CHHWinType...

            // Get the rectangle for the sizebar.
            RECT rcSizeBar ;
            GetWindowRect(m_hWnd, &rcSizeBar) ;
            ScreenRectToClientRect(m_pWinType->GetHwnd(), &rcSizeBar) ;

            // Change the left size of the Topic pane.
            m_pWinType->rcHTML.left = rcSizeBar.right;

            // move the Nav Pane
            ASSERT(m_pWinType->GetNavigationHwnd());
            if (m_pWinType->IsExpandedNavPane() &&
                IsValidWindow(m_pWinType->hwndNavigation))
            {
               m_pWinType->rcNav.right = rcSizeBar.left;
            }
        
            // resize the tab control and its' dialogs. This will also resize the sizebar and draw it.
            ::ResizeWindow(m_pWinType, false); // This is the one defined in wndproc.cpp. Don't recalc the sizes. Use the ones we've set.


            m_bDragging = false ;
         }

         break;

      case WM_MOUSEMOVE:
         if (m_bDragging)
         {
            ASSERT(m_pWinType) ;
            // Get the rectangle for the htmlhelp window.
           RECT rcHelpWin;
           GetClientRect(m_pWinType->GetHwnd(), &rcHelpWin);

           // Get the rectangle for the sizebar.
           RECT rcSizeBar ;
           GetWindowRect(m_hWnd, &rcSizeBar) ;

           // Calculate the new position.
           ScreenRectToClientRect(m_pWinType->GetHwnd(), &rcSizeBar) ;
           rcSizeBar.left += GET_X_LPARAM(lParam) - m_offset ;
           // The width of rcSizeBar is now not correct.

           // Validate the new position.
           if ( (rcSizeBar.left > MinimumPaneWidth()) && // Check left side.
                (rcSizeBar.left + Width() < rcHelpWin.right - MinimumTopicWidth()) ) // Check right boundary.
           {
               // Move it.
               SetWindowPos(m_hWnd, NULL,
                            rcSizeBar.left,
                            rcSizeBar.top,
                            0,0,
                            SWP_NOOWNERZORDER | SWP_NOSIZE | SWP_NOZORDER) ;
           }
         }
         break;
    case WM_PAINT:
          {

            // Draw an edige on the left side of the size bar.
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps) ;
                Draw() ;
            EndPaint(hwnd, &ps) ;

          }
          break ;
    case WM_ERASEBKGND:
        return 1; // We don't want the background erased.
    default:
         return DefWindowProc(hwnd, msg, wParam, lParam);
   }
   return 0;
}

///////////////////////////////////////////////////////////
//
//              Callbacks
//
///////////////////////////////////////////////////////////
//
// Static Window Proc
//
LRESULT WINAPI
CSizeBar::s_SizeBarProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CSizeBar* pThis = reinterpret_cast<CSizeBar*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    if (pThis)
        return pThis->SizeBarProc(hwnd, msg, wParam, lParam) ;
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\splash.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "hhctrl.h"
#include "cpaldc.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

const char g_wcSplash[] = "Splash";

const int CB_BORDER = 2;  // Width of the border we draw around splash window
const int SHADOW_WIDTH	= 6; // Shadow border
const int SHADOW_HEIGHT = 6;

#define IDSPLASH_TIMER 9999

static BITMAP bmpSplash;

LRESULT SplashWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

void CHtmlHelpControl::CreateSplash(void)
{
	ASSERT(m_ptblItems);
	if (!m_ptblItems || m_ptblItems->CountStrings() < 1)
		return;

	char szBitmap[MAX_PATH];

	// If current video display supports more then 256 colors, then check
	// for an alternate image in Item3. Note that this requires
	// the author to specify a timeout value for Item2.

	if (m_ptblItems->CountStrings() > 2) {
		HDC hdc = CreateIC("DISPLAY", NULL, NULL, NULL);
		if( hdc && GetDeviceCaps(hdc, BITSPIXEL) > 8) {
			if (!ConvertToCacheFile(m_ptblItems->GetPointer(1), szBitmap))
				return;
			else
				goto GotImageFile;
		}
    if( hdc )
      DeleteDC( hdc );
	}

	if (!ConvertToCacheFile(m_ptblItems->GetPointer(1), szBitmap))
		return;

GotImageFile:

	if (stristr(szBitmap, ".gif")) {
		if (!LoadGif(szBitmap, &g_hbmpSplash, &g_hpalSplash, this))
			return;
	}

	// REVIEW: If we are on a 256-color system, read the color information
	// and create a palette
	else {
		g_hbmpSplash = (HBITMAP) LoadImage(_Module.GetResourceInstance(), szBitmap, IMAGE_BITMAP, 0, 0,
			LR_LOADFROMFILE);
	}

	if (!g_hbmpSplash) {
		// BUGBUG: nag the help author
		return;
	}
	GetObject(g_hbmpSplash, sizeof(bmpSplash), &bmpSplash);

	if (!g_fRegisteredSpash) {
		WNDCLASS wc;
		ZERO_STRUCTURE(wc);
		wc.lpfnWndProc	 = SplashWndProc;
		wc.hInstance	 = _Module.GetModuleInstance();
		wc.hCursor		 = LoadCursor(NULL, IDC_ARROW);
		wc.lpszClassName = g_wcSplash;

		if (!RegisterClass(&wc))
			return; 	// REVIEW: should we notify the help author?
		g_fRegisteredSpash = TRUE;
	}

	RECT rc;

	// Find the parent window so the splash screen is centered over the parent

	{
		HWND hwndParent = GetParent(m_hwnd);
#if defined(_DEBUG)
		char szClass[256];
#endif
		while (GetWindowLong(hwndParent, GWL_STYLE) & WS_CHILD) {
			HWND hwnd = GetParent(hwndParent);
			if (IsValidWindow(hwnd)) {
				hwndParent = hwnd;
#if defined(_DEBUG)
				GetClassName(hwndParent, szClass, sizeof(szClass));
#endif
			}
			else
				break;
		}
		GetWindowRect(hwndParent, &rc);
	}

	g_hwndSplash = CreateWindowEx(WS_EX_TOPMOST, g_wcSplash, "",
		WS_POPUP | WS_VISIBLE,
		rc.left +
			RECT_WIDTH(rc) / 2 - (bmpSplash.bmWidth / 2),
		rc.top +
			RECT_HEIGHT(rc) / 2 - (bmpSplash.bmHeight / 2),
		bmpSplash.bmWidth + CB_BORDER * 2 + SHADOW_WIDTH,
		bmpSplash.bmHeight + CB_BORDER * 2 + SHADOW_HEIGHT,
		NULL, NULL, _Module.GetModuleInstance(), NULL);

	if (!g_hwndSplash)
		return;

	// Default to 3 seconds before deleting the splash window

	SetTimer(g_hwndSplash, IDSPLASH_TIMER,
		m_ptblItems->CountStrings() > 1 ?
		(UINT) Atoi(m_ptblItems->GetPointer(2)) : 2500, NULL);
}

LRESULT SplashWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_CREATE:
			SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)
				((CREATESTRUCT*) lParam)->lpCreateParams);
			return 0;

		case WM_ERASEBKGND:
			{
				HDC hdc = (HDC) wParam;
				PaintShadowBackground(hwnd, hdc);

				CPalDC cdc(g_hbmpSplash, g_hpalSplash);
				HPALETTE hpalOld;
				if (g_hpalSplash) {
					hpalOld = SelectPalette(hdc, g_hpalSplash, FALSE);
					RealizePalette(hdc);
				}

				BitBlt(hdc, CB_BORDER, CB_BORDER, bmpSplash.bmWidth,
					bmpSplash.bmHeight, cdc.m_hdc, 0, 0, SRCCOPY);

				if (g_hpalSplash)
					SelectPalette(hdc, hpalOld, FALSE);
			}
			return TRUE;

		case WM_TIMER:
			if (wParam == IDSPLASH_TIMER) {
				KillTimer(hwnd, IDSPLASH_TIMER);
				DestroyWindow(hwnd);
				g_hwndSplash = NULL;
			}
			return 0;

		case WM_LBUTTONDOWN:
			DestroyWindow(hwnd);
			g_hwndSplash = NULL;
			return 0;

		case WM_RBUTTONDOWN:
			DestroyWindow(hwnd);
			g_hwndSplash = NULL;
//			  DisplayCredits();
			return 0;

		default:
			return (DefWindowProc(hwnd, msg, wParam, lParam));
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\state.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "state.h"
#include "fs.h"
#include "hhtypes.h"

CState::CState(PCSTR pszChm)
{
    m_pfs = NULL;
    m_pSubFS = NULL;

    // Make sure we have a name we can use to create a sub file with

    PCSTR pszTmp = StrChr(pszChm, CH_COLON);
    if (pszTmp)
        pszChm = pszTmp + 1;
    pszTmp = strstr(pszChm, "//");
    if (pszTmp)
        pszChm = pszTmp + 2;
    pszTmp = strstr(pszChm, "\\\\");
    if (pszTmp)
        pszChm = pszTmp + 2;

    m_cszChm = pszChm;
}

HRESULT CState::Open(PCSTR pszName, DWORD dwAccess)
{
   HRESULT hr;

   lstrcpy(m_pszName, pszName);
   m_dwAccess = dwAccess;
   hr = _IOpen();
   Close();
   return hr;
}

HRESULT CState::_IOpen()
{
    char szPath[MAX_URL];
    HRESULT hr;

   // force access modes
   if( (m_dwAccess & STGM_WRITE) || (m_dwAccess & STGM_READWRITE) ) {
     m_dwAccess &= ~STGM_WRITE;
     m_dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     m_dwAccess |= STGM_SHARE_DENY_WRITE;

    if (!m_pfs) {

        GetRegWindowsDirectory(szPath);
        AddTrailingBackslash(szPath);

        HHGetUserDataPathname( szPath, sizeof(szPath) );

        m_pfs = new CFileSystem;
        m_pfs->Init();
        hr = m_pfs->Open(szPath, STGM_READWRITE | STGM_SHARE_EXCLUSIVE );
        if(hr == STG_E_SHAREVIOLATION)
        {
            Sleep(200);
            hr = m_pfs->Open(szPath, STGM_READWRITE | STGM_SHARE_EXCLUSIVE );
            if(FAILED(hr))
            {
                delete m_pfs;
                m_pfs = NULL;
                return hr;
            }
        }
        if (FAILED(hr))
            hr = m_pfs->CreateUncompressed(szPath);
        if (FAILED(hr)) {
            delete m_pfs;
            m_pfs = NULL;
            return hr;
        }
    }
    if (m_pSubFS)
        delete m_pSubFS;    // close any previous subfile
    m_pSubFS = new CSubFileSystem(m_pfs);
    strcpy(szPath, m_cszChm);
    AddTrailingBackslash(szPath);
    strcat(szPath, m_pszName);

    hr = m_pSubFS->OpenSub(szPath, m_dwAccess);
    if (FAILED(hr) && ((m_dwAccess & STGM_WRITE) || (m_dwAccess & STGM_READWRITE)) )
        hr = m_pSubFS->CreateUncompressedSub(szPath);
    if (FAILED(hr)) {
        delete m_pSubFS;
        m_pSubFS = NULL;
    }
    return hr;
}

HRESULT CState::Read(void* pData, DWORD cb, DWORD* pcbRead)
{
   HRESULT hr;

   _IOpen();
   if (!m_pSubFS)
       return STG_E_INVALIDHANDLE;

   hr = m_pSubFS->ReadSub(pData, cb, pcbRead);
   Close();
   return hr;
}

DWORD CState::Write(const void* pData, DWORD cb)
{
   HRESULT hr;

   _IOpen();
    if (!m_pSubFS)
        return STG_E_INVALIDHANDLE;
   hr = m_pSubFS->WriteSub(pData, cb);
   Close();
   return hr;
}

CState::~CState()
{
    if (m_pSubFS)
        delete m_pSubFS;    // close any previous subfile
    if (m_pfs)
        delete m_pfs;
}

void CState::Close()
{
    if (m_pSubFS) {
        delete m_pSubFS;    // close any previous subfile
        m_pSubFS = NULL;
    }
    if (m_pfs)
    {
        delete m_pfs;
        m_pfs = NULL;
    }
}

///////////////////////////////////////////////////////////
//
//
//
HRESULT
CState::Delete()
{
    HRESULT hr = S_FALSE ;

    _IOpen();
    if (m_pSubFS)
    {
        hr = m_pSubFS->DeleteSub() ; // Removes the element from the state.

        // Overkill, but what the hey!
        Close() ;
    }
    Close();
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\state.h ===
// Copyright  1997-1998  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _STATE_H_
#define _STATE_H_

class CState
{
public:
    CState(PCSTR pszChm);
    ~CState();

    HRESULT Open(PCSTR pszName, DWORD dwAccess = (STGM_READWRITE | STGM_SHARE_DENY_WRITE));
    HRESULT _IOpen(void);

    void    Close(void);
    HRESULT Read(void* pData, DWORD cb, DWORD* pcbRead);
    DWORD   Write(const void* pData, DWORD cb);
    HRESULT Delete() ;

private:
    class CFileSystem* m_pfs;
    class CSubFileSystem* m_pSubFS;
    CStr  m_cszChm;
    DWORD m_dwAccess;
    TCHAR m_pszName[MAX_PATH];
};

#endif _STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\stdafx.cpp ===
// This module is used for generating the precompiled header

#ifdef INTERNAL
#pragma message("<< Internal Version >>")
#endif

#ifdef _DEBUG
#pragma message("<< Debug Version >>")
#else
#pragma message("<< Release Version >>")
#endif

#include "header.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sitechar.cpp ===
static const char txtBeginList[] =     "<UL>";
static const char txtEndList[]    =    "</UL>";
static const char txtBeginListItem[] = "<LI";
static const char txtSitemap[] =    "<!-- Sitemap"; // 3 different sitemap declarations
static const char txtSitemap1[] =      "<!--Sitemap";
static const char txtSitemap2[] =      "<!Sitemap";
static const char txtParam[] =         "<param name";
static const char txtValue[] =         "value";
static const char txtBeginHref[] =     "<A HREF";
static const char txtEndHref[] =    "</A>";
static const char txtBeginObject[] =   "<OBJECT";
static const char txtEndObject[] =     "</OBJECT>";
static const char txtSiteMapObject[] = "text/sitemap";
static const char txtSitemapProperties[] = "text/site properties";
static const char txtBackGround[] =    "Background";
static const char txtBackGroundImage[] = "Background Image";
static const char txtForeGround[] =    "Foreground";
static const char txtFont[] =       "Font";
static const char txtImageList[] =     "ImageList";
static const char txtNumberImages[] =  "NumberImages";
static const char txtImageWidth[] =    "Image Width";
static const char txtColorMask[] =     "Color Mask";
static const char txtNumberTypes[] =   "NumberTypes";
static const char txtExWindowStyles[] = "ExWindow Styles";
static const char txtWindowStyles[] =  "Window Styles";
static const char txtType[] =       "type";
static const char txtNo[] =         "No";
static const char txtFolderType[] =    "Folder";
static const char txtEndTag[] =     "</";
static const char txtInfoTypeDeclaration[] = "InformationTypeDecl";

// Param labels

static const char txtParamType[] =        "Type";
static const char txtParamTypeExclusive[] = "TypeExclusive";
static const char txtParamTypeHidden[]   = "TypeHidden";
static const char txtParamTypeDesc[]  =   "TypeDesc";
static const char txtParamTypeTypical[]  =   "TypeTypical";
static const char txtParamCategory[]    = "Category";
static const char txtParamCategoryDesc[] =   "CategoryDesc";
static const char txtParamSSInclusive[] = "SSInclusive";  // member of a subset's inclusive filter
static const char txtParamSSExclusive[] = "SSExclusive";  // member of a subset's exclusive filter  
static const char txtParamName[] =        "Name";
static const char txtParamUrl[] =         "URL";
static const char txtParamSecondary[] =   "Secondary";
static const char txtParamIcon[] =        "Icon";
static const char txtParamLocal[] =       "Local";
static const char txtParamFrame[] =       "FrameName";
static const char txtParamWindow[] =      "WindowName";
static const char txtParamNew[] =         "New";
static const char txtParamComment[] =     "Comment";
static const char txtParamImageNumber[] = "ImageNumber";
static const char txtParamDisplay[] =     "Display";
static const char txtParamKeyword[] =     "Keyword";
static const char txtParamInstruction[] = "Instruction";
static const char txtParamSectionTitle[] =   "Section Title";
static const char txtSeeAlso[]          = "See Also";
static const char txtImageType[]     = "ImageType";
static const char txtFavorites[]     = "Favorites";
static const char txtQueryType[]     = "QueryType";
static const char txtSendEvent[]     = "SendEvent";
static const char txtSendMessage[]      = "SendMessage";
static const char txtParamMerge[]       = "Merge";
static const char txtParamHHI[]         = "HHI";
static const char txtAutoGenerated[]    = "Auto Generated";
static const char txtSSInclusive[]         =  "Inclusive";
static const char txtSSExclusive[]         =  "Exclusive";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sitemap.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __SITEMAP_H__
#define __SITEMAP_H__

class CHtmlHelpControl; // forward reference
#include "cinput.h"
#include "strtable.h"

typedef PCSTR URL;
typedef UINT INFOTYPE;

const INFOTYPE ITYPE_ALWAYS_SHOW = 0;   // when this info type is defined, the entry is always shown to the user (unless a Hidden info type overrides)

const int MAX_RELATED_ENTRIES = 256;    // maximum number of sitemap entries for Related Topics
const int MAX_KEYSEARCH_ENTRIES = 256;  // maximum number of sitemap entries for Keyword Search

enum {
    IMAGE_CLOSED_BOOK = 1,
    IMAGE_OPEN_BOOK,
    IMAGE_CLOSED_BOOK_NEW,
    IMAGE_OPEN_BOOK_NEW,
    IMAGE_CLOSED_FOLDER,
    IMAGE_OPEN_FOLDER,
    IMAGE_CLOSED_FOLDER_NEW,
    IMAGE_OPEN_FOLDER_NEW,
    IMAGE_HELP_TOPIC,
    IMAGE_HELP_TOPIC_NEW,
    IMAGE_TOPIC,
    IMAGE_TOPIC_NEW,
    IMAGE_TOPIC_REMOTE,
    IMAGE_TOPIC_NEW_REMOTE,
};

#define IMAGE_INFOTYPE 37

#define ESCAPE_ENTITY       0x01
#define ESCAPE_URL          0x02
#define ESCAPE_C            0x04
#define ESCAPE_ALL          0x07

/*
    Each URL can be associated with any number of information types.
    Information types are stored as bit flags. By default, each
    SITE_ENTRY_URL entry contains enough storage for 32 information types.
    If more are needed, then additional memory must be allocated. Note that
    we must allocate 4 bytes for each additional information type in order to
    avoid alignment problems.

    The CSiteMap class must keep track of the total number of bytes to
    allocate for each SITE_ENTRY_URL structure. This can NOT change once
    a SITEMAP_ENTRY has been allocated (unless all SITEMAP_ENTRY structures
    get updated). Within the SITEMAP_ENTRY structure, cUrls tells us how
    many SITE_ENTRY_URL structures to allocate.
*/

typedef struct {
    PCSTR pszTitle;
    URL urlPrimary;
    URL urlSecondary;
    //INFOTYPE ainfoTypes[1];     // which information types
    INFOTYPE *ainfoTypes;
} SITE_ENTRY_URL;


const int MAX_CATEGORIES = 10;
typedef struct {
    int c_Types;            // the number of ITs in a category
    INFOTYPE *pInfoType;    // a pointer to a set of infotype bits.  The bits represent info types
                            // bit zero is reserved.
} CATEGORY_TYPE;

typedef struct {
    CTable* m_ptblInfoTypes;
    CTable* m_ptblInfoTypeDescriptions;
    CTable* m_ptblCategories;
    CTable* m_ptblCatDescription;
    int     m_cTypes;             // total number of types
    int     m_cITSize;            // The number of DWORDs allocated for categories, m_pExclusive, and m_pHidden
    INFOTYPE* m_pExclusive;    // index to first exclusive information type
    INFOTYPE* m_pHidden;       // index to first hidden information type
    int     m_max_categories;     // The number of categories currently allocated.
    CATEGORY_TYPE *m_aCategories;
} INFOTYPE_TABLES;

// Overhead is 20 bytes per entry + 12 for each URL (assuming up to 32 InfoTypes)

// forward reference
class CSiteMap;

typedef struct _tagSiteMapEntry {

#ifndef HHA
    CSiteMap* pSiteMap;
#endif

    PCSTR   pszText;    // title/keyword for this entry

#ifndef HHCTRL
    PCSTR   pszComment;
    PCSTR   pszSort;    // used when sorting index
#endif

    short   iWindowName;
    short   iFrameName;
    short   iFontName;
    short   cUrls;  // number or URLS

    BYTE    iImage;
    BYTE    level;
    BYTE    fInclude;  // Used by HHW to track included sitemap file

    BYTE    fTopic:1;
    BYTE    fNew:1;
    BYTE    fNoDisplay:1;
    BYTE    fSeeAlso:1;
    BYTE    fShowToEveryOne:1;  // TRUE if no Information Type was specified
    BYTE    fSendEvent:1;       // TRUE if URL is an event string
    BYTE    fSendMessage:1;     // TRUE if URL is a message string
    BYTE    fShortCut:1;        // TRUE if URL is a shortcut string

    // WARNING! pUrls must be the last member of this structure

    SITE_ENTRY_URL* pUrls;

    int   GetLevel(void) const { return level; }
    void  SetLevel(int val) { level = (BYTE)val; }

    PCSTR   GetKeyword() const { return pszText; }

#ifdef HHCTRL
#ifndef HHA
    HRESULT GetKeyword( WCHAR* pwszKeyword, int cch );
#endif
#endif

    PCSTR   GetTitle( SITE_ENTRY_URL* pUrl ) { return pUrl->pszTitle ? pUrl->pszTitle : GetStringResource(IDS_UNTITLED); }

#ifdef HHCTRL
#ifndef HHA
    HRESULT GetTitle( SITE_ENTRY_URL* pUrl, WCHAR* pwszTitle, int cch );
#endif
#endif

    BOOL  IsTopic(void) const { return fTopic; }
    void  SetTopic(BOOL fSetting) { fTopic = fSetting; }

    BOOL  IsNew(void) const { return fNew; }
    void  SetNew(BOOL fSetting) { fNew = fSetting; }

    BOOL  GetSeeAlso(void) const { return fSeeAlso; }
    void  SetSeeAlso(BOOL fSetting) { fSeeAlso = fSetting; }

    int   GetImageIndex(void) const { return iImage; }
    void  SetImageIndex(int IndexImage) { iImage = (BYTE) IndexImage; }

    int   GetWindowIndex(void) const { return (int) iWindowName; }
    void  SetWindowIndex(int index) { iWindowName = (short)index; }

    int   GetFrameIndex(void) const { return (int) iFrameName; }
    void  SetFrameIndex(int index) { iFrameName = (short)index; }

    int   GetFontIndex(void) const { return (int) iFontName; }
    void  SetFontIndex(int index) { iFontName = (short)index; }

    void  Clear(void) { ClearMemory(this, sizeof(_tagSiteMapEntry)); }

} SITEMAP_ENTRY;





class CSiteMapEntry : public SITEMAP_ENTRY
{
public:
    CSiteMapEntry() { ClearMemory(this, sizeof(CSiteMapEntry)); }
#ifndef HHCTRL
    void CopyFrom(const SITEMAP_ENTRY* pSiteMapEntry, CSiteMap* pSiteMapSrc, CSiteMap* pSiteMapDst);
    void CopyTo(SITEMAP_ENTRY* pSiteMapEntry, CSiteMap* pSiteMapSrc, CSiteMap* pSiteMapDst);
#endif
};

class CSiteEntryUrl
{
public:
    CSiteEntryUrl(int ITSize) {
        m_pUrl = (SITE_ENTRY_URL*) lcCalloc(sizeof(SITE_ENTRY_URL) );
        m_pUrl->ainfoTypes = (INFOTYPE*)lcCalloc( ITSize==0?sizeof(INFOTYPE):ITSize );
        m_fUrlSpecified = FALSE;
    }
    ~CSiteEntryUrl() { lcFree(m_pUrl->ainfoTypes); lcFree(m_pUrl); }
    void SaveUrlEntry(CSiteMap* pSiteMap, SITEMAP_ENTRY* pSiteMapEntry);

    SITE_ENTRY_URL* m_pUrl;
    int  m_cMaxTypes;
    BOOL m_fUrlSpecified;
};

class CParseSitemap;    // forward reference

// Forward declarations  declared in genit.cpp
//
int GetITBitfromIT(INFOTYPE const *IT, int* offset, int* bit, int cTypes);
void AddIT(int const type, INFOTYPE *pIT );
void DeleteIT(int const type, INFOTYPE *pIT );
int GetITfromCat(int* offset, INFOTYPE* bit, INFOTYPE* pInfoType, int cTypes);
int GetITBitfromIT(INFOTYPE const *IT, int* offset, INFOTYPE* bit, int cTypes);
void CopyITBits(INFOTYPE** ITDst, INFOTYPE* ITSrc, int size);

// WARNING!!! All member classes should be included as pointers or initialization
// will trash the class.

// forward reference
SITEMAP_ENTRY;

class CSiteMap : public CTable
{
private:
    void SizeIT(int oldSize);

public:
    CSiteMap(int cMaxEntries = 0);
    virtual ~CSiteMap();

#ifdef HHA
    SITEMAP_ENTRY* AddEntry( SITEMAP_ENTRY* pSiteMapEntry = NULL ) 
	{ 
		int iData = AddData(sizeof(SITEMAP_ENTRY), pSiteMapEntry);
		if (iData)
		{
			return GetSiteMapEntry(iData); 
		}
		else
			return NULL;
	}
#else
    SITEMAP_ENTRY* AddEntry( SITEMAP_ENTRY* pSiteMapEntry = NULL )
    {
	  int iData = AddData(sizeof(SITEMAP_ENTRY), pSiteMapEntry);
   	  if (iData)
	  {
		SITEMAP_ENTRY* pReturn = GetSiteMapEntry(iData);
		pReturn->pSiteMap = this;
		return pReturn;
	  }
	  else
		return NULL;
    }
#endif

    void            AddFavoriteNodes(PCSTR pszRoot, PCSTR pszNewFolder, int level);
    void            AddInfoTypeToUrl(SITEMAP_ENTRY* pSiteMapEntry, INFOTYPE iType);
    int             AddTypeName(PCSTR pszName);
    int             Count(void) const { return endpos - 1; };
    void            CreateFavorites(int level = 1);
    int             GetImageNumber(SITEMAP_ENTRY* pSiteMapEntry) const;
    SITEMAP_ENTRY*  GetSiteMapEntry(int pos) const { return (SITEMAP_ENTRY*) GetPointer(pos); }
#ifdef HHCTRL
#ifdef HHA
    BOOL            ReadFromFile(PCSTR pszFileName, BOOL fIndex, CHtmlHelpControl* phhctrl );
#else
    BOOL            ReadFromFile(PCSTR pszFileName, BOOL fIndex, CHtmlHelpControl* phhctrl, UINT CodePage );
#endif
#else
    BOOL            ReadFromFile(PCSTR pszFileName, BOOL fIndex, PCSTR pszBaseFile = NULL);
#endif

    BOOL            AreAnyInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry);
    SITE_ENTRY_URL* AreTheseInfoTypesDefined(SITEMAP_ENTRY* pSiteMapEntry, INFOTYPE types, int offset) const;

    SITE_ENTRY_URL* NextUrlEntry(SITE_ENTRY_URL* pUrl) const { return (SITE_ENTRY_URL*) ((PBYTE) pUrl + sizeof(SITE_ENTRY_URL) ); }
    SITE_ENTRY_URL* GetUrlEntry(SITEMAP_ENTRY* pSiteMapEntry, int pos /* zero-based */) { return (SITE_ENTRY_URL*) ((PBYTE) pSiteMapEntry->pUrls + (GetUrlEntrySize() * pos)); }
    SITE_ENTRY_URL* GetUrlEntry(SITE_ENTRY_URL* pUrl, int pos /* zero-based */) { return (SITE_ENTRY_URL*) ((PBYTE) pUrl + (GetUrlEntrySize() * pos)); }
    PCSTR           GetUrlTitle(SITEMAP_ENTRY* pSiteMapEntry, int pos /* zero-based */) { return  pSiteMapEntry->GetTitle((SITE_ENTRY_URL*) (SITE_ENTRY_URL*) ((PBYTE) pSiteMapEntry->pUrls + (GetUrlEntrySize() * pos))); }
    int             GetUrlEntrySize(void) const { return sizeof(SITE_ENTRY_URL); }
    BOOL            ParseSiteMapParam(CParseSitemap* pcparse, PCSTR pszParamType, CTable *ptblSubSets);

    void            ReSizeIT(int Size=0);   
    void            ReSizeURLIT(int Size=0);
    
    BOOL            IsEntryInCurTypeList(SITEMAP_ENTRY* pSiteMapEntry) const;
    int             GetInfoType(PCSTR pszTypeName);
    PCSTR           GetInfoTypeName(int pos) const { return m_itTables.m_ptblInfoTypes->GetPointer(pos); }
    int             GetITIndex(PCSTR pszString) const { return m_itTables.m_ptblInfoTypes->IsStringInTable( pszString ); }
    PCSTR           GetInfoTypeDescription(int pos) const { return m_itTables.m_ptblInfoTypeDescriptions->GetPointer(pos); }
    int             GetInfoTypeSize(void) const { return InfoTypeSize(); }
    int             HowManyInfoTypes(void) const { return m_itTables.m_ptblInfoTypes ? m_itTables.m_ptblInfoTypes->CountStrings() : 0; }
    BOOL            IsInACategory( int type ) const;

    int             InfoTypeSize(void) const { return m_itTables.m_cITSize * sizeof(INFOTYPE); }
    BOOL            IsDeleted( const int pos ) const { return ( *(GetInfoTypeName(pos))==' ' )?TRUE:FALSE; }

    int             GetFirstExclusive(int=-1, INFOTYPE=1) const;
    int             GetNextExclusive(void) const;
    int             GetLastExclusive(void) const;
    void            AddExclusiveIT(int const type) { AddIT( type, m_itTables.m_pExclusive ); }
    void            DeleteExclusiveIT(int const type ) { DeleteIT( type, m_itTables.m_pExclusive); }
    BOOL            IsExclusive(int const type) const { return m_itTables.m_pExclusive?*(m_itTables.m_pExclusive+(type/32)) & (1<<(type%32)):0; }

    int             GetFirstHidden(int=-1, INFOTYPE=1) const;
    int             GetNextHidden(void) const;
    int             GetLastHidden(void) const;
    void            AddHiddenIT(int const type ) { AddIT(type, m_itTables.m_pHidden); }
    void            DeleteHiddenIT(int const type) { DeleteIT( type, m_itTables.m_pHidden ); }
    BOOL            IsHidden(int const type) const { return m_itTables.m_pHidden?*(m_itTables.m_pHidden+(type/32)) & (1<<(type%32)):0; }

    int             GetFirstCategoryType(int pos) const ;
    int             GetNextITinCategory( void ) const ;
    int             GetLastCategoryType(int pos) const ;
    void            AddITtoCategory(int pos, int type);
    void            AddToCategory( int iLastType );
    void            DeleteITfromCat(int pos, int type);
    BOOL            IsITinCategory( int pos, int type) const { return m_itTables.m_aCategories[pos].pInfoType?*(m_itTables.m_aCategories[pos].pInfoType+(type/32)) & (1<<(type%32)):0; }
    BOOL            IsCatDeleted( const int pos ) const { return ( *(GetCategoryString(pos))==' ' )?TRUE:FALSE; }

    void            CopyCat(INFOTYPE_TABLES*, const INFOTYPE_TABLES*);
    PCSTR           GetCategoryString(int pos) const { return m_itTables.m_ptblCategories->GetPointer(pos); }
    int             GetCatPosition(PCSTR psz) const { return m_itTables.m_ptblCategories->IsStringInTable(psz); }
    int             HowManyCategories(void) const { return m_itTables.m_ptblCategories ? m_itTables.m_ptblCategories->CountStrings() : 0; }
    PCSTR           GetCategoryDescription(int pos) const { return m_itTables.m_ptblCatDescription?m_itTables.m_ptblCatDescription->GetPointer(pos):0; }

    int             GetLevel(int pos) const { return GetSiteMapEntry(pos)->GetLevel(); }
    void            SetLevel(int val, int pos) { GetSiteMapEntry(pos)->SetLevel(val); }

    PCSTR           GetPathName(void) { return m_pszSitemapFile; }
    PCSTR           GetSiteMapFile(void) { return m_pszSitemapFile; }
    void            SetSiteMapFile(PCSTR pszFile)
                    {
                      if (!m_pszSitemapFile && pszFile)
                        m_pszSitemapFile = StrDup(pszFile);
                    }

    PCSTR           GetFrameName(void) { return m_pszFrameName ? m_pszFrameName : ""; }
    void            SetFrameName(PCSTR psz) { m_pszFrameName = IsEmptyString(psz) ? NULL : StrDup(psz); }
    BOOL            IsFrameDefined(void) { return m_pszFrameName != NULL; }
    void            SetEntryFrame(SITEMAP_ENTRY* pSiteMapEntry, PCSTR psz) { pSiteMapEntry->SetFrameIndex(AddName(psz)); }
    PCSTR           GetEntryFrame(SITEMAP_ENTRY* pSiteMapEntry) { return GetName(pSiteMapEntry->GetFrameIndex()); }

    PCSTR           GetWindowName(void) { return m_pszWindowName ? m_pszWindowName : ""; }
    void            SetWindowName(PCSTR psz) { m_pszWindowName = IsEmptyString(psz) ? NULL : StrDup(psz); }
    BOOL            IsWindowDefined(void) { return m_pszWindowName != NULL; }
    void            SetEntryWindow(SITEMAP_ENTRY* pSiteMapEntry, PCSTR psz) { pSiteMapEntry->SetWindowIndex(AddName(psz)); }
    PCSTR           GetEntryWindow(SITEMAP_ENTRY* pSiteMapEntry) { return GetName(pSiteMapEntry->GetWindowIndex()); }

    URL             AddUrl(PCSTR pszUrl);
    PCSTR           GetUrlString(URL url) const { return (PCSTR) url; }

    int             AddName(PCSTR psz);
    PCSTR           GetName(int pos)
                    {
                        #ifdef _DEBUG
                        if (m_ptblStrings)
                            ASSERT(pos <= m_ptblStrings->CountStrings());
                        #endif
                        return (m_ptblStrings && pos > 0) ? m_ptblStrings->GetHashStringPointer(pos) : "";
                    }
    BOOL            IsIndex(void) { return m_fIndex; }

#ifndef HHA
    UINT GetCodePage() { if( m_CodePage != (UINT)-1 ) return m_CodePage; else return CP_ACP; }
#endif

    //////// member variables //////////

    /*
    !!! WARNING: if you add or remove members, you must change the version
    !!! number in hhamsgs.h or face a GPF when the author does a View Entry.
    */
    BOOL    m_fTypeCopy;    // TRUE if following tables are pointers that must not be freed
    INFOTYPE_TABLES m_itTables;
//    CSubSets *m_pSubSets;
    PCSTR   m_pszSitemapFile;
    INFOTYPE* m_pInfoTypes; // user-specified Information Types
    INFOTYPE* m_pTypicalInfoTypes; // "typical" information types
    BOOL    m_fIndex;           // TRUE if using this as an index
    PSTR    m_pszBase;  // used when reading sitemap file

    PCSTR    m_pszImageList;
    int      m_cImageWidth;         // width of each icon in image
    int      m_cImages;
    COLORREF m_clrMask;

    COLORREF m_clrBackground;
    COLORREF m_clrForeground;
    PCSTR    m_pszFont;                 // name, pointsize, ext.  usefull to CTocClass.

    BOOL     m_fFolderImages;    // use folders instead of books as the image
    BOOL     m_fPromotForInfoTypes;

    DWORD    m_tvStyles;          // regular window styles
    DWORD    m_exStyles;          // extended window styles

    PCSTR    m_pszBackBitmap; // used for TOC and Index

    int      m_cITSize;       // The number of DWORDS currently allocated for IT bits for the URL
 //   int     m_cUrlEntry;  // sizeof(SITE_ENTRY_URL) + sizeof(URL) for each additional 32 Information Types
 //   int     m_cInfoTypeOffsets; // number of additional offsets to check

    BOOL    m_fAutoGenerated;   // means the file is not writeable

#ifndef HHCTRL
    SITEMAP_ENTRY*  Add(const SITEMAP_ENTRY* pSiteMapEntry = NULL);
    SITEMAP_ENTRY*  Insert(int pos, const SITEMAP_ENTRY* pSiteMapEntry = NULL);
    void            Remove(int pos, BOOL fCompact = TRUE);
    void            FillUrlComboBox(SITEMAP_ENTRY* pSiteMapEntry, HWND hwndCombo);
    void            MoveEntry(int posSrc, int posDst);
    BOOL            SaveSiteMap(PCSTR pszPathName, BOOL fIndex);
    void            OutputDefaultSiteMapEntry(COutput* pout, SITEMAP_ENTRY* pSiteMapEntry, int curLevel, BOOL fIndex);
    void            CopyProperties(CSiteMap* pSiteMap, BOOL fIncludeTables = FALSE);
#endif

    CTable*  m_ptblStrings;

    PCSTR m_pszFrameName;     // default frame to use
    PCSTR m_pszWindowName;    // default window to use
    PCSTR m_pszHHIFile;
    BOOL  m_fSaveIT;          // Save the declared IT in an instance of CSitemap, if there is an hhi hhc IT declarations are not saved.

#ifndef HHA
  private:
    UINT      m_CodePage;
#endif
};


// note the inlined SITEMAP_ENTRY functions below must be declared after
// the declaration of CSiteMap otherwise the compiler will choke on them
// since they access CSiteMap members/methods

#ifdef HHCTRL
#ifndef HHA
    inline HRESULT SITEMAP_ENTRY::GetKeyword( WCHAR* pwszKeyword, int cch )
    {
      ASSERT( pSiteMap );
      //ASSERT( pSiteMap->GetCodePage() );
      UINT CodePage = pSiteMap->GetCodePage();
      if( MultiByteToWideChar( CodePage, 0, pszText, -1, pwszKeyword, cch ) == 0 )
        return E_FAIL;
      return S_OK;
    }
#endif
#endif

#ifdef HHCTRL
#ifndef HHA
    inline HRESULT SITEMAP_ENTRY::GetTitle( SITE_ENTRY_URL* pUrl, WCHAR* pwszTitle, int cch )
    {
      ASSERT( pSiteMap );
      //ASSERT( pSiteMap->GetCodePage() );
      if( !pUrl->pszTitle ) {
        wcsncpy( pwszTitle, GetStringResourceW(IDS_UNTITLED), cch);
        pwszTitle[cch] = 0;
        return S_OK;
      }
      UINT CodePage = pSiteMap->GetCodePage();
      if( MultiByteToWideChar( CodePage, 0, pszText, -1, pwszTitle, cch) == 0 )
        return E_FAIL;
      return S_OK;
    }
#endif
#endif



extern const char txtBeginList[];       // "<UL>"
extern const char txtEndList[]  ;       // "</UL>"
extern const char txtBeginListItem[];   // "<LI"
extern const char txtSitemap[];         // "<!Sitemap";
extern const char txtSitemap1[];        // "<!--Sitemap";
extern const char txtSitemap2[];        // "<!Sitemap";
extern const char txtParam[];           // "<param name";
extern const char txtValue[];           // "value";
extern const char txtBeginHref[];       // "<A HREF";
extern const char txtEndHref[];         // "</A>";
extern const char txtBeginObject[];     // "<OBJECT"
extern const char txtEndObject[];       // "</OBJECT>"
extern const char txtSiteMapObject[];   // "text/sitemap";
extern const char txtSitemapProperties[]; // "text/site properties";
extern const char txtBackGround[];      // "Background";
extern const char txtForeGround[];      // "Foreground";
extern const char txtFont[];            // "Font";
extern const char txtImageList[];       // "ImageList";
extern const char txtImageWidth[];      // "Image Width";
extern const char txtColorMask[];       // "Color Mask";
extern const char txtNumberImages[];    // "NumberImages";
extern const char txtExWindowStyles[];  // "ExWindow Styles";
extern const char txtWindowStyles[];    // "Window Styles";
extern const char txtType[];            // "type";
extern const char txtNo[];              // "No";
extern const char txtFolderType[];      // "Folder";
extern const char txtEndTag[];          // "</";
extern const char txtInfoTypeDeclaration[]; // "InformationTypeDecl";


// Param labels

extern const char txtParamType[];         // "Type";
extern const char txtParamTypeExclusive[];// "TypeExclusive";
extern const char txtParamTypeHidden[];   // "TypeHidden";
extern const char txtParamTypeDesc[];     // "TypeDesc";
extern const char txtParamCategory[];     // "Category";
extern const char txtParamCategoryDesc[]; // "CategoryDesc";
extern const char txtParamName[];         // "Name";
extern const char txtParamUrl[];          // "URL";
extern const char txtParamIcon[];         // "Icon";
extern const char txtParamLocal[];        // "Local";
extern const char txtParamFrame[];        // "Frame";
extern const char txtParamWindow[];       // "Window";
extern const char txtParamNew[];          // "New";
extern const char txtParamComment[];      // "Comment";
extern const char txtParamImageNumber[];  // "ImageNumber";
extern const char txtParamDisplay[];      // "Display";
extern const char txtParamKeyword[];      // "Keyword";
extern const char txtParamInstruction[];  // "Instruction";
extern const char txtParamSectionTitle[]; // "Section Title";
extern const char txtSeeAlso[];           // "See Also";
extern const char txtImageType[];         // "ImageType";
extern const char txtFavorites[];         // "Favorites";
extern const char txtAutoGenerated[];     // "Auto Generated";
extern const char txtSSInclusive[];         // "Inclusive";
extern const char txtSSExclusive[];         // "Exclusive";

//////////////////////////////////// Functions ///////////////////////////////

int  CompareSz(PCSTR psz, PCSTR pszSub);
HASH HashFromSz(PCSTR pszKey);
BOOL ReplaceEscapes(PCSTR pszSrc, PSTR pszDst, int);    // pszSrc can be same as pszDst

#endif // __SITEMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\strtable.cxx ===
#include "strtable.h"
#include "hhatable.h"

#include "hhctrl.rcv"

STRINGTABLE DISCARDABLE 
BEGIN
	IDS_OOM 				"There is not enough memory available for this task.\nQuit one or more programs to increase available memory, and then try again."

	// Font must be true-type, or tab control could break

	IDS_DEFAULT_FONT		"Arial,8"	// used for buttons and other UI elements
	IDS_NO_SUCH_KEYWORD 	"The word you have typed is not in the Index. Type another word or select one from the list."
	IDS_NEWER_VERSION		"You need a newer version of HHCTRL.OCX to be able to read this file."
	IDS_FIND_YOURSELF		"The file \042%s\042 cannot be found. Do you want to try to find this file yourself?"

	IDS_PROPERTIES			"Microsoft HTML Help Control Properties"

	IDS_BAD_PARAMETERS		"This control does not have the correct parameters and will not function."
	IDS_MSGBOX_TITLE		"HTML Help ActiveX Control"
	IDS_CANT_FIND_FILE		"Cannot locate \042%s\042."
	IDS_EXPAND_ALL			"&Open all"
	IDS_CONTRACT_ALL		"&Close all"
	IDS_HELP_TOPICS 		"Help Topics"
	IDS_PRIMARY_URL 		"Primary"
	IDS_SECONDARY_URL		"Secondary"
	IDS_BROWSER_FAVORITES	"Your Favorites"
	IDS_CUSTOMIZE_INFO_TYPES "Customize..."
	IDS_VIEW_RELATED		"View ";
	IDS_WEB_TB_TEXTROWS 	"1" // number of text rows for toolbar
	IDS_UNTITLED			"untitled"

	IDTB_EXPAND 			"<< Show"
	IDTB_CONTRACT			"Hide >>"
	IDTB_STOP				"Stop"
	IDTB_REFRESH			"Refresh"
	IDTB_BACK				"Back"
	IDTB_FORWARD			"Forward"
	IDTB_HOME				"Home"
	IDTB_BROWSE_FWD 		"Next"
	IDTB_BROWSE_BACK		"Previous"
	IDTB_SYNC				"Locate"
	IDTB_PRINT				"Print"
	IDTB_OPTIONS			"Options"
	IDTB_NOTES				"Notes"
	IDTB_CONTENTS			"Contents"
	IDTB_INDEX				"Index"
	IDTB_SEARCH 			"Search"
	IDTB_HISTORY			"History"
	IDTB_FAVORITES			"Favorites"
	IDTB_JUMP1				""
	IDTB_JUMP2				""

	IDS_TAB_CONTENTS		"Contents"
	IDS_TAB_INDEX			"Index"
	IDS_TAB_SEARCH			"Search"
	IDS_TAB_HISTORY 		"History"
	IDS_TAB_FAVORITES		"Favorites"
#ifdef INTERNAL
	IDS_TAB_ASKME			"Ask Me"
#endif

#if 0
	// Related Topics in all languages

	IDS_ENGLISH_RELATED 			"Related Topics"
	IDS_GERMAN_RELATED				"Siehe auch"
	IDS_ARABIC_RELATED				" "
	IDS_HEBREW_RELATED				" "
	IDS_SIMPLE_CHINESE_RELATED		""
	IDS_TRADITIONAL_CHINESE_RELATED "DD"
	IDS_JAPANESE_RELATED			"A"
	IDS_FRENCH_RELATED				"Rubriques connexes"
	IDS_SPANISH_RELATED 			"Temas relacionados"
	IDS_ITALIAN_RELATED 			"Argomenti correlati"
	IDS_SWEDISH_RELATED 			"Nrliggande information"
	IDS_DUTCH_RELATED				"Verwante onderwerpen"
	IDS_BRAZILIAN_RELATED			"Tpicos relacionados"
	IDS_NORGEWIAN_RELATED			"Beslektede emner"
	IDS_DANISH_RELATED				"Relaterede emner"
	IDS_FINNISH_RELATED 			"Aiheeseen liittyvi ohjeita"
	IDS_PORTUGUESE_RELATED			"Tpicos Relacionados"
	IDS_POLISH_RELATED				"Pokrewne tematy"
	IDS_HUNGARIAN_RELATED			"Kapcsold tmakrk"
	IDS_CZECH_RELATED				"Pbuzn tmata"
	IDS_SLOVENIAN_RELATED			"Sorodne teme"
	IDS_RUSSIAN_RELATED 			" "
	IDS_GREEK_RELATED				" "
	IDS_TURKISH_RELATED 			"lgili Konular"
	IDS_CATALAN_RELATED 			"Temes relacionats"
	IDS_BASQUE_RELATED				"Inguruko gaiak"
	IDS_SLOVAK_RELATED				"Prbuzn tmy"
#endif

	// Display button for Index

	IDS_ENGLISH_DISPLAY 			"Display"
	IDS_ENGLISH_ADD 				"Add..."
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\stdenum.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

//
// implementation of a generic enumerator object.
//
#include "header.h"
#include "StdEnum.H"

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement)
{
    m_pEnumClonedFrom = NULL;
}

// #pragma warning(default:4355)  // using 'this' in constructor

CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
        m_pEnumClonedFrom->Release();
    else {
		if (m_rgElements)
			lcFree(m_rgElements);
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, m_iid)) {
        ExternalAddRef();
        *ppvObjOut = (IEnumGeneric *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
    CStandardEnum *pNewEnum;

    pNewEnum = new CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement);
    RETURN_ON_NULLALLOC(pNewEnum);

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;

    // AddRef() ourselves on their behalf.
    //
    AddRef();
    *ppEnumClone = (IEnumGeneric *)pNewEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\subfile.h ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __SUBFILE_H__
#define __SUBFILE_H__

#include "hhtypes.h"

// we have three possible caching schemes:

// HH_FAST_CACHE - fast but its a hog!
//
// We store a small number of pages (2-3) for each unique
// title and subfile combination.  This results is quite of bit
// of memory being used per collection but oh boy is it fast!
//
//#define HH_FAST_CACHE

// HH_EFFICIENT_CACHE - slow but it saves memory!
//
// We store a small number of moderate pages (2-3) for each unique
// subfile regardless of the title it came from.  This results in an
// efficient use of memory since like subfiles, such as #TOCIDX, share
// the same group of cache pages instead of having their own uniqe group
// per title.  However, this method slows things down since multiple reads
// from the same named subfile accross several titles results in many
// cache misses.
//
//#define HH_EFFICIENT_CACHE

// HH_SHARED_CACHE - nice balance of speed and size!
//
// We store a large number of pages (16+) for the entire collection.
// This result is a fixed quantity of cache pages regardless of number
// and type of subfiles we have.  It utilizes memory well since we can
// access multiple subfiles of the same name accross several titles
// effectively yielding a larger pool of cache pages.
//
// [paulti] - We want to use this method exclusively.  Please see me
//            if you want to change this for any reason.
//
#define HH_SHARED_CACHE

#if defined ( HH_FAST_CACHE )
#define CACHE_PAGE_COUNT 3
#elif defined ( HH_EFFICIENT_CACHE )
#define CACHE_PAGE_COUNT 5
#else // HH_SHARED_CACHE
#define CACHE_PAGE_COUNT 32
#endif

class CSubFileSystem;
class CExTitle;

typedef struct page {
    CExTitle* pTitle;
    DWORD     dwPage;
    HASH      hashPathname;
    DWORD     dwLRU;
    BYTE      rgb[PAGE_SIZE];
} PAGE;

//////////////////////////////////////////////
//
//  CPagesList
//
//////////////////////////////////////////////

class CPagesList
{
    friend class CPagedSubfile;
    friend class CPages;

public:
    CPagesList() { m_pFirst = 0; }
    ~CPagesList();

private:
    CPages* m_pFirst;
    CPages* GetPages( HASH );

};

////////////////////////////////////////
//
//  CPages
//
////////////////////////////////////////

class CPages
{
public:
    void  Flush( CExTitle* pTitle );

private:
    CPages( HASH );

    void* Find( const CExTitle *, HASH, DWORD );
    void* Alloc( CExTitle *, HASH, DWORD );
    void  Flush( void );

    CPages* m_pNext;
    HASH           m_hash;
    DWORD          m_dwLRUPage;
    DWORD          m_dwLRUCount;
    PAGE           m_pages[CACHE_PAGE_COUNT];

    friend class CPagedSubfile;
    friend class CPagesList;
};

//////////////////////////////////////////////
//
//  CPagedSubfile
//
//////////////////////////////////////////////

class CPagedSubfile
{
public:
   CPagedSubfile();
   ~CPagedSubfile();

   HRESULT Open(CExTitle *, LPCSTR);

   void* Offset(DWORD dwOffs);
   void* Page(DWORD iPage);

private:
   CSubFileSystem* m_pCSubFileSystem;
   CExTitle*       m_pTitle;
   HASH            m_hashPathname;
   HASH            m_hash;
   DWORD           m_cbSize;
   CPages*  m_pPages;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\stdenum.h ===
//=--------------------------------------------------------------------------=
// StdEnum.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STDENUM_H_

#include "Unknown.H"

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public CUnknownObject, public IEnumGeneric {

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

    CStandardEnum(REFIID riid, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    ~CStandardEnum();

private:
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);
};



#define _STDENUM_H_
#endif // _STDENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\strcoll.h ===
//=--------------------------------------------------------------------------=
// StrColl.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the definitions for the various string collections we'll use
//
#ifndef _STRCOLL_H_

#include "CommDlgInterfaces.H"



//=--------------------------------------------------------------------------=
// the CStringsCollection class basically works with a safearray to expose the
// collection, and uses the safearray functions to maniplate it.
//=--------------------------------------------------------------------------=
// NOTES: 9.95 - this collection assumes that the safearray lbound is
//        zero!
//=--------------------------------------------------------------------------=
//
class CStringCollection {

  public:
    // a couple of methods that are common
    //
    STDMETHOD(get_Count)(THIS_ long FAR* pcStrings);
    STDMETHOD(get_Item)(THIS_ long lIndex, BSTR FAR* pbstrItem);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppUnkNewEnum);

    CStringCollection(SAFEARRAY *);
    virtual ~CStringCollection();

  protected:
    // what the collection will work with.
    //
    SAFEARRAY *m_psa;
};

class CStringDynaCollection : public CStringCollection {

  public:
    // in addition to the CStringCollection methods, we'll have
    //
    STDMETHOD(put_Item)(THIS_ long lIndex, BSTR bstrItem);
    STDMETHOD(Add)(THIS_ BSTR bstrNew);
    STDMETHOD(Remove)(THIS_ long lIndex);

    CStringDynaCollection(SAFEARRAY *);
    virtual ~CStringDynaCollection();

};


#define _STRCOLL_H_
#endif // _STRCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\subfile.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "header.h"

#include "subfile.h"
#include "fs.h"
#include "toc.h"

static CPagesList listSubfiles;

//////////////////////////////////////////////
//
//  CPagesList
//
//////////////////////////////////////////////

CPagesList::~CPagesList()
{
    CPages* p;

    while (p = m_pFirst)
    {
        m_pFirst = p->m_pNext;
        delete p;
    }
}

CPages* CPagesList::GetPages( HASH hash )
{
    CPages * p;

    for (p = m_pFirst; p; p = p->m_pNext)
        if ( hash == p->m_hash )
            return p;

    p = new CPages( hash );
    p->m_pNext = m_pFirst;
    m_pFirst = p;

    return p;
}

////////////////////////////////////////
//
//  CPages
//
////////////////////////////////////////

CPages::CPages( HASH hash )
{
    m_pNext = 0;
    m_hash = hash;
    Flush();
}

void* CPages::Find(const CExTitle * pTitle, HASH hashPathname, DWORD dwPage)
{
  int i;
   
   for( i = 0; i < CACHE_PAGE_COUNT; i++ )
   {
      // test if lowest LRU
      if( m_pages[i].dwLRU < m_pages[m_dwLRUPage].dwLRU ) {
        m_dwLRUPage = i;
      }

      if( m_pages[i].dwLRU &&
          m_pages[i].hashPathname == hashPathname &&
          m_pages[i].dwPage == dwPage &&
          m_pages[i].pTitle == pTitle )
      {
         m_pages[i].dwLRU = ++m_dwLRUCount;  // update LRU
         return m_pages[i].rgb;
      }
   }

   return NULL;
}

void* CPages::Alloc(CExTitle * pTitle, HASH hashPathname, DWORD dwPage)
{
    // if we reached the max LRU number then flush the cache and start over
    if( m_dwLRUCount == ((DWORD) -1) )
      Flush();
    
    m_pages[m_dwLRUPage].dwLRU = ++m_dwLRUCount;
    m_pages[m_dwLRUPage].hashPathname = hashPathname;
    m_pages[m_dwLRUPage].dwPage = dwPage;
    m_pages[m_dwLRUPage].pTitle = pTitle;

    return m_pages[m_dwLRUPage].rgb;
}

void CPages::Flush(void)
{
    int i;

    for( i = 0; i < CACHE_PAGE_COUNT; i++ ) 
        m_pages[i].dwLRU = 0;
    m_dwLRUPage = 0;
    m_dwLRUCount = 0;
}

void CPages::Flush( CExTitle* pTitle )
{
    if( !pTitle )
      return;

    int i;

    for( i = 0; i < CACHE_PAGE_COUNT; i++ )
      if( m_pages[i].pTitle == pTitle )
        m_pages[i].dwLRU = 0;
}


//////////////////////////////////////////////
//
//  CPagedSubfile
//
//////////////////////////////////////////////

CPagedSubfile::CPagedSubfile()
{
   m_pCSubFileSystem = 0;          // type CSubFileSystem from fs.h/fs.cpp
   m_pTitle = 0;
   m_pPages = 0;
   m_cbSize = 0xFFFFFFFF;
}

CPagedSubfile::~CPagedSubfile()
{
   if ( m_pCSubFileSystem )
      delete m_pCSubFileSystem;

   // flush all of its owned pages since
   // the same pTitle value may be re-used and thus
   // the cache is invalid
   m_pPages->Flush( m_pTitle );
}

HRESULT CPagedSubfile::Open(CExTitle * pTitle, LPCSTR lpsz)
{
   if (m_pCSubFileSystem || m_pTitle || m_pPages || !pTitle->m_pCFileSystem )
      return E_FAIL;

   m_pTitle = pTitle;

   // hash the filename
   m_hashPathname = HashFromSz( lpsz );

#ifdef _DEBUG
   char sz[1024];
   wsprintf( sz, "Hash:%d File:%s\n", m_hashPathname, lpsz );
   OutputDebugString( sz );
#endif

#if defined( HH_FAST_CACHE )
   // keep CACHE_PAGE_COUNT small (2-3) and hash the title and the filename
   char szHash[MAX_PATH*2];
   strcpy( szHash, pTitle->GetInfo2()->GetShortName() );
   strcat( szHash, "::" );
   strcat( szHash, lpsz );
   m_hash = HashFromSz( szHash );
#elif defined ( HH_EFFICIENT_CACHE )
   // keep CACHE_PAGE_COUNT moderately low (3-5) and hash just the filename
   m_hash = HashFromSz( lpsz );
#else // HH_SHARED_CACHE
   // keep CACHE_PAGE_COUNT high (30+) and have only one shared cache group
   m_hash = HashFromSz( "HTMLHelpSharedCache" );
#endif

   if (!(m_pPages = listSubfiles.GetPages(m_hash)))
       return E_FAIL;

   m_pCSubFileSystem = new CSubFileSystem(pTitle->m_pCFileSystem);

   if(FAILED(m_pCSubFileSystem->OpenSub(lpsz)))
   {
       delete m_pCSubFileSystem;
       m_pCSubFileSystem = NULL;
       return E_FAIL;
   }
   m_cbSize = m_pCSubFileSystem->GetUncompressedSize();

   return S_OK;
}

void* CPagedSubfile::Offset(DWORD dwOffs)
{
   DWORD dwPage;
   void* pv;

   if (dwOffs >= m_cbSize)
       return NULL;

   dwPage = dwOffs / PAGE_SIZE;

   dwOffs -= (dwPage * PAGE_SIZE);

   if (pv = Page(dwPage))
      return (BYTE*)pv + dwOffs;
   else
      return NULL;
}

void* CPagedSubfile::Page(DWORD dwPage)
{
    void* pv;

    if (pv = m_pPages->Find(m_pTitle, m_hashPathname, dwPage))
        return pv;

    if (!(pv = m_pPages->Alloc(m_pTitle, m_hashPathname, dwPage)))
        return NULL;

    DWORD li = dwPage * PAGE_SIZE;

    if ( m_pCSubFileSystem->SeekSub(li,0) != li )
       return NULL;

    // init the page in case we don't read it all...
    //
#ifdef _DEBUG
    memset(pv,0xFF,PAGE_SIZE);
#endif

    ULONG cb;
    if (FAILED(m_pCSubFileSystem->ReadSub(pv, PAGE_SIZE, &cb)))
        return NULL;

   return pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\strtable.h ===
// this must be defined for any server that has propety pages. it must be one
// thousand.

#define IDS_PROPERTIES                        1000

// this is defined for all inproc servers that use satellite localization. it
// must be 1001

#define IDS_SERVERBASENAME                    1001

// DO NOT CHANGE THIS VALUE! hha.dll expects this string resource

#define IDS_VERSION                 0xD000

#define IDTB_EXPAND                 200
#define IDTB_CONTRACT               201
#define IDTB_STOP                   202
#define IDTB_REFRESH                203
#define IDTB_BACK                   204
#define IDTB_HOME                   205
#define IDTB_SYNC                   206
#define IDTB_PRINT                  207
#define IDTB_OPTIONS                208
#define IDTB_FORWARD                209
#define IDTB_NOTES                  210
#define IDTB_BROWSE_FWD             211
#define IDTB_BROWSE_BACK            212
#define IDTB_CONTENTS               213
#define IDTB_INDEX                  214
#define IDTB_SEARCH                 215
#define IDTB_HISTORY                216
#define IDTB_FAVORITES              217
#define IDTB_JUMP1                  218
#define IDTB_JUMP2                  219
#define IDTB_HILITE                 220
#define IDTB_CUSTOMIZE              221
#define IDTB_ZOOM                   222
#define IDTB_TOC_NEXT               223
#define IDTB_TOC_PREV               224

#define IDTB_AUTO_SHOW              248     // not a toolbar button, but a command
#define IDTB_AUTO_HIDE              249

#define ID_EXPAND_ALL               250
#define ID_CONTRACT_ALL             251
#define ID_CUSTOMIZE_INFO_TYPES     252
#define ID_PRINT                    253
#define ID_TV_SINGLE_CLICK          256

#define IDM_RELATED_TOPIC   0xE000 // reserve the next 4096 values

#ifdef _DEBUG
#define ID_VIEW_MEMORY     0xEFFC
#define ID_DEBUG_BREAK     0xEFFD
#endif
#define ID_VIEW_ENTRY      0xEFFE
#define ID_JUMP_URL        0xEFFF  // NO button/menu commands can be defined higher then this 0xF000

// Our strings messages

#define IDS_DEFAULT_RES_FONT_NT5_WIN98 1023
#define IDS_DEFAULT_CONTENT_FONT 1024
#define IDS_CANT_FIND_FILE  1025
#define IDS_BAD_PARAMETERS  1026
#define IDS_DEFAULT_RES_FONT    1027
#define IDS_NO_SUCH_KEYWORD 1028
#define IDS_EXPAND_ALL      1029
#define IDS_CONTRACT_ALL    1030
#define IDS_PRINT           1031
#define IDS_IE_PRINT        1032
#define IDS_LIST_TOPICS     1033
#define IDS_IE_MSGBOX       1034
#define IDS_HELP_TOPICS     1035
#define IDS_PRIMARY_URL     1036
#define IDS_SECONDARY_URL   1037
#undef  IDS_BROWSER_FAVORITES
#define IDS_BROWSER_FAVORITES   1038
#define IDS_CUSTOMIZE_INFO_TYPES    1039
#define IDS_VIEW_RELATED    1040
#define IDS_WEB_TB_TEXTROWS 1041
#undef  IDS_UNTITLED
#define IDS_UNTITLED        1042
#define IDS_TAB_CONTENTS    1043
#define IDS_TAB_INDEX       1044
#define IDS_TAB_SEARCH      1045
#define IDS_TAB_HISTORY     1046
#define IDS_TAB_FAVORITES   1047
#define IDS_NEWER_VERSION   1048
#define IDS_FIND_YOURSELF   1049
#define IDS_IDH_OK          1050
#define IDS_IDH_CANCEL      1051
#define IDS_IDH_HELP        1052
#define IDS_IDH_MISSING_CONTEXT 1053
#undef  IDS_UNKNOWN
#define IDS_UNKNOWN        1054
#define IDS_DEF_WINDOW_CAPTION 1056
#define IDS_BAD_ITIRCL      1057
#define IDS_SEARCH_FAILURE  1058
#define IDS_NO_FTS_DATA     1059
#define IDS_NO_TOPICS_FOUND 1060
#define IDS_TYPE_KEYWORD    1061
#define IDS_SELECT_TOPIC    1062
#define IDS_OPTION_HIDE             1063
#define IDS_OPTION_BACK             1064
#define IDS_OPTION_FORWARD          1065
#define IDS_OPTION_HOME             1066
#define IDS_OPTION_STOP             1067
#define IDS_OPTION_REFRESH          1068
#define IDS_OPTION_SYNC             1069
#define IDS_OPTION_CUSTOMIZE        1070
#define IDS_OPTION_PRINT            1071
#define IDS_OPTION_HILITING_ON      1072
#define IDS_OPTION_HILITING_OFF     1073
#define IDS_OPTION_SHOW             1074
#define IDS_INCORRECT_SYNTAX        1075
#define IDS_TAB_VERT_PADDING        1076
#define IDS_TAB_HORZ_PADDING        1077

#define IDS_OPTION_SELECTALL        1080
#define IDS_OPTION_VIEWSOURCE       1081
#define IDS_OPTION_PROPERTIES       1082
#define IDS_OPTION_COPY             1083
#define IDS_OPTION_IE_OPTIONS    1084

#define IDS_REMOVABLE_MEDIA_MESSAGE_FORMAT  1100
#define IDS_REMOVABLE_MEDIA_CDROM           1101
#define IDS_REMOVABLE_MEDIA_DISK            1102

#define IDS_SEARCH_TOPIC            1103
#define IDS_SAMPLE_APPLICATION      1104
#define IDS_INSUFFICIENT_SPACE      1105
#define IDS_CORRUPTED_HTML          1106
#define IDS_GATHERING_PRINTS        1107
#define IDS_TOPIC_UNAVAILABLE       1108
#define IDS_JUMP_URL                1109
#define IDS_PRINTING                1110
#define IDS_PRINT_CAPTION           1111
#define IDS_SUBSET_NAME_EXISTS      1112
#define IDS_OVERRITE_SUBSET_NAME    1113
#define IDS_TITLE_NAME_SUBSET       1114
#define IDS_NAME_ALREADY_USED       1115
#define IDS_NO_NAME                 1116
#define IDS_CHOOSE_NAME             1117
#define IDS_MERGE_PROMPT            1118

#define IDS_REQUIRES_HTMLHELP       1900

// String Resources for the AdvSearch Nav Pane.
#define IDS_ADVSEARCH_CONJ_AND      1200
#define IDS_ADVSEARCH_CONJ_OR       1201
#define IDS_ADVSEARCH_CONJ_NEAR     1202
#define IDS_ADVSEARCH_CONJ_NOT      1203
#define IDS_ADVSEARCH_HEADING_TITLE     1204
#define IDS_ADVSEARCH_HEADING_LOCATION  1205
#define IDS_ADVSEARCH_HEADING_RANK      1206
#define IDS_ADVSEARCH_SEARCHIN_PREVIOUS 1207
//#define IDS_ADVSEARCH_SEARCHIN_CURRENT  1208
#define IDS_ADVSEARCH_SEARCHIN_ENTIRE   1208
#define IDS_ADVSEARCH_FOUND             1209
#define IDS_SAVESUBSET                  1210
#define IDS_SAVESUBSET_TITLE            1211
#define IDS_SAVEERROR                   1212
#define IDS_SAVEERROR_TITLE             1213
#define IDS_NEW                         1214

// String resources necessary for implementing structural subsets.
#define IDS_SAVE_FILTER                 1230
#define IDS_BAD_RANGE_NAME              1231
#define IDS_OVERWRITE                   1232
#define IDS_UNTITLED_SUBSET             1233
#define IDS_DEFINE_SUBSET               1234
#define IDS_SUBSET_UI                   1235

// String resources for the last error messages.
#define IDS_HH_E_NOCONTEXTIDS           1300
#define IDS_HH_E_FILENOTFOUND           1301
#define IDS_HH_E_INVALIDHELPFILE        1302
#define IDS_HH_E_CONTEXTIDDOESNTEXIT    1303

#define IDS_HH_E_KEYWORD_NOT_FOUND       1400
#define IDS_HH_E_KEYWORD_IS_PLACEHOLDER  1401
#define IDS_HH_E_KEYWORD_NOT_IN_SUBSET   1402
#define IDS_HH_E_KEYWORD_NOT_IN_INFOTYPE 1403
#define IDS_HH_E_KEYWORD_EXCLUDED        1404
#define IDS_SWITCH_SUBSETS               1405

#define IDS_REMOVABLE_MEDIA_MESSAGE_FORMAT2 1500
#define IDS_REMOVABLE_MEDIA_REMOTE          1501
#define IDS_REMOVABLE_MEDIA_FIXED           1502

#ifdef _DEBUG
#define IDS_TAB_ASKME       1148
#endif

#define IDS_MSGBOX_TITLE    2049

#define IDS_ENGLISH_RELATED             4096
#define IDS_GERMAN_RELATED              4097
#define IDS_ARABIC_RELATED              4098
#define IDS_HEBREW_RELATED              4099
#define IDS_SIMPLE_CHINESE_RELATED      4100
#define IDS_TRADITIONAL_CHINESE_RELATED 4101
#define IDS_JAPANESE_RELATED            4102
#define IDS_FRENCH_RELATED              4103
#define IDS_SPANISH_RELATED             4104
#define IDS_ITALIAN_RELATED             4105
#define IDS_SWEDISH_RELATED             4106
#define IDS_DUTCH_RELATED               4107
#define IDS_BRAZILIAN_RELATED           4108
#define IDS_NORGEWIAN_RELATED           4109
#define IDS_DANISH_RELATED              4110
#define IDS_FINNISH_RELATED             4111
#define IDS_PORTUGUESE_RELATED          4112
#define IDS_POLISH_RELATED              4113
#define IDS_HUNGARIAN_RELATED           4114
#define IDS_CZECH_RELATED               4115
#define IDS_SLOVENIAN_RELATED           4116
#define IDS_RUSSIAN_RELATED             4117
#define IDS_GREEK_RELATED               4118
#define IDS_TURKISH_RELATED             4119
#define IDS_CATALAN_RELATED             4120
#define IDS_BASQUE_RELATED              4121
#define IDS_SLOVAK_RELATED              4122
#define IDS_FILE_ERROR                      4123
#define IDS_ENGLISH_DISPLAY             4128
#define IDS_ENGLISH_ADD                 4129
#define IDS_NO_HOMEPAGE                 4130
#define IDS_CHM_CHI_MISMATCH            4131
#define IDS_CANT_PRINT_FRAMESET         4132
#define IDS_UWAIT_TITLE                 4133
#define IDS_CONFIRM_ABORT               4134
#define IDS_HTML_HELP                   4135
#define IDS_ABOUT       4136
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\subset.cpp ===
/*****************************************************************************
 * Subset.cpp
 *
 * Copyright (C) Microsoft, 1989-1998
 * Feb 22, 1998
 *
 *  Modification History:
 *
 *  Ported to hhctrl.ocx from the old B2 code base.
 *
 *****************************************************************************/
#include "header.h"
#include "subset.h"
#include "resource.h"
#include "toc.h"
#include "cdefinss.h"
#include "verdef.h"
#include "secwin.h"

#define CmdID   LOWORD(wParam)
#define CmdCode HIWORD(wParam)
#define CmdHwnd (HWND)lParam
/*
 *  Defines, the EXPANDED define aids in intrepreting the proper bit in the
 *  FGT data structure depending on which LB we're operating on.
 */
#define EXPANDED(lb_id, ds) ((lb_id) ? ds->f_A_Open : ds->f_F_Open)
#define PRESENT(lb_id, ds) ((lb_id) ? ds->f_Available : ds->f_Filter)

// declare a static this pointer for our window procedures.
//
CDefineSS* CDefineSS::m_pThis;

//********************************************************************************
//
// CStructuralSubset Implementation - This is object representation of a subset.
//
//********************************************************************************


CSSList::CSSList()
{
   m_iSubSetCount = 0;
   m_pHeadSubSets = m_pFTS_SS = m_pF1_SS = m_pTOC_SS = m_pNew_SS = m_pEC_SS = NULL;
}

CSSList::~CSSList()
{
   CStructuralSubset *pSS, *pSSNext;

   pSS = m_pHeadSubSets;
   while ( pSS )
   {
      pSSNext = pSS->m_pNext;
      delete pSS;
      pSS = pSSNext;
   }
}

CStructuralSubset* CSSList::GetSubset(PSTR pszSSName)
{
   CStructuralSubset *pSS = m_pHeadSubSets;

   while ( pSS )
   {
      if (! lstrcmpi(pSS->GetName(), pszSSName) )
         return pSS;
      pSS = pSS->m_pNext;
   }
   return NULL;
}

void CSSList::DeleteSubset(CStructuralSubset* pSS, CStructuralSubset* pSSNew, /* == NULL */ HWND hWndUI /* == NULL */)
{
   CStructuralSubset *pSSCurrCB, *pSSl = m_pHeadSubSets;
   TCHAR szSel[MAX_SS_NAME_LEN];
   HWND hWndCB;
   INT_PTR i;
   CHHWinType* phh;

   if (! pSSNew )
      pSSNew = m_pEC_SS;

   if ( pSS->m_dwFlags & SS_READ_ONLY )
      return;

   if ( pSS == m_pFTS_SS )
      m_pFTS_SS = pSSNew;
   if ( pSS == m_pF1_SS )
      m_pF1_SS = pSSNew;
   if ( pSS == m_pTOC_SS )
      m_pTOC_SS = pSSNew;
   //
   // If we're given an hwnd, update the combo-box UI.
   //
   if ( hWndUI && (hWndCB = GetDlgItem(hWndUI, IDC_SS_PICKER)) )
   {
      //
      // Get the current CB selection and see if it's the one we're deleting ?
      //
      if ( ((i = SendMessage(hWndCB, CB_GETCURSEL, 0, 0L)) != -1) )
      {
		 GetDlgItemText(hWndUI, IDC_SS_PICKER, szSel, sizeof(szSel));

         pSSCurrCB = GetSubset(szSel);
         if ( pSSCurrCB == pSS )        // Yep, we're deleting the current one, select the new one.
         {
            SendMessage(hWndCB, CB_SELECTSTRING, -1, (LPARAM)pSSNew->GetName());
            if ( (phh = FindWindowIndex(hWndUI)) )
            {
               pSSNew->SelectAsTOCSubset(phh->m_phmData->m_pTitleCollection);
               phh->UpdateInformationTypes();                                   // This call re-draws the TOC.
            }
         }
      }
      if ( lstrcmpi(pSS->GetName(), pSSNew->GetName()) )
      {
         if ( (i = SendMessage(hWndCB, CB_FINDSTRING, -1, (LPARAM)pSS->GetName())) != -1 )
            SendMessage(hWndCB, CB_DELETESTRING, i, 0L);
      }
   }
   //
   // Take the delete victum out of the linked list.
   //
   while ( pSSl )
   {
      if ( pSSl->m_pNext == pSS )
      {
         pSSl->m_pNext = pSS->m_pNext;
         delete pSS;
         break;
      }
      pSSl = pSSl->m_pNext;
   }
   m_iSubSetCount--;
}

HRESULT CSSList::PersistSubsets(CExCollection* pCollection)
{
   LPCSTR lpszFQSSStore;
   HANDLE hFile;
   SSHEADER ssHeader;
   CStructuralSubset* pSS;
   CStructuralSubset* pSSCurr = NULL;
   PSS       pSSFile = NULL;
   unsigned long ulCnt;
   int iSSSize;
   int i = 0;

   if (! (pSS = m_pHeadSubSets) )
      return S_OK;
   //
   // Count'em
   //
   do
   {
      if ( pSS->IsTOC() )
         pSSCurr = pSS;
      if ( !pSS->IsEntire() && !pSS->IsEmpty() && !pSS->IsReadOnly() )
         i++;
   } while ( (pSS = GetNextSubset(pSS)) );
   //
   // Prepare a file.
   //
   if (! (lpszFQSSStore = pCollection->GetUserCHSLocalStoragePathnameByLanguage()) )
      return E_FAIL;
   hFile = CreateFile(lpszFQSSStore, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, 0);
   if ( hFile == INVALID_HANDLE_VALUE )
      return E_FAIL;
   //
   // Fill in the header, write out the header.
   //
   // Need to store the persisted subset in the header since it may be a predefine.
   //
   ssHeader.dwSig      = SS_FILE_SIGNATURE;
   ssHeader.dwVer      = (VER_PRODUCTVERSION_DW & 0x0000);
   ssHeader.iSSCount   = i;
   ssHeader.dwFlags    = 0;
   if ( pSSCurr )
      lstrcpy(ssHeader.lpszCurrentSSName, pSSCurr->GetName());
   if (! WriteFile(hFile, &ssHeader, sizeof(SSHEADER), &ulCnt, NULL) )
   {
      MsgBox(IDS_PERSIST_SUBSET_ERR, MB_OK | MB_ICONHAND);
      return E_FAIL;
   }
   //
   // Write out the subsets.
   //
   pSS = m_pHeadSubSets;
   do
   {
      if ( pSS->IsEntire() || pSS->IsEmpty() || pSS->IsReadOnly() )
         continue;
      int iHashCnt = pSS->GetHashCount();
      iSSSize = (sizeof(SS) + ((iHashCnt - 1) * sizeof(DWORD)));
      if ( (pSSFile = (PSS)lcReAlloc(pSSFile, iSSSize)) )
      {
         pSSFile->iHashCount = iHashCnt;
         lstrcpy(pSSFile->lpszSSName, pSS->GetName());
         lstrcpy(pSSFile->lpszSSID, pSS->GetID());
         pSSFile->dwFlags = pSS->m_dwFlags;
         while ( --iHashCnt >= 0)
            pSSFile->dwHashes[iHashCnt] = pSS->EnumHashes(iHashCnt);
         if (! WriteFile(hFile, pSSFile, iSSSize, &ulCnt, NULL) )
         {
            MsgBox(IDS_PERSIST_SUBSET_ERR, MB_OK | MB_ICONHAND);
            lcFree(pSSFile);
            CloseHandle(hFile);
            return E_FAIL;
         }
      }
   } while ( (pSS = GetNextSubset(pSS)) );

   lcFree(pSSFile);
   CloseHandle(hFile);
   return S_OK;
}

HRESULT CSSList::RestoreSubsets(CExCollection* pCollection, PSTR pszRestoreSS)
{
   LPCSTR lpszFQSSStore;
   HANDLE hFile;
   SSHEADER ssHeader;
   PSS pSSFile;
   CStructuralSubset* pSS;
   unsigned long ulHashCnt, ulRead;
   HRESULT hr = E_FAIL;

   if (! (pSSFile = (PSS)lcMalloc(sizeof(SS) + sizeof(DWORD) * 50)) )
      return hr;
   lpszFQSSStore = pCollection->GetUserCHSLocalStoragePathnameByLanguage();
   hFile = CreateFile(lpszFQSSStore, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
   if ( hFile == INVALID_HANDLE_VALUE)
   {
      lpszFQSSStore = pCollection->GetUserCHSLocalStoragePathname();
      hFile = CreateFile(lpszFQSSStore, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
      if ( hFile == INVALID_HANDLE_VALUE)
      {
         lpszFQSSStore = pCollection->GetLocalStoragePathname(".chs");
         hFile = CreateFile(lpszFQSSStore, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
         if ( hFile == INVALID_HANDLE_VALUE )
         {
           lcFree(pSSFile);
           return hr;
         }
      }
   }
   //
   // Read the header.
   //
   if (! ReadFile(hFile, &ssHeader, sizeof(SSHEADER), &ulRead, NULL) )
      goto crap_out;
   if ( ssHeader.dwSig != SS_FILE_SIGNATURE )
      goto crap_out;
   //
   // Get the subsets.
   //
   while ( ssHeader.iSSCount-- )
   {
      if (! ReadFile(hFile, &ulHashCnt, sizeof(int), &ulRead, NULL) )
         goto crap_out;
      if ( ulHashCnt > 51 )
      {
         if (! (pSSFile = (PSS)lcReAlloc(pSSFile, sizeof(SS) + (sizeof(DWORD) * ulHashCnt))) )
            goto crap_out;
      }
      pSSFile->iHashCount = ulHashCnt;
      unsigned long ulAmt = ((sizeof(SS) - sizeof(int)) + (sizeof(DWORD) * (ulHashCnt - 1)));
      if (! ReadFile(hFile, (((BYTE*)pSSFile) + sizeof(int)), ulAmt, &ulRead, NULL) )
         goto crap_out;
      //
      // Now create a CStructuralSubset from the data.
      //
      pSS = new CStructuralSubset(pSSFile->lpszSSName);
      pSS->m_dwFlags = pSSFile->dwFlags;
      pSS->m_dwFlags &= ~(SS_FTS | SS_TOC | SS_F1);       // Insure selection bits are reset.
      lstrcpy(pSS->m_szSSID, pSSFile->lpszSSID);
      while ( ulHashCnt )
         pSS->AddHash(pSSFile->dwHashes[--ulHashCnt]);
      //
      // Add the subset to the list appropiatly.
      //
      AddSubset(pSS);
      if (! lstrcmpi(ssHeader.lpszCurrentSSName, pSS->GetName() ) )
      {
         SetFTS(pSS);
         SetTOC(pSS);
         SetF1(pSS);
      }
   }
   if ( pszRestoreSS )
      lstrcpy(pszRestoreSS, ssHeader.lpszCurrentSSName);
   hr = S_OK;
crap_out:
   lcFree(pSSFile);
   CloseHandle(hFile);
   return hr;
}

HRESULT CSSList::ReadPreDefinedSubsets(CExCollection* pCollection, PSTR pszRestoreSS)
{
   SSHEADER ssHeader;
   PSS pSSFile;
   CStructuralSubset* pSS;
   CSubFileSystem* pSubFS;
   unsigned long ulHashCnt, ulRead;
   HRESULT hr = E_FAIL;

   if (! (pSSFile = (PSS)lcMalloc(sizeof(SS) + sizeof(DWORD) * 50)) )
      return hr;

   if (! pCollection || !pCollection->GetMasterTitle() )
      return hr;

   pSubFS = new CSubFileSystem(pCollection->GetMasterTitle()->GetTitleIdxFileSystem());
   if ( !SUCCEEDED(pSubFS->OpenSub("predef.chs")) )
      goto crap_out;
   //
   // Read the header.
   //
   if ( !SUCCEEDED(pSubFS->ReadSub(&ssHeader, sizeof(SSHEADER), &ulRead)) )
      goto crap_out;
   if ( ssHeader.dwSig != SS_FILE_SIGNATURE )
      goto crap_out;
   //
   // Get the subsets.
   //
   while ( ssHeader.iSSCount-- )
   {
      if ( !SUCCEEDED(pSubFS->ReadSub(&ulHashCnt, sizeof(int), &ulRead)) )
         goto crap_out;
      if ( ulHashCnt > 51 )
      {
         if (! (pSSFile = (PSS)lcReAlloc(pSSFile, sizeof(SS) + (sizeof(DWORD) * ulHashCnt))) )
            goto crap_out;
      }
      pSSFile->iHashCount = ulHashCnt;
      unsigned long ulAmt = ((sizeof(SS) - sizeof(int)) + (sizeof(DWORD) * (ulHashCnt - 1)));
      if ( !SUCCEEDED(pSubFS->ReadSub((((BYTE*)pSSFile) + sizeof(int)), ulAmt, &ulRead)) )
         goto crap_out;
      //
      // Now create a CStructuralSubset from the data.
      //
      pSS = new CStructuralSubset(pSSFile->lpszSSName);
      pSS->m_dwFlags = pSSFile->dwFlags;
      pSS->m_dwFlags &= ~(SS_FTS | SS_TOC | SS_F1);       // Insure selection bits are reset.
      pSS->m_dwFlags |= SS_READ_ONLY;
      lstrcpy(pSS->m_szSSID, pSSFile->lpszSSID);
      while ( ulHashCnt )
         pSS->AddHash(pSSFile->dwHashes[--ulHashCnt]);
      //
      // Add the subset to the list appropiatly.
      //
      AddSubset(pSS);
      if (! lstrcmpi(pszRestoreSS, pSS->GetName() ) )
      {
         SetFTS(pSS);
         SetTOC(pSS);
         SetF1(pSS);
      }
   }
   hr = S_OK;
crap_out:
   lcFree(pSSFile);
   delete pSubFS;
   return hr;
}

HRESULT CSSList::AddSubset(CStructuralSubset* pSS, HWND hWndUI /* == NULL */)
{
   CStructuralSubset *pSSl;
   HWND hWndCB;

   if (! m_pHeadSubSets )
      m_pHeadSubSets = pSS;
   else
   {
      pSSl = m_pHeadSubSets;
      while ( pSSl->m_pNext )
         pSSl = pSSl->m_pNext;

      pSSl->m_pNext = pSS;
      pSS->m_pNext = NULL;
   }
   m_iSubSetCount++;
   if ( hWndUI && (hWndCB = GetDlgItem(hWndUI, IDC_SS_PICKER)) )
   {
      if ( SendMessage(hWndCB, CB_FINDSTRING, -1, (LPARAM)pSS->GetName()) == -1 )
         SendMessage(hWndCB, CB_ADDSTRING, 0, (LPARAM)pSS->GetName());
   }
   return S_OK;
}

void CSSList::Set(CStructuralSubset* pSSNew, CStructuralSubset** pSSOld, DWORD dwFlags)
{
   if (! pSSNew )
      return;

   pSSNew->m_dwFlags |= dwFlags;
   if ( *pSSOld && (pSSNew != *pSSOld) )
      (*pSSOld)->m_dwFlags &= ~dwFlags;
   *pSSOld = pSSNew;
}

//********************************************************************************
//
// CStructuralSubset Implementation - This is object representation of a subset.
//
//********************************************************************************

CStructuralSubset::CStructuralSubset(PCSTR pszSubSetName)
{
   TCHAR* psz;
   int i = 0;

   m_szSSID[0] = '\0';

   if ( pszSubSetName )
   {
      if ( (psz = StrChr(pszSubSetName, '|')) )  // If the subset name contains an identifier, process it.
      {
         psz = AnsiNext(psz);
         lstrcpyn(m_szSubSetName, psz, MAX_SS_NAME_LEN);
         while ( pszSubSetName[i] != '|' && (i < MAX_SS_NAME_LEN) )
         {
            m_szSSID[i] = pszSubSetName[i];
            i++;
         }
         m_szSSID[i] = '\0';     // terminate.
      }
      else
         lstrcpyn(m_szSubSetName, pszSubSetName, MAX_SS_NAME_LEN);
   }
   else
   {
      m_szSubSetName[0] = '\0';
      m_szSSID[0] = '\0';
   }
   m_pdwHashes = NULL;
   m_iAllocatedCount = m_iHashCount = 0;
   m_dwFlags = 0;
   m_pNext = NULL;
}

CStructuralSubset::~CStructuralSubset()
{
   if ( m_pdwHashes )
      lcFree(m_pdwHashes);
}

HASH CStructuralSubset::EnumHashes(int pos)
{
   if ( !m_iHashCount || (pos >= m_iHashCount) || (pos < 0) )
      return 0;
   return m_pdwHashes[pos];
}

void CStructuralSubset::AddHash(DWORD dwHash)
{
   if ( (m_iHashCount &&  (!(m_iHashCount % 12))) || (m_iAllocatedCount == 0) )
   {
      m_iAllocatedCount += 12;
      m_pdwHashes = (HASH*)lcReAlloc(m_pdwHashes, sizeof(HASH) * m_iAllocatedCount);
   }
   m_pdwHashes[m_iHashCount] = dwHash;
   m_iHashCount++;
}

BOOL CStructuralSubset::IsTitleInSubset(CExTitle* pTitle)
{
   int i;

   for (i = 0; i < m_iHashCount; i++)
   {
      if ( m_pdwHashes[i] == pTitle->m_dwHash )
         return TRUE;
   }
   return FALSE;
}

//
// Function selects the subset as the current TOC filter by setting the f_IsVisable bit accordingly.
// NOTE: we don't bother selecting the bits for entire contents, this is special cased for performance reasons.
//
void CStructuralSubset::SelectAsTOCSubset(CExCollection* pCollection)
{
   CFolder*  pFgt;    // pointer to filtered group tree.
   UINT  i = 0;
   HASH  Hash;

   if ( IsEntire() || IsEmpty() )
      return;

   pFgt = pCollection->m_Collection.GetVisableRootFolder();
   //
   //  De-select all node's filter bits and select the proper
   //  tree nodes based on the hash list!
   //
   while ( pFgt )
   {
      MarkNode(pFgt, 0);        // Remove nodes by marking as not visable.  // RemoveNodeFromFilter(pFgt);
      pFgt = pFgt->pNext;
   }
   while ( Hash = EnumHashes(i++) )
   {
      if ( (pFgt = pCollection->m_pCSlt->HashToCFolder(Hash)) )
         MarkNode(pFgt, 1);     // Add nodes by marking as "visable".       // AddNode2Filter(pFgt);
   }
}

void CStructuralSubset::MarkNode(CFolder* pFgti, BOOL bVisable)
{
   CFolder*   pFgt;
   CFolder*   pFgtLast;

   // First, mark the node and any children of the node.
   //
   pFgt = pFgti;
   if ( pFgt->pKid )
   {
      while ( pFgt )
      {
         do
         {
            pFgt->f_IsVisable = bVisable;
            pFgtLast = pFgt;
            pFgt = pFgt->pKid;

         } while ( pFgt );
         pFgt = pFgtLast;
         while ( pFgt && (! (pFgt->pNext)) )
         {
            if ( pFgt->pParent != pFgti )
               pFgt = pFgt->pParent;
            else
               break;
         }
         if ( pFgt )
            pFgt = pFgt->pNext;
      }
   }
   // Next, assure any parents of the node are properly marked.
   //
   pFgt = pFgti;
   pFgt->f_IsVisable = bVisable;

   while ( (pFgt = pFgt->pParent) )
      pFgt->f_IsVisable = bVisable;
}

//****************************************************************************
//
// CDefineSS Implementation - This is the guy that does all the UI.
//
//*****************************************************************************

CDefineSS::CDefineSS(CExCollection* pCollection)
{
   m_bShouldSave = FALSE;
   m_pSS = NULL;
   m_pCollection = pCollection;
   m_hIL = 0;
   m_hWndParent = 0;
}

CDefineSS::~CDefineSS()
{
}

/****************************************************************************
 * IDefineFilter()
 *
 * Internal entry point for filter manipulation dialog.
 *
 * ENTRY:
 *   none.
 *
 * EXIT:
 *   none.
 *
 ****************************************************************************/
CStructuralSubset* CDefineSS::DefineSubset(HWND hWnd, CStructuralSubset* pSS)
{
   m_pSS = pSS;

   if (! m_hIL )
   {
      m_hIL = ImageList_LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDBMP_CNT_IMAGE_LIST), CWIDTH_IMAGE_LIST,
                                  0, 0x00FF00FF, IMAGE_BITMAP, 0);
      if (! m_hIL )
         return NULL;
   }
   //
   // Create the model dialog.
   //
   m_pThis = this;
   m_hWndParent = hWnd;
	if(g_bWinNT5)
	   return (CStructuralSubset*)DialogBoxW(_Module.GetResourceInstance(), MAKEINTRESOURCEW(DLG_FILTERS), hWnd, FilterDlgProc);
	else
	   return (CStructuralSubset*)DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(DLG_FILTERS), hWnd, FilterDlgProc);
}

/*****************************************************************************
 * MyFilterLBFunc()
 *
 * ListBox subclasser. Used for our filter construction LB's. Needed so
 * we can do proper mouse move processing for diddiling the cursor and
 * implementing the silly collpase feature.
 *
 * ENTRY:
 *  The usual window procedure parameters.
 *
 * EXIT:
 *  a long LRESULT.
 *
 *****************************************************************************/
LRESULT CDefineSS::MyFilterLBFunc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
   int    iTop, iHeight, iItem;
   POINT  pt;
   CFolder*   pFgt;

   switch (uiMsg)
   {
      case WM_SETCURSOR:
         m_pThis->m_giXpos = -1;
         iTop = (int)SendMessage(hWnd, LB_GETTOPINDEX, 0, 0L);
         iHeight = (int)SendMessage(hWnd, LB_GETITEMHEIGHT, 0, 0L);
         GetCursorPos(&pt);
         ScreenToClient(hWnd, &pt);
         //
         // Compute index of the item the cursor is currently hovering over
         // and then get the item data for that item so we can determine it's
         // level and diddle the cursor appropiatly.
         //
         iItem = ((pt.y / iHeight) + iTop);
         if ( (pFgt = (CFolder*)SendMessage(hWnd, LB_GETITEMDATA, iItem, (LPARAM)0)) != (CFolder*)LB_ERR )
         {
            if ( pFgt->iLevel >= 1 )
            {
               if ( pt.x < (pFgt->iLevel * m_pThis->m_giIndentSpacing) )
               {
                  SetCursor(LoadCursor(_Module.GetResourceInstance(),MAKEINTRESOURCE(IDC_COLLAPSE)));
                  m_pThis->m_giXpos = pt.x;
                  return(TRUE);
               }
            }
         }
         break;

      case WM_KEYDOWN:
        PostMessage(hWnd, WM_SETCURSOR, 0, 0L);
        break;

      // HACKHACK - we have a hidden button called IDOK that
      // we use to trap VK_RETURNs so we can send these to
      // the list boxes or other controls
      case WM_SETFOCUS:
        m_pThis->SetDefaultButton( GetParent(hWnd), IDOK, FALSE );
        break;

   }
   return(CallWindowProc(m_pThis->m_lpfnOrigLBProc, hWnd, uiMsg, wParam, lParam));
}

/*****************************************************************************
 * FilterDlgProc()
 *
 * Filter dialog handler
 *
 * ENTRY:
 *   Standard windows callback params.
 *
 * EXIT:
 *   BOOL - TRUE if we handled it. FALSE if we didn't.
 *
 ****************************************************************************/
INT_PTR CDefineSS::FilterDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
   int    i;
   CFolder* pfgt;

   switch(msg)
   {
      case WM_INITDIALOG: {
         //
         // Set the this pointers for our LB message hook procedures. Also, set the procedure hooks
         // for our LB's so we can do cursor changes, tree collapse and proper keyboard interface.
         //
         SendMessage(GetDlgItem(hDlg,IDF_AVAIL), WM_SETFONT, (WPARAM)m_pThis->m_pCollection->m_phmData->GetContentFont(), 0);
         SendMessage(GetDlgItem(hDlg,IDF_RANGE), WM_SETFONT, (WPARAM)m_pThis->m_pCollection->m_phmData->GetContentFont(), 0);
         SendMessage(GetDlgItem(hDlg,IDF_RANGES), WM_SETFONT, (WPARAM)m_pThis->m_pCollection->m_phmData->GetContentFont(), 0);
//         SendMessage(GetDlgItem(hDlg,IDF_RANGES), WM_SETFONT, (WPARAM)_Resource.GetUIFont(), 0);
         m_pThis->m_lpfnOrigLBProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hDlg,IDF_RANGE), GWLP_WNDPROC, (LONG_PTR)MyFilterLBFunc);
         SetWindowLongPtr(GetDlgItem(hDlg,IDF_AVAIL), GWLP_WNDPROC, (LONG_PTR)MyFilterLBFunc);
         SendDlgItemMessage(hDlg, IDF_SAVE_EC, EM_LIMITTEXT, MAX_SS_NAME_LEN - 1, 0L);
         SendMessage(GetDlgItem(hDlg,IDF_SAVE_EC), WM_SETFONT, (WPARAM)m_pThis->m_pCollection->m_phmData->GetContentFont(), 0);
         m_pThis->InitDialog(hDlg, NULL);
         m_pThis->m_bShouldSave = FALSE;
         // set the Close button as the default button
         m_pThis->SetDefaultButton( hDlg, IDCANCEL, FALSE );
         m_pThis->m_giXpos = -1;
         break;
      }

      case WM_CHARTOITEM: // swallow these
        return( -2 );

      case WM_VKEYTOITEM:
         switch (CmdID)
         {
             case 0xBD: // '-'
             case VK_SUBTRACT:
                pfgt=(CFolder*)SendMessage(CmdHwnd, LB_GETITEMDATA, CmdCode, (LPARAM)0);
                m_pThis->ExpandContract(CmdHwnd, pfgt, FALSE, (HWND)CmdHwnd == GetDlgItem(hDlg,IDF_AVAIL));
                return(-2);

             case VK_HOME:
                if (CmdID == VK_HOME && !(GetKeyState(VK_CONTROL) & 0x8000 ))
                  return( -1 );

                // otherwise fall through

             case VK_LEFT:
                if ( ((CmdID == VK_HOME)||(CmdID == VK_LEFT)) && (GetKeyState(VK_CONTROL) & 0x8000 ))
                {
                    // Close everyone
                    pfgt= (CFolder*)SendMessage(CmdHwnd, LB_GETITEMDATA, 0, (LPARAM)0);
                    while (pfgt->pNext)
                    {

                      m_pThis->ExpandContract(CmdHwnd, pfgt, FALSE, (HWND)CmdHwnd == GetDlgItem(hDlg,IDF_AVAIL));
                      pfgt = pfgt->pNext;
                    }
                }
                else
                {
                    pfgt= (CFolder*)SendMessage(CmdHwnd, LB_GETITEMDATA, CmdCode, (LPARAM)0);
                    m_pThis->ExpandContract(CmdHwnd, pfgt, FALSE, (HWND)CmdHwnd == GetDlgItem(hDlg,IDF_AVAIL));
                }
                return(-2);

             case VK_BACK: { // go to parent
                CFolder* pFgtCaret;
                int caret;

                if ( (caret = (int)SendMessage(CmdHwnd,LB_GETCARETINDEX,0,0L)) == -1 )
                   return -2;
                if (! (pFgtCaret=(CFolder*)SendMessage(CmdHwnd, LB_GETITEMDATA, caret, (LPARAM)0)) )
                   return -2;
                pFgtCaret = pFgtCaret->pParent;
                if( pFgtCaret )
                {
                   SendMessage(CmdHwnd, LB_SETSEL, FALSE, MAKELPARAM(caret,0));
                   if ( (caret = (int)SendMessage(CmdHwnd,LB_FINDSTRINGEXACT,0,(LPARAM)pFgtCaret)) == -1 )
                      caret = 0;
                   SendMessage(CmdHwnd, LB_SETCARETINDEX, caret, 0L);
                   SendMessage(CmdHwnd, LB_SETSEL, TRUE, MAKELPARAM(caret,0));
                }
                return(-2);
             }

             case 0xBB: // '+'
             case VK_ADD:
                pfgt=(CFolder*)SendMessage(CmdHwnd, LB_GETITEMDATA, CmdCode, (LPARAM)0);
                m_pThis->ExpandContract(CmdHwnd, pfgt, TRUE, (HWND)CmdHwnd == GetDlgItem(hDlg,IDF_AVAIL) );
                return(-2);

             case VK_RIGHT: {
                INT  ci;

                pfgt=(CFolder*)SendMessage(CmdHwnd, LB_GETITEMDATA, CmdCode, (LPARAM)0);
                m_pThis->ExpandContract(CmdHwnd, pfgt, TRUE, (HWND)CmdHwnd == GetDlgItem(hDlg,IDF_AVAIL));

                // select the first child if it has one
                if ( CmdID == VK_RIGHT && pfgt->pKid && (ci = (INT)SendMessage(CmdHwnd, LB_GETCARETINDEX, 0, 0L)) != LB_ERR ) {
                  SendMessage(CmdHwnd, LB_SETSEL, FALSE, MAKELPARAM(ci,0));
                  SendMessage(CmdHwnd, LB_SETCARETINDEX, ci++, MAKELPARAM(0,0));
                  SendMessage(CmdHwnd, LB_SETSEL, TRUE, MAKELPARAM(ci,0));
                }

                return(-2);
             }

             case VK_RETURN:
                SendMessage( CmdHwnd, WM_COMMAND, ((HWND)CmdHwnd == GetDlgItem(hDlg,IDF_AVAIL))?IDF_AVAIL:IDF_RANGE,
                           MAKELPARAM(CmdHwnd,LBN_DBLCLK));
                return(-2);

         }
         return(-1);  // Tell dlgmgr we didn't handle this key stroke.

      case WM_NCLBUTTONDOWN:
          SendDlgItemMessage(hDlg,IDF_RANGES,CB_SHOWDROPDOWN,FALSE,0L);
          return(FALSE);

      case WM_DRAWITEM:
          // draw one of our listbox items
          m_pThis->DrawFBItem(hDlg, (LPDRAWITEMSTRUCT)lParam, (UINT)wParam);
          break;

      case WM_MEASUREITEM:
          // report how big our items are
          m_pThis->MeasureFBItem((LPMEASUREITEMSTRUCT)lParam);
          break;

      case WM_COMMAND:
          if ( m_pThis->FilterDlgCommand(hDlg, wParam, lParam) )
          {
             i = m_pThis->FillFilterTree(GetDlgItem(hDlg,IDF_RANGE), FALSE, FALSE);
             EnableWindow(GetDlgItem(hDlg,IDF_REMOVE), (i != 0));
             EnableWindow(GetDlgItem(hDlg,IDF_REMOVEALL), (i != 0));
             i = m_pThis->FillFilterTree(GetDlgItem(hDlg,IDF_AVAIL), TRUE, FALSE);
             EnableWindow(GetDlgItem(hDlg,IDF_ADD), (i != 0));
             EnableWindow(GetDlgItem(hDlg,IDF_ADDALL), (i != 0));
             m_pThis->SetSaveStatus(hDlg);
          }
          else
             return FALSE;
          break;

      case WM_CLOSE:
          // Closing the Dialog behaves the same as Cancel
          PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
          break;

      case WM_DESTROY:
          break;

      default:
          return FALSE; // say we didn't handle it
          break;
   }
   return TRUE; // say we did handle it
}

/*****************************************************************************
 * MeasureFBItem()
 *
 * Set appropiate size entries in the measure item struc according to the
 * items we'll be rendering in the filter listboxes.
 *
 * ENTRY:
 *   hDlg - Handle to the filter dialog.
 *   lpMIS - Pointer to the LPMEASUREITEMSTRUCT
 *
 * EXIT:
 *   None.
 *
 *****************************************************************************/
void CDefineSS::MeasureFBItem(LPMEASUREITEMSTRUCT lpMIS)
{
    POINT         pt;
    HDC           hDC;
    HFONT         hOldFont;
    TEXTMETRIC    tm;

    ImageList_GetIconSize(m_hIL, (int*)&pt.x, (int*)&pt.y);
    hDC = GetDC(NULL);
    hOldFont = (HFONT)SelectObject(hDC, m_pCollection->m_phmData->GetContentFont());
    GetTextMetrics(hDC, &tm);
    SelectObject(hDC, hOldFont);
    ReleaseDC(NULL, hDC);

    if ( pt.y > tm.tmHeight )
       lpMIS->itemHeight = pt.y;
    else
       lpMIS->itemHeight = tm.tmHeight;

    m_giIndentSpacing = pt.x;
    m_iFontHeight = tm.tmHeight;
    m_iGlyphX = pt.x;
    m_iGlyphY = pt.y;
}

/*****************************************************************************
 * InitDialog()
 *
 * Do all initialization of the range definition dialog for a particular
 * situation, Add, Delete or Change.
 *
 * ENTRY:
 *   hDlg     - The handle to the dialog.
 *   szRange  - Pointer to new range or NULL if initing the range combo-box.
 *
 * EXIT:
 *   BOOL - TRUE on success, FALSE on failure.
 *
 ****************************************************************************/
BOOL CDefineSS::InitDialog(HWND hDlg, LPSTR szRange)
{
   int     iSel = 0;
   int     i = 0;
   int     iFilterCnt = 0;
   BOOL    bDef = FALSE;
   CStructuralSubset* pSS = NULL;

   SendDlgItemMessage(hDlg,IDF_RANGES,CB_SETEXTENDEDUI,TRUE,0L);

   if (! m_pCollection->m_pSSList )
      return(FALSE);

   if (! szRange  )
   {
      SendDlgItemMessage(hDlg, IDF_RANGES, CB_RESETCONTENT, 0, 0L);
      while ( (pSS = m_pCollection->m_pSSList->GetNextSubset(pSS)) )
      {
         i = (int) SendDlgItemMessage(hDlg, IDF_RANGES, CB_INSERTSTRING, (WPARAM) -1, (LPARAM)(LPSTR)pSS->GetName());
         SendDlgItemMessage(hDlg, IDF_RANGES, CB_SETITEMDATA, i, (LPARAM)((DWORD_PTR)pSS));
      }
   }
   else
   {
      if ( (iSel = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_FINDSTRINGEXACT,0, (LPARAM)szRange)) != LB_ERR )
         pSS = (CStructuralSubset*)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETITEMDATA, iSel,0L);
      SendDlgItemMessage(hDlg, IDF_RANGES, CB_SETCURSEL, iSel, 0L);
      bDef = TRUE;
   }
   //
   // Select the current filter. If it's "entire CD" select "New".
   //
   if (! bDef || ! pSS)
   {
      pSS = m_pCollection->m_pSSList->GetNew();
      SendDlgItemMessage(hDlg, IDF_RANGES, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)pSS->GetName());
   }
   //
   // Init the listboxes!
   //
   SetRangeToTree(pSS);
   //
   //  Init filter LB and remove options.
   //
   i = FillFilterTree(GetDlgItem(hDlg,IDF_RANGE), FALSE, FALSE);
   EnableWindow(GetDlgItem(hDlg,IDF_REMOVE), (i != 0));
   EnableWindow(GetDlgItem(hDlg,IDF_REMOVEALL), (i != 0));
   //
   //  Init available LB and add options.
   //
   i = FillFilterTree(GetDlgItem(hDlg,IDF_AVAIL), TRUE, FALSE);
   EnableWindow(GetDlgItem(hDlg,IDF_ADD), (i != 0));
   EnableWindow(GetDlgItem(hDlg,IDF_ADDALL), (i != 0));
   //
   // deal with buttons
   //
   if ( pSS->IsReadOnly() )
   {
      EnableWindow(GetDlgItem(hDlg, IDF_DELETE), FALSE);
      SetWindowText(GetDlgItem(hDlg,IDF_SAVE_EC),GetStringResource(IDS_UNTITLED_SUBSET));
   }
   else
   {
      EnableWindow(GetDlgItem(hDlg, IDF_DELETE), TRUE);
      SetWindowText(GetDlgItem(hDlg,IDF_SAVE_EC), pSS->GetName());
   }
   EnableWindow(GetDlgItem(hDlg,IDF_SAVE), FALSE);
   return(TRUE);
}

/*****************************************************************************
 * DoesNodeHaveANext()
 *
 * aids DrawFBItem() in painting the vertical connecting codes in the filter
 * list boxes.
 *
 * ENTRY:
 *   LbId - ListBox ID.
 *   n    - What level are we painting.
 *   pFgt - Pointer to the node we're painting.
 *
 * EXIT:
 *   BOOL - TRUE if a next will appear on the given level. FALSE otherwise.
 *
 ****************************************************************************/
BOOL CDefineSS::DoesNodeHaveANext(UINT LbId, int n, CFolder* pFgt)
{
   while ( pFgt->iLevel > (n + 1) )
      pFgt = pFgt->pParent;

   while ( pFgt->pNext )
   {
      pFgt = pFgt->pNext;
      if ( (PRESENT((LbId == IDF_AVAIL), pFgt)) )
         return(TRUE);
   }
   return(FALSE);
}

/*****************************************************************************
 * DrawFBItem()
 *
 * Function is responsible for painting the items in the owner-draw list boxes
 * that are used in the filter contents dialog.
 *
 * ENTRY:
 *   hDlg - Handle to the dialog.
 *   lpDI - Pointer to the draw item struct. Contains a pFgt to the item
 *          we're painting.
 *   Lbid - ListBox identifier.
 *
 * EXIT:
 *   None.
 *
 ****************************************************************************/
void CDefineSS::DrawFBItem(HWND hDlg, LPDRAWITEMSTRUCT lpDI, UINT LbId)
{
   RECT     rc;
   int      n;
   WORD     wTopText;
   HDC      hDC;
   CFolder* pFgt;
   INT      xBitmap = 0;
   int      iHeight;
   BOOL     bHasNext;
   char*    lpszText;
   char     szScratch[MAX_PATH];
   static int bNoReEnter = 0;

   if (lpDI->itemID == 0xFFFF)
       return;
   pFgt = (CFolder*)lpDI->itemData;
   if (!pFgt || lpDI->itemData == -1 )
      return;

   bNoReEnter++;
   if ( bNoReEnter > 1 )
   {
      bNoReEnter--;
      return;
   }

   hDC = lpDI->hDC;
   rc = lpDI->rcItem;
   iHeight = rc.bottom - rc.top;
   wTopText = (WORD)((rc.top + ((iHeight) / 2)) - ((m_iFontHeight - 2) / 2));
   /*
    *  Paint the proper lines based on the level and position of the item.
    */
   if ( pFgt->iLevel )
   {
      for ( n = 0; n < pFgt->iLevel; n++ )
      {
         // Draw the verticle line indicating level. Remember to not leave a
         // "tail".
         //
         bHasNext = DoesNodeHaveANext(LbId, n, pFgt);
         if ( bHasNext )
            QRect(hDC, rc.left + m_iGlyphX / 2, rc.top,     // Full verticle line.
                  1, iHeight, COLOR_WINDOWTEXT);
         else if ( n == (pFgt->iLevel - 1) )
            QRect(hDC, rc.left + m_iGlyphX / 2, rc.top,     // Half vertical line.
                  1, (iHeight / 2), COLOR_WINDOWTEXT);

         rc.left += m_iGlyphX;
      }
      // Draw the horizontal connector line.
      //
      QRect(hDC, (rc.left - m_iGlyphX / 2), (rc.top + (m_iGlyphY / 2)), ((m_iGlyphX / 2)), 1, COLOR_WINDOWTEXT);
   }
   //
   // draw the little book.
   //
   if ( EXPANDED((LbId == IDF_AVAIL), pFgt) )  // Is the book open or closed ?
      xBitmap++;                               // It's an open book.
   ImageList_Draw(m_hIL, xBitmap, hDC, rc.left+1, rc.top, ILD_NORMAL);
   rc.left += m_iGlyphX + 2;
   if ( lpDI->itemState & ODS_SELECTED )
   {
       SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
       SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
   }
   else
   {
      SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
      SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
   }
   //
   // Now paint the text.
   //
   if ( pFgt->f_HasHash && pFgt->pExTitle )
   {
      pFgt->pExTitle->GetTopicLocation(0, szScratch, sizeof(szScratch));
      lpszText = szScratch;
   }
   else
      lpszText = pFgt->Title;
   //
   // Set LB Horizontal extent based upon the width of the string.
   //
   int iWidth, len = lstrlen(lpszText);
   SIZE size;

   if ( lpDI->itemAction == ODA_DRAWENTIRE )
   {
      GetTextExtentPoint32(hDC, lpszText, len, &size);
      size.cx += rc.left + 4;
      iWidth = (int)SendDlgItemMessage(hDlg, LbId, LB_GETHORIZONTALEXTENT, 0, 0L);
      if ( size.cx > iWidth )
         SendDlgItemMessage(hDlg, LbId, LB_SETHORIZONTALEXTENT, (WPARAM)size.cx, 0L);
   }
   //
   // Paint the string.
   //
   ExtTextOut(hDC, (rc.left + 2), wTopText, ETO_OPAQUE | ETO_CLIPPED, &rc, lpszText, len, NULL);
   if (lpDI->itemState & ODS_FOCUS)
       DrawFocusRect(hDC,&rc);

   bNoReEnter--;
}

/****************************************************************************
 * SetRangeToTree()
 *
 * Function will set the filter tree up according the the subset specified
 * by the given CStructuraSubset pointer.
 *
 * ENTRY:
 *   CStructuralSubset* A NULL object is the equivelent to RF_NONE.
 *                      Use of this feature will cause all nodes to be
 *                      removed from the filter.
 *
 * EXIT:
 *  BOOL - TRUE for success. FALSE for failure!
 *
 ****************************************************************************/
BOOL CDefineSS::SetRangeToTree(CStructuralSubset* pSS)
{
   CFolder*  pFgt;    // pointer to filtered group tree.
   UINT  i = 0;
   HASH  Hash;

   pFgt = m_pCollection->m_Collection.GetVisableRootFolder();
   if ( pSS )
   {
      if ( pSS->m_dwFlags & SS_ENTIRE_CONTENTS )
      {
         while ( pFgt )
         {
            AddNode2Filter(pFgt);
            pFgt = pFgt->pNext;
         }
      }
      else
      {
         //
         //  De-select all nodes filter bits and select the proper
         //  tree nodes based on the hash list!
         //
         while ( pFgt )
         {
            RemoveNodeFromFilter(pFgt);
            pFgt = pFgt->pNext;
         }
         while ( Hash = pSS->EnumHashes(i++) )
         {
            if ( (pFgt = m_pCollection->m_pCSlt->HashToCFolder(Hash)) )
               AddNode2Filter(pFgt);
         }
      }
      return(TRUE);
   }
   else
   {
      while ( pFgt )
      {
         RemoveNodeFromFilter(pFgt);
         pFgt = pFgt->pNext;
      }
   }
   return(FALSE);
}

/****************************************************************************
 * GetRangeFromTree()
 *
 * Function will extract a range from the filter LB and return a handle to
 * the range.
 *
 * ENTRY:
 *  sz - Range name.
 *
 * EXIT:
 *
 ****************************************************************************/
CStructuralSubset* CDefineSS::GetRangeFromTree(LPSTR sz)
{
   CFolder*    pFgt;
   CFolder*    pFgtLast;
   int     i = 0;
   CStructuralSubset* pSS;
   CExTitle* pExTitle;

   if (! (pSS = new CStructuralSubset(sz)) )
      return NULL;  // Young girls are chaining themselves to the axels of big mac trucks.

   // Walk root level nodes and gather up the prefix hashes from each node
   // and all it's kids if the filter bit is set.
   //
   pFgt = m_pCollection->m_Collection.GetVisableRootFolder();
   while ( pFgt )
   {
      do
      {
         pFgtLast = pFgt;
         if ( pFgt->f_Filter && !pFgt->f_Available && pFgt->f_HasHash )
         {
            pSS->AddHash(pFgt->pExTitle->m_dwHash);
            //
            // Any merged .CHM's ?
            //
            pExTitle = pFgt->pExTitle->m_pKid;
            while ( pExTitle )
            {
               pSS->AddHash(pExTitle->m_dwHash);
               pExTitle = pExTitle->m_pNextKid;
            }
            i++;
            break;
         }
         pFgt = pFgt->pKid;

      } while ( pFgt );

      pFgt = pFgtLast;
      while ( pFgt && (! (pFgt->pNext)) )
         pFgt = pFgt->pParent;
      if ( pFgt )
         pFgt = pFgt->pNext;
   }
   // Lastly, setup the range entry and add it to the range list.
   //
   if (! i )
   {
      delete pSS;
      return(NULL);
   }
   return pSS;
}

/*****************************************************************************
 * SetSaveStatus()
 *
 * If you don't want'em saving then disable the save button!
 *
 * ENTRY:
 *  hDlg - Handle to the define contents dialog.
 *
 * EXIT:
 *  None.
 *
 ****************************************************************************/
void CDefineSS::SetSaveStatus(HWND hDlg)
{
   char     sz[MAX_SS_NAME_LEN];
   int      i;
   CStructuralSubset* pSS;
   HWND     hWnd = GetDlgItem(hDlg, IDF_SAVE);

   GetWindowText(GetDlgItem(hDlg, IDF_SAVE_EC), sz, sizeof(sz));
   i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETCURSEL, 0, 0L);
   pSS = (CStructuralSubset*)SendDlgItemMessage(hDlg,IDF_RANGES,CB_GETITEMDATA,i,0L);

   if ( ((pSS->m_dwFlags & SS_READ_ONLY) && (! lstrcmpi(pSS->GetName(), sz))) ||
      (! SendDlgItemMessage(hDlg, IDF_RANGE, LB_GETCOUNT, 0, 0L)) ||
      (! lstrlen(sz)) || !m_bShouldSave )
      EnableWindow(hWnd, FALSE);
   else
      EnableWindow(hWnd, TRUE);
}

/*****************************************************************************
 * ShouldSave()
 *
 * Alert the user that they may want to save the changes they've made to
 * the filter.
 *
 * ENTRY:
 *   hDlg - Handle to the filter definition dialog.
 *
 * EXIT:
 *   INT - IDYES, IDNO or IDCANCEL. 0 if saving is not necessary.
 *
 ****************************************************************************/
INT CDefineSS::ShouldSave(HWND hDlg)
{
   char    sz[MAX_SS_NAME_LEN];

   if ( IsWindowEnabled(GetDlgItem(hDlg, IDF_SAVE)) )
   {
      GetWindowText(GetDlgItem(hDlg, IDF_SAVE_EC), sz, sizeof(sz));
      return MsgBox(IDS_SAVE_FILTER, sz, MB_YESNOCANCEL | MB_ICONQUESTION);
   }
   return(0);
}

/****************************************************************************
 * FilterDlgCommand()
 *
 * Function handles all WM_COMMAND messages from the filter dialog.
 *
 * ENTRY:
 *   hDlg   - Handle to the dialog.
 *   wParam - Message dependent.
 *   lParam - Message dependent.
 *
 * EXIT:
 *   Returns TRUE is range list boxes need updating. False otherwise.
 *
 ***************************************************************************/
BOOL CDefineSS::FilterDlgCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
   int         i, n;
   CFolder*    pFgt;
   char        sz[MAX_SS_NAME_LEN];
   static      il;
   static HWND hWndCombo = NULL;

   switch (CmdID)
   {
      // HACKHACK - this is an invisible button that we use to route double-clicks
      // to other controls
      case IDOK:
      {
        HWND hWndCurrent, hWndFocus;
        int id = 0;
        // find out which control we are on
        if( (hWndFocus = GetFocus()) )
        {
          hWndCurrent = GetDlgItem(hDlg,IDF_AVAIL);
          if( hWndFocus == hWndCurrent )
            id = IDF_AVAIL;
          hWndCurrent = GetDlgItem(hDlg,IDF_RANGE);
          if( hWndFocus == hWndCurrent )
            id = IDF_RANGE;
          hWndCurrent = GetDlgItem(hDlg,IDF_RANGES);
          if( hWndFocus == hWndCurrent )
            id = IDF_RANGES;

          SendMessage( hDlg, WM_COMMAND, MAKEWPARAM(id,LBN_DBLCLK), 0L);
        }
        return( TRUE );
      }

      case IDF_SAVE:
         if ( SaveFilter(hDlg) )
         {
            SetDefaultButton( hDlg, IDCANCEL, TRUE );
            i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETCURSEL, 0, 0L);
            m_pSS = (CStructuralSubset*)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETITEMDATA, i, 0L);
            EnableWindow(GetDlgItem(hDlg, IDF_DELETE), TRUE);
            m_bShouldSave = FALSE;
         }
         else
            SetFocus(GetDlgItem(hDlg, IDF_RANGES));
         break;

      case IDCANCEL:
         // if a combo box is open then close it and don't close the dialog
         if( hWndCombo )
         {
           SendMessage( hWndCombo, CB_SHOWDROPDOWN, FALSE, 0L );
           return FALSE;
         }
         //
         // Has the range been modified ? Might it need to be saved.
         //
         if ( m_bShouldSave )
         {
            i = ShouldSave(hDlg);
            if ( i == IDYES )
            {
               if (! SaveFilter(hDlg) )
               {
                  SetFocus(GetDlgItem(hDlg, IDF_RANGES));
                  break;
               }
               i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETCURSEL, 0, 0L);
               m_pSS = (CStructuralSubset*)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETITEMDATA, i, 0L);
               m_bShouldSave = FALSE;
            }
            else if ( i == IDCANCEL )
               break;
         }
         EndDialog(hDlg, (INT_PTR)m_pSS);
         break;

      case IDF_DELETE:
         if ( (i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETCURSEL, 0, 0L)) != CB_ERR )
         {
            int n;
            m_pSS = (CStructuralSubset*)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETITEMDATA, i, 0L);
            if ( MsgBox(IDS_CONFIRM_SSDELETE, m_pSS->GetName(), MB_YESNO | MB_ICONQUESTION) == IDYES )
            {
               if ( (i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_FINDSTRINGEXACT, 0, (LPARAM)m_pSS->GetName())) != LB_ERR)
                  SendDlgItemMessage(hDlg, IDF_RANGES, CB_DELETESTRING, i, 0L);
               m_pCollection->m_pSSList->DeleteSubset(m_pSS, NULL, m_hWndParent);
               n = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETCOUNT, 0, 0L);
               n--;
               i = min(n,i);
               SendDlgItemMessage(hDlg, IDF_RANGES, CB_SETCURSEL, i, 0L);
               i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETCURSEL, 0, 0L);
               m_pSS = (CStructuralSubset*)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETITEMDATA, i, 0L);
               InitDialog(hDlg, m_pSS->GetName());
               m_bShouldSave = FALSE;
               return(FALSE);
            }
         }
         break;

      case IDF_SAVE_EC:
         switch (CmdCode)
         {
            case EN_UPDATE:
               m_bShouldSave = TRUE;
               SetSaveStatus(hDlg);
               SetDefaultButton( hDlg, IDF_SAVE, FALSE );
               break;

            case EN_CHANGE:
               m_bShouldSave = TRUE;
               break;
         }
         break;

      case IDF_RANGES:
         switch (CmdCode)
         {
            case CBN_DROPDOWN:
               il = (int)SendDlgItemMessage(hDlg,IDF_RANGES,CB_GETCURSEL,0,0L);
               break;

            case CBN_SELCHANGE:
               i = (int)SendDlgItemMessage(hDlg,IDF_RANGES,CB_GETCURSEL,0,0L);
               SendDlgItemMessage(hDlg,IDF_RANGES,CB_GETLBTEXT,i,(LPARAM)sz);
               if ( m_bShouldSave )
               {
                  n = ShouldSave(hDlg);
                  if ( n == IDCANCEL )
                     goto cancel_it;
                  else if ( n == IDYES )
                  {
                     if (! SaveFilter(hDlg) )
                        goto cancel_it;
                  }
                  //SetDefaultButton( hDlg, IDCANCEL, TRUE );
               }
               i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETCURSEL, 0, 0L);
               m_pSS = (CStructuralSubset*)SendDlgItemMessage(hDlg, IDF_RANGES, CB_GETITEMDATA, i, 0L);
               m_bShouldSave = FALSE;
               InitDialog(hDlg, sz);
               return(FALSE);
cancel_it:
               SendDlgItemMessage(hDlg,IDF_RANGES,CB_SETCURSEL,(WPARAM)il,0L);
         }
         break;

      case IDHELP:
         break;


      case IDF_NEW:
         m_bShouldSave = TRUE;
         SetSaveStatus(hDlg);
         break;

      case IDF_REMOVE:
         n = (int)SendDlgItemMessage(hDlg, IDF_RANGE, LB_GETCOUNT, 0, 0L);
         for (i = 0; i < n; i++)
         {
             if (SendDlgItemMessage(hDlg, IDF_RANGE, LB_GETSEL, i, 0L))
             {
                 pFgt=(CFolder*)SendDlgItemMessage(hDlg,IDF_RANGE,LB_GETITEMDATA,i, (LPARAM)0);
                 RemoveNodeFromFilter(pFgt);
                 SendDlgItemMessage(hDlg, IDF_RANGE, LB_SETSEL, 0, (LPARAM)i);
                 m_bShouldSave = TRUE;
             }
         }
         SetFocus(GetDlgItem(hDlg, IDF_RANGE));
         return(TRUE);
         break;

      case IDF_ADDALL:
         //
         // Enumerate root level nodes Adding each!
         //
         pFgt = m_pCollection->m_Collection.GetVisableRootFolder();
         while ( pFgt )
         {
            AddNode2Filter(pFgt);
            pFgt = pFgt->pNext;
         }
         m_bShouldSave = TRUE;
         SetFocus(GetDlgItem(hDlg, IDF_RANGE));
         return(TRUE);
         break;

      case IDF_ADD:
         n = (int)SendDlgItemMessage(hDlg, IDF_AVAIL, LB_GETCOUNT, 0, 0L);
         for (i = 0; i < n; i++)
         {
             if (SendDlgItemMessage(hDlg, IDF_AVAIL, LB_GETSEL, i, 0L))
             {
                 pFgt=(CFolder*)SendDlgItemMessage(hDlg,IDF_AVAIL,LB_GETITEMDATA,i, (LPARAM)0);
                 AddNode2Filter(pFgt);
                 SendDlgItemMessage(hDlg, IDF_AVAIL, LB_SETSEL, 0, (LPARAM)i);
                 m_bShouldSave = TRUE;
             }
         }
         SetFocus(GetDlgItem(hDlg, IDF_AVAIL));
         return(TRUE);
         break;

      case IDF_REMOVEALL:
         //
         // Enumerate root level nodes removing each!
         //
         pFgt = m_pCollection->m_Collection.GetVisableRootFolder();
         while ( pFgt )
         {
            RemoveNodeFromFilter(pFgt);
            pFgt = pFgt->pNext;
         }
         m_bShouldSave = TRUE;
         SetFocus(GetDlgItem(hDlg, IDF_AVAIL));
         return(TRUE);
         break;

      case IDF_RANGE:
         switch (CmdCode)
         {
            case LBN_DBLCLK:
               n = 0;
               goto expcont;
         }
         break;

      case IDF_AVAIL:
         switch (CmdCode)
         {
            case LBN_DBLCLK:
               n = 1;
expcont:
               i = (int)SendDlgItemMessage(hDlg,CmdID,LB_GETCARETINDEX,0,0L);
               if (i == (int)LB_ERR)
                   break;

               pFgt=(CFolder*)SendDlgItemMessage(hDlg,CmdID,LB_GETITEMDATA,i, (LPARAM)0);
               if ( !pFgt || pFgt == (CFolder*)-1 )
                  break;
               //
               // giXpos is set in my LB hook proc. If it's != -1 then this
               // double click is intended as a collapsing dbl click and giXpos
               // will indicate the x position within the LB where the double
               // click occured. Sound reasonable ?
               //
               if ( m_giXpos > 0 )
               {
                  int iLevel;

                  iLevel = m_giXpos / m_giIndentSpacing;
                  while ( (iLevel != pFgt->iLevel) && pFgt->pParent )
                     pFgt = pFgt->pParent;
               }
               ExpandContract(GetDlgItem(hDlg,CmdID), pFgt, -1, n);
               break;

            default:
               break;

         }
         break;
   }

   switch( CmdCode )
   {
      case CBN_DROPDOWN:
         hWndCombo = (HWND) lParam;
         SetDefaultButton( hDlg, IDCANCEL, FALSE );
         break;

      case CBN_CLOSEUP:
         hWndCombo = NULL;
         SetDefaultButton( hDlg, IDCANCEL, FALSE );
         break;

   }

   return(FALSE);
}

/*****************************************************************************
 * SaveFilter()
 *
 * Function saves a filter to the filter list, insuring a read-only filter
 * is not over-written.
 *
 * ENTRY:
 *   hDlg - Handle to the filter definition dialog.
 *
 * EXIT:
 *   BOOL - TRUE Indicates the filter was saved. FALSE indicates filter
 *          was not saved.
 *
 *****************************************************************************/
BOOL CDefineSS::SaveFilter(HWND hDlg)
{
   char    szGivenRN[MAX_SS_NAME_LEN];
   int     i = 0;
   CStructuralSubset* pSS = NULL;
   CStructuralSubset* pSSNew;

   GetDlgItemText(hDlg, IDF_SAVE_EC, szGivenRN, sizeof(szGivenRN));
   //
   // Extract range from the filter LB.
   //
   if (! (pSSNew = GetRangeFromTree(szGivenRN)) )
      return(FALSE);
   //
   // Insure we're not trashing a read only ramge.
   //
   while ( (pSS = m_pCollection->m_pSSList->GetNextSubset(pSS)) )
   {
      if (! lstrcmpi(pSS->GetName(), pSSNew->GetName()) )
      {
         if ( pSS->m_dwFlags & SS_READ_ONLY )
         {
            MsgBox(IDS_BAD_RANGE_NAME, MB_OK | MB_ICONEXCLAMATION);
            return(FALSE);
         }
         // Sure you want to over-write the existing rnage ?
         //
         if ( MsgBox(IDS_OVERWRITE, MB_YESNO | MB_ICONQUESTION) == IDNO )
            return(FALSE);
         if ( (i = (int)SendDlgItemMessage(hDlg, IDF_RANGES, CB_FINDSTRINGEXACT, 0, (LPARAM)pSS->GetName())) != LB_ERR)
            SendDlgItemMessage(hDlg, IDF_RANGES, CB_DELETESTRING, i, 0L);
         m_pCollection->m_pSSList->DeleteSubset(pSS, pSSNew, m_hWndParent);
         break;
      }
   }
   // Add new subset to the list and update UI...
   //
   m_pCollection->m_pSSList->AddSubset(pSSNew, m_hWndParent);
   SendDlgItemMessage(hDlg, IDF_RANGES, CB_INSERTSTRING, 0, (LPARAM)pSSNew->GetName());
   SendDlgItemMessage(hDlg, IDF_RANGES, CB_SETITEMDATA, 0, (LPARAM)pSSNew);
   SendDlgItemMessage(hDlg, IDF_RANGES, CB_SETCURSEL, 0, 0L);
   EnableWindow(GetDlgItem(hDlg,IDF_SAVE), FALSE);
   return(TRUE);
}

/*****************************************************************************
 * RemoveNodeFromFilter()
 *
 * Function removes the node and all it's kids from the filter.
 *
 * ENTRY:
 *   pFgt - Poiner to the node to be removed.
 *
 * EXIT:
 *  None.
 *
 *****************************************************************************/
void CDefineSS::RemoveNodeFromFilter(CFolder* pFgti)
{
   CFolder*   pFgt;
   CFolder*   pFgtLast;

   // First, de-select the node and any children of the node taking care
   // to set the f_Available bit from each!
   //
   pFgt = pFgti;
   if ( pFgt->pKid )
   {
      while ( pFgt )
      {
         do
         {
            pFgt->f_Available = 1;
            pFgt->f_Filter = 0;
            pFgtLast = pFgt;
            pFgt = pFgt->pKid;

         } while ( pFgt );
         pFgt = pFgtLast;
         while ( pFgt && (! (pFgt->pNext)) )
         {
            if ( pFgt->pParent != pFgti )
               pFgt = pFgt->pParent;
            else
               break;
         }
         if ( pFgt )
            pFgt = pFgt->pNext;
      }
   }
   // Next, assure any parents of the node are marked as available. We also
   // have to take care to see that a parent who has no children who are
   // part of the filter are removed from the filter!
   //
   pFgt = pFgti;
   pFgt->f_Filter = 0;
   pFgt->f_Available = 1;

   while ( pFgt = pFgt->pParent )
   {
      pFgt->f_Available = 1;
      SetFilterStatus(pFgt);
   }
}

/*****************************************************************************
 * SetFilterStatus()
 *
 * If ALL children of the given node are marked as available, that nodes
 * filter bit will be set to zero.
 *
 * ENTRY:
 *   pFgt - Pointer to the node to start from.
 *
 * EXIT:
 *
 ****************************************************************************/
void CDefineSS::SetFilterStatus(CFolder* pFgt)
{
   CFolder* pFgtl = pFgt->pKid;
   CFolder* pFgtLast;

   while ( pFgtl )
   {
      do
      {
         if (! pFgtl->f_Available )
            return;
         pFgtLast = pFgtl;
         pFgtl = pFgtl->pKid;
      } while ( pFgtl );
      pFgtl = pFgtLast;
      while ( pFgtl && (! (pFgtl->pNext)) && (pFgtl->pParent != pFgt) )
         pFgtl = pFgtl->pParent;
      if ( pFgtl )
         pFgtl = pFgtl->pNext;
   }
   pFgt->f_Filter = 0;
}

/*****************************************************************************
 * AddNode2Filter()
 *
 * Function adds a node to the filter assuring that necessary parents are
 * added, and necessary nodes are removed from the available listbox.
 *
 * ENTRY:
 *   pFgti = Node to be added.
 *
 * EXIT:
 *   None.
 *
 *****************************************************************************/
void CDefineSS::AddNode2Filter(CFolder* pFgti)
{
   CFolder*   pFgt;
   CFolder*   pFgtLast;

   // First, select the node and any children of the node taking care
   // to remove the f_Available bit from each!
   //
   pFgt = pFgti;
   while ( pFgt )
   {
      do
      {
         pFgt->f_Available = 0;
         pFgt->f_Filter = 1;

         pFgtLast = pFgt;
         pFgt = pFgt->pKid;

      } while ( pFgt );
      pFgt = pFgtLast;
      if ( pFgt == pFgti )
         break;
      while ( pFgt && (! (pFgt->pNext)) )
      {
         if ( pFgt->pParent != pFgti )
            pFgt = pFgt->pParent;
         else
            break;
      }
      if ( pFgt )
         pFgt = pFgt->pNext;
   }
   // Next, assure parents are selected.
   //
   pFgt = pFgti;
   if ( pFgt->pParent )
   {
      while ( pFgt = pFgt->pParent )
      {
         pFgt->f_Filter = 1;
         pFgt->f_F_Open = 1;
         SetAvailableStatus(pFgt);   // Should it still be available ?
      }
   }
}

/*****************************************************************************
 * SetAvailabilityStatus()
 *
 * If ALL children of the given node are selected as part of a filter, that
 * nodes availability bit will be set to zero.
 *
 * ENTRY:
 *   pFgt - Pointer to the node to start from.
 *
 * EXIT:
 *
 ****************************************************************************/
void CDefineSS::SetAvailableStatus(CFolder* pFgt)
{
   CFolder* pFgtl = pFgt->pKid;
   CFolder* pFgtLast;

   while ( pFgtl )
   {
      do
      {
         if (! pFgtl->f_Filter )
            return;
         pFgtLast = pFgtl;
         pFgtl = pFgtl->pKid;
      } while ( pFgtl );
      pFgtl = pFgtLast;
      while ( pFgtl && (! (pFgtl->pNext)) && (pFgtl->pParent != pFgt) )
         pFgtl = pFgtl->pParent;
      if ( pFgtl )
         pFgtl = pFgtl->pNext;
   }
   pFgt->f_Available = 0;
}

/******************************************************************************
 * ExpandContract()
 *
 * Function set's appropiate bits in the appropiate nodes to cause
 * a parent node to expand or contract when FillRangeTree() is called.
 *
 * ENTRY:
 *   hwndLB - Handle to the listbox that contains the node were operating on.
 *
 *   pFgt   - Pointer to the node were expanding or contracting.
 *
 *   sel    - Identifies action: TRUE for Expansion
 *                               FALSE for Contraction
 *                               -1 for double-click which really means that
 *                               we toggle the current state for the appropiate
 *                               LB identified by the "which" arg.
 *
 *   which  - Which ListBox are we working with: TRUE  == Available LB.
 *                                               FALSE == Range LB.
 *
 * EXIT:
 *  WORD - Returns the AX from FillRangeTree which happens to be the number
 *         of items placed in the LB.
 *
 *****************************************************************************/
WORD CDefineSS::ExpandContract(HWND hwndLB, CFolder* pFgt, int sel, BOOL which)
{
   if (sel != 0 && sel != 1)
   {
      if (! pFgt->pKid )
         return(0);
      //
      // This is the double click case.
      //
      if ( which ) {
         if( pFgt->f_A_Open )
           pFgt->f_A_Open = FALSE;
         else
           pFgt->f_A_Open = TRUE;
      }
      else
         pFgt->f_F_Open = !pFgt->f_F_Open;
   }
   else
   {
      // This is the +/- case
      //
      // Contraction works a little differently than expansion.
      // For contraction, if the selected node is not expanded, we close
      // it's parent. If it is expanded, we close it.
      //
      if ( !sel )  // if we're doing contraction...
      {
         if ( ! (which ? pFgt->f_A_Open : pFgt->f_F_Open) ) // if node closed...
         {
            if ( pFgt->pParent )
               pFgt = pFgt->pParent;
         }
      }

      if (! pFgt->pKid && pFgt->pParent)
         pFgt = pFgt->pParent;

      if ( which )
         pFgt->f_A_Open = sel;
      else
         pFgt->f_F_Open = sel;
   }
   return (WORD)FillFilterTree(hwndLB, which, sel);
}

/*****************************************************************************
 * FillFilterTree()
 *
 * Function actually makes the send message calls to cause a repaint of
 * the listbox identified by hwndLB.
 *
 * ENTRY:
 *    hwndLB     - Identifies the listbox were working with (it's handle)
 *    fAvailable - Which ListBox are we working with: TRUE  == Available LB.
 *                                                    FALSE == Range LB.
 *    fScrollup  - If TRUE and a parents children will appear off the bottom
 *                 of the LB we'll scroll the parent to the top of the LB.
 *
 * EXIT:
 *    UINT - Returns the number of items placed in the LB.
 *
 *****************************************************************************/
UINT CDefineSS::FillFilterTree(HWND hwndLB, BOOL fAvailable, BOOL fScrollup)
{
   UINT uiRet = 0;
   int  n, nVis, top, caret;
   CFolder* pFgtTop, *pFgtCaret, *pFgt, *plFgt;
   RECT rc;

   /*
    *  Compute the number of visible lines, get the top and caret indicies.
    */
   GetClientRect(hwndLB,&rc);
   n = (int)SendMessage(hwndLB,LB_GETITEMHEIGHT,0,0L);
   nVis = rc.bottom / n;
   SendMessage(hwndLB,WM_SETREDRAW,FALSE,0L);  // Don't re-paint!

   caret = (int)SendMessage(hwndLB,LB_GETCARETINDEX,0,0L);
   top = (int)SendMessage(hwndLB,LB_GETTOPINDEX,0,0L);
   /*
    *  Get the items living at the top and the caret position of the listbox.
    */
   if (top == (int)LB_ERR)
       pFgtTop = NULL;
   else
   {
       if ( (pFgtTop=(CFolder*)SendMessage(hwndLB, LB_GETITEMDATA, top, (LPARAM)0)) == (CFolder*)LB_ERR )
          pFgtTop = NULL;
   }

   if (caret == (int)LB_ERR)
       pFgtCaret = NULL;
   else
   {
       if ( (pFgtCaret=(CFolder*)SendMessage(hwndLB, LB_GETITEMDATA, caret, (LPARAM)0)) == (CFolder*)LB_ERR )
          pFgtCaret = NULL;
   }
   /*
    *  If the top entry is a child and it's not expanded, set it's parent
    *  as the top. ie it's been collapsed.
    */
   if ( pFgtTop && pFgtTop->pParent && !EXPANDED(fAvailable, pFgtTop->pParent) )
       pFgtTop = pFgtTop->pParent;
   /*
    *  If the caret position is on a child and it's not expanded, set it's
    *  parent as the caret position. ie it's been collapsed.
    */
   if ( pFgtCaret && pFgtCaret->pParent && !EXPANDED(fAvailable, pFgtCaret->pParent) )
       pFgtCaret = pFgtCaret->pParent;
   /*
    *  Insure we have not set the top or caret position to a non selected
    *  node.
    */
   if ( pFgtTop && !PRESENT(fAvailable,pFgtTop) )
   {
      plFgt = pFgtTop;
      do
      {
         do
         {
            pFgtTop = pFgtTop->pNext;
         } while ( pFgtTop && !PRESENT(fAvailable,pFgtTop) );

         if (! pFgtTop )
         {
            pFgtTop = plFgt->pParent;
            plFgt = pFgtTop;
         }
         else
            break;
      } while ( pFgtTop );
   }
   if ( pFgtCaret && !PRESENT(fAvailable,pFgtCaret) )
   {
      plFgt = pFgtCaret;
      do
      {
         do
         {
            pFgtCaret = pFgtCaret->pNext;
         } while ( pFgtCaret && !PRESENT(fAvailable,pFgtCaret) );

         if (! pFgtCaret )
         {
            pFgtCaret = plFgt->pParent;
            plFgt = pFgtCaret;
         }
         else
            break;
      } while ( pFgtCaret );
   }
   SendMessage(hwndLB,LB_RESETCONTENT,FALSE,0L);
   /*
    *  Reset horizontal extent.
    */
   SendMessage(hwndLB, LB_SETHORIZONTALEXTENT, 0, 0L);
   /*
    *  Now, add the appropiate items to the list box.
    */
   if ( fAvailable )
      uiRet = AvailableWalk(hwndLB);
   else
      uiRet = FilteredWalk(hwndLB);
   /*
    *  Lastly, insure a parent is scrolled to the top of the LB if it's kids
    *  have run off of the bottom of the LB.
    */
    if (pFgtTop)
        top = (int)SendMessage(hwndLB,LB_FINDSTRINGEXACT,0,(LPARAM)pFgtTop);

    if (pFgtCaret)
        caret = (int)SendMessage(hwndLB,LB_FINDSTRINGEXACT,0,(LPARAM)pFgtCaret);

    if (!pFgtTop || top == (int)LB_ERR)
        top = 0;

    if (!pFgtCaret || caret == (int)LB_ERR)
        caret = 0;

    if ( fScrollup && pFgtCaret && pFgtCaret->pKid )
    {
        if (caret < top)
            top = caret;

        for (pFgt = pFgtCaret->pKid, n = 1; pFgt; pFgt = pFgt->pNext)
            ++n;

        if (n >= nVis)
            top = caret;
        else if (caret + n > top + nVis)
            top = caret - nVis + n;
    }
    SendMessage(hwndLB, LB_SETTOPINDEX, top, 0L);
    SendMessage(hwndLB, LB_SETCARETINDEX, caret, 0L);
    SendMessage(hwndLB, LB_SETSEL, TRUE, MAKELPARAM(caret,0));

    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hwndLB, NULL, TRUE);
    return(uiRet);
}

/*****************************************************************************
 * FilteredWalk()
 *
 * Helper function called only from FillFilterTree(). This bit of code walks
 * the filter group tree and adds the selected nodes to the listbox given.
 *
 * ENTRY:
 *   hwndLB - Handle to the list box to which items are to be added.
 *
 * EXIT:
 *   uint - Returns the number of items added to the listbox.
 *
 ****************************************************************************/
UINT CDefineSS::FilteredWalk(HWND hwndLB)
{
   CFolder*  pFgt;
   CFolder*  pFgtLast;
   UINT  i = 0;

   pFgt = m_pCollection->m_Collection.GetVisableRootFolder();
   /*
    *  Ok, now we actually do all the walking of the filter linked list to
    *  re-generate the filter listbox contnets. This must be done in the
    *  order in which the items appear in the LB. ie. Depthwise.
    */
   while ( pFgt )
   {
      do
      {
         if ( pFgt->f_Filter && !pFgt->f_IsOrphan )
         {
            SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)pFgt);
            i++;
         }
         pFgtLast = pFgt;
         if ( pFgt->f_F_Open )
            pFgt = pFgt->pKid;
         else
            break;
      } while ( pFgt );
      pFgt = pFgtLast;
      while ( pFgt && (! (pFgt->pNext)) )
         pFgt = pFgt->pParent;
      if ( pFgt )
         pFgt = pFgt->pNext;
   }
   return(i);
}

/*****************************************************************************
 * AvailableWalk()
 *
 * Helper function called only from FillFilterTree(). This bit of code walks
 * the filter group tree and adds the selected nodes to the listbox given.
 *
 * ENTRY:
 *   hwndLB - Handle to the list box to which items are to be added.
 *
 * EXIT:
 *   uint - Returns the number of items added to the listbox.
 *
 ****************************************************************************/
UINT CDefineSS::AvailableWalk(HWND hwndLB)
{
   CFolder*  pFgt;
   CFolder*  pFgtLast;
   UINT  i = 0;

   pFgt = m_pCollection->m_Collection.GetVisableRootFolder();
   /*
    *  Ok, now we actually do all the walking of the filter linked list to
    *  re-generate the filter listbox contnets. This must be done in the
    *  order in which the items appear in the LB. ie. Depthwise.
    */
   while ( pFgt )
   {
      do
      {
         if ( pFgt->f_Available && !pFgt->f_IsOrphan )
         {
            SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)pFgt);
            i++;
         }
         pFgtLast = pFgt;
         if ( pFgt->f_A_Open )
            pFgt = pFgt->pKid;
         else
            break;
      } while ( pFgt );
      pFgt = pFgtLast;
      while ( pFgt && (! (pFgt->pNext)) )
         pFgt = pFgt->pParent;
      if ( pFgt )
         pFgt = pFgt->pNext;
   }
   return(i);
}

//
// Change a dialog's default push button
//
BOOL CDefineSS::SetDefaultButton( HWND hDlg, int iID, BOOL fFocus )
{
  BOOL bReturn = FALSE;

  if( hDlg ) {

    // Get the current default push button and reset it.
    ResetDefaultButton( hDlg );

    // Update the default push button's control ID.
    SendMessage( hDlg, DM_SETDEFID, (WPARAM) iID, 0L );

    // Set the new style.
    bReturn = (BOOL) SendDlgItemMessage( hDlg, iID, BM_SETSTYLE, (WPARAM) BS_DEFPUSHBUTTON, (LPARAM) TRUE );

    // Set the focus to the new default push button.
    if( fFocus )
      bReturn &= (SetFocus( GetDlgItem( hDlg, iID ) ) != NULL);

  }
  return( bReturn );
}

//
// Clear the current default button status from the default push button
//
void CDefineSS::ResetDefaultButton( HWND hDlg )
{
  DWORD dwResult;

  if( hDlg ) {

    // Get the current default push button.
    dwResult = (DWORD) SendMessage( hDlg, DM_GETDEFID, 0, 0L );

    // Reset the current default push button to a regular button.
    if( HIWORD(dwResult) == DC_HASDEFID )
      SendDlgItemMessage( hDlg, LOWORD(dwResult), BM_SETSTYLE, (WPARAM) BS_PUSHBUTTON, (LPARAM) TRUE );

  }

  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sysnames.cpp ===
// Include this to assure identical names between compiler and hhctrl

#include "sysnames.h"

const char txtStringsFile[]  = "#STRINGS";
const char txtURLsFile[]	 = "#URLS";
const char txtWindowsFile[]  = "#WINDOWS";
const char txtSystemFile[]	 = "#SYSTEM";
const char txtIdxHdrFile[]	 = "#IDXHDR";
const char txtTocIdxFile[]	 = "#TOCIDX";
const char txtTopicsFile[]	 = "#TOPICS";
const char txtUrlTblFile[]	 = "#URLTBL";
const char txtUrlStrFile[]	 = "#URLSTR";
const char txtGrpInfFile[]	 = "#GRPINF";
const char txtMAP[] 		 = "#IVB";		 // number to URL mapping
const char txtITBits[]		 = "#ITBITS";	  // InfoType bit storage.
const char txtSubSetFile[]   = "#SUBSETS";   // The subset storage.
const char txtInfoTypeFile[] = "#INFOTYPES";    // InfoType and Category storage.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\subset.h ===
/*****************************************************************************
 * Copyright (C) Microsoft, 1989-1998
 * Feb 22, 1998
 *
 *  subset.h - subset.cpp header.
 *
 *  Modification History:
 *
 *  02/22/98  MC  Port to hhctrl.ocx from old B2 code.
 *
 *****************************************************************************/
#include <commctrl.h>

#define MAX_SS_NAME                 50

#define SS_ENTIRE_CONTENTS          0x0001
#define SS_READ_ONLY                0x0002
#define SS_EMPTY_SUBSET             0x0004       // Also refered to as "new" subset.
#define SS_FTS                      0x0008
#define SS_TOC                      0x0010
#define SS_F1                       0x0020

class CExTitle;
class CExCollection;
class CFolder;

// This is the subset class (singular)

class CStructuralSubset
{
public:
   CStructuralSubset(PCSTR pszSubSetName = NULL);
   ~CStructuralSubset();

   void NameSubSet(PCSTR pszSubSetName) { lstrcpy(m_szSubSetName,pszSubSetName); }
   void AddHash(DWORD dwHash);
   BOOL IsTitleInSubset(CExTitle* pTitle);
   int  GetHashCount() { return m_iHashCount; }
   HASH EnumHashes(int pos);
   PSTR GetName() { return m_szSubSetName; }
   PSTR GetID() { return m_szSSID; }
   BOOL IsEntire() { return (m_dwFlags & SS_ENTIRE_CONTENTS); }
   BOOL IsReadOnly() { return (m_dwFlags & SS_READ_ONLY); }
   BOOL IsEmpty() { return (m_dwFlags & SS_EMPTY_SUBSET); }
   BOOL IsFTS() { return (m_dwFlags & SS_FTS); }
   BOOL IsF1() { return (m_dwFlags & SS_F1); }
   BOOL IsTOC() { return (m_dwFlags & SS_TOC); }
   void SetEntire() { m_dwFlags |= SS_ENTIRE_CONTENTS; }
   void SetReadOnly() { m_dwFlags |= SS_READ_ONLY; }
   void SetEmpty() { m_dwFlags |= SS_EMPTY_SUBSET; }
   void SelectAsTOCSubset(CExCollection* pCollection);

private:
   HASH*  m_pdwHashes;
   int    m_iHashCount;
   int    m_iAllocatedCount;
   TCHAR  m_szSubSetName[MAX_SS_NAME];
   TCHAR  m_szSSID[MAX_SS_NAME];
   CStructuralSubset* m_pNext;    // Used only in the list class CSSList
   DWORD  m_dwFlags;

   void MarkNode(CFolder* pFgti, BOOL bVisable);

friend class CDefineSS;
friend class CSSList;
};

// CDefineSS is the UI wrapper class.

class CDefineSS
{
public:
   CDefineSS(CExCollection* pCollection);
   ~CDefineSS();

   CStructuralSubset* DefineSubset(HWND hWnd, CStructuralSubset* = NULL);

private:
   BOOL InitDialog(HWND hDlg, LPSTR szRange);
   WORD ExpandContract(HWND hwndLB, CFolder* pFgt, int sel, BOOL which);
   BOOL FilterDlgCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
   void MeasureFBItem(LPMEASUREITEMSTRUCT lpMIS);
   void DrawFBItem(HWND hDlg, LPDRAWITEMSTRUCT lpDI, UINT LbId);
   UINT FillFilterTree(HWND hwndLB, BOOL fAvailable, BOOL fScrollup);
   UINT AvailableWalk(HWND hwndLB);
   UINT FilteredWalk(HWND hwndLB);
   BOOL DoesNodeHaveANext(UINT LbId, int n, CFolder* pFgt);
   void AddNode2Filter(CFolder* pFgti);
   void SetAvailableStatus(CFolder* pFgt);
   void RemoveNodeFromFilter(CFolder* pFgt);
   void SetFilterStatus(CFolder* pFgt);
   BOOL SetRangeToTree(CStructuralSubset* pSS);
   CStructuralSubset* GetRangeFromTree(LPSTR sz);
   BOOL SaveFilter(HWND hDlg);
   void SetSaveStatus(HWND hDlg);
   BOOL ShouldSave(HWND hDlg);
   BOOL SetDefaultButton( HWND hDlg, int iID, BOOL fFocus );
   void ResetDefaultButton( HWND hDlg );

   INT_PTR static FilterDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
   LRESULT static MyFilterLBFunc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:
   HWND m_hWndParent;
   BOOL m_bShouldSave;
   WNDPROC m_lpfnOrigLBProc;
   int m_giIndentSpacing;
   int m_giXpos;
   CStructuralSubset* m_pSS;
   CExCollection* m_pCollection;
   HIMAGELIST  m_hIL;
   int m_iFontHeight;
   int m_iGlyphX;
   int m_iGlyphY;
   static CDefineSS* m_pThis;
};

// This is the class that manages all subsets.

class CSSList
{
public:
   CSSList();
   ~CSSList();

   CStructuralSubset* GetFTS()   { return m_pFTS_SS; }
   CStructuralSubset* GetF1() { return m_pF1_SS; }
   CStructuralSubset* GetTOC()   { return m_pTOC_SS; }
   CStructuralSubset* GetNew()   { return m_pNew_SS; }
   CStructuralSubset* GetEC()   { return m_pEC_SS; }

   void SetFTS(CStructuralSubset* pSS) { Set(pSS, &m_pFTS_SS, SS_FTS); }
   void SetF1(CStructuralSubset* pSS) { Set(pSS, &m_pF1_SS, SS_F1); }
   void SetTOC(CStructuralSubset* pSS) { Set(pSS, &m_pTOC_SS, SS_TOC); }
   void SetNew(CStructuralSubset* pSS) { m_pNew_SS = pSS; }
   void SetEC(CStructuralSubset* pSS) { m_pEC_SS = pSS; }


   int GetCount() { return m_iSubSetCount; }
   CStructuralSubset* GetNextSubset(CStructuralSubset* pSS) { return pSS ? pSS->m_pNext : m_pHeadSubSets; }
   CStructuralSubset* GetSubset(PSTR pszSSName);
   void DeleteSubset(CStructuralSubset* pSS, CStructuralSubset* pSSNew = NULL, HWND hWndUI = NULL);
   HRESULT PersistSubsets(CExCollection* pCollection);
   HRESULT RestoreSubsets(CExCollection* pCollection, PSTR pszRestoreSS);
   HRESULT ReadPreDefinedSubsets(CExCollection* pCollection, PSTR pszRestoreSS);
   HRESULT AddSubset(CStructuralSubset* pSS, HWND hWndUI = NULL);

private:
   void Set(CStructuralSubset* pSSNew, CStructuralSubset** pSSOld, DWORD dwFlags);
   int m_iSubSetCount;
   CStructuralSubset* m_pHeadSubSets;
   CStructuralSubset* m_pFTS_SS;
   CStructuralSubset* m_pF1_SS;
   CStructuralSubset* m_pTOC_SS;
   CStructuralSubset* m_pNew_SS;
   CStructuralSubset* m_pEC_SS;
};

#define SS_FILE_SIGNATURE      0x12345679

//
// File format for subset storage.
//
typedef struct
{
   DWORD dwSig;                                 // Signature (do we know this file?)
   DWORD dwVer;                                 // Version of hhctrl that wrote this file.
   INT   iSSCount;                              // Count of SubSets in the file.
   DWORD dwFlags;                               // Reserved flag bits.
   TCHAR lpszCurrentSSName[MAX_SS_NAME_LEN];    // The name of the subset.
   DWORD dwReserved1;
   DWORD dwReserved2;
   DWORD dwReserved3;
} SSHEADER, *PSSHEADER;

typedef struct
{
   INT      iHashCount;                     // How many hashes in this subset.
   TCHAR    lpszSSName[MAX_SS_NAME_LEN];    // The name of the subset.
   TCHAR    lpszSSID[MAX_SS_NAME_LEN];      // The subset identifier.
   DWORD    dwFlags;                        // reserved flag bits.
   DWORD    dwHashes[1];                    // The hash array.
} SS, *PSS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\sysnames.h ===
extern const char txtStringsFile[];
extern const char txtURLsFile[];
extern const char txtWindowsFile[];
extern const char txtSystemFile[];
extern const char txtIdxHdrFile[];
extern const char txtTocIdxFile[];
extern const char txtTopicsFile[];
extern const char txtUrlTblFile[];
extern const char txtUrlStrFile[];
extern const char txtGrpInfFile[];
extern const char txtMAP[]; 	  // number to URL mapping
extern const char txtITBits[];	   // InfoType bit storage.
extern const char txtSubSetFile[];   // The subset strings
extern const char txtInfoTypeFile[]; // InfoType and Category storage.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\system.cpp ===
// This module is for reading binary files out of a compiled HTML file

#include "header.h"
#include "system.h"
#include "htmlhelp.h"
#include "strtable.h"
#include "fts.h"
#include "TCHAR.h"
#include "parserhh.h"
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"

#include "secwin.h" // Only included for SetWinType....

enum {
    TYPE_STRINGS,
    TYPE_URLS,
};

#include "sysnames.h"

CHmData** g_phmData;
BOOL AddTitleToGlobalList(PCSTR pszITSSFile);

/////////////////////////////////////////////////////////////////////////////////////////////
// Darwin Stuff
//

// REVIEW: These must be tied to the calling process. If we ever support
// multiple processes in a single OCX, this will break big time.

PSTR g_pszDarwinGuid;
PSTR g_pszDarwinBackupGuid;

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation - read in the title informaton file (#SYSTEM) settings for each title
//

#ifndef SEEK_SET
  #define SEEK_CUR    1
  #define SEEK_END    2
  #define SEEK_SET    0
#endif

unsigned short CharsetFromLangID(unsigned short uLangID)
{
   unsigned short uCharset;

   switch (uLangID)
   {
      case LANG_RUSSIAN:      uCharset = RUSSIAN_CHARSET; break;
      case LANG_ENGLISH:      uCharset = ANSI_CHARSET; break;
      case LANG_JAPANESE:     uCharset = SHIFTJIS_CHARSET; break;
      case LANG_KOREAN:       uCharset = HANGEUL_CHARSET; break;
      case LANG_ARABIC:       uCharset = ARABIC_CHARSET; break;
      case LANG_GREEK:        uCharset = GREEK_CHARSET; break;
      case LANG_THAI:         uCharset = THAI_CHARSET; break;
      case LANG_HEBREW:       uCharset = HEBREW_CHARSET; break;
      case LANG_TURKISH:      uCharset = TURKISH_CHARSET; break;
      case LANG_VIETNAMESE:   uCharset = VIETNAMESE_CHARSET; break;

      case LANG_CHINESE:
         if ( (SUBLANGID(uLangID) == SUBLANG_CHINESE_TRADITIONAL) || (SUBLANGID(uLangID) == SUBLANG_CHINESE_HONGKONG) )
            uCharset = CHINESEBIG5_CHARSET;
         else
            uCharset = GB2312_CHARSET;
         break;

      default:
         uCharset = DEFAULT_CHARSET;
   }
   return uCharset;
}

CTitleInformation::CTitleInformation( CFileSystem* pFileSystem )
{
  ClearMemory( this, sizeof( CTitleInformation ) );
  m_pFileSystem = pFileSystem;
  m_iCharset = -1;
}

CTitleInformation::~CTitleInformation()
{
    if (m_pszCompilerVersion)
        lcFree (m_pszCompilerVersion); // leak fix

  CHECK_AND_FREE( m_pszDefToc );
  CHECK_AND_FREE( m_pszDefIndex );
  CHECK_AND_FREE( m_pszDefHtml );
  CHECK_AND_FREE( m_pszDefCaption );
  CHECK_AND_FREE( m_pszDefWindow );
  CHECK_AND_FREE( m_pszShortName );

  if( m_pdInfoTypes )
      lcFree(m_pdInfoTypes );
  if (m_paExtTabs) {
    for (DWORD i = 0; i < m_cExtTabs; i++) {
        lcFree(m_paExtTabs[i].pszTabName);
        lcFree(m_paExtTabs[i].pszProgId);
    }
    lcFree(m_paExtTabs);
  }
  if ( m_hFontAccessableContent && (m_hFontAccessableContent != m_hFont) )
    DeleteObject(m_hFontAccessableContent);

  if (m_hFont)
    DeleteObject(m_hFont);
}

HRESULT CTitleInformation::Initialize()
{
  if( !m_pFileSystem )
    return S_FALSE;

  // open the title information file (#SYSTEM)
  CSubFileSystem* pSubFileSystem = new CSubFileSystem(m_pFileSystem);
  HRESULT hr = pSubFileSystem->OpenSub(txtSystemFile);
  if( FAILED(hr))
      return S_FALSE;

  // check the version of the title information file (#SYSTEM)

  DWORD dwVersion;
  DWORD cbRead;
  hr = pSubFileSystem->ReadSub(&dwVersion, sizeof(dwVersion), &cbRead);
  if( FAILED(hr) || cbRead != sizeof(dwVersion) ) {
    delete pSubFileSystem;
    return STG_E_READFAULT;
  }
  if( dwVersion > VERSION_SYSTEM ) {
    // BUGBUG: This will fail if we allow more then one process to attach
    // to us -- meaning we won't put up a warning for each process

    static BOOL fWarned = FALSE;
    if (!fWarned) {
        MsgBox(IDS_NEWER_VERSION);
        fWarned = TRUE;
    }
    return STG_E_OLDDLL;
  }

  // read in each and every item (skip those tags we don't care about)

  SYSTEM_TAG tag;
  for(;;) {

    // get the tag type

    hr = pSubFileSystem->ReadSub(&tag, sizeof(SYSTEM_TAG), &cbRead);
    if( FAILED(hr) || cbRead != sizeof(SYSTEM_TAG))
      break;

    // handle each tag according to it's type

    switch( tag.tag ) {

      // where all of our simple settings are stored

      case TAG_SYSTEM_FLAGS: {
        ZERO_STRUCTURE( m_Settings );
        DWORD cbSettings = sizeof(m_Settings);
        DWORD cbTag = tag.cbTag;
        DWORD cbReadIn = 0;
        if( cbTag > cbSettings )
          cbReadIn = cbSettings;
        else
          cbReadIn = cbTag;
          hr = pSubFileSystem->ReadSub( &m_Settings, cbReadIn, &cbRead );
        if( cbTag > cbSettings )
          hr = pSubFileSystem->SeekSub( cbTag-cbSettings, SEEK_CUR );
        break;
      }

      // where the short name of the title is stored

      case TAG_SHORT_NAME:
        m_pszShortName = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszShortName, tag.cbTag, &cbRead);
        break;

      case TAG_DEFAULT_TOC:
        m_pszDefToc = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszDefToc, tag.cbTag, &cbRead);
        break;

      case TAG_DEFAULT_INDEX:
        m_pszDefIndex = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszDefIndex, tag.cbTag, &cbRead);
        break;

      case TAG_DEFAULT_HTML:
        m_pszDefHtml = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszDefHtml, tag.cbTag, &cbRead);
        break;

      case TAG_DEFAULT_CAPTION:
        m_pszDefCaption = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszDefCaption, tag.cbTag, &cbRead);
        break;

      case TAG_DEFAULT_WINDOW:
        m_pszDefWindow = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszDefWindow, tag.cbTag, &cbRead);
        break;

      case TAG_HASH_BINARY_TOC:
        hr = pSubFileSystem->ReadSub((void*) &m_hashBinaryTocName, tag.cbTag, &cbRead);
        break;

      case TAG_HASH_BINARY_INDEX:
        hr = pSubFileSystem->ReadSub((void*) &m_hashBinaryIndexName, tag.cbTag, &cbRead);
        break;

      case TAG_INFO_TYPES:
        ASSERT(!m_pdInfoTypes);
        m_pdInfoTypes = (INFOTYPE_DATA*) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pdInfoTypes, tag.cbTag, &cbRead);
        break;

      case TAG_COMPILER_VERSION:
        m_pszCompilerVersion = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszCompilerVersion, tag.cbTag, &cbRead);
        break;

      case TAG_INFOTYPE_COUNT:
        hr = pSubFileSystem->ReadSub((void*)&m_iCntInfoTypes, tag.cbTag, &cbRead);
        break;

      case TAG_IDXHEADER:
        hr = pSubFileSystem->ReadSub((void*)&m_idxhdr, tag.cbTag, &cbRead);
        m_bGotHeader = TRUE;
        break;

      case TAG_EXT_TABS:
        {
            ASSERT_COMMENT(!m_ptblExtTabs, "TAG_EXT_TABS appears in the system file twice.");
            hr = pSubFileSystem->ReadSub((void*) &m_cExtTabs, sizeof(DWORD), &cbRead);
            CMem mem(tag.cbTag);
            hr = pSubFileSystem->ReadSub((void*) mem.pb,
                tag.cbTag - sizeof(DWORD), &cbRead);
            PCSTR psz = (PCSTR) mem.pb;
            m_paExtTabs = (EXTENSIBLE_TAB*) lcMalloc(m_cExtTabs * sizeof(EXTENSIBLE_TAB));
            for (DWORD iTab = 0; iTab < m_cExtTabs; iTab++) {
                m_paExtTabs[iTab].pszTabName = lcStrDup(psz);
                psz += strlen(psz) + 1;
                m_paExtTabs[iTab].pszProgId = lcStrDup(psz);
                psz += strlen(psz) + 1;

                //--- Add the accelerator to the global accelerator list.
                char* p = strchr(m_paExtTabs[iTab].pszTabName , '&') ;
                if (p != NULL)
                {
                    _Resource.TabCtrlKeys(HH_TAB_CUSTOM_FIRST + iTab, tolower(*(p+1))) ;
                }
            }
        }
        break;

      case TAG_DEFAULT_FONT:
        m_pszDefaultFont = (PCSTR) lcMalloc(tag.cbTag);
        hr = pSubFileSystem->ReadSub((void*) m_pszDefaultFont, tag.cbTag, &cbRead);
        ASSERT_COMMENT(!m_hFont, "Compiler should never allow two font tags");
        m_hFont = (HFONT)1;  // just to say we've been here before...
        break;

      case TAG_NEVER_PROMPT_ON_MERGE:
        hr = pSubFileSystem->ReadSub( (void*) &m_bNeverPromptOnMerge, tag.cbTag, &cbRead);
        break;


      // skip those we don't care about or don't know about

      default:
        hr = pSubFileSystem->SeekSub( tag.cbTag, SEEK_CUR );
        break;

    }

    if( FAILED(hr) ) {
      delete pSubFileSystem;
      return STG_E_READFAULT;
    }
  }
  delete pSubFileSystem;
  //
  // Init title charset.
  //
  unsigned short uLangID = PRIMARYLANGID(LANGIDFROMLCID(m_Settings.lcid));
  m_iCharset = CharsetFromLangID(uLangID);
  //
  // Init the title font...
  //
  _Module.SetCodePage(CodePageFromLCID(m_Settings.lcid));
#ifndef CHIINDEX
  InitContentFont(m_pszDefaultFont);
#endif
  m_bInit = TRUE;
  return S_OK;
}

void CTitleInformation::InitContentFont(PCSTR pszFontSpec)
{
   TCHAR szLocal[MAX_PATH];
   PSTR pszComma;
   LOGFONT lf;
   NONCLIENTMETRICS ncm;

   //
   // We're only going to trust the charset specification if it came from the title!
   //
   if ( !pszFontSpec || !(*pszFontSpec) )
   {
      // if Win9X on Japaneese system. AsPer Achimru Bug# 7012
      //
      if ( (GetVersion() >= 0x80000000) && ( (_Module.m_Language.GetUiLanguage() & 0x00FF) == LANG_JAPANESE) )
         pszFontSpec = "MS P Gothic,9,128";
      else
      {
#ifndef HHUTIL
         pszFontSpec = (PSTR)GetStringResource(IDS_DEFAULT_CONTENT_FONT);
#endif
            // HH bugs 7859 and 7707:
            //
            // It turns out that on Win9x, using DEFAULT_CHARSET means I don't care about the char set. Soooo, the
            // last thing we want to do is use a blank facename with default charset on Win9x. On NT, default_charset
            // has a reasonable meaning, i.e. use an appropiate charset based on system locale. So, to fix the above
            // bugs, I'm only going to execute this logic on NT. <mc>
            //
            if( g_fSysWinNT )
            {
               // lang != english AND the resID charset does NOT match the .CHM charset then use a blank facename
               // but retain the pointsize specified in the resource string.
               //
               char* pszFS = StrChr(pszFontSpec, ',');
               int iCharSet = Atoi(pszFontSpec + 1);
               if ( pszFontSpec && ((m_iCharset != ANSI_CHARSET) || (m_iCharset != DEFAULT_CHARSET)) && (iCharSet != m_iCharset) )
                   pszFontSpec = pszFS;
            }
      }

      if ( !pszFontSpec )
      {
         // nothing specified in the .res file. Go with hardcoded defaults?
         //
         lstrcpy(szLocal, "MS Shell Dlg,8");
      }
      else
         lstrcpy(szLocal, pszFontSpec);
   }
   else
   {
      //
      // We have a specification from the .HHP file, insure it matches the LCID specified in the .HHP
      // The specification string is formatted as followes:
      // Facename, point size, charset, (BOLD | ITALIC | UNDERLINE) | 0x???? colorspec | #rrggbb colorspec
      //
      // We'll override the charset selected from the title LCID if we have a valid one specified in the title font.
      //
      lstrcpy(szLocal, pszFontSpec);
      if ( (pszComma = StrChr(szLocal, ',')) )
      {
         pszComma++;
         if ( (pszComma = StrChr(pszComma, ',')) )
         {
            pszComma++;
            m_iCharset = atoi(pszComma);
         }
      }
   }
   // We (Doug and Mikecole) have decided to override the ANSI charset (english) with the current user charset
   // in the event we find we're viweing an english chm on a non englist system on Win9X...
   //
   if ( (m_iCharset == ANSI_CHARSET) )
   {
      LANGID lid = _Module.m_Language.GetUiLanguage();
      m_iCharset = CharsetFromLangID(lid);
   }
    
    if(g_fSysWinNT)
    {
        char wchLocale[10];

        // Check to see if the system understands the LCID of the title.  If not, we have no way of 
		// accurately processing the text in szLocal (it's in an encoding the OS doesn't understand).
		// The only safe thing we can do is to default to MS Shell Dlg and hope for the best.
		//
        if (!GetLocaleInfoA(m_Settings.lcid, LOCALE_IDEFAULTANSICODEPAGE, wchLocale, sizeof(wchLocale)))
            lstrcpy(szLocal, "MS Shell Dlg,8");
		
        WCHAR *pwcLocal = MakeWideStr(szLocal,CodePageFromLCID(m_Settings.lcid));
        if(pwcLocal)
        {
            m_hFont = CreateUserFontW(pwcLocal, NULL, NULL, m_iCharset);
            free(pwcLocal);
        }            
    }
    else
        m_hFont = CreateUserFont(szLocal, NULL, NULL, m_iCharset);
    
   ASSERT(m_hFont);
   BOOL bRet1 = GetObject(m_hFont, sizeof(lf), &lf) ;
   ncm.cbSize = sizeof(NONCLIENTMETRICS);
   BOOL bRet2 = SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), (void*)&ncm, 0);
   if ( bRet1 && bRet2 && (ncm.lfMenuFont.lfHeight < lf.lfHeight) )
   {
      lf.lfHeight = ncm.lfMenuFont.lfHeight;
      m_hFontAccessableContent = CreateFontIndirect(&lf);
   }
   else
      m_hFontAccessableContent = m_hFont;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation2 - get title informaton without going through the file system
//

CTitleInformation2::CTitleInformation2( LPCTSTR pszPathName )
{
  ClearMemory( this, sizeof(CTitleInformation2) );
  m_pszPathName = pszPathName;
}

CTitleInformation2::~CTitleInformation2()
{
  if( m_pszShortName )
    delete [] (PSTR) m_pszShortName;
}

HRESULT CTitleInformation2::Initialize()
{
  HANDLE hFile = CreateFile( m_pszPathName, GENERIC_READ, FILE_SHARE_READ,
    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

  if( hFile == INVALID_HANDLE_VALUE )
    return S_FALSE;

  DWORD dwFileStamp = 0;
  LCID FileLocale = 0;
  DWORD dwRead = 0;

  SetFilePointer( hFile, 4*sizeof(UINT), NULL, FILE_BEGIN );
  ReadFile( hFile, (void*) &dwFileStamp, sizeof( dwFileStamp ), &dwRead, NULL );
  ReadFile( hFile, (void*) &FileLocale, sizeof( FileLocale ), &dwRead, NULL );
  CloseHandle( hFile );

  m_FileTime.dwLowDateTime = dwFileStamp;
  m_FileTime.dwHighDateTime = dwFileStamp;
  m_lcid = FileLocale;

  TCHAR szShortName[MAX_PATH];
  LPTSTR pszShortName = szShortName;

  GetFullPathName( m_pszPathName, MAX_PATH, szShortName, &pszShortName );
  LPTSTR pszShortNameEnd = StrRChr( pszShortName, '.' );
  *pszShortNameEnd = 0;

  m_pszShortName = new char[ strlen(pszShortName)+1 ];
  strcpy( (PSTR) m_pszShortName, pszShortName );

  m_bInit = TRUE;
  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////
// CHmData
//
#ifdef _WIN64
typedef struct tagHH_DISK_WINTYPE {
    int     cbStruct;        // IN: size of this structure including all Information Types
    BOOL    fUniCodeStrings; // IN/OUT: TRUE if all strings are in UNICODE
    DWORD /*LPCTSTR*/ pszType;// IN/OUT: Name of a type of window
    DWORD   fsValidMembers;  // IN: Bit flag of valid members (HHWIN_PARAM_)
    DWORD   fsWinProperties; // IN/OUT: Properties/attributes of the window (HHWIN_)

    DWORD /*LPCTSTR*/ pszCaption;// IN/OUT: Window title
    DWORD   dwStyles;        // IN/OUT: Window styles
    DWORD   dwExStyles;      // IN/OUT: Extended Window styles
    RECT    rcWindowPos;     // IN: Starting position, OUT: current position
    int     nShowState;      // IN: show state (e.g., SW_SHOW)

    LONG /*HWND*/  hwndHelp;          // OUT: window handle
    LONG /*HWND*/  hwndCaller;        // OUT: who called this window

    DWORD /*HH_INFOTYPE* */ paInfoTypes;  // IN: Pointer to an array of Information Types

    // The following members are only valid if HHWIN_PROP_TRI_PANE is set

    LONG /*HWND*/  hwndToolBar;      // OUT: toolbar window in tri-pane window
    LONG /*HWND*/  hwndNavigation;   // OUT: navigation window in tri-pane window
    LONG /*HWND*/  hwndHTML;         // OUT: window displaying HTML in tri-pane window
    int   iNavWidth;        // IN/OUT: width of navigation window
    RECT  rcHTML;           // OUT: HTML window coordinates

    DWORD /*LPCTSTR*/ pszToc;         // IN: Location of the table of contents file
    DWORD /*LPCTSTR*/ pszIndex;       // IN: Location of the index file
    DWORD /*LPCTSTR*/ pszFile;        // IN: Default location of the html file
    DWORD /*LPCTSTR*/ pszHome;        // IN/OUT: html file to display when Home button is clicked
    DWORD   fsToolBarFlags; // IN: flags controling the appearance of the toolbar
    BOOL    fNotExpanded;   // IN: TRUE/FALSE to contract or expand, OUT: current state
    int     curNavType;     // IN/OUT: UI to display in the navigational pane
    int     tabpos;         // IN/OUT: HHWIN_NAVTAB_TOP, HHWIN_NAVTAB_LEFT, or HHWIN_NAVTAB_BOTTOM
    int     idNotify;       // IN: ID to use for WM_NOTIFY messages
    BYTE    tabOrder[HH_MAX_TABS + 1];    // IN/OUT: tab order: Contents, Index, Search, History, Favorites, Reserved 1-5, Custom tabs
    int     cHistory;       // IN/OUT: number of history items to keep (default is 30)
    DWORD /*LPCTSTR*/ pszJump1;       // Text for HHWIN_BUTTON_JUMP1
    DWORD /*LPCTSTR*/ pszJump2;       // Text for HHWIN_BUTTON_JUMP2
    DWORD /*LPCTSTR*/ pszUrlJump1;    // URL for HHWIN_BUTTON_JUMP1
    DWORD /*LPCTSTR*/ pszUrlJump2;    // URL for HHWIN_BUTTON_JUMP2
    RECT    rcMinSize;      // Minimum size for window (ignored in version 1)
    int     cbInfoTypes;    // size of paInfoTypes;
    DWORD /*LPCTSTR*/ pszCustomTabs;  // multiple zero-terminated strings
} HH_DISK_WINTYPE, *PHH_DISK_WINTYPE;

static
void ConvertToWin64HHWinType( HH_WINTYPE& rWinType , const HH_DISK_WINTYPE& rDiskWinType )
{
    rWinType.cbStruct = sizeof(HH_WINTYPE);  // ???
    rWinType.fUniCodeStrings = rDiskWinType.fUniCodeStrings;
//    LPCTSTR pszType;         // IN/OUT: Name of a type of window
    rWinType.fsValidMembers = rDiskWinType.fsValidMembers;
    rWinType.fsWinProperties = rDiskWinType.fsWinProperties;

//    LPCTSTR pszCaption;      // IN/OUT: Window title
    rWinType.dwStyles = rDiskWinType.dwStyles;
    rWinType.dwExStyles = rDiskWinType.dwExStyles;
    CopyRect( &rWinType.rcWindowPos, &rDiskWinType.rcWindowPos );
    rWinType.nShowState = rDiskWinType.nShowState;

//    HWND  hwndHelp;          // OUT: window handle
//    HWND  hwndCaller;        // OUT: who called this window

//    HH_INFOTYPE* paInfoTypes;  // IN: Pointer to an array of Information Types

//    HWND  hwndToolBar;      // OUT: toolbar window in tri-pane window
//    HWND  hwndNavigation;   // OUT: navigation window in tri-pane window
//    HWND  hwndHTML;         // OUT: window displaying HTML in tri-pane window
    rWinType.iNavWidth = rDiskWinType.iNavWidth;
    CopyRect( &rWinType.rcHTML, &rDiskWinType.rcHTML );

//    LPCTSTR pszToc;         // IN: Location of the table of contents file
//    LPCTSTR pszIndex;       // IN: Location of the index file
//    LPCTSTR pszFile;        // IN: Default location of the html file
//    LPCTSTR pszHome;        // IN/OUT: html file to display when Home button is clicked
    rWinType.fsToolBarFlags = rDiskWinType.fsToolBarFlags;
    rWinType.fNotExpanded = rDiskWinType.fNotExpanded;
    rWinType.curNavType = rDiskWinType.curNavType;
    rWinType.tabpos = rDiskWinType.tabpos;
    rWinType.idNotify = rDiskWinType.idNotify;
    memcpy( rWinType.tabOrder, rDiskWinType.tabOrder, sizeof(rWinType.tabOrder) );
    rWinType.cHistory = rDiskWinType.cHistory;
//    LPCTSTR pszJump1;       // Text for HHWIN_BUTTON_JUMP1
//    LPCTSTR pszJump2;       // Text for HHWIN_BUTTON_JUMP2
//    LPCTSTR pszUrlJump1;    // URL for HHWIN_BUTTON_JUMP1
//    LPCTSTR pszUrlJump2;    // URL for HHWIN_BUTTON_JUMP2
    CopyRect( &rWinType.rcMinSize, &rDiskWinType.rcMinSize );
    rWinType.cbInfoTypes = rDiskWinType.cbInfoTypes;
//    LPCTSTR pszCustomTabs;  // multiple zero-terminated strings
}
#endif


CHmData::CHmData()
{
    ClearMemory(this, sizeof(CHmData));
}

CHmData::~CHmData()
{
    if( m_pszDefToc )
      lcFree( m_pszDefToc );

    if( m_pszDefIndex )
      lcFree( m_pszDefIndex );

    if (m_pTitleCollection)
        delete m_pTitleCollection;

    if (m_pdSubSets)
        lcFree(m_pdSubSets);

    if (m_pszITSSFile)
        lcFree(m_pszITSSFile);

}

int CHmData::Release(void)
{
   if ( cRef )
      cRef--;
   if (! cRef )
   {
      delete this;
      return 0;
   }
   else
      return cRef;
}

HFONT CHmData::GetContentFont()
{
 return (m_pTitleCollection->GetMasterTitle()->GetInfo()->GetContentFont());
}

// BUGBUG: This is broken! We cannot pass in any random offset and use GetFirstTitle() to fetch a string. <mc>

PCSTR CHmData::GetString(DWORD offset)
{
    ASSERT(m_pTitleCollection);
    ASSERT(m_pTitleCollection->GetFirstTitle());
    ASSERT(m_pTitleCollection->GetFirstTitle()->GetString(offset));
    return m_pTitleCollection->GetFirstTitle()->GetString(offset);
}

CExTitle* CHmData::GetExTitle(void)
{
    ASSERT(m_pTitleCollection);
    ASSERT(m_pTitleCollection->GetFirstTitle());
    return m_pTitleCollection->GetFirstTitle();
}

BOOL CHmData::ReadSubSets( CExTitle *pTitle )
{
ULONG cbRead;
HRESULT hr;
SYSTEM_TAG tag;

    CFSClient fsclient(pTitle->GetFileSystem(), txtSubSetFile);
    if (!fsclient.isStreamOpen())
        return TRUE;
    hr = fsclient.Read(&tag, sizeof(SYSTEM_TAG), &cbRead);
    if (FAILED(hr) || cbRead != sizeof(SYSTEM_TAG))
    {
        fsclient.CloseStream();
        return STG_E_READFAULT;
    }
    m_pdSubSets = (SUBSET_DATA *)lcMalloc(tag.cbTag);
    hr = fsclient.Read(m_pdSubSets, tag.cbTag, &cbRead);
    if (FAILED(hr) || cbRead != tag.cbTag)
    {
        fsclient.CloseStream();
        return STG_E_READFAULT;
    }

    return S_OK;
}

BOOL CHmData::ReadSystemFiles(PCSTR pszITSSFile)
{
    TCHAR szScratch[MAX_PATH];
    m_pTitleCollection = new CExCollection(this, pszITSSFile, !IsCollectionFile(pszITSSFile));
    if (m_pTitleCollection->InitCollection() == FALSE)
        return FALSE;

   CTitleInformation *pInfo = m_pTitleCollection->GetMasterTitle()->GetInfo();
   LANGID MasterLangId;

   if (pInfo)
      MasterLangId = LANGIDFROMLCID(pInfo->GetLanguage());
   else
      return FALSE;
   //
    // Determine if we are running a bidi title or collection
    //
   // This is the place where we turn on/off bi-di settings for the help system
   //
    if(PRIMARYLANGID(MasterLangId) == LANG_HEBREW || PRIMARYLANGID(MasterLangId) == LANG_ARABIC)
    {
        g_fuBiDiMessageBox = MB_RIGHT | MB_RTLREADING;

        // Turn on the Bi-Di "Mirroring" style when running on Bi-Di system and Win98 or NT5
        //
        if(g_bWinNT5 || g_bWin98)
        {
//            MessageBox(NULL,"Bidi Enabled NT5/Win98","Notice",MB_OK);
            g_RTL_Mirror_Style = WS_EX_LAYOUT_RTL | WS_EX_LTRREADING | WS_EX_RIGHT;
            g_RTL_Style = WS_EX_RTLREADING | WS_EX_RIGHT;
        }
        else
        {
//            MessageBox(NULL,"Bidi Under NT4/Win95","Notice",MB_OK);
            g_RTL_Mirror_Style = 0;
            g_RTL_Style = WS_EX_RTLREADING | WS_EX_RIGHT;
        }

        g_fBiDi = TRUE;
    }
    else
    {
//        MessageBox(NULL,"Bidi Not Enabled","Notice",MB_OK);
        g_fuBiDiMessageBox = 0;
        g_RTL_Style = 0;
        g_fBiDi = FALSE;
    }

    CExTitle* pTitle = m_pTitleCollection->GetMasterTitle();
    CStr cszCompiledFile(pTitle->GetIndexFileName());
    if (ReadSystemFile(pTitle) == FALSE)
        return FALSE;
    m_pInfo = pTitle->GetInfo();

    // init fts and keyword
    m_pTitleCollection->InitFTSKeyword();

    // init structural subsetting if appropiate.
    //
    m_pTitleCollection->InitStructuralSubsets();

    // Read the SubSets
    ReadSubSets ( pTitle );  //from the #SUBSETS subfile

    // Init the Infotypes and predefined subsets objects from the master title...
    if ( pTitle && pTitle->GetInfo() )
    {
       int iCntITBytes = ((pTitle->GetInfo()->GetInfoTypeCount() / 8) + 1);

       if ( ( m_pTitleCollection->m_pSubSets = new CSubSets(iCntITBytes, this, FALSE)) )
          m_pTitleCollection->m_pSubSets->CopyTo(this);
       //
       // Add "Entire Collection" to the list since all subset users (FTS, TOC and Index) use it.
       //
       CSubSet* pS =  m_pTitleCollection->m_pSubSets->AddSubSet();
       pS->m_bIsEntireCollection = TRUE;
       pS->m_cszSubSetName = (PCSTR)GetStringResource(IDS_ADVSEARCH_SEARCHIN_ENTIRE);
       memset(pS->m_pInclusive, 0xFF, pS->m_pIT->InfoTypeSize());
            // Mask out all the hidden ITs from entire contents.
       INFOTYPE HiddenIT;
       for ( int i=0; i< pS->m_pIT->m_itTables.m_cITSize; i++)
       {    HiddenIT = (*pS->m_pInclusive)+i & ~(*pS->m_pIT->m_itTables.m_pHidden)+i;
           memcpy( &(*pS->m_pInclusive)+i, &HiddenIT, sizeof(INFOTYPE) );                  // flip the Hidden bits in the filter mask
       }
       pS->m_bPredefined = TRUE;
       //
       // Restore persisted subset selections for FTS, Index anf TOC.
       //
       CState* pstate = m_pTitleCollection->GetState();
       DWORD cb;
       if ( SUCCEEDED(pstate->Open(g_szFTSKey,STGM_READ)) && SUCCEEDED(pstate->Read(szScratch,MAX_PATH,&cb)) && cb > 0 )
          m_pTitleCollection->m_pSubSets->SetFTSMask(szScratch);
       else
          m_pTitleCollection->m_pSubSets->SetFTSMask(pS->m_cszSubSetName);  // Entire Collection.
       pstate->Close();

       if ( SUCCEEDED(pstate->Open(g_szIndexKey,STGM_READ)) && SUCCEEDED(pstate->Read(szScratch,MAX_PATH,&cb)) && cb > 0 )
          m_pTitleCollection->m_pSubSets->SetIndexMask(szScratch);
       else
          m_pTitleCollection->m_pSubSets->SetIndexMask(pS->m_cszSubSetName);   // Entire Collection.
       pstate->Close();

       if ( SUCCEEDED(pstate->Open(g_szTOCKey,STGM_READ)) && SUCCEEDED(pstate->Read(szScratch,MAX_PATH,&cb)) && cb > 0 )
          m_pTitleCollection->m_pSubSets->SetTocMask(szScratch, NULL);
       else
          m_pTitleCollection->m_pSubSets->SetTocMask(pS->m_cszSubSetName, NULL);  // Entire Collection.
       pstate->Close();
    }

    // Read all the window definitions
    CFSClient fsclient(pTitle->GetFileSystem(), txtWindowsFile);
    if (!fsclient.isStreamOpen())
        return TRUE;
    DWORD cWindows;
    DWORD cbStruct;
    ULONG cbRead;
    CStr csz;
    HRESULT hr = fsclient.Read(&cWindows, sizeof(DWORD), &cbRead);
    if (FAILED(hr) || cbRead != sizeof(DWORD))
        goto ForgetIt;
    hr = fsclient.Read(&cbStruct, sizeof(DWORD), &cbRead);
    if (FAILED(hr) || cbRead != sizeof(DWORD))
        goto ForgetIt;

    HH_WINTYPE hhWinType;
#ifdef _WIN64
	HH_DISK_WINTYPE hhDiskWinType;
#else
#define hhDiskWinType  hhWinType
#endif

    DWORD i;
    for (i = 0; i < cWindows; i++)
    {
        ZERO_STRUCTURE(hhWinType);
#ifdef _WIN64
        ZERO_STRUCTURE(hhDiskWinType);
#endif
        hr = fsclient.Read(&hhDiskWinType, cbStruct, &cbRead);
#ifdef _WIN64
		ConvertToWin64HHWinType( hhWinType, hhDiskWinType );
#endif
        if (FAILED(hr) || cbRead != cbStruct)
            goto ForgetIt;

        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszType, &csz)))
            csz.TransferPointer(&hhWinType.pszType);
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszCaption, &csz)))
            csz.TransferPointer(&hhWinType.pszCaption);
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszJump1, &csz)))
            csz.TransferPointer(&hhWinType.pszJump1);
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszJump2, &csz)))
            csz.TransferPointer(&hhWinType.pszJump2);

        // BUGBUG: needs to match compiler which should be using URL store

        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString((DWORD) hhDiskWinType.pszToc, &csz)))
        {
            if (csz.IsNonEmpty()) // BUGBUG: GetString should fail on Empty strings.
            {
                if (!m_pszDefToc)
                    m_pszDefToc = lcStrDup(csz.psz);
                if (!stristr(csz, txtDoubleColonSep) &&
                        !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader)) {
                    cszCompiledFile = GetCompiledFile();
                    cszCompiledFile += txtSepBack;
                    cszCompiledFile += csz.psz;
                    cszCompiledFile.TransferPointer(&hhWinType.pszToc);
                }
                else
                    csz.TransferPointer(&hhWinType.pszToc);
            }
        }
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString((DWORD) hhDiskWinType.pszIndex, &csz)))
        {
            if (csz.IsNonEmpty()) // BUGBUG: GetString should fail on Empty strings.
            {
                if (!m_pszDefIndex)
                    m_pszDefIndex = lcStrDup(csz.psz);
                if (!stristr(csz, txtDoubleColonSep) &&
                        !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader))
                {
                    cszCompiledFile = GetCompiledFile();
                    cszCompiledFile += txtSepBack;
                    cszCompiledFile += csz.psz;
                    cszCompiledFile.TransferPointer(&hhWinType.pszIndex);
                }
                else
                    csz.TransferPointer(&hhWinType.pszIndex);
            }
        }
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszFile, &csz))) {
#if 0
            if (!stristr(csz, txtDoubleColonSep) &&
                    !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader)) {
                cszCompiledFile = GetCompiledFile();
                cszCompiledFile += txtSepBack;
                cszCompiledFile += csz.psz;
                cszCompiledFile.TransferPointer(&hhWinType.pszFile);
            }
            else
#endif
                csz.TransferPointer(&hhWinType.pszFile);
        }
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszHome, &csz))) {
            if (!stristr(csz, txtDoubleColonSep) &&
                    !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader)) {
                cszCompiledFile = GetCompiledFile();
                cszCompiledFile += txtSepBack;
                cszCompiledFile += csz.psz;
                cszCompiledFile.TransferPointer(&hhWinType.pszHome);
            }
            else
                csz.TransferPointer(&hhWinType.pszHome);
        }
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszUrlJump1, &csz))) {
            if (!stristr(csz, txtDoubleColonSep) &&
                    !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader)) {
                cszCompiledFile = GetCompiledFile();
                cszCompiledFile += txtSepBack;
                cszCompiledFile += csz.psz;
                cszCompiledFile.TransferPointer(&hhWinType.pszUrlJump1);
            }
            else
                csz.TransferPointer(&hhWinType.pszUrlJump1);
        }
        if (SUCCEEDED(m_pTitleCollection->GetFirstTitle()->GetString(
                (DWORD) hhDiskWinType.pszUrlJump2, &csz))) {
            if (!stristr(csz, txtDoubleColonSep) &&
                    !stristr(csz, txtFileHeader) && !stristr(csz, txtHttpHeader)) {
                cszCompiledFile = GetCompiledFile();
                cszCompiledFile += txtSepBack;
                cszCompiledFile += csz.psz;
                cszCompiledFile.TransferPointer(&hhWinType.pszUrlJump2);
            }
            else
                csz.TransferPointer(&hhWinType.pszUrlJump2);
        }

        // Set the window type, but don't call FindCurFileData...
        SetWinType(pszITSSFile, &hhWinType, this);

        CHECK_AND_FREE(hhWinType.pszType) ;
        CHECK_AND_FREE(hhWinType.pszCaption) ;
        CHECK_AND_FREE(hhWinType.pszToc) ;
        CHECK_AND_FREE(hhWinType.pszIndex) ;
        CHECK_AND_FREE(hhWinType.pszFile) ;
        CHECK_AND_FREE(hhWinType.pszHome) ;
        CHECK_AND_FREE(hhWinType.pszJump1) ;
        CHECK_AND_FREE(hhWinType.pszJump2) ;
        CHECK_AND_FREE(hhWinType.pszUrlJump1) ;
        CHECK_AND_FREE(hhWinType.pszUrlJump2) ;

    }
#ifndef _WIN64
#undef hhDiskWinType
#endif

ForgetIt:
    fsclient.CloseStream();
    return TRUE;
}

BOOL CHmData::ReadSystemFile(CExTitle* pTitle)
{
    ASSERT(pTitle);

    CTitleInformation *pInfo = pTitle->GetInfo();

    if (!pInfo)
        return FALSE;
    m_sysflags            = pInfo->GetSystemFlags();

    m_pszDefToc           = lcStrDup( pInfo->GetDefaultToc() );
    m_pszDefIndex         = lcStrDup( pInfo->GetDefaultIndex() );
    m_pszDefHtml          = pInfo->GetDefaultHtml();
    m_pszDefCaption       = pInfo->GetDefaultCaption();
    m_pszDefWindow        = pInfo->GetDefaultWindow();
    m_pszShortName        = pInfo->GetShortName();

    m_hashBinaryTocName   = pInfo->GetBinaryTocNameHash();
    m_hashBinaryIndexName = pInfo->GetBinaryIndexNameHash();
    m_pdInfoTypes         = pInfo->GetInfoTypeData();


    return TRUE;
}

void CHmData::PopulateUNICODETables( void )
{
    if ( !m_ptblIT )
    {
        ASSERT(!m_ptblIT_Desc);
        ASSERT(!m_ptblCat);
        ASSERT(!m_ptblCat_Desc);
        if ( !m_pInfoType )
        {
            m_pInfoType = new CInfoType();
            m_pInfoType->CopyTo( this );
        }
            // populate the unicode CTables for Info Type and Catagory strings.
        m_ptblIT = new CTable(16 * 1024 * 2);
        m_ptblIT_Desc = new CTable(64 * 1024 * 2);
        m_ptblCat = new CTable(16 * 1024 * 2);
        m_ptblCat_Desc = new CTable(64 * 1024 * 2);
        for ( int i=1; i <= m_pInfoType->HowManyInfoTypes(); i++ )
        {
            CWStr cwsz( (PCSTR)m_pInfoType->GetInfoTypeName(i) );
            m_ptblIT->AddString( cwsz.pw );
            cwsz = (PCSTR)m_pInfoType->GetInfoTypeDescription(i);
            m_ptblIT_Desc->AddString( cwsz.pw );
        }
        for ( i=1; i <= m_pInfoType->HowManyCategories(); i++ )
        {
            CWStr cwsz( (PCSTR)m_pInfoType->GetCategoryString(i) );
            m_ptblCat->AddString( cwsz.pw );
            cwsz = (PCSTR)m_pInfoType->GetCategoryDescription(i);
            m_ptblCat_Desc->AddString( cwsz.pw );
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CHmData Helper functions
//

void DeleteAllHmData()
{
    for (int i = 0; i < g_cHmSlots; i++)
    {
        if (g_phmData[i])
        {
                CHmData* p = g_phmData[i];
                g_phmData[i] = NULL;
                delete p;
        }
    }
}

CHmData* FindCurFileData(PCSTR pszITSSFile)
{
    CStr csz;
    if (!FindThisFile(NULL, pszITSSFile, &csz, FALSE))
        return NULL;
    if (!g_phmData)
        goto NeverSeen;

    if (IsCollectionFile(csz))
    {
        // Check current system data first

        if (g_phmData[g_curHmData] &&
                g_phmData[g_curHmData]->m_pTitleCollection &&
                lstrcmpi(csz, g_phmData[g_curHmData]->m_pTitleCollection->m_csFile) == 0) {
            return g_phmData[g_curHmData];
        }

        // Not current, so check our cache

        for (int i = 0; i < g_cHmSlots; i++) {
            if (g_phmData[i] &&
                    g_phmData[i]->m_pTitleCollection &&
                    lstrcmpi(csz,g_phmData[i]->m_pTitleCollection->m_csFile) == 0) {
                return g_phmData[i];
            }
        }
    }
    else
    {
        if (g_phmData[g_curHmData] &&
                lstrcmpi(csz, g_phmData[g_curHmData]->GetCompiledFile()) == 0) {
            return g_phmData[g_curHmData];
        }

        // Not current, so check our cache

        for (int i = 0; i < g_cHmSlots; i++) {
            if (g_phmData[i] &&
                    lstrcmpi(csz, g_phmData[i]->GetCompiledFile()) == 0) {
                return g_phmData[i];
            }
        }
    }

NeverSeen:

    // If we get here, then either we haven't seen the file before, or it
    // isn't cached.

    if (!AddTitleToGlobalList(csz))
        return NULL;
    else
    {
        return g_phmData[g_curHmData];
    }
}

/***************************************************************************

    FUNCTION:   AddTitleToGlobalList

    PURPOSE:    Read the various system files into memory

    PARAMETERS:
        pszITSSFile

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        30-Apr-1997 [ralphw]
        03-Mar-1998 [dalero] no more process ids

***************************************************************************/

BOOL AddTitleToGlobalList(PCSTR pszITSSFile)
{
    // HH BUG 2428
    // Make sure that we can read the file in before we put it in the array.

   if (IsFile(pszITSSFile) == FALSE)
      return FALSE;

    CHmData* pHmData = new CHmData;

    BOOL bResult = pHmData->ReadSystemFiles(pszITSSFile);
    if (!bResult)
    {
        // The ReadSystemFiles call failed. Cleanup and get out.
        delete pHmData ;
    }
    else
    {
        // We have valid data. Get us a place to store it.
        if (!g_phmData) {
            g_cHmSlots = 5;
            g_phmData = (CHmData**) lcCalloc(g_cHmSlots * sizeof(CHmData*));
         for (int i = 0; i < g_cHmSlots; i++) // just in case
            g_phmData[i] = NULL;
        }

        // Find an open slot to store the file data

        for (int pos = 0; pos < g_cHmSlots; pos++) {
            if (!g_phmData[pos])
                break;
        }
        if (pos == g_cHmSlots) {
            g_cHmSlots += 5;
            g_phmData = (CHmData**) lcReAlloc(g_phmData, g_cHmSlots * sizeof(CHmData*));
         for (int i = pos; i < g_cHmSlots; i++)
            g_phmData[i] = NULL;
        }

        // Store the new data.
        g_phmData[pos] = pHmData;

        // Change the current global data pointer.
        g_curHmData = pos ;
    }
    return bResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\system.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _SYSTEM_H_
#define _SYSTEM_H_

#include "fs.h"
#include "fsclient.h"
#include "cinfotyp.h"
#include "hhtypes.h"

// Manifest constants and Enums

// These HHW and other modules suck these files in.
#ifdef HHCTRL
#define DEFAULT_FONT (_Resource.GetUIFont())
#else
#define DEFAULT_FONT (g_hfontDefault)
#endif

class CFullTextSearch;
class CExCollection;
class CExTitle;

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation - read in the title informaton file (#SYSTEM) settings for each title
//

class CTitleInformation
{
public:
    CTitleInformation( CFileSystem* pFileSystem );
    ~CTitleInformation();

    inline SYSTEM_FLAGS   GetSystemFlags() { Init(); return m_Settings; }
    inline PCSTR          GetShortName() { Init(); return m_pszShortName; }
    inline PCSTR          GetDefaultToc() { Init(); return m_pszDefToc; }
    inline PCSTR          GetDefaultIndex() { Init(); return m_pszDefIndex; }
    inline PCSTR          GetDefaultHtml() { Init(); return m_pszDefHtml; }
    inline PCSTR          GetDefaultCaption() { Init(); return m_pszDefCaption; }
    inline PCSTR          GetDefaultWindow() { Init(); return m_pszDefWindow; }
    inline PCSTR          GetCompilerInformation() { Init(); return m_pszCompilerVersion; }
    inline HASH           GetBinaryIndexNameHash() { Init(); return m_hashBinaryIndexName; }
    inline HASH           GetBinaryTocNameHash() { Init(); return m_hashBinaryTocName; }
    inline INFOTYPE_DATA* GetInfoTypeData() { Init(); return m_pdInfoTypes; }
    inline int            GetInfoTypeCount() { Init(); return m_iCntInfoTypes; }
    inline BOOL           GetIdxHeader(IDXHEADER** ppIdxHdr)
                          {
                             Init();
                             if ( ppIdxHdr )
                                *ppIdxHdr = &m_idxhdr;
                             return m_bGotHeader;
                          }
    inline int            GetExtTabCount() const { return m_cExtTabs; }
    inline EXTENSIBLE_TAB* GetExtTab(int pos) const { if (m_paExtTabs && pos < (int)m_cExtTabs) return &m_paExtTabs[pos]; else return NULL; }
    inline HFONT          GetContentFont() { Init(); return (m_hFont); }
    inline HFONT          GetAccessableContentFont() { Init(); return (m_hFontAccessableContent); }
    inline BOOL           IsNeverPromptOnMerge() { Init(); return m_bNeverPromptOnMerge; }

    // below items are stored in the SYSTEM_FLAGS structure
    inline FILETIME GetFileTime() { Init(); return m_Settings.FileTime; }
    inline LCID     GetLanguage() { Init(); return m_Settings.lcid; }
#ifdef HHCTRL
    inline UINT     GetCodePage() { Init(); if( !m_CodePage ) m_CodePage = CodePageFromLCID(m_Settings.lcid); return m_CodePage; }
    inline INT      GetTitleCharset(void) { Init(); return m_iCharset; }
#endif
    inline BOOL     IsKeywordLinks() { Init(); return m_Settings.fKeywordLinks; }
    inline BOOL     IsAssociativeLinks() { Init(); return m_Settings.fALinks; }
    inline BOOL     IsFullTextSearch() { Init(); return m_Settings.fFTI; }
    inline BOOL     IsDoubleByte() { Init(); return m_Settings.fDBCS; }

    HRESULT Initialize();

private:
    void            InitContentFont(PCSTR pszFontSpec);
    inline BOOL     Init() { if( !m_bInit ) Initialize(); return m_bInit; }
                                                 // m_pIT;
    BOOL            m_bInit;         // self-initing class
    BOOL            m_bGotHeader;
    CFileSystem*    m_pFileSystem;   // title file system handle

    SYSTEM_FLAGS    m_Settings;      // simple title information settings
    PCSTR           m_pszShortName;  // short title name
    PCSTR           m_pszDefToc;
    PCSTR           m_pszDefIndex;
    PCSTR           m_pszDefHtml;
    PCSTR           m_pszDefCaption;
    PCSTR           m_pszDefWindow;
    HASH            m_hashBinaryIndexName;   // used to see if we should use binary index or not
    HASH            m_hashBinaryTocName;     // used to see if we should use binary toc or not
    INFOTYPE_DATA*  m_pdInfoTypes;
    PCSTR           m_pszCompilerVersion;
    int             m_iCntInfoTypes;
    IDXHEADER       m_idxhdr;
    DWORD           m_cExtTabs;
    EXTENSIBLE_TAB* m_paExtTabs;
    CTable*         m_ptblExtTabs;
    PCSTR           m_pszDefaultFont;
    HFONT           m_hFont;
    HFONT           m_hFontAccessableContent;
    BOOL            m_bNeverPromptOnMerge;
    UINT            m_CodePage;
    INT             m_iCharset;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation2 - get title informaton without going through the file system
//

class CTitleInformation2
{
public:
    CTitleInformation2( LPCTSTR pszPathName );
    ~CTitleInformation2();

    inline LPCTSTR  GetShortName() { Init(); return m_pszShortName; }
    inline FILETIME GetFileTime()  { Init(); return m_FileTime; }
    inline LCID     GetLanguage()  { Init(); return m_lcid; }

    HRESULT Initialize();

private:
    inline BOOL    Init() { if( !m_bInit ) Initialize(); return m_bInit; }

    BOOL           m_bInit;        // self-initing class
    LPCTSTR        m_pszPathName;  // title pathname
    LPCTSTR        m_pszShortName; // short title name
    LCID           m_lcid;         // language
    FILETIME       m_FileTime;     // file time
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Darwin Stuff
//

// REVIEW: These must be tied to the calling process. If we ever support
// multiple processes in a single OCX, this will break big time.

extern PSTR g_pszDarwinGuid;
extern PSTR g_pszDarwinBackupGuid;

/////////////////////////////////////////////////////////////////////////////////////////////
// CHmData
//

extern CHmData** g_phmData;

CHmData* FindCurFileData(PCSTR pszCompiledFile);

// WARNING: CStr is about the only class that can be specified in CHmData
// that will be automatically created during the constructor -- we zero
// out all members during ChmData contstruction which can wipe out another
// class that wants non-zero members after its constructor

class CHmData
{
public:
    CHmData::CHmData();
    CHmData::~CHmData();

    inline void AddRef() { cRef++; }
    int         Release(void);

    inline CTitleInformation* GetInfo() { return m_pInfo; }

    inline PCSTR  GetDefaultToc() { return m_pszDefToc; }
    inline PCSTR  GetDefaultIndex() { return m_pszDefIndex; }
    inline PCSTR  GetDefaultHtml() { return m_pszDefHtml; }
    inline PCSTR  GetDefaultCaption() { return m_pszDefCaption; }
    inline PCSTR  GetDefaultWindow() { return m_pszDefWindow; }

    LPCTSTR GetCompiledFile(void) const { return m_pszITSSFile; }
    void    SetCompiledFile(PCSTR pszCompiledFile) {
                if (m_pszITSSFile)
                    lcFree(m_pszITSSFile);
                m_pszITSSFile = lcStrDup(pszCompiledFile); }
    BOOL    ReadSystemFiles(PCSTR pszITSSFile);
    BOOL    ReadSystemFile(CExTitle* pTitle);
    BOOL    ReadSubSets( CExTitle *pTitle );

    CExTitle* GetExTitle(void);

    void PopulateUNICODETables( void );

    PCSTR                  GetString(DWORD offset);
    inline int             GetExtTabCount() const { return m_pInfo->GetExtTabCount(); }
    inline EXTENSIBLE_TAB* GetExtTab(int pos) const { return m_pInfo->GetExtTab(pos); }
    HFONT                  GetContentFont();

    PCSTR          m_pszShortName;
    HASH           m_hashBinaryIndexName;   // used to see if we should use binary index or not
    HASH           m_hashBinaryTocName;     // used to see if we should use binary toc or not
    SUBSET_DATA*   m_pdSubSets;
    INFOTYPE_DATA* m_pdInfoTypes;

    // public data is bad!  make it private and expose via inline methods

    // For the Info Type API
    INFOTYPE*  m_pAPIInfoTypes;       // info type bit mask set by the API.
    int        m_cur_Cat;
    int        m_cur_IT;
    CInfoType* m_pInfoType;

    CTable* m_ptblIT;                 // The unicode copy of the Info Type strings
    CTable* m_ptblIT_Desc;            //                         InfoType Descriptions
    CTable* m_ptblCat;                // The unicode copy of the Category strings
    CTable* m_ptblCat_Desc;           //                         Category Descriptions

    SYSTEM_FLAGS       m_sysflags;
    CExCollection*     m_pTitleCollection;

protected:
    PCSTR m_pszITSSFile;
    int cRef;

#ifdef _DEBUG
    DWORD m_cbStrings;
    DWORD m_cbUrls;
    DWORD m_cbKeywords;
#endif

private:
    PCSTR m_pszDefToc;
    PCSTR m_pszDefIndex;
    PCSTR m_pszDefHtml;
    PCSTR m_pszDefCaption;
    PCSTR m_pszDefWindow;

    CTitleInformation* m_pInfo;
};

#endif // _SYSTEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\tabctrl.cpp ===
///////////////////////////////////////////////////////////
//
//
// tabctrl - CTabControl controls encapsulates the system
//           tab control.
//
//
/*
TODO:
    Move tab ordering into this CTabControl.
*/
///////////////////////////////////////////////////////////
//
// Includes
//
#include "header.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include "system.h"
#include "secwin.h"

// For ID_TAB_CONTROL
#include "resource.h"

// Our header
#include "tabctrl.h"

// So that we can get the width of the sizebar.
#include "sizebar.h"

#include "hha_strtable.h"

#include "cctlww.h"

///////////////////////////////////////////////////////////
//
// Constructor
//

CTabControl::CTabControl(HWND hwndParent, int tabpos, CHHWinType* phh)
{
    ASSERT(IsValidWindow(hwndParent)) ;
    m_phh = phh;
    m_hWndParent = hwndParent ;

    RECT rc;
    CalcSize(&rc) ; // Get our size.

    int tabstyle = 0;
    if (tabpos == HHWIN_NAVTAB_LEFT)
        tabstyle = TCS_VERTICAL;
    else if (tabpos == HHWIN_NAVTAB_BOTTOM)
        tabstyle = TCS_BOTTOM;

    m_hWnd = W_CreateControlWindow (0, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | tabstyle,
        W_TabCtrl, NULL, rc.left, rc.top, RECT_WIDTH(rc), RECT_HEIGHT(rc),
        hwndParent, (HMENU) ID_TAB_CONTROL, _Module.GetModuleInstance(), NULL );

    W_EnableUnicode(m_hWnd, W_TabCtrl);
    ZeroMemory(m_apTabText, sizeof(m_apTabText));

    m_cTabs = 0;
    if (m_phh->IsValidNavPane(HH_TAB_CONTENTS))
    {
        m_apTabText[m_cTabs] = lcStrDupW(GetStringResourceW(IDS_TAB_CONTENTS));
        m_cTabs++;
    }
    if (m_phh->IsValidNavPane(HH_TAB_INDEX))
    {
        m_apTabText[m_cTabs] = lcStrDupW(GetStringResourceW(IDS_TAB_INDEX));
        m_cTabs++;
    }
    if (m_phh->IsValidNavPane(HH_TAB_SEARCH))
    {
        m_apTabText[m_cTabs] = lcStrDupW(GetStringResourceW(IDS_TAB_SEARCH));
        m_cTabs++;
    }
    if (m_phh->IsValidNavPane(HH_TAB_HISTORY))
    {
        m_apTabText[m_cTabs] = lcStrDupW(GetStringResourceW(IDS_TAB_HISTORY));
        m_cTabs++;
    }

    // Turn on the Help Favorites Tab
    if (m_phh->IsValidNavPane(HH_TAB_FAVORITES))
    {
        m_apTabText[m_cTabs] = lcStrDupW(GetStringResourceW(IDS_TAB_FAVORITES));
        m_cTabs++;
    }

    // Add the Custom Tabs.
    //int iNumCustomTabs = phh->GetExtTabCount();
    int index = HH_TAB_CUSTOM_FIRST;
    for (int j = HH_TAB_CUSTOM_FIRST ; j <= HH_TAB_CUSTOM_LAST ; j++)
    {
        if (m_phh->IsValidNavPane(j))
        {
            //TODO: You never know when any of Ralph's objects are valid and there is almost never a way to know.
            // The failure condition below, should never have gotten this far. However, its not clear
            // when we have valid system data to check against.
            EXTENSIBLE_TAB* pExtTab = phh->GetExtTab(j - HH_TAB_CUSTOM_FIRST);
            if (pExtTab && pExtTab->pszTabName && pExtTab->pszProgId)
            {
//TODO:[paulde] EXTENSIBLE_TAB should be made Unicode, or at least a way to get the authored codepage
// [mikecole] Chanced the MultiByteToWideChar() call to use the CP info from the .CHM rather than ACP.
                int cch = lstrlen(pExtTab->pszTabName) + 1;
                PWSTR psz = (PWSTR)lcMalloc(cch*sizeof(WCHAR));
                MultiByteToWideChar(phh->GetCodePage(), 0, pExtTab->pszTabName, -1, psz, cch);
                m_apTabText[m_cTabs] = psz;
                m_cTabs++ ;
            }
            else
            {
                // Reset the window type so that this tab no longer valid.
                m_phh->fsWinProperties &= ~(HHWIN_PROP_TAB_CUSTOM1 << (j - HH_TAB_CUSTOM_FIRST));
            }
        }
    }

#ifdef __TEST_CUSTOMTAB__
    if (IsHelpAuthor(hwndParent)) {
        m_apTabText[m_phh->tabOrder[HH_TAB_AUTHOR]] = lcStrDup(pGetDllStringResource(IDSHHA_TAB_AUTHOR));
        m_cTabs++;
    }
#endif

    TC_ITEMW tie;
    tie.mask = TCIF_TEXT;
    tie.iImage = -1;

    int i;
    for (i = 0; i < m_cTabs; i++)
    {
        tie.pszText = (PWSTR) m_apTabText[i];
        if (tie.pszText) {
            tie.cchTextMax = lstrlenW( m_apTabText[i] );
            W_TabCtrl_InsertItem(m_hWnd, i, &tie);
        }
    }

    // see if we need to adjust vertical tab padding
    //
    char *pszTabVertSize = lcStrDup(GetStringResource(IDS_TAB_VERT_PADDING));
    char *pszTabHorzSize = lcStrDup(GetStringResource(IDS_TAB_HORZ_PADDING));

   if (pszTabVertSize && pszTabHorzSize)
   {
        if ((g_fDBCSSystem || g_langSystem == LANG_ARABIC || g_langSystem == LANG_HEBREW) && IsDigit((BYTE) *pszTabVertSize) && IsDigit((BYTE) *pszTabHorzSize))
               W_TabCtrl_SetPadding(m_hWnd,Atoi(pszTabHorzSize),Atoi(pszTabVertSize));

      lcFree(pszTabVertSize);
      lcFree(pszTabHorzSize);
   }
   SendMessage(m_hWnd, WM_SETFONT, (WPARAM)_Resource.GetAccessableUIFont() , 0);
}

///////////////////////////////////////////////////////////
//
// Destructor
//
CTabControl::~CTabControl()
{
    for (int i = 0; i < m_cTabs; i++) {
        if (m_apTabText[i])
            lcFree(m_apTabText[i]);
    }
}


///////////////////////////////////////////////////////////
//
//                  Operations
//
///////////////////////////////////////////////////////////
//
// ResizeWindow
//
void
CTabControl::ResizeWindow()
{
    // Validate
    ASSERT(IsValidWindow(hWnd())) ;

    // Calculate our size.
    RECT rc;
    CalcSize(&rc); // This will be the navigation window.

    // Size the window.
    MoveWindow(hWnd(), rc.left, rc.top,
                RECT_WIDTH(rc), RECT_HEIGHT(rc),
                TRUE);
}

///////////////////////////////////////////////////////////
//
//                  Helper Functions
//
///////////////////////////////////////////////////////////
//
// CalcSize - This is where we calc the size of the tab control
//
void
CTabControl::CalcSize(RECT* prect)
{
    // Currently this is simple. It will get more complicated.
    ::GetClientRect(m_hWndParent, prect);

    // Subtract room for padding and room for the sizebar.
    prect->right -= GetSystemMetrics(SM_CXSIZEFRAME)*2 - CSizeBar::Width();
    prect->top += GetSystemMetrics(SM_CYSIZEFRAME)*2 ;   // Add room on top to see the top edge.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\tabctrl.h ===
#ifndef __TABCTRL_H__
#define __TABCTRL_H__

///////////////////////////////////////////////////////////
//
//
// tabctrl.h -  CTabControl controls encapsulates the system
//              tab control.
//
//
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.


#include "htmlhelp.h"
#include "secwin.h"

class CTabControl
{
public:
    // Constructor
    CTabControl(HWND hwndParent, int tabpos, CHHWinType* phh);

    // Destructor
    ~CTabControl();

// Access
public:
    HWND hWnd() const
        { return m_hWnd; }

// Operations
public:
    void ResizeWindow() ;
    int MaxTabs() {return m_cTabs; }

// Internal Helper Functions
protected:
    void CalcSize(RECT* prect) ;


// Member variables.
protected:
    HWND m_hWnd;
    HWND m_hWndParent ;
    PCWSTR m_apTabText[HH_MAX_TABS + 1];
    CHHWinType* m_phh;
    int m_cTabs;    // tabs in use
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\topics.h ===
// Copyright  1996-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _HHCTRL_H_
#include "hhctrl.h"
#endif

#ifndef _CPROP_H_
#include "cprop.h"
#endif

#include "resource.h"

class CPageContents : public CPropPage
{
public:
	CPageContents(CHtmlHelpControl* phhCtrl)
		: CPropPage(IDPAGE_CONTENTS) { };
	BOOL OnBeginOrEnd();
};

class CPageIndex : public CPropPage
{
public:
	CPageIndex(CHtmlHelpControl* phhCtrl)
			: CPropPage(IDPAGE_TAB_INDEX) {
		m_fSelectionChange = FALSE;
	}
	BOOL OnBeginOrEnd();
	void OnDblClick() {
		PostMessage(GetParent(m_hWnd), WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0); }
	void OnSelChange();

	BOOL m_fSelectionChange;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\toc.cpp ===
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    File: toc.cpp
//    Author: Donald Drake
//    Purpose: Implements classes to support the table of contents

#include "header.h"
#include "stdio.h"
#include "string.h"
#ifdef HHCTRL
#include "parserhh.h"
#else
#include "windows.h"
#include "parser.h"
#endif
#include "collect.h"
#include "hhtypes.h"
#include "wwheel.h"
#include "toc.h"
#include "fts.h"
#include "subfile.h"
#include "fs.h"
#include "sysnames.h"

#include "highlite.h"
#include "hhfinder.h"
#include "csubset.h"
#include "hherror.h"
// NormalizeUrlInPlace
#include "util.h"
#include "subset.h"

// typed -- just use ANSI for now
#undef _tcsicmp
#undef _tcstok
#define _tcsicmp strcmpi
#define _tcstok  StrToken

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

// Persist keys. No need for these to be localized so I place them here.
//
const char g_szFTSKey[] = "ssv1\\FTS";
const char g_szIndexKey[] = "ssv1\\Index";
const char g_szTOCKey[] = "ssv1\\TOC";
const char g_szUDSKey[] = "ssv2\\UDS";  // User Defined Subsets

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// global helper functions
CExCollection* g_pCurrentCollection = NULL;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CExCollection implementation

CExCollection::CExCollection(CHmData* phmData, const CHAR* pszFile,  BOOL bSingleTitle)
{
    m_pstate = new CState(pszFile);
    m_phmData = phmData;
    m_bSingleTitle = bSingleTitle;
    m_pHeadTitles = NULL;
    m_csFile = pszFile;

    m_pFullTextSearch = NULL;
    m_pSearchHighlight = NULL;
    m_pDatabase = NULL;
    m_szWordWheelPathname = NULL;
    m_dwCurrSlot = 0;
    m_pCurrTitle = NULL;
    m_pSubSets = NULL;
    m_pMasterTitle = NULL ; // HH BUG 2428: Always initialize your variables!!!

    m_dwLastSlot = 0;
    m_pSSList = NULL;

    for (int i = 0; i < MAX_OPEN_TITLES; i++)
        m_MaxOpenTitles[i] = NULL;

    if (! bSingleTitle )
    {
       //
       // If this is ever not the case then we have a situation where we are trying to init more than a single
       // collection. This is a very bad thing and must be avoided.
       //
       ASSERT(g_pCurrentCollection == NULL);
       g_pCurrentCollection = NULL;
    }

    m_pCSlt = NULL;
}

CExCollection::~CExCollection()
{

   if ( m_phmData->m_sysflags.fDoSS && m_pSSList )
   {
      m_pSSList->PersistSubsets(this);
      delete m_pSSList;
   }
   if( m_pDatabase )
      delete m_pDatabase;

   if (m_pFullTextSearch)
      delete m_pFullTextSearch;

   if ( m_pSearchHighlight )
      delete m_pSearchHighlight;

   CExTitle *p, *pNext;
   p = m_pHeadTitles;

   while (p)
   {
      pNext = p->GetNext();
      delete p;
      p = pNext;
   }

   if (m_Collection.IsDirty())
   m_Collection.Save();

   m_Collection.Close();

  if( m_szWordWheelPathname ) {
    delete [] (CHAR*) m_szWordWheelPathname;
    m_szWordWheelPathname = NULL;
  }

  // Persist subset selections.
  //
#if 0
  CSubSet* pSS;
#endif
  if ( m_pSubSets )
  {
#if 0
     if ( (pSS = m_pSubSets->GetFTSSubset()) && SUCCEEDED(m_pstate->Open(g_szFTSKey,STGM_WRITE)) )
     {
        m_pstate->Write(pSS->m_cszSubSetName, strlen(pSS->m_cszSubSetName)+1);
        m_pstate->Close();
     }
     if ( (pSS = m_pSubSets->GetIndexSubset()) && SUCCEEDED(m_pstate->Open(g_szIndexKey,STGM_WRITE)) )
     {
        m_pstate->Write(pSS->m_cszSubSetName, strlen(pSS->m_cszSubSetName)+1);
        m_pstate->Close();
     }
     if ( (pSS = m_pSubSets->GetTocSubset()) && SUCCEEDED(m_pstate->Open(g_szTOCKey,STGM_WRITE)) )
     {
        m_pstate->Write(pSS->m_cszSubSetName, strlen(pSS->m_cszSubSetName)+1);
        m_pstate->Close();
     }

#ifdef _DEBUG
    /* Output all the user defined subsets to the state store.
     *******************/
     int nKey;
     char buf[5];
     CStr cszKey;
extern const char txtSSInclusive[];         // "Inclusive";
extern const char txtSSExclusive[];         // "Exclusive";
static const int MAX_PARAM = 4096;
static const char txtSSConvString[] = "%s:%s:%s";   // Exclusive|Inclusive:SetName:TypeName
CMem memParam( MAX_PARAM );
CHAR* pszParam = (CHAR*)memParam;   // for notational convenience
    for(int i=0; i<m_pSubSets->HowManySubSets(); i++ )
    {
        pSS = m_pSubSets->GetSubSet(i);
        if ( pSS->m_bPredefined )
            continue;
        int type = pSS->GetFirstExcITinSubSet();
        nKey=1;
        while (type != -1 && pSS->m_pIT->GetInfoTypeName(type) && (type <= pSS->m_pIT->HowManyInfoTypes()))
        {
                // even though we don't define exclusive filters, for user defined, it will be
                // here when we do.
            wsprintf(pszParam, txtSSConvString, txtSSExclusive,
                    pSS->m_cszSubSetName.psz,
                    pSS->m_pIT->GetInfoTypeName(type) );
            cszKey = g_szUDSKey;
            wsprintf(buf,"%d",nKey++);
            cszKey += buf;
            if ( SUCCEEDED( m_pstate->Open(cszKey, STGM_WRITE)) )
                m_pstate->Write(pszParam, strlen(pszParam)+1);
            m_pstate->Close();
            type = pSS->GetNextExcITinSubSet();
        }
        type = pSS->GetFirstIncITinSubSet();
        nKey=1;
        while (type != -1 && pSS->m_pIT->GetInfoTypeName(type) && (type <= pSS->m_pIT->HowManyInfoTypes()))
        {
            wsprintf(pszParam, txtSSConvString, txtSSInclusive,
                    pSS->m_cszSubSetName.psz,
                    pSS->m_pIT->GetInfoTypeName(type) );
            cszKey = g_szUDSKey;
            wsprintf(buf,"%d",nKey++);
            cszKey += buf;
            if ( SUCCEEDED( m_pstate->Open(cszKey, STGM_WRITE)) )
                m_pstate->Write(pszParam, strlen(pszParam)+1);
            m_pstate->Close();
            type = pSS->GetNextIncITinSubSet();
        }
    }
#endif

#endif
     delete m_pSubSets;
  }

  if (m_pCSlt)
      delete m_pCSlt; // leak fix

  if ( m_pstate )
     delete m_pstate;

  if (! m_bSingleTitle )
    g_pCurrentCollection = NULL;
}

/* The FullPath parameter is the name of a directory.  The directory is suppose to contain files
   to add to the collection.
*/
#ifdef CHIINDEX
#include <io.h>
BOOL CExCollection::InitCollection( const TCHAR * FullPath, const TCHAR * szMasterChmFn )
{
    char szExt[2][5] = {".chm", ".chi"};
    BOOL ret = FALSE;
    CStr filespec;
    long hSrch;
    struct _finddata_t fd_t;
    CStr szAdd;
    HRESULT hr;

    m_pMasterTitle = NULL;

    for(int i=0; i<2; i++)
    {
        filespec = FullPath;
        filespec += "\\*";
        filespec += szExt[i]; 
        if ( (hSrch = _findfirst( filespec, &fd_t ) ) == -1 )
            continue;
        else
            ret = TRUE;

        do 
        {
            CExTitle *pExTitle = NULL;

            szAdd = FullPath;
            szAdd += "\\";
            szAdd += fd_t.name;

            // only check for the existance of a index for chm files
            if (0==i)
            {
                CFileSystem* pFileSystem = new CFileSystem;
                pFileSystem->Init();
                if (!(SUCCEEDED(pFileSystem->Open( szAdd ))))
                {
                    delete pFileSystem;
                    continue;
                }
                CSubFileSystem* pSubFileSystem = new CSubFileSystem(pFileSystem);
                hr = pSubFileSystem->OpenSub("$WWKeywordLinks\\btree");
                if (FAILED(hr))
                {
                    hr = pSubFileSystem->OpenSub("$WWAssociativeLinks\\btree");
                    if (FAILED(hr))
                    {
                        pFileSystem->Close();
                        delete pFileSystem;
                        delete pSubFileSystem;
                        continue;
                    }
                }
                delete pSubFileSystem;
                pFileSystem->Close();
                delete pFileSystem;
            }
			pExTitle = new CExTitle( szAdd , this );
            pExTitle->SetNext(m_pHeadTitles);
            m_pHeadTitles = pExTitle;

            if ( (m_pMasterTitle == NULL) && (strnicmp( szMasterChmFn, fd_t.name, strlen(szMasterChmFn)) == 0) )
            {
                m_pMasterTitle = m_pHeadTitles;
                m_phmData->SetCompiledFile(szAdd);
            }
            m_Collection.IncrementRefTitleCount();
        } while( _findnext( hSrch, &fd_t ) == 0 );
    } 

    if ( (ret == TRUE) && (m_pMasterTitle == NULL) )
    {
        m_pMasterTitle = m_pHeadTitles;
        m_phmData->SetCompiledFile(szAdd);
    }
    return ret;
}
#endif

BOOL CExCollection::InitCollection()
{
    if (m_bSingleTitle)
    {
        m_pHeadTitles = new CExTitle(m_csFile, this);
        m_pMasterTitle = m_pHeadTitles;
        m_Collection.IncrementRefTitleCount();
        GetMergedTitles(m_pHeadTitles);
        CStr cszCompiledFile;
        const CHAR* pszFilePortion = GetCompiledName(m_csFile, &cszCompiledFile);
        m_phmData->SetCompiledFile(cszCompiledFile);
#ifdef DUMPTOC
        m_fh = fopen("c:\\toc_dump.txt", "w");
        m_bRoot = TRUE;
        m_dwLevel = 0;
        CTreeNode *pNode = GetRootNode();

        DumpNode(&pNode);
        fclose(m_fh);
#endif
   }
   else
   {
      m_Collection.ConfirmTitles();
      m_Collection.m_bFailNoFile = TRUE;
      if (m_Collection.Open(m_csFile) != F_OK)
        return FALSE;

      // Create an CExTitle for each referanced title
      LANGID LangId;
      CHAR* pszTitle;
      CTitle *pTitle;
      CFolder *p;
      LISTITEM *pItem;
      CExTitle *pExTitle;

      m_pCSlt = new CSlotLookupTable();            // start a new slot lookup table.
      pItem = m_Collection.m_RefTitles.First();
      while (pItem)
      {
        p = (CFolder *)pItem->pItem;

        pszTitle = p->GetTitle() + 1;
        LangId = p->GetLanguage();

        // check if extitle already exist, title referanced twice in the collection
        if ( (pExTitle = FindTitle(pszTitle, LangId)) )
        {
           m_Collection.DecrementRefTitleCount();
           pItem = m_Collection.m_RefTitles.Next(pItem);
           p->SetExTitlePtr(pExTitle);
           continue;
        }

        // find the title
        pTitle = m_Collection.FindTitle(pszTitle, LangId);

        if (pTitle == NULL)
        {
           m_Collection.DecrementRefTitleCount();
           pItem = m_Collection.m_RefTitles.Next(pItem);
           continue;
        }
        
        //create CExTitle
        pExTitle = new CExTitle(pTitle, m_Collection.GetColNo(), this);
        if (ValidateTitle(pExTitle) == FALSE)
        {
            pItem = m_Collection.m_RefTitles.Next(pItem);
            continue;
        }

        // add the title
        pExTitle->SetNext(m_pHeadTitles);
        m_pHeadTitles = pExTitle;

        // Wire up the CFolder to the CExTitle, also, generate the Title Hash identifier.
        //
        p->SetExTitlePtr(pExTitle);

        char szBuf[20];
        char szID[MAX_PATH + 20];
        Itoa(p->GetLanguage(), szBuf);
        strcpy(szID, p->GetTitle()+1);    // Don't hash the '='
        strcat(szID, szBuf);
        pExTitle->m_dwHash = HashFromSz(szID);
        m_pCSlt->AddValue(p);

        if (pExTitle->GetUsedLocation()->bSupportsMerge)
        {
           GetMergedTitles(pExTitle);
        }
        pItem = m_Collection.m_RefTitles.Next(pItem);
      }
      //
      // check for a master chm
      //
      CHAR* pszName;
      LANGID LangId2;

      if (m_Collection.GetMasterCHM(&pszName, &LangId2))
      {
        m_pMasterTitle = FindTitle(pszName, LangId2);
      }

      if (!m_pMasterTitle)
      {
        // default to first title
        m_pMasterTitle = GetFirstTitle();
      }

      if (!m_pMasterTitle)
        return FALSE;

      g_pCurrentCollection = this;
      m_pCSlt->SortAndAssignSlots();     // Complete construction of the slot lookup table.
      while (TRUE)
      {
          if (m_pMasterTitle->OpenTitle() == FALSE)
          {
             m_pMasterTitle = m_pMasterTitle->GetNext();
             if (m_pMasterTitle == NULL)
                return FALSE;
             continue;
          }
          CStr cszCompiledFile;
          GetCompiledName(m_pMasterTitle->GetPathName(), &cszCompiledFile);
          m_phmData->SetCompiledFile(cszCompiledFile);
          return TRUE;
      }
   }

   return TRUE;
}

void CExCollection::InitStructuralSubsets(void)
{
   if ( m_bSingleTitle )
   {
      m_phmData->m_sysflags.fDoSS = 0;
      return;
   }
   if ( m_phmData->m_sysflags.fDoSS )
   {
      // Initilize the structural subset list and the "new" and "entire contents" subsets.
      //
      CStructuralSubset* pSS;
      CHAR szBuf[50];

      m_pSSList = new CSSList;

	  strncpy(szBuf,GetStringResource(IDS_ADVSEARCH_SEARCHIN_ENTIRE), sizeof(szBuf));
	  szBuf[49] = 0;
      pSS = new CStructuralSubset(szBuf);
      pSS->SetEntire();
      pSS->SetReadOnly();
      m_pSSList->AddSubset(pSS);
      m_pSSList->SetEC(pSS);

	  strncpy(szBuf,GetStringResource(IDS_NEW), sizeof(szBuf));
	  szBuf[49] = 0;
      pSS = new CStructuralSubset(szBuf);
      pSS->SetEmpty();
      pSS->SetReadOnly();
      m_pSSList->AddSubset(pSS);
      m_pSSList->SetNew(pSS);

      m_pSSList->RestoreSubsets(this, szBuf);
      m_pSSList->ReadPreDefinedSubsets(this, szBuf);
      //
      // If a subset has been selected via SetGlobalProperties() via HH_GPROPID_CURRENT_SUBSET then use that as an override...
      //
      if ( _Module.szCurSS[0] )
      {
         pSS = NULL;
         while ( (pSS = m_pSSList->GetNextSubset(pSS)) )
         {
            if (! strcmpi(_Module.szCurSS, pSS->GetID()) )
            {
               m_pSSList->SetFTS(pSS);
               m_pSSList->SetF1(pSS);
               m_pSSList->SetTOC(pSS);
               break;
            }
         }
      }
   }
}

void CExCollection::GetOpenSlot(CExTitle *p)
{
    if (m_MaxOpenTitles[m_dwLastSlot])
        m_MaxOpenTitles[m_dwLastSlot]->CloseTitle();

    m_MaxOpenTitles[m_dwLastSlot] = p;
    m_dwLastSlot++;

    if (m_dwLastSlot == MAX_OPEN_TITLES)
        m_dwLastSlot = 0;
}

BOOL CExCollection::ValidateTitle(CExTitle *pExTitle, BOOL bDupCheckOnly)
{
	// make sure the collection does not already contain a chm with same location MMC
	CExTitle *pEnumTitle;
	pEnumTitle = GetFirstTitle();

	while (pEnumTitle)
	{
    	if (lstrcmp(pEnumTitle->GetContentFileName(), pExTitle->GetContentFileName()) == 0)
		{
	        delete pExTitle;
			m_Collection.DecrementRefTitleCount();
			return FALSE;
		}
		pEnumTitle = pEnumTitle->GetNext();
	}

    if (bDupCheckOnly == TRUE)
        return TRUE;

    // before adding to title list confirm that files exist
    pExTitle->FindUsedLocation();

    if (pExTitle->GetUsedLocation() == NULL)
    {
        delete pExTitle;
        m_Collection.DecrementRefTitleCount();
        return FALSE;
    }

    if (pExTitle->GetUsedLocation()->IndexFileName && pExTitle->GetUsedLocation()->IndexFileName[0])
    {
        if (GetFileAttributes(pExTitle->GetUsedLocation()->IndexFileName) == HFILE_ERROR)
        {
            delete pExTitle;
            m_Collection.DecrementRefTitleCount();
            return FALSE;
        }
    }
    return TRUE;
}

BOOL CExCollection::UpdateLocation( const CHAR* pszLocId, const CHAR* pszNewPath, const CHAR* pszNewVolume, const CHAR* pszNewTitle )
{
    // find the location itself
    CLocation *pLocation = FindLocation( (CHAR*)pszLocId);
    if (pLocation == NULL)
        return FALSE;

    // make sure new path has trailing backslash
    CStr cStrPath = pszNewPath;
    if (pszNewPath[strlen(pszNewPath) - 1] != '\\')
        cStrPath += "\\";

    // get the current (old) location path
    CStr cStrOldPath = pLocation->GetPath();
    if (cStrOldPath.psz[strlen(cStrOldPath.psz) - 1] != '\\')
        cStrOldPath += "\\";

    // if new and old paths are the some just bail out
    if( lstrcmpi( cStrPath.psz, cStrOldPath.psz ) == 0 )
      return FALSE;

    // determine what has changed in this path (was it just the drive letter?)
    // note we must compare from the tail end and thus we have to be careful when
    // dealing with DBCS strings
    CHAR* pszOldPathHead = cStrOldPath.psz;
    CHAR* pszOldPathTail = CharPrev(pszOldPathHead, pszOldPathHead + strlen(pszOldPathHead));
    CHAR* pszPathHead = cStrPath.psz;
    CHAR* pszPathTail = CharPrev(pszPathHead, pszPathHead + strlen(pszPathHead));
    while( (pszOldPathTail >= pszOldPathHead) && (pszPathTail >= pszPathHead) ) {
      BOOL bOldLB = IsDBCSLeadByte(*pszOldPathTail);
      BOOL bLB = IsDBCSLeadByte(*pszPathTail);
      if( bOldLB && bLB ) {
        if( !((*pszOldPathTail == *pszPathTail) && (*(pszOldPathTail+1) == *(pszPathTail+1))) )
          break;
      }
      else if( bOldLB || bLB ) {
        break;
      }
      else if( ToLower(*pszOldPathTail) != ToLower(*pszPathTail) ) {
        break;
      }
      // bail if we compared all chars
      if( (pszOldPathTail == pszOldPathHead) || (pszPathTail == pszPathHead) )
        break;
      // advance to previous char
      pszOldPathTail = CharPrev(pszOldPathHead, pszOldPathTail);
      pszPathTail = CharPrev(pszPathHead, pszPathTail);
    }
    if( IsDBCSLeadByte(*pszOldPathTail) )
      pszOldPathTail++;
    if( IsDBCSLeadByte(*pszPathTail) )
      pszPathTail++;
    char szOldPathPrefix[MAX_PATH];
    int iLen = (int)(((DWORD_PTR)pszOldPathTail)-((DWORD_PTR)pszOldPathHead)+1); // always at least one
    lstrcpyn( szOldPathPrefix, pszOldPathHead, iLen+1 );
    char szPathPrefix[MAX_PATH];
    iLen = (int)(((DWORD_PTR)pszPathTail)-((DWORD_PTR)pszPathHead)+1); // always at least one
    lstrcpyn( szPathPrefix, pszPathHead, iLen+1 );

    // update title if specified
    if (pszNewTitle)
       pLocation->SetTitle(pszNewTitle);

    // get the volume that will be updated
    CStr cStrVolume = pLocation->GetVolume();

    // first, update each pathname in the titles that have the same volume label
    CExTitle *pExTitle = GetFirstTitle();
    LOCATIONHISTORY *pLH;
    CHAR* pszFilePortion;
    CStr cFileName;
    while (pExTitle)
    {
        // if the used location for this title is the new location update it
        pLH = pExTitle->GetUsedLocation();
        CLocation *pLoc = FindLocation( (CHAR*)pLH->LocationId );
        CStr cStrVol = pLoc->GetVolume();

        // get the old location path
        CStr cStrOldPath = pLoc->GetPath();
        if (cStrOldPath.psz[strlen(cStrOldPath.psz) - 1] != '\\')
            cStrOldPath += "\\";

        if (pExTitle->GetContentFileName().psz && pLH)
        {
            if (strcmpi( cStrVol, cStrVolume ) == 0)
            {
                // make sure that it did point to the old location
                pszFilePortion = (CHAR*)FindFilePortion(pExTitle->GetContentFileName());
                cFileName = cStrOldPath.psz;
                cFileName += pszFilePortion;
                pszFilePortion = (CHAR*)FindFilePortion(cFileName);

                if (strcmpi(cFileName, pExTitle->GetContentFileName()) == 0)
                {
                    // find the ending location of the old prefix
                    CHAR* pszOldPathNameEnd = pExTitle->GetContentFileName().psz + strlen(szOldPathPrefix);

                    // create the new pathname using the prefix of the new location and the
                    // ending string of the old pathname
                    CStr cStrPathName = szPathPrefix;
                    cStrPathName += pszOldPathNameEnd;

                    // update the pathname
                    pExTitle->GetContentFileName() = cStrPathName.psz;
                }
            }
        }

        // check each location for this title
        pLH = pExTitle->m_pTitle->m_pHead;
        while (pLH)
        {
            // chm file location information
            CLocation *pLoc = FindLocation( (CHAR*)pLH->LocationId );
            // if the location is NULL, this indications that we are looking at a title
            // that belongs to a different collection and thus we should skip it
            if( pLoc ) {
              CStr cStrVol = pLoc->GetVolume();

              // get the old location path
              CStr cStrOldPath = pLoc->GetPath();
              if (cStrOldPath.psz[strlen(cStrOldPath.psz) - 1] != '\\')
                  cStrOldPath += "\\";

              // chm file
              if (strcmpi( cStrVol, cStrVolume ) == 0)
              {
                  pszFilePortion = (CHAR*)FindFilePortion(pLH->FileName);
                  cFileName = cStrOldPath.psz;
                  cFileName += pszFilePortion;

                  if (strcmpi(cFileName, pLH->FileName) == 0)
                  {
                      // find the ending location of the old prefix
                      CHAR* pszOldPathNameEnd = pLH->FileName + strlen(szOldPathPrefix);

                      // create the new pathname using the prefix of the new location and the
                      // ending string of the old pathname
                      CStr cStrPathName = szPathPrefix;
                      cStrPathName += pszOldPathNameEnd;

                      // update the pathname
                      AllocSetValue(cStrPathName.psz, &pLH->FileName);
                  }
              }

              // chq file
              if( pLH->QueryFileName && *pLH->QueryFileName ) {

                // chq file location information
                // (use the same as the chm file if QueryLocation is not set)
                if( pLH->QueryLocation && *(pLH->QueryLocation) ) {
                  pLoc = FindLocation( (CHAR*) pLH->QueryLocation );
                  cStrVol = pLoc->GetVolume();

                  // get the old location path
                  cStrOldPath = pLoc->GetPath();
                  if (cStrOldPath.psz[strlen(cStrOldPath.psz) - 1] != '\\')
                      cStrOldPath += "\\";
                }

                // chq file
                if( strcmpi( cStrVol, cStrVolume ) == 0 )
                {
                    pszFilePortion = (CHAR*)FindFilePortion(pLH->QueryFileName);
                    cFileName = cStrOldPath.psz;
                    cFileName += pszFilePortion;

                    if (strcmpi(cFileName, pLH->QueryFileName) == 0)
                    {
                        // find the ending location of the old prefix
                        CHAR* pszOldPathNameEnd = pLH->QueryFileName + strlen(szOldPathPrefix);

                        // create the new pathname using the prefix of the new location and the
                        // ending string of the old pathname
                        CStr cStrPathName = szPathPrefix;
                        cStrPathName += pszOldPathNameEnd;

                        // update the pathname
                        AllocSetValue(cStrPathName.psz, &pLH->QueryFileName);
                    }
                }

              }

            }
            pLH = pLH->pNext;
        }
        pExTitle = pExTitle->GetNext();
    }

    // and finally, update any location identifier that has the same volume label
    //
    // note: we must do this list since the individual title updating relies on the fact
    // that we can fetch the "old" location information to validate the file pathing before
    // we update it
    CLocation *pLoc = m_Collection.FirstLocation();
    while( pLoc ) {
      CStr cStrVol = pLoc->GetVolume();
      if( strcmpi( cStrVol, cStrVolume ) == 0 ) {

        // get the old location path
        CStr cStrOldPath = pLoc->GetPath();
        if (cStrOldPath.psz[strlen(cStrOldPath.psz) - 1] != '\\')
          cStrOldPath += "\\";

        // find the ending location of the old prefix
        CHAR* pszOldPathEnd = cStrOldPath.psz + strlen(szOldPathPrefix);

        // create the new path using the prefix of the new location and the
        // ending string of the old path
        CStr cStrPath = szPathPrefix;
        cStrPath += pszOldPathEnd;

        // make sure the path aways ends with a backslash
        if (cStrPath.psz[strlen(cStrPath.psz) - 1] != '\\')
          cStrPath += "\\";

        // update the path
        pLoc->SetPath(cStrPath);

        // update the volume label if specified
        if( pszNewVolume )
          pLoc->SetVolume( pszNewVolume );

      }
      pLoc = pLoc->GetNextLocation();
    }

    // set the collection dirty bit so the hhcolreg.dat will get updated on shutdown
    m_Collection.Dirty();

    return FALSE;
}

void CExCollection::GetChildURLS(CTreeNode *pNode, CTable *pTable)
{
    CTreeNode *pParents[50];
    CTreeNode *pCur, *pNext;
    CHAR* pszFind;

    DWORD dwCurLevel = 0;
    CHAR szURL[MAX_URL];

    for (int i = 0; i < 50; i++)
       pParents[i] = NULL;

    // add the URL for this node
    if (pNode->GetURL(szURL, sizeof(szURL), TRUE))
    {
        // Truncate the strings at the # character if there is one.
        pszFind = StrChr((const CHAR*)szURL, '#');
        if (pszFind != NULL)
            *pszFind = '\0';

        if (pszFind = StrChr((const CHAR*)szURL, '\\'))
        {
             while (*pszFind != '\0')
             {
                 if (*pszFind == '\\')
                     *pszFind = '/';
                 pszFind = CharNext(pszFind);
              }
         }

         if (pTable->IsStringInTable(szURL) == 0)
             pTable->AddString(szURL);
    }

    if (pNode->HasChildren())
    {
        pParents[dwCurLevel] = pNode;
        dwCurLevel++;

        pCur = pNode->GetFirstChild();

        while (pCur)
        {
            if (pCur->GetURL(szURL, sizeof(szURL), TRUE))
            {
                // Truncate the strings at the # character if there is one.
                pszFind = StrChr((const CHAR*)szURL, '#');
                if (pszFind != NULL)
                    *pszFind = '\0';
                if (pszFind = StrChr((const CHAR*)szURL, '\\'))
                {
                    while (*pszFind != '\0')
                    {
                        if (*pszFind == '\\')
                            *pszFind = '/';
                        pszFind = CharNext(pszFind);
                    }
                }
                if (pTable->IsStringInTable(szURL) == 0)
                    pTable->AddString(szURL);
             }

            if (pNext = pCur->GetFirstChild())
            {
                if (pParents[dwCurLevel])
                    delete pParents[dwCurLevel];
                pParents[dwCurLevel] = pCur;
                dwCurLevel++;
                pCur = pNext;
            }
            else if (pNext = pCur->GetNextSibling())
            {
                delete pCur;
                pCur = pNext;
            }
            else
            {
                delete pCur;
                while (TRUE)
                {
                    dwCurLevel--;
                    if (dwCurLevel == 0)
                    {
                        if (pParents[dwCurLevel+1])
                            delete pParents[dwCurLevel+1];
                        pCur = NULL;
                        break;
                    }
                    pCur = pParents[dwCurLevel];

                    if (pNext = pCur->GetNextSibling())
                    {
                        pCur = pNext;
                        break;
                    }
                    delete pCur;
                    pParents[dwCurLevel] = NULL;
                }
            }
        }
    }
    return;
}

BOOL CExCollection::InitFTSKeyword()
{
   // BUGBUG: we shouldn't do this until we know we have full-text search
   // in the file (which will usually NOT be the case).

   // Create full-text search object
   //
   if (m_phmData->m_sysflags.fFTI) {
      m_pFullTextSearch = new CFullTextSearch(this);
      m_pFullTextSearch->Initialize();

      // Create search highlight object
      //
      m_pSearchHighlight = new CSearchHighlight(this);
   }

  // create word wheels (they self initialize themselves upon use)
  //
  // TODO: move full text search shared code to CTitleDatabase
  //
  m_pDatabase = new CTitleDatabase( this );

   return TRUE;
}


#ifdef DUMPTOC

void CExCollection::DumpNode(CTreeNode **p)
{
   char sz[256];

   if (m_bRoot == TRUE)
      m_bRoot = FALSE;
   else
   {
      for (DWORD i = 1; i < m_dwLevel; i++)
    fprintf(m_fh, "  ");

      (*p)->GetTopicName(sz, sizeof(sz));

      fprintf(m_fh, "%s\n", sz);
   }

   CTreeNode *pNode;

   if (pNode = (*p)->GetFirstChild())
   {
      m_dwLevel++;
      DumpNode(&pNode);
      m_dwLevel--;
   }

   pNode = (*p)->GetNextSibling();
   delete (*p);
   *p = NULL;

   do
   {
      if (pNode)
    DumpNode(&pNode);
   } while (pNode && (pNode = pNode->GetNextSibling()));
}

#endif

void CExCollection::GetMergedTitles(CExTitle *pTitle)
{
    CStr cStrFile;
    CStr cStrFullPath;
    CExTitle *pNewTitle = NULL;
    CExTitle *pPreviousNewTitle = NULL;
    CExTitle *pParent = pTitle;
    char szMasterPath[MAX_PATH];
    char szTmp[MAX_PATH];
    BOOL bOk2Add = FALSE;

    LCID TitleLocale = NULL;

    if( !(pTitle->Init()) )
        return;

    //[ZERO IDXHDR]
    if (!pTitle->IsIdxHeaderValid())
    {
        return ;
    }

    if (pTitle->GetInfo())
    {
        TitleLocale = pTitle->GetInfo()->GetLanguage();
    }

    DWORD dwCount = pTitle->GetIdxHeaderStruct()->dwCntMergedTitles;
    for (DWORD i = 0; i < dwCount; i++)
    {
        // read string table for this string
        if (FAILED(pTitle->GetString((((DWORD*)(&(pTitle->GetIdxHeaderStruct()->pad)))[i]), &cStrFile)))
            continue;

        // if this is not a single title (.col file) search collection registry
        if (m_bSingleTitle == FALSE)
        {
            // get base name
           SplitPath((CHAR*)cStrFile, NULL, NULL,  szTmp, NULL);

            // search
            CTitle *pCTitle = m_Collection.FindTitle(szTmp, (LANGID)TitleLocale);

            if (pCTitle == NULL && TitleLocale != ENGLANGID)  // for localized merged chms if we can't find a child with the same lang look for englist look for english titles in hhcolreg
            {
                pCTitle = m_Collection.FindTitle(szTmp, (LANGID)ENGLANGID);
            }

            if (pCTitle)
            {
                // create CExTitle
                pNewTitle = new CExTitle(pCTitle, m_Collection.GetColNo(), this);
                m_Collection.IncrementRefTitleCount();

                if (ValidateTitle(pNewTitle) == TRUE)
                {
                    CExTitle* pTitle = m_pHeadTitles;
                    while(pTitle->GetNext())
                        pTitle = pTitle->GetNext();
                    pTitle->SetNext(pNewTitle);
                    //
                    // Sync/Next/Prev and subsetting spupport for "merged" chms...
                    //
                    pNewTitle->m_pParent = pParent;       // Set parent pointer.
                    if (! pParent->m_pKid )               // Set parent titles kid pointer to first kid.
                       pParent->m_pKid = pNewTitle;
                    if ( pPreviousNewTitle )
                       pPreviousNewTitle->m_pNextKid = pNewTitle;
                    pPreviousNewTitle = pNewTitle;
                    //
                    // Create a hash for these...
                    //
                    char szBuf[20];
                    char szID[MAX_PATH + 20];
                    Itoa(pCTitle->GetLanguage(), szBuf);
                    strcpy(szID, pCTitle->GetId());
                    strcat(szID, szBuf);
                    pNewTitle->m_dwHash = HashFromSz(szID);
                    continue;
                }
            }
			else if (m_Collection.GetFindMergedCHMS())
			{
	            if ( FindThisFile(NULL, cStrFile, &cStrFullPath) )
		        {
					// if found add to title list (add to the end of the list)
					pNewTitle = new CExTitle(cStrFullPath, this);
					m_Collection.IncrementRefTitleCount();
    
                    if (ValidateTitle(pNewTitle, TRUE) == TRUE)
                    {
					    CExTitle* pTitle = m_pHeadTitles;
					    while(pTitle->GetNext())
    	                    pTitle = pTitle->GetNext();
					    pTitle->SetNext(pNewTitle);
                        //
                        // Sync/Next/Prev and subsetting spupport for "merged" chms...
                        //
                        pNewTitle->m_pParent = pParent;       // Set parent pointer.
                        if (! pParent->m_pKid )               // Set parent titles kid pointer to first kid.
                            pParent->m_pKid = pNewTitle;
                        if ( pPreviousNewTitle )
                           pPreviousNewTitle->m_pNextKid = pNewTitle;
                        pPreviousNewTitle = pNewTitle;
                        //
                        // Create a hash for these...
                        //
                        char szBuf[20];
                        char szID[MAX_PATH + 20];
                        Itoa(0, szBuf);
                        strcpy(szID, szTmp);
                        strcat(szID, szBuf);
                        pNewTitle->m_dwHash = HashFromSz(szID);
                        continue;
				    }
                }
			}
        }
        else
        {
            //
            // First check location of this file
            //
            if ((CHAR*)m_csFile )
            {
               SplitPath((CHAR*)m_csFile, szMasterPath, szTmp, NULL, NULL);
               CatPath(szMasterPath, szTmp);
               CatPath(szMasterPath, (CHAR*)cStrFile);
                bOk2Add = ( GetFileAttributes(szMasterPath) != HFILE_ERROR );
            }

            // search for file
            //
            if (! bOk2Add )
               bOk2Add = FindThisFile(NULL, cStrFile, &cStrFullPath);
            else
               cStrFullPath = (const CHAR*)szMasterPath;

            if ( bOk2Add )
            {
                // if found add to title list (add to the end of the list)
                pNewTitle = new CExTitle(cStrFullPath, this);
                pNewTitle->m_pParent = pParent;       // Set parent pointer.
                CExTitle* pTitle = m_pHeadTitles;
                while(pTitle->GetNext())
                    pTitle = pTitle->GetNext();
                pTitle->SetNext(pNewTitle);
                m_Collection.IncrementRefTitleCount();
            }
        }
    }
}

// BUGBUG: <mikecole> dondr review, could this go away in-lu of checking the f_IsOrphan bit ?

CTreeNode * CExCollection::CheckForTitleNode(CFolder *p)
{
   if (p == NULL)
      return NULL;

   CHAR* pszTitle = p->GetTitle();

   if (pszTitle && pszTitle[0] == '=')
   {
      CExTitle *pt = FindTitle(pszTitle+1, p->GetLanguage());

      if (pt == NULL)
         return NULL;

      CExTitleNode *pext = new CExTitleNode(pt, p);
      return pext;
   }
   else
   {
      // Check if this folder has a title below it somewhere
      BOOL bFound = FALSE;
      CFolder *pFolder;
      if (pFolder = p->GetFirstChildFolder())
      {
         CheckForTitleChild(pFolder, &bFound);
      }
      if (bFound == FALSE)
      {
         return NULL;
      }
      CExFolderNode *pf = new CExFolderNode(p, this);
      return pf;
   }
   return NULL;
}

// BUGBUG: <mikecole> dondr review, could this go away in-lu of checking the f_IsOrphan bit ?

void CExCollection::CheckForTitleChild(CFolder *p, BOOL *pbFound)
{
   if (*pbFound == TRUE)
      return;

   CHAR* pszTitle = p->GetTitle();
   CFolder *pF;

   if (pszTitle && pszTitle[0] == '=')
   {
      *pbFound = TRUE;
      return;
   }

   if (pF = p->GetFirstChildFolder())
   {
      CheckForTitleChild(pF, pbFound);
      if (*pbFound == TRUE)
    return;
   }

   pF = p->GetNextFolder();

   while (pF)
   {
      CheckForTitleChild(pF, pbFound);
      if (*pbFound == TRUE)
    return;
      pF = pF->GetNextFolder();
   }
}

DWORD CExCollection::GetRefedTitleCount()
{
   return m_Collection.GetRefTitleCount();
}

BOOL CExCollection::IsBinaryTOC(const CHAR* pszToc)
{
   if (! m_phmData || !pszToc)
      return FALSE;
   return (HashFromSz(FindFilePortion(pszToc)) == m_phmData->m_hashBinaryTocName);
}

CTreeNode * CExCollection::GetRootNode()
{
   CStructuralSubset* pSS = NULL;

   if (m_bSingleTitle)
   {
      if (!m_pHeadTitles)
         m_pHeadTitles = new CExTitle(GetPathName(), this);

      TOC_FOLDERNODE Node;

      if ( !SUCCEEDED(m_pHeadTitles->GetRootNode(&Node)) )
         return NULL;

      CExTitleNode *pext = new CExTitleNode(m_pHeadTitles, NULL);
         return pext;
   }
   else
   {
      CFolder *p = m_Collection.GetRootFolder();
      CTreeNode *pN;

      // implement structural subset filtering for TOC here.
      if( m_pSSList )
         pSS = m_pSSList->GetTOC();

      while (p)
      {
         if ((pN = CheckForTitleNode(p)))
         {
            if ( !pSS || pSS->IsEntire() || p->bIsVisable() )
               return pN;
            else
               delete pN; // leak fix
         }
         p = p->GetNextFolder();
      }
      return NULL;
   }
}

//////////////////////////////////////////////////////////////////////////
//
// Ignore LangId if its Zero.
//
CExTitle * CExCollection::FindTitle(const CHAR* pszId, LANGID LangId)
{
   // look in list of titles
   CExTitle *p = m_pHeadTitles;

   while (p)
   {
      if( p->GetCTitle() )
          if( _tcsicmp(p->GetCTitle()->GetId(), pszId) == 0 ) 
            if( (LangId == 0 || p->GetCTitle()->GetLanguage() == LangId) ) // If LangId == 0, we ignore the lang id.
      {
         return p;
      }
      p = p->GetNext();
   }
   return NULL;
}

// Try multiple LangIds before failing
CExTitle * CExCollection::FindTitleNonExact(const CHAR* pszId, LANGID DesiredLangId)
{
    CExTitle* pTitle = NULL ;

    CLanguageEnum* pEnum = _Module.m_Language.GetEnumerator(DesiredLangId) ;
    ASSERT(pEnum) ;
    LANGID LangId = pEnum->start() ;
    while (LangId != c_LANGID_ENUM_EOF)
    {
        pTitle = FindTitle(pszId, LangId);
        if (pTitle)
        {
            break ; // Found it!
        }

        LangId = pEnum->next() ;
    }

    // Cleanup.
    if (pEnum)
    {
        delete pEnum ;
    }


    return pTitle;
}

//
CExTitle * CExCollection::TitleFromChmName(const CHAR* pszChmName)
{
   CExTitle *p = m_pHeadTitles;
   CHAR szFN[MAX_PATH];
   CHAR szExt[MAX_PATH];

   while (p)
   {
      SplitPath(p->GetContentFileName(), NULL, NULL, szFN, szExt);
      strcat(szFN, szExt);
      if (! _tcsicmp(szFN, pszChmName) )
         return p;
      p = p->GetNext();
   }
   return NULL;
}

CLocation * CExCollection::FindLocation(CHAR* pszId)
{
   return m_Collection.FindLocation(pszId);
}

// GetNext()
//
// Returns the next physical TOC node irregaurdless of its type. If a node is a container, it's
// next is considered to be it's child.
//
// Note that the caller will be responsible for deleting the returned CTreeNode object.
//
CTreeNode * CExCollection::GetNext(CTreeNode* pTreeNode, DWORD* pdwSlot)
{
   CTreeNode *pTreeNext = NULL, *pTreeParent = NULL, *pSaveNode = NULL;
   DWORD dwObjType;

   dwObjType = pTreeNode->GetType();
   if ( ((dwObjType == FOLDER) || (dwObjType == CONTAINER)) && (pTreeNext = pTreeNode->GetFirstChild(pdwSlot)) )
      return pTreeNext;
   else
   {
      if ( (pTreeNext = pTreeNode->GetNextSibling(NULL, pdwSlot)) )
         return pTreeNext;
      else
      {
         pSaveNode = pTreeNode;
         do
         {
            pTreeParent = pTreeNode->GetParent(pdwSlot, TRUE);
            if ( pSaveNode != pTreeNode )
               delete pTreeNode;
            if (! (pTreeNode = pTreeParent) )
               return NULL;

         } while (!(pTreeNext = pTreeNode->GetNextSibling(NULL, pdwSlot)));
      }
      return pTreeNext;
   }
}

// GetNext()
//
// Returns the next TOC node that represents a displayable topic.
//
// Note that the caller will be responsible for deleting the returned CTreeNode object.
//
CTreeNode * CExCollection::GetNextTopicNode(CTreeNode* pTreeNode, DWORD* pdwSlot)
{
   CTreeNode *pTocNext = NULL, *pTocKid = NULL;
   DWORD dwObjType;

try_again:
   if ( (pTocNext = GetNext(pTreeNode, pdwSlot)) )
   {
      dwObjType = pTocNext->GetType();
      if ( (dwObjType != TOPIC) && (dwObjType != CONTAINER) )
      {
         //  We need to drill down!
         //
         do
         {
             if ( (pTocKid = pTocNext->GetFirstChild(pdwSlot)) )
             {
                 dwObjType = pTocKid->GetType();
                 delete pTocNext;
                 pTocNext = pTocKid;
             }
             else
             {
                 // This is the case of the book that contains no kids! For this case, we'll skip this dirty node!
                 //
                 pTreeNode = pTocNext;
                 goto try_again;
             }
         } while ( (dwObjType != TOPIC) && (dwObjType != CONTAINER) );
      }
      return pTocNext;
   }
   return NULL;
}


// GetPrev()
//
// Returns the previous physical TOC node irregardless of its type.
//
// Note that the caller will be responsible for deleting the returned CTreeNode object.
//
CTreeNode * CExCollection::GetPrev(CTreeNode* pTreeNode, DWORD* pdwSlot)
{
   CTreeNode *pTreeNext = NULL, *pTreeParent = NULL , *pSaveNode = NULL, *pTmpNode = NULL;
   DWORD dwObjType;
   DWORD dwTmpSlot;

   pSaveNode = pTreeNode;
   if (! (pTreeParent = pTreeNode->GetParent(pdwSlot, TRUE)) )
   {
      // Could this be a single title with multiple roots ?
      //
      if ( pTreeNode->GetObjType() == EXNODE )
      {
         CExTitle* pTitle;
         pTitle = ((CExNode*)pTreeNode)->GetTitle();
         if ( pTitle->m_pCollection->IsSingleTitle() )
         {
            TOC_FOLDERNODE Node;
            pTitle->GetRootNode(&Node);
            pTreeNext = new CExNode(&Node, pTitle);
            if ( pTreeNext->Compare(pSaveNode) ) {
               delete pTreeNext;  // leak fix
               return NULL;       // No prev to be found!
            }
            if ( pdwSlot )
               *pdwSlot = pTitle->GetRootSlot();
            goto find_it;
         }
      }
      else
      {
         CFolder *p = m_Collection.GetRootFolder();
         if( !p )
           return NULL;
         p = p->GetFirstChildFolder();
         //
         // Is it visable ?
         //
         CStructuralSubset* pSS = NULL;
         if( m_pSSList )
            pSS = m_pSSList->GetTOC();

         if ( pSS && !pSS->IsEntire() && !p->bIsVisable() )
            return NULL;

         pTreeNext = new CExFolderNode(p, this);
         goto find_it;
      }
      return NULL;
   }
   if (! (pTreeNext = pTreeParent->GetFirstChild(&dwTmpSlot)) ) {
      delete pTreeParent;  // leak fix
      return NULL;
   }

   // ---LEAK!: At this point we have a pTreeNext and pTreeParent ---

   if ( pTreeNext->Compare(pSaveNode) )
   {
      dwObjType = pTreeParent->GetType();
      if ( dwObjType == CONTAINER )
         return pTreeParent;
      else
      {
         pTmpNode = GetPrev(pTreeParent, pdwSlot);
         delete pTreeParent;
         if (! pTmpNode )
         {
             delete pTreeNext ; // Fix Leak.
            return NULL;
         }
         if ( pTmpNode->GetType() == CONTAINER )
            return pTmpNode;
         else
         {
            pTreeParent = GetLastChild(pTmpNode, pdwSlot);
            if ( pTreeParent != pTmpNode )
               delete pTmpNode;
            return pTreeParent;
         }
      }
   }
   delete pTreeParent;
   if ( pdwSlot )
      *pdwSlot = dwTmpSlot;
find_it:
   pTmpNode = pTreeNext->GetNextSibling(NULL, &dwTmpSlot);
   while ( pTmpNode && !pTmpNode->Compare(pSaveNode) )
   {
      delete pTreeNext; pTreeNext = NULL;  // leak fix
      pTreeNext = pTmpNode;
      if ( pdwSlot )
         *pdwSlot = dwTmpSlot;
      pTmpNode = pTreeNext->GetNextSibling(NULL, &dwTmpSlot);
   }
   if (pTmpNode && pTmpNode->Compare(pSaveNode) )
   {
      delete pTmpNode;
      if ( pTreeNext->GetType() == BOGUS_FOLDER )
      {
         pTmpNode = GetPrev(pTreeNext, pdwSlot);
         if ( pTmpNode != pTreeNext )
         {
            delete pTreeNext; pTreeNext = NULL;  // leak fix
            pTreeNext = pTmpNode;
         }
      }
      pTmpNode = GetLastChild(pTreeNext, pdwSlot);
      if ( pTmpNode != pTreeNext )
         delete pTreeNext;
      return pTmpNode;
   }
   else if( pTmpNode )
     delete pTmpNode;  // leak fix

   if( pTreeNext && (pTreeNext != pTmpNode) )
     delete pTreeNext;  // leak fix

   return NULL;
}

CTreeNode * CExCollection::GetLastChild(CTreeNode* pTreeNode, DWORD* pdwSlot)
{
   CTreeNode *pTreeTmp = NULL, *pTreeKid = NULL, *pSiblingNode = NULL;
   DWORD dwObjType;

   if (! pTreeNode )
      return NULL;

   dwObjType = pTreeNode->GetType();
   if ( dwObjType != TOPIC )
   {
      // We need to drill down.
      //
      if ( (pTreeKid = pTreeNode->GetFirstChild(pdwSlot)) )
      {
         while ( (pSiblingNode = pTreeKid->GetNextSibling(NULL, pdwSlot)) )
         {
            while ( pSiblingNode->GetType() == BOGUS_FOLDER )
            {
               if ( ! (pTreeTmp = pSiblingNode->GetNextSibling(NULL, pdwSlot)) )
                  break;
               else
               {
                  delete pSiblingNode;
                  pSiblingNode = pTreeTmp;
               }
            }
            delete pTreeKid;
            pTreeKid = pSiblingNode;
         }
         if ( pTreeKid->GetType() != TOPIC )
         {
            pTreeTmp = GetLastChild(pTreeKid, pdwSlot);
            if (pTreeTmp == pTreeKid)
            {
                delete pTreeKid;
                return NULL;
            }
            delete pTreeKid;
            pTreeKid = pTreeTmp;
         }
         return pTreeKid;
      }
   }
   return pTreeNode;
}

HRESULT CExCollection::URL2ExTitle(const CHAR* pszURL, CExTitle **ppTitle)
{
   // get the title from the URL
   CStr cStr;
   const CHAR* pszThisFileName;
   GetCompiledName(pszURL, &cStr);
   if( !cStr.psz )
     return E_FAIL;
   const CHAR* pszFileName = FindFilePortion( cStr.psz );

   CExTitle *pTitle = GetFirstTitle();

   while (pTitle)
   {
      pszThisFileName = pTitle->GetFileName();
      if (pszThisFileName == NULL)
      {
        pTitle = pTitle->GetNext();
        continue;
      }
      if( StrCmpIA(pszThisFileName, pszFileName) == 0 )
      {
        *ppTitle = pTitle;
        return S_OK;
      }
      pTitle = pTitle->GetNext();
   }
   return E_FAIL;
}

//
// The following bit of code attempts to detect if we have arrived at a topic that is referenced in
// more than one place in the TOC. This is done by comparing the TOC location we lookup for the URL with
// the "m_dwCurrSlot" which is updated here and when any navigation call is made. If these TOC locations
// are different yet they reference the same topic, we utilize the "m_dwCurrSlot" TOC location for syncing
// needs.
//
// UpdateTopicSlot()
//
// Called ONLY from BeforeNavigate() before a navigation in allowed to proceed.
//
void CExCollection::UpdateTopicSlot(DWORD dwSlot, DWORD dwTN, CExTitle* pTitle)
{
   if ( m_dwCurrSlot && dwSlot != m_dwCurrSlot )
   {
//      if ( (dwTN != m_dwCurrTN) && dwSlot )
      if ( (dwTN != m_dwCurrTN) )
         m_dwCurrSlot = dwSlot;
      else
         return;
   }
   else
      m_dwCurrSlot = dwSlot;
   m_dwCurrTN = dwTN;
   m_pCurrTitle = pTitle;
}

HRESULT CExCollection::Sync(CPointerList *pHier, const CHAR* pszURL)
{
   CTreeNode* pThis = NULL;
   CExTitle *pTitle = NULL;
   CTreeNode *pParent = NULL;

   if ( m_dwCurrSlot )
   {
      if( IsBadReadPtr(m_pCurrTitle, sizeof(CExTitle)) )
         return E_FAIL;
      if (! SUCCEEDED(m_pCurrTitle->Slot2TreeNode(m_dwCurrSlot, &pThis)) )
         return E_FAIL;
   }
   else if (pszURL) {
      if (! SUCCEEDED(URL2ExTitle(pszURL, &pTitle)) )
         return E_FAIL;

      // MAJOR HACK to fix a show stopper for nt5.  This code assumes nt's superchm authoring of URLS's as follows
      // MS-ITS:dkconcepts.chm::/defrag_overview_01.htm.  This code assumes ansi URL strings
      if (pTitle->m_pParent)
      {
          char szBuf[MAX_URL];
          strcpy(szBuf, pszURL);

          char *pszLastWak, *pszCurChar;

          pszLastWak = NULL;
          pszCurChar = szBuf;

          while (*pszCurChar)
          {
            // if we get to the :: we are at the end of the pathing information
            if (*pszCurChar == ':' && *(pszCurChar+1) == ':')
                break;
            if (*pszCurChar == '\\' || *pszCurChar == '/')
                pszLastWak = pszCurChar;
            pszCurChar++;
          }
          if (pszLastWak)
          {
              char szBuf2[MAX_URL];
              pszLastWak ++;
              strcpy(szBuf2, pszLastWak);
              strcpy(szBuf, txtMsItsMoniker);
              pszCurChar = szBuf2;
              strcat(szBuf, szBuf2);
              if (! SUCCEEDED(pTitle->m_pParent->GetURLTreeNode(szBuf, &pThis, FALSE)) ) 
                  return E_FAIL;
          }
      } 
      else if (! SUCCEEDED(pTitle->GetURLTreeNode(pszURL, &pThis)) )
      {
          return E_FAIL;
      }
   }
   else 
   {
      return E_FAIL;   
   }

   // Make sure we have a valid CTreeNode pointer (Whistler bug #8112 & 8101).
   // The above code below "MAJOR HACK" doesn't appear to work because:
   //    1) we fall out of the parsing loop before pszLastWak is set, and
   //    2) even if pszLastWak was set, GetURLTreeNode() fails on the 
   //       generated URL.  
   //
   // In the case of bug #8112 & 8101, we get to this point and pThis has not 
   // been set to a valid CTreeNode (thus the crash).  The safest thing to do
   // is simply call GetURLTreeNode here and get the CTreeNode pointer.
   // 
   if(!pThis)
   {
      if (!SUCCEEDED(pTitle->GetURLTreeNode(pszURL, &pThis)))
          return E_FAIL;
   }

   pHier->Add(pThis);
   // now get all of the parents
   for (pParent = pThis->GetParent(); pParent; pParent = pParent->GetParent())
      pHier->Add(pParent);

   return S_OK;
}

CFolder *CExCollection::FindTitleFolder(CExTitle *pTitle)
{
   CFolder *p;
   LISTITEM *pItem;
   pItem = m_Collection.m_RefTitles.First();
   while (pItem)
   {
      p = (CFolder *)pItem->pItem;

      if (pTitle->GetCTitle() && _tcsicmp(pTitle->GetCTitle()->GetId(), p->GetTitle() + 1) == 0 &&
    pTitle->GetCTitle()->GetLanguage() == p->GetLanguage())
    return p;
      pItem = m_Collection.m_RefTitles.Next(pItem);
   }
   return NULL;
}


// <mc>
// I've modified this function be be more generic. It returns a local storage path according to
// the same rules as always:
//
// 1.) location of local .COL
// 2.) "windir"\profiles\"user"\application data\microsoft\htmlhelp directory.
//
// The function mow takes an extension name which will be used to qualify the requested storage
// pathname.
//
//   **** WARNING ****
//   We return a pointer from this function. Callers should make a copy of the string immeadiatly
//   after they call this function rather than placing any reliance of the integrity of the pointer returned.
//
// </mc>

const CHAR* CExCollection::GetLocalStoragePathname(const CHAR* pszExt)
{
  // TODO: read this in from the XML file
  //      (for now base it on the collection pathname)
  //
  // TODO: check write permission of destination, if not allowed
  //       the set the path to the system directory or some
  //       other default writable location
  //
  // TODO: check for sufficient disk space.

  static CHAR szPathname[MAX_PATH];
  CHAR szFileName[MAX_PATH];
  CHAR* pszExtension;
  UINT uiDt = DRIVE_UNKNOWN;

  if( !pszExt && *pszExt )
    return NULL;

  // if we want the chw and it is already set then return it and bail out
  if( !strcmp( pszExt, ".chw" ) ) {
    if( m_szWordWheelPathname )
      return m_szWordWheelPathname;
  }

  // If we're operating a collection, use the location of the collection file and the collection
  // file root name as the .chm name.
  //
  if (! m_bSingleTitle )
   strcpy(szPathname, m_Collection.GetCollectionFileName());
  else   // else, in single title mode, use master .chm name and location.
   strcpy(szPathname ,GetPathName());

  CHAR* pszFilePart = NULL;
  GetFullPathName( szPathname, sizeof(szPathname), szPathname, &pszFilePart );

  // get the drive of the path
  CHAR szDriveRoot[4];
  strncpy( szDriveRoot, szPathname, 4 );
  szDriveRoot[3] = '\0';

  // make sure to add a backslash if the second char is a colon
  // sometimes we will get just "d:" instead of "d:\" and thus
  // GetDriveType will fail under this circumstance
  if( szDriveRoot[1] == ':' ) {
   szDriveRoot[2] = '\\';
   szDriveRoot[3] = 0;
  }

  // Get media type
  if( szDriveRoot[1] == ':' && szDriveRoot[2] == '\\' ) {
   uiDt = GetDriveType(szDriveRoot);
  }
  else if( szDriveRoot[0] == '\\' && szDriveRoot[1] == '\\' ) {
   uiDt = DRIVE_REMOTE;
  }

  // If removable media or not write access then write to the %windir%\profiles... directory
  if( !( ((uiDt == DRIVE_FIXED) || (uiDt == DRIVE_REMOTE) || (uiDt == DRIVE_RAMDISK)) ) ) {  
   strcpy(szFileName, FindFilePortion(szPathname));
   HHGetUserDataPath( szPathname );
   CatPath(szPathname, szFileName);
  }

  // for chw files this location must be writeable
  if( !strcmp( pszExt, ".chw" ) )
  {
   
   if( (pszExtension = StrRChr( szPathname, '.' )) )
     *pszExtension = '\0';
   strcat( szPathname, ".foo" );
   HANDLE hFile = CreateFile(szPathname, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL, 0);
   if (INVALID_HANDLE_VALUE == hFile)
   {  
    strcpy(szFileName, FindFilePortion(szPathname));
    HHGetUserDataPath( szPathname );
    CatPath(szPathname, szFileName);
   }
   else
   {
     CloseHandle(hFile);
     DeleteFile(szPathname);
   }
  }
  // now update the extension
  if( (pszExtension = StrRChr( szPathname, '.' )) )
    *pszExtension = '\0';
  strcat( szPathname, pszExt );

  // for the chw file, save it
  if( !strcmp( pszExt, ".chw" ) ) 
    SetWordWheelPathname( szPathname );

  return( szPathname );
}

const CHAR* CExCollection::GetUserCHSLocalStoragePathnameByLanguage()
{
  // TODO: check for sufficient disk space.

  static CHAR szPathname[MAX_PATH];
  CHAR* pszExtension;

  // If we're operating a collection, use the location of the collection file and the collection
  // file root name as the .chm name.
  //
  if (! m_bSingleTitle )
   strcpy(szPathname, m_Collection.GetCollectionFileName());
  else   // else, in single title mode, use master .chm name and location.
   strcpy(szPathname ,GetPathName());

  CHAR* pszFilePart = NULL;
  GetFullPathName( szPathname, sizeof(szPathname), szPathname, &pszFilePart );

  // now get the users path name
  char szUserPath[MAX_PATH];

  if (HHGetCurUserDataPath( szUserPath ) == S_OK)
  {
    // append language id
    CHAR szTemp[5];
    CHAR* pszName;
    LANGID LangId;
    m_Collection.GetMasterCHM(&pszName, &LangId);
    wsprintf(szTemp, "%d", LangId);
    CatPath(szUserPath, szTemp);
    if( !IsDirectory(szUserPath) )
      CreateDirectory( szUserPath, NULL );

    CatPath(szUserPath, pszFilePart);

    strcpy(szPathname, szUserPath);
  }
  // now update the extension
  if( (pszExtension = StrRChr( szPathname, '.' )) )
    *pszExtension = '\0';
  strcat( szPathname, ".chs" );

  return( szPathname );
}

const CHAR* CExCollection::GetUserCHSLocalStoragePathname()
{
  // TODO: check for sufficient disk space.

  static CHAR szPathname[MAX_PATH];
  CHAR* pszExtension;

  // If we're operating a collection, use the location of the collection file and the collection
  // file root name as the .chm name.
  //
  if (! m_bSingleTitle )
   strcpy(szPathname, m_Collection.GetCollectionFileName());
  else   // else, in single title mode, use master .chm name and location.
   strcpy(szPathname ,GetPathName());

  CHAR* pszFilePart = NULL;
  GetFullPathName( szPathname, sizeof(szPathname), szPathname, &pszFilePart );

  // now get the users path name
  char szUserPath[MAX_PATH];

  if (HHGetCurUserDataPath( szUserPath ) == S_OK)
  {
    CatPath(szUserPath, pszFilePart);
    strcpy(szPathname, szUserPath);
  }
  // now update the extension
  if( (pszExtension = StrRChr( szPathname, '.' )) )
    *pszExtension = '\0';
  strcat( szPathname, ".chs" );

  return( szPathname );
}


const CHAR* CExCollection::SetWordWheelPathname( const CHAR* pszWordWheelPathname )
{
  // if we already have one, free it
  if( m_szWordWheelPathname ) {
    delete [] (CHAR*) m_szWordWheelPathname;
    m_szWordWheelPathname = NULL;
  }

  // allocate a new once based on the size of the input buffer
  int iLen = (int)strlen( pszWordWheelPathname );
  m_szWordWheelPathname = new char[iLen+10];                      // Add 10 for future extension additions.
  strcpy( (CHAR*) m_szWordWheelPathname, pszWordWheelPathname );

  return m_szWordWheelPathname;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CExTitle implementation

void CExTitle::_CExTitle() // <--- put all shared initialization here
{
    m_pUsedLocation = NULL;
    m_bOpen = FALSE;
    m_dwNodeOffsetInParentTitle = 0;
    m_pTitleFTS = NULL;
    m_pCFileSystem = NULL;
    m_pTocNodes = m_pTopics = m_pStrTbl = m_pUrlTbl = m_pUrlStrings = m_pITBits = NULL;
    m_pNext = NULL;
    m_pHeader = NULL;
    m_pInfo = NULL;
    m_pInfo2 = NULL;
    m_fIsChiFile = FALSE;
    m_uiVolumeOrder = (UINT) -1;
    m_bChiChmChecked = FALSE;
    m_bIsValidTitle = FALSE;
    m_cMapIds = 0;
    m_pMapIds = NULL;

    //[ZERO IDXHDR] Mark the m_IdxHeader as being uninitialized.
    m_pIdxHeader = NULL;
    m_pKid = m_pNextKid = m_pParent = NULL;
    m_szAttachmentPathName[0] = 0;
}

CExTitle::CExTitle(const CHAR* pszFileName, CExCollection *pCollection)
{
    _CExTitle();
    m_ContentFileName = pszFileName;
    m_dwColNo = 0;
    m_pTitle = NULL;
    m_pCollection = pCollection;
    m_pInfo2 = new CTitleInformation2( GetIndexFileName() );
}

CExTitle::CExTitle(CTitle *p, DWORD ColNo, CExCollection *pCollection)
{
    _CExTitle();
    m_dwColNo = ColNo;
    m_pTitle = p;
    m_pCollection = pCollection;

    const CHAR* pFileName = NULL ;
    ASSERT(p) ;

   FindUsedLocation();

   if (GetUsedLocation() == NULL)
      return;

    if (GetUsedLocation()->IndexFileName)
      pFileName = GetUsedLocation()->IndexFileName  ;
    else
        pFileName = GetUsedLocation()->FileName ;

   m_pInfo2 = new CTitleInformation2(pFileName);
}

CExTitle::~CExTitle()
{
    CloseTitle();

    if ( m_pTitleFTS )
        delete m_pTitleFTS;
    m_pTitleFTS = NULL;

    if ( m_pInfo2 )
        delete m_pInfo2;
    m_pInfo2 = NULL;

    if ( m_pInfo )
        delete m_pInfo;
    m_pInfo = NULL;
}

void CExTitle::CloseTitle()
{
    if ( m_pTocNodes )
        delete m_pTocNodes;
    m_pTocNodes = NULL;

    if ( m_pTopics )
        delete m_pTopics;
    m_pTopics = NULL;

    if ( m_pStrTbl )
        delete m_pStrTbl;
    m_pStrTbl = NULL;

    if ( m_pUrlTbl )
        delete m_pUrlTbl;
    m_pUrlTbl = NULL;

    if ( m_pUrlStrings )
        delete m_pUrlStrings;
    m_pUrlStrings = NULL;

    if ( m_pITBits )
        delete m_pITBits;
    m_pITBits = NULL;

    if ( m_pHeader )
        lcFree(m_pHeader);
    m_pHeader = NULL;

    if ( m_pCFileSystem ) {
        m_pCFileSystem->Close();
        delete m_pCFileSystem;
      }
    m_pCFileSystem = NULL;

    m_bOpen = FALSE;
}

static const char txtChiFile[] = ".chi";

BOOL CExTitle::OpenTitle()
{
  if (m_bOpen)
    return TRUE;

  // get our title locations
  const CHAR* pszContentFilename = GetPathName();
  const CHAR* pszIndexFilename = GetIndexFileName();

  // bail out if neither file specified
  if( !pszContentFilename && !pszIndexFilename )
    return FALSE;

  // for the single title case, the command line is simply
  // the chm file so we will have to see if the chi files lives in the
  // same location.  If it does not, then we have a monolithic title
  // condition.
  char szIndexFilename[_MAX_PATH];
  if( m_pCollection && m_pCollection->IsSingleTitle() && pszContentFilename ) {
    strcpy( szIndexFilename, pszContentFilename );
    CHAR* psz;
    if( (psz = StrRChr(szIndexFilename, '.')) )
      strcpy(psz, txtChiFile);
    else
      strcat(szIndexFilename, txtChiFile);
    if (GetFileAttributes(szIndexFilename) != HFILE_ERROR)
        pszIndexFilename = szIndexFilename;
  }

  // monolithic title?
  BOOL bMonolithic = FALSE;
  if( !pszIndexFilename || !pszContentFilename ||
    (strcmpi( pszContentFilename, pszIndexFilename ) == 0) ) {
    bMonolithic = TRUE;
  }

  // bail out if no content file
  if( !pszContentFilename )
    return FALSE;

  // now open the title files
  return exOpenFile( pszContentFilename, (bMonolithic || pszIndexFilename[0] == NULL) ? NULL : pszIndexFilename );
}

BOOL CExTitle::FindUsedLocation()
{
    if (m_pUsedLocation)
        return TRUE;

    char drive[_MAX_DRIVE];
    char dir[_MAX_DIR];
    char fname[_MAX_FNAME];
    char ext[_MAX_EXT];

    // find the correct location to use
    // first look for the newest local and entry for this collection
    m_pUsedLocation = m_pTitle->m_pHead;
    DWORD dwNewestLocal = 0;
    DWORD dwNewest = 0;
    LOCATIONHISTORY *pNewestLocal = NULL;
    LOCATIONHISTORY *pNewest = NULL;
    LOCATIONHISTORY *pThisCol = NULL;
    while (m_pUsedLocation)
    {
       _splitpath( m_pUsedLocation->FileName, drive, dir, fname, ext );
       strcpy(dir, drive);
       if (dir[0] != NULL)
       {
            dir[1] = ':';
            dir[2] = '\\';
            dir[3] = NULL;
        }
        if (GetDriveType(dir) == DRIVE_FIXED)
        {
            if (m_pUsedLocation->Version > dwNewestLocal)
            {
                dwNewestLocal = m_pUsedLocation->Version;
                pNewestLocal = m_pUsedLocation;
            }
        }

        if (m_pUsedLocation->Version >= dwNewest)
        {
            dwNewest = m_pUsedLocation->Version;
            pNewest = m_pUsedLocation;
        }

        if (m_pUsedLocation->CollectionNumber == m_dwColNo)
        {
            if (pThisCol)
            {
                if (pThisCol->Version <= m_pUsedLocation->Version)
                    pThisCol = m_pUsedLocation;
            }
            else
                pThisCol = m_pUsedLocation;
        }
        m_pUsedLocation = m_pUsedLocation->pNext;
    }

    m_pUsedLocation = pThisCol;

    if (m_pUsedLocation == NULL)
        return FALSE;

    m_ContentFileName = m_pUsedLocation->FileName;
    m_IndexFileName = m_pUsedLocation->IndexFileName;
    return TRUE;
}

BOOL CExTitle::exOpenFile(const CHAR* pszContent, const CHAR* pszIndex)
{
   HRESULT hr;

   if (m_bOpen)
      return TRUE;

   ASSERT_COMMENT(!m_pCFileSystem, "exOpenFile already called once");

   m_pCFileSystem = new CFileSystem();

   if ( m_pCFileSystem->Init() != S_OK )
      goto failure;
   if ( pszIndex )
   {
       hr = m_pCFileSystem->Open(pszIndex);
       m_IndexFileName = pszIndex;
       m_fIsChiFile = TRUE;
   }
   else
       hr = m_pCFileSystem->Open(pszContent);

   if (FAILED(hr))
      goto failure;

   // title information pointer

   if (! m_pInfo )
   {
      m_pInfo = new CTitleInformation( m_pCFileSystem );
      if (! m_pInfo->GetIdxHeader(&m_pIdxHeader) )
      {
         //
         //    Open and read the idxheader subifle.
         //
         CPagedSubfile* pHdrSubFile;
         BYTE* pb;
      
         pHdrSubFile = new CPagedSubfile;
         if ( SUCCEEDED(hr = pHdrSubFile->Open(this, txtIdxHdrFile)) )
         {
            if ( (pb = (BYTE*)pHdrSubFile->Offset(0)) )
            {
               CopyMemory((PVOID)m_pIdxHeader, (LPCVOID)pb, sizeof(IDXHEADER));
//               m_pIdxHeader->dwOffsMergedTitles = (DWORD*)&m_pIdxHeader->pad; // 64bit overwrite
            }
         }
         if( pHdrSubFile )
           delete pHdrSubFile;
      }
   }
   m_bOpen = TRUE;

   //
   // Init full-text for title
   //
   if(!m_pTitleFTS && GetInfo()->IsFullTextSearch())
   {
      m_pTitleFTS = new CTitleFTS( pszContent, GetInfo()->GetLanguage(), this );
   }

   m_ITCnt = GetInfo()->GetInfoTypeCount();

   if( m_pCollection )
   {
     if ( m_pCollection->GetMasterTitle() != this )    // ALWAYS cache the CExTitle data for the master title. i.e.
        m_pCollection->GetOpenSlot(this);
   }

   // BUGBUG - return a value based on hr when these subfiles exist
   return(TRUE);    // TRUE on success.

failure:
   delete m_pCFileSystem;
   m_pCFileSystem = NULL;
   return FALSE;
}

BOOL CExTitle::EnsureChmChiMatch( CHAR* pszChm )
{
   if (! m_fIsChiFile )
      return TRUE;

   if ( !pszChm && m_bChiChmChecked )
      return m_bIsValidTitle;

   if( pszChm ) {
     m_bChiChmChecked = FALSE;
     m_bIsValidTitle = FALSE;
   }
   else
     m_bChiChmChecked = TRUE;

   FILETIME ftChi, ftChm;
   CTitleInformation* pChmInfo = NULL;
   HRESULT hr;

   ftChi = GetInfo()->GetFileTime();
   CFileSystem* pCFileSysChm = new CFileSystem();
   if ( pCFileSysChm->Init() == S_OK )
   {
      const CHAR* pszChmTry;
      if( pszChm )
        pszChmTry = pszChm;
      else
        pszChmTry = GetPathName();

      if ( SUCCEEDED((hr = pCFileSysChm->Open(pszChmTry))) )
      {
         pChmInfo = new CTitleInformation(pCFileSysChm);
         ftChm = pChmInfo->GetFileTime();
         if ( (ftChm.dwHighDateTime != ftChi.dwHighDateTime) || (ftChm.dwLowDateTime != ftChi.dwLowDateTime) )
         {
            if( pszChm )
               m_bIsValidTitle = FALSE;               
            else if ( MsgBox(IDS_CHM_CHI_MISMATCH, GetPathName(), MB_OKCANCEL | MB_ICONWARNING | MB_TASKMODAL) == IDOK )
               m_bIsValidTitle = TRUE;
            else
               m_bIsValidTitle = FALSE;               
         }
         else
           m_bIsValidTitle = TRUE;
      }
   }
   delete pCFileSysChm;

   if ( pChmInfo )
      delete pChmInfo;

   return m_bIsValidTitle;
}

const CHAR* CExTitle::GetFileName()
{
  if (m_pTitle && GetUsedLocation() == NULL)
    return NULL;

  if (GetUsedLocation())
    return FindFilePortion(GetUsedLocation()->FileName);
  else
    return FindFilePortion(m_ContentFileName);
}

const CHAR* CExTitle::GetPathName()
{
  if (m_pTitle && GetUsedLocation() == NULL)
    return NULL;

  if (GetUsedLocation())
    return GetUsedLocation()->FileName;
  else
    return m_ContentFileName;
}

const CHAR* CExTitle::GetQueryName()
{
  if (m_pTitle && GetUsedLocation() == NULL)
    return NULL;

  if (GetUsedLocation())
  {
    char *pszQueryName = GetUsedLocation()->QueryFileName;

    if( pszQueryName && *pszQueryName)  // don't want a null string
      return pszQueryName;
    else
      return NULL;
  }
  else
  {
    // DON: Is this right?
    //
    return NULL;
  }
}

const CHAR* CExTitle::GetIndexFileName()
{
  if (m_pTitle && GetUsedLocation() == NULL)
    return NULL;

  if (GetUsedLocation())
  {
    return GetUsedLocation()->IndexFileName;
  }
  else
  {
    if ( (CHAR*)m_IndexFileName )
      return m_IndexFileName;
    else
      return GetPathName();
  }
}


const CHAR* CExTitle::GetCurrentAttachmentName()
{
  return (const CHAR*) &m_szAttachmentPathName;
}


const CHAR* CExTitle::SetCurrentAttachmentName( const CHAR* pszAttachmentPathName )
{
  if( pszAttachmentPathName && pszAttachmentPathName[0] )
    strcpy( m_szAttachmentPathName, pszAttachmentPathName );
  return (const CHAR*) &m_szAttachmentPathName;
}

DWORD CExTitle::GetRootSlot(void)
{
   BYTE* pb;

   if (m_bOpen == FALSE)
   {
      if (OpenTitle() == FALSE)
         return 0;
   }
   if (!m_pTocNodes)
   {
       m_pTocNodes = new CPagedSubfile;
      if (FAILED(m_pTocNodes->Open(this, txtTocIdxFile)))
      {
         delete m_pTocNodes;
         m_pTocNodes = NULL;
         return 0;
      }
   }
   if (! m_pHeader )
   {
      m_pHeader = (TOCIDX_HDR*)lcCalloc(sizeof(TOCIDX_HDR));
      if (! (pb = (BYTE*)m_pTocNodes->Offset(0)) )
         return 0;  // m_pHeader will be freeed in destructor.
      CopyMemory((PVOID)m_pHeader, (LPCVOID)pb, sizeof(TOCIDX_HDR));
   }
   return(m_pHeader->dwOffsRootNode);
}


HRESULT CExTitle::GetRootNode(TOC_FOLDERNODE *pNode)
{
   HRESULT hr = E_FAIL;
   DWORD dwNode;
   unsigned int uiWidth;
   const unsigned int *pdwITBits;
   CSubSet* pSS;

   dwNode = GetRootSlot();
   do
   {
      if ( !SUCCEEDED(GetNode(dwNode, pNode)) )
         return hr;

      if ( pNode->dwFlags & TOC_HAS_UNTYPED )
         break;

      if ( (pSS = m_pCollection->m_pSubSets->GetTocSubset()) && pSS->m_bIsEntireCollection )
         break;

      if ( pNode->dwFlags & TOC_FOLDER )
      {
         if ( m_ITCnt > 31 )
         {
            uiWidth = (((m_ITCnt / 32) + 1) * 4);
            pdwITBits = GetITBits(pNode->dwIT_Idx * uiWidth);
         }
         else
            pdwITBits = (const unsigned int *)&pNode->dwIT_Idx;
      }
      else
         pdwITBits = GetTopicITBits(pNode->dwOffsTopic);

   } while ( !m_pCollection->m_pSubSets->fTOCFilter(pdwITBits) && (dwNode = pNode->dwOffsNext) );

   if ( dwNode )
      hr = S_OK;
   return hr;
}

HRESULT CExTitle::GetNode(DWORD iNode, TOC_FOLDERNODE *pNode)
{
   BYTE* pb;
   TOC_FOLDERNODE* pLocalNode;
   HRESULT hr = E_FAIL;

   if ( !iNode )
      return hr;

   if (m_bOpen == FALSE)
   {
      if (OpenTitle() == FALSE)
    return hr;
   }
   if (!m_pTocNodes)
   {
      m_pTocNodes = new CPagedSubfile;
     if (FAILED(hr = m_pTocNodes->Open(this, txtTocIdxFile)))
     {
        delete m_pTocNodes;
        m_pTocNodes = NULL;
        return hr;
    }
   }
   if ( (pb = (BYTE*)m_pTocNodes->Offset(iNode)) )
   {
      pLocalNode = (TOC_FOLDERNODE*)pb;

      if ( pLocalNode->dwFlags & TOC_FOLDER )
    CopyMemory((PVOID)pNode, (LPCVOID)pb, sizeof(TOC_FOLDERNODE));
      else
      {
    CopyMemory((PVOID)pNode, (LPCVOID)pb, sizeof(TOC_LEAFNODE));
    pNode->dwOffsChild = 0;
      }
      hr = S_OK;
   }
   return hr;
}

// CExTitle::GetString()
//
const CHAR* CExTitle::GetString( DWORD dwOffset )
{
  HRESULT hr;
  const CHAR* pStr;

  if( !m_bOpen )
    if( !OpenTitle() )
      return NULL;

  if( !m_pStrTbl ) {
    m_pStrTbl = new CPagedSubfile;
    if( FAILED(hr = m_pStrTbl->Open(this,txtStringsFile)) ) {
      delete m_pStrTbl;
      m_pStrTbl = NULL;
      return NULL;
    }
  }

  pStr = (const CHAR*) m_pStrTbl->Offset( dwOffset );

  return pStr;
}


// CExTitle::GetString()
//
HRESULT CExTitle::GetString( DWORD dwOffset, CHAR* psz, int cb )
{
  const CHAR* pStr = GetString( dwOffset );

  if( pStr ) {
    strncpy( psz, pStr, cb );
    psz[cb-1] = 0;

    return S_OK;
  }
  else
    return E_FAIL;
}

// CExTitle::GetString()
//
HRESULT CExTitle::GetString( DWORD dwOffset, CStr* pcsz )
{
  const CHAR* pStr = GetString( dwOffset );

  if( pStr ) {
    *pcsz = pStr;
    return S_OK;
  }
  else
    return E_FAIL;
}

// CExTitle::GetString()
//
HRESULT CExTitle::GetString( DWORD dwOffset, WCHAR* pwsz, int cch )
{
  const CHAR* pStr = GetString( dwOffset );

  if( pStr ) {
    MultiByteToWideChar( GetInfo()->GetCodePage(), 0, pStr, -1, pwsz, cch );
    return S_OK;
  }
  else
    return E_FAIL;
}

// CExTitle::GetString()
//
HRESULT CExTitle::GetString( DWORD dwOffset, CWStr* pcwsz )
{
  const CHAR* pStr = GetString( dwOffset );

  if( pStr ) {
    MultiByteToWideChar( GetInfo()->GetCodePage(), 0, pStr, -1, *pcwsz, -1 );
    return S_OK;
  }
  else
    return E_FAIL;
}


//
// CExTitle::InfoTypeFilter()
//
// Function determines if the given topic id (topic number) is part of the currently
// selected InfoType profile.
//
// ENTRY:
//   dwTopic - Topic number.
//
// EXIT:
//   BOOL - TRUE if topic is part of currently selected infotype profile. FALSE if not.
//
BOOL CExTitle::InfoTypeFilter(CSubSet* pSubSet, DWORD dwTopic)
{
   const unsigned int *pdwITBits;

   if (m_bOpen == FALSE)
   {
      if (OpenTitle() == FALSE)
         return FALSE;
   }
   pdwITBits = GetTopicITBits(dwTopic);
   return pSubSet->Filter(pdwITBits);
}

//
// Given a topic number, fetch and return a pointer to the itbits
// in the form of a DWORD*
//
const unsigned int * CExTitle::GetTopicITBits(DWORD dwTN)
{
   TOC_TOPIC TopicData;
   unsigned int uiWidth;
   static unsigned int dwITBits;

   GetTopicData(dwTN, &TopicData);
   if ( m_ITCnt > 15 )
   {
     uiWidth = (((m_ITCnt / 32) + 1) * 4);
     return (GetITBits(TopicData.wIT_Idx * uiWidth));
   }
   else
   {
      dwITBits = 0;
      dwITBits = TopicData.wIT_Idx;
      return &dwITBits;
   }
}

//
// Given an offset into the ITBITS subfile, fetch and return a pointer to the itbits
// in the form of a DWORD*
//
const unsigned int * CExTitle::GetITBits(DWORD dwOffsBits)
{
   if (! m_pITBits )
   {
      m_pITBits = new CPagedSubfile;
      if (FAILED(m_pITBits->Open(this, txtITBits)))
      {
         delete m_pITBits;
         m_pITBits = NULL;
         return NULL;
     }
   }
   //
   // Compute the width in DWORDS and get the bits.
   //
   return (const unsigned int *)m_pITBits->Offset(dwOffsBits);
}

// CExTitle::GetTopicData()
//
HRESULT CExTitle::GetTopicData(DWORD dwTopic, TOC_TOPIC * pTopicData)
{
   HRESULT hr;
   BYTE * pb;

   if (m_bOpen == FALSE)
   {
      if (OpenTitle() == FALSE)
    return E_FAIL;
   }
   if (!m_pTopics)
   {
      m_pTopics = new CPagedSubfile;
      if (FAILED(hr = m_pTopics->Open(this, txtTopicsFile)))
      {
            delete m_pTopics;
            m_pTopics = NULL;
            return hr;
        }
   }
   pb = (BYTE*)m_pTopics->Offset(dwTopic * sizeof(TOC_TOPIC));
   if (pb)
   {
      memcpy(pTopicData, pb, sizeof(TOC_TOPIC));
      return S_OK;
   }
   else
      return E_FAIL;
}

HRESULT CExTitle::GetTopicName(DWORD dwTopic, CHAR* pszTitle, int cb)
{
   TOC_TOPIC topic;
   HRESULT hr;

   if (SUCCEEDED(hr = GetTopicData(dwTopic, &topic)))
      return GetString(topic.dwOffsTitle, pszTitle, cb);
   else
      return hr;
}

HRESULT CExTitle::GetTopicName(DWORD dwTopic, WCHAR* pwszTitle, int cch)
{
   TOC_TOPIC topic;
   HRESULT hr;

   if (SUCCEEDED(hr = GetTopicData(dwTopic, &topic)))
      return GetString(topic.dwOffsTitle, pwszTitle, cch);
   else
      return hr;
}

HRESULT CExTitle::GetTopicLocation(DWORD dwTopic, CHAR* pszLocation, int cb)
{
  CTitleInformation* pInfo = GetInfo();

  if( pInfo ) {
    const CHAR* psz = NULL;
    psz = pInfo->GetDefaultCaption();
    if( !psz || !*psz )
      psz = pInfo->GetShortName();
    if( psz && *psz ) {
      strncpy( pszLocation, psz, cb );
      pszLocation[cb-1] = 0;
      return S_OK;
    }
  }

  return E_FAIL;
}

HRESULT CExTitle::GetTopicLocation(DWORD dwTopic, WCHAR* pwszLocation, int cch)
{
  CTitleInformation* pInfo = GetInfo();

  if( pInfo ) {
    const CHAR* psz = NULL;
    psz = pInfo->GetDefaultCaption();
    if( !psz || !*psz )
      psz = pInfo->GetShortName();
    if( psz && *psz ) {
      MultiByteToWideChar( GetInfo()->GetCodePage(), 0, psz, -1, pwszLocation, cch );
      return S_OK;
    }
  }

  return E_FAIL;
}

//
// GetUrlTocSlot();
//
// Translates a URL from this title into it's corisponding offset into the TOC.
// Function will also return the Topic number if desired in reference pdwTopicNumber.
//
HRESULT CExTitle::GetUrlTocSlot(const CHAR* pszURL, DWORD* pdwSlot, DWORD* pdwTopicNumber)
{
   char szURL[MAX_URL];
   HRESULT hr = E_FAIL;

   strncpy( szURL, pszURL, MAX_URL );
   szURL[MAX_URL-1] = 0;

   // Remove all of the stuff from the url.
   NormalizeUrlInPlace(szURL) ;

   TOC_TOPIC Topic;
   if (SUCCEEDED(URL2Topic(szURL, &Topic, pdwTopicNumber)))
   {
      *pdwSlot = Topic.dwOffsTOC_Node;
      return S_OK;
   }

   CHAR* pszInterTopic = NULL;
   if (pszInterTopic = StrChr(szURL, '#'))
   {
     *pszInterTopic = NULL;
     if (SUCCEEDED(URL2Topic(szURL, &Topic, pdwTopicNumber)))
     {
      *pdwSlot = Topic.dwOffsTOC_Node;
      return S_OK;
     }
   }

   return E_FAIL;
}

//
// GetURLTreeNode()
//
// Translates a URL from this title into it's corisponding node in the TOC.
//
HRESULT CExTitle::GetURLTreeNode(const CHAR* pszURL, CTreeNode** ppTreeNode, BOOL bNormalize /* = TRUE */)
{
   char szURL[MAX_URL];
   HRESULT hr = E_FAIL;

   strncpy( szURL, pszURL, MAX_URL );
   szURL[MAX_URL-1] = 0;

   // Remove all of the stuff from the url.
   if (bNormalize)
	   NormalizeUrlInPlace(szURL) ;

   TOC_TOPIC Topic;
   if (SUCCEEDED(URL2Topic(szURL, &Topic)))
   {
      TOC_FOLDERNODE Node;
      if (SUCCEEDED(GetNode(Topic.dwOffsTOC_Node, &Node)))
      {
         *ppTreeNode = new CExNode(&Node, this);
         hr = S_OK;
      }
   }
   return hr;
}

//
// Slot2TreeNode(DWORD dwSlot)
//
// Returns a tree node given a TOC "slot" number. A slot number is just the
// offset into the #TOCIDX subfile.
//
HRESULT CExTitle::Slot2TreeNode(DWORD dwSlot, CTreeNode** ppTreeNode)
{
   TOC_FOLDERNODE Node;
   if ( !IsBadReadPtr(this, sizeof(CExTitle)) && SUCCEEDED(GetNode(dwSlot, &Node)))
   {
//      *ppTreeNode = new CExNode(&Node, this, dwSlot);
      *ppTreeNode = new CExNode(&Node, this);
      return S_OK;
   }
   return E_FAIL;
}

HRESULT CExTitle::GetTopicURL(DWORD dwTopic, CHAR* pszURL, int cb, BOOL bFull )
{
    TOC_TOPIC topic;
    HRESULT hr;
    CExTitle* pTitle;
    CHAR* psz;

    if (m_bOpen == FALSE)
    {
        if (OpenTitle() == FALSE)
            return E_FAIL;
    }
    if (!m_pUrlTbl)
    {
        m_pUrlTbl = new CPagedSubfile;
        if (FAILED(hr = m_pUrlTbl->Open(this, txtUrlTblFile)))
        {
            delete m_pUrlTbl;
            m_pUrlTbl = NULL;
            return hr;
        }
    }
    if (!m_pUrlStrings)
    {
        m_pUrlStrings = new CPagedSubfile;
        if (FAILED(hr = m_pUrlStrings->Open(this, txtUrlStrFile)))
        {
            delete m_pUrlStrings;
            m_pUrlStrings = NULL;
            return hr;
        }
    }
    if ( (hr = GetTopicData(dwTopic, &topic)) == S_OK )
    {
        PCURL pUrlTbl;
        if ( (pUrlTbl = (PCURL)m_pUrlTbl->Offset(topic.dwOffsURL)) )
        {
            PURLSTR purl = (PURLSTR) m_pUrlStrings->Offset(pUrlTbl->dwOffsURL);
            if (purl)
            {
                // If not an interfile jump, the create the full URL
                //
                if (! StrChr(purl->szURL, ':'))
                {
                    /*
                     * 22-Oct-1997  [ralphw] ASSERT on this rather then
                     * checking in retail, because if the caller is using
                     * MAX_URL or INTERNET_MAX_URL_LENGTH then an overflow
                     * will never happen.
                     */
                    pTitle = this;
                    psz = purl->szURL;
qualify:
                    ASSERT((strlen(psz) + strlen((g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore)) + strlen(pTitle->GetPathName()) + 7) < (size_t) cb);
                    if ((int) (strlen(psz) + strlen((g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore)) + strlen(pTitle->GetPathName()) + 7) > cb )
                       return E_OUTOFMEMORY;
                    strncpy(pszURL, (g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore), cb);
                    pszURL[cb-1] = 0;
                    if( bFull )
                      strcat(pszURL, pTitle->GetPathName());
                    else
                      strcat(pszURL, pTitle->GetFileName());
                    if (*psz != '/')
                        strcat(pszURL, txtSepBack);
                    else
                        strcat(pszURL, txtDoubleColonSep);
                    strcat(pszURL, psz);
                }
                else
                {
                   // Check for a URL of this type: vb98.chm::\foo\bar\cat.htm
                   //
                   if ( psz = StrStr(purl->szURL, txtChmColon) )
                   {
                      psz += 4;
                      *psz = '\0';
                      pTitle = m_pCollection->TitleFromChmName(purl->szURL);
                      *psz = ':';
                      if ( pTitle )
                      {
                         psz += 2;
                         goto qualify;
                      }
                   }
                   // BUGBUG: we do the check here to see if the CHM exists,
                   // and if not, switch to the alternate URL (if there is one).

                   strncpy(pszURL, purl->szURL, cb);
                   pszURL[cb-1] = 0;
                }
                hr = S_OK;
            }
        }
    }
    return hr;
}

//
//
//
// we now have to support a new URL format for compiled files.  The format is:
//
//  mk:@MSITStore:mytitle.chm::/dir/mytopic.htm
//
// where "mk:@MSITStore:" can take any one of the many forms of our URL
// prefix and it may be optional.  The "mytitle.chm" substring may or
// may not be a full pathname to the title.  The remaining part is simply
// the pathname inside of the compiled title.
//
// When the URL is in the format, we need to change it to the fully
// qualified URL format which is:
//
//  mk:@MSITStore:c:\titles\mytitle.chm::/dir/mytopic.htm
//
HRESULT CExTitle::ConvertURL( const CHAR* pszURLIn, CHAR* pszURLOut )
{
  HRESULT hr = S_OK;

  // prefix
  if( IsSamePrefix(pszURLIn, txtMkStore, (int)strlen(txtMkStore) - 1) )
    strcpy( pszURLOut, txtMkStore );
  else if( IsSamePrefix(pszURLIn, txtMsItsMoniker, (int)strlen(txtMsItsMoniker) - 1) )
    strcpy( pszURLOut, txtMsItsMoniker );
  else if( IsSamePrefix(pszURLIn, txtItsMoniker, (int)strlen(txtItsMoniker) - 1) )
    strcpy( pszURLOut, txtItsMoniker );
  else {
    strcpy( pszURLOut, pszURLIn );
    return hr;
  }

  // title full pathname
  CStr szPathName;
  ConvertSpacesToEscapes( m_ContentFileName.psz, &szPathName );
  strcat( pszURLOut, szPathName.psz );

  // subfile pathname
  char* pszTail = strstr( pszURLIn, "::" );
  if( pszTail )
    strcat( pszURLOut, pszTail );
  else
    strcpy( pszURLOut, pszURLIn );

  return hr;
}

// CExTitle::URL2TopicNumber
//
//          Translate a URL into a topic number.
//
HRESULT CExTitle::URL2Topic(const CHAR* pszURL, TOC_TOPIC* pTopic, DWORD* pdwTN)
{
   static int iPageCnt = (PAGE_SIZE / sizeof(CURL));
   DWORD dwOffs;
   HRESULT hr = E_FAIL;
   HASH dwHash;
   PCURL pCurl;
   int mid,low = 0;

   if (m_bOpen == FALSE)
   {
       if (OpenTitle() == FALSE)
           return E_FAIL;
   }
   //[ZERO IDXHDR]
   if (!IsIdxHeaderValid())
   {
      return E_FAIL;
   }
   int high = m_pIdxHeader->cTopics - 1;

   if (!m_pUrlTbl)
   {
        m_pUrlTbl = new CPagedSubfile;
        if (FAILED(hr = m_pUrlTbl->Open(this,txtUrlTblFile)))
        {
            delete m_pUrlTbl;
            m_pUrlTbl = NULL;
            return hr;
         }
   }
   //
   // Hash it and find it!
   dwHash = HashFromSz(pszURL);
   while ( low <= high )
   {
     mid = ((low + high) / 2);
     dwOffs = (((mid / iPageCnt) * PAGE_SIZE) + ((mid % iPageCnt) * sizeof(CURL)));
     if (! (pCurl = (PCURL)m_pUrlTbl->Offset(dwOffs)) )   // Read the data in.
        return hr;
     if ( pCurl->dwHash == dwHash )
     {
        if ( pdwTN )
        {
           *pdwTN = pCurl->dwTopicNumber;
           hr = S_OK ; // This part succeeded. we may fail the GetTopicData below.
        }

        if ( pTopic )                     // Found it!
           hr = GetTopicData(pCurl->dwTopicNumber, pTopic);
        break;
     }
     else if ( pCurl->dwHash > dwHash )
        high = mid - 1;
     else
        low = mid + 1;
   }
   return hr;
}

////////////////////////////////////////////////////////
// GetVolumeOrder
//
// returned value in puiVolumeOrder is:
//  0   = local drive
//  1-N = Removable media order (CD1, CD2, etc.)
//  -1  = error

HRESULT CExTitle::GetVolumeOrder( UINT* puiVolumeOrder, UINT uiFileType )
{
  HRESULT hr = S_OK;

  if( m_uiVolumeOrder == (UINT) -1 ) {

    if( m_pCollection->IsSingleTitle() )
      return E_FAIL;

    // Get the location information
    LOCATIONHISTORY* pLocationHistory = GetUsedLocation();

    // Get the pathname
    const CHAR* pszPathname = NULL;
    if( uiFileType == HHRMS_TYPE_TITLE )
      pszPathname = GetPathName();
    else if( uiFileType == HHRMS_TYPE_COMBINED_QUERY )
      pszPathname = GetQueryName();
    else
      return E_FAIL;

    // Get the location identifier
    const CHAR* pszLocation = NULL;
    CLocation* pLocation = NULL;
    if( pLocationHistory ) {
      pszLocation = pLocationHistory->LocationId;
      pLocation = m_pCollection->m_Collection.FindLocation( pszLocation, puiVolumeOrder );
      m_uiVolumeOrder = *puiVolumeOrder;
    }

    // Get the location path
    const CHAR* pszPath = NULL;
    CHAR szPath[MAX_PATH];
    szPath[0]= 0;
    if( pLocation ) {
      pszPath = pLocation->GetPath();
      strcpy( szPath, pszPath );
    }

    // get the drive of the path
    CHAR szDriveRoot[4];
    strncpy( szDriveRoot, szPath, 4 );
    szDriveRoot[3] = '\0';

    // make sure to add a backslash if the second char is a colon
    // sometimes we will get just "d:" instead of "d:\" and thus
    // GetDriveType will fail under this circumstance
    if( szDriveRoot[1] == ':' ) {
      szDriveRoot[2] = '\\';
      szDriveRoot[3] = 0;
    }

    // Get media type
    UINT uiDriveType = DRIVE_UNKNOWN;
    if( szDriveRoot[1] == ':' && szDriveRoot[2] == '\\' ) {
      uiDriveType = GetDriveType(szDriveRoot);
    }
    else if( szDriveRoot[0] == '\\' && szDriveRoot[1] == '\\' ) {
      uiDriveType = DRIVE_REMOTE;
    }

    // handle the drive types
    switch( uiDriveType ) {

      case DRIVE_REMOTE:
      case DRIVE_FIXED:
      case DRIVE_RAMDISK:
        m_uiVolumeOrder = 0;
        break;

      case DRIVE_REMOVABLE:
      case DRIVE_CDROM:
        //m_uiVolumeOrder = 1; // set to one for now
        break;

      case DRIVE_UNKNOWN:
      case DRIVE_NO_ROOT_DIR:
        return E_FAIL;
        break;

      default:
        return E_FAIL;

    }

  }

  *puiVolumeOrder = m_uiVolumeOrder;

  if( m_uiVolumeOrder == (UINT) -1 )
    hr = E_FAIL;

  return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Translate a ContextID into a URL.
//
//
HRESULT CExTitle::ResolveContextId(DWORD id, CHAR** ppszURL)
{
   CSubFileSystem* pCSubFS;
   int cbMapIds, cbRead;

   if (!m_bOpen)
   {
      if (OpenTitle() == FALSE)
         return E_FAIL;
   }
   if ( !m_pMapIds )
   {
      pCSubFS = new CSubFileSystem(m_pCFileSystem);
      if(FAILED(pCSubFS->OpenSub(txtMAP)))
      {
          delete pCSubFS;
          return HH_E_NOCONTEXTIDS;
      }
      if ( (pCSubFS->ReadSub(&cbMapIds, sizeof(DWORD), (ULONG*)&cbRead) != S_OK) || (cbRead != sizeof(DWORD)) )
      {
          delete pCSubFS;
          return HH_E_NOCONTEXTIDS;
      }
      if (! (m_pMapIds = (MAPPED_ID*)lcMalloc(cbMapIds)) )
      {
          delete pCSubFS;
          return E_FAIL;
      }
      if ( (pCSubFS->ReadSub(m_pMapIds, cbMapIds, (ULONG*)&cbRead) != S_OK) || (cbRead != cbMapIds) )
      {
         delete pCSubFS;
         lcFree(m_pMapIds);
         m_pMapIds = NULL;
         return HH_E_NOCONTEXTIDS;
      }
      m_cMapIds = cbMapIds / sizeof(MAPPED_ID);
   }
   //
   // Translate the id into a URL...
   //
   for (int i = 0; i < m_cMapIds; i++)
   {
      if ( id == m_pMapIds[i].idTopic )
      {
         *ppszURL = (CHAR*)GetString(m_pMapIds[i].offUrl);
         return S_OK;
      }
   }
   return HH_E_CONTEXTIDDOESNTEXIT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CTreeNode implementation

CTreeNode::CTreeNode()
{
   m_Expanded = FALSE;
   SetError(0);
}

CTreeNode::~CTreeNode()
{

}

BOOL CTreeNode::Compare(CTreeNode *pOtherNode)
{
   if (m_ObjType != pOtherNode->GetObjType())
      return FALSE;

   switch (m_ObjType)
   {
      case EXFOLDERNODE:
    if (((CExFolderNode *)this)->GetFolder() == ((CExFolderNode *)pOtherNode)->GetFolder())
       return TRUE;
    return FALSE;
      case EXTITLENODE:
    if (((CExTitleNode *)this)->GetFolder() == ((CExTitleNode *)pOtherNode)->GetFolder() &&
       ((CExTitleNode *)this)->GetTitle() == ((CExTitleNode *)pOtherNode)->GetTitle())
       return TRUE;
    return FALSE;
      case EXNODE:
      case EXMERGEDNODE:
    CExTitle *p1, *p2;
    p1 = ((CExNode *)this)->GetTitle();
    p2 =((CExNode *)pOtherNode)->GetTitle();
    if (p1 == p2 &&
       ((CExNode *)this)->m_Node.dwFlags == ((CExNode *)pOtherNode)->m_Node.dwFlags &&
       ((CExNode *)this)->m_Node.dwOffsTopic == ((CExNode *)pOtherNode)->m_Node.dwOffsTopic &&
       ((CExNode *)this)->m_Node.dwOffsParent == ((CExNode *)pOtherNode)->m_Node.dwOffsParent &&
       ((CExNode *)this)->m_Node.dwOffsNext == ((CExNode *)pOtherNode)->m_Node.dwOffsNext &&
       ((CExNode *)this)->m_Node.dwOffsChild == ((CExNode *)pOtherNode)->m_Node.dwOffsChild)
          return TRUE;
    return FALSE;
   }
   return FALSE;
}

CTreeNode *CTreeNode::GetExNode(TOC_FOLDERNODE *pNode, CExTitle *pTitle)
{
   if (pNode->dwFlags & TOC_MERGED_REF)
   {
      // read chm file from string file
      CStr cStr;
      if (SUCCEEDED(pTitle->GetString(pNode->dwOffsChild, &cStr)))
      {
         // search title list
         CExTitle *pCur = pTitle->m_pCollection->GetFirstTitle();
         while (pCur)
         {
            if (strcmp(cStr, FindFilePortion(pCur->GetPathName())) == 0)
            {
               CExMergedTitleNode *pT;
               pT = new CExMergedTitleNode(pNode, pCur);
               if (pT != NULL)
                  return pT;
            }
            pCur = pCur->GetNext();
         }
      }
      return GetNextSibling(pNode);
   }
   else
   {
      CExNode *p = new CExNode(pNode, pTitle);
      if (p == NULL)
         return GetNextSibling(pNode);
      return p;
   }
}

void CTreeNode::SetError(DWORD dw)
{
   m_Error = dw;
}

DWORD CTreeNode::GetLastError()
{
   return m_Error;
}

BOOL CTreeNode::GetURL(CHAR* pszURL, unsigned cb, BOOL bFull)
{
   return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CExFolderNode  implementation
CExFolderNode::CExFolderNode(CFolder *p, CExCollection *pCollection)
{
   SetObjType(EXFOLDERNODE);
   m_pCollection = pCollection;
   m_pFolder = p;
}

CExFolderNode::~CExFolderNode()
{

}

CTreeNode *CExFolderNode::GetFirstChild(DWORD* pdwSlot)
{
   CStructuralSubset* pSS = NULL;
   CFolder *p = m_pFolder->GetFirstChildFolder();
   CTreeNode *pN;

   // implement structural subsetting here.
   if( m_pCollection && m_pCollection->m_pSSList )
      pSS = m_pCollection->m_pSSList->GetTOC();

   while (p)
   {
      if ((pN = m_pCollection->CheckForTitleNode(p)))
      {
         if ( !pSS || pSS->IsEntire() || p->bIsVisable() )
            return pN;
         else
            delete pN; // leak fix
      }
      p = p->GetNextFolder();
   }
   return NULL;
}

CTreeNode *CExFolderNode::GetNextSibling(TOC_FOLDERNODE *pAltNode, DWORD* pdwSlot)
{
   CStructuralSubset* pSS = NULL;
   CFolder *p = m_pFolder->GetNextFolder();
   CTreeNode *pN;

   // implement structural subsetting here.
   if( m_pCollection && m_pCollection->m_pSSList )
      pSS = m_pCollection->m_pSSList->GetTOC();

   while (p)
   {
      if ((pN = m_pCollection->CheckForTitleNode(p)))
      {
         if ( !pSS || pSS->IsEntire() || p->bIsVisable() )
            return pN;
         else
            delete pN; // leak fix
      }
      p = p->GetNextFolder();
   }
   return NULL;
}

CTreeNode *CExFolderNode::GetParent(DWORD* pdwSlot, BOOL bDirectParent)
{
   CFolder *p = m_pFolder->GetParent();

   if (p->GetTitle() == NULL)
      return NULL;

   if (p)
   {
      return m_pCollection->CheckForTitleNode(p);
   }
   return NULL;
}

HRESULT CExFolderNode::GetTopicName(CHAR* pszTitle, int cb)
{
   CHAR* psz = m_pFolder->GetTitle();

   if (strlen(psz) + 1 > (size_t) cb)
      return E_FAIL;
   else
      strcpy(pszTitle, psz);

   return S_OK;
}

HRESULT CExFolderNode::GetTopicName( WCHAR* pwszTitle, int cch )
{
   CHAR* psz = m_pFolder->GetTitle();

   if( (2*(strlen(psz) + 1)) > (size_t) cch )
      return E_FAIL;
   else {
      UINT CodePage = m_pCollection->GetMasterTitle()->GetInfo()->GetCodePage();
      MultiByteToWideChar( CodePage, 0, psz, -1, pwszTitle, cch );
   }

   return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CExTitleNode implementation
CExTitleNode::CExTitleNode(CExTitle *pTitle, CFolder *p)
{
   SetObjType(EXTITLENODE);
   m_pTitle = pTitle;
   m_pFolder = p;
}

#if 0
CExTitleNode::~CExTitleNode()
{

}
#endif

CTreeNode * CExTitleNode::GetFirstChild(DWORD* pdwSlot)
{
   TOC_FOLDERNODE Node;

   if ( !SUCCEEDED(m_pTitle->GetRootNode(&Node)) )
      return NULL;

   if ( pdwSlot )
      *pdwSlot = m_pTitle->GetRootSlot();

   return GetExNode(&Node, m_pTitle);
}

CTreeNode * CExTitleNode::GetNextSibling(TOC_FOLDERNODE *pAltNode, DWORD* pdwSlot)
{
   CTreeNode *pN;
   CStructuralSubset* pSS = NULL;

   if (m_pFolder == NULL)
      return NULL;

   CFolder *p = m_pFolder->GetNextFolder();

   // implement structural subsetting here.
   if(  m_pTitle && m_pTitle->m_pCollection && m_pTitle->m_pCollection->m_pSSList )
      pSS = m_pTitle->m_pCollection->m_pSSList->GetTOC();

   while (p)
   {
      if ((pN = m_pTitle->m_pCollection->CheckForTitleNode(p)))
      {
         if ( !pSS || pSS->IsEntire() || p->bIsVisable() )
            return pN;
         else
            delete pN; // leak fix
      }
      p = p->GetNextFolder();
   }
   return NULL;
}

CTreeNode * CExTitleNode::GetParent(DWORD* pdwSlot, BOOL bDirectParent)
{
   CFolder *p = m_pFolder->GetParent();

   if (p->GetTitle() == NULL)
      return NULL;

   if (p)
   {
      return m_pTitle->m_pCollection->CheckForTitleNode(p);
   }
   return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CExMergedTitleNode implementation

CExMergedTitleNode::CExMergedTitleNode(TOC_FOLDERNODE *p, CExTitle *pTitle) : CExNode(p, pTitle)
{
   SetObjType(EXMERGEDNODE);
}

CExMergedTitleNode::~CExMergedTitleNode()
{

}

CTreeNode * CExMergedTitleNode::GetFirstChild(DWORD* pdwSlot)
{
   TOC_FOLDERNODE Node;

   if (FAILED(GetTitle()->GetRootNode(&Node)))
      return NULL;

   return GetExNode(&Node, GetTitle());
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CExNode implementation
CExNode::CExNode(TOC_FOLDERNODE *p, CExTitle *pTitle)
{
   SetObjType(EXNODE);
   if (p)
      memcpy(&m_Node, p, sizeof(TOC_FOLDERNODE));
   m_pTitle = pTitle;
}

#if 0
CExNode::~CExNode()
{

}
#endif

DWORD CExNode::GetType()
{
   if ( (m_Node.dwFlags & TOC_FOLDER) )
   {
      if ( (m_Node.dwFlags & TOC_TOPIC_NODE) )
    return CONTAINER; // Topic Folder.
      else
      {
    if ( m_Node.dwOffsChild )
       return FOLDER;
    else
       return BOGUS_FOLDER;
      }
   } // Folder Only.
   return TOPIC;  // Topic Only.
}

HRESULT CExNode::GetTopicName(CHAR* pszTitle, int cb)
{
   HRESULT hr = S_OK;

   if (! (m_Node.dwFlags & TOC_TOPIC_NODE) )
      hr |= m_pTitle->GetString(m_Node.dwOffsTopic, pszTitle, cb);
   else
      hr |= m_pTitle->GetTopicName(m_Node.dwOffsTopic, pszTitle, cb);

   return hr;
}

HRESULT CExNode::GetTopicName( WCHAR* pwszTitle, int cch )
{
   HRESULT hr = S_OK;

   if (! (m_Node.dwFlags & TOC_TOPIC_NODE) )
      hr |= m_pTitle->GetString(m_Node.dwOffsTopic, pwszTitle, cch);
   else
      hr |= m_pTitle->GetTopicName(m_Node.dwOffsTopic, pwszTitle, cch);

   return hr;
}

CTreeNode *CExNode::GetFirstChild(DWORD* pdwSlot)
{
   unsigned int uiWidth;
   const unsigned int *pdwITBits;
   DWORD dwOffsChild;
   CSubSet* pSS;

   if (m_Node.dwFlags & TOC_HAS_CHILDREN)
   {
      TOC_FOLDERNODE Node;
      dwOffsChild = m_Node.dwOffsChild;

      do
      {
         if ( !SUCCEEDED(m_pTitle->GetNode(dwOffsChild, &Node)) )
            return NULL;

         if ( Node.dwFlags & TOC_HAS_UNTYPED )
            break;

         if ( (pSS = m_pTitle->m_pCollection->m_pSubSets->GetTocSubset()) && pSS->m_bIsEntireCollection )
            break;

         if ( Node.dwFlags & TOC_FOLDER )
         {
            if ( m_pTitle->m_ITCnt > 31 )
            {
               uiWidth = (((m_pTitle->m_ITCnt / 32) + 1) * 4);
               pdwITBits = m_pTitle->GetITBits(Node.dwIT_Idx * uiWidth);
            }
            else
               pdwITBits = (const unsigned int *)&Node.dwIT_Idx;
         }
         else
            pdwITBits = m_pTitle->GetTopicITBits(Node.dwOffsTopic);
      } while ( !m_pTitle->m_pCollection->m_pSubSets->fTOCFilter(pdwITBits) && (dwOffsChild = Node.dwOffsNext) );

      if ( dwOffsChild )
      {
         if ( pdwSlot )
            *pdwSlot = dwOffsChild;
         return GetExNode(&Node, m_pTitle);
      }
   }
   return NULL;
}

CTreeNode *CExNode::GetNextSibling(TOC_FOLDERNODE *pAltNode, DWORD* pdwSlot)
{
   TOC_FOLDERNODE Node;
   DWORD dwNext = (pAltNode ? pAltNode->dwOffsNext : m_Node.dwOffsNext);
   unsigned int uiWidth;
   const unsigned int *pdwITBits;
   CSubSet* pSS;

   do
   {
      if ( !SUCCEEDED(m_pTitle->GetNode(dwNext, &Node)) )
         return NULL;

      if ( Node.dwFlags & TOC_HAS_UNTYPED )
         break;

      if ( (pSS = m_pTitle->m_pCollection->m_pSubSets->GetTocSubset()) && pSS->m_bIsEntireCollection )
         break;
      if ( Node.dwFlags & TOC_FOLDER )
      {
         if ( m_pTitle->m_ITCnt > 31 )
         {
            uiWidth = (((m_pTitle->m_ITCnt / 32) + 1) * 4);
            pdwITBits = m_pTitle->GetITBits(Node.dwIT_Idx * uiWidth);
         }
         else
            pdwITBits = (const unsigned int *)&Node.dwIT_Idx;
      }
      else
         pdwITBits = m_pTitle->GetTopicITBits(Node.dwOffsTopic);
   } while ( !m_pTitle->m_pCollection->m_pSubSets->fTOCFilter(pdwITBits) && (dwNext = Node.dwOffsNext) );

   if ( dwNext )
   {
      if ( pdwSlot )
         *pdwSlot = dwNext;
      return GetExNode(&Node, m_pTitle);
   }
   return NULL;
}

CTreeNode *CExNode::GetParent(DWORD* pdwSlot, BOOL bDirectParent)
{
   TOC_FOLDERNODE Node;

    if (m_Node.dwOffsParent)
    {
        if ( !SUCCEEDED(m_pTitle->GetNode(m_Node.dwOffsParent, &Node)) )
            return NULL;
        if ( pdwSlot )
           *pdwSlot = m_Node.dwOffsParent;
        return GetExNode(&Node, m_pTitle);
    }
    else
    {
        // check if this is a merged title
        if (m_pTitle->GetNodeOffsetInParentTitle())
        {
            // assume that the first title in the collection is the master title
            CExTitle * pParent;

            pParent = m_pTitle->m_pCollection->GetFirstTitle();

            if (!pParent)
                return NULL;

            if ( !SUCCEEDED(pParent->GetNode(m_pTitle->GetNodeOffsetInParentTitle(), &Node)) )
                return NULL;
            if ( pdwSlot )
               *pdwSlot = m_pTitle->GetNodeOffsetInParentTitle();
            return GetExNode(&Node, pParent);
        }
        else
        {
             // is this a collection
            if (m_pTitle->m_pCollection->IsSingleTitle() == FALSE)
            {

               CFolder *p = m_pTitle->m_pCollection->FindTitleFolder(m_pTitle);

               if (!p)
                  return NULL;

                CTreeNode *pTitle;
                if (pTitle = m_pTitle->m_pCollection->CheckForTitleNode(p))
                {
                    if (bDirectParent == TRUE)
                        return pTitle;
                    CTreeNode *p = pTitle->GetParent(pdwSlot);
                    delete pTitle;
                    return p;
                }
            }
        }
    }
   return NULL;
}

BOOL CExNode::GetURL(CHAR* pszURL, unsigned cb, BOOL bFull)
{
   if ( (m_Node.dwFlags & TOC_TOPIC_NODE) )
      if ( SUCCEEDED(m_pTitle->GetTopicURL(m_Node.dwOffsTopic, pszURL, cb, bFull)) )
    return TRUE;
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\toc.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

//*********************************************************************************************************************************************
//
// File: toc.h
//  Author: Donald Drake
//  Purpose: Defines classes to support populating the table of contents

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _TOC_H
#define _TOC_H
#include "cinfotyp.h"
#include "system.h"
#include "collect.h"
#include "hhtypes.h"
#include "fs.h"
#include "subfile.h"
#include "state.h"

#include "csubset.h"
//#include "subset.h"      // Structural subsets
#include "hhfinder.h"

#define MAX_OPEN_TITLES 25

//#define DUMPTOC  1
#ifdef  DUMPTOC
#include <stdio.h>
#endif

// Persist keys. Declared in toc.cpp
//
extern const char g_szFTSKey[];
extern const char g_szIndexKey[];
extern const char g_szTOCKey[];

class CExTitle;
class CExFolderNode;
class CExTitleNode;
class CExMergedTitleNode;
class CExNode;
class CTreeNode;
class CFullTextSearch;
class CTitleFTS;
class CSearchHighlight;
class CPagedSubfile;
class CTitleDatabase;
class CSSList;

extern CExCollection* g_pCurrentCollection;

//[ZERO IDXHDR] The IDX Header subfile may be zero length, because some early version of HHCTRL
// didn't write it out. We need to make sure that we have an IDX header before we try to use it.
// If we don't we will crash.
#define IDXHEADER_UNINITIALIZED  (0xFFFFFFFF)

//class CExTitle: public CSubfileGroupList
class CExTitle SI_COUNT(CExTitle)
{
   friend class CPagedSubfile;

public:
   void _CExTitle();
   CExTitle(CTitle* p, DWORD ColNo, CExCollection* pCollection);
   CExTitle(const CHAR* pszFileName, CExCollection* pCollection);
   ~CExTitle();

   inline BOOL Init() { int bReturn = TRUE; if( !isOpen() ) bReturn = OpenTitle(); return bReturn; }
   inline CTitleInformation* GetInfo() { if( Init() ) return m_pInfo; else return NULL; }
   inline CTitleInformation2* GetInfo2() { return m_pInfo2; }
   inline BOOL isOpen(void) { return m_bOpen; }
   inline CFileSystem* GetTitleIdxFileSystem(void) { if(!m_bOpen) OpenTitle(); return m_pCFileSystem; }
   inline void SetNodeOffsetInParentTitle(DWORD dw) { m_dwNodeOffsetInParentTitle = dw;}
   inline DWORD GetNodeOffsetInParentTitle() { return m_dwNodeOffsetInParentTitle; }
   inline CExTitle* GetNext() { return m_pNext; }
   inline void SetNext(CExTitle* p) { m_pNext = p; }

   IDXHEADER* GetIdxHeaderStruct() { ASSERT(IsIdxHeaderValid()); return m_pIdxHeader;}
   DWORD GetTopicCount() { ASSERT(IsIdxHeaderValid()); return m_pIdxHeader->cTopics;}
   BOOL  IsIdxHeaderValid() { if(m_pIdxHeader) return (BOOL)m_pIdxHeader->cTopics; else return FALSE; }
   CTitle*  GetCTitle() { return m_pTitle; }
   CFileSystem* GetFileSystem(void) { return m_pCFileSystem; }
   LOCATIONHISTORY* GetUsedLocation() { return m_pUsedLocation; }
   BOOL isChiFile(void) { return m_fIsChiFile; }

   const unsigned int* GetITBits(DWORD dwOffsBits);
   BOOL OpenTitle();
   void CloseTitle();
   BOOL exOpenFile(const CHAR* pszContent, const CHAR* pszIndex = NULL);
   BOOL InfoTypeFilter(CSubSet* pSubSet, DWORD dwTopic);

   const unsigned int* GetTopicITBits(DWORD dwTN);

   HRESULT GetRootNode(TOC_FOLDERNODE* pNode);
   DWORD   GetRootSlot(void);
   HRESULT GetNode(DWORD iNode, TOC_FOLDERNODE* pNode);
   const CHAR* GetFileName();
   const CHAR* GetPathName();
   const CHAR* GetQueryName();
   const CHAR* GetIndexFileName();
   const CHAR* GetCurrentAttachmentName();
   const CHAR* SetCurrentAttachmentName( const CHAR* pszAttachmentPathName );

   HRESULT GetTopicName( DWORD dwTopic, CHAR* pszTitle, int cb );
   HRESULT GetTopicName( DWORD dwTopic, WCHAR* pwszTitle, int cch );

   HRESULT GetTopicLocation(DWORD dwTopic, CHAR* pszLocation, int cb);
   HRESULT GetTopicLocation(DWORD dwTopic, WCHAR* pwszLocation, int cch);

   HRESULT GetUrlTocSlot(const CHAR* pszURL, DWORD* pdwSlot, DWORD* pdwTopicNumber);
   HRESULT GetTopicURL(DWORD dwTopic, CHAR* pszURL, int cb, BOOL bFull = TRUE );

   const CHAR* GetString( DWORD dwOffset );
   HRESULT GetString( DWORD dwOffset, CStr* pcsz );
   HRESULT GetString( DWORD dwOffset, CHAR* psz, int cb );
   HRESULT GetString( DWORD dwOffset, CWStr* pcsz );
   HRESULT GetString( DWORD dwOffset, WCHAR* pwsz, int cb );

   HRESULT GetURLTreeNode(const CHAR* pszURL, CTreeNode** ppTreeNode, BOOL b = TRUE);
   HRESULT GetVolumeOrder( UINT* puiVolumeOrder, UINT uiFileType = HHRMS_TYPE_TITLE );

   HRESULT ConvertURL( const CHAR* pszURLIn, CHAR* pszURLOut );
   HRESULT Slot2TreeNode(DWORD dwSlot, CTreeNode** ppTreeNode);
   HRESULT URL2Topic(const CHAR* pszURL, TOC_TOPIC* pTopic, DWORD* pdwTN = NULL);
   BOOL    FindUsedLocation();
   BOOL    EnsureChmChiMatch( CHAR* pszChm = NULL );
   HRESULT ResolveContextId(DWORD id, CHAR** ppszURL);

   inline CStr& GetContentFileName() { return m_ContentFileName; } 

   // data members should always be private!

   CTitleFTS*     m_pTitleFTS;
   CTitle*        m_pTitle;
   CExCollection* m_pCollection;
   HASH           m_dwHash;
   int            m_ITCnt;
   //
   // Support for VB style "super chms"
   //
   CExTitle* m_pKid;
   CExTitle* m_pNextKid;
   CExTitle* m_pParent;

private:
   HRESULT GetTopicData(DWORD dwTopic, TOC_TOPIC* pTopicData);

   CStr m_ContentFileName;
   CStr m_IndexFileName;

   TOCIDX_HDR* m_pHeader; // Header of #TOCIDX system subfile.
   IDXHEADER* m_pIdxHeader; // Global header information for entire .CHM/.CHI file.
   LOCATIONHISTORY* m_pUsedLocation;
   BOOL m_bOpen;
   CExTitle* m_pNext;
   DWORD m_dwColNo;
   DWORD m_dwNodeOffsetInParentTitle;
   BOOL m_fIsChiFile;
   BOOL m_bIsValidTitle;
   BOOL m_bChiChmChecked;
   MAPPED_ID* m_pMapIds;
   int m_cMapIds;
   //
   // Tome FS object (.chm/.chi) and Cached subfile objects.
   //
   CFileSystem*   m_pCFileSystem;
   CPagedSubfile* m_pTocNodes;
   CPagedSubfile* m_pTopics;
   CPagedSubfile* m_pStrTbl;
   CPagedSubfile* m_pUrlTbl;
   CPagedSubfile* m_pUrlStrings;
   CPagedSubfile* m_pITBits;

   CTitleInformation*  m_pInfo;
   CTitleInformation2* m_pInfo2;

   UINT m_uiVolumeOrder;
   char m_szAttachmentPathName[MAX_PATH];

};

class CExCollection SI_COUNT(CExCollection)
{
public:
   CExCollection(CHmData* phmData, const CHAR* pszFile, BOOL bSingleTitle = TRUE);
   virtual ~CExCollection();

   BOOL InitCollection();
#ifdef CHIINDEX
   BOOL InitCollection( const TCHAR * FullPath, const TCHAR * szMasterChmFn );
#endif
   BOOL InitFTSKeyword();
   CHmData* m_phmData;
   DWORD GetRefedTitleCount();

   BOOL IsBinaryTOC(const CHAR* pszToc);
   void GetOpenSlot(CExTitle* p);
   CTreeNode* GetRootNode();
   CTreeNode* GetPrev(CTreeNode* pTreeNode, DWORD* pdwSlot = NULL);
   CTreeNode* GetNext(CTreeNode* pTreeNode, DWORD* pdwSlot = NULL);
   CTreeNode* GetNextTopicNode(CTreeNode* pTreeNode, DWORD* pdwSlot = NULL);
   HRESULT Sync(CPointerList* pHier, const CHAR* pszURL = NULL);
   HRESULT GetCurrentTocNode(CTreeNode** ppTreeNode) { if (m_pCurrTitle) return m_pCurrTitle->Slot2TreeNode(m_dwCurrSlot, ppTreeNode); else return E_FAIL ;}
   CExTitle* GetFirstTitle() { return m_pHeadTitles; }
   CExTitle* GetMasterTitle() { return m_pMasterTitle; }
   CExTitle* GetCurSyncExTitle() { return m_pCurrTitle; }
   CExTitle* FindTitle(const CHAR* pszId, LANGID LangId);

   // Try multiple LangIds before failing
   CExTitle* FindTitleNonExact(const CHAR* pszId, LANGID LangId);

   CLocation* FindLocation(CHAR* pszId);
   void CheckForTitleChild(CFolder* p, BOOL *pbFound);
   CTreeNode*  CheckForTitleNode(CFolder* );
   void GetMergedTitles(CExTitle* );
   BOOL IsSingleTitle() { return m_bSingleTitle; }
   CFolder* FindTitleFolder(CExTitle* pTitle);
   const CHAR* GetPathName() const {
      return m_phmData->GetCompiledFile(); }
   HRESULT URL2ExTitle(const CHAR* pszURL, CExTitle** ppTitle);

   const CHAR* GetUserCHSLocalStoragePathnameByLanguage();
   const CHAR* GetUserCHSLocalStoragePathname();
   const CHAR* GetLocalStoragePathname( const CHAR* pszExt );
   BOOL UpdateLocation( const CHAR* pszLocId, const CHAR* pszNewPath, const CHAR* pszNewVolume = NULL, const CHAR* pszNewTitle = NULL);
   void GetChildURLS(CTreeNode* pNode, CTable *pTable);
   void UpdateTopicSlot(DWORD dwSlot, DWORD dwTN, CExTitle* pTitle);
   void SetTopicSlot(DWORD dwSlot, DWORD dwTN, CExTitle* pTitle) { m_dwCurrSlot = (dwSlot ? dwSlot : m_dwCurrSlot), m_dwCurrTN = dwTN, m_pCurrTitle = pTitle ? pTitle : m_pCurrTitle; }
   CExTitle* TitleFromChmName(const CHAR* pszChmName);
   void InitStructuralSubsets(void);

   //
   // State API's
   //
   CState* GetState(void) { return m_pstate; }
   HRESULT OpenState(const CHAR* pszName, DWORD dwAccess = (STGM_READWRITE | STGM_SHARE_DENY_WRITE)) { return m_pstate->Open(pszName, dwAccess); }
   void    CloseState(void) { m_pstate->Close(); }
   HRESULT ReadState(void* pData, DWORD cb, DWORD* pcbRead) { return m_pstate->Read(pData, cb, pcbRead); }
   DWORD   WriteState(const void* pData, DWORD cb) { return m_pstate->Write(pData, cb); }

   // data members should always be private!

   CFullTextSearch* m_pFullTextSearch;
   CSearchHighlight* m_pSearchHighlight;
   CTitleDatabase* m_pDatabase;
   CSubSets *m_pSubSets;         // SubSets of information types, instantiated in system.cpp::ReadSystemFiles()
   CSSList* m_pSSList;           // List of structural subsets.
   CSlotLookupTable* m_pCSlt;    // Pointer to the slot lookup table.
   CCollection m_Collection;
   CStr m_csFile;

private:
   const CHAR* SetWordWheelPathname( const CHAR* pszWordWheelPathname );
   CTreeNode* GetLastChild(CTreeNode* pTreeNode, DWORD* pdwSlot = NULL);
   BOOL ValidateTitle(CExTitle* pExTitle, BOOL bDupCheckOnly = FALSE);

   CExTitle* m_pHeadTitles;
   CExTitle* m_pMasterTitle;
   BOOL m_bSingleTitle;
   CHAR* m_szWordWheelPathname;
   CExTitle* m_MaxOpenTitles[MAX_OPEN_TITLES];
   DWORD m_dwLastSlot;
   //
   // Topic centricity work below. !!!! Don't ever even consider relying on m_pCurrTitle for any thing !!!!
   // this is only here to make make topic centricity work more robustly.
   //
   DWORD m_dwCurrSlot;
   DWORD m_dwCurrTN;
   CExTitle* m_pCurrTitle;
   //
   // Support for persistance via hh.dat
   //
   CState* m_pstate;

#ifdef  DUMPTOC
   void DumpNode(CTreeNode**);

   FILE* m_fh;
   BOOL m_bRoot;
   DWORD m_dwLevel;
#endif

};

class CSubSet;

#define EXFOLDERNODE 1
#define EXTITLENODE 2
#define EXNODE 3
#define EXMERGEDNODE 4

class CTreeNode SI_COUNT(CTreeNode)
{
public:
   CTreeNode();
   virtual ~CTreeNode();

   BYTE GetObjType() { return m_ObjType; }
   void SetObjType(BYTE x) { m_ObjType = x; }
   virtual DWORD GetType() = 0;

   virtual HRESULT GetTopicName( CHAR* pszTitle, int cb ) = 0;
   virtual HRESULT GetTopicName( WCHAR* pwszTitle, int cch ) = 0;

   virtual CTreeNode* GetFirstChild(DWORD* pdwSlot = NULL) = 0;
   virtual CTreeNode* GetNextSibling(TOC_FOLDERNODE* pAltNode = NULL, DWORD* pdwSlot = NULL) = 0;
   virtual CTreeNode* GetParent(DWORD* pdwSlot = NULL, BOOL bDirectParent = FALSE) = 0;
   virtual BOOL HasChildren() = 0;
   inline virtual BOOL IsNew() { return FALSE; }
   virtual BOOL GetURL(CHAR* pszURL, unsigned cb, BOOL bFull = TRUE);
   DWORD GetLastError();
   CTreeNode*  GetExNode(TOC_FOLDERNODE* pNode, CExTitle* pTitle);
   BOOL Compare(CTreeNode* pOtherNode);

   // data members should always be private!

   BYTE m_Expanded;

private:
   void SetError(DWORD dw);

   BYTE m_ObjType;
   DWORD m_Error;
};

//The GetType function can return one of the follow defines:
#define VIRTUALROOT   0 // a node that contains the top level nodes of the tree, not part of the tree
#define XMLFOLDER     1 // a folder defined in the collection file
#define TITLE         2 // a title which is leaf node of the xml tree
#define FOLDER        3 // a folder defined in a title
#define CONTAINER     4 // a folder that is also a topic
#define TOPIC         5 // a topic
#define BOGUS_FOLDER  6 // a folder that is not a topic and has no kids. Bogus!

class CExFolderNode : MI_COUNT(CExFolderNode)
                    public CTreeNode
{
public:
   CExFolderNode( CFolder*, CExCollection* );
   virtual ~CExFolderNode();

   inline virtual DWORD GetType() { return XMLFOLDER; }

   virtual HRESULT GetTopicName( CHAR* pszTitle, int cb );
   virtual HRESULT GetTopicName( WCHAR* pwszTitle, int cch );

   inline virtual BOOL  HasChildren() { return TRUE; }
   virtual CTreeNode*   GetFirstChild(DWORD* pdwSlot);
   virtual CTreeNode*   GetNextSibling(TOC_FOLDERNODE* pAltNode = NULL, DWORD* pdwSlot = NULL);
   virtual CTreeNode*   GetParent(DWORD* pdwSlot = NULL, BOOL bDirectParent = FALSE);
   inline CFolder*      GetFolder() { return m_pFolder; }

private:
   CFolder* m_pFolder;
   CExCollection* m_pCollection;
};

class CExTitleNode : // MI_COUNT(CExTitleNode) 
                    public CTreeNode
{
public:
   CExTitleNode( CExTitle* , CFolder* );
   // virtual ~CExTitleNode();

   inline virtual DWORD GetType() { return TITLE; }

   inline virtual HRESULT GetTopicName( CHAR* pszTitle, int cb ) { return NULL; }
   inline virtual HRESULT GetTopicName( WCHAR* pwszTitle, int cch ) { return NULL; }

   virtual CTreeNode* GetFirstChild(DWORD* pdwSlot = NULL);
   virtual CTreeNode* GetNextSibling(TOC_FOLDERNODE* pAltNode = NULL, DWORD* pdwSlot = NULL);
   virtual CTreeNode* GetParent(DWORD* pdwSlot = NULL, BOOL bDirectParent = FALSE);
   inline virtual BOOL HasChildren() { return TRUE; }
   CExTitle* GetTitle() { return m_pTitle; }
   CFolder* GetFolder() { return m_pFolder; }

private:
   CFolder* m_pFolder;
   CExTitle* m_pTitle;
};

class CExNode : MI_COUNT(CExNode)
                public CTreeNode
{
public:
   CExNode(TOC_FOLDERNODE* p, CExTitle* pTitle);
   // virtual ~CExNode();

   virtual BOOL GetURL(CHAR* pszURL, unsigned cb, BOOL bFull = TRUE);
   virtual DWORD GetType();

   virtual HRESULT GetTopicName( CHAR* pszTitle, int cb );
   virtual HRESULT GetTopicName( WCHAR* pwszTitle, int cch );

   virtual CTreeNode* GetFirstChild(DWORD* pdwSlot = NULL);
   virtual CTreeNode* GetNextSibling(TOC_FOLDERNODE* pAltNode = NULL, DWORD* pdwSlot = NULL);
   virtual CTreeNode* GetParent(DWORD* pdwSlot = NULL, BOOL bDirectParent = FALSE);
   inline virtual BOOL HasChildren() { return m_Node.dwFlags & TOC_HAS_CHILDREN; }
   inline virtual BOOL IsNew() { return m_Node.dwFlags & TOC_NEW_NODE; }
   inline CExTitle*  GetTitle() { return m_pTitle; }

   // data members should always be private!

   TOC_FOLDERNODE m_Node;

private:
   CExTitle* m_pTitle;
};

class CExMergedTitleNode : MI_COUNT(CExMergedTitleNode)
                            public CExNode
{
public:
   CExMergedTitleNode( TOC_FOLDERNODE* pFolderNode, CExTitle* pTitle );
   virtual ~CExMergedTitleNode();

   inline virtual DWORD GetType() { return TITLE; }
   virtual CTreeNode* GetFirstChild( DWORD* pdwSlot = NULL );
};

// Helper functions

#endif // _TOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\thread.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"

static DWORD thrdID;
static HANDLE hThrd;
static HANDLE hsemThread;
static int ThreadPriority;
static THRD_COMMAND ThreadCommand;
static void* pThreadParam;

static DWORD WINAPI WorkerThread(LPVOID pParam);

BOOL ActivateThread(THRD_COMMAND cmd, void* pParam, int priority)
{
	if (!hThrd) {
		if (cmd == THRD_TERMINATE) // don't start the thread just to kill it
			return FALSE;

		if (!hsemThread)
			hsemThread = CreateSemaphore(NULL, 0, 1, NULL);
		hThrd = CreateThread(NULL, 0, &WorkerThread, NULL,
			0, &thrdID);
		if (!hThrd) {
			OOM();
			return FALSE;
		}
		SetThreadPriority(hThrd, ThreadPriority = priority);
	}

	if (g_fThreadRunning)
		return FALSE;

	if (g_fDualCPU == -1) { // haven't initialized it yet
		HKEY hkey;
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\1", 0,
				KEY_READ, &hkey) == ERROR_SUCCESS) {
			g_fDualCPU = TRUE;
			RegCloseKey(hkey);
		}
		else
			g_fDualCPU = FALSE;
	}

	// For multiple CPU's, we can use a normal priority for threads

	if (g_fDualCPU && (priority == THREAD_PRIORITY_IDLE ||
					  priority == THREAD_PRIORITY_LOWEST ||
					  priority == THREAD_PRIORITY_BELOW_NORMAL))
		priority = THREAD_PRIORITY_NORMAL;

	if (ThreadPriority != priority)
		SetThreadPriority(hThrd, ThreadPriority = priority);

	ThreadCommand = cmd;
	pThreadParam = pParam;

	g_fThreadRunning = TRUE;
	ReleaseSemaphore(hsemThread, 1, NULL);
	return TRUE;
}

/***************************************************************************

	FUNCTION:	WaitForThread

	PURPOSE:	Find out if the worker thread is running. If it is, and
				the command is anything other then THRD_ANY, then kick
				up the thread priority and wait for it to finish.

	PARAMETERS:
		cmd

	RETURNS:

	COMMENTS:

	MODIFICATION DATES:
		04-Jun-1997 [ralphw]

***************************************************************************/

BOOL WaitForThread(THRD_COMMAND cmd)
{
	if (!g_fThreadRunning)
		return TRUE;
	else if (cmd != THRD_ANY && cmd != ThreadCommand)
		return FALSE;

	// Kick the thread to a high priority, and wait for it to complete

	SetThreadPriority(hThrd, THREAD_PRIORITY_HIGHEST);

	{
		CHourGlass waitcur;
		while (g_fThreadRunning)
			Sleep(200);
	}

	SetThreadPriority(hThrd, ThreadPriority);
	return TRUE;
}

static DWORD WINAPI WorkerThread(LPVOID pParam)
{
	for (;;) {
		if (WaitForSingleObject(hsemThread, INFINITE) != WAIT_OBJECT_0)
			return (UINT) -1;

		switch (ThreadCommand) {
			case THRD_TERMINATE:
				g_fThreadRunning = FALSE;
				thrdID = 0;
				hThrd = NULL;
				ExitThread(0);
				break;
		}

		g_fThreadRunning = FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\topics.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "topics.h"
#include "strtable.h"

void CHtmlHelpControl::OnHelpTopics(void)
{
	CPropSheet cprop(GetStringResource(IDS_HELP_TOPICS),
		PSH_NOAPPLYNOW, m_hwnd);
	cprop.m_fNoCsHelp = TRUE;

	CPageContents pageContents(this);
	CPageIndex	  pageIndex(this);
	cprop.AddPage(&pageContents);
	cprop.AddPage(&pageIndex);

	ModalDialog(TRUE);
	cprop.DoModal();
	ModalDialog(FALSE);
}

BOOL CPageContents::OnBeginOrEnd()
{
	return TRUE;
}

BOOL CPageIndex::OnBeginOrEnd()
{
	if (m_fInitializing) {
		BEGIN_MSG_LIST()
			ON_CDLG_MSG(LBN_DBLCLK,    IDC_LIST, OnDblClick)
			ON_CDLG_MSG(LBN_SELCHANGE, IDC_LIST, OnSelChange)
		END_MSG_LIST()
	}

	return TRUE;
}

void CPageIndex::OnSelChange()
{
	INT_PTR pos = SendMessage(IDC_LIST, LB_GETCURSEL, 0, 0L);
	if (pos == LB_ERR)
		return;
	SITEMAP_ENTRY* pSiteMapEntry = m_phhCtrl->m_pindex->GetSiteMapEntry((int)pos + 1);

	m_fSelectionChange = TRUE; // ignore EN_CHANGE
	SetWindowText(IDC_EDIT, pSiteMapEntry->GetKeyword());
	m_fSelectionChange = FALSE; // ignore EN_CHANGE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\unicode.h ===
// unicode.h - Unicode functions that work on all 32-bit Window platform

#pragma once

#ifndef __UNICODE_H__
#define __UNICODE_H__

// C/C++ differences
#ifndef INLINE
#ifdef __cplusplus
#define INLINE inline
#else
#define INLINE __inline
#endif
#endif

#define CP_UNICODE          1200 // Unicode
#define IN_RANGE(v, r1, r2) ((r1) <= (v) && (v) <= (r2))


//====================
// From VS6 minar.h
//====================

class CBufImpl
{
private:
    BYTE * m_pData;
    int    m_cb;
    
    HRESULT _SetByteSize (int cb);

public:
    CBufImpl() : m_pData(NULL), m_cb(0) {}
    ~CBufImpl()  { Clear(); }

    void    Clear             ();
    HRESULT SetByteSize       (int cb);
    HRESULT SetByteSizeShrink (int cb);
    int     GetByteSize       () { return m_cb; }
    BYTE *  ByteData          () { return m_pData; }
};

inline HRESULT CBufImpl::SetByteSize (int cb)
{
    if (cb <= m_cb)
        return S_OK;
    return _SetByteSize(cb);
}

//---------------------------------------------------------------
template <class T> class CMinimalArray : public CBufImpl
{
public:
    HRESULT SetSize       (int cel) { return SetByteSize(cel*sizeof(T)); }
    HRESULT SetSizeShrink (int cel) { return SetByteSizeShrink(cel*sizeof(T)); }
    int     Size    ()        { return GetByteSize()/sizeof(T); }
    operator T*     ()        { return (T*)ByteData(); }
    T*      GetData ()        { return (T*)ByteData(); }
};


//====================
// From VS6 intlutil.h
//====================

/////////////////////////////////////////////////////////////////
// GetDefaultFont - Get default monospaced font for a codepage
//
// IN   cp   Codepage -- usually result of GetACP().
// IN   plf  Address of uninitialized LOGFONT structure.
// OUT  plf  Fully initialized LOGFONT struct.
//
void GetDefaultFont(UINT cp, LOGFONT * plf, BYTE *pbySize);

BOOL IsStringDisplayable(const char *pszString, UINT codepage);

/////////////////////////////////////////////////////////////////
// locale/codepage mappings
//
#define LCIDCP_CURRENT (2)
#define LCIDCP_GUESSED (1)
#define LCIDCP_UNKNOWN (0)
int WINAPI LCIDFromCodePage(UINT cp, LCID * plcid);

UINT WINAPI CodePageFromLCID(LCID lcid);
UINT WINAPI CodepageFromCharset(BYTE cs);
BOOL WINAPI IsSupportedFontCodePage(UINT cp);

BOOL WINAPI IsDbcsGdi ();
BOOL WINAPI IsWin95OrLess ();
BOOL WINAPI IsNT ();
BOOL WINAPI WideAPIHack ();
UINT WINAPI GetFontCodePage (HDC hdc);
BOOL IntlGetTextExtentPoint32W (HDC hdc, LPCWSTR lpString, int cbString, LPSIZE lpSize, UINT *pCP = NULL);
BOOL IntlExtTextOutW (HDC hdc, int X, int Y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpString, UINT cbCount, CONST INT *lpDx, UINT *pCP = NULL); 
BOOL IntlTextOutW(HDC hdc, int nXStart, int nYStart, LPCWSTR lpString, int cbString, UINT *pCP = NULL);
BOOL IntlGetTextExtentExPointW(HDC hdc, LPCWSTR lpString, int cbString, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize, UINT *pCP = NULL);

BOOL HxAppendMenu(HMENU hMenu, UINT uFlags, UINT uIDNewItem, LPCTSTR lpNewItem);

BOOL HxSetWindowText(HWND hWnd, LPCTSTR lpString);

BOOL IntlExtTextOut( HDC hdc, int X, int Y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpString, UINT cbCount, CONST INT *lpDx, UINT* pCP );

inline BOOL IntlTextOutW (HDC hdc, int nXStart, int nYStart, LPCWSTR lpString, int cch, UINT *pCP)
{
    // WARNING: this is not completely generic.
    // This does work for the ways we use TextOut.
    return IntlExtTextOutW(hdc, nXStart, nYStart, 0, NULL, lpString, cch, NULL, pCP);
}

inline BOOL IsImeLanguage(LANGID wLang)
{
    wLang = PRIMARYLANGID(wLang);
    if (LANG_NEUTRAL  == wLang) return FALSE;
    if (LANG_ENGLISH  == wLang) return FALSE;
    if (LANG_JAPANESE == wLang) return TRUE;
    if (LANG_KOREAN   == wLang) return TRUE;
    if (LANG_CHINESE  == wLang) return TRUE;
    return FALSE;
}

inline BOOL IsImeCharSet(BYTE charset)
{
    if (ANSI_CHARSET        == charset) return FALSE;
    if (SHIFTJIS_CHARSET    == charset) return TRUE;
    if (GB2312_CHARSET      == charset) return TRUE;
    if (CHINESEBIG5_CHARSET == charset) return TRUE;
    if (HANGEUL_CHARSET     == charset) return TRUE;
    if (JOHAB_CHARSET       == charset) return TRUE;
    return FALSE;
}

#endif // __UNICODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\unicode.cpp ===
// unicode.cpp - Unicode functions that work on all 32-bit Window platforms
//
// Rules:
// 1. if Windows NT, then just use the GDI APIs directly
// 2. if Windows 95/98 call our Unicode functions to do the dirty deeds

// needed for those pesky pre-compiled headers
#include "header.h"

#include <windows.h>
#include <malloc.h>

#include "unicode.h"

#ifndef ASSERT
#if defined(_DEBUG) || defined(DEBUG)
#define ASSERT(b) if(b) MessageBox(NULL, "FAILED: #b", "ASSERT", MB_OK );
#else
#define ASSERT(b)
#endif
#endif


//======================
// From VS6 minar.cpp
//======================

void CBufImpl::Clear()
{
    if (m_pData)
        free(m_pData);
    m_pData = NULL;
    m_cb = 0;
}

HRESULT CBufImpl::_SetByteSize (int cb)
{
    if (cb > m_cb)
    {
        cb = ((cb + 64) & ~63);
        if (m_cb)
        {
            ASSERT(NULL != m_pData);
            BYTE * pb = (BYTE*)realloc(m_pData, cb);
            if (pb)
            {
                m_pData = pb;
                m_cb = cb;
            }
            else
                return E_OUTOFMEMORY;
        }
        else
        {
            ASSERT(NULL == m_pData);
            m_pData = (BYTE*)malloc(cb);
            if (m_pData)
                m_cb = cb;
            else
                return E_OUTOFMEMORY;
        }
    }

#ifdef _DEBUG
    // fill unused area to aid debugging
    if (cb < m_cb)
    {
        memset(m_pData + cb, -1, m_cb - cb);
    }
#endif
    return S_OK;
}

HRESULT CBufImpl::SetByteSizeShrink (int cb)
{
    Clear();
    if (0 == cb)
        return S_OK;
    if (cb >= m_cb)
        return _SetByteSize(cb);
    m_pData = (BYTE*)malloc(cb);
    if (m_pData)
        m_cb = cb;
    else
        return E_OUTOFMEMORY;
    return S_OK;
}


//======================
// From VS6 intlutil.cpp
//======================

/////////////////////////////////////////////////////////////////
// if some component ever bypasses the GDI versions of these APIs
// we will need to get the real APIs for GDI32.
//
//#define GET_REAL_GDI_PFNS

#ifdef GET_REAL_GDI_PFNS
typedef BOOL (WINAPI   *PFN_GDI_ExtTextOutW) (HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *);
typedef BOOL (APIENTRY *PFN_GDI_GetTextExtentPoint32W) (HDC, LPCWSTR, int, LPSIZE);
typedef BOOL (APIENTRY *PFN_GDI_GetTextExtentExPointW) (HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);
PFN_GDI_ExtTextOutW           GdiExtTextOutW           = NULL;
PFN_GDI_GetTextExtentPoint32W GdiGetTextExtentPoint32W = NULL;
PFN_GDI_GetTextExtentExPointW GdiGetTextExtentExPointW = NULL;
void LoadAPIs()
{
    HMODULE hGDI = GetModuleHandleA("GDI32");
    ASSERT(hGDI);
    GdiExtTextOutW           = (PFN_GDI_ExtTextOutW          )GetProcAddress(hGDI, "ExtTextOutW");
    GdiGetTextExtentPoint32W = (PFN_GDI_GetTextExtentPoint32W)GetProcAddress(hGDI, "GetTextExtentPointW");
    GdiGetTextExtentExPointW = (PFN_GDI_GetTextExtentExPointW)GetProcAddress(hGDI, "GetTextExtentExPointW");
    ASSERT(NULL != GdiExtTextOutW);
    ASSERT(NULL != GdiGetTextExtentPoint32W);
    ASSERT(NULL != GdiGetTextExtentExPointW);
}
#define ENSUREAPIS { if (NULL == GdiExtTextOutW) LoadAPIs(); }

#else  // nothing is bypassing GDI so we can just use the real APIs directly
#define GdiExtTextOutW           ExtTextOutW
#define GdiGetTextExtentPoint32W GetTextExtentPoint32W
#define GdiGetTextExtentExPointW GetTextExtentExPointW
#define ENSUREAPIS
#endif // GET_REAL_GDI_PFNS

/////////////////////////////////////////////////////////////////

#define USE_WIDE_API_HACK                        FALSE // Invert Wide API hack flag
#define VALIDATE_SIMULATED_GETTEXTEXTENTEXPOINT  FALSE // Validate simulated GetTextExtentExPoint

/////////////////////////////////////////////////////////////////

// These strings are not localized
static const char szFontENU[] = "Courier New";
static const char szFontJPN[] = "\x82\x6c\x82\x72\x20\x83\x53\x83\x56\x83\x62\x83\x4e"; // MS Gothic
static const char szFontKOR[] = "\xb5\xb8\xbf\xf2\xc3\xbc"; // Dotum Che
static const char szFontCHS[] = "\xcb\xce\xcc\xe5";         // Song Ti
static const char szFontCHT[] = "\xb2\xd3\xa9\xfa\xc5\xe9"; // Ming Li
static const char szFontGenericFE[] = "FixedSys";

typedef struct _FI {
        UINT         uCharset;
        int          iPtHeight;
        const char * szName;
} FI;

static const FI FontDefaults[] = {
    ANSI_CHARSET,        10, szFontENU, // First entry is default
    SHIFTJIS_CHARSET,    10, szFontJPN,
    GB2312_CHARSET,       9, szFontCHS,
    HANGEUL_CHARSET,     10, szFontKOR,
    JOHAB_CHARSET,       10, szFontKOR,
    CHINESEBIG5_CHARSET,  9, szFontCHT,
    THAI_CHARSET,        12, szFontGenericFE,
    DEFAULT_CHARSET,     10, "",      // let fontmapper choose

    // These are the same as the default, so we just let them fall to
    //   the default handling instead of defining/scanning more entries.
//  GREEK_CHARSET,       10, szFontENU, // Courier New has Greek
//  TURKISH_CHARSET,     10, szFontENU, // Courier New has Turkish
//  EASTEUROPE_CHARSET,  10, szFontENU, // Courier New has EE
//  RUSSIAN_CHARSET,     10, szFontENU, // Courier New has Cyrillic
//  BALTIC_CHARSET,      10, szFontENU,     // Courier New has Baltic

    // not supported
//  OEM_CHARSET,         10, szFont???,
//  HEBREW_CHARSET,      10, szFont???,
//  ARABIC_CHARSET,      10, szFontENU,     // Courier New has Arabic on Arabic systems
//  MAC_CHARSET,         10, szFont???,

    // nonsense for text
//  SYMBOL_CHARSET,      10, "Symbol",

    // End of table
    0, 0, 0
};

//---------------------------------------------------------------
// GetDefaultFont - Get default monospaced font for a codepage
//
// IN    cp  codepage
// INOUT lf  logfont
//
void GetDefaultFont(UINT cp, LOGFONT * plf, BYTE *pbySize)
{
    int dpi;
    CHARSETINFO csi;
    BYTE bySize = 12;

    ASSERT(plf);
    memset(plf, 0, sizeof LOGFONT);

    { // get display resolution
        HDC dc = GetDC(NULL);
        dpi = dc ? GetDeviceCaps(dc, LOGPIXELSY) : 72;
        ReleaseDC(NULL,dc);
    }
    // check and normalize codepage
    ASSERT(0 == cp || IsValidCodePage(cp));
    if (!cp)
    cp = GetACP();

    // init to crudest defaults
    plf->lfCharSet        = DEFAULT_CHARSET;
    plf->lfPitchAndFamily = FIXED_PITCH;

    // translate codepage to charset
    memset( &csi, 0, sizeof csi );
    if (TranslateCharsetInfo((DWORD*)(DWORD_PTR)cp, &csi, TCI_SRCCODEPAGE))
    plf->lfCharSet = (BYTE)csi.ciCharset;

    // lookup font that corresponds to the codepage
    int i;
    for (i = 0; FontDefaults[i].iPtHeight; i++)
    {
            if (FontDefaults[i].uCharset == plf->lfCharSet)
                    goto L_Return;
    }
    i = 0; // first entry in table is the default

L_Return:
    if (FontDefaults[i].szName)
            strncpy(plf->lfFaceName, FontDefaults[i].szName, LF_FACESIZE);
    if (FontDefaults[i].iPtHeight)
            bySize = (BYTE)FontDefaults[i].iPtHeight;

    plf->lfHeight = -MulDiv(bySize, dpi, 72);
    if (pbySize)
            *pbySize = bySize;
}

/////////////////////////////////////////////////////////////////
//
// This table derived from information in
// "Developing International Software" by Nadine Kano, Microsoft Press
// Appendix E: Codepage Support in Microsoft Windows
//
// Entries in ascending cp number.
// Only valid ACP entires are listed
//
static const DWORD mapCPtoLCID[] =
{
     874,    MAKELCID(MAKELANGID(LANG_THAI, SUBLANG_NEUTRAL), SORT_DEFAULT), // Thai
     932,    MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL), SORT_DEFAULT), // Japanese
     936,    MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL), SORT_DEFAULT), // Chinese Trad. (Hong Kong, Taiwan)
     949,    MAKELCID(MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN), SORT_DEFAULT), // Korean (wansung)
     950,    MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT), // Chinese Simp. (PRC, Singapore)
//  1200,    MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT), // Unicode
    1250,    MAKELCID(MAKELANGID(LANG_HUNGARIAN, SUBLANG_NEUTRAL), SORT_DEFAULT), // Eastern European
    1251,    MAKELCID(MAKELANGID(LANG_RUSSIAN, SUBLANG_NEUTRAL), SORT_DEFAULT), // Cyrillic
    1252,    MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_NEUTRAL), SORT_DEFAULT), // Western European (US)
    1253,    MAKELCID(MAKELANGID(LANG_GREEK, SUBLANG_NEUTRAL), SORT_DEFAULT), // Greek
    1254,    MAKELCID(MAKELANGID(LANG_TURKISH, SUBLANG_NEUTRAL), SORT_DEFAULT), // Turkish
    1255,    MAKELCID(MAKELANGID(LANG_HEBREW, SUBLANG_NEUTRAL), SORT_DEFAULT), // Hebrew
    1256,    MAKELCID(MAKELANGID(LANG_ARABIC, SUBLANG_NEUTRAL), SORT_DEFAULT), // Arabic
    1257,    MAKELCID(MAKELANGID(LANG_ESTONIAN, SUBLANG_NEUTRAL), SORT_DEFAULT), // Baltic: Estonian, Latvian, Lithuanian: Which is best default?
#ifdef SUBLANG_KOREAN_JOHAB
    1361,    MAKELCID(MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN_JOHAB), SORT_DEFAULT), // Korean Johab
#endif // SUBLANG_KOREAN_JOHAB
//  CP_UTF7, MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT), // Unicode UTF-7
//  CP_UTF8, MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT), // Unicode UTF-8
    0, 0
};

// LCIDFromCodePage - Given a codepage, return a reasonable LCID.
//
// Since there is not a 1-1 mapping, we'll have to choose a somewhat
// arbitrary locale. If we match the current system locale, we'll use it.
// Otherwise, we're looking at something from a different system, and
// we'll have to make a guess. This means that all Western European codepages
// come up as US English when you're not on a WE system.
//
// Currently, EBCDIC, OEM, and MAC codepages not supported.
//
int WINAPI LCIDFromCodePage( UINT cp, LCID * plcid )
{
    if ((CP_ACP == cp) || (GetACP() == cp))
    {
        *plcid = GetUserDefaultLCID();
        return LCIDCP_CURRENT;
    }
    else
    {
        //lookup something somewhat reasonable
        for (int i = 0; mapCPtoLCID[i] > 0; i += 2)
        {
            if (mapCPtoLCID[i] == cp)
            {
                *plcid = mapCPtoLCID[i + 1];
                return LCIDCP_GUESSED;
            }
            if (mapCPtoLCID[i] > cp)
                    break;
        }
    }
    // Unknown: give up
    return LCIDCP_UNKNOWN;
}

UINT WINAPI CodePageFromLCID(LCID lcid)
{
    char wchLocale[10];
    UINT cp;

    if (GetLocaleInfoA(lcid, LOCALE_IDEFAULTANSICODEPAGE, wchLocale, sizeof wchLocale))
    {
        cp = strtoul(wchLocale, NULL, 10);
        if (cp)
            return cp;
    }
#ifdef _DEBUG
    else
    {
        DWORD dwErr = GetLastError();
    }
#endif
        return GetACP();
}

UINT WINAPI CodepageFromCharset(BYTE cs)
{
    CHARSETINFO csi;
    TranslateCharsetInfo ((DWORD *)(DWORD_PTR)MAKELONG(cs, 0), &csi, TCI_SRCCHARSET);
    return csi.ciACP;
}

//---------------------------------------------------------------
// GetFontCodePage -
//
// Returns the code page of the font selected into hdc
//
UINT WINAPI GetFontCodePage (HDC hdc)
{
    TEXTMETRIC  tm;
    CHARSETINFO cs;

    GetTextMetrics (hdc, &tm);
    TranslateCharsetInfo ((DWORD *)(DWORD_PTR)MAKELONG(tm.tmCharSet, 0), &cs, TCI_SRCCHARSET);
    return cs.ciACP;
}

//---------------------------------------------------------------
// Returns non-zero if this is a DBCS version of GDI
//
BOOL WINAPI IsDbcsGdi()
{
    static int iDbcs = -2;
    if (-2 != iDbcs)
        return iDbcs;
    WORD lang = PRIMARYLANGID(LOWORD(GetSystemDefaultLCID()));
    iDbcs = (LANG_JAPANESE == lang)
        || (LANG_CHINESE  == lang)
        || (LANG_KOREAN   == lang)
        || (LANG_ARABIC   == lang)
		|| (LANG_HEBREW   == lang);
    return iDbcs;
}

BOOL WINAPI IsWin95OrLess()
{
    static int iWin95 = -2;
    if (-2 != iWin95)
        return iWin95;

    OSVERSIONINFO osVerInfo;
    osVerInfo.dwOSVersionInfoSize = sizeof (osVerInfo);
    GetVersionEx (&osVerInfo);
    iWin95 = ((osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            ((osVerInfo.dwMajorVersion < 4) ||
            ((osVerInfo.dwMajorVersion == 4) && (osVerInfo.dwMinorVersion < 1))) );
    return iWin95;
}

BOOL WINAPI IsNT()
{
    static int iNT = -2;
    if (-2 != iNT)
        return iNT;

    OSVERSIONINFO osver;
    memset (&osver, 0, sizeof osver);
    osver.dwOSVersionInfoSize = sizeof osver;
    GetVersionEx(&osver);
    iNT = (osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
    return iNT;
}

//---------------------------------------------------------------
// WideAPIHack
//
// Returns non-zero if this version of Windows has bugs in UNICODE
// API - GetTextExtentPoint32W, ExtTextOut, etc
//
inline BOOL WINAPI WideAPIHack()
{
    static int iHack = -2;

    if (-2 == iHack)
    {
        iHack = IsDbcsGdi() && IsWin95OrLess();
    }

    if (USE_WIDE_API_HACK) // Use hack anyway?
        return !iHack;

    return iHack;
}

//---------------------------------------------------------------------------
// Text utility services
//---------------------------------------------------------------------------

// conversion buffers
static CMinimalArray<CHAR> INTL_arText;
static CMinimalArray<int>  INTL_arDx;
// cached codepage info
static CPINFO              INTL_cpi;
static UINT                INTL_cp = (UINT)-1;

inline BOOL WINAPI IsSupportedFontCodePage(UINT cp)
{
    if ((cp == CP_ACP))
        return TRUE;
    return IsValidCodePage(cp)
        && (cp != CP_UNICODE)
        && (cp != CP_UTF7)
        && (cp != CP_UTF8)
        ;
}

BOOL IsLeadByte(BYTE ch, CPINFO * pcpi)
{
    //if (pcpi->MaxCharSize < 2) return FALSE; // SBCS
    for (int i = 0; i < 10; i += 2) // max 5 lead byte ranges
    {
        if (!pcpi->LeadByte[i])
            return FALSE; // no more lead byte ranges
        if (IN_RANGE(ch, pcpi->LeadByte[i], pcpi->LeadByte[i+1]))
            return TRUE;
    }
    return FALSE;
}

CPINFO * GetCachedCPInfo(UINT cp)
{
    ASSERT(IsSupportedFontCodePage(cp));
    if (cp == INTL_cp)
        return &INTL_cpi;
    memset(&INTL_cpi, 0, sizeof(CPINFO));
    if (!GetCPInfo(cp, &INTL_cpi))
    {
        ASSERT(0); // this should never fail!
        return NULL;
    }
    INTL_cp = cp;
    return &INTL_cpi;
}

UINT GetCodePage(HDC hdc, UINT *pCP)
{
    UINT cp;
    if (!WideAPIHack())
    {
        cp = (pCP) ? *pCP : GetFontCodePage (hdc);
        if (IsSupportedFontCodePage(cp))
            return cp;
    }
    cp = CodePageFromLCID(GetThreadLocale());
    return cp;
}

//---------------------------------------------------------------
// IntlGetTextExtentPoint32W
//
// This exists to work around bugs in the W API in pre-Memphis Win95
//
BOOL IntlGetTextExtentPoint32W (HDC hdc, LPCWSTR lpString, int cch, LPSIZE lpSize, UINT *pCP)
{
    ENSUREAPIS

    BOOL fRet;

    if (!WideAPIHack())
    {
        fRet = GdiGetTextExtentPoint32W (hdc, lpString, cch, lpSize);
        if (fRet)
            return fRet;
#ifdef _DEBUG
        DWORD e = GetLastError();
#endif
    }

    if (FAILED(INTL_arText.SetSize(2*cch)))
    {
        return 0;
    }

    CHAR * psz;
    long   cb;
    UINT   cp;

    cp  = GetCodePage(hdc, pCP);
    psz = INTL_arText;
    cb  = WideCharToMultiByte (cp, 0, lpString, cch, psz, 2*cch, 0, 0);
    fRet = GetTextExtentPoint32A (hdc, psz, cb, lpSize);
#ifdef _DEBUG
    if (!fRet)
    {
        DWORD e = GetLastError();
        ASSERT(0);
    }
#endif
    return fRet;
}

//---------------------------------------------------------------
// IntlExtTextOut
//
// Take in an MBCS string and do a Unicode Text out
// this requires that the caller provide the proper codepage for the conversion
//
BOOL IntlExtTextOut (HDC hdc, int X, int Y, UINT fuOptions, CONST RECT *lprc, LPCSTR lpString, UINT cch, CONST INT *lpDx, UINT *pCP)
{
  WCHAR* pwszString = new WCHAR[cch];

  if( MultiByteToWideChar( *pCP, 0, lpString, cch, pwszString, cch*sizeof(WCHAR) ) == 0 )
    return FALSE;

  BOOL bReturn = IntlExtTextOutW( hdc, X, Y, fuOptions, lprc, pwszString, cch, lpDx, pCP );

  if( pwszString )
    delete [] pwszString;

  return bReturn;
}


//---------------------------------------------------------------
// IntlExtTextOutW
//
// This exists to work around bugs in the W API in pre-Memphis FE Win95
//
BOOL IntlExtTextOutW (HDC hdc, int X, int Y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpString, UINT cch, CONST INT *lpDx, UINT *pCP)
{
    ENSUREAPIS

    BOOL fRet;

    if (!WideAPIHack())
    {
        fRet = GdiExtTextOutW (hdc, X, Y, fuOptions, lprc, lpString, cch, lpDx);
        if (fRet)
            return fRet;
#ifdef _DEBUG
        DWORD e = GetLastError();
#endif
    }

    if (FAILED(INTL_arText.SetSize(2*cch)))
    {
        return 0;
    }

    CHAR *   psz;
    long     cb;
    UINT     cp;

    cp  = GetCodePage(hdc, pCP);
    psz = INTL_arText;
    cb  = WideCharToMultiByte (cp, 0, lpString, cch, psz, 2*cch, 0, 0);
    if (lpDx)
    {
        // Map delta info if we have a MBCS codepage
        //

        CPINFO * pcpi = GetCachedCPInfo(cp);
        if (!pcpi)
        {
            ASSERT(0);
            lpDx = NULL;
            goto _Eto;
        }
        if (pcpi->MaxCharSize > 1) // Multibyte
        {
            if (SUCCEEDED(INTL_arDx.SetSize(2*cch)))
            {
                LPINT pdx = INTL_arDx;
                CHAR *pch = psz;
                for (UINT i = 0; i < cch; i++)
                {
                    if (IsLeadByte(*pch++, pcpi))
                    {
                        *pdx++ = *lpDx++;
                        pch++;
                        *pdx++ = 0;
                    }
                    else
                    {
                        *pdx++ = *lpDx++;
                    }
                }
                lpDx = INTL_arDx;
            }
            else
                // OOM: just send it out without spacing info -- what else can we do?
                lpDx = NULL;
        }
    }
_Eto:
    fRet = ExtTextOutA (hdc, X, Y, fuOptions, lprc, psz, cb, lpDx);
#ifdef _DEBUG
    if (!fRet)
    {
        DWORD e = GetLastError();
    }
#endif
    return fRet;
}

// SimulateGetTextExtentExPointW
// Algorithm:
// 1) Convert to multibyte with known replacement char
// 2) Use GetTextExtentExPointA
// 3) While mapping dx's back to wide dx's, use GetTextExtentPoint32W for replaced characters
//
// This is much faster than iterating GetTextExtentPoint32W.
//
BOOL SimulateGetTextExtentExPointW(HDC hdc, LPCWSTR lpString, int cch, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize, UINT * pCP)
{
#define SZDEFAULT "\1"
#define CHDEFAULT '\1'

    if (FAILED(INTL_arText.SetSize(2*cch)))
        return 0;

    BOOL     fRet;
    int    * pdx;
    CPINFO * pcpi;
    CHAR   * psz;
    long     cb;

    UINT cp = (pCP) ? *pCP : GetFontCodePage (hdc);
    psz = INTL_arText;

    // Convert string
    cb = WideCharToMultiByte (cp, 0, lpString, cch, psz, 2*cch, SZDEFAULT, 0);
#ifdef _DEBUG
    if (0 == cb)
    {
        DWORD e = GetLastError();
    }
#endif

    pcpi = GetCachedCPInfo(cp);
    // Getting extents?
    if (NULL != alpDx)
    {
        // Map MBCS extents?
        if (pcpi && pcpi->MaxCharSize == 1)
        {
            // SBCS: no mapping required - use caller's array directly
            pdx = alpDx;
        }
        else
        {
            // MBCS: must map array
            if (FAILED(INTL_arDx.SetSize(cb)))
            {
                return 0;
            }
            pdx = INTL_arDx;
        }
    }
    else
        pdx = NULL;

    int nFit = cb;
    if (!lpnFit)
        nMaxExtent = 32750;

    // Measure!
    fRet = GetTextExtentExPointA (hdc, psz, cb, nMaxExtent, &nFit, pdx, lpSize);
    if (!fRet)
    {
        ASSERT(0);
        nFit = 0;
#ifdef _DEBUG
        DWORD e = GetLastError();
#endif
    }

    if ((NULL != alpDx) && fRet)
    {
        LPCWSTR pwch = lpString;
        int dxOut = 0;
        int dxChar;
        SIZE size;
        // Map MBCS extents?
        if (pcpi && pcpi->MaxCharSize > 1)
        {
            ASSERT(nFit >= 0 && nFit <= cb);
            ASSERT(!IsLeadByte(CHDEFAULT, pcpi));
#ifdef _DEBUG
            int * pUDx = alpDx;
#endif
            int   nMB = 0;
            BOOL fDBCSGDI = IsDbcsGdi();
            for (int i = 0; i < nFit; i++)
            {
                if (IsLeadByte(*psz, pcpi))
                {
                    if (!fDBCSGDI)
                    dxChar = (i) ? ((*pdx) - (*(pdx-1))) : (*pdx);
                    // advance to trail byte
                    nMB++;
                    pdx++;
                    psz++;
                    if (fDBCSGDI)
                        dxChar = (i) ? ((*pdx) - (*(pdx-2))) : (*pdx);
                    // advance to next char
                    i++;
                    psz++;
                    pdx++;
                }
                else
                {
                    if (CHDEFAULT == *psz)
                    {
                        GdiGetTextExtentPoint32W(hdc, pwch, 1, &size);
                        dxChar = size.cx;
                    }
                    else
                    {
                        dxChar = (i) ? ((*pdx) - (*(pdx-1))) : (*pdx);
                    }
                    pdx++;
                    psz++;
                }
                pwch++;
                dxOut += dxChar;
                ASSERT(alpDx-pUDx < cch); // if this fires, you aren't tracking the pointers correctly
                *alpDx++ = dxOut;
            }
            nFit -= nMB;
        }
        else
        {
            for (int i = 0; i < nFit; i++)
            {
                if (CHDEFAULT == *psz)
                {
                    GdiGetTextExtentPoint32W(hdc, pwch, 1, &size);
                    dxChar = size.cx;
                }
                else
                {
                    dxChar = (i) ? ((*alpDx) - (*(alpDx-1))) : (*alpDx);
                }
                dxOut += dxChar;
                *alpDx++ = dxOut;
                psz++;
                pwch++;
            }
        }
        if (lpSize)
            lpSize->cx = dxOut;
    }
    if (lpnFit)
        *lpnFit = nFit;
    return fRet;
}

//---------------------------------------------------------------
// IntlGetTextExtentExPointW
//
BOOL IntlGetTextExtentExPointW(HDC hdc, LPCWSTR lpString, int cch, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize, UINT *pCP)
{
    ENSUREAPIS

    if (VALIDATE_SIMULATED_GETTEXTEXTENTEXPOINT)
    {
        return SimulateGetTextExtentExPointW(hdc, lpString, cch, nMaxExtent, lpnFit, alpDx, lpSize, pCP);
    }

    static BOOL fUseWideAPI = TRUE;
    DWORD err;
    BOOL  fRet = FALSE;

    if (!WideAPIHack())
    {
        if (fUseWideAPI)
        {
            fRet = GdiGetTextExtentExPointW (hdc, lpString, cch, nMaxExtent, lpnFit, alpDx, lpSize);
            if (fRet)
                return fRet;
            err = GetLastError();
            if (ERROR_CALL_NOT_IMPLEMENTED == err)
                fUseWideAPI = FALSE;
        }
        fRet = SimulateGetTextExtentExPointW(hdc, lpString, cch, nMaxExtent, lpnFit, alpDx, lpSize, pCP);
        if (fRet)
            return fRet;
    }

    ASSERT(NULL != lpString);

    if (FAILED(INTL_arText.SetSize(2*cch)))
    {
        return 0;
    }

    UINT     cp   = (UINT)-1;
    int    * pdx;
    CPINFO * pcpi;
    CHAR   * psz;
    long     cb;

    cp  = GetCodePage(hdc, pCP);
    if (NULL == (pcpi = GetCachedCPInfo(cp)))
        cp = CodePageFromLCID(GetThreadLocale());
    psz = INTL_arText;

    // Convert string
    cb = WideCharToMultiByte (cp, 0, lpString, cch, psz, 2*cch, 0, 0);

    // Getting extents?
    if (NULL != alpDx)
    {
        // Map MBCS extents?
        if (pcpi && pcpi->MaxCharSize == 1)
        {
            // SBCS: no mapping required - use caller's array directly
            pdx = alpDx;
        }
        else
        {
            // MBCS: must map array
            if (FAILED(INTL_arDx.SetSize(cb)))
            {
                return 0;
            }
            pdx = INTL_arDx;
        }
    }
    else
        pdx = NULL;

    int nFit = cb;
    if (!lpnFit)
        nMaxExtent = 32750;

    // Measure!
    fRet = GetTextExtentExPointA (hdc, psz, cb, nMaxExtent, &nFit, pdx, lpSize);
    if (!fRet)
    {
        ASSERT(0);
        nFit = 0;
#ifdef _DEBUG
        DWORD e = GetLastError();
#endif
    }

    if ((NULL != alpDx) && fRet)
    {
        // Map MBCS extents?
        if (pcpi && pcpi->MaxCharSize > 1)
        {
            ASSERT(nFit >= 0 && nFit <= cb);
#ifdef _DEBUG
            int * pUDx = alpDx;
#endif
            int   nMB = 0;
            for (int i = 0; i < nFit; i++)
            {
                if (IsLeadByte(*psz++, pcpi))
                {
                    nMB++;
                    pdx++;
                    psz++;
                    i++;
                }
                ASSERT(alpDx-pUDx < cch);
                *alpDx++ = *pdx++;
            }
            nFit -= nMB;
        }
    }
    if (lpnFit)
        *lpnFit = nFit;
    return fRet;
}


// IsStringDisplayable()
//
// This function computes if all characters are displayable under current system's
// default codepage. It does this by converting the input string (ANSI/DBCS) to
// Unicode using the string's native codepage and then convert it back to ANSI/DBCS
// using the system default codepage.  If unmappable characters are detected 
// during either conversion it means the string will not display properly under
// the system's default codepage.
// 
// This function returns a pointer to the string that sucessfully made it round trip.
// This is necessary because the system sometimes normalizes character to make them
// displayable (and we need to use the modified version).
//
// The caller is responsible for freeing this return string.
//
BOOL IsStringDisplayable(const char *pszString, UINT codepage)
{
    if(!pszString)
	    return FALSE;
		
    // allocate buffer for Unicode string
	//
    int cUnicodeLen = (int)(strlen(pszString) * 2) + 4;
	WCHAR *pszUnicodeBuffer = (WCHAR *) lcMalloc(cUnicodeLen);

	if(!pszUnicodeBuffer)
	    return FALSE;

    // Convert string to Unicode
    int ret = MultiByteToWideChar(codepage, MB_ERR_INVALID_CHARS, pszString, -1, pszUnicodeBuffer, cUnicodeLen);

    // See if we had unmappable characters on our way to Unicode
	//
	if(!ret && GetLastError() == ERROR_NO_UNICODE_TRANSLATION)
	{
	    lcFree(pszUnicodeBuffer);
        return FALSE;
	}

    // other failure (same return)
    if(!ret)
	{
	    lcFree(pszUnicodeBuffer);
	    return FALSE;
	}

    // allocate the return ANSI/DBCS buffer
	//
	char *pszAnsiBuffer = (char *) lcMalloc(cUnicodeLen + 2);

    if(!pszAnsiBuffer)
	{
	    lcFree(pszUnicodeBuffer);
	    return FALSE;
	}

    BOOL bDefaultChar = FALSE, bExactMatch = FALSE;

    // Convert back to ANSI/DBCS using default codepage
	//
    ret = WideCharToMultiByte(CP_ACP, 0, pszUnicodeBuffer, -1, pszAnsiBuffer, cUnicodeLen+2, ".", &bDefaultChar);

    if(!strcmp(pszAnsiBuffer,pszString))
        bExactMatch = TRUE;	    

    // free our buffers
	//
    lcFree(pszAnsiBuffer);
    lcFree(pszUnicodeBuffer);

    // check if default character was used
	//
	if(!ret || bDefaultChar || !bExactMatch)
        return FALSE;

    // success!
	//
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// MUI support
//
// This AppendMenu wrapper will (under NT5) get a Unicode resource and 
// then call AppendMenuW().
//
BOOL HxAppendMenu(HMENU hMenu, UINT uFlags, UINT uIDNewItem, LPCTSTR lpNewItem)
{
    if(g_bWinNT5 && !uFlags && lpNewItem)
    {
        	
        DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
		
		DWORD dwSize = (DWORD)(sizeof(WCHAR) * strlen(lpNewItem)) + 4;
		WCHAR *pwcString = (WCHAR *) lcMalloc(dwSize);
		
		if(!pwcString)
		    return FALSE;
		
		MultiByteToWideChar(cp, MB_PRECOMPOSED, lpNewItem, -1, pwcString, dwSize);
		
        BOOL ret = AppendMenuW(hMenu, uFlags, uIDNewItem, pwcString);
		
        lcFree(pwcString);	
		
		return ret;
	}
	else
    {
        return AppendMenu(hMenu, uFlags, uIDNewItem, lpNewItem);
	}

}

///////////////////////////////////////////////////////////////////////////////
// MUI support
//
// This SetWindowText wrapper will (under NT5) convert the string to Unicode 
// based on the MUI setting and then call SetWindowTextW().
//
BOOL HxSetWindowText(HWND hWnd, LPCTSTR lpString)
{
    if(g_bWinNT5 && lpString)
    {
        DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
		
		DWORD dwSize = (DWORD)(sizeof(WCHAR) * strlen(lpString)) + 4;
		WCHAR *pwcString = (WCHAR *) lcMalloc(dwSize);
		
		if(!pwcString)
		    return FALSE;
		
		MultiByteToWideChar(cp, MB_PRECOMPOSED, lpString, -1, pwcString, dwSize);
		
        BOOL ret = SetWindowTextW(hWnd, pwcString);
		
        lcFree(pwcString);	
		
		return ret;
	}
	else
    {
        return SetWindowText(hWnd, lpString);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\unknown.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "Unknown.H"
#include <stddef.h>

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.	basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.

inline CUnknownObject *CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
(
	void
)
{
	return (CUnknownObject *)((LPBYTE)this - offsetof(CUnknownObject, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//	  REFIID		- [in]	interface they want
//	  void **		- [out] where they want to put the resulting object ptr.
//
// Output:
//	  HRESULT		- S_OK, E_NOINTERFACE

STDMETHODIMP CUnknownObject::CPrivateUnknownObject::QueryInterface(REFIID riid, void **ppvObjOut)
{
	CHECK_POINTER(ppvObjOut);

	// if they're asking for IUnknown, then we have to pass them ourselves.
	// otherwise defer to the inheriting object's InternalQueryInterface
	//
	if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
		m_cRef++;
		*ppvObjOut = (IUnknown *)this;
		return S_OK;
	} else
		return m_pMainUnknown()->InternalQueryInterface(riid, ppvObjOut);

	// dead code
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//	  ULONG 	   - the new reference count

ULONG CUnknownObject::CPrivateUnknownObject::AddRef(void)
{
	return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//	  ULONG 		- remaining refs

ULONG CUnknownObject::CPrivateUnknownObject::Release (void)
{
	ULONG cRef = --m_cRef;

	if (!m_cRef)
		delete m_pMainUnknown();

	return cRef;
}


//=--------------------------------------------------------------------------=
// CUnknownObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// objects that are aggregated use this to support additional interfaces.
// they should call this method on their parent so that any of it's interfaces
// are queried.
//
// Parameters:
//	  REFIID		- [in]	interface they want
//	  void **		- [out] where they want to put the resulting object ptr.
//
// Output:
//	  HRESULT		- S_OK, E_NOINTERFACE

HRESULT CUnknownObject::InternalQueryInterface(REFIID riid, void **ppvObjOut)
{
	*ppvObjOut = NULL;

	return E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\unknown.h ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

//=--------------------------------------------------------------------------=
// UNKNOWNOBJECTINFO
//
// if you want a simple co-creatable object, with no other guarantees about
// it, then you need to put the following entry in the global table of objects.
// other object types that are more complex, such as automation objects, and
// controls, will also use this information...

typedef struct {

	const CLSID *rclsid;					// CLSID of your object.	  ONLY USE IF YOU'RE CoCreatable!
	LPCSTR		 pszObjectName; 			// Name of your object. 	  ONLY USE IF YOU'RE CoCreatable!
	IUnknown	*(*pfnCreate)(IUnknown *);	// pointer to creation fn.	  ONLY USE IF YOU'RE CoCreatable!

} UNKNOWNOBJECTINFO;

#define NAMEOFOBJECT(index) 	  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszObjectName)
#define CLSIDOFOBJECT(index)	  (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid))
#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnCreate)

#ifndef INITOBJECTS

#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
extern UNKNOWNOBJECTINFO name##Object \

#else
#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
	UNKNOWNOBJECTINFO name##Object = { clsid, objname, fn } \

#endif // INITOBJECTS


//=--------------------------------------------------------------------------=
// DECLARE_STANDARD_UNKNOWN
//
// All objects that are going to inherit from CUnknown for their IUnknown
// implementation should put this in their class declaration instead of the
// three IUnknown methods.
//
#define DECLARE_STANDARD_UNKNOWN() \
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \
		return ExternalQueryInterface(riid, ppvObjOut); \
	} \
	STDMETHOD_(ULONG, AddRef)(void) { \
		return ExternalAddRef(); \
	} \
	STDMETHOD_(ULONG, Release)(void) { \
		return ExternalRelease(); \
	} \

// global variable where we store the current lock count on our DLL.  This resides
// in InProcServer.Cpp

extern LONG g_cLocks;

//=--------------------------------------------------------------------------=
// this class doesn't inherit from IUnknown since people inheriting from it
// are going to do so, and just delegate their IUnknown calls to the External*
// member functions on this object.  the internal private unknown object does
// need to inherit from IUnknown, since it will be used directly as an IUnknown
// object.

class CUnknownObject
{
public:
	CUnknownObject(IUnknown *pUnkOuter, void *pvInterface)
		: m_pvInterface(pvInterface),
		  m_pUnkOuter((pUnkOuter) ? pUnkOuter : &m_UnkPrivate)
		{  InterlockedIncrement(&g_cLocks); }

	CUnknownObject(IUnknown *pUnkOuter) {
		m_pUnkOuter = pUnkOuter ? pUnkOuter : &m_UnkPrivate;
		InterlockedIncrement(&g_cLocks);
	}
	virtual ~CUnknownObject() { InterlockedDecrement(&g_cLocks); }

	// these are all protected so that classes that inherit from this can
	// at get at them.

protected:
	// IUnknown methods.  these just delegate to the controlling
	// unknown.

	HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) {
		return m_pUnkOuter->QueryInterface(riid, ppvObjOut);
	}
	ULONG ExternalAddRef(void) {
		return m_pUnkOuter->AddRef();
	}
	ULONG ExternalRelease(void) {
		return m_pUnkOuter->Release();
	}

	// people should use this during creation to return their private
	// unknown
	//
	inline IUnknown *PrivateUnknown (void) {
		return &m_UnkPrivate;
	}

	virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

	IUnknown *m_pUnkOuter;			  // outer controlling Unknown
	void	 *m_pvInterface;		  // the real interface we're working with.

private:
	// the inner, private unknown implementation is for the aggregator
	// to control the lifetime of this object, and for those cases where
	// this object isn't aggregated.

	class CPrivateUnknownObject : public IUnknown {
public:
		STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
		STDMETHOD_(ULONG, AddRef)(void);
		STDMETHOD_(ULONG, Release)(void);

		// constructor is remarkably trivial
		//
		CPrivateUnknownObject() : m_cRef(1) {}

private:
		CUnknownObject *m_pMainUnknown();
		ULONG m_cRef;
	} m_UnkPrivate;

	// so they can reference themselves in CUnknownObject from pMainUnknown()

	friend class CPrivateUnknownObject;
};

#endif // _UNKNOWN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\userwait.cpp ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "resource.h"
#include "lockout.h"
#include "userwait.h"
#include "cdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// class constructor 
//
CUWait::CUWait(HWND hwndParent)
{
    m_hwndParent = hwndParent;
    m_hwndUWait = NULL; 
    m_bVisable = FALSE;
    m_bUserCancel = FALSE;

    // create the thread
    //
    LPCTSTR lpDialogTemplate = MAKEINTRESOURCE(IDD_SEARCH_CANCEL);

    m_LockOut.LockOut(hwndParent);

    if(g_bWinNT5)
    {
        CreateDialogParamW(_Module.GetResourceInstance(), MAKEINTRESOURCEW(IDD_SEARCH_CANCEL), m_hwndParent,
            (DLGPROC) CWaitDlgProc, (LPARAM) this);
	}
	else
	{
        CreateDialogParam(_Module.GetResourceInstance(), lpDialogTemplate, m_hwndParent,
            (DLGPROC) CWaitDlgProc, (LPARAM) this);
	}
    
    if(!IsValidWindow(m_hwndUWait))
        m_LockOut.Unlock();    
		
    if(IsValidWindow(m_hwndUWait))
	    ShowWindow(m_hwndUWait, SW_SHOW);

    MSG msg;
    int iCount = 256;
    		
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && iCount--)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

// class destructor
//
CUWait::~CUWait()
{
    // destroy the dialog
    //
    if(m_hwndUWait)
        SendMessage(m_hwndUWait, WM_CLOSE, 0, 0);

    if (IsValidWindow(m_hwndUWait))
        DestroyWindow(m_hwndUWait);
}

// Dialog procedure for search cancel dialog
//
BOOL CALLBACK CWaitDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CUWait* pUWait = (CUWait*) GetWindowLongPtr(hdlg, GWLP_USERDATA);

    switch (msg) {
        case WM_INITDIALOG:

            pUWait = (CUWait*) lParam;
            SetWindowLongPtr(hdlg, GWLP_USERDATA, lParam);
            pUWait->m_hwndUWait = hdlg;

            CenterWindow(pUWait->m_hwndParent, hdlg);

            SetWindowPos(hdlg, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

            return TRUE; 

        case WM_COMMAND:
            {
                switch (LOWORD(wParam))
                {
                    case IDCANCEL:
                        EnableWindow(GetDlgItem(hdlg,IDCANCEL),FALSE);
                        pUWait->m_bUserCancel = TRUE; 
                        break;
                }
            }
            break;

        case WM_CLOSE:
            pUWait->m_bUserCancel = TRUE; 
            pUWait->m_LockOut.Unlock();    
            EndDialog(hdlg, FALSE);
            break;

        default:
            return FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\verdef.h ===
#ifdef HHCTRL
#define IDS_VERSION_STRING		"HTML Help Control Version 4.74.9140"
#endif

#define VERSION 			"4.74.9140"
#define VER_PRODUCTVERSION_STR		"4.74.9140\0"
#define VER_PRODUCTVERSION		4,74,9140,0
#define VER_PRODUCTVERSION_DW		(0x04740000 | 9140)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\vc41warn.h ===
//=--------------------------------------------------------------------------=
// VC41Warn.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several new VC4.1 warnings that trip standard headers
//

// VC4.1 warning about bool
#pragma warning(disable:4237)

// VC4.1 warning - anachronism used
#pragma warning(disable:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\util.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "secwin.h"

#include "strtable.h"
#include "hha_strtable.h"
#include "htmlhelp.h"
#include <commctrl.h>

#include "sitemap.h" // ReplaceEscapes

#include <shlobj.h>  // CSIDL_X defs

// global window type array.
#include "gwintype.h"
#include "cstr.h"

#ifndef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#ifndef _DEBUG
#pragma optimize("a", on)
#endif

#define PT_TO_PIXELS(hdc, pt)  MulDiv(-(pt), GetDeviceCaps(hdc, LOGPIXELSY), 72)

static POINT GetTextSize(HDC hdc, PCSTR qchBuf, int iCount);
static POINT GetTextSizeW(HDC hdc, WCHAR *qchBuf, int iCount);

BOOL IsDigitW(WCHAR ch) { return (ch >= L'0' && ch <= 'L9'); }

int IEColorToWin32Color( PCWSTR pwsz )
{
  // input: "#rrggbb"
  // output: int in hex form of 0xbbggrr
  char sz[9];
  strcpy( sz, "0x" );

  // get blue
  WideCharToMultiByte( CP_ACP, 0, pwsz+5, 2, &(sz[2]), 2, NULL, NULL );

  // get green
  WideCharToMultiByte( CP_ACP, 0, pwsz+3, 2, &(sz[4]), 2, NULL, NULL );

  // get red
  WideCharToMultiByte( CP_ACP, 0, pwsz+1, 2, &(sz[6]), 2, NULL, NULL );

  // null terminate the string
  sz[8] = 0;

  // convert it
  return Atoi( sz );
}

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//

LPWSTR MakeWideStrFromAnsi(LPSTR psz, BYTE  bType)
{
    LPWSTR pwsz;
    int i;

    ASSERT(psz)

    // compute the length of the required BSTR

    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0)
        return NULL;

    // allocate the widestr

    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator

        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;

      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;

      default:
        FAIL("Bogus String Type.");
    }

    if (!pwsz)
        return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}


LPWSTR MakeWideStr(LPSTR psz, UINT codepage)
{
    LPWSTR pwsz;
    int i;

    ASSERT(psz)

    // compute the length of the required BSTR

    i =  MultiByteToWideChar(codepage, 0, psz, -1, NULL, 0);
    if (i <= 0)
        return NULL;

    ++i;
	
    pwsz = (WCHAR *) malloc(i * sizeof(WCHAR));

    if (!pwsz)
        return NULL;
		
    MultiByteToWideChar(codepage, 0, psz, -1, pwsz, i);

    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//

LPWSTR MakeWideStrFromResourceId (WORD    wId, BYTE    bType)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(_Module.GetResourceInstance(), wId, szTmp, 512);
    if (!i)
        return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1,
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2],
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all

BOOL RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    char  szScratch[MAX_PATH];
    long  l;

    // clean out any garbage

    UnregisterUnknownObject(riidObject);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, (ULONG)strlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(_Module.GetModuleInstance(), szScratch, sizeof(szScratch));
    if (!dwPathLen)
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment"));
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// RegisterAutomationObject
//=--------------------------------------------------------------------------=
// given a little bit of information about an automation object, go and put it
// in the registry.
// we add the following information in addition to that set up in
// RegisterUnknownObject:
//
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered

BOOL RegisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    char  szScratch[MAX_PATH];
    long  l;
    DWORD dwDummy;

    // first register the simple Unknown stuff.
    //
    if (!RegisterUnknownObject(pszObjectName, riidObject)) return FALSE;

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
    //
    strcpy(szScratch, pszLibName);
    strcat(szScratch, ".");
    strcat(szScratch, pszObjectName);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "",
                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, (ULONG)strlen(szScratch)+1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!StringFromGuidA(riidObject, szGuidStr))
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, (ULONG)strlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, (ULONG)strlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, (ULONG)strlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, (ULONG)strlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, (ULONG)strlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, (ULONG)strlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkSub, &dwDummy);

    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, (ULONG)strlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);
    return TRUE;

  CleanUp:
    if (hk) RegCloseKey(hkSub);
    if (hk) RegCloseKey(hk);
    return FALSE;
}

//=--------------------------------------------------------------------------=
// RegisterControlObject.
//=--------------------------------------------------------------------------=
// in addition to writing out automation object information, this function
// writes out some values specific to a control.
//
// What we add here:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Control
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\MiscStatus\1 = <MISCSTATUSBITS>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ToolboxBitmap32 = <PATH TO BMP>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = <VERSION>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//    DWORD        - [in] misc status flags for ctl
//    WORD         - [in] toolbox id for control
//
// Output:
//    BOOL
//
// Notes:
//    - not the most terribly efficient routine.
//
BOOL RegisterControlObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    DWORD    dwMiscStatus,
    WORD     wToolboxBitmapId
)
{
    HKEY    hk, hkSub = NULL, hkSub2 = NULL;
    char    szTmp[MAX_PATH];
    char    szGuidStr[GUID_STR_LEN];
    DWORD   dwDummy;
    LONG    l;

    // first register all the automation information for this sucker.
    //
    if (!RegisterAutomationObject(pszLibName, pszObjectName, lVersion, riidLibrary, riidObject)) return FALSE;

    // then go and register the control specific stuff.
    //
    StringFromGuidA(riidObject, szGuidStr);
    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // create the control flag.
    //
    l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    // now set up the MiscStatus Bits...
    //
    RegCloseKey(hkSub);
    hkSub = NULL;
    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    szTmp[0] = '0';
    szTmp[1] = '\0';
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub2, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%d", dwMiscStatus);
    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, (ULONG)strlen(szTmp) + 1);
    RegCloseKey(hkSub2);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    // now set up the toolbox bitmap
    //
    GetModuleFileName(_Module.GetModuleInstance(), szTmp, MAX_PATH);
    wsprintf(szGuidStr, ", %d", wToolboxBitmapId);
    strcat(szTmp, szGuidStr);

    l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, (ULONG)strlen(szTmp) + 1);
    CLEANUP_ON_ERROR(l);

    // now set up the version information
    //
    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%ld.0", lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, (ULONG)strlen(szTmp) + 1);

CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//    - WARNING: this routine will blow away all other keys under the CLSID
//      for this object.  mildly anti-social, but likely not a problem.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuidA(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);

    return f;
}

//=--------------------------------------------------------------------------=
// UnregisterAutomationObject
//=--------------------------------------------------------------------------=
// unregisters an automation object, including all of it's unknown object
// information.
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't get it all unregistered.
//
// Notes:
//
BOOL UnregisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    BOOL f;

    // first thing -- unregister Unknown information
    //
    f = UnregisterUnknownObject(riidObject);
    if (!f) return FALSE;

    // delete everybody of the form:
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> [\] *
    //
    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> [\] *
    //
    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    REFCLSID riidLibrary
)
{
    HKEY hk;
    char szScratch[GUID_STR_LEN];
    long l;
    BOOL f;

    // convert the libid into a string.
    //
    if (!StringFromGuidA(riidLibrary, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);
    return f;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPSTR               - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPSTR   pszSubKey
)
{
    HKEY  hk;
    char  szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;
    int   x;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    x = 0;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, x, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
        x++;
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}


//=--------------------------------------------------------------------------=
// Conversion Routines
//=--------------------------------------------------------------------------=
// the following stuff is stuff used for the various conversion routines.
//
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

static  int     s_iXppli;            // Pixels per logical inch along width
static  int     s_iYppli;            // Pixels per logical inch along height
static  BYTE    s_fGotScreenMetrics; // Are above valid?

//=--------------------------------------------------------------------------=
// GetScreenMetrics
//=--------------------------------------------------------------------------=
// private function we call to set up various metrics the conversion routines
// will use.
//
// Notes:

// BUGBUG: 26-Sep-1997  [ralphw] This will fail miserably if the user changes
// screen resolutions. Doah!

static void GetScreenMetrics (void)
{
    if (s_fGotScreenMetrics)
        return;

    // we want the metrics for the screen

    HDC hdc = CreateIC("DISPLAY", NULL, NULL, NULL);

    ASSERT(hdc);
    s_iXppli = GetDeviceCaps(hdc, LOGPIXELSX);
    s_iYppli = GetDeviceCaps(hdc, LOGPIXELSY);

    DeleteDC( hdc );
    s_fGotScreenMetrics = TRUE;
}

//=--------------------------------------------------------------------------=
// HiMetricToPixel
//=--------------------------------------------------------------------------=
// converts from himetric to Pixels.
//
// Parameters:
//    const SIZEL *        - [in]  dudes in himetric
//    SIZEL *              - [out] size in pixels.
//
// Notes:
//
void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, SIZE* lpSizeInPix)
{
    GetScreenMetrics();

    // We got logical HIMETRIC along the display, convert them to pixel units

    lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, s_iXppli);
    lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// PixelToHiMetric
//=--------------------------------------------------------------------------=
// converts from pixels to himetric.
//
// Parameters:
//    const SIZEL *        - [in]  size in pixels
//    SIZEL *              - [out] size in himetric

void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    GetScreenMetrics();

    // We got pixel units, convert them to logical HIMETRIC along the display

    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, s_iXppli);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// _MakePath
//=--------------------------------------------------------------------------=
// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle.
// not terrilby efficient or smart, but it's registration code, so we don't
// really care.
//
// Notes:
//
void _MakePath
(
    LPSTR pszFull,
    const char * pszName,
    LPSTR pszOut
)
{
    LPSTR psz;
    LPSTR pszLast;

    strcpy(pszOut, pszFull);
    psz = pszLast = pszOut;
    while (*psz) {
        if (*psz == '\\')
            pszLast = AnsiNext(psz);
        psz = AnsiNext(psz);
    }

    // got the last \ character, so just go and replace the name.
    //
    strcpy(pszLast, pszName);
}

/***************************************************************************

    FUNCTION:   GetStringResource

    PURPOSE:    Copy a string resource to a buffer, returning a pointer
                to that buffer

    PARAMETERS:
        idString    -- resource id

    RETURNS:    Pointer to the string containing the buffer

    COMMENTS:
        Note that the same buffer is used each time. You will need to
        duplicate the returned pointer if you need to call this function
        again before the previous value is no longer needed.

***************************************************************************/

PCSTR GetStringResource(int idString)
{
    static TCHAR pszStringBuf[MAX_STRING_RESOURCE_LEN + 1];


	pszStringBuf[0] = 0;

	// special case W2K
	//
	// The purpose of this code is to get the resource string in Unicode 
	// and then convert to ANSI using the UI codepage when running under W2K.
	//
	// The narrow GetStringResource() API fails under MUI configurations
	// due to it using the default system locale rather than the UI locale 
	// for the conversion to ANSI.
	//
	if(g_bWinNT5)
	{
		const WCHAR *pswString = GetStringResourceW(idString);
	    static char pszAnsiStringBuf[MAX_STRING_RESOURCE_LEN + 1];

 		if(pswString)
		{
			DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
			pszAnsiStringBuf[0] = 0;
			WideCharToMultiByte (cp, 0, pswString, -1, pszAnsiStringBuf, sizeof(pszAnsiStringBuf), NULL, NULL);
			return pszAnsiStringBuf;
		}
		else
			return pszStringBuf;
	}

    if (LoadString(_Module.GetResourceInstance(), idString, pszStringBuf, MAX_STRING_RESOURCE_LEN) == 0) {
#ifdef _DEBUG
        wsprintf(pszStringBuf, "invalid string id #%u", idString);
        MsgBox(pszStringBuf);
#endif
        pszStringBuf[0] = '\0';
    }
    return (PCSTR) pszStringBuf;
}

/***************************************************************************

    FUNCTION:   GetStringResource

    PURPOSE:    Copy a string resource to a buffer, returning a pointer
                to that buffer

    PARAMETERS:
        idString    -- resource id
        hInstance   -- resource instance

    RETURNS:    Pointer to the string containing the buffer

    COMMENTS:
        Note that the same buffer is used each time. You will need to
        duplicate the returned pointer if you need to call this function
        again before the previous value is no longer needed.

***************************************************************************/

PCSTR GetStringResource(int idString, HINSTANCE hInstance)
{
    static TCHAR pszStringBuf[MAX_STRING_RESOURCE_LEN + 1];

	pszStringBuf[0] = 0;

	// special case W2K
	//
	// The purpose of this code is to get the resource string in Unicode 
	// and then convert to ANSI using the UI codepage when running under W2K.
	//
	// The narrow GetStringResource() API fails under MUI configurations
	// due to it using the default system locale rather than the UI locale 
	// for the conversion to ANSI.
	//
	if(g_bWinNT5)
	{
		const WCHAR *pswString = GetStringResourceW(idString, hInstance);
	    static char pszAnsiStringBuf[MAX_STRING_RESOURCE_LEN + 1];

 		if(pswString)
		{
			DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
			pszAnsiStringBuf[0] = 0;
			WideCharToMultiByte (cp, 0, pswString, -1, pszAnsiStringBuf, sizeof(pszAnsiStringBuf), NULL, NULL);
			return pszAnsiStringBuf;
		}
		else
			return pszStringBuf;
	}

    if (LoadString(hInstance, idString, pszStringBuf, MAX_STRING_RESOURCE_LEN) == 0) {
#ifdef _DEBUG
        wsprintf(pszStringBuf, "invalid string id #%u", idString);
        MsgBox(pszStringBuf);
#endif
        pszStringBuf[0] = '\0';
    }
    return (PCSTR) pszStringBuf;
}

PCWSTR GetStringResourceW(int idString)
{
    static WCHAR pszStringBuf[MAX_STRING_RESOURCE_LEN + 1];

    if (0 == ::LoadStringW(_Module.GetResourceInstance(), idString, pszStringBuf, MAX_STRING_RESOURCE_LEN))
    {
        if (ERROR_CALL_NOT_IMPLEMENTED == ::GetLastError())
        {
            PCSTR pszA = GetStringResource(idString);
            MultiByteToWideChar(CP_ACP, 0, pszA, -1, pszStringBuf, MAX_STRING_RESOURCE_LEN);
        }
        else
        {
            ASSERT(0); // bad string id, probably
            pszStringBuf[0] = '\0';
        }
    }
    return (PCWSTR) pszStringBuf;
}

// GetStringResourceW
//
PCWSTR GetStringResourceW(int idString, HINSTANCE hInstance)
{
    static WCHAR pszStringBuf[MAX_STRING_RESOURCE_LEN + 1];

    if (0 == ::LoadStringW(hInstance, idString, pszStringBuf, MAX_STRING_RESOURCE_LEN))
    {
        if (ERROR_CALL_NOT_IMPLEMENTED == ::GetLastError())
        {
            PCSTR pszA = GetStringResource(idString, hInstance);
            MultiByteToWideChar(CP_ACP, 0, pszA, -1, pszStringBuf, MAX_STRING_RESOURCE_LEN);
        }
        else
        {
            ASSERT(0); // bad string id, probably
            pszStringBuf[0] = '\0';
        }
    }
    return (PCWSTR) pszStringBuf;
}



/***************************************************************************

    FUNCTION:   Atoi

    PURPOSE:    Convert string to an integer

    PARAMETERS:
        psz

    RETURNS:

    COMMENTS:
        Taken from C runtime code -- this code makes no function calls, and
        assumes there is no such thing as a DBCS number. It will read either
        decimal or hex (preceeded with an 0x)

    MODIFICATION DATES:
        04-Dec-1997 [ralphw]
        15-Aug-1997 [ralphw] Support hex digits

***************************************************************************/

int FASTCALL Atoi(PCSTR psz)
{
    // skip whitespace

    while (*psz == ' ' || *psz == '\t')
        ++psz;

    if (!*psz)
        return 0;

    int c = (int) (unsigned char) *psz++;
    int sign = c;                               // save sign indication
    if (c == '-' || c == '+')
        c = (int) (unsigned char) *psz++;  // skip sign

    int total = 0;

    if (c == '0' && psz[0] == 'x') {
        psz++;  // skip over the 'x'
        c = (int) (unsigned char) *psz++;  // skip sign
        for (;;) {
            if (c >= '0' && c <= '9') {
                total = 16 * total + (c - '0');
                c = (int)(unsigned char)*psz++;
            }
            else if (c >= 'a' && c <= 'f') {
                total = 16 * total + ((c - 'a') + 10);
                c = (int)(unsigned char)*psz++;
            }
            else if (c >= 'A' && c <= 'F') {
                total = 16 * total + ((c - 'A') + 10);
                c = (int)(unsigned char)*psz++;
            }
            else {
                if (sign == '-')
                    return -total;
                else
                    return total;
            }
        }
    }
    while (c >= '0' && c <= '9') {
        total = 10 * total + (c - '0');
        c = (int)(unsigned char)*psz++;
    }

    if (sign == '-')
        return -total;
    else
        return total;
}

void OOM(void)
{
#ifdef _DEBUG
    ASSERT_COMMENT(FALSE, "Out of memory.");
#else
    char szMsg[256];
    LoadString(_Module.GetResourceInstance(), IDS_OOM, szMsg, sizeof(szMsg));

    // Task modal to allow other applications to run. Note that this will
    // disable the caller's windows.

    MessageBox(GetActiveWindow(), szMsg, "", MB_OK | MB_TASKMODAL | MB_ICONHAND);
    ExitProcess((UINT) -1);
#endif
}

int MsgBox(int idString, UINT nType)
{
	if(g_bWinNT5)
	{
    	WCHAR *pszString;
		WCHAR wcString[(MAX_STRING_RESOURCE_LEN + 1) + MAX_PATH + 64];
        WCHAR wcTitle[(MAX_STRING_RESOURCE_LEN + 1) + MAX_PATH + 64];
		wcTitle[0] = 0;
		
    	pszString = (WCHAR *) GetStringResourceW(idString);
    	
    	if(!pszString)
    	{
    #ifdef _DEBUG
            char szMsg[(MAX_STRING_RESOURCE_LEN + 1) + MAX_PATH + 64];
            wsprintf(szMsg, "invalid string id #%u", idString);
            DBWIN(szMsg);
    #endif
            return 0;
        }
		else
		    wcscpy(wcString,pszString);
		
		char *pszTitle = _Resource.MsgBoxTitle();
 		if(pszTitle)
		{
		
			DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
			MultiByteToWideChar(cp, 0, pszTitle, -1, wcTitle, sizeof(wcTitle)); 
        }
        else
            return 0;		
		
        return MessageBoxW(GetActiveWindow(), wcString, wcTitle, nType | g_fuBiDiMessageBox);
    }
	else
    {

    	
    	CStr pszTemp = (char *) GetStringResource(idString);
    	
    	if(!pszTemp.psz)
    	{
    #ifdef _DEBUG
            char szMsg[(MAX_STRING_RESOURCE_LEN + 1) + MAX_PATH + 64];
            wsprintf(szMsg, "invalid string id #%u", idString);
            DBWIN(szMsg);
    #endif
            return 0;
        }
        return MessageBox(GetActiveWindow(), pszTemp, _Resource.MsgBoxTitle(), nType | g_fuBiDiMessageBox);
    }
}

int MsgBox(PCSTR pszMsg, UINT nType)
{
    return MessageBox(GetActiveWindow(), pszMsg, _Resource.MsgBoxTitle(), nType | g_fuBiDiMessageBox);
}

int MsgBox(int idFormatString, PCSTR pszSubString, UINT nType)
{
    CStr csz(idFormatString, pszSubString);
    return MessageBox(GetActiveWindow(), csz.psz, _Resource.MsgBoxTitle(), nType);
}

void AddTrailingBackslash(PSTR psz)
{
    int sPos;

    if (psz != NULL && *psz != '\0') {

        if (g_fDBCSSystem) {
            PSTR pszEnd = psz + strlen(psz);
            if (*(CharPrev(psz, pszEnd)) != '\\' &&
                    *(CharPrev(psz, pszEnd)) != '/' &&
                    *(CharPrev(psz, pszEnd)) != ':') {
                *pszEnd++ = '\\';
                *pszEnd++ = '\0';
            }
        }
        else {
            sPos = (int)strlen(psz) - 1;

            if (psz[sPos] != '\\' && psz[sPos] != '/' && psz[sPos] != ':') {
                psz[sPos + 1] = '\\';
                psz[sPos + 2] = '\0';
            }
        }
    }
}

#if 0
/***************************************************************************

    FUNCTION:   StrChr

    PURPOSE:    DBCS-capable version of strchr

    PARAMETERS:
        pszString
        ch

    RETURNS:    pointer to the character

    COMMENTS:   This can NOT find a DBCS character. It can only be used to
                find a SBCS character imbedded in a DBCS character string.

    MODIFICATION DATES:
        29-Jul-1994 [ralphw]

***************************************************************************/

extern "C" PSTR StrChr(PCSTR pszString, char ch)
{
    if (!g_fDBCSSystem)
        return strchr(pszString, ch);
    while (*pszString) {
        while (IsDBCSLeadByte(*pszString))
            pszString += 2;
        if (*pszString == ch)
            return (PSTR) pszString;
        else if (!*pszString)
            return NULL;
        pszString++;
    }
    return NULL;
}
#endif 

extern "C" PSTR StrRChr(PCSTR pszString, char ch)
{
    PSTR psz = StrChr(pszString, ch);
    PSTR pszLast;

    if (!psz)
        return NULL;
    do {
        pszLast = psz;
        psz = StrChr(pszLast + 1, ch);
    } while (psz);

    return pszLast;
}

extern "C" PSTR FirstNonSpace(PCSTR psz)
{
    // note, for various bits of code to work throughout the HH project,
    // this function cannot return NULL if the first non-space does not exist,
    // instead the caller may count on this function returning non-NULL and
    // thus we need to pass back a pointer to the terminating NULL character
    // instead of simply a NULL value.

    if( !psz /*|| !*psz*/ )
      return NULL;

    if (g_fDBCSSystem) {
        while (!IsDBCSLeadByte(*psz) && (*psz == ' ' || *psz == '\t'))
            psz++;
        return (PSTR) psz;
    }

    while(*psz == ' ' || *psz == '\t')
        psz++;
    return (PSTR) psz;
}

WCHAR *FirstNonSpaceW(WCHAR *psz)
{
    // note, for various bits of code to work throughout the HH project,
    // this function cannot return NULL if the first non-space does not exist,
    // instead the caller may count on this function returning non-NULL and
    // thus we need to pass back a pointer to the terminating NULL character
    // instead of simply a NULL value.

    if( !psz /*|| !*psz*/ )
      return NULL;

    while(*psz == L' ' || *psz == L'\t')
        psz++;
    return psz;
}

PSTR SzTrimSz(PSTR pszOrg)
{
    if (!pszOrg)
        return NULL;

    // Skip over leading whitespace

    if (g_fDBCSSystem) {
        PSTR psz = pszOrg;
        while (!IsDBCSLeadByte(*psz) && IsSpace(*psz))
            psz++;
        if (psz != pszOrg)
            strcpy(pszOrg, psz);
    }

    else if (IsSpace(*pszOrg))
        strcpy(pszOrg, FirstNonSpace(pszOrg));

    RemoveTrailingSpaces(pszOrg);

    return pszOrg;
}

void RemoveTrailingSpaces(PSTR pszString)
{
    if (!g_fDBCSSystem) {
        PSTR psz = pszString + strlen(pszString) - 1;

        while (IsSpace(*psz)) {
            if (--psz <= pszString) {
                *pszString = '\0';
                return;
            }
        }
        psz[1] = '\0';
    }
    else {

        /*
         * Removing trailing spaces in DBCS requires stepping through
         * from the beginning of the string since we can't know if a
         * trailing space is really a space or the second byte of a lead
         * byte.
         */
        PSTR psz = pszString + strlen(pszString) - 1;
        while (IsSpace(*psz) && psz > pszString + 2 &&
                !IsDBCSLeadByte(psz[-1])) {
            if (--psz <= pszString) {
                *pszString = '\0';
                return;
            }
        }
        psz[1] = '\0';
    }
}

/***************************************************************************

    FUNCTION:   GetLeftOfEquals

    PURPOSE:    Allocate a string and copy everything to the left of the
                equal character to that string. If there is no equal character,
                return NULL.

    PARAMETERS:
        pszString   --  note that we do actually modify this string, but we
                        restore it before returning, hence we use PCSTR
                        so the compiler thinks it is unmodified.

    RETURNS:    Allocated memory or NULL

    COMMENTS:
        DBCS enabled. A backslash character may be used to escape (ignore)
        the equals character.

    MODIFICATION DATES:
        07-Jul-1997 [ralphw]

***************************************************************************/

PSTR GetLeftOfEquals(PCSTR pszString)
{
    PSTR pszEqual = (PSTR) FindEqCharacter(pszString);
    if (!pszEqual)
        return NULL;
    *pszEqual = '\0';

    PSTR pszLeft = (PSTR) lcStrDup(pszString);
    RemoveTrailingSpaces(pszLeft);
    *pszEqual = '=';
    return pszLeft;
}

/***************************************************************************

    FUNCTION:   FindEqCharacter

    PURPOSE:    Return a pointer to the '=' character in a line

    PARAMETERS:
        pszLine

    RETURNS:    Pointer to '=' or NULL if there is no '='

    COMMENTS:
        We DO modify pszLine in spite of it's being marked as PCSTR, but
        we always put it back the way we found it before returning. So, you
        can't use this function on a string stored in a code segment.

    MODIFICATION DATES:
        10-Jul-1997 [ralphw]

***************************************************************************/

PCSTR FindEqCharacter(PCSTR pszLine)
{
    PSTR pszEqual = (PSTR) pszLine;
    for (;;) {
        pszEqual = StrChr(pszEqual, '=');
        if (!pszEqual)
            return NULL;
        *pszEqual = '\0';

        /*
         * We need to find out if the previous character was a backslash.
         * You can't back up in a DBCS string, so we just start from the
         * first and search for the last backslash. Don't be fooled into
         * thinking CharPrev() will do the trick -- it will, but by doing
         * the same thing we do here more efficiently (start from the
         * beginning of the string).
         */

        PSTR pszBackSlash = StrRChr(pszLine, '\\');
        if (pszBackSlash && pszBackSlash == (pszEqual - 1)) {
            *pszEqual = '='; // put the character back
            pszEqual++;
            continue; // keep looking;
        }

        *pszEqual = '=';    // put the character back
        return pszEqual;
    }
}

/***************************************************************************

    FUNCTION:   Itoa

    PURPOSE:    Convert a positive interger to a base 10 string

    PARAMETERS:
        val
        pszDst

    RETURNS:

    COMMENTS:
        Taken from C runtime code, modified for speed and size

    MODIFICATION DATES:
        04-Dec-1997 [ralphw]

***************************************************************************/

void FASTCALL Itoa(int val, PSTR pszDst)
{
    if (val < 0) {
        *pszDst++ = '-';
        val = abs(val);
    }
    PSTR firstdig = pszDst;  // save pointer to first digit

    do {
        *pszDst++ = ((char) (val % 10)) + '0';
        val /= 10;  // get next digit
    } while (val > 0);

    /*
     * We now have the digit of the number in the buffer, but in reverse
     * order. Thus we reverse them now.
     */

    *pszDst-- = '\0';        // terminate string; p points to last digit

    do {
        char temp = *pszDst;
        *pszDst = *firstdig;
        *firstdig = temp;   // swap *p and *firstdig
        --pszDst;
        ++firstdig;         // advance to next two digits
    } while (firstdig < pszDst); // repeat until halfway
}

#if 0
/***************************************************************************

    FUNCTION:   stristr

    PURPOSE:    Case-insensitive search for a sub string in a main string

    PARAMETERS:
        pszMain
        pszSub

    RETURNS:

    COMMENTS:
        Not tested

    MODIFICATION DATES:
        28-Mar-1994 [ralphw]

***************************************************************************/

// REVIEW: should replace this with a version that doesn't use CompareString,
// since this function is typically used to parse sitemap files -- the object
// names of a sitemap file will always be in english.

extern "C"
PSTR stristr(PCSTR pszMain, PCSTR pszSub)
{
    if (!pszMain || !pszSub)
        return NULL;
    PSTR pszCur = (PSTR) pszMain;
    char ch = ToLower(*pszSub);
    int cb = strlen(pszSub);

    if (g_fDBCSSystem) {
        for (;;) {
            while (ToLower(*pszCur) != ch && *pszCur)
                pszCur = CharNext(pszCur);
            if (!*pszCur)
                return NULL;
            if (CompareString(g_lcidSystem, NORM_IGNORECASE,
                    pszCur, cb,  pszSub, cb) == 2)
                return pszCur;
            pszCur = CharNext(pszCur);
        }
    }
    else {
        for (;;) {
            while (ToLower(*pszCur) != ch && *pszCur)
                pszCur++;
            if (!*pszCur)
                return NULL;
            if (CompareString(g_lcidSystem, NORM_IGNORECASE,
                    pszCur, cb,  pszSub, cb) == 2)
                return pszCur;
            pszCur++;
        }
    }
}
#endif

// NOTE: this only works with Unicode strings

BOOL IsSamePrefix(PCWSTR pwszMainIn, PCWSTR pwszSubIn, int cchPrefix)
{
  if( !pwszMainIn || !pwszSubIn )
    return FALSE;

  const WCHAR* pwszMain = pwszMainIn;
  const WCHAR* pwszSub  = pwszSubIn;

  if( cchPrefix == -1 )
    cchPrefix = lstrlenW(pwszSub);

  // convert both to lowercase and then compare the first few characters
  // in pwszSub to pwszMain
  while( cchPrefix-- ) {

    // if we hit the end of the strings, quit and return 
    // TRUE if both NULL or FALSE otherwise
    if( !(*pwszSub) || !(*pwszMain) ) {
      if( (*pwszSub) == (*pwszMain) )
        return TRUE;
      else
        return FALSE;
    }

    WCHAR wchSub = *(pwszSub++);
    WCHAR wchMain = *(pwszMain++);

    CharLowerW( &wchSub );
    CharLowerW( &wchMain );

    // if not the same then quit and return FALSE
    if( wchSub != wchMain )
      return FALSE;
  }
  return TRUE;
}


// NOTE: this only works with ANSI strings

BOOL IsSamePrefix(PCSTR pszMain, PCSTR pszSub, int cbPrefix)
{
    if (!pszMain || !pszSub)
        return FALSE;

    if (cbPrefix == -1)
        cbPrefix = (int)strlen(pszSub);

    int f, l;
    while (cbPrefix--) {
        if (((f = (BYTE) (*(pszMain++))) >= 'A') && (f <= 'Z'))
            f -= 'A' - 'a';

        if (((l = (BYTE) (*(pszSub++))) >= 'A') && (l <= 'Z'))
            l -= 'A' - 'a';

        if (f != l)
            return FALSE;
        else if (!f)
            return (f == l);
    }
    return TRUE;
}

#ifndef _DEBUG
#pragma optimize("t", on)
#endif

int FASTCALL CompareIntPointers(const void *pval1, const void *pval2)
{
#ifdef _DEBUG
    int val1 = *(int*) pval1;
    int val2 = *(int*) pval2;
#endif
    return *(int*) pval1 - *(int*) pval2;
}

/*
 * this parameter defines the cutoff between using quick sort and insertion
 * sort for arrays; arrays with lengths shorter or equal to the below value
 * use insertion sort
 */

#define CUTOFF 8        // testing shows that this is good value

void INLINE Swap(void* pb1, void* pb2, UINT width)
{
    BYTE tmp[256];
    ASSERT(width < sizeof(tmp));
    CopyMemory(tmp, pb1, width);
    CopyMemory(pb1, pb2, width);
    CopyMemory(pb2, tmp, width);
}

static void InsertionSort(char *lo, char *hi, unsigned width,
    int (FASTCALL *compare)(const void *, const void *))
{
    char *p, *max;

    /*
     * Note: in assertions below, i and j are alway inside original bound
     * of array to sort.
     */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo + width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (compare(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        Swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        // A[i] <= A[j] for i <= j, j > hi, loop top condition established
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}

void QSort(void *pbase, UINT num, UINT width,
    int (FASTCALL *compare)(const void *, const void *))
{
    char *lo, *hi;              // ends of sub-array currently sorting
    char *mid;                  // points to middle of subarray
    char *loguy, *higuy;        // traveling pointers for partition step
    unsigned size;              // size of the sub-array
    char *lostk[30], *histk[30];
    int stkptr;         // stack for saving sub-array to be processed

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (num < 2 || width == 0)
        return;                 // nothing to do

    stkptr = 0;                 // initialize stack

    lo = (char*) pbase;
    hi = (char *) pbase + width * (num-1);      // initialize limits

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       prserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (unsigned)((hi - lo) / width + 1);               // number of el's to sort

    // below a certain size, it is faster to use a O(n^2) sorting method

    if (size <= CUTOFF) {
         InsertionSort(lo, hi, width, compare);
    }
    else {
        /*
         * First we pick a partititioning element. The efficiency of the
         * algorithm demands that we find one that is approximately the
         * median of the values, but also that we select one fast. Using the
         * first one produces bad performace if the array is already sorted,
         * so we use the middle one, which would require a very wierdly
         * arranged array for worst case performance. Testing shows that a
         * median-of-three algorithm does not, in general, increase
         * performance.
         */

        mid = lo + (size / 2) * width;      // find middle element
        Swap(mid, lo, width);               // swap it to beginning of array

        /*
         * We now wish to partition the array into three pieces, one
         * consisiting of elements <= partition element, one of elements
         * equal to the parition element, and one of element >= to it. This
         * is done below; comments indicate conditions established at every
         * step.
         */

        loguy = lo;
        higuy = hi + width;

        /*
         * Note that higuy decreases and loguy increases on every
         * iteration, so loop must terminate.
         */

        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi + 1,
               A[i] <= A[lo] for lo <= i <= loguy,
               A[i] >= A[lo] for higuy <= i <= hi */

            do  {
                loguy += width;
            } while (loguy <= hi && compare(loguy, lo) <= 0);

            /* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[lo] */

            do  {
                higuy -= width;
            } while (higuy > lo && compare(higuy, lo) >= 0);

            /* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
               either higuy <= lo or A[higuy] < A[lo] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy <= lo, then we would have exited, so
               A[loguy] > A[lo], A[higuy] < A[lo],
               loguy < hi, highy > lo */

            Swap(loguy, higuy, width);

            /* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
               of loop is re-established */
        }

        /*     A[i] >= A[lo] for higuy < i <= hi,
               A[i] <= A[lo] for lo <= i < loguy,
               higuy < loguy, lo <= higuy <= hi
           implying:
               A[i] >= A[lo] for loguy <= i <= hi,
               A[i] <= A[lo] for lo <= i <= higuy,
               A[i] = A[lo] for higuy < i < loguy */

        Swap(lo, higuy, width);         // put partition element in place

        /* OK, now we have the following:
              A[i] >= A[higuy] for loguy <= i <= hi,
              A[i] <= A[higuy] for lo <= i < higuy
              A[i] = A[lo] for higuy <= i < loguy    */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy-1] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           // save big recursion for later

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           // do small recursion
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               // save big recursion for later
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           // do small recursion
            }
        }
    }

    /*
     * We have sorted the array, except for any pending sorts on the
     * stack. Check if there are any, and do them.
     */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           // pop subarray from stack
    }
    else
        return;                 // all subarrays done
}

// C Runtime stuff

int __cdecl _purecall()
{
#ifdef _DEBUG
    DebugBreak();
#endif
    return 0;
}

/***************************************************************************

    FUNCTION:   MoveClientWindow

    PURPOSE:    Moves a child window using screen coordinates

    PARAMETERS:
        hwndParent
        hwndChild
        prc         - rectangle containing coordinates
        fRedraw

    RETURNS:

    COMMENTS:
        This function is similar to MoveWindow, only it expects the
        coordinates to be in screen coordinates rather then client
        coordinates. This makes it possible to use functions like
        GetWindowRect() and use the values directly.

    MODIFICATION DATES:
        25-Feb-1992 [ralphw]

***************************************************************************/

BOOL MoveClientWindow(HWND hwndParent, HWND hwndChild, const RECT *prc, BOOL fRedraw)
{
    POINT pt;
    pt.x = pt.y = 0;

    ScreenToClient(hwndParent, &pt);

    return SetWindowPos(hwndChild, NULL, prc->left + pt.x, prc->top + pt.y,
        RECT_WIDTH(prc), RECT_HEIGHT(prc),
        (fRedraw ? (SWP_NOZORDER | SWP_NOACTIVATE) :
        (SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW)));
}

HWND FindTopLevelWindow(HWND hwnd)
{
    HWND hwndParent = hwnd;
    while (IsValidWindow(hwndParent)) {
        char szClass[256];
        GetClassName(hwndParent, szClass, sizeof(szClass));
        if (IsSamePrefix(szClass, "IEFrame", -2) ||
                IsSamePrefix(szClass, txtHtmlHelpWindowClass, -2))
            return hwndParent;
        hwndParent = GetParent(hwndParent);
    }
    return hwnd;    // no parent found
}

void ConvertBackSlashToForwardSlash(PSTR pszUrl)
{
   PSTR psz;

   if ( !(psz = pszUrl) )
      return;
   //
   // <mc>
   // I added the code to terminate the loop when we encounter a '#' char because that designates
   // an anchor name or reference. We cannot modify this part of the URL without breaking the link.
   // We have to respect the way the anchor is marked up in the HTM. I made this fix for bug#2058
   // 12-15-97.
   // </mc>
   //
   while (*psz && *psz != '#' )
   {
      if ( *psz == '\\' )
         *psz = '/';
      psz = AnsiNext(psz);
   }
}
//////////////////////////////////////////////////////////////////////////
//
// GetParentSize
//
/*
    This function is used by the navigation panes to get the size of the
    area with which they have to work.
*/
HWND GetParentSize(RECT* prcParent, HWND hwndParent, int padding, int navpos)
{
    GetClientRect(hwndParent, prcParent);
    if (padding)
    {
        InflateRect(prcParent, -padding, -padding);
    }
    char szClass[256];
    GetClassName(hwndParent, szClass, sizeof(szClass)); // NOTE: The tab control is note the parent of the panes. The Navigation window is.
    if (IsSamePrefix(szClass, WC_TABCONTROL, -2))
    {
        // Get the dimensions of a tab.
        RECT rectTab ;
        TabCtrl_GetItemRect(hwndParent, 0, &rectTab) ;
        int RowCount = TabCtrl_GetRowCount( hwndParent );
        switch (navpos) {
            case HHWIN_NAVTAB_TOP:
                prcParent->top += RECT_HEIGHT(rectTab)*RowCount;
                break;

            case HHWIN_NAVTAB_LEFT:
                prcParent->left += RECT_WIDTH(rectTab);
                InflateRect(prcParent, 0, 2);   // need less space top/bottom
                break;

            case HHWIN_NAVTAB_BOTTOM:
                prcParent->bottom -= RECT_HEIGHT(rectTab)*RowCount;
                break;
        }
        // The following is used by the index and search tabs.
        // I think that there has to be a better way.
        hwndParent = GetParent(hwndParent);
    }
    else if (padding)
    {
        //InflateRect(prcParent, padding, padding);

        // If there is no tab control, we need to add some space to clear the top edge.
        prcParent->top += GetSystemMetrics(SM_CYSIZEFRAME)*2 ; //TODO: Centralize.
    }
    return hwndParent ;
}

// pszFont == "facename, pointsize, charset, color and attributes"
//
// color or attributes: 0x??? == specifies a standard win32 COLORREF DWORD == 0xbbggrr
//                      #???  == specifies an IE color in the form #rrggbb.
//
HFONT CreateUserFont(PCSTR pszFont, COLORREF* pclrFont, HDC hDC, INT charset)
{
    LOGFONT logfont;
    ZERO_STRUCTURE(logfont);
    logfont.lfWeight = FW_NORMAL;
    logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    logfont.lfCharSet = 0xff;  // lfCharSet is unsigned (don't use -1).

    if( pclrFont )
      *pclrFont = CLR_INVALID;

    // facename[, point size[, charset[, color[, BOLD | ITALIC | UNDERLINE]]]]

    CStr cszFont(pszFont);  // make a copy so that we can change it
    PSTR pszComma = StrChr(cszFont, ',');
    int ptSize = 12;

    if (pszComma){
        *pszComma = '\0';   // So the facename is isolated
        pszComma = FirstNonSpace(pszComma + 1);    // get the point size
        if (IsDigit(*pszComma))
            ptSize = Atoi(pszComma);

        pszComma = StrChr(pszComma, ',');
        if (pszComma) {
            pszComma = FirstNonSpace(pszComma + 1);    // get the charset
            if (IsDigit(*pszComma))
                logfont.lfCharSet = (BYTE)Atoi(pszComma);

            pszComma = StrChr(pszComma, ',');
            if (pszComma) {                         // get color or attribs

                // Get the font attributes first
                pszComma = FirstNonSpace(pszComma + 1);

                if (stristr(pszComma, "BOLD"))
                    logfont.lfWeight = FW_BOLD;
                if (stristr(pszComma, "ITALIC"))
                    logfont.lfItalic = TRUE;
                if (stristr(pszComma, "UNDERLINE"))
                    logfont.lfUnderline = TRUE;

                // may be a color value instead, if so, save the color
                // an repeat this check go fetch the attributes
                if( stristr( pszComma, "#" ) ) { // IE color
                  //*(pszComma+7) = 0;
                  // IE Color
                  CWStr pwszColor = pszComma;
                  if( pclrFont )
                    *pclrFont = IEColorToWin32Color( pwszColor.pw );
                }
                else if( stristr( pszComma, "0x" )  || stristr( pszComma, "0X" )  ) {
                  //*(pszComma+8) = 0;
                  // Win32 Color
                  if( pclrFont )
                    *pclrFont = Atoi( pszComma );
                }


            }

        }
    }
    lstrcpyn(logfont.lfFaceName, cszFont, LF_FACESIZE);

    // REVIEW: we could special-case some common font names to get the
    // correct font family for logfont.lfPitchAndFamily
    logfont.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality        = DEFAULT_QUALITY;

    // Deal with charset...
    //
    if ( charset != -1 )
       logfont.lfCharSet = (BYTE)charset;
    else
    {
       if ( logfont.lfCharSet == 0xff)
       {
          if (isSameString(cszFont, "Symbol") || isSameString(cszFont, "WingDings"))
              logfont.lfCharSet = SYMBOL_CHARSET;
          else
          {
              HWND hwndDesktop = GetDesktopWindow();
              HDC hdc = GetDC(hwndDesktop);
              if (hdc) {
                  TEXTMETRIC tm;
                  GetTextMetrics(hdc, &tm);
                  logfont.lfCharSet = tm.tmCharSet;
                  ReleaseDC(hwndDesktop, hdc);
              }
              else
                  logfont.lfCharSet = ANSI_CHARSET; // REVIEW: should use the current system charset
          }
       }
    }

    // fix for Whistler bug #8123
    //
    if(PRIMARYLANGID(LANGIDFROMLCID(GetSystemDefaultLCID())) == LANG_THAI && g_bWinNT5 && ptSize < 11)
       ptSize = 11;


    LONG dyHeight;
    if (! hDC )
    {
       hDC = CreateIC("DISPLAY", NULL, NULL, NULL);
       dyHeight = MulDiv(GetDeviceCaps(hDC, LOGPIXELSY), ptSize * 2, 144);
       DeleteDC(hDC);
    }
    else
       dyHeight = MulDiv(GetDeviceCaps(hDC, LOGPIXELSY), ptSize * 2, 144);

    logfont.lfHeight = -dyHeight;
    return CreateFontIndirect(&logfont);
}

// pszFont == "facename, pointsize, charset, color and attributes"
//
// color or attributes: 0x??? == specifies a standard win32 COLORREF DWORD == 0xbbggrr
//                      #???  == specifies an IE color in the form #rrggbb.
//
HFONT CreateUserFontW(WCHAR *pwzFont, COLORREF* pclrFont, HDC hDC, INT charset)
{
    LOGFONTW logfont;
    ZERO_STRUCTURE(logfont);
    logfont.lfWeight = FW_NORMAL;
    logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    logfont.lfCharSet = -1;

    if( pclrFont )
      *pclrFont = CLR_INVALID;

    // facename[, point size[, charset[, color[, BOLD | ITALIC | UNDERLINE]]]]

    
    WCHAR *cwzFont = _wcsdup(pwzFont);  // make a copy so that we can change it
    WCHAR *pwzComma = wcschr(cwzFont, L',');
    int ptSize = 12;

    if (pwzComma){
        *pwzComma = '\0';   // So the facename is isolated
        pwzComma = FirstNonSpaceW(pwzComma + 1);    // get the point size
        if (IsDigitW(*pwzComma))
            ptSize = _wtoi(pwzComma);

        pwzComma = wcschr(pwzComma, L',');
        if (pwzComma) 
        {
            pwzComma = FirstNonSpaceW(pwzComma + 1);    // get the charset
            if (IsDigitW(*pwzComma))
                logfont.lfCharSet = (BYTE)_wtoi(pwzComma);

            pwzComma = wcschr(pwzComma, L',');
            if (pwzComma) 
            {                         // get color or attribs

                // Get the font attributes first
                pwzComma = FirstNonSpaceW(pwzComma + 1);

                if (wcsstr(pwzComma, L"BOLD"))
                    logfont.lfWeight = FW_BOLD;
                if (wcsstr(pwzComma, L"ITALIC"))
                    logfont.lfItalic = TRUE;
                if (wcsstr(pwzComma, L"UNDERLINE"))
                    logfont.lfUnderline = TRUE;

                // may be a color value instead, if so, save the color
                // an repeat this check go fetch the attributes
                if( wcsstr( pwzComma, L"#" ) ) { // IE color
                  //*(pszComma+7) = 0;
                  // IE Color
                    *pclrFont = IEColorToWin32Color( pwzComma);
                }
                else if( wcsstr( pwzComma, L"0x" )  || wcsstr( pwzComma, L"0X" )  ) 
                {
                  //*(pszComma+8) = 0;
                  // Win32 Color
                  if( pclrFont )
                    *pclrFont = _wtoi( pwzComma );
                }
            }
        }
    }
    wcsncpy(logfont.lfFaceName, cwzFont, LF_FACESIZE);

    // REVIEW: we could special-case some common font names to get the
    // correct font family for logfont.lfPitchAndFamily
    logfont.lfOutPrecision   = OUT_DEFAULT_PRECIS;
    logfont.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
    logfont.lfQuality        = DEFAULT_QUALITY;

    // Deal with charset...
    //
    if ( charset != -1 )
       logfont.lfCharSet = (BYTE)charset;
    else
    {
       if ( logfont.lfCharSet == -1 )
       {
          if (!wcsicmp(cwzFont, L"Symbol") || !wcsicmp(cwzFont, L"WingDings"))
              logfont.lfCharSet = SYMBOL_CHARSET;
          else
          {
              HWND hwndDesktop = GetDesktopWindow();
              HDC hdc = GetDC(hwndDesktop);
              if (hdc) {
                  TEXTMETRIC tm;
                  GetTextMetrics(hdc, &tm);
                  logfont.lfCharSet = tm.tmCharSet;
                  ReleaseDC(hwndDesktop, hdc);
              }
              else
                  logfont.lfCharSet = ANSI_CHARSET; // REVIEW: should use the current system charset
          }
       }
    }

    LONG dyHeight;
    if (! hDC )
    {
       hDC = CreateIC("DISPLAY", NULL, NULL, NULL);
       dyHeight = MulDiv(GetDeviceCaps(hDC, LOGPIXELSY), ptSize * 2, 144);
       DeleteDC(hDC);
    }
    else
       dyHeight = MulDiv(GetDeviceCaps(hDC, LOGPIXELSY), ptSize * 2, 144);

    logfont.lfHeight = -dyHeight;
	
	free(cwzFont);
	
    return CreateFontIndirectW(&logfont);
}


/***************************************************************************

    FUNCTION:   CreateFolder

    PURPOSE:    Create a directory, even if it means creating several
                subdirectories

    PARAMETERS:
        pszPath

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        31-Oct-1996 [ralphw]

***************************************************************************/

BOOL CreateFolder(PCSTR pszPath)
{
    CStr cszPath(pszPath);  // copy it so that we can change it

    if (CreateDirectory(cszPath, NULL))
        return TRUE;

    PSTR psz = StrRChr(cszPath, CH_BACKSLASH);
    if (!psz) {
        psz = StrRChr(cszPath, '/');
        if (!psz)
            return FALSE;
    }
    *psz = '\0';
    BOOL fResult = CreateFolder(cszPath);
    *psz = CH_BACKSLASH;
    return CreateDirectory(cszPath, NULL);
}

BOOL GetHighContrastFlag(void)
{
    HIGHCONTRAST highcontrast;

    highcontrast.cbSize = sizeof(highcontrast);

    if (SystemParametersInfo(SPI_GETHIGHCONTRAST,
            sizeof(highcontrast),
            &highcontrast, FALSE)) {
        return (highcontrast.dwFlags & HCF_HIGHCONTRASTON);
    }
    else
        return FALSE;
}

#if 0
BOOL IsValidString(LPCWSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrW(lpsz, nLength) == 0;
}

BOOL IsValidString(LPCSTR lpsz, int nLength)
{
    if (lpsz == NULL)
        return FALSE;
    return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

#endif

void ConvertSpacesToEscapes(PCSTR pszSrc, CStr* pcszDst)
{
    int cbAlloc = pcszDst->SizeAlloc();
    if (!cbAlloc)
        pcszDst->ReSize(cbAlloc = (int)(strlen(pszSrc) + 128));
    int dstPos = 0;
    if (!pszSrc) {
        *pcszDst = "";
        return;
    }
    int cbSrc = (int)strlen(pszSrc);
    while (*pszSrc) {
        if (*pszSrc == ' ') {
            if ((size_t) cbAlloc - dstPos <= 4)
                pcszDst->ReSize(cbAlloc += 128);
            strcpy(pcszDst->psz + dstPos, "%20");
            dstPos += (int)strlen("%20");
            pszSrc++;
        }
        else
            pcszDst->psz[dstPos++] = *pszSrc++;
        if (cbAlloc <= dstPos)
            pcszDst->ReSize(cbAlloc += 128);
    }
    pcszDst->psz[dstPos] = '\0';
}

static const char txtItsExtension[] = ".its";

/***************************************************************************

    FUNCTION:   IsCompiledURL

    PURPOSE:    Determines if a specified URL represents one of our compiled
                files.

    PARAMETERS:
        pszURL - URL to check

    RETURNS:

        TRUE if so, otherwise FALSE.

    COMMENTS:

      Unlike IsCompiledHtmlFile, this function does not have any side
      effects--the way God intended all IsX functions to be!

    MODIFICATION DATES:
        02-Jan-1998 [paulti]

***************************************************************************/

BOOL IsCompiledURL( PCSTR pszURL )
{
  //  Check to see if the pszURL is prefixed with the moniker information.
  if( IsSamePrefix(pszURL, txtMkStore, (int)strlen(txtMkStore) - 1) ||
      IsSamePrefix(pszURL, txtMsItsMoniker, (int)strlen(txtMsItsMoniker) - 1) ||
      IsSamePrefix(pszURL, txtItsMoniker, (int)strlen(txtItsMoniker) - 1)) {
    return TRUE;
  }

  // TODO: do we want to verify this further?  We could do an existence
  //       check or make sure the URL is formulated correctly.  However,
  //       doing such will just introduce more overhead.

  return FALSE;
}

/***************************************************************************

    FUNCTION:   GetURLType

    PURPOSE:    Determines what type of URL we have.

    PARAMETERS:
        pszURL - URL to check

    RETURNS:

        HH_URL_PREFIX_LESS if of the form: my.chm::/my.htm
        HH_URL_UNQUALIFIED if of the form: mk@MSITStore:my.chm::/my.htm
        HH_URL_QUALIFIED   if of the form: mk@MSITStore:c:\my.chm::/my.htm
        HH_URL_JAVASCRIPT  if of the form: javascript:...
        HH_URL_UNKNOWN     if of an unknown form (just pass these along)

    COMMENTS:

      The unknown URL type is basically a non-HTML Help URL that
      should remain unprocessed!

    MODIFICATION DATES:
        11-Jun-1998 [paulti] created
        29-Oct-1998 [paulti] added ms-its:http://some.server.com/... check
        18-Nov-1998 [paulti] added //255.255.255.255 check

***************************************************************************/

UINT GetURLType( PCSTR pszURL )
{
  // bail out if we are passed a NULL value
  if( !pszURL || !*pszURL )
    return HH_URL_UNKNOWN;

  // check if it is a javascript
  if( !StrNCmpI(pszURL, "javascript:", 11) )
    return HH_URL_JAVASCRIPT;

  UINT uiReturn = HH_URL_UNKNOWN;

  // check if the URL contains a ".chm" string
  PSTR pszExt = NULL;
  if( (uiReturn == HH_URL_UNKNOWN) && (pszExt = stristr(pszURL, txtDefExtension)) ) {

    PSTR pszChm = (PSTR) pszURL;
    uiReturn = HH_URL_UNQUALIFIED;

    //  Check to see if the pszURL is prefixed with the moniker information.
    // if it is then we will call is this a unqualified URL (and will prove
    // if it is really qualified later).
    if( IsSamePrefix(pszURL, txtMkStore, (int)strlen(txtMkStore) - 1) )
       pszChm += strlen(txtMkStore);
    else if ( IsSamePrefix(pszURL, txtMsItsMoniker, (int)strlen(txtMsItsMoniker) - 1) )
       pszChm += strlen(txtMsItsMoniker);
    else if ( IsSamePrefix(pszURL, txtItsMoniker, (int)strlen(txtItsMoniker) - 1))
       pszChm += strlen(txtItsMoniker);
    else
      uiReturn = HH_URL_PREFIX_LESS;

    // if prefix less lets make sure it really is just prefixed with
    // a simple chm filename instead of some other bizarre URL that does
    // contain .chm somewhere in the middle
    if( uiReturn == HH_URL_PREFIX_LESS ) {
      PSTR psz = (PSTR) pszURL;
      while( psz != pszExt ) {
        if( *psz == ':' || *psz == '\\' || *psz == '/' ) {
          uiReturn = HH_URL_UNKNOWN;
          break;
        }
        psz++;
      }
    }

    // if unqualified, check if it is really qualified or not
    // if it begins with "X:" or "\\" then it is qualified
    // if it is not qualified but contains a '/' or a '\' and the .chm 
    // extention then it is unknown (probably of the for:"
    // ms-its:http://some.server.com/some/file.chm::some.stream.htm
    if( uiReturn == HH_URL_UNQUALIFIED ) {
      PSTR psz = (PSTR) ((DWORD_PTR)pszChm+1);
      if( *psz == ':' || *psz == '\\' || *psz == '/' ) {

        // make sure it is not of the type:
        // ms-its:\\172.30.161.112\shared\boof\oops.chm::/source/Adam_nt.html
        // if it is, call it unknown
        BOOL bTCPIPServer = FALSE;
        for( psz++; psz && *psz != '\\' && *psz != '/'; psz++ ) {
          if( isdigit( *psz ) )
            bTCPIPServer = TRUE;
          else if( *psz == '.' )
            bTCPIPServer = TRUE;
          else {
            bTCPIPServer = FALSE;
            break;
          }
        }

        if( bTCPIPServer ) {
          uiReturn = HH_URL_UNKNOWN;
        }
        else {
          uiReturn = HH_URL_QUALIFIED;
        }
      }
      else { 
        // seek to the first slash/backslash--if .chm is after this then
        // we have an unknown type possibly of the form:
        // ms-its:http://some.server.com/some/file.chm::some.stream.htm       
        PSTR pszSlash = strstr( psz, "/" );
        if( !pszSlash )
          pszSlash = strstr( psz, "\\" );
        if( pszSlash && (pszSlash <= pszExt) ) {
          uiReturn = HH_URL_UNKNOWN;
        }
      }

    }

  }

  return uiReturn;
}


/***************************************************************************

    FUNCTION:   IsCompiledHtmlFile

    PURPOSE:    Determines if a compiled HTML file is specified. If
                pcszFile is specified, and pszFile does not begin with a
                moniker, then we find the compiled HTML file before
                returning.

    PARAMETERS:
        pszFile
        pcszFile --- If this parameter is null, we don't attempt to find.

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        03-Jun-1997 [ralphw]

***************************************************************************/

BOOL IsCompiledHtmlFile(PCSTR pszFile, CStr* pcszFile)
{
    //--- Check to see if the pszFile is prefixed with the moniker information.
    if ( IsCompiledURL(pszFile) ) {
        if (pcszFile)
            *pcszFile = pszFile;
        return TRUE;
    }

    //--- Look for the chm::topic separator.
    PCSTR pszSep = stristr(pszFile, txtDoubleColonSep);
    if (!pszSep)
    {
        // The separator has not been found.
        if (stristr(pszFile, txtDefExtension) || stristr(pszFile, txtItsExtension))
            pszSep = pszFile;
        else
            return FALSE;   // not a compiled file if no separator
    }

    // If pcszFile is NULL, don't go look for the file.
    if (!pcszFile)
        return TRUE;    // don't find it, just say it's compiled

    //NOTE: We always return true. Whether we find the file or not.

    // Remove the topic from the filename, before we find the file.
    CStr cszFindFile(pszFile);
    if (pszSep > pszFile)
        cszFindFile.psz[pszSep - pszFile] = '\0';   // remove separator

    //--- Find the file.
    if (FindThisFile(NULL, cszFindFile, &cszFindFile, FALSE)) {
        // Add on the moniker information. FindThisFile doesn't do this.
        char szSep[MAX_PATH];
        strcpy(szSep, pszSep);  // in case pszFile == *pcszFile
        *pcszFile = (g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore);
        *pcszFile += cszFindFile.psz;
        if (pszSep > pszFile)
            *pcszFile += szSep;
        return TRUE;
    }
    else
        *pcszFile = pszFile;

    // If we get here, it's a compiled file, but we don't know where it is

    return TRUE;   // we can't find the file, so let IE try to find it
}

/***************************************************************************

    FUNCTION:   IsCollectionFile

    PURPOSE:    Determines if a input file is a collection

    PARAMETERS:
        pszName -- original name

    RETURNS:
        TRUE if file is a collection

    MODIFICATION DATES:
        29-Jul-1997 [dondr]

***************************************************************************/
BOOL IsCollectionFile(PCSTR pszName)
{
        if (stristr(pszName, txtCollectionExtension))
            return TRUE;

        return FALSE;
}


/***************************************************************************

    FUNCTION:   GetCompiledName

    PURPOSE:    Parse out just the compiled file name (and path)
                E.g. "its:c:\foo.chm::/bar.htm" becomes "c:\foo.chm"
                Note, we must convert any and all escape sequences like %20 as well [paulti]

    PARAMETERS:
        pszName -- original name
        pcsz    -- CStr to store result

    RETURNS:
                Pointer to any filename after a '::' separator in the
                original string (pszName);

    MODIFICATION DATES:
        10-Jun-1997 [ralphw]

***************************************************************************/

PCSTR GetCompiledName(PCSTR pszName, CStr* pcsz)
{
    ASSERT(pcsz != NULL) ;
    if( !pszName )
      return NULL;

    if (IsSamePrefix(pszName, txtMkStore))
        pszName += strlen(txtMkStore);
    else if (IsSamePrefix(pszName, txtMsItsMoniker))
        pszName += strlen(txtMsItsMoniker);
    else if (IsSamePrefix(pszName, txtItsMoniker))
        pszName += strlen(txtItsMoniker);

    *pcsz = pszName;
    PSTR pszSep = strstr(*pcsz, txtDoubleColonSep);
    if (pszSep) {
        *pszSep = '\0';
        ReplaceEscapes(pcsz->psz, pcsz->psz, ESCAPE_URL);   // remove escapes
        return (strstr(pszName, txtDoubleColonSep) + 2);
    }
    return NULL;
}

/***************************************************************************

    FUNCTION:   NormalizeFileName

    PURPOSE:    Take a filename to a CHM or COL and create a definitive
                name for the file. For a CHM file, this is the moniker.
                For a COL, its the moniker to the master CHM.

    PARAMETERS:
        cszFileName -- Modifies the name passed in.

    RETURNS:
        true - success
        false - failure.

    MODIFICATION DATES:
        27-Apr-98 [dalero]

***************************************************************************/
bool
NormalizeFileName(CStr& cszFileName)
{
    // We shouldn't be getting any http files. This isn't incorrect. I'm just testing my assumptions.
    ASSERT(!IsHttp(cszFileName)) ;

    if (IsCollectionFile(cszFileName)) // Is this a collection?
    {
        //...Much of this was borrowed from OnDisplayTopic...
        // Get the master chm file name.

        GetCompiledName(cszFileName, &cszFileName); // pszFilePortion is everything is cszFile after the '::', in other words the topic path.
        if (!FindThisFile(NULL, cszFileName, &cszFileName, FALSE))
        {
            //TODO: Move error message into FindThisFile.
            //g_LastError.Set(HH_E_FILENOTFOUND) ;
            return false;
        }

        CHmData* phmData;

        CExCollection* pCollection = GetCurrentCollection(NULL, (PCSTR)cszFileName);
        if ( pCollection )
           phmData = pCollection->m_phmData;

        if (phmData == NULL)
        {
            //g_LastError.Set(HH_E_INVALIDHELPFILE) ; // TODO: FindCurFileData should set this.
            return false;
        }
        else
        {
            // Get the name of the master chm.
            cszFileName = phmData->GetCompiledFile();
        }
    }

    // Find the file and get all the moniker information.
    if (IsCompiledHtmlFile(cszFileName, &cszFileName))
    {
        // Remove any filename tacked onto the end.
        PSTR pszSep = strstr(cszFileName.psz, txtDoubleColonSep);
        if (pszSep)
        {
            *pszSep = '\0';
        }

        return true;
    }
    else
    {
        return false ;
    }

}
/***************************************************************************

    FUNCTION:    GetButtonDimensions

    PURPOSE:    Get the width/height of the button

    PARAMETERS:
    hwnd
    psz

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
    04-Feb-1993 [ralphw]

***************************************************************************/

#define CXBUTTONEXTRA 16    // spacing between text and button
#define CYBUTTONEXTRA  7

DWORD GetButtonDimensions(HWND hwnd, HFONT hFont, PCSTR psz)
{
    HDC hdc = GetDC(hwnd);
    DWORD dwRet;
    POINT pt;

    if (hdc == NULL)
        return 0L;
    // Select in the new font. The dialog may not have done this.
    HFONT hOldFont = NULL ;
    if (hFont)
    {
        hOldFont = (HFONT)SelectObject(hdc, hFont) ;
    }

    // Get the size of the text.
    pt = GetTextSize(hdc, psz, (int)strlen(psz));
    dwRet = MAKELONG(pt.x, pt.y) +
        MAKELONG(CXBUTTONEXTRA, CYBUTTONEXTRA);

    // Cleanup.
    if (hOldFont)
    {
        SelectObject(hdc, hOldFont) ;
    }

    ReleaseDC(hwnd, hdc);
    return dwRet;
}

//////////////////////////////////////////////////////////////////////////
//
// GetStaticDimensions - used by simple search tab. max_len should include
// any space needed between the static text and buttons on the left or right.
//
DWORD GetStaticDimensions(HWND hwnd, HFONT hFont, PCSTR psz, int max_len )
{
    DWORD dwRet;
    POINT pt;
    int rows;
    HDC hdc = GetDC(hwnd);

    if ( hdc == NULL )
        return 0L;

    // Select in the new font. The dialog may not have done this.
    HFONT hOldFont = NULL ;
    if (hFont)
    {
        hOldFont = (HFONT)SelectObject(hdc, hFont) ;
    }

    // Get the text extent.
    pt = GetTextSize(hdc, psz, (int)strlen(psz) );

    rows = pt.x/(max_len ? max_len : 1);
    if ( pt.x%(max_len ? max_len : 1) > 0 )
        rows++;
    pt.y *= rows;
    dwRet = MAKELONG(pt.x, pt.y);

    // Cleanup.
    if (hOldFont)
    {
        SelectObject(hdc, hOldFont) ;
    }

    ReleaseDC(hwnd, hdc);
    return dwRet;
}

//////////////////////////////////////////////////////////////////////////
//
// GetStaticDimensions - used by simple search tab. max_len should include
// any space needed between the static text and buttons on the left or right.
//
DWORD GetStaticDimensionsW(HWND hwnd, HFONT hFont, WCHAR *psz, int max_len )
{
    DWORD dwRet;
    POINT pt;
    int rows;
    HDC hdc = GetDC(hwnd);

    if ( hdc == NULL )
        return 0L;

    // Select in the new font. The dialog may not have done this.
    HFONT hOldFont = NULL ;
    if (hFont)
    {
        hOldFont = (HFONT)SelectObject(hdc, hFont) ;
    }

    // Get the text extent.
    pt = GetTextSizeW(hdc, psz, wcslen(psz) );

    rows = pt.x/(max_len ? max_len : 1);
    if ( pt.x%(max_len ? max_len : 1) > 0 )
        rows++;
    pt.y *= rows;
    dwRet = MAKELONG(pt.x, pt.y);

    // Cleanup.
    if (hOldFont)
    {
        SelectObject(hdc, hOldFont) ;
    }

    ReleaseDC(hwnd, hdc);
    return dwRet;
}


static POINT GetTextSize(HDC hdc, PCSTR qchBuf, int iCount)
{
    POINT ptRet;
    SIZE size;

    GetTextExtentPoint32(hdc, qchBuf, iCount, &size);
    ptRet.x = size.cx;
    ptRet.y = size.cy;

    return ptRet;
}

static POINT GetTextSizeW(HDC hdc, WCHAR *qchBuf, int iCount)
{
    POINT ptRet;
    SIZE size;

    GetTextExtentPoint32W(hdc, qchBuf, iCount, &size);
    ptRet.x = size.cx;
    ptRet.y = size.cy;

    return ptRet;
}


DWORD CreatePath(char *szPath)
{
   char szTmp[MAX_PATH],*p,*q,szTmp2[MAX_PATH];
   DWORD dwErr;

   strcpy(szTmp2,szPath);
   memset(szTmp,0,sizeof(szTmp));
   q = szTmp2;
   p = szTmp;

   while (*q)
   {
      if (*q == '/' || *q == '\\')
      {
         if (szTmp[1] == ':' && strlen(szTmp) <= 3)
         {
            if(IsDBCSLeadByte(*q))
         {
                *p++ = *q++;
            if(*q)
                    *p++ = *q++;
         }
         else
                *p++ = *q++;
            continue;
         }
         if (!::CreateDirectory(szTmp,0))
         {
            if ( (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS)
               return(dwErr);
         }
      }
      if(IsDBCSLeadByte(*q))
     {
          *p++ = *q++;
          if(*q)
            *p++ = *q++;
     }
     else
          *p++ = *q++;
   }
   if (!::CreateDirectory(szTmp,0))
   {
            if ((dwErr = GetLastError()) != ERROR_ALREADY_EXISTS)
               return(dwErr);
   }

   return(FALSE);
}

BOOL IsFile( LPCSTR lpszPathname )
{
  DWORD dwAttribs = GetFileAttributes( lpszPathname );
  if( dwAttribs != (DWORD) -1 )
    if( (dwAttribs & FILE_ATTRIBUTE_DIRECTORY) == 0 )
      return TRUE;
  return FALSE;
}

BOOL IsDirectory( LPCSTR lpszPathname )
{
  DWORD dwAttribs = GetFileAttributes( lpszPathname );
  if( dwAttribs != (DWORD) -1 )
    if( dwAttribs & FILE_ATTRIBUTE_DIRECTORY )
      return TRUE;
  return FALSE;
}

/***
*SplitPath() - split a path name into its individual components
*
*Purpose:
*       to split a path name into its individual components
*
*Entry:
*       path  - pointer to path name to be parsed
*       drive - pointer to buffer for drive component, if any
*       dir   - pointer to buffer for subdirectory component, if any
*       fname - pointer to buffer for file base name component, if any
*       ext   - pointer to buffer for file name extension component, if any
*
*Exit:
*       drive - pointer to drive string.  Includes ':' if a drive was given.
*       dir   - pointer to subdirectory string.  Includes leading and trailing
*           '/' or '\', if any.
*       fname - pointer to file base name
*       ext   - pointer to file extension, if any.  Includes leading '.'.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl SplitPath (
        const char *path,
        char *drive,
        char *dir,
        char *fname,
        char *ext
        )
{
        char *p;
        char *last_slash = NULL, *dot = NULL;
        unsigned len;

        /* we assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *  <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *  0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *  ':'
         *  dir:
         *  0 to _MAX_DIR-1 characters in the form of an absolute path
         *  (leading '/' or '\') or relative path, the last of which, if
         *  any, must be a '/' or '\'.  E.g -
         *  absolute path:
         *      \top\next\last\     ; or
         *      /top/next/last/
         *  relative path:
         *      top\next\last\  ; or
         *      top/next/last/
         *  Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *  0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *  0 to _MAX_EXT-1 characters where, if any, the first must be a
         *  '.'
         *
         */

        /* extract drive letter and :, if any */

        if ((strlen(path) >= (_MAX_DRIVE - 2)) && (*(path + _MAX_DRIVE - 2) == ':')) {
            if (drive) {
                lstrcpyn(drive, path, _MAX_DRIVE);
                *(drive + _MAX_DRIVE-1) = '\0';
            }
            path += _MAX_DRIVE - 1;
        }
        else if (drive) {
            *drive = '\0';
        }

        /* extract path string, if any.  Path now points to the first character
         * of the path, if any, or the filename or extension, if no path was
         * specified.  Scan ahead for the last occurence, if any, of a '/' or
         * '\' path separator character.  If none is found, there is no path.
         * We will also note the last '.' character found, if any, to aid in
         * handling the extension.
         */

        for (last_slash = NULL, p = (char *)path; *p; p++) {
#ifdef _MBCS
            if (IsDBCSLeadByte (*p))
                p++;
            else {
#endif  /* _MBCS */
            if (*p == '/' || *p == '\\')
                /* point to one beyond for later copy */
                last_slash = p + 1;
            else if (*p == '.')
                dot = p;
#ifdef _MBCS
            }
#endif  /* _MBCS */
        }

        if (last_slash) {

            /* found a path - copy up through last_slash or max. characters
             * allowed, whichever is smaller
             */

            if (dir) {
                len = (unsigned)__min(((char *)last_slash - (char *)path) / sizeof(char),
                    (_MAX_DIR - 1));
                lstrcpyn(dir, path, len+1);
                *(dir + len) = '\0';
            }
            path = last_slash;
        }
        else if (dir) {

            /* no path found */

            *dir = '\0';
        }

        /* extract file name and extension, if any.  Path now points to the
         * first character of the file name, if any, or the extension if no
         * file name was given.  Dot points to the '.' beginning the extension,
         * if any.
         */

        if (dot && (dot >= path)) {
            /* found the marker for an extension - copy the file name up to
             * the '.'.
             */
            if (fname) {
                len = (unsigned)__min(((char *)dot - (char *)path) / sizeof(char),
                    (_MAX_FNAME - 1));
                lstrcpyn(fname, path, len+1);
                *(fname + len) = '\0';
            }
            /* now we can get the extension - remember that p still points
             * to the terminating nul character of path.
             */
            if (ext) {
                len = (unsigned)__min(((char *)p - (char *)dot) / sizeof(char),
                    (_MAX_EXT - 1));
                lstrcpyn(ext, dot, len+1);
                *(ext + len) = '\0';
            }
        }
        else {
            /* found no extension, give empty extension and copy rest of
             * string into fname.
             */
            if (fname) {
                len = (unsigned)__min(((char *)p - (char *)path) / sizeof(char),
                    (_MAX_FNAME - 1));
                lstrcpyn(fname, path, len+1);
                *(fname + len) = '\0';
            }
            if (ext) {
                *ext = '\0';
            }
        }
}

void MemMove(void * dst, const void * src, int count)
{
#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
    {

    RtlMoveMemory( dst, src, count );
    }
#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
    if (dst <= src || (char *)dst >= ((char *)src + count)) {
            memcpy(dst, src, count);
    }
    else {
        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;

        while (count--) {
            *(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
    }
#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
}

LPSTR CatPath(LPSTR lpTop, LPCSTR lpTail)
{
    //
    // make sure we have a slash at the end of the first element
    //
    LPSTR p;

    if (lpTop && lpTop[0])
    {
        p = lpTop + strlen(lpTop);
        p = CharPrev(lpTop,p);
        if (*p != '\\' && *p != '/')
        {
            strcat(lpTop,"\\");
        }
    
        //
        // strip any leading slash from the second element
        //
    
        while (*lpTail == '\\') lpTail = CharNext(lpTail);
    
        //
    }
    // add them together
    //

    strcat(lpTop, lpTail);

    return lpTop;
}

///////////////////////////////////////////////////////////
//
// NoRun - Checks registry to determine if the no run option is set for this system
//
BOOL NoRun()
{
    HKEY hKeyResult;
    DWORD dwNoRun;
    DWORD count = sizeof(DWORD);
    DWORD type;
    LONG lReturn;

    lReturn = RegOpenKeyEx( HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer", 0, KEY_READ, &hKeyResult);
 
    if( lReturn == ERROR_SUCCESS ) 
    {
        lReturn = RegQueryValueEx(hKeyResult, "NoRun", 0, &type, (BYTE *)&dwNoRun, &count);
        RegCloseKey(hKeyResult);
    }

    if (lReturn == ERROR_SUCCESS)
    {
        if (dwNoRun == 1)
            return TRUE;
        else
            return FALSE;
    }
    else
    {
        count = sizeof(DWORD);
        lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer", 0, KEY_READ, &hKeyResult);
 
        if( lReturn == ERROR_SUCCESS )
        {
            lReturn = RegQueryValueEx(hKeyResult, "NoRun", 0, &type, (BYTE *)&dwNoRun, &count);
            RegCloseKey(hKeyResult);
        }
        
        if (lReturn == ERROR_SUCCESS)
        {
            if (dwNoRun == 1)
                return TRUE;
            else
                return FALSE;
        }
    }
    return FALSE;
}

///////////////////////////////////////////////////////////
//
// NormalizeUrlInPlace
//
void
NormalizeUrlInPlace(LPSTR szURL)
{
   //
   // Normalize the URL by stripping off protocol, storage type, storage name goo from the URL then make sure
   // we only have forward slashes. BUGBUG: May want to consider moving this to util.cpp if it turns up useful.
   //
   PSTR pszSep = strstr(szURL, txtDoubleColonSep);
   if (pszSep)
   {
      strcpy(szURL, pszSep + 3);
   }
   ConvertBackSlashToForwardSlash(szURL);
}

void QRect(HDC hdc, INT x, INT y, INT cx, INT cy, INT color)
{
    DWORD dwColor;
    RECT rc;

    dwColor = SetBkColor(hdc,GetSysColor(color));
    rc.left = x;
    rc.top = y;
    rc.right = x + cx;
    rc.bottom = y + cy;
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
    SetBkColor(hdc,dwColor);
}

///////////////////////////////////////////////////////////
//
// Determine if the wintype is a global wintype.
//
bool
IsGlobalWinType(const char* szType)
{
    // Skip possible leading window separator character.
    const char* psz = szType ;
    if (psz[0] == '>')
    {
        psz++ ;
    }

    if (_strnicmp(psz, GLOBAL_WINDOWTYPE_PREFIX, (int)strlen(GLOBAL_WINDOWTYPE_PREFIX)) == 0)
    {
        return true ;
    }
    else if (_strnicmp(psz, GLOBAL_WINDOWTYPE_PREFIX_OFFICE, (int)strlen(GLOBAL_WINDOWTYPE_PREFIX_OFFICE)) == 0)
    {
        return true ;
    }
    else if (_Module.m_GlobalWinTypes.Find(psz))
    {
        return true ;
    }
    else
    {
        return false ;
    }

}

///////////////////////////////////////////////////////////
//
// Determine if the wintype is a global wintype.
//
bool
IsGlobalWinTypeW(LPCWSTR szType)
{
    LPCWSTR psz = szType ;
    if (psz[0] == '>')
    {
        psz++ ;
    }

    if (_wcsnicmp(psz, GLOBAL_WINDOWTYPE_PREFIX_W, wcslen(GLOBAL_WINDOWTYPE_PREFIX_W)) == 0)
    {
        return true ;
    }
    else if (_wcsnicmp(psz, GLOBAL_WINDOWTYPE_PREFIX_OFFICE_W, wcslen(GLOBAL_WINDOWTYPE_PREFIX_OFFICE_W)) == 0)
    {
        return true ;
    }
    else if (_Module.m_GlobalWinTypes.Find(psz))
    {
        return true ;
    }
    else
    {
        return false ;
    }

}

static const char txtSetupKey[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Setup";
static const char txtSharedDir[] = "SharedDir";


///////////////////////////////////////////////////////////
//
// Get the windows directory for the system or the user
//
// Note, Windows NT Terminal Server has changed the system API
// of GetWindowsDirectory to return a per-user system directory.
// Inorder to determine this condtion we need to check kernel32
// for the GetSystemWindowsDirectory API and if it exists use
// this one instead.
//
UINT HHGetWindowsDirectory( LPSTR lpBuffer, UINT uSize, UINT uiType )
{
  UINT uiReturn = 0;
  static PFN_GETWINDOWSDIRECTORY pfnGetUsersWindowsDirectory = NULL;
  static PFN_GETWINDOWSDIRECTORY pfnGetSystemWindowsDirectory = NULL;

  // determine which system API to call for each case
  if( !pfnGetSystemWindowsDirectory || !pfnGetSystemWindowsDirectory ) {

    HINSTANCE hInst = LoadLibrary( "Kernel32" );
    if( !hInst )
      return uiReturn;

    pfnGetSystemWindowsDirectory = (PFN_GETWINDOWSDIRECTORY) GetProcAddress( hInst, "GetSystemWindowsDirectoryA" );

    pfnGetUsersWindowsDirectory = (PFN_GETWINDOWSDIRECTORY) GetProcAddress( hInst, "GetWindowsDirectoryA" );
    ASSERT( pfnGetUsersWindowsDirectory ); // if NULL then we have a bug!

    if( !pfnGetSystemWindowsDirectory ) {
      pfnGetSystemWindowsDirectory = pfnGetUsersWindowsDirectory;
    }

    FreeLibrary( hInst );
  }

  // for Windows 9x, we need to consult with the registry shareddir first
  // [paulti] - I have no idea why we need to do this -- this code came
  // from Ralph!
  HKEY hkey;
  DWORD type;

  DWORD cbPath = uSize;
  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, txtSetupKey, 0, KEY_READ, &hkey) ==
          ERROR_SUCCESS) {
      RegQueryValueEx(hkey, txtSharedDir, 0, &type, (PBYTE) lpBuffer, &cbPath);
      RegCloseKey(hkey);
  }

  // if this failed, then call the system functions
  if( cbPath == uSize ) { // means couldn't read registry key
    if( uiType == HH_SYSTEM_WINDOWS_DIRECTORY )
      uiReturn = pfnGetSystemWindowsDirectory( lpBuffer, uSize );
    else if( uiType == HH_USERS_WINDOWS_DIRECTORY )
      uiReturn = pfnGetUsersWindowsDirectory( lpBuffer, uSize );
    else
      uiReturn = 0;
  }
  else
    uiReturn = cbPath;


  return uiReturn;
}

static const char txtGlobal[]    = "global.col";
static const char txtColReg[]    = "hhcolreg.dat";
static const char txtHelp[]      = "help";
static const char txtHHDat[]     = "hh.dat";

///////////////////////////////////////////////////////////
//
// Get the help directory
//
// Note, this is always relative to the system's windows
// directory and not the user's windows directory.
// See HHGetWindowsDirectory for details on this.
//
UINT HHGetHelpDirectory( LPTSTR lpBuffer, UINT uSize )
{
  UINT uiReturn = 0;

  uiReturn = HHGetWindowsDirectory( lpBuffer, uSize );
  CatPath( lpBuffer, txtHelp );

  return uiReturn;
}

///////////////////////////////////////////////////////////
//
// Get the full pathname to the global collections file
//
// Note, this is in always in the system's help directory.
//
UINT HHGetGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize, BOOL *pbNewPath )
{
  UINT uiReturn = 0;

  *pbNewPath = TRUE;
  uiReturn = HHGetHelpDataPath( lpBuffer );

  if (uiReturn != S_OK)
  {
     *pbNewPath = FALSE;
     uiReturn = HHGetHelpDirectory( lpBuffer, uSize );
     if( !IsDirectory(lpBuffer) )
        CreatePath( lpBuffer );
  }   
  CatPath( lpBuffer, txtColReg );

  return uiReturn;
}

///////////////////////////////////////////////////////////
//
// Get the full pathname to the old global collections file
//
// Note, this is in always in the user's windows\help directory
// since the old code did not handle the Terminal Server path correctly.
//
UINT HHGetOldGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize )
{
  UINT uiReturn = 0;

  uiReturn = HHGetHelpDirectory( lpBuffer, uSize );

  if( !IsDirectory(lpBuffer) )
      CreatePath( lpBuffer );

  CatPath( lpBuffer, txtColReg );

  return uiReturn;
}

typedef HRESULT (WINAPI *PFN_SHGETSPECIALFOLDERPATH)( HWND hWnd, LPSTR pszPath, int nFolder, BOOL fCreate );
static const char txtProfiles[]        = "Profiles";
static const char txtUser[]            = "Default User";
static const char txtAllUsers[]        = "All Users";
static const char txtApplicationData[] = "Application Data";
static const char txtMicrosoft[]       = "Microsoft";
static const char txtHTMLHelp[]        = "HTML Help";

///////////////////////////////////////////////////////////
//
// Get the full path to where the user's data file is stored
//
// Note, if the subdirectories of the path does not exist
// we will create them
//
// Note, the Shell32 function SHGetSpecialFolderPathA only exist
// on platforms with IE4 or later.  For those platforms that
// do not have this API we will have to simulate the returned
// "%windir%\Profiles\%username%\Application Data" path
HRESULT HHGetUserDataPath( LPSTR pszPath )
{
  HRESULT hResult = S_OK;
  static PFN_SHGETSPECIALFOLDERPATH pfnSHGetSpecialFolderPath = NULL;

  // get the pointer to this function in shell32
  if( !pfnSHGetSpecialFolderPath ) {
    HINSTANCE hInst = LoadLibrary( "Shell32" );
    if( !hInst )
      return S_FALSE;
    pfnSHGetSpecialFolderPath = (PFN_SHGETSPECIALFOLDERPATH) GetProcAddress( hInst, "SHGetSpecialFolderPathA" );
    FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
  }

  // if this function does not exist then we need to similate the return path of
  // "%windir%\Profiles\%username%\Application Data"
  if( !pfnSHGetSpecialFolderPath ) {
HardCodeUserPath:
    // get the system's Windows directory
    HHGetWindowsDirectory( pszPath, _MAX_PATH, HH_SYSTEM_WINDOWS_DIRECTORY );

    // append "Profiles"
    CatPath( pszPath, txtProfiles );
    if( !IsDirectory(pszPath) )
      if( !CreateDirectory( pszPath, NULL ) )
        return S_FALSE;

    // append "User"
    char szUsername[_MAX_PATH];
    DWORD dwSize = sizeof(szUsername);
    if( !GetUserName( szUsername, &dwSize ) )
      strcpy( szUsername, txtUser );
    CatPath( pszPath, szUsername );
    if( !IsDirectory(pszPath) )
      if( !CreateDirectory( pszPath, NULL ) )
        return S_FALSE;

    // append "Application Data"
    CatPath( pszPath, txtApplicationData );
    if( !IsDirectory(pszPath) )
      if( !CreateDirectory( pszPath, NULL ) )
        return S_FALSE;

  }
  else {
    // now call it
    hResult = pfnSHGetSpecialFolderPath( NULL, pszPath, CSIDL_APPDATA, 0 );
    if (pszPath[0] == NULL)
        goto HardCodeUserPath;
  }

  // append "Microsoft"
  CatPath( pszPath, txtMicrosoft );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  // append "HTML Help"
  CatPath( pszPath, txtHTMLHelp );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  return hResult;
}

///////////////////////////////////////////////////////////
//
// Get the full pathname to the user's data file
//
// Note, older version of HTML Help always put the hh.dat file
// in the user's windows directory.  Thus, if we find one there
// and not in the new user's directory we will copy over this file
// to the new location.
//
HRESULT HHGetUserDataPathname( LPSTR lpBuffer, UINT uSize )
{
  HRESULT hResult = S_OK;

  // check the new user data path first
  if( (SUCCEEDED( hResult = HHGetUserDataPath( lpBuffer ))) ) {

    // append the name of the hh.dat file to the path
    CatPath( lpBuffer, txtHHDat );

    // if file exists there then we are done
    if( !IsFile(lpBuffer) ) {

      // if the file does not exist in the new user's path then
      // check the users's windows directory can copy it if found
      char szHHDatPathname[_MAX_PATH];
      HHGetWindowsDirectory( szHHDatPathname, sizeof(szHHDatPathname),
        HH_USERS_WINDOWS_DIRECTORY );
      CatPath( szHHDatPathname, txtHHDat );
      if( IsFile( szHHDatPathname ) ) {
        CopyFile( szHHDatPathname, lpBuffer, TRUE );
        //DeleteFile( szHHDatPathname );  // should we nuke the old one?
      }
    }

  }

  return hResult;
}
typedef HRESULT (WINAPI *PFN_SHGETFOLDERPATH)( HWND hWnd, int nFolder, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath );
#ifndef CSIDL_FLAG_CREATE
#define CSIDL_COMMON_APPDATA 0x0023      
#define CSIDL_FLAG_CREATE 0x8000
#endif

///////////////////////////////////////////////////////////
//
// Get the full path to where the common help data files lives
//  hhcolreg.dat
//
// Note, if the subdirectories of the path does not exist
// we will create them
//
HRESULT HHGetHelpDataPath( LPSTR pszPath )
{
  HRESULT hResult = S_OK;
  static PFN_SHGETFOLDERPATH pfnSHGetFolderPath = NULL;

  // get the pointer to this function in shell32
  if( !pfnSHGetFolderPath ) {
    HINSTANCE hInst = LoadLibrary( "Shell32" );
    if( !hInst )
      return S_FALSE;
    pfnSHGetFolderPath = (PFN_SHGETFOLDERPATH) GetProcAddress( hInst, "SHGetFolderPathA" );
    FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
  }

  // if this function does not exist then we need to similate the return path of
  // "%windir%\Profiles\All Users\Application Data"
  if( pfnSHGetFolderPath ) {
    // now call it
    hResult = pfnSHGetFolderPath( NULL, CSIDL_FLAG_CREATE | CSIDL_COMMON_APPDATA, NULL, 0, pszPath);
    if (pszPath[0] == NULL)
       return S_FALSE;
  }
  else
    return S_FALSE;
      
  // append "Microsoft"
  CatPath( pszPath, txtMicrosoft );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  // append "HTML Help"
  CatPath( pszPath, txtHTMLHelp );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  return hResult;
}

///////////////////////////////////////////////////////////
//
// Get the full path to where the common help data files lives
//  hhcolreg.dat
//
// Note, if the subdirectories of the path does not exist
// we will create them
//
HRESULT HHGetCurUserDataPath( LPSTR pszPath )
{
  HRESULT hResult = S_OK;
  static PFN_SHGETFOLDERPATH pfnSHGetFolderPath = NULL;

  // get the pointer to this function in shell32
  if( !pfnSHGetFolderPath ) {
    HINSTANCE hInst = LoadLibrary( "Shell32" );
    if( !hInst )
      return S_FALSE;
    pfnSHGetFolderPath = (PFN_SHGETFOLDERPATH) GetProcAddress( hInst, "SHGetFolderPathA" );
    FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
  }

  // if this function does not exist then we need to similate the return path of
  // "%windir%\Profiles\"username"\Application Data"
  if( pfnSHGetFolderPath ) {
    // now call it
    hResult = pfnSHGetFolderPath( NULL, CSIDL_FLAG_CREATE | CSIDL_APPDATA , NULL, 0, pszPath);
    if (pszPath[0] == NULL)
       return S_FALSE;
  }
  else
    return S_FALSE;
      
  // append "Microsoft"
  CatPath( pszPath, txtMicrosoft );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  // append "HTML Help"
  CatPath( pszPath, txtHTMLHelp );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  return hResult;
}

///////////////////////////////////////////////////////////
//
// NT Keyboard hidden UI support functions.
//
LRESULT SendMessageAnsiOrWide(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (IsWindowUnicode(hwnd))
    {
        return SendMessageW(hwnd, msg, wParam, lParam);
    }
    else
    {
        return SendMessageA(hwnd, msg, wParam, lParam) ;
    }
}

void UiStateInitialize(HWND hwnd)
{
    if (g_bWinNT5 && IsWindow(hwnd))
    {
        SendMessageAnsiOrWide(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0) ;
    }
}

void UiStateChangeOnTab(HWND hwnd)
{
    if (g_bWinNT5 && IsWindow(hwnd))
    {
        SendMessageAnsiOrWide(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0) ;
    }
}

void UiStateChangeOnAlt(HWND hwnd)
{
    if (g_bWinNT5 && IsWindow(hwnd))
    {
        // The only thing we can do is just turn on the underlines.
        SendMessageAnsiOrWide(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL | UISF_HIDEFOCUS), 0) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\userwait.h ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

//void CenterWaitWindow(HWND hwndParent, HWND hwnd);
BOOL CALLBACK CWaitDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
//LRESULT UWaitWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

class CUWait
{
public:
    CUWait(HWND hwndParent);
    ~CUWait();

    CLockOut m_LockOut;
    BOOL m_bVisable;
    volatile HWND    m_hwndParent;
    volatile HWND    m_hwndUWait;
//    volatile BOOL    m_bThreadTerminated;
    volatile BOOL    m_bUserCancel;   // TRUE if user canceled the wait.
//    HANDLE  m_hthrd;
//    DWORD   m_idThrd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_


//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
      m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : lcMalloc(cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
      if (m_pBuf && m_fHeapAlloc)
         lcFree(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

BOOL NoRun( void );
BOOL IsFile( LPCSTR lpszPathname );
BOOL IsDirectory( LPCSTR lpszPathname );

void __cdecl SplitPath (
        register const char *path,
        char *drive,
        char *dir,
        char *fname,
        char *ext
        );


// Normalize the URL by stripping off protocol, storage type, storage name goo from the URL then make sure
// we only have forward slashes.
void NormalizeUrlInPlace(LPSTR szURL) ;

// Get the moniker for the filename. For a col, its the moniker of the master chm.
bool NormalizeFileName(CStr& cszFileName) ;

void QRect(HDC hdc, INT x, INT y, INT cx, INT cy, INT color);

// To create a global window type, use the following prefix.
const char GLOBAL_WINDOWTYPE_PREFIX[] = "$global_" ;
const wchar_t GLOBAL_WINDOWTYPE_PREFIX_W[] = L"$global_" ;

// Hack for Office.
const char GLOBAL_WINDOWTYPE_PREFIX_OFFICE[] = "MSO_Small" ;
const wchar_t GLOBAL_WINDOWTYPE_PREFIX_OFFICE_W[] = L"MSO_Small" ;

// Determine if the wintype is a global wintype.
bool IsGlobalWinType(const char* szType) ;

// Determine if the wintype is a global wintype.
bool IsGlobalWinTypeW(LPCWSTR szType) ;

// Checks for the http: reference. Assumes its a URL if this exists.
inline bool
IsHttp(const char* szUrl)
{
    if (szUrl)
        return (stristr(szUrl, txtHttpHeader) != 0); // Is this a internet URL?
    else
        return false;
}

///////////////////////////////////////////////////////////
//
// NT Keyboard hidden UI support functions.
//
void UiStateInitialize(HWND hwnd) ;
void UiStateChangeOnTab(HWND hwnd) ;
void UiStateChangeOnAlt(HWND hwnd) ;

#define _UTIL_H_
#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\vlist.h ===
#ifndef __VLIST_H__
#define __VLIST_H__

typedef struct tagVLC_ITEM
{
    NMHDR hdr;
    int   iItem;
    WCHAR*lpwsz;
    int   cchMax;
    int   iLevel;
    DWORD dwFlags;  // bit 0; 1 = disabled, 0 = normal
} VLC_ITEM, * PVLC_ITEM;

#define IDC_KWD_VLIST 222

#define VLN_GETITEM (-100)
#define VLN_SELECT  (-101)
#define VLN_TAB     (-102)

class CVirtualListCtrl
{
public:
    CVirtualListCtrl(LCID lcid);
    ~CVirtualListCtrl();
    BOOL SetItemCount(int);
    BOOL SetSelection(int iSel, BOOL bNotify = TRUE);
    BOOL SetTopIndex(int);
    BOOL EnsureVisible(int);
    BOOL GetItemRect(int, RECT* prc);
    int GetSelection();
    int GetTopIndex();
    static LRESULT StaticWindowProc(HWND, UINT, WPARAM, LPARAM);
    HWND CreateVlistbox(HWND hWndParent, RECT* prc);
    LRESULT GetItemText(int iItem, int* piLevel, DWORD* pdwFlags, WCHAR* lpwsz, int cchMax);
    LRESULT ItemSelected(int);
    LRESULT ItemDoubleClicked(int);
    LRESULT DrawItem(HDC hDC, int, RECT* prc, BOOL, BOOL);
    void PaintParamsSetup(COLORREF clrBackground, COLORREF clrForeground, LPCSTR pszBackBitmap);
    void Refresh()
    {
       if ( m_hWnd )
          InvalidateRect(m_hWnd, NULL, TRUE);
    }
    LANGID GetLanguageId() { return m_langid; }
    LCID   GetLanguage() { return m_lcid; }

private:
    void RedrawCurrentItem();
    LRESULT Notify(int, NMHDR * = 0);

    int m_cItems;
    int m_iTopItem;
    int m_iSelItem;
    int m_cyItem;
    int m_cItemsPerPage;
    BOOL m_fFocus;
    HFONT m_hFont;
    HWND m_hWnd;
    HWND m_hWndParent;
    LANGID m_langid;
    LCID    m_lcid; // the locale ID of the text in the listbox
    //
    // Ralphs goo.
    //
    HPALETTE m_hpalBackGround;
    HBRUSH   m_hbrBackGround;
    HBITMAP  m_hbmpBackGround;
    int      m_cxBackBmp;
    int      m_cyBackBmp;
    COLORREF m_clrForeground;
    COLORREF m_clrBackground;

    BOOL  m_fBiDi;
    DWORD m_RTL_Style;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\web.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __WEB_H__
#define __WEB_H__

// Stolen from MFC

// parameter types: by value VTs
#define VTS_I2              "\x02"      // a 'short'
#define VTS_I4              "\x03"      // a 'long'
#define VTS_R4              "\x04"      // a 'float'
#define VTS_R8              "\x05"      // a 'double'
#define VTS_CY              "\x06"      // a 'CY' or 'CY*'
#define VTS_DATE            "\x07"      // a 'DATE'
#define VTS_WBSTR           "\x08"      // an 'LPCOLESTR'
#define VTS_DISPATCH        "\x09"      // an 'IDispatch*'
#define VTS_SCODE           "\x0A"      // an 'SCODE'
#define VTS_BOOL            "\x0B"      // a 'BOOL'
#define VTS_VARIANT         "\x0C"      // a 'const VARIANT&' or 'VARIANT*'
#define VTS_UNKNOWN         "\x0D"      // an 'IUnknown*'
#if defined(_UNICODE) || defined(OLE2ANSI)
	#define VTS_BSTR            VTS_WBSTR// an 'LPCOLESTR'
	#define VT_BSTRT            VT_BSTR
#else
	#define VTS_BSTR            "\x0E"  // an 'LPCSTR'
	#define VT_BSTRA            14
	#define VT_BSTRT            VT_BSTRA
#endif
#define VTS_UI1             "\x0F"      // a 'BYTE'

// parameter types: by reference VTs
#define VTS_PI2             "\x42"      // a 'short*'
#define VTS_PI4             "\x43"      // a 'long*'
#define VTS_PR4             "\x44"      // a 'float*'
#define VTS_PR8             "\x45"      // a 'double*'
#define VTS_PCY             "\x46"      // a 'CY*'
#define VTS_PDATE           "\x47"      // a 'DATE*'
#define VTS_PBSTR           "\x48"      // a 'BSTR*'
#define VTS_PDISPATCH       "\x49"      // an 'IDispatch**'
#define VTS_PSCODE          "\x4A"      // an 'SCODE*'
#define VTS_PBOOL           "\x4B"      // a 'VARIANT_BOOL*'
#define VTS_PVARIANT        "\x4C"      // a 'VARIANT*'
#define VTS_PUNKNOWN        "\x4D"      // an 'IUnknown**'
#define VTS_PUI1            "\x4F"      // a 'BYTE*'

// special VT_ and VTS_ values
#define VTS_NONE            NULL        // used for members with 0 params
#define VT_MFCVALUE         0xFFF       // special value for DISPID_VALUE
#define VT_MFCBYREF         0x40        // indicates VT_BYREF type
#define VT_MFCMARKER        0xFF        // delimits named parameters (INTERNAL USE)

// variant handling (use V_BSTRT when you have ANSI BSTRs, as in DAO)
#ifndef _UNICODE
	#define V_BSTRT(b)  (LPSTR)V_BSTR(b)
#else
	#define V_BSTRT(b)  V_BSTR(b)
#endif

/////////////////////////////////////////////////////////////////////////////
// OLE control parameter types

#define VTS_COLOR           VTS_I4      // OLE_COLOR
#define VTS_XPOS_PIXELS     VTS_I4      // OLE_XPOS_PIXELS
#define VTS_YPOS_PIXELS     VTS_I4      // OLE_YPOS_PIXELS
#define VTS_XSIZE_PIXELS    VTS_I4      // OLE_XSIZE_PIXELS
#define VTS_YSIZE_PIXELS    VTS_I4      // OLE_YSIZE_PIXELS
#define VTS_XPOS_HIMETRIC   VTS_I4      // OLE_XPOS_HIMETRIC
#define VTS_YPOS_HIMETRIC   VTS_I4      // OLE_YPOS_HIMETRIC
#define VTS_XSIZE_HIMETRIC  VTS_I4      // OLE_XSIZE_HIMETRIC
#define VTS_YSIZE_HIMETRIC  VTS_I4      // OLE_YSIZE_HIMETRIC
#define VTS_TRISTATE        VTS_I2      // OLE_TRISTATE
#define VTS_OPTEXCLUSIVE    VTS_BOOL    // OLE_OPTEXCLUSIVE

#define VTS_PCOLOR          VTS_PI4     // OLE_COLOR*
#define VTS_PXPOS_PIXELS    VTS_PI4     // OLE_XPOS_PIXELS*
#define VTS_PYPOS_PIXELS    VTS_PI4     // OLE_YPOS_PIXELS*
#define VTS_PXSIZE_PIXELS   VTS_PI4     // OLE_XSIZE_PIXELS*
#define VTS_PYSIZE_PIXELS   VTS_PI4     // OLE_YSIZE_PIXELS*
#define VTS_PXPOS_HIMETRIC  VTS_PI4     // OLE_XPOS_HIMETRIC*
#define VTS_PYPOS_HIMETRIC  VTS_PI4     // OLE_YPOS_HIMETRIC*
#define VTS_PXSIZE_HIMETRIC VTS_PI4     // OLE_XSIZE_HIMETRIC*
#define VTS_PYSIZE_HIMETRIC VTS_PI4     // OLE_YSIZE_HIMETRIC*
#define VTS_PTRISTATE       VTS_PI2     // OLE_TRISTATE*
#define VTS_POPTEXCLUSIVE   VTS_PBOOL   // OLE_OPTEXCLUSIVE*

#define VTS_FONT            VTS_DISPATCH    // IFontDispatch*
#define VTS_PICTURE         VTS_DISPATCH    // IPictureDispatch*

#define VTS_HANDLE          VTS_I4      // OLE_HANDLE
#define VTS_PHANDLE         VTS_PI4     // OLE_HANDLE*

class COleDispatchDriver
{
// Constructors
public:
	COleDispatchDriver();
	COleDispatchDriver(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	COleDispatchDriver(const COleDispatchDriver& dispatchSrc);

// Attributes
	LPDISPATCH m_lpDispatch;
	BOOL m_bAutoRelease;

// Operations
	BOOL CreateDispatch(REFCLSID clsid);
	BOOL CreateDispatch(LPCTSTR lpszProgID);

	void AttachDispatch(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	LPDISPATCH DetachDispatch();
		// detach and get ownership of m_lpDispatch
	void ReleaseDispatch();

	// helpers for IDispatch::Invoke
	void __cdecl InvokeHelper(DISPID dwDispID, WORD wFlags,
		VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
	void __cdecl SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;

	// special operators
	operator LPDISPATCH()	{ return m_lpDispatch;	}
	const COleDispatchDriver& operator=(const COleDispatchDriver& dispatchSrc);

// Implementation
public:
	~COleDispatchDriver()	{ ReleaseDispatch();	}
	void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE* pbParamInfo, va_list argList);
};

class DWebBrowserEventsImpl : public COleDispatchDriver
{
public:
   DWebBrowserEventsImpl() {}    // Calls COleDispatchDriver default constructor
   DWebBrowserEventsImpl(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
   DWebBrowserEventsImpl(const DWebBrowserEventsImpl& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

public:
   void BeforeNavigate(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Cancel);
   void NavigateComplete(LPCTSTR URL);
   void StatusTextChange(LPCTSTR Text);
   void ProgressChange(long Progress, long ProgressMax);
   void DownloadComplete();
   void CommandStateChange(long Command, BOOL Enable);
   void DownloadBegin();
   void NewWindow(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Processed);
   void TitleChange(LPCTSTR Text);
   void FrameBeforeNavigate(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Cancel);
   void FrameNavigateComplete(LPCTSTR URL);
   void FrameNewWindow(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Processed);
   void Quit(BOOL* Cancel);
   void WindowMove();
   void WindowResize();
   void WindowActivate();
   void PropertyChange(LPCTSTR szProperty);
};

class IWebBrowserAppImpl : public COleDispatchDriver
{
public:
   IWebBrowserAppImpl() {}    // Calls COleDispatchDriver default constructor
   ~IWebBrowserAppImpl() {}    // Calls COleDispatchDriver default destructor
   IWebBrowserAppImpl(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
   IWebBrowserAppImpl(const IWebBrowserAppImpl& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

public:
   void GoBack();
   void GoForward();
   void GoHome();
   void GoSearch();
   void Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
   void Refresh();
   void Refresh2(VARIANT* Level);
   void Stop();
   LPDISPATCH GetApplication();
   LPDISPATCH GetParent();
   LPDISPATCH GetContainer();
   LPDISPATCH GetDocument();
   BOOL  GetTopLevelContainer();
   CStr* GetType();
   long  GetLeft();
   void  SetLeft(long nNewValue);
   long  GetTop();
   void  SetTop(long nNewValue);
   long  GetWidth();
   void  SetWidth(long nNewValue);
   long  GetHeight();
   void  SetHeight(long nNewValue);
   void  GetLocationName(CStr* pcsz);
   void  GetLocationURL(CStr* pcsz);
   BOOL  GetBusy();
   void  Quit();
   void  ClientToWindow(long* pcx, long* pcy);
   void  PutProperty(LPCTSTR szProperty, const VARIANT& vtValue);
   VARIANT GetProperty_(LPCTSTR szProperty);
   CStr* GetName();
   HWND  GetHwnd();
   CStr* GetFullName();
   CStr* GetPath();
   BOOL  GetVisible();
   void  SetVisible(BOOL bNewValue);
   BOOL  GetStatusBar();
   void  SetStatusBar(BOOL bNewValue);
   CStr* GetStatusText();
   void  SetStatusText(LPCTSTR lpszNewValue);
   long  GetToolBar();
   void  SetToolBar(long nNewValue);
   BOOL  GetMenuBar();
   void  SetMenuBar(BOOL bNewValue);
   BOOL  GetFullScreen();
   void  SetFullScreen(BOOL bNewValue);
};

#if 0
   void Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers);
   long QueryStatusWB(long cmdID);
   void ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut);
   long GetReadyState();
   BOOL GetOffline();
   void SetOffline(BOOL bNewValue);
   BOOL GetSilent();
   void SetSilent(BOOL bNewValue);
   BOOL GetRegisterAsBrowser();
   void SetRegisterAsBrowser(BOOL bNewValue);
   BOOL GetRegisterAsDropTarget();
   void SetRegisterAsDropTarget(BOOL bNewValue);
#endif      
      
#endif   // __WEB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\web.cpp ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#include "header.h"
#include "web.h"
#include "secwin.h"
#include <exdispid.h>

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

void OurVariantInit(LPVARIANT pVar);

COleDispatchDriver::COleDispatchDriver()
{
	m_lpDispatch = NULL;
	m_bAutoRelease = TRUE;
}

COleDispatchDriver::COleDispatchDriver(LPDISPATCH lpDispatch, BOOL bAutoRelease)
{
	m_lpDispatch = lpDispatch;
	m_bAutoRelease = bAutoRelease;
}

COleDispatchDriver::COleDispatchDriver(const COleDispatchDriver& dispatchSrc)
{
	ASSERT(this != &dispatchSrc);   // constructing from self?

	m_lpDispatch = dispatchSrc.m_lpDispatch;
	if (m_lpDispatch != NULL)
		m_lpDispatch->AddRef();
	m_bAutoRelease = TRUE;
}

void IWebBrowserAppImpl::GoBack()
{
    InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IWebBrowserAppImpl::GoForward()
{
    InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IWebBrowserAppImpl::GoHome()
{
    InvokeHelper(0x66, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IWebBrowserAppImpl::GoSearch()
{
    InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IWebBrowserAppImpl::Navigate(LPCTSTR pszUrl, VARIANT* pFlags,
    VARIANT* TargetFrameName, VARIANT* pPostData, VARIANT* Headers)
{
    static BYTE parms[] =
            VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
    InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms,pszUrl, pFlags, TargetFrameName, pPostData, Headers);
}

void IWebBrowserAppImpl::Refresh()
{
    InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IWebBrowserAppImpl::Refresh2(VARIANT* Level)
{
    static BYTE parms[] = VTS_PVARIANT;
    InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Level);
}

void IWebBrowserAppImpl::Stop()
{
    InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH IWebBrowserAppImpl::GetApplication()
{
    LPDISPATCH result;
    InvokeHelper(0xc8, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

LPDISPATCH IWebBrowserAppImpl::GetParent()
{
    LPDISPATCH result;
    InvokeHelper(0xc9, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

LPDISPATCH IWebBrowserAppImpl::GetContainer()
{
    LPDISPATCH result;
    InvokeHelper(0xca, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

LPDISPATCH IWebBrowserAppImpl::GetDocument()
{
    LPDISPATCH result;
    InvokeHelper(0xcb, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
    return result;
}

BOOL IWebBrowserAppImpl::GetTopLevelContainer()
{
    BOOL result;
    InvokeHelper(0xcc, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}

CStr* IWebBrowserAppImpl::GetType()
{
    CStr* presult = new CStr;
    InvokeHelper(0xcd, DISPATCH_PROPERTYGET, VT_BSTR, (void*)presult, NULL);
    return presult;
}

long IWebBrowserAppImpl::GetLeft()
{
    long result;
    InvokeHelper(0xce, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetLeft(long nNewValue)
{
    static BYTE parms[] = VTS_I4;
    InvokeHelper(0xce, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, nNewValue);
}

long IWebBrowserAppImpl::GetTop()
{
    long result;
    InvokeHelper(0xcf, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetTop(long nNewValue)
{
    static BYTE parms[] = VTS_I4;
#if 0
    DISPID dispid;
    LPWSTR pszDispMethod = L"put_Top";
    HRESULT hr = m_lpDispatch->GetIDsOfNames(IID_NULL, &pszDispMethod, 1, g_lcidSystem, &dispid);
#endif

    InvokeHelper(0xcf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, nNewValue);
}

long IWebBrowserAppImpl::GetWidth()
{
    long result;
    InvokeHelper(0xd0, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetWidth(long nNewValue)
{
    static BYTE parms[] = VTS_I4;
    InvokeHelper(0xd0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, nNewValue);
}

long IWebBrowserAppImpl::GetHeight()
{
    long result;
    InvokeHelper(0xd1, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetHeight(long nNewValue)
{
    static BYTE parms[] = VTS_I4;
    InvokeHelper(0xd1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, nNewValue);
}

void IWebBrowserAppImpl::GetLocationName(CStr* pcsz)
{
    InvokeHelper(0xd2, DISPATCH_PROPERTYGET, VT_BSTR, (void*) pcsz, NULL);
}

void IWebBrowserAppImpl::GetLocationURL(CStr* pcsz)
{
    InvokeHelper(0xd3, DISPATCH_PROPERTYGET, VT_BSTR, (void*) pcsz, NULL);
}

BOOL IWebBrowserAppImpl::GetBusy()
{
    BOOL result;
    InvokeHelper(0xd4, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::Quit()
{
//  InvokeHelper(0x12c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IWebBrowserAppImpl::ClientToWindow(long* pcx, long* pcy)
{
    static BYTE parms[] = VTS_PI4 VTS_PI4;
    InvokeHelper(0x12d, DISPATCH_METHOD, VT_EMPTY, NULL, parms, pcx, pcy);
}

void IWebBrowserAppImpl::PutProperty(LPCTSTR szProperty, const VARIANT& vtValue)
{
    static BYTE parms[] = VTS_BSTR VTS_VARIANT;
    InvokeHelper(0x12e, DISPATCH_METHOD, VT_EMPTY, NULL, parms, szProperty, &vtValue);
}

VARIANT IWebBrowserAppImpl::GetProperty_(LPCTSTR szProperty)
{
    VARIANT result;
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(0x12f, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
            szProperty);
    return result;
}

CStr* IWebBrowserAppImpl::GetName()
{
    CStr* presult = new CStr;
    InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*) presult, NULL);
    return presult;
}

HWND IWebBrowserAppImpl::GetHwnd()
{
#if 0
    // initialize EXCEPINFO struct
    EXCEPINFO excepInfo;
    ZERO_STRUCTURE(excepInfo);
    UINT nArgErr = (UINT)-1;  // initialize to invalid arg
    VARIANT vaResult;
    OurVariantInit(&vaResult);
    DISPPARAMS dispparams;
    ZERO_STRUCTURE(dispparams);

    SCODE sc = m_lpDispatch->Invoke(DISPID_HWND, IID_NULL, 0,
        DISPATCH_PROPERTYGET,
        &dispparams, &vaResult, &excepInfo, &nArgErr);

    if (FAILED(sc)) {
        VariantClear(&vaResult);

        // BUGBUG: need to notify caller

        return 0;
    }
    return vaResult.lVal;
#endif


    HWND hwnd = NULL;
    InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&hwnd, NULL);
    return hwnd;
}

CStr* IWebBrowserAppImpl::GetFullName()
{
    CStr* presult = new CStr;
    InvokeHelper(0x190, DISPATCH_PROPERTYGET, VT_BSTR, (void*) presult, NULL);
    return presult;
}

CStr* IWebBrowserAppImpl::GetPath()
{
    CStr* presult = new CStr;
    InvokeHelper(0x191, DISPATCH_PROPERTYGET, VT_BSTR, (void*) presult, NULL);
    return presult;
}

BOOL IWebBrowserAppImpl::GetVisible()
{
    BOOL result;
    InvokeHelper(0x192, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetVisible(BOOL bNewValue)
{
    static BYTE parms[] = VTS_BOOL;
    InvokeHelper(0x192, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
                 bNewValue);
}

BOOL IWebBrowserAppImpl::GetStatusBar()
{
    BOOL result;
    InvokeHelper(0x193, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetStatusBar(BOOL bNewValue)
{
    static BYTE parms[] = VTS_BOOL;
    InvokeHelper(0x193, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, bNewValue);
}

CStr* IWebBrowserAppImpl::GetStatusText()
{
    CStr* presult = new CStr;
    InvokeHelper(0x194, DISPATCH_PROPERTYGET, VT_BSTR, (void*) presult, NULL);
    return presult;
}

void IWebBrowserAppImpl::SetStatusText(LPCTSTR lpszNewValue)
{
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(0x194, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
                 lpszNewValue);
}

long IWebBrowserAppImpl::GetToolBar()
{
    long result;
    InvokeHelper(0x195, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetToolBar(long nNewValue)
{
    static BYTE parms[] = VTS_I4;
    InvokeHelper(0x195, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, nNewValue);
}

BOOL IWebBrowserAppImpl::GetMenuBar()
{
    BOOL result;
    InvokeHelper(0x196, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetMenuBar(BOOL bNewValue)
{
    static BYTE parms[] = VTS_BOOL;
    InvokeHelper(0x196, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, bNewValue);
}

BOOL IWebBrowserAppImpl::GetFullScreen()
{
    BOOL result;
    InvokeHelper(0x197, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
    return result;
}

void IWebBrowserAppImpl::SetFullScreen(BOOL bNewValue)
{
    static BYTE parms[] = VTS_BOOL;
    InvokeHelper(0x197, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms, bNewValue);
}

void DWebBrowserEventsImpl::BeforeNavigate(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Cancel)
{
    static BYTE parms[] = VTS_BSTR VTS_I4 VTS_BSTR VTS_PVARIANT VTS_BSTR VTS_PBOOL;
    InvokeHelper(DISPID_BEFORENAVIGATE, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        URL, Flags, TargetFrameName, PostData, Headers, Cancel);
}

void DWebBrowserEventsImpl::NavigateComplete(LPCTSTR URL)
{
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(DISPID_NAVIGATECOMPLETE, DISPATCH_METHOD, VT_EMPTY, NULL, parms, URL);
}

void DWebBrowserEventsImpl::StatusTextChange(LPCTSTR Text)
{
#if 0
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(DISPID_STATUSTEXTCHANGE, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Text);
#endif
}

void DWebBrowserEventsImpl::ProgressChange(long Progress, long ProgressMax)
{
#if 0
    static BYTE parms[] = VTS_I4 VTS_I4;
    InvokeHelper(DISPID_PROGRESSCHANGE, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        Progress, ProgressMax);
#endif
}

void DWebBrowserEventsImpl::DownloadComplete()
{
#if 0
    DBWIN("*** DWebBrowserEventsImpl::DownloadComplete() ***");
    InvokeHelper(DISPID_DOWNLOADCOMPLETE, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
#endif
}

void DWebBrowserEventsImpl::CommandStateChange(long Command, BOOL Enable)
{
#if 0
    static BYTE parms[] = VTS_I4 VTS_BOOL;
    InvokeHelper(DISPID_COMMANDSTATECHANGE, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        Command, Enable);
#endif
}

void DWebBrowserEventsImpl::DownloadBegin()
{
#if 0
    InvokeHelper(DISPID_DOWNLOADBEGIN, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
#endif
}

void DWebBrowserEventsImpl::NewWindow(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Processed)
{
    static BYTE parms[] = VTS_BSTR VTS_I4 VTS_BSTR VTS_PVARIANT VTS_BSTR VTS_PBOOL;
    InvokeHelper(DISPID_NEWWINDOW, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        URL, Flags, TargetFrameName, PostData, Headers, Processed);
}

void DWebBrowserEventsImpl::TitleChange(LPCTSTR Text)
{
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(DISPID_TITLECHANGE, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Text);
}

void DWebBrowserEventsImpl::FrameBeforeNavigate(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Cancel)
{
    static BYTE parms[] = VTS_BSTR VTS_I4 VTS_BSTR VTS_PVARIANT VTS_BSTR VTS_PBOOL;
    InvokeHelper(DISPID_FRAMEBEFORENAVIGATE, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        URL, Flags, TargetFrameName, PostData, Headers, Cancel);
}

void DWebBrowserEventsImpl::FrameNavigateComplete(LPCTSTR URL)
{
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(DISPID_FRAMENAVIGATECOMPLETE, DISPATCH_METHOD, VT_EMPTY, NULL, parms, URL);
}

void DWebBrowserEventsImpl::FrameNewWindow(LPCTSTR URL, long Flags, LPCTSTR TargetFrameName, VARIANT* PostData, LPCTSTR Headers, BOOL* Processed)
{
    static BYTE parms[] = VTS_BSTR VTS_I4 VTS_BSTR VTS_PVARIANT VTS_BSTR VTS_PBOOL;
    InvokeHelper(DISPID_FRAMENEWWINDOW, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
        URL, Flags, TargetFrameName, PostData, Headers, Processed);
}

void DWebBrowserEventsImpl::Quit(BOOL* Cancel)
{
    static BYTE parms[] = VTS_PBOOL;
    InvokeHelper(DISPID_QUIT, DISPATCH_METHOD, VT_EMPTY, NULL, parms, Cancel);
}

void DWebBrowserEventsImpl::WindowMove()
{
    InvokeHelper(DISPID_WINDOWMOVE, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void DWebBrowserEventsImpl::WindowResize()
{
    InvokeHelper(DISPID_WINDOWRESIZE, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void DWebBrowserEventsImpl::WindowActivate()
{
    InvokeHelper(DISPID_WINDOWACTIVATE, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void DWebBrowserEventsImpl::PropertyChange(LPCTSTR szProperty)
{
#if 0
    static BYTE parms[] = VTS_BSTR;
    InvokeHelper(DISPID_PROPERTYCHANGE, DISPATCH_METHOD, VT_EMPTY, NULL, parms, szProperty);
#endif
}

void __cdecl COleDispatchDriver::InvokeHelper(DISPID dwDispID, WORD wFlags,
	VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...)
{
	va_list argList;
	va_start(argList, pbParamInfo);

	InvokeHelperV(dwDispID, wFlags, vtRet, pvRet, pbParamInfo, argList);

	va_end(argList);
}

void OurVariantInit(LPVARIANT pVar)
{
    memset(pVar, 0, sizeof(*pVar));
}

void COleDispatchDriver::InvokeHelperV(DISPID dwDispID, WORD wFlags,
	VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, va_list argList)
{
    ASSERT(m_lpDispatch);
	if (m_lpDispatch == NULL)
	{
		DBWIN("Warning: attempt to call Invoke with NULL m_lpDispatch!\n");
		return;
	}

	DISPPARAMS dispparams;
	memset(&dispparams, 0, sizeof dispparams);

	// determine number of arguments
	if (pbParamInfo != NULL)
		dispparams.cArgs = lstrlenA((LPCSTR)pbParamInfo);

	DISPID dispidNamed = DISPID_PROPERTYPUT;
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
	{
		ASSERT(dispparams.cArgs > 0);
		dispparams.cNamedArgs = 1;
		dispparams.rgdispidNamedArgs = &dispidNamed;
	}

	if (dispparams.cArgs != 0)
	{
		// allocate memory for all VARIANT parameters
		VARIANT* pArg = new VARIANT[dispparams.cArgs];
		ASSERT(pArg != NULL);   // should have thrown exception
		dispparams.rgvarg = pArg;
		memset(pArg, 0, sizeof(VARIANT) * dispparams.cArgs);

		// get ready to walk vararg list
		const BYTE* pb = pbParamInfo;
		pArg += dispparams.cArgs - 1;   // params go in opposite order

		while (*pb != 0)
		{
			ASSERT(pArg >= dispparams.rgvarg);

			pArg->vt = *pb; // set the variant type
			if (pArg->vt & VT_MFCBYREF)
			{
				pArg->vt &= ~VT_MFCBYREF;
				pArg->vt |= VT_BYREF;
			}
			switch (pArg->vt)
			{
			case VT_UI1:
				pArg->bVal = va_arg(argList, BYTE);
				break;
			case VT_I2:
				pArg->iVal = va_arg(argList, short);
				break;
			case VT_I4:
				pArg->lVal = va_arg(argList, long);
				break;
			case VT_R4:
				pArg->fltVal = (float)va_arg(argList, double);
				break;
			case VT_R8:
				pArg->dblVal = va_arg(argList, double);
				break;
			case VT_DATE:
				pArg->date = va_arg(argList, DATE);
				break;
			case VT_CY:
				pArg->cyVal = *va_arg(argList, CY*);
				break;
			case VT_BSTR:
				{
					LPCOLESTR lpsz = va_arg(argList, LPOLESTR);
					pArg->bstrVal = ::SysAllocString(lpsz);
					if (lpsz != NULL && pArg->bstrVal == NULL)
					{
						OOM();
						return;
					}
				}
				break;
			case VT_BSTRA:
				{
					LPCSTR lpsz = va_arg(argList, LPSTR);
                    CWStr csz(lpsz);
                    pArg->bstrVal = ::SysAllocString(csz);
					if (lpsz != NULL && pArg->bstrVal == NULL)
					{
						OOM();
						return;
					}
					pArg->vt = VT_BSTR;
				}
				break;
			case VT_DISPATCH:
				pArg->pdispVal = va_arg(argList, LPDISPATCH);
				break;
			case VT_ERROR:
				pArg->scode = va_arg(argList, SCODE);
				break;
			case VT_BOOL:
				V_BOOL(pArg) = (VARIANT_BOOL)(va_arg(argList, BOOL) ? -1 : 0);
				break;
			case VT_VARIANT:
				*pArg = *va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN:
				pArg->punkVal = va_arg(argList, LPUNKNOWN);
				break;

			case VT_I2|VT_BYREF:
				pArg->piVal = va_arg(argList, short*);
				break;
			case VT_UI1|VT_BYREF:
				pArg->pbVal = va_arg(argList, BYTE*);
				break;
			case VT_I4|VT_BYREF:
				pArg->plVal = va_arg(argList, long*);
				break;
			case VT_R4|VT_BYREF:
				pArg->pfltVal = va_arg(argList, float*);
				break;
			case VT_R8|VT_BYREF:
				pArg->pdblVal = va_arg(argList, double*);
				break;
			case VT_DATE|VT_BYREF:
				pArg->pdate = va_arg(argList, DATE*);
				break;
			case VT_CY|VT_BYREF:
				pArg->pcyVal = va_arg(argList, CY*);
				break;
			case VT_BSTR|VT_BYREF:
				pArg->pbstrVal = va_arg(argList, BSTR*);
				break;
			case VT_DISPATCH|VT_BYREF:
				pArg->ppdispVal = va_arg(argList, LPDISPATCH*);
				break;
			case VT_ERROR|VT_BYREF:
				pArg->pscode = va_arg(argList, SCODE*);
				break;
			case VT_BOOL|VT_BYREF:
				{
					// coerce BOOL into VARIANT_BOOL
					BOOL* pboolVal = va_arg(argList, BOOL*);
					*pboolVal = *pboolVal ? MAKELONG(-1, 0) : 0;
					pArg->pboolVal = (VARIANT_BOOL*)pboolVal;
				}
				break;
			case VT_VARIANT|VT_BYREF:
				pArg->pvarVal = va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN|VT_BYREF:
				pArg->ppunkVal = va_arg(argList, LPUNKNOWN*);
				break;

			default:
				ASSERT(FALSE);  // unknown type!
				break;
			}

			--pArg; // get ready to fill next argument
			++pb;
		}
	}

	// initialize return value
	VARIANT* pvarResult = NULL;
	VARIANT vaResult;
	OurVariantInit(&vaResult);
	if (vtRet != VT_EMPTY)
		pvarResult = &vaResult;

	// initialize EXCEPINFO struct
	EXCEPINFO excepInfo;
	memset(&excepInfo, 0, sizeof excepInfo);

	UINT nArgErr = (UINT)-1;  // initialize to invalid arg

	// make the call
	SCODE sc = m_lpDispatch->Invoke(dwDispID, IID_NULL, 0, wFlags,
		&dispparams, pvarResult, &excepInfo, &nArgErr);

	// cleanup any arguments that need cleanup
	if (dispparams.cArgs != 0)
	{
		VARIANT* pArg = dispparams.rgvarg + dispparams.cArgs - 1;
		const BYTE* pb = pbParamInfo;
		while (*pb != 0)
		{
			switch ((VARTYPE)*pb)
			{
#if !defined(_UNICODE) && !defined(OLE2ANSI)
			case VT_BSTRA:
#endif
			case VT_BSTR:
				VariantClear(pArg);
				break;
			}
			--pArg;
			++pb;
		}
	}
	delete[] dispparams.rgvarg;

	if (FAILED(sc))
	{
        VariantClear(&vaResult);
		if (pvRet)
			*(long*)pvRet = 0;

        // BUGBUG: need to notify caller

        return;
	}

	if (vtRet != VT_EMPTY)
	{
		// convert return value
		if (vtRet != VT_VARIANT)
		{
			SCODE sc = VariantChangeType(&vaResult, &vaResult, 0, vtRet);
			if (FAILED(sc))
			{
                DBWIN("Warning: automation return value coercion failed.");
                VariantClear(&vaResult);
                // BUGBUG: notify caller
                return;
			}
			ASSERT(vtRet == vaResult.vt);
		}

		// copy return value into return spot!
		switch (vtRet)
		{
		case VT_UI1:
			*(BYTE*)pvRet = vaResult.bVal;
			break;
		case VT_I2:
			*(short*)pvRet = vaResult.iVal;
			break;
		case VT_I4:
			*(long*)pvRet = vaResult.lVal;
			break;

#if 0
26-Sep-1997 [ralphw] Enable as necessary
		case VT_R4:
			*(_AFX_FLOAT*)pvRet = *(_AFX_FLOAT*)&vaResult.fltVal;
			break;
		case VT_R8:
			*(_AFX_DOUBLE*)pvRet = *(_AFX_DOUBLE*)&vaResult.dblVal;
			break;
		case VT_DATE:
			*(_AFX_DOUBLE*)pvRet = *(_AFX_DOUBLE*)&vaResult.date;
			break;
#endif

		case VT_CY:
			*(CY*)pvRet = vaResult.cyVal;
			break;
		case VT_BSTR:
            *((CStr*) pvRet) = (WCHAR*) vaResult.bstrVal;
			break;
		case VT_DISPATCH:
			*(LPDISPATCH*)pvRet = vaResult.pdispVal;
			break;
		case VT_ERROR:
			*(SCODE*)pvRet = vaResult.scode;
			break;
		case VT_BOOL:
			*(BOOL*)pvRet = (V_BOOL(&vaResult) != 0);
			break;
		case VT_VARIANT:
			*(VARIANT*)pvRet = vaResult;
			break;
		case VT_UNKNOWN:
			*(LPUNKNOWN*)pvRet = vaResult.punkVal;
			break;

		default:
            ASSERT_COMMENT(FALSE, "invalid return type specified");
		}
	}
}

void COleDispatchDriver::ReleaseDispatch()
{
	if (m_lpDispatch != NULL)
	{
		if (m_bAutoRelease)
			m_lpDispatch->Release();
		m_lpDispatch = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\wndproc.cpp ===
// Copyright (C) Microsoft Corporation 1996, All Rights reserved.

#include "header.h"
#include <commctrl.h>
#include "contain.h"
#include "secwin.h"
#include "strtable.h"
#include "resource.h"
#include "cnotes.h"
#include "system.h"
#include "stdio.h"
#include "string.h"
#include "parserhh.h"
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"
#include "highlite.h"
#include "htmlhelp.h"
#include "htmlpriv.h"
#include <wininet.h>
#include "cdefinss.h"
#include "subset.h"
#include <windowsx.h>
#include "adsearch.h"   // Used so we can update the subset combo in the AFTS tab after the define subset wizard.

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

extern BOOL g_HackForBug_HtmlHelpDB_1884;

//////////////////////////////////////////////////////////////////////////
//
// Internal Helper Prototypes
//
LRESULT OnKeyDown(HWND hwnd, WPARAM wParam, LPARAM lParam) ;
void DrawNavWnd(HWND hWnd) ;
LRESULT OnAppCommand(HWND hwnd, WPARAM wParam, LPARAM lParam);
#ifndef APPCOMMAND_BROWSER_BACKWARD
#define FAPPCOMMAND_MASK  0xF000
#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#define WM_APPCOMMAND                   0x0319
#define APPCOMMAND_BROWSER_BACKWARD       1
#define APPCOMMAND_BROWSER_FORWARD        2
#define APPCOMMAND_BROWSER_REFRESH        3
#define APPCOMMAND_BROWSER_STOP           4
#define APPCOMMAND_BROWSER_SEARCH         5
#define APPCOMMAND_BROWSER_FAVORITES      6
#define APPCOMMAND_BROWSER_HOME           7
#endif

//
// CAboutDlg
//
class CAboutDlg : public CDlg
{
public:
    CAboutDlg(HWND hwndParent) : CDlg(hwndParent, IDD_ABOUT) {
    }
    BOOL OnBeginOrEnd();
};

BOOL CAboutDlg::OnBeginOrEnd()
{
    if (m_fInitializing) {
        SetWindowText(IDC_VERSION, GetStringResource(IDS_VERSION));
    }
    return TRUE;
}

static void UpdateSearchHiMenu(CHHWinType* phh, TBBUTTON * tbbtn);
static void doOptionsMenu(CHHWinType* phh, HWND hwnd);
void        doWindowInformation(HWND hwndParent, CHHWinType* phh);
extern BOOL AddTitleToGlobalList(PCSTR pszITSSFile);

LRESULT WINAPI HelpWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CHHWinType* phh;

    if (msg == MSG_MOUSEWHEEL) {
        phh = FindWindowIndex(hwnd);
        if (phh)
            return phh->m_pCIExpContainer->ForwardMessage(msg, wParam, lParam);
        return 0;
    }

    switch(msg) {
/*
        case WM_UPDATEUISTATE:
            {
                char buf[500] ;
                sprintf(buf, "hWnd = %x, Element = %x, State = %x", hwnd, HIWORD(wParam), LOWORD(wParam)) ;
                MessageBox(hwnd, buf, "WM_UPDATEUISTATE", MB_OK);
            }
            return DefWindowProc(hwnd, msg, wParam, lParam);

        case WM_CHANGEUISTATE:
            {
                char buf[500] ;
                sprintf(buf, "hWnd = %x, Element = %x, State = %x", hwnd, HIWORD(wParam), LOWORD(wParam)) ;
                MessageBox(hwnd, buf, "WM_UPDATEUISTATE", MB_OK);
            }
            return DefWindowProc(hwnd, msg, wParam, lParam);
*/

        case WM_CREATE:
            phh = FindWindowIndex(hwnd);
            if (phh)
            {
                UiStateInitialize(phh->GetHwnd()) ;
            }
            return 0 ;

        case WM_NCCREATE:
            return TRUE;

        case WM_APPCOMMAND:
            if (OnAppCommand(hwnd, wParam, lParam) == 1)
	           return 1;
            return DefWindowProc(hwnd, msg, wParam, lParam);

        case WM_ACTIVATE:
            phh = FindWindowIndex(hwnd);
            if (phh)
            {
                if (LOWORD(wParam) != WA_INACTIVE)
                {
                    //SetForegroundWindow(hwnd);
                    if (!phh->RestoreCtrlWithFocus())
                    {
                       if (phh->m_pCIExpContainer) //TODO: Architect out these checks
                       {
                           if ( phh->m_pCIExpContainer->m_hWnd == phh->m_hwndFocused )
                           {
                              phh->m_pCIExpContainer->SetFocus();
                           }
                           else
                           {
                              if (phh->IsExpandedNavPane())
                              {
                                 phh->m_pCIExpContainer->UIDeactivateIE();
                                 int iTabIndex = (int)::SendMessage(phh->m_hwndFocused, TCM_GETCURSEL, 0, 0);
                                 phh->doSelectTab(phh->tabOrder[iTabIndex]);
                              }
                              else
                                 phh->m_pCIExpContainer->SetFocus(TRUE);
                           }
                       }
                    }

                    // Don't expand if activation is part of creation

                    if (phh->IsProperty(HHWIN_PROP_TAB_AUTOHIDESHOW) && !phh->IsExpandedNavPane())
                    {
                        MSG peekmsg;
                        if (PeekMessage(&peekmsg, hwnd, WM_SYSCOMMAND, WM_SYSCOMMAND, PM_NOREMOVE) )
                        {
                            if ( (peekmsg.wParam & 0xFFF0) == SC_MINIMIZE )
                                return 0;
                        }
                        else
                            DWORD dwErr = GetLastError();
                        if ( !HIWORD(wParam) && !phh->m_fActivated)
                            PostMessage(hwnd, WM_COMMAND, IDTB_AUTO_SHOW, 0);
                    }
                    if (!phh->m_fActivated)
                        phh->m_fActivated = TRUE;
                    //
                    // !!Hack alert!!
                    //
                    // For some unknown reason winhelp popup's create painting problems. I believe that the root of the
                    // problem lies in the way winhelp popup's are implemented. It seems that the popup paints on the window
                    // that it sits over and then upon dismissal it invalidates the area it painted on but it does not call
                    // UpdateWindow(). Obviously we can't do anything about that now. This code detects the case where we have
                    // received activation from a winhelp popup and forces a WM_PAINT message to go to the ie window.
                    //
                    if ( g_HackForBug_HtmlHelpDB_1884 )
                    {
                       if (phh->m_pCIExpContainer)
                          UpdateWindow(phh->m_pCIExpContainer->m_hWnd);
                       g_HackForBug_HtmlHelpDB_1884 = 0;
                    }
                }
                else
                {
                    phh->SaveCtrlWithFocus() ;
                    phh->m_fActivated = FALSE;
                    if ( phh->IsProperty(HHWIN_PROP_TAB_AUTOHIDESHOW) && !phh->fNotExpanded)
                    {
                        MSG peekmsg;
                        while (PeekMessage(&peekmsg, hwnd, WM_SYSCOMMAND, WM_SYSCOMMAND, PM_NOREMOVE))
                        {
                            if ( (peekmsg.wParam & 0xFFF0) == SC_MINIMIZE )
                                return 0;
                        }
                        if (!HIWORD(wParam) )  // if not minimized
                            phh->ToggleExpansion();//SendMessage(hwnd, WM_COMMAND, IDTB_CONTRACT, 0);
                    }
                }
            }
            return FALSE;

        case WM_DESTROY:
            // Find the index into our array of HELPWINDOWS structures

            phh = FindWindowIndex(hwnd);
            if (phh)
            {
                    // shutdown the child windows and controls.
                for(int j=0; j< c_NUMNAVPANES; j++)
                {
                   if ( phh->m_aNavPane[j] )
                   {
                       delete phh->m_aNavPane[j];
                       phh->m_aNavPane[j] = NULL;
                   }
                }
                if ( phh->m_pTabCtrl )
                {
                    delete phh->m_pTabCtrl;
                    phh->m_pTabCtrl = NULL;
                }
                if ( phh->m_pSizeBar )
                {
                    delete phh->m_pSizeBar;
                    phh->m_pSizeBar = NULL;
                }
                if ( phh->hwndToolBar )
                {
                    DestroyWindow( phh->hwndToolBar );
                    phh->hwndToolBar = NULL;
                }

                if( phh->m_hImageListGray ) {
                  ImageList_Destroy( phh->m_hImageListGray );
                  phh->m_hImageListGray = NULL;
                }

                if( phh->m_hImageList ) {
                  ImageList_Destroy( phh->m_hImageList );
                  phh->m_hImageList = NULL;
                }

                // Get the desktop window.
                HWND hWndDesktop = ::GetDesktopWindow() ;
                if (hWndDesktop != phh->hwndCaller)
                {
                    // VS98 Bug 14755 - We were setting the foreground window to be that
                    // of the desktop when we were embedded in vs98. To fix the bug,
                    // we let windows pick the foreground window.
                    SetForegroundWindow(phh->hwndCaller);
                }

                // Check to see if we are destroying the last window.
                // If not, then just set the current phh->hwndHelp
                // member to NULL so the WIN_TYPE can be used again.
                //
                BOOL bOtherWindowsExist = FALSE;

                // Determine if other windows exist.
                //
                for (int i = 0; i < g_cWindowSlots; i++)
                {
                    if (pahwnd[i] != NULL && pahwnd[i]->hwndHelp != NULL && pahwnd[i] != phh)
                        bOtherWindowsExist = TRUE;
                }

                // If other windows exist, then remove this window handle from the
                // the current HH_WIN_TYPE.  If we are asked to display another topic
                // of this window type the hwndHelp member will be used to store the
                // handle of the new window created.
                //
                if(bOtherWindowsExist)
                {
                    phh->hwndHelp = NULL;

                    // Delete the container
                    //
                    if (phh->m_pCIExpContainer)
                    {
                        phh->m_pCIExpContainer->ShutDown();
                        phh->m_pCIExpContainer = NULL;
                    }

                    phh->m_phmData = NULL;
                }
                else
                {
                    // This is the last window.  Destroy all HH_WIN_TYPE objects.
                    //
                    for (int i = 0; i < g_cWindowSlots; i++)
                    {
                        if (pahwnd[i] != NULL)
                        {
                            delete pahwnd[i];
                            pahwnd[i] = NULL;
                        }
                    }
                }
            }
            return DefWindowProc(hwnd, msg, wParam, lParam);

        case WM_MENUCHAR: // translate the accelerator key strokes.
sim_menuchar:
        PostMessage(hwnd, WMP_HH_TRANS_ACCELERATOR, ToLower(static_cast<char>(LOWORD(wParam))), (LPARAM)NULL);
            return MAKELONG( 0, MNC_CLOSE) ;

        case WMP_HH_TRANS_ACCELERATOR:
            phh = FindWindowIndex(hwnd);
            if (!phh)
                phh = FindWindowIndex(GetParent(hwnd));
            if (!phh)
                break;

            return phh->ManualTranslateAccelerator(ToLower(static_cast<char>(LOWORD(wParam))));

      case WM_KEYDOWN:
          return OnKeyDown(hwnd, wParam, lParam) ;

      case WM_SIZE:
         switch (wParam) {
            case SIZE_RESTORED:
            case SIZE_MAXIMIZED:
            case SIZE_MAXSHOW:
               phh = FindWindowIndex(hwnd);
               if (phh)
               {
                  if (hwnd == *phh)
                  {
                     if (phh->hwndToolBar )
                         phh->WrapTB();

                     if (phh->hwndHTML)
                     {
                        ResizeWindow(phh);
                     }
                     else if (phh->m_pCIExpContainer)
                     {
                        // non tri-pane window
                        ::GetClientRect(phh->hwndHelp, &phh->rcHTML);
                        phh->m_pCIExpContainer->SizeIt(RECT_WIDTH(phh->rcHTML), RECT_HEIGHT(phh->rcHTML));
                     }
                  }
               }
               break;
         }
         return DefWindowProc(hwnd, msg, wParam, lParam);

    case WM_SYSCOMMAND:
        if ((LOWORD(wParam) >= IDC_SELECT_TAB_FIRST) && (LOWORD(wParam) <= IDC_SELECT_TAB_LAST))
        {
            phh = FindWindowIndex(hwnd);
            if (!phh)
                phh = FindWindowIndex(GetParent(hwnd));
            if (phh)
                phh->doSelectTab(LOWORD(wParam) - IDC_SELECT_TAB_FIRST) ;
        }
        else if (LOWORD(wParam) == IDM_VERSION) {
         if (IsHelpAuthor(hwnd)) {
               phh = FindWindowIndex(hwnd);
              if (!phh)
                 phh = FindWindowIndex(GetParent(hwnd));
            doHhctrlVersion(hwnd,
               (phh && phh->m_phmData && phh->m_phmData->GetInfo() ? phh->m_phmData->GetInfo()->GetCompilerInformation() : NULL));
         }
         else
            goto about;
            break;
        }
        else if (LOWORD(wParam) == ID_JUMP_URL) {
JumpURL:
            phh = FindWindowIndex(hwnd);
            if (!phh)
                phh = FindWindowIndex(GetParent(hwnd));
            if (!phh)
                break;
            char szDstUrl[INTERNET_MAX_URL_LENGTH];
            CStr cszCurUrl;
            phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszCurUrl);
            if (doJumpUrl(hwnd, cszCurUrl, szDstUrl) && szDstUrl[0])
                phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(szDstUrl, NULL, NULL, NULL, NULL);
            break;
        }
        else if (LOWORD(wParam) == IDM_WINDOW_INFO) {
            phh = FindWindowIndex(hwnd);
            if (!phh)
                phh = FindWindowIndex(GetParent(hwnd));
            doWindowInformation(hwnd, phh);
            break;
        }
#ifdef _DEBUG
        else if (LOWORD(wParam) == ID_VIEW_MEMORY) {
            OnReportMemoryUsage();
            break;
        }
        else if (LOWORD(wParam) == ID_DEBUG_BREAK) {
#ifdef _DEBUG
            DebugBreak();
#endif
            break;
        }
#endif
        return DefWindowProc(hwnd, msg, wParam, lParam);

    case WM_INITMENU:
        HMENU hMenu;

        if ( (phh = FindWindowIndex(hwnd)) )
        {
           hMenu = GetMenu(hwnd);

           if( hMenu ) {

             if(  phh->IsExpandedNavPane() )
                CheckMenuItem(hMenu, HHM_HIDE_SHOW, MF_CHECKED);
             else
                CheckMenuItem(hMenu, HHM_HIDE_SHOW, MF_UNCHECKED);

             if( !phh->m_iZoomMin && !phh->m_iZoomMax ) {

               CheckMenuItem(hMenu, IDTB_ZOOM_SMALLEST, MF_UNCHECKED);
               CheckMenuItem(hMenu, IDTB_ZOOM_SMALLER, MF_UNCHECKED);
               CheckMenuItem(hMenu, IDTB_ZOOM_MEDIUM, MF_UNCHECKED);
               CheckMenuItem(hMenu, IDTB_ZOOM_LARGER, MF_UNCHECKED);
               CheckMenuItem(hMenu, IDTB_ZOOM_LARGEST, MF_UNCHECKED);

               EnableMenuItem(hMenu, IDTB_ZOOM_SMALLEST, MF_GRAYED);
               EnableMenuItem(hMenu, IDTB_ZOOM_SMALLER, MF_GRAYED);
               EnableMenuItem(hMenu, IDTB_ZOOM_MEDIUM, MF_GRAYED);
               EnableMenuItem(hMenu, IDTB_ZOOM_LARGER, MF_GRAYED);
               EnableMenuItem(hMenu, IDTB_ZOOM_LARGEST, MF_GRAYED);

             }
             else {

               if( phh->m_iZoom == phh->m_iZoomMin )
                 CheckMenuItem(hMenu, IDTB_ZOOM_SMALLEST, MF_CHECKED);
               else
                 CheckMenuItem(hMenu, IDTB_ZOOM_SMALLEST, MF_UNCHECKED);

               if( phh->m_iZoom == phh->m_iZoomMin+1 )
                 CheckMenuItem(hMenu, IDTB_ZOOM_SMALLER, MF_CHECKED);
               else
                 CheckMenuItem(hMenu, IDTB_ZOOM_SMALLER, MF_UNCHECKED);

               if( phh->m_iZoom == phh->m_iZoomMin+2 )
                 CheckMenuItem(hMenu, IDTB_ZOOM_MEDIUM, MF_CHECKED);
               else
                 CheckMenuItem(hMenu, IDTB_ZOOM_MEDIUM, MF_UNCHECKED);

               if( phh->m_iZoom == phh->m_iZoomMax-1 )
                 CheckMenuItem(hMenu, IDTB_ZOOM_LARGER, MF_CHECKED);
               else
                 CheckMenuItem(hMenu, IDTB_ZOOM_LARGER, MF_UNCHECKED);

               if( phh->m_iZoom == phh->m_iZoomMax )
                 CheckMenuItem(hMenu, IDTB_ZOOM_LARGEST, MF_CHECKED);
               else
                 CheckMenuItem(hMenu, IDTB_ZOOM_LARGEST, MF_UNCHECKED);
              }

              // See if selection exists in doc window
              //
              if ( phh && phh->m_pCIExpContainer )
              {
                  LPDISPATCH lpDispatch = phh->m_pCIExpContainer->m_pWebBrowserApp->GetDocument();
                  if(lpDispatch)
                  {
                      WCHAR *pSelectText = GetSelectionText(lpDispatch);

                      lpDispatch->Release();

                      if(pSelectText)
                      {
                         SysFreeString(pSelectText);
                          EnableMenuItem(hMenu, HHM_COPY,   MF_BYCOMMAND | MF_ENABLED) ;
                      }
                      else
                          EnableMenuItem(hMenu, HHM_COPY,   MF_BYCOMMAND | MF_GRAYED) ;
                  }
                  else
                      EnableMenuItem(hMenu, HHM_COPY,   MF_BYCOMMAND | MF_GRAYED) ;
              }

              if (phh->GetCurrentNavPaneIndex() == HHWIN_NAVTYPE_TOC)
              {
               CheckMenuItem(hMenu, HHM_CONTENTS , MF_CHECKED);
               CheckMenuItem(hMenu, HHM_INDEX , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_SEARCH , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_FAVORITES , MF_UNCHECKED);
              }
              else if  (phh->GetCurrentNavPaneIndex() == HHWIN_NAVTYPE_INDEX)
              {
               CheckMenuItem(hMenu, HHM_INDEX , MF_CHECKED);
               CheckMenuItem(hMenu, HHM_CONTENTS , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_SEARCH , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_FAVORITES , MF_UNCHECKED);
              }
              else if  (phh->GetCurrentNavPaneIndex() == HHWIN_NAVTYPE_SEARCH)
              {
               CheckMenuItem(hMenu, HHM_SEARCH , MF_CHECKED);
               CheckMenuItem(hMenu, HHM_INDEX , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_CONTENTS , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_FAVORITES , MF_UNCHECKED);

              }
              else if  (phh->GetCurrentNavPaneIndex() == HHWIN_NAVTYPE_FAVORITES)
              {
               CheckMenuItem(hMenu, HHM_FAVORITES , MF_CHECKED);
               CheckMenuItem(hMenu, HHM_INDEX , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_SEARCH , MF_UNCHECKED);
               CheckMenuItem(hMenu, HHM_CONTENTS , MF_UNCHECKED);
              }

              if ( phh->m_phmData
                  && phh->m_phmData->m_pTitleCollection // Bug 4163: Why? TODO: Too much checking on state.
                  && phh->m_phmData->m_pTitleCollection->m_pSearchHighlight)
              {
                  if ( phh->m_phmData->m_pTitleCollection->m_pSearchHighlight->m_bHighlightEnabled )
                      CheckMenuItem(hMenu, HHM_SEARCHHILITE , MF_CHECKED);
                  else
                      CheckMenuItem(hMenu, HHM_SEARCHHILITE , MF_UNCHECKED);
              }
              else
                   EnableMenuItem(hMenu, HHM_SEARCHHILITE,   MF_BYCOMMAND | MF_GRAYED);


             if (phh->m_pCIExpContainer->m_pInPlaceActive)
             {
               EnableMenuItem(hMenu, HHM_SELECTALL,   MF_BYCOMMAND | MF_ENABLED) ;
               EnableMenuItem(hMenu, HHM_VIEWSOURCE,   MF_BYCOMMAND | MF_ENABLED) ;
              }
              else
              {
               EnableMenuItem(hMenu, HHM_SELECTALL,   MF_BYCOMMAND | MF_GRAYED) ;
               EnableMenuItem(hMenu, HHM_VIEWSOURCE,   MF_BYCOMMAND | MF_GRAYED) ;
              }
            }
            break;
        }
    case WM_COMMAND:
        phh = FindWindowIndex(hwnd);
        if (!phh)
            phh = FindWindowIndex(GetParent(hwnd));
        if (!phh)
            break;

        switch (LOWORD(wParam))
        {

            case IDC_SS_COMBO:
               if ( phh->m_pCIExpContainer )
                  phh->m_pCIExpContainer->UIDeactivateIE();
               SetFocus(GetDlgItem(hwnd,IDC_SS_PICKER));
               break;

            case IDC_SS_PICKER:
               if ( HIWORD(wParam) == CBN_SELCHANGE )
               {
                  if ( phh->m_phmData && phh->m_phmData->m_pTitleCollection && phh->m_phmData->m_pTitleCollection->m_pSSList )
                  {
                     HWND hWndCB = (HWND)lParam;
                     INT_PTR i;
                     TCHAR szSel[MAX_SS_NAME_LEN];
                     CStructuralSubset* pSS, *pSSCur;

                     pSSCur = phh->m_phmData->m_pTitleCollection->m_pSSList->GetTOC();
                     if ( (i = SendMessage(hWndCB, CB_GETCURSEL, 0, 0L)) != -1 )
                     {
                        SendMessage(hWndCB, CB_GETLBTEXT, i, (LPARAM)szSel);
                        if ( (pSS = phh->m_phmData->m_pTitleCollection->m_pSSList->GetSubset(szSel)) && pSS != pSSCur )
                        {
                           phh->m_phmData->m_pTitleCollection->m_pSSList->SetFTS(pSS);
                           phh->m_phmData->m_pTitleCollection->m_pSSList->SetF1(pSS);
                           phh->m_phmData->m_pTitleCollection->m_pSSList->SetTOC(pSS);
                           pSS->SelectAsTOCSubset(phh->m_phmData->m_pTitleCollection);
                           phh->UpdateInformationTypes();  // This call re-draws the TOC.
                        }
                        else
                        {
                            if ( pSS = phh->m_phmData->m_pTitleCollection->m_pSSList->GetEC() )
                            {
                                phh->m_phmData->m_pTitleCollection->m_pSSList->SetFTS(pSS);
                                phh->m_phmData->m_pTitleCollection->m_pSSList->SetF1(pSS);
                                phh->m_phmData->m_pTitleCollection->m_pSSList->SetTOC(pSS);
                                pSS->SelectAsTOCSubset(phh->m_phmData->m_pTitleCollection);
                                phh->UpdateInformationTypes();  // This call re-draws the TOC.
                            }
                        }
                     }
                  }
               }
               break;

            case IDTB_HILITE:
searchhighlight:
                if ( phh )
                {
                    if (phh->OnTrackNotifyCaller(HHACT_HIGHLIGHT))
                        break;

                    const int MENUITEMSTRINGLEN = 80;

                    if ( !(phh->m_phmData->m_pTitleCollection) && !(phh->m_phmData->m_pTitleCollection->m_pSearchHighlight) )
                       break;

               if ( phh->m_phmData->m_pTitleCollection->m_pSearchHighlight->m_bHighlightEnabled )
               {  // its currently on; turn it off
                  phh->m_phmData->m_pTitleCollection->m_pSearchHighlight->EnableHighlight(FALSE);   // TURN HIGHLIGHTING OFF
               }
               else
               {  // its currently off; turn it on.
                  phh->m_phmData->m_pTitleCollection->m_pSearchHighlight->EnableHighlight(TRUE);   // TURN HIGHLIGHTING ON
               }
               }
               break;

            case IDTB_CUSTOMIZE:
               if ( !phh )
                  break;

               if (phh->OnTrackNotifyCaller(HHACT_CUSTOMIZE))
                  break;

               // Currently only forward this to the TOC, because that the way the code was.
               if (phh->curNavType == HHWIN_NAVTYPE_TOC)
               {
                  // ASSERT(phh->m_aNavPane[phh->curNavType]) ;
                  if( phh && phh->m_aNavPane[phh->curNavType] )
                    phh->m_aNavPane[phh->curNavType]->OnCommand(hwnd, LOWORD(ID_CUSTOMIZE_INFO_TYPES), HIWORD(0), 0L);
               }
/*
               else if (phh->curNavType == HHWIN_NAVTYPE_INDEX)
                  break; //phh->m_aNavPane[HH_TAB_INDEX]->OnCommand(LOWORD(wParam), HIWORD(wParam));
               else if (phh->curNavType == HHWIN_NAVTYPE_SEARCH)
                  break; //phh->m_aNavPane[HH_TAB_SEARCH]->OnCommand(LOWORD(wParam), HIWORD(wParam), lParam );
*/

               break;

            case HHM_HOMEPAGE:
            case IDTB_HOME:
               if (!phh)
                  break;
               if (phh->OnTrackNotifyCaller(HHACT_HOME))
                  break;
               if (phh->pszHome)
                  phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(phh->pszHome, NULL, NULL, NULL, NULL);
               else
                  MsgBox(IDS_NO_HOMEPAGE, (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL));
               break;

            case IDTB_JUMP1:
               if (!phh)
                  break;
               if (phh->OnTrackNotifyCaller(HHACT_JUMP1))
                  break;

               if (phh->pszUrlJump1)
                  phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(
                     phh->pszUrlJump1, NULL, NULL, NULL, NULL);
               break;

            case IDTB_JUMP2:
jump2:
               if (!phh)
                  break;
               if (phh->OnTrackNotifyCaller(HHACT_JUMP2))
                  break;
               if (phh->pszUrlJump2)
                  phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(
                     phh->pszUrlJump2, NULL, NULL, NULL, NULL);
               break;

            case IDTB_REFRESH:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_REFRESH))
                     break;
                  phh->m_pCIExpContainer->m_pWebBrowserApp->Refresh();
               }
               break;

            case IDTB_BACK:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_BACK))
                     break;
                  phh->m_pCIExpContainer->m_pWebBrowserApp->GoBack();
               }
               break;

            case IDTB_FORWARD:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_FORWARD))
                     break;
                  phh->m_pCIExpContainer->m_pWebBrowserApp->GoForward();
               }
               break;

            case IDTB_STOP:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_STOP))
                     break;
                  phh->m_pCIExpContainer->m_pWebBrowserApp->Stop();
               }
               break;

            case IDTB_ZOOM:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_ZOOM))
                     break;
                  phh->ZoomIn();
               }
               break;


            case IDTB_ZOOM_SMALLEST:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_ZOOM))
                     break;
                  phh->Zoom(phh->m_iZoomMin);
               }
               break;

            case IDTB_ZOOM_SMALLER:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_ZOOM))
                     break;
                  phh->Zoom(phh->m_iZoomMin+1);
               }
               break;

            case IDTB_ZOOM_MEDIUM:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_ZOOM))
                     break;
                  phh->Zoom(phh->m_iZoomMin+2);
               }
               break;

            case IDTB_ZOOM_LARGER:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_ZOOM))
                     break;
                  phh->Zoom(phh->m_iZoomMax-1);
               }
               break;

            case IDTB_ZOOM_LARGEST:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_ZOOM))
                     break;
                  phh->Zoom(phh->m_iZoomMax);
               }
               break;

            case IDTB_TOC_NEXT:  // ALT-<downarrow>
               if (phh)
               {
                  if ( HIWORD(wParam) )   // Have we gotten here via a keyboard accelerator ?
                  {
                     HWND hwnd_focus;
                     hwnd_focus = GetFocus();
                     if ( GetWindowLong(hwnd_focus, GWL_ID) == IDC_ADVSRC_KEYWORD_COMBO )
                     {
                        // The combo box has the drop down window style.  Sooao, drop it down.
                        ::SendMessage(GetParent( hwnd_focus), CB_SHOWDROPDOWN, (WPARAM)TRUE, (LPARAM)0);
                        break;

                     }
                     else if ( hwnd_focus == GetDlgItem(hwnd,IDC_SS_PICKER) )
                     {
                        SendMessage(hwnd_focus, CB_SHOWDROPDOWN, (WPARAM)1, (LPARAM)0);
                        break;
                     }
                  }
                  if (phh->OnTrackNotifyCaller(HHACT_TOC_NEXT))
                     break;
                  phh->OnTocNext(TRUE);
               }
               break;


            case IDTB_TOC_PREV:
               if (phh)
               {
                  if ( HIWORD(wParam) )   // Have we gotten here via a keyboard accelerator ?
                  {
                     HWND hwnd_focus;
                     hwnd_focus = GetFocus();
                     if ( GetWindowLong(hwnd_focus, GWL_ID) == IDC_ADVSRC_KEYWORD_COMBO )
                     {
                        // The combo box has the drop down window style.  Sooao, fold it up.
                        ::SendMessage(GetParent( hwnd_focus), CB_SHOWDROPDOWN, (WPARAM)0, (LPARAM)0);
                        break;

                     }
                     else if ( hwnd_focus == GetDlgItem(hwnd,IDC_SS_PICKER) )
                     {
                        SendMessage(hwnd_focus, CB_SHOWDROPDOWN, (WPARAM)0, (LPARAM)0);
                        break;
                     }
                  }
                  if (phh->OnTrackNotifyCaller(HHACT_TOC_PREV))
                     break;
                  phh->OnTocPrev(TRUE);
               }
               break;

            case HHM_HIDE_SHOW:
            case IDTB_CONTRACT:
            case IDTB_EXPAND:
               if (phh)
               {

                  if (phh->OnTrackNotifyCaller(LOWORD(wParam) == IDTB_CONTRACT ?
                        HHACT_CONTRACT : HHACT_EXPAND))
                     break;

                  TBBUTTON tbbtn;
                  BOOL fUpdateMenu;

                  MENUITEMINFO mii;
                  ZERO_STRUCTURE ( mii );
                  mii.cbSize = sizeof( MENUITEMINFO );
                  // update the menu items
                  WPARAM btn_index = SendMessage(phh->hwndToolBar, TB_COMMANDTOINDEX, IDTB_OPTIONS, 0L);
                  fUpdateMenu = SendMessage(phh->hwndToolBar, TB_GETBUTTON, btn_index, (LPARAM)(LPTBBUTTON)&tbbtn )!=0;
                  mii.fMask = MIIM_STATE;
                  mii.fState = (phh->IsExpandedNavPane() ? MFS_DISABLED : MFS_ENABLED);
                  if ( fUpdateMenu )
                     SetMenuItemInfo((HMENU)tbbtn.dwData, IDTB_CONTRACT, FALSE, &mii);
                  mii.fState = (phh->IsExpandedNavPane() ? MFS_ENABLED : MFS_DISABLED);
                  if ( fUpdateMenu)
                     SetMenuItemInfo((HMENU)tbbtn.dwData, IDTB_EXPAND, FALSE, &mii);
                  phh->ToggleExpansion(false);
                  phh->m_pCIExpContainer->SetFocus();
//                  phh->m_pCIExpContainer->m_pWebBrowserApp->Refresh();
                  ResizeWindow(phh);
               }
               break;

            case IDGA_TOGGLE_PANE:
               //
               // Toggle focus and UI activation between the nav-tabs and the topic window.
               //
               if ( phh && phh->m_pCIExpContainer )
               {
                  if ( phh->m_pCIExpContainer->IsUIActive() )
                  {
                     if (phh->m_pTabCtrl)
                     {
                         phh->m_pCIExpContainer->UIDeactivateIE();  // deactive topic window (IE)
                         HWND hWndTabCtrl = phh->m_pTabCtrl->hWnd();
                         int iTabIndex = (int)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0);
                         phh->doSelectTab(phh->tabOrder[iTabIndex]);
                     }
                  }
                  else
                     phh->m_pCIExpContainer->SetFocus();
               }
               break;

            case IDGA_F1_LOOKUP:
                if ( phh && phh->m_pCIExpContainer )
                {
                    if ( phh->m_pCIExpContainer->IsUIActive() )
                    {
                        if( phh->m_pCIExpContainer->m_pWebBrowserApp )
                            DoF1Lookup(phh->m_pCIExpContainer->m_pWebBrowserApp);
                    }
                }
                break;
            case IDGA_NEXT_NAV_TAB:
            case IDGA_PREV_NAV_TAB:
                 if ( phh && !phh->m_pCIExpContainer->IsUIActive() )
                 {      // IE does not have focus;  so the CTRL-TAB is for the navigation tab.
                        // even though we pretranslate the accelerators to IE first then to the
                        // HH second we dont want to process CTRL-TAB if IE does not and IE has focus.
                        // This would lead to inconsistent actions based on what is displayed in the IE pane.
                        // CTRL-TAB moves between buttons in the IE pane.

                     // display the next tab in the tab order of the navigation pane. ( if there
                     // is a navigation pane)
                     if ( phh->m_pTabCtrl )
                     {
                         HWND hWndTabCtrl = phh->m_pTabCtrl->hWnd();
                         int iTabIndex = (int)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0);
                         if ( LOWORD(wParam) == IDGA_NEXT_NAV_TAB )
                            iTabIndex = iTabIndex+1 >= phh->m_pTabCtrl->MaxTabs() ? 0:iTabIndex+1;
                         else if ( LOWORD(wParam) == IDGA_PREV_NAV_TAB )
                            iTabIndex = (iTabIndex-1 < 0 ? phh->m_pTabCtrl->MaxTabs()-1:iTabIndex-1);
                         phh->doSelectTab(phh->tabOrder[iTabIndex]);
                     }
                 }
                break;

            case HHM_SEARCHHILITE:
                goto searchhighlight;

            case HHM_ABOUT:
         {
about:
                CAboutDlg about(hwnd);
                about.DoModal();
                break;
            }

            case HHM_SYNC:
            case IDTB_SYNC:
               if (!phh)
                  break;
               if (phh->OnTrackNotifyCaller(HHACT_SYNC))
                  break;
               if (!IsEmptyString(phh->pszToc))
               {
                  CStr cszUrl;
                  phh->m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);

                  phh->doSelectTab(HH_TAB_CONTENTS) ;
                  CToc* ptoc = reinterpret_cast<CToc*>(phh->m_aNavPane[HH_TAB_CONTENTS]) ; // HACKHACK: Should use dynamic cast, but no RTTI.
                  if (! ptoc )
                     break;
                  if (! ptoc->Synchronize(cszUrl) )
                  {
                     // If sync failed and we're using a subset, offer to switch to EC.
                     //
                     if ( phh->m_phmData && phh->m_phmData->m_pTitleCollection && phh->m_phmData->m_pTitleCollection->m_pSSList )
                     {
                        CStructuralSubset* pSSCur;
                        HWND hWndCB;

                        pSSCur = phh->m_phmData->m_pTitleCollection->m_pSSList->GetTOC();
                        if (! pSSCur->IsEntire() )
                        {
                           if ( MsgBox(IDS_SWITCH_SUBSETS, MB_YESNO | MB_ICONQUESTION) == IDYES )
                           {
                              pSSCur = phh->m_phmData->m_pTitleCollection->m_pSSList->GetEC();
                              phh->m_phmData->m_pTitleCollection->m_pSSList->SetTOC(pSSCur);
                              phh->m_phmData->m_pTitleCollection->m_pSSList->SetFTS(pSSCur);
                              phh->m_phmData->m_pTitleCollection->m_pSSList->SetF1(pSSCur);
                              pSSCur->SelectAsTOCSubset(phh->m_phmData->m_pTitleCollection);
                              ptoc->Refresh();
                              ptoc->Synchronize(cszUrl);
                              //
                              // Select EC in the SS picker combo...
                              //
                              if ( (hWndCB = GetDlgItem(hwnd, IDC_SS_PICKER)) )
                                 SendMessage(hWndCB, CB_SELECTSTRING, -1, (LPARAM)pSSCur->GetName());

                           }
                        }
                     }
                  }
               }
               break;

#ifndef CHIINDEX
            case HHM_PRINT:
            case IDTB_PRINT:

               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_PRINT))
                     break;
                  phh->OnPrint();
               }
               break;
#endif

            //REVIEW: Sending a key to ourselfs to do a menu item seems a little hokey.
            case HHM_CONTENTS:
               wParam = _Resource.TabCtrlKeys(HHWIN_NAVTYPE_TOC);
               goto sim_menuchar;

            case HHM_SEARCH:
               wParam = _Resource.TabCtrlKeys(HHWIN_NAVTYPE_SEARCH);
               goto sim_menuchar;

            case HHM_INDEX:
               wParam = _Resource.TabCtrlKeys(HHWIN_NAVTYPE_INDEX);
               goto sim_menuchar;

            case HHM_FAVORITES:
                wParam = _Resource.TabCtrlKeys(HHWIN_NAVTYPE_FAVORITES);
                goto sim_menuchar;

            case HHM_EXIT:
               PostMessage(hwnd, WM_CLOSE, 0, 0);
               return 0;

            case HHM_COPY:
               phh->m_pCIExpContainer->m_pIE3CmdTarget->Exec(NULL, OLECMDID_COPY, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
               break;

            case HHM_SELECTALL:
               phh->m_pCIExpContainer->m_pIE3CmdTarget->Exec(NULL, OLECMDID_SELECTALL, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
               break;

            case HHM_VIEWSOURCE:
               phh->m_pCIExpContainer->m_pIE3CmdTarget->Exec(&CGID_IWebBrowserPriv, HTMLID_VIEWSOURCE, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
               break;

            case HHM_FIND:
               phh->m_pCIExpContainer->m_pIE3CmdTarget->Exec(&CGID_IWebBrowserPriv, HTMLID_FIND, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
               break;

            case HHM_OPTIONS:
               phh->m_pCIExpContainer->m_pIE3CmdTarget->Exec(&CGID_IWebBrowserPriv, HTMLID_OPTIONS, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
               break;

            case IDTB_OPTIONS:
               if ( phh )
                  doOptionsMenu(phh, hwnd);
               break;

            case HHM_DEFINE_SUBSET: {
               CDefineSS* pDefSSUI = new CDefineSS(GetCurrentCollection(NULL, NULL));
               if (pDefSSUI ) {
                  pDefSSUI->DefineSubset(hwnd, NULL);
                  delete pDefSSUI;
               }
               break;
            }

            case HHM_JUMP_URL:
               goto JumpURL;

            case HHM_LIB_HELP:
               if (!phh)
                  break;
               if (phh->pszUrlJump1)
            {
              // DONDR: Fix this after VS6 release.
              // fix up the URL to point to the correct location of dshelp.. This is a total hack but
              // the best fix short of a complete change to the implementation which can't be done
              // for VS6
                char szURL[MAX_URL], szURL2[MAX_URL];
                strcpy(szURL, phh->pszUrlJump1);
              char *p = stristr(szURL, ".");
              if (p)
              {
                 *p = NULL;
                 CExTitle *pTitle = phh->m_phmData->m_pTitleCollection->FindTitleNonExact(szURL, 1033);
                 if (pTitle)
                 {
                     strcpy(szURL, (g_bMsItsMonikerSupport ? txtMsItsMoniker : txtMkStore));
                    strcat(szURL, phh->pszUrlJump1);
                    pTitle->ConvertURL(szURL, szURL2);
                        phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(szURL2, NULL, NULL, NULL, NULL);
                    break;
                 }
              }
              phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(phh->pszUrlJump1, NULL, NULL, NULL, NULL);
            }
            break;

            case HHM_DEV_ONLINE:
                goto jump2;

            case HHM_SELECT_ITP:
               if ( phh )
               {
                  CChooseSubsets pDlg(hwnd, phh);
                  pDlg.DoModal();
               }
               break;

            case HHM_DEFINE_ITP:
               if ( phh )
               {
                  if (! phh->m_phmData->m_pInfoType )
                  {
                     phh->m_phmData->m_pInfoType = new CInfoType();
                     phh->m_phmData->m_pInfoType->CopyTo( phh->m_phmData );
                  }
#if 0  // enable for subset filtering
                  ChooseInformationTypes(phh->m_phmData->m_pInfoType, NULL, hwnd, NULL, phh);
#else
                  ChooseInformationTypes(phh->m_phmData->m_pInfoType, NULL, hwnd, NULL);
#endif

                  // If the search tab exists, then update the combo box. Slimy! We need a notification scheme for tabs.
                  if (phh->m_aNavPane[HH_TAB_SEARCH])
                  {
                     CAdvancedSearchNavPane* pSearch = reinterpret_cast<CAdvancedSearchNavPane*>(phh->m_aNavPane[HH_TAB_SEARCH]) ;
                     pSearch->UpdateSSCombo() ;
                  }

               }
               break;

            case IDTB_AUTO_SHOW:
                if (phh) {

                    /*
                     * The user may have clicked the Show button in order
                     * to activate the window. We want to trap that condition
                     * so that we don't attempt to expand the window twice.
                     */

                    MSG peekmsg;
                    while (PeekMessage(&peekmsg, hwnd, WM_COMMAND, WM_COMMAND, PM_NOREMOVE)) {
                        if (LOWORD(peekmsg.wParam) == IDTB_EXPAND)
                            return 0;   // show command already pending
                    }
                    while (PeekMessage(&peekmsg, hwnd, WM_SYSCOMMAND, WM_SYSCOMMAND, PM_NOREMOVE)) {
                        if ( (peekmsg.wParam & 0xFFF0) == SC_MINIMIZE )
                            return 0;
                    }
                    if (phh->fNotExpanded)
                        phh->ToggleExpansion();
                }
                break;

#ifdef _DEBUG
            case IDTB_NOTES:
               if (phh) {
                  if (phh->OnTrackNotifyCaller(HHACT_NOTES))
                     break;
                  if (!phh->m_pNotes)
                     phh->m_pNotes = new CNotes(phh);
                  if (phh->m_fNotesWindow)
                     phh->m_pNotes->HideWindow(); // toggles m_fNotesWindow
                  else
                     phh->m_pNotes->ShowWindow(); // toggles m_fNotesWindow
               }
               break;
#endif

            default:
                /* Maybe we have a tab selection command */
                if (!phh)
                   break;

                // Handle WM_COMMANDS for controls on the tabs...
                //
                if ((LOWORD(wParam) >= IDC_SELECT_TAB_FIRST) && (LOWORD(wParam) <= IDC_SELECT_TAB_LAST))
                {
                    phh->doSelectTab(LOWORD(wParam) - IDC_SELECT_TAB_FIRST) ;
                }
                else
                {
                   ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES) ;
                   if (phh->m_aNavPane[phh->curNavType])
                   {
                      phh->m_aNavPane[phh->curNavType]->OnCommand(hwnd, LOWORD(wParam), HIWORD(wParam), lParam);
                   }
                }
               break;
         }
         break;

      case WM_NOTIFY:
        ASSERT(::IsValidWindow(hwnd)) ;
         phh = FindWindowIndex(hwnd);
         if (!phh)
         {
            phh = FindWindowIndex(GetParent(hwnd));
         }

         if (phh)
         {
            ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES) ;
            if (phh->m_aNavPane[phh->curNavType])
            {
                phh->m_aNavPane[phh->curNavType]->OnNotify(hwnd, wParam, lParam);
            }
         }

#define lpnm   ((LPNMHDR)lParam)

         if (lpnm->code == TBN_DROPDOWN)
         {
            doOptionsMenu(phh, hwnd);
            return FALSE;
         }

         if (lpnm->code == TBN_GETINFOTIP && phh  && phh->m_fNoToolBarText )
         {
            LPNMTBGETINFOTIP pTip;
            pTip = (LPNMTBGETINFOTIP)lParam;
            lstrcpyn(pTip->pszText, GetStringResource(pTip->iItem), pTip->cchTextMax);
         }
         break;

      case WM_TCARD: // sent by TCard command of the OCX
         phh = FindWindowIndex(hwnd);
         if (phh) {
            PostMessage(phh->hwndCaller, WM_TCARD, wParam, lParam);
         }
         break;

      case WMP_JUMP_TO_URL:
         phh = FindWindowIndex(hwnd);
         if( phh ) {
           // if we have an lParam then init this title
           BOOL bSkipNewNavigate = FALSE;
           if( lParam && !IsBadReadPtr( (void*)lParam, sizeof(PCSTR) ) ) {
             // note if we cannot init the new title then we must abort
             // the navigate below otherwise we get stuck into the infinite
             // PostMessage loop.  Also we must display an error message
             // stating that the title could not be located otherwise
             // it will silently fail (since we are skipping the navigate).
             //
             CStr PathName = (PCSTR) lParam;
             if( !AddTitleToGlobalList( PathName ) )
               bSkipNewNavigate = TRUE;
           }
           // if we have a wParam then navigate to this URL
           if( !bSkipNewNavigate && wParam &&
               !IsBadReadPtr( (void*)wParam, sizeof(PCSTR) ) ) {
             phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(
                               (PCSTR) wParam, NULL, NULL, NULL, NULL);
           }
         }
         LocalFree((HLOCAL) wParam);
         if( lParam )
           LocalFree((HLOCAL) lParam);
         break;

      case WMP_GET_CUR_FILE:
         phh = FindWindowIndex(hwnd);
         if (phh && phh->m_phmData) {
            return (LRESULT) phh->m_phmData->GetCompiledFile();
         }
         else
            return 0;
#if 0
        case WMP_HH_TAB_KEY:
            phh = FindWindowIndex(hwnd);
            ASSERT(phh);
            ASSERT(phh->m_pCIExpContainer);
            phh->m_pCIExpContainer->SetFocus();
            return 0;
#endif

      case WM_QUERYNEWPALETTE:
      case WM_PALETTECHANGED:
      case WM_SYSCOLORCHANGE:
      case WM_DISPLAYCHANGE:
      case WM_ENTERSIZEMOVE:
      case WM_EXITSIZEMOVE:
         phh = FindWindowIndex(hwnd);
         if (phh && phh->m_pCIExpContainer)
         {
            if ( msg == WM_EXITSIZEMOVE)
            {
                phh->m_pCIExpContainer->SizeIt(0, 0);
                phh->m_pCIExpContainer->SizeIt(RECT_WIDTH(phh->rcHTML), RECT_HEIGHT(phh->rcHTML));
                if ( phh->hwndToolBar )
                {
                      // need to force a repaint due to a bug in the IE3.02 comctrl toolbar not
                      // repainting buttons on resize when buttons are wrapped to different rows.
                      // This is not a perfect fix.  The buttons do not show up where they are
                      // suppose to be until the size move is completed.
                   GetClientRect(phh->hwndToolBar, &phh->rcToolBar);
                   InvalidateRect(phh->hwndToolBar, &phh->rcToolBar, TRUE);
                   UpdateWindow( phh->hwndToolBar );
                }
            }

            phh->m_pCIExpContainer->ForwardMessage(msg, wParam, lParam);
         }
         return DefWindowProc(hwnd, msg, wParam, lParam);
         break;

      case WM_PAINT:
         if ( (phh = FindHHWindowIndex(hwnd)) )
         {
            HWND hWnd;
            if ( (hWnd = phh->GetToolBarHwnd()) )
            {
               RECT  rc;
               POINT pt;
               PAINTSTRUCT ps;
               HDC hdc;

               GetWindowRect(hWnd, &rc);  // to figure out Y coordinate.
               pt.x = rc.left;
               pt.y = rc.bottom;
               ScreenToClient(hwnd, &pt);
               GetWindowRect(phh->GetNavigationHwnd(), &rc);   // For proper width.
               hdc = BeginPaint(hwnd, &ps);
               QRect(hdc, pt.x, pt.y, RECT_WIDTH(rc) + 5, 1, COLOR_BTNSHADOW);    // the +5 is the width of the size bar window.
               QRect(hdc, pt.x, pt.y+1, RECT_WIDTH(rc) + 5, 1, COLOR_BTNHILIGHT);
               EndPaint(hwnd, &ps);
               break;
            }
         }
         /*** Fall Through ***/

      default:
         return DefWindowProc(hwnd, msg, wParam, lParam);
   }

   return 0;
}

LRESULT WINAPI ChildWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CHHWinType* phh;
    if (msg == MSG_MOUSEWHEEL) {
        phh = FindHHWindowIndex(hwnd);
        if (phh)
            return phh->m_pCIExpContainer->ForwardMessage(msg, wParam, lParam);
        return 0;
    }

    switch(msg) {
        case WM_MOUSEACTIVATE:
            phh = FindHHWindowIndex(hwnd);
            if ( phh->m_pCIExpContainer && phh->m_pCIExpContainer->m_hWnd == hwnd )
            {
                phh->m_hwndFocused = hwnd;
                return 0;
            }
            else
            {
              if( phh && phh->m_pTabCtrl && phh->m_pCIExpContainer) {
                phh->m_hwndFocused = phh->m_pTabCtrl->hWnd();
                phh->m_pCIExpContainer->UIDeactivateIE();  // shdocvw is loosing focus need to uideactivate here.
              }
            }
            break;

        case WM_SIZE:
            switch (wParam)
            {
              case SIZE_RESTORED:
              case SIZE_MAXIMIZED:
              case SIZE_MAXSHOW:
                 phh = FindHHWindowIndex(hwnd);
                 ASSERT(phh);

                 if (hwnd == phh->GetNavigationHwnd())
                 {
                    // This resize is needed when we have only a single nav pane.
                    // When we have a single nav pane, we do not have the toolbar ctrl
                    // and therefore m_pTabCtrl is null. this does mean that we do not
                    // size without the following line...
                    ResizeWindow(phh);
                 }
            }
            break;

        case WM_NOTIFY:
            ASSERT(::IsValidWindow(hwnd)) ;
            phh = FindWindowIndex(GetParent(hwnd));
            if (phh)
            {
                if ( wParam == IDC_KWD_VLIST )
                {
                   phh->m_aNavPane[phh->curNavType]->OnVKListNotify((NMHDR*)lParam);
                   break;
                }
                //--- Handle the TAB Control
                else if (wParam == ID_TAB_CONTROL)
                {
                    LPNMHDR pNmHdr = (LPNMHDR)lParam;
                    int nIndex = phh->GetCurrentNavPaneIndex() ;
                    if (nIndex != phh->curNavType)
                    {
                        // HideWindow
                        ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES) ;
                        if (phh->m_aNavPane[phh->curNavType])
                        {
                           phh->m_aNavPane[phh->curNavType]->HideWindow();
                        }

                        phh->curNavType = nIndex;

                         // Create the new pane if required.
                         phh->CreateNavPane(phh->curNavType) ;

                         ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES) ;
                         if (phh->m_aNavPane[phh->curNavType])
                         {
                             phh->m_aNavPane[phh->curNavType]->ResizeWindow();
                             phh->m_aNavPane[phh->curNavType]->ShowWindow();
                             phh->m_aNavPane[phh->curNavType]->SetDefaultFocus() ;
                         }
                    }
                    break;
                }
                else
                {
                    // If its not the tab control forward the messages to the panes.
                    ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES) ;
                    if (phh->m_aNavPane[phh->curNavType ])
                    {
                       ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES) ;
                       if (phh->m_aNavPane[phh->curNavType])
                          phh->m_aNavPane[phh->curNavType]->OnNotify(hwnd, wParam, lParam) ;
                    }
                }
            }
            else {   // couldn't find parent, how about parent's parent
               phh = FindWindowIndex(GetParent(GetParent(hwnd)));
               if (phh)
               {
                   ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES) ;
                   if (phh->m_aNavPane[phh->curNavType])
                   {
                       phh->m_aNavPane[phh->curNavType]->OnNotify(hwnd, wParam, lParam) ;
                   }
               }
            }
            break;

        case WM_COMMAND:
         //BUG:[paulde]Might need to make A/W call that matches THIS window's A/W type
            return SendMessage(GetParent(hwnd), msg, wParam, lParam);

        case WM_DRAWITEM:
            phh = FindWindowIndex(GetParent(hwnd));
            if (phh->curNavType == HHWIN_NAVTYPE_INDEX && phh->m_aNavPane[HH_TAB_INDEX])
            {
               phh->m_aNavPane[HH_TAB_INDEX]->OnDrawItem((UINT)wParam, (LPDRAWITEMSTRUCT) lParam);
            }
            break;

        case WM_KEYDOWN:

            /*
             * We only want to process VK_ESCAPE on the down-key, because when
             * you press ESCAPE in a dialog box, the down key cancels the dialog
             * box, and then the Up key gets passed through to the app.
             */

            if (wParam == VK_ESCAPE) {
               PostMessage(GetParent(hwnd), WM_CLOSE, 0, 0);
               return 0;
            }
            return DefWindowProc(hwnd, msg, wParam, lParam);

    case WM_PAINT: //TODO: Make a class for the navigation window.
            phh = FindHHWindowIndex(hwnd);
            if (phh && hwnd == phh->GetNavigationHwnd() && ::IsWindow(hwnd))
            {
                PAINTSTRUCT ps;
                HDC hdc = BeginPaint(hwnd, &ps) ;
                    DrawNavWnd(hwnd) ;
                EndPaint(hwnd, &ps) ;
                break ;
            }
            /*** Fall Through ***/

        default:
         if (IsWindowUnicode(hwnd))
            return DefWindowProcW(hwnd, msg, wParam, lParam);
         else
            return DefWindowProcA(hwnd, msg, wParam, lParam);
    }

    return 0;
}


static void UpdateSearchHiMenu(CHHWinType* phh, TBBUTTON * tbbtn)
{
MENUITEMINFO mii;
CStr  cszMenuItem;

   if ( phh && phh->m_phmData && phh->m_phmData->m_pTitleCollection &&
      phh->m_phmData->m_pTitleCollection->m_pSearchHighlight &&
      phh->m_phmData->m_pTitleCollection->m_pSearchHighlight->m_bHighlightEnabled )
    {  // its currently on; turn it off
       cszMenuItem = GetStringResource( IDS_OPTION_HILITING_OFF );// the string to display for the menu item
    }
    else
    {  // its currently off; turn it on.
       cszMenuItem = GetStringResource( IDS_OPTION_HILITING_ON );// the string to display for the menu item
    }

	ZERO_STRUCTURE ( mii );
	mii.cbSize     = sizeof(MENUITEMINFO);
	mii.fMask      = MIIM_TYPE;
	mii.fType      = MFT_STRING;
	mii.hSubMenu   = NULL;
	mii.hbmpChecked = NULL;    // bitmap to display when checked
	mii.hbmpUnchecked = NULL;  // bitmap to display when not checked
	mii.dwItemData = NULL;     // data associated with the menu item
	mii.dwTypeData = cszMenuItem.psz;
	mii.cch        = (ULONG)strlen( mii.dwTypeData );       // length of the string.

	if(g_bWinNT5)
    {
        DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
		
		DWORD dwSize = (sizeof(WCHAR) * mii.cch) + 4;
		WCHAR *pwcString = (WCHAR *) lcMalloc(dwSize);
		
		if(!pwcString)
		    return;
		
		MultiByteToWideChar(cp, MB_PRECOMPOSED, cszMenuItem.psz, -1, pwcString, dwSize);
		
		mii.dwTypeData = (char *) pwcString;

		SetMenuItemInfoW((HMENU)tbbtn->dwData, IDTB_HILITE, FALSE,(LPMENUITEMINFOW) &mii);
		
        lcFree(pwcString);	
	}
	else	
	   SetMenuItemInfo((HMENU)tbbtn->dwData, IDTB_HILITE, FALSE, &mii);
	return;
}


static void doOptionsMenu(CHHWinType* phh, HWND hwnd)
{
TBBUTTON tbbtn;
POINT pt;
RECT rcBtn;
WPARAM btn_index;
DWORD dwErr;

#define lpnm   ((LPNMHDR)lParam)
#define lpnmTB ((LPNMTOOLBAR)lParam)

    if (phh && phh->hwndToolBar) {
        btn_index = SendMessage(phh->hwndToolBar, TB_COMMANDTOINDEX, IDTB_OPTIONS, 0L);
        SendMessage(phh->hwndToolBar, TB_GETBUTTON, btn_index, (LPARAM) (LPTBBUTTON) &tbbtn);
        if (!SendMessage(phh->hwndToolBar, TB_GETITEMRECT, btn_index, (LPARAM) (LPRECT) &rcBtn))
           return;

        if (tbbtn.dwData) {
            if(g_bWinNT5)
            {

                if (!phh->IsExpandedNavPane())
                    ModifyMenuW((HMENU)tbbtn.dwData,
                        0, MF_BYPOSITION | MF_STRING, IDTB_EXPAND,
                        GetStringResourceW(IDS_OPTION_SHOW));
                else
                    ModifyMenuW((HMENU)tbbtn.dwData,
                        0, MF_BYPOSITION | MF_STRING, IDTB_CONTRACT,
                        GetStringResourceW(IDS_OPTION_HIDE));
			}
			else
			{
			    if (!phh->IsExpandedNavPane())
                    ModifyMenu((HMENU)tbbtn.dwData,
                        0, MF_BYPOSITION | MF_STRING, IDTB_EXPAND,
                        GetStringResource(IDS_OPTION_SHOW));
                else
                    ModifyMenu((HMENU)tbbtn.dwData,
                        0, MF_BYPOSITION | MF_STRING, IDTB_CONTRACT,
                        GetStringResource(IDS_OPTION_HIDE));
			}


         UpdateSearchHiMenu(phh, &tbbtn);

            EnableMenuItem((HMENU)tbbtn.dwData, IDTB_CUSTOMIZE, MF_BYCOMMAND | MF_ENABLED);

            // ASSERT(phh->m_aNavPane[HH_TAB_CONTENTS]) ;
            if( phh && phh->m_aNavPane[HH_TAB_CONTENTS] ) {
              CToc* ptoc = reinterpret_cast<CToc*>(phh->m_aNavPane[HH_TAB_CONTENTS]) ; // HACKHACK: Should use dynamic cast, but no RTTI.
              if ((phh->curNavType == HHWIN_NAVTYPE_TOC) &&
                      (!ptoc || (ptoc->m_pInfoType->HowManyInfoTypes() <= 0) ||
                      (ptoc->m_pInfoType->GetFirstHidden() == 1)))
                  EnableMenuItem((HMENU) tbbtn.dwData, IDTB_CUSTOMIZE, MF_BYCOMMAND | MF_GRAYED);
              else if (phh->curNavType == HHWIN_NAVTYPE_INDEX)
                  EnableMenuItem((HMENU) tbbtn.dwData, IDTB_CUSTOMIZE, MF_BYCOMMAND | MF_GRAYED);
              else if (phh->curNavType == HHWIN_NAVTYPE_SEARCH)
                  EnableMenuItem((HMENU) tbbtn.dwData, IDTB_CUSTOMIZE, MF_BYCOMMAND | MF_GRAYED);
            }

            pt.x = pt.y = 0;
            ScreenToClient(phh->hwndHelp, &pt);
            if ( !TrackPopupMenu((HMENU)tbbtn.dwData,
                    TPM_LEFTALIGN|TPM_TOPALIGN|TPM_LEFTBUTTON|TPM_NONOTIFY,
                    rcBtn.left-pt.x, rcBtn.bottom-pt.y, 0, hwnd, NULL) )
                dwErr = GetLastError();
        }
    }
}
void ResizeWindow(CHHWinType* phh, bool bRecalcHtmlFrame /*=true*/)
{
    if (phh) // Needs to be valid.
    {
        if (phh->hwndHTML)
        {
            if (bRecalcHtmlFrame)
            {
                phh->CalcHtmlPaneRect(); // Don't recalc if the sizebar is calling us. See sizebar.cpp
            }

            MoveWindow(phh->hwndHTML, phh->rcHTML.left,
                phh->rcHTML.top, RECT_WIDTH(phh->rcHTML),
                RECT_HEIGHT(phh->rcHTML), TRUE);
	    if (phh->m_pCIExpContainer)
               phh->m_pCIExpContainer->SizeIt(RECT_WIDTH(phh->rcHTML), RECT_HEIGHT(phh->rcHTML));
        }

        if (phh->GetNavigationHwnd() &&  // Have to have the navigation window to have any of the other stuff.
           phh->IsExpandedNavPane())   // Should be expanded.
        {
            // Move the nav pane.
            MoveWindow( phh->hwndNavigation, phh->rcNav.left,
                        phh->rcNav.top, RECT_WIDTH(phh->rcNav),
                        RECT_HEIGHT(phh->rcNav), TRUE);

            if ( phh->m_hWndSSCB )
            {
               RECT rcST, rcTB, rcCB;
               int  iTop;

               GetClientRect(phh->m_hWndST, &rcST);
               GetClientRect(phh->GetToolBarHwnd(), &rcTB);
               GetClientRect(phh->m_hWndSSCB, &rcCB);

               iTop = rcTB.bottom + 5;
               SetWindowPos(phh->m_hWndST, NULL, phh->rcNav.left+6, iTop, RECT_WIDTH(phh->rcNav)-8, RECT_HEIGHT(rcST), SWP_NOZORDER);
               iTop += RECT_HEIGHT(rcST) + 2;
               SetWindowPos(phh->m_hWndSSCB, NULL, phh->rcNav.left+6, iTop, RECT_WIDTH(phh->rcNav)-8, RECT_HEIGHT(rcCB), SWP_NOZORDER);

               InvalidateRect(phh->m_hWndST, NULL, FALSE);
               InvalidateRect(phh->m_hWndSSCB, NULL, FALSE);
            }

            // If we have a tab control let's make sure to resize those as well.
            if (phh->m_pTabCtrl)
            {
                phh->m_pTabCtrl->ResizeWindow() ;
            }

            // Now resize the controls on the pane.
            ASSERT(phh->curNavType >=0 && phh->curNavType < c_NUMNAVPANES);
            if (phh->m_aNavPane[phh->curNavType])
            {
                phh->m_aNavPane[phh->curNavType]->ResizeWindow();
            }

            // Finally, resize the sizebar if we have one of them.
            if (phh->m_pSizeBar)
            {
                phh->m_pSizeBar->ResizeWindow() ;
            }
       }
    }
}

BOOL CHHWinType::OnTrackNotifyCaller(int idAction)
{
    if (idNotify && m_pCIExpContainer && m_pCIExpContainer->m_pWebBrowserApp)
    {
        HHNTRACK hhtrack;
        ZeroMemory(&hhtrack, sizeof(HHNTRACK));
        hhtrack.hdr.hwndFrom = hwndHelp;
        hhtrack.hdr.idFrom = idNotify;
        hhtrack.hdr.code = HHN_TRACK;
        CStr cszUrl;
        m_pCIExpContainer->m_pWebBrowserApp->GetLocationURL(&cszUrl);
        hhtrack.pszCurUrl = cszUrl.psz;
        hhtrack.idAction = idAction;
        hhtrack.phhWinType = (HH_WINTYPE*) this;

        if (IsWindow(hwndCaller))
        {
            return SendMessage(hwndCaller, WM_NOTIFY, idNotify, (LPARAM) &hhtrack)!=0;
        }
    }
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// WM_APPCOMMAND
//
LRESULT OnAppCommand(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    switch (GET_APPCOMMAND_LPARAM(lParam))
        {
            case APPCOMMAND_BROWSER_BACKWARD:
                SendMessage(hwnd, WM_COMMAND, MAKELONG(IDTB_BACK, 0), NULL);
                return 1;
            case APPCOMMAND_BROWSER_FORWARD:
                SendMessage(hwnd, WM_COMMAND, MAKELONG(IDTB_FORWARD, 0), NULL);
                return 1;
            case APPCOMMAND_BROWSER_REFRESH:
                SendMessage(hwnd, WM_COMMAND, MAKELONG(IDTB_REFRESH, 0), NULL);
                return 1;
            case APPCOMMAND_BROWSER_STOP:
                SendMessage(hwnd, WM_COMMAND, MAKELONG(IDTB_STOP, 0), NULL);
                return 1;
            case APPCOMMAND_BROWSER_HOME:
                SendMessage(hwnd, WM_COMMAND, MAKELONG(IDTB_HOME, 0), NULL);
                return 1;
            case APPCOMMAND_BROWSER_SEARCH:
                SendMessage(hwnd, WM_COMMAND, MAKELONG(HHM_SEARCH, 0), NULL);
                return 1;
            case APPCOMMAND_BROWSER_FAVORITES:
                SendMessage(hwnd, WM_COMMAND, MAKELONG(HHM_FAVORITES, 0), NULL);
                return 1;
        }
    return 0;
}

//////////////////////////////////////////////////////////////////////////
//
// WM_KEYDOWN Handler
//
LRESULT OnKeyDown(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    switch(wParam)
    {
    case VK_ESCAPE:
        /*
          * We only want to process VK_ESCAPE on the down-key, because when
          * you press ESCAPE in a dialog box, the down key cancels the dialog
          * box, and then the Up key gets passed through to the app.
        */
        {
            CHHWinType* phh = FindWindowIndex(hwnd);
            if (phh && (phh->dwStyles & WS_CHILD))
            {
                // Don't process the ESC key if we are a child/embedded window.
                return 0 ;
            }
            PostMessage(hwnd, WM_CLOSE, 0, 0);
            return 0;
        }

/*
    case VK_NEXT:
        // Never reached
        return 0 ;
*/

    default:
        return DefWindowProc(hwnd, WM_KEYDOWN, wParam, lParam);
    }
}


//////////////////////////////////////////////////////////////////////////
//
// Draws the edge to the upper part of the navigation frame window.
//
void DrawNavWnd(HWND hWnd)
{
    // Get a dc to draw in.
    HDC hdc = GetDC(hWnd) ;
        // get the rectangle to draw on.
        RECT rc ;
        GetClientRect(hWnd, &rc) ;

        // Draw the edge.
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOP) ;
    // Clean up.
    ReleaseDC(hWnd, hdc) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itcat.h ===
// ITCAT.H:	IITCatalog interface declaration

#ifndef __ITCAT_H__
#define __ITCAT_H__

#include <comdef.h>

// {F21B1A31-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(IID_IITCatalog,
0xf21b1a31, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#ifdef ITPROXY

// {F21B1A32-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(CLSID_IITCatalog,
0xf21b1a32, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daaa-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCatalogLocal,
0x4662daaa, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Forward declarations
interface IITDatabase;
interface IITResultSet;

DECLARE_INTERFACE_(IITCatalog, IUnknown)
{
	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszwName = NULL) PURE;
	STDMETHOD(Close)(void) PURE;
	STDMETHOD(Lookup)(IITResultSet* pRSIn, IITResultSet* pRSOut = NULL) PURE;
	STDMETHOD(GetColumns)(IITResultSet* pRS) PURE;
};

typedef IITCatalog* LPITCATALOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\wmp.h ===
// Copyright  1996-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WMP_H_
#define _WMP_H_

// This head file contains private messages for talking between
// HHCTRL.OCX, HtmlHelp windows, HTML Help Workshop, Flash, and other
// components of the HTML Help retail and SDK set

const int MAX_PASS_STRING = (32 * 1024); // maximum string to send to parent

enum PRIVATE_MESSAGES  {

    // HTML Help Workshop messages

    WMP_STOP_RUN_DLG = (WM_USER + 0x100),
    WMP_UPDATE_VIEW_UI,         // wParam = id, Param = CCmdUI*
    WMP_IS_COMMAND_SUPPORTED,   // wParam = id
    WMP_MSG,                    // general message
    WMP_SETHLP_FILE,
    WMP_BUILD_COMPLETE,
    WMP_HWND_GRINDER,
    WMP_AUTO_MINIMIZE,
    WMP_AUTO_CMD_LINE,
    WMP_SET_TMPDIR,
    WMP_STOP_GRINDING,
    WMP_STOP_COMPILING,
    WMP_ERROR_COUNT,
    WMP_NO_ACTIVATE,
    WMP_KILL_TCARD,
    WMP_FLASH_COMMAND_LINE,
    WMP_INITIALIZE_HTML,
    WMP_LOG_MSG,    // wParam == PCSTR
    WMP_LOAD_LAST_PROJECT,
    WMP_CLEAR_LOG,
    WMP_STARTUP_HELP,   // display startup HTML file
    WMP_GRIND_MESSAGE,  // message box with grind window as the owner: wParam == psz, lParam == nType

    // HHA messages

    WMP_WINDOW_CAPTURE = (WM_USER + 0x1C0), // lParam == POINTS
    WMP_WINDOW_HILIGHT, // wParam == TRUE/FALSE to hilight, remove hilight, // lParam == POINTS
    WMP_KEYBOARD_HOOK,  // wParam == virtual key code, // lParam == see KeyboardProc value in API description of keyboard hooks

    // THIS CANNOT CHANGE! It is documented externally

    WMP_HH_MSG = (WM_USER + 0x1C3),         // Notifies window that a string is in shared memory

    // Flash messages

    WMP_SET_TEXT =          (WM_USER + 0x200),
    WMP_SET_INFO_FILE,
    WMP_ADD_PATTERN,
    WMP_CHANGE_SRC,
    WMP_BROWSE_OPEN,
    WMP_BACKCOLOR_CHANGED,
    WMP_PERFORM_CAPTURE,    // wParam == POINTS, lParam == capture type
    WMP_WHAT_ARE_YOU_DOING,
    WMP_KILL_CAPTURE,
    WMP_FOCUS_MAIN,
    WMP_AUTO_SIZE,
    WMP_MOUSE_HOOK,
    WMP_UPDATE_STATUS_BAR,
    WMP_COMMAND_LINE,       // (WM_USER + 0x20d)
    WMP_CANCEL,
    WMP_CHECK_BROWSE_DIR,   // wParam == pszFolder
    WMP_CONVERT_MFILES,     // file stored in g_pszMfile

    // HTML Help messages

    WMP_AUTHOR_MSG, // wParam = idResource, lParam = lcStrDup of string -- processing message will free the string
    WMP_USER_MSG,   // wParam = idResource, lParam = lcStrDup of string or NULL -- processing message will free the string
    WMP_PRINT_COMPLETE,     // wParam = TRUE/FALSE (for success or failure)
    WMP_GET_CUR_FILE,   // returns pointer to current compiled HTML file
    WMP_JUMP_TO_URL,    // wParam = LocalAlloc of URL string

    WMP_ANSI_API_CALL = (WM_USER + 0x280),       // lParam = pHhDataA
    WMP_UNICODE_API_CALL,    // lParam = pHhDataW
    WMP_HH_WIN_CLOSING,
    WMP_FORCE_HH_API_CLOSE, // forceably close all HH windows and HH_API window
    WMP_HH_COMMAND_LINE = (WM_USER + 0x284),    // TODO: Remove: Currently unused, but not removed because of possible side affects.
    WMP_HH_TAB_KEY,     // control has received TAB downkey
    WMP_HH_ANSI_THREAD_API,     // wParam = HH_ANSI_DATA*
    WMP_HH_UNI_THREAD_API,      // wParam = HH_UNICODE_DATA*
    WMP_HH_TRANS_ACCELERATOR,   // wParam = CHAR
};

typedef enum {
    HHA_DEBUG_ERROR,    // Displays string in wParam, asks permission to call DebugBreak();
    HHA_SEND_STRING_TO_PARENT,  // Sends string in wParam to hhw.exe
    HHA_SEND_RESID_TO_PARENT,   // sends resource string in hha.dll to hhw.exe
    HHA_FIND_PARENT,            // finds hhw.exe's window handle
    HHA_SEND_RESID_AND_STRING_TO_PARENT,
} HHA_MSG;

#endif      // _WMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\wwheel.cpp ===
// WWheel.cpp - HTML Help Word Wheel support
//
// Covers both KeywordLinks and AssociativeLinks
//
//

// needed for those pesky pre-compiled headers
#include "header.h"

#include "wwheel.h"

#include "animate.h"
#include "strtable.h"
#include "resource.h"
#include "util.h"

// memory leak checks
AUTO_CLASS_COUNT_CHECK(CTitleMapEntry);
AUTO_CLASS_COUNT_CHECK(CTitleMap);
AUTO_CLASS_COUNT_CHECK(CTitleDatabase);
AUTO_CLASS_COUNT_CHECK(CResultsEntry);
AUTO_CLASS_COUNT_CHECK(CResults);
AUTO_CLASS_COUNT_CHECK(CWordWheelEntry);
AUTO_CLASS_COUNT_CHECK(CWordWheel);
AUTO_CLASS_COUNT_CHECK(CWordWheelCompiler);

// taken from "hhsyssrt.h"
// {4662dab0-d393-11d0-9a56-00c04fb68b66}
// HACKHACK: I simply changed the last value of CLSID_ITSysSort from 0xf7 to 0x66
DEFINE_GUID(CLSID_HHSysSort,
0x4662dab0, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0x66);

// old format
#define IHHSK666_KEYTYPE_ANSI_SZ    ((DWORD) 66630) // NULL-term. MBCS string + extra data
#define IHHSK666_KEYTYPE_UNICODE_SZ ((DWORD) 66631) // NULL-term. Unicode string + extra data

#if 0
// New format
#define IHHSK100_KEYTYPE_ANSI_SZ    ((DWORD) 10030) // NULL-term. MBCS string + extra data
#define IHHSK100_KEYTYPE_UNICODE_SZ ((DWORD) 10031) // NULL-term. Unicode string + extra data
#endif

#define IHHSK100_KEYTYPE_ANSI_SZ    ((DWORD) 30) // NULL-term. MBCS string + extra data
#define IHHSK100_KEYTYPE_UNICODE_SZ ((DWORD) 31) // NULL-term. Unicode string + extra data

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

// Global Variables
static const CHAR  g_szKeywordLinks[]      = "KeywordLinks";
static const CHAR  g_szAssociativeLinks[]  = "AssociativeLinks";
static const CHAR  g_szTitleMap[]          = "$HHTitleMap";
static const WCHAR g_wszKeywordLinks[]     = L"KeywordLinks";
static const WCHAR g_wszAssociativeLinks[] = L"AssociativeLinks";
static const WCHAR g_wszTitleMap[]         = L"$HHTitleMap";
static const WCHAR g_wszError[]            = L"(ERROR)";
DWORD   g_dwError             = ((DWORD)-1);

/////////////////////////////////////////////////////////////////////////////
// helpful functions

static const CHAR g_szBusyFile[] = "HTMLHelpKeywordMergingBusy";

static HANDLE g_hFileBusy = NULL;

#define BUSY_FILE_SIZE 32

BOOL IsBusy()
{
  BOOL bBusy = FALSE;
  HANDLE hFileBusy = NULL;
  SetLastError(0);
  hFileBusy = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READONLY, 0, BUSY_FILE_SIZE, g_szBusyFile  );

  if( hFileBusy ) {
    if( GetLastError() == ERROR_ALREADY_EXISTS )
      bBusy = TRUE;
    CloseHandle( hFileBusy );
  }

  return bBusy;
}

void SetBusy( BOOL bBusy )
{
  if( bBusy ) {
    if( !g_hFileBusy )
      g_hFileBusy = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READONLY, 0, BUSY_FILE_SIZE, g_szBusyFile  );
  }
  else {
    if( g_hFileBusy ) {
      CloseHandle( g_hFileBusy );
      g_hFileBusy = NULL;
    }
  }
}

int FASTCALL CompareIds( const void* p1, const void* p2 )
{
  int iReturn;

  CTitleMapEntry* pEntry1= (CTitleMapEntry*) p1;
  CTitleMapEntry* pEntry2= (CTitleMapEntry*) p2;

  DWORD dwId1 = pEntry1->GetId();
  DWORD dwId2 = pEntry2->GetId();

  if( dwId1 < dwId2 )
    iReturn = -1;
  else if ( dwId1 > dwId2 )
    iReturn = 1;
  else
    iReturn = 0;

  return iReturn;
}

// check if a specified subfile exists in the specified title
BOOL IsSubFile( PCSTR pszTitlePathname, PCSTR pszSubFile )
{
  BOOL bExists = FALSE;

  if( pszTitlePathname && pszTitlePathname[0] && pszSubFile && pszSubFile[0] ) {
    HRESULT hr = S_OK;
    CFileSystem* pFS = new CFileSystem;
    if( pFS && SUCCEEDED(hr = pFS->Init()) && SUCCEEDED(hr = pFS->Open( pszTitlePathname )) ) {
      CSubFileSystem* pSFS = new CSubFileSystem( pFS );
      if( pSFS && SUCCEEDED(pSFS->OpenSub(pszSubFile)) ) {
        bExists = TRUE;
        delete pSFS;
      }
      delete pFS;
    }
  }

  return bExists;
}

/////////////////////////////////////////////////////////////////////////////
// class CTitleMap implementation

BOOL CTitleMap::Initialize()
{
  // bail out if we are already initialized
  if( m_bInit )
    return TRUE;

  // allocate a MBCS version of our file system pathname
  CHAR* psz = NULL;
  if( m_pszDatabase && *m_pszDatabase ) {
    DWORD dwLen = (DWORD)strlen(m_pszDatabase) + 1;
    psz = new char[dwLen];
    strcpy(psz,m_pszDatabase);
  }
  m_pszDatabase = psz;

  // set this bool first since we are going to call GetAt()
  // which will make a reentrant call if this is not set--
  // this would be bad!
  m_bInit = TRUE;

  // if we have a database, read in the data
  if( m_pszDatabase ) {

    HRESULT hr = S_OK;

    // open the database and read in the subfile
    CFileSystem* pDatabase = new CFileSystem;
    if( SUCCEEDED(hr = pDatabase->Init()) && SUCCEEDED(hr = pDatabase->Open( GetDatabase() )) ) {
      CSubFileSystem* pTitleMap = new CSubFileSystem( pDatabase );
      if( SUCCEEDED(hr = pTitleMap->OpenSub( g_szTitleMap ) ) ) {

        // format of TitleMap subfile is as follows:
        //
        // wCount (number of entries)
        // wShortNameLen, sShortName, FILETIME, LCID
        // ...line above repeated for each entry...
        //
        ULONG cbRead = 0;
        WORD wCount = 0;
        pTitleMap->ReadSub( (void*) &wCount, sizeof(wCount), &cbRead );
        SetCount( (DWORD) wCount );
        for( int iCount = 0; iCount < (int) wCount; iCount++ ) {
          WORD wLen = 0;
          char szShortName[256];
          FILETIME FileTime;
          LCID lcid;
          pTitleMap->ReadSub( (void*) &wLen, sizeof(wLen), &cbRead );
          pTitleMap->ReadSub( (void*) &szShortName, wLen, &cbRead );
          szShortName[wLen] = 0;
          ASSERT(cbRead != 0) ; // See HH Bug 2807 --- Saved a NULL shortname. 
                                // This means that the CHM file associted with this 
                                // topic probably doesn't exist. Tell the owner of the collection.
          pTitleMap->ReadSub( (void*) &FileTime, sizeof(FileTime), &cbRead );
          pTitleMap->ReadSub( (void*) &lcid, sizeof(lcid), &cbRead );
          GetAt((DWORD)iCount)->SetId( iCount+1 );
          GetAt((DWORD)iCount)->SetShortName( szShortName );
          GetAt((DWORD)iCount)->SetFileTime( FileTime );
          GetAt((DWORD)iCount)->SetLanguage( lcid );
        }

      }
      delete pTitleMap;

    }
    delete pDatabase;
  }
  else
    m_bInit = FALSE;


  return m_bInit;
}

BOOL CTitleMap::Free()
{
  if( m_pEntries ) {
    delete [] m_pEntries;
    m_pEntries = NULL;
    m_dwCount = HHWW_ERROR;
  }

  if( m_pszDatabase ) {
    delete [] (CHAR*) m_pszDatabase;
    m_pszDatabase = NULL;
  }

  m_bInit = FALSE;

  return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// class CTitleDatabase implementation (Shared Centaur object)

void CTitleDatabase::_CTitleDatabase()
{
  m_bInit             = FALSE;
  m_pDatabase         = NULL;
  m_pwszDatabase      = NULL;
  m_pszDatabase       = NULL;
  m_bCollection       = FALSE;
  m_pTitleMap         = NULL;
  m_pKeywordLinks     = NULL;
  m_pAssociativeLinks = NULL;
  m_pCollection       = NULL;
  m_pTitle            = NULL;
#ifdef CHIINDEX
  m_bAnimation        = TRUE;  // display animation
#endif
}

CTitleDatabase::CTitleDatabase( CExCollection* pCollection )
{
  _CTitleDatabase();
  m_pCollection = pCollection;
}

CTitleDatabase::CTitleDatabase( CExTitle* pTitle )
{
  _CTitleDatabase();
  m_pTitle = pTitle;
}

CTitleDatabase::CTitleDatabase( const WCHAR* pwszDatabase )
{
  _CTitleDatabase();
  m_pwszDatabase = pwszDatabase;
}

CTitleDatabase::CTitleDatabase( const CHAR* pszDatabase )
{
  _CTitleDatabase();
  m_pszDatabase = pszDatabase;
}

CTitleDatabase::~CTitleDatabase()
{
  Free();
}

BOOL CTitleDatabase::Initialize(CHAR *pszFileName)
{
  BOOL bReturn = FALSE;
  HRESULT hr = S_OK;

  // bail out if we are already initialized
  if( m_bInit )
    return TRUE;

  // bail out if collection or title not specified
  if( !(m_pCollection || m_pTitle || m_pwszDatabase || m_pszDatabase ) )
    return FALSE;

  // set the hourglass cursor
  CHourGlass HourGlass;

  // get the database name
  if( m_pCollection ) {
    m_pTitle = m_pCollection->GetFirstTitle();
    m_bCollection = ( m_pCollection && (m_pCollection->GetRefedTitleCount() > 1) );
    if( m_bCollection )
      m_pszDatabase = m_pCollection->GetLocalStoragePathname(".chw");
    else
      m_pszDatabase = m_pTitle->GetIndexFileName();
  }
  else if( m_pTitle ) {
    m_pszDatabase = m_pTitle->GetIndexFileName();
  }

  if (pszFileName)
  {
     char drive[_MAX_PATH], dir[_MAX_PATH];
     splitpath(m_pszDatabase, drive, dir, NULL, NULL);
     if (drive[0] && drive[strlen(drive)-1] != '\\' && dir[0] != '\\')
       strcat(drive, "\\");
     strcat(drive, dir);
     if (drive[strlen(drive)-1] != '\\' && pszFileName[0] != '\\')
       strcat(drive, "\\");
     strcat(drive, pszFileName);
     strcpy(m_szFullPath, drive);
     m_pszDatabase = m_szFullPath;
  }


  // allocate UNICODE and MBCS versions of our file system pathname
  WCHAR* pwsz = NULL;
  CHAR* psz = NULL;
  if( m_pszDatabase && *m_pszDatabase ) {
    DWORD dwLen = (DWORD)strlen(m_pszDatabase) + 1;
    pwsz = new WCHAR[dwLen];
    MultiByteToWideChar(CP_ACP, 0, m_pszDatabase, -1, pwsz, dwLen);
    psz = new char[dwLen];
    strcpy(psz,m_pszDatabase);
  }
  else if( m_pwszDatabase && *m_pwszDatabase ) {
    DWORD dwLen = wcslen(m_pwszDatabase) + 1;
    pwsz = new WCHAR[dwLen];
    wcscpy(pwsz,m_pwszDatabase);
    psz = new char[dwLen];
    WideCharToMultiByte(CP_ACP, 0, m_pwszDatabase, -1, psz, dwLen, NULL, NULL);
  }
  m_pwszDatabase = pwsz;
  m_pszDatabase = psz;

  // bail out if file system pathname not specified
  if( !m_pwszDatabase || !*m_pwszDatabase )
    return FALSE;

  // do a merge check
  if( m_bCollection ) {
    if( !MergeWordWheels() ) {
      m_bCollection = FALSE;
      m_pCollection = NULL;
      Free();
      return Initialize();
    }
  }

  // get ITDatabase ptr.
  if( SUCCEEDED(hr = CoCreateInstance(CLSID_IITDatabaseLocal, NULL, CLSCTX_INPROC_SERVER,
              IID_IITDatabase, (void**)&m_pDatabase) ) ) {

    // if the file exists then this is good enough to say we initialized it
    if( IsFile( m_pszDatabase ) ) {
      bReturn = TRUE;

      // Open the database
      if( SUCCEEDED(hr = m_pDatabase->Open(NULL, m_pwszDatabase, 0) ) ) {
        bReturn = TRUE;
      }
    }

  }

  // create our word wheels
  CTitleInformation* pInfo = NULL;
  if( (m_pTitle && (pInfo = m_pTitle->GetInfo())) || !m_pTitle ) {
    if( (m_pTitle && pInfo->IsKeywordLinks()) || 
        (!m_pTitle && IsSubFile( m_pszDatabase, "$WWKeywordLinks\\Data" ) ) ) {
      m_pKeywordLinks = new CWordWheel( this, g_szKeywordLinks );  
    }
    if( (m_pTitle && pInfo->IsAssociativeLinks()) || 
        (!m_pTitle && IsSubFile( m_pszDatabase, "$WWAssociativeLinks\\Data" ) ) ) {
      m_pAssociativeLinks = new CWordWheel( this, g_szAssociativeLinks );  
    }
  }
  
  if( !bReturn ) {
    Free();
    m_bInit = FALSE;
  }
  else
    m_bInit = TRUE;

  return bReturn;
}

BOOL CTitleDatabase::Free()
{
  BOOL bReturn = FALSE;

  if( m_pTitleMap ) {
    delete m_pTitleMap;
    m_pTitleMap = NULL;
  }

  if( m_pKeywordLinks ) {
    delete m_pKeywordLinks;
    m_pKeywordLinks = NULL;
  }

  if( m_pAssociativeLinks ) {
    delete m_pAssociativeLinks;
    m_pAssociativeLinks = NULL;
  }

  if( m_pDatabase ) {
    m_pDatabase->Close();
    m_pDatabase->Release();
    m_pDatabase = NULL;
  }

  if( m_pwszDatabase ) {
    delete [] (WCHAR*) m_pwszDatabase;
    m_pwszDatabase = NULL;
  }

  if( m_pszDatabase ) {
    delete [] (CHAR*) m_pszDatabase;
    m_pszDatabase = NULL;
  }

  m_bInit = FALSE;

  bReturn = TRUE;

  return bReturn;
}

BOOL CTitleDatabase::MergeWordWheels()
{
  BOOL bReturn = FALSE;
#ifndef CHIINDEX
  // get the application window
  int iTry = 0;
  HWND hWndApp = GetActiveWindow();
  HWND hWndDesktop = GetDesktopWindow();
  HWND hWnd = GetParent( hWndApp );
  if( hWnd ) {
    while( hWnd != hWndDesktop ) {
      if( iTry++ == 16 ) {
        hWndApp = GetActiveWindow();
        if( !IsValidWindow( hWndApp ) )
          hWndApp = NULL;
        break;
      }
      hWndApp = hWnd;
      hWnd = GetParent( hWndApp );
    }
  }
#endif
  // start the animation
#ifndef CHIINDEX
  if( !IsBusy() )
    StartAnimation( IDS_CREATING_INDEX, hWndApp );
#endif

  // if another merge is in progress then wait

  // if we are currently busy then pretend to generate the file
#ifndef CHIINDEX
  while( IsBusy() ) {
    Sleep( 100 );
    NextAnimation();
  }
#endif


  // set the busy state
  SetBusy( TRUE );

  // check if we need to merge or not
  BOOL bMerge = CheckWordWheels();

  // do the merge if necessary
  if( bMerge ) {
#if 0  // MsgBox causes a reentrant problem--so don't do this!
    if( !m_pTitle->GetInfo()->IsNeverPromptOnMerge() ) {
      if( MsgBox( IDS_MERGE_PROMPT, MB_OKCANCEL ) != IDOK )
        bMerge = FALSE;
    }
#endif
    if( bMerge ) {
      bReturn = BuildWordWheels();
    }
  }
  else
    bReturn = TRUE;


#ifndef CHIINDEX
  // stop the animation
  StopAnimation();
#endif
  // reset the busy state
  SetBusy( FALSE );

  return bReturn;
}

BOOL CTitleDatabase::CheckWordWheels()
{
  BOOL bReturn = FALSE;

  //
  // We perform a merge under the following conditions:
  //
  // 1. merged file does not exist.
  // 2. title count has changed
  // 3. any title has changed (updated, removed, added)

  BOOL bMerge = FALSE;
  DWORD dwCount = 0;
  CExTitle* pTitle = NULL;

  // We have to always create the title map even if we do not need to merge

  // first check if each title can be initialized
  // so we know how many real titles we have
  // (the collection may contain bogus entries so we need to exclude these)
  DWORD dwCount0 = m_pCollection->GetRefedTitleCount();

  // create our title map of the existing files
  dwCount = dwCount0;
  m_pTitleMap = new CTitleMap;
  m_pTitleMap->SetCount( dwCount );
  pTitle = m_pCollection->GetFirstTitle();
  for( int iTitle = 0; iTitle < (int) dwCount; iTitle++ ) {
    CTitleMapEntry* pEntry = m_pTitleMap->GetAt( iTitle );
    pEntry->SetTitle( pTitle );
    if( pTitle )
      pTitle = pTitle->GetNext();
  }

  // 1. merged file does not exist.
  bMerge = !IsFile( m_pszDatabase );

  if( !bMerge ) {

    // if we cannot read the file since read access is denied then wait
    // for the file to be readable again
    while( TRUE ) {
      HANDLE hFile = CreateFile( m_pszDatabase, GENERIC_READ, FILE_SHARE_READ,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
      if( hFile != INVALID_HANDLE_VALUE ) {
        CloseHandle( hFile );
        break;
      }
      Sleep( 100 );
      NextAnimation();
    }

    // 2. title count has changed
    CTitleMap* pTitleMapSaved = new CTitleMap( m_pszDatabase );
    DWORD dwCountSaved = pTitleMapSaved->GetCount();
    bMerge = !( dwCountSaved == dwCount );

    // 3. any title has changed (updated, removed, added)
    if( !bMerge ) {

      // walk the title list and compare it's title entries
      // to the one we just read in from the title map.
      // If they differ, then rebuild the merged file
      // otherwise, update the mapping Ids for the title map.
      for( int iTitleSaved = 0; iTitleSaved < (int) dwCountSaved; iTitleSaved++ ) {
        BOOL bMatch = FALSE;
        CTitleMapEntry* pEntrySaved = pTitleMapSaved->GetAt( iTitleSaved );
        const CHAR* pszShortNameSaved    = pEntrySaved->GetShortName();
        FILETIME FileTimeSaved      = pEntrySaved->GetFileTime();
        LCID lcidSaved              = pEntrySaved->GetLanguage();
        DWORD dwIdSaved             = pEntrySaved->GetId();
        for( int iTitle = 0; iTitle < (int) dwCount; iTitle++ ) {
          CTitleMapEntry* pEntry = m_pTitleMap->GetAt( iTitle );
          const CHAR*   pszShortName  = pEntry->GetShortName();
          FILETIME FileTime      = pEntry->GetFileTime();
          LCID     lcid          = pEntry->GetLanguage();
          // BUG 2807: the CHW file on the system had NULL for the "=pdobj" title. 
          // This caused an access violation in SetShortName.  [dalero]
          // A NULL short name will be saved to the CHW file, if we cannot find the CHM.
          if( pszShortNameSaved && !lstrcmpi( pszShortNameSaved, pszShortName ) ) {
            if( !CompareFileTime( &FileTimeSaved, &FileTime ) ) {
              if( lcidSaved == lcid ) {
                // Note, some dummy (MSDN) may have more than one copy of the identical
                // title but saved under a different filename.
                //
                // Thus, we need to make sure that each Id gets assigned to a title
                // and we do this by making sure the Id is not set already.
                // If it is set, the continue looking for the next free spot that
                // contains the same title information.
                if( !pEntry->GetId() ) { // empty Id
                  pEntry->SetId( dwIdSaved ); // set the Id
                  pEntry->SetShortName( pszShortNameSaved ); // set the Short Name
                  bMatch = TRUE;
                  break;
                }
              }
            }
          }
        }
        if( (bMerge = !bMatch) == TRUE )
          break;
      }
    }
    delete pTitleMapSaved;
  }

  if( !bMerge ) {
    // sort the map entries in Id order
    m_pTitleMap->Sort( CompareIds );
  }

  bReturn = bMerge;

  return bReturn;
}

BOOL CTitleDatabase::BuildWordWheels()
{
  BOOL bReturn = FALSE;

  // delete existing file
  if( IsFile( m_pszDatabase ) )
    DeleteFile( m_pszDatabase );

  DWORD dwCount = m_pTitleMap->GetCount();
  CExTitle* pTitle = NULL;

  // now merge the keywords (using the title map)
  CWordWheelCompiler* pCompiler = new CWordWheelCompiler( m_pszDatabase, 
                                          g_wszKeywordLinks, g_wszAssociativeLinks );

  if( pCompiler->Initialize() != S_OK )
    return FALSE;

  IITBuildCollect* pBuildCollect = NULL;
  IITPropList* pPropList = pCompiler->m_pPropList;

// #define HH_SLOW_MERGE // if you want merging to be slow

#ifndef HH_SLOW_MERGE
      // create the property items upfront, and just update them as they change
      pPropList->Set(STDPROP_UID, (DWORD)0, PROP_ADD );
      pPropList->Set(STDPROP_SORTKEY, (VOID*) NULL, 0, PROP_ADD );
#endif

  CWordWheel* pWordWheel = NULL;

  // set our title map Ids (in order), create our databases,
  // and create our word wheels
  for( int iTitleWalk = 0; iTitleWalk < (int) dwCount; iTitleWalk++ ) 
  {
#ifdef CHIINDEX
    if ( m_bAnimation )
    {
#endif
        NextAnimation();
        Sleep(0);
#ifdef CHIINDEX
    }
#endif
    CTitleMapEntry* pEntry = m_pTitleMap->GetAt( iTitleWalk );
    pEntry->SetId( iTitleWalk+1 );

    CTitleDatabase* pDatabase = NULL;
    CWordWheel* pKeywordLinks = NULL;
    CWordWheel* pAssociativeLinks = NULL;

    pDatabase = new CTitleDatabase( pEntry->GetTitle()->GetIndexFileName() );
    if( !pDatabase->Initialize() ) {
      delete pDatabase;
      pDatabase = NULL;
      // Can't do anything else without a CTitleDatabase.
      continue;
    }

    pEntry->SetDatabase( pDatabase );
    pEntry->SetKeywordLinks( pDatabase->GetKeywordLinks() );
    pEntry->SetAssociativeLinks( pDatabase->GetAssociativeLinks() );

    // loop through each word wheel type
    for( int iWordWheel=1; iWordWheel<=2; iWordWheel++ ) {

      if( iWordWheel == 1 ) {
        pWordWheel = pDatabase->GetKeywordLinks();
        pBuildCollect = pCompiler->m_pBuildCollectKeywordLinks;
      }
      if( iWordWheel == 2 ) {
        pWordWheel = pDatabase->GetAssociativeLinks();
        pBuildCollect = pCompiler->m_pBuildCollectAssociativeLinks;
      }
      if( !pWordWheel )
        continue;

      // add each keyword
      DWORD dwCount = pWordWheel->GetCount();

      for( int iKeyword = 0; iKeyword < (int) dwCount; iKeyword++ ) {

        // update the animation
          if( !(iKeyword%200) ) {
#ifdef CHIINDEX
            if (m_bAnimation) {
#endif
                NextAnimation();
                Sleep(0);
#ifdef CHIINDEX
            }
#endif
        }

        DWORD dwKeyword = iKeyword;
        BYTE KeywordObject[HHWW_MAX_KEYWORD_OBJECT_SIZE];
        if( SUCCEEDED( pWordWheel->GetWordWheel()->Lookup( dwKeyword, KeywordObject, HHWW_MAX_KEYWORD_OBJECT_SIZE ) ) ) {
          int iLen = wcslen( (WCHAR*) KeywordObject );
          int iOffset = sizeof(WCHAR) * (iLen+1);
          HHKEYINFO* pInfo = (HHKEYINFO*)(((DWORD_PTR)(&KeywordObject)+iOffset));
          iOffset += sizeof(HHKEYINFO);
          if( pInfo->wFlags & HHWW_SEEALSO )
            iOffset += sizeof(WCHAR) * (wcslen( (WCHAR*) (((DWORD_PTR)&KeywordObject)+iOffset) ) + 1);
          else { // change the UIDs to 12:20 format
            DWORD dwCount = pInfo->dwCount;
            UNALIGNED DWORD* pdwURLId = (DWORD*)(((DWORD_PTR)&KeywordObject)+iOffset);
            for( int iURLId = 0; iURLId < (int) dwCount; iURLId++ ) {
              DWORD dwURLId = *(pdwURLId+iURLId);
              dwURLId = ((iTitleWalk+1)<<20) + dwURLId; // 12:20 format
              *((UNALIGNED DWORD*)(((DWORD_PTR)&KeywordObject)+iOffset)) = dwURLId;
              iOffset += sizeof(DWORD);
            }
          }

          // add the new entry to the new word wheel
          // Note, we must set SZ_WWDEST_OCC and not SZ_WWDEST_KEY
          // otherwise ITCC crashes
#ifdef HH_SLOW_MERGE
          pPropList->Set(STDPROP_UID, (DWORD)0, PROP_ADD );
          pPropList->Set(STDPROP_SORTKEY, (VOID*) KeywordObject, iOffset, PROP_ADD );
          pBuildCollect->SetEntry(SZ_WWDEST_OCC, pPropList);
          pPropList->Clear();
#else
          // simply update the property items -- no need to add/clear them each time
          pPropList->Set(STDPROP_SORTKEY, (VOID*) KeywordObject, iOffset, PROP_UPDATE );
          pBuildCollect->SetEntry(SZ_WWDEST_OCC, pPropList);
#endif
        }
      }

    }

    if( pDatabase ) {
      delete pDatabase;
      pEntry->SetDatabase( NULL );
    }

  }

#ifndef HH_SLOW_MERGE
  pPropList->Clear();
#endif

  // build it
#ifdef CHIINDEX
  if ( m_bAnimation )
  {
#endif
    NextAnimation();
    Sleep(0);
#ifdef CHIINDEX
  }
#endif
  pCompiler->Build();

  // delete the compiler
  delete pCompiler;

  // open the database file
  CFileSystem* pDatabaseMap = new CFileSystem();
  if( FAILED( pDatabaseMap->Init() ) || FAILED( pDatabaseMap->Open( m_pszDatabase, STGM_READWRITE | STGM_SHARE_EXCLUSIVE ) ) ) {
    // stop the animation
    StopAnimation();
    SetBusy( FALSE );
    return FALSE;
  }

  // sort the map entries in Id order
  m_pTitleMap->Sort( CompareIds );

  // write out the new title map
  CSubFileSystem* pTitleMap = new CSubFileSystem( pDatabaseMap );
  pTitleMap->CreateSub( g_szTitleMap );

  // walk the collection and write out the map
  WORD wValue = (WORD) dwCount;

  pTitleMap->WriteSub( (const void*) &wValue, sizeof(wValue) );

  for( int iTitle = 0; iTitle < (int) dwCount; iTitle++ ) {
    CTitleMapEntry* pEntry = m_pTitleMap->GetAt( iTitle );
    const CHAR*   pszShortName = pEntry->GetShortName(); // NOTE: pszShortName may be NULL. If the CHM file does not exists. It can be NULL!!!
    FILETIME FileTime     = pEntry->GetFileTime();
    LCID     lcid         = pEntry->GetLanguage();
    ASSERT(pszShortName != NULL) ; // NOTE: If you get this assert it most likely means that the CHM file associated with this topic doesn't exist.
    DWORD dwLen = 0 ;
    if (pszShortName)
    {
        dwLen = (DWORD)strlen(pszShortName);
    }
    wValue = (WORD) dwLen;
    pTitleMap->WriteSub( (const void*) &wValue, sizeof(wValue) );
    pTitleMap->WriteSub( pszShortName, (int) dwLen );
    pTitleMap->WriteSub( (const void*) &FileTime, sizeof(FileTime) );
    pTitleMap->WriteSub( (const void*) &lcid, sizeof(lcid) );
  }
  delete pTitleMap;
  delete pDatabaseMap;

  bReturn = TRUE;

  return bReturn;
}
/////////////////////////////////////////////////////////////////////////////
// class CWordWheel implementation

void CWordWheel::_CWordWheel()
{
  m_bInit           = FALSE;
  m_pWordWheel      = NULL;
  m_dwCount         = HHWW_ERROR;
  m_pszWordWheelIn  = NULL;
  m_pwszWordWheelIn = NULL;
  m_pwszWordWheel   = NULL;
  m_dwRefCount      = 0;
}

CWordWheel::CWordWheel( CTitleDatabase* pDatabase, const WCHAR* pwszWordWheel, DWORD dwTitleId )
{
  _CWordWheel();
  m_pDatabase = pDatabase;
  m_pwszWordWheelIn = pwszWordWheel;
  m_dwTitleId = dwTitleId;
}

CWordWheel::CWordWheel( CTitleDatabase* pDatabase, const CHAR* pszWordWheel, DWORD dwTitleId )
{
  _CWordWheel();
  m_pDatabase = pDatabase;
  m_pszWordWheelIn = pszWordWheel;
  m_dwTitleId = dwTitleId;
}

CWordWheel::~CWordWheel()
{
  Free();
}

DWORD CWordWheel::AddRef()
{
  return ++m_dwRefCount;
}

DWORD CWordWheel::Release()
{
  if( m_dwRefCount )
    --m_dwRefCount;
  return m_dwRefCount;
}

BOOL CWordWheel::Initialize()
{
  // bail out if we are already initialized
  if( m_bInit )
    return TRUE;

  // allocate a UNICODE version of our word wheel name
  if( m_pszWordWheelIn && *m_pszWordWheelIn ) {
    DWORD dwLen = (DWORD)strlen(m_pszWordWheelIn) + 1;
    m_pwszWordWheel = new WCHAR[dwLen+1];
    MultiByteToWideChar(CP_ACP, 0, m_pszWordWheelIn, -1, (WCHAR*) m_pwszWordWheel, dwLen);
  }
  else if( m_pwszWordWheelIn && *m_pwszWordWheelIn ) {
    DWORD dwLen = wcslen(m_pwszWordWheelIn) + 1;
    m_pwszWordWheel = new WCHAR[dwLen];
    wcscpy( (WCHAR*) m_pwszWordWheel, m_pwszWordWheelIn );
  }

  // bail out if word wheel name not specified
  if( !m_pwszWordWheel || !*m_pwszWordWheel )
    return FALSE;

  BOOL bReturn = FALSE;
  HRESULT hr = S_OK;

  // get ITWordWheel ptr.
  if( SUCCEEDED(hr = CoCreateInstance(CLSID_IITWordWheelLocal, NULL, CLSCTX_INPROC_SERVER,
              IID_IITWordWheel, (void**)&m_pWordWheel) ) ) {

    // open the word wheel
    if( SUCCEEDED(hr = m_pWordWheel->Open( m_pDatabase->GetDatabase(), m_pwszWordWheel, ITWW_OPEN_NOCONNECT) ) ) {
      bReturn = TRUE;
    }
  }

  if( !bReturn ) {
    Free();
    m_bInit = FALSE;
  }
  else
    m_bInit = TRUE;

  return bReturn;
}

BOOL CWordWheel::Free()
{
  BOOL bReturn = FALSE;

  if( m_pWordWheel ) {
    m_pWordWheel->Close();
    m_pWordWheel->Release();
    m_pWordWheel = NULL;
  }

  if( m_pwszWordWheel ) {
    delete [] (WCHAR*) m_pwszWordWheel;
    m_pwszWordWheel = NULL;
  }

  if( m_pwszWordWheelIn )
    m_pwszWordWheelIn = NULL;

  if( m_pszWordWheelIn )
    m_pszWordWheelIn = NULL;

  m_bInit = FALSE;

  bReturn = TRUE;

  return bReturn;
}

DWORD CWordWheel::GetCount()
{
  DWORD dwReturn = HHWW_ERROR;

  if( Init() ) {
    if( m_dwCount == HHWW_ERROR ) {
      LONG nCount;
      if( SUCCEEDED(m_pWordWheel->Count(&nCount)) )
        dwReturn = m_dwCount = nCount;
    }
    else
      dwReturn = m_dwCount;
  }

  return dwReturn;
}

/////////////////////////////////////////////////////////////////////////////
// CWordWheel::GetIndex
//
// params:
//
// pwszKeywordIn  - keyword to lookup
//
// bFragment      - set this to TRUE if only looking for a partial match
//                  such as when the user types in a string fragment
//                  in the Index tab
//
// pdwIndexLast   - If not NULL, then the function should return the
//                  first equivalent index and set the contents of this
//                  argument to the index of the last equivalent keyword.
//                  And equivalent keyword is where the root word (less
//                  and special prefixes) is the same regardless of case.
//                  For example, "_open", "open", "Open", and "OPEN" are
//                  equivalent keywords.  This should be used for F1 lookups
//                  and A/KLink lookups as well.
//
// Note: if bFragment is TRUE and pdwIndexLast is non-NULL then
//       bFragment will be set to FALSE.  If neither, then we look for an
//       exact match only.
//
DWORD CWordWheel::GetIndex( const WCHAR* pwszKeywordIn, BOOL bFragment, DWORD* pdwIndexLast )
{
  DWORD dwIndexFirst = HHWW_ERROR;

  // we cannot do both a fragment lookup and an equivalent lookup
  if( pdwIndexLast )
    bFragment = FALSE;

  if( Init() && pwszKeywordIn && *pwszKeywordIn ) {

    if( GetCount() == (DWORD) -1 )
      return dwIndexFirst;

    // since we are using a pluggable sort object the input to Lookup must
    // be in the save format as the sort object itself.  That is, we need
    // to add an HHKEYINFO structure to the end of this string and fill in
    // the data properly since the CHHSysSort::GetSize function in our
    // pluggable sort module will get this object and expect in in that format
    //
    // Note, if it did not contain the trailing struct it can and will fault.
    BYTE KeywordObject[HHWW_MAX_KEYWORD_OBJECT_SIZE];
    WCHAR* pwszKeywordObject = (WCHAR*) KeywordObject;

    wcsncpy( pwszKeywordObject, pwszKeywordIn, HHWW_MAX_KEYWORD_LENGTH );
    pwszKeywordObject[HHWW_MAX_KEYWORD_LENGTH] = 0;

#ifdef _DEBUG
    int iMaxObject = HHWW_MAX_KEYWORD_OBJECT_SIZE;
    int iMaxLen = HHWW_MAX_KEYWORD_LENGTH;
    int iLen = wcslen(pwszKeywordObject);
#endif

    HHKEYINFO Info;
    Info.wFlags = 0;
    Info.wLevel = 0;
    Info.dwLevelOffset = 0;
    Info.dwFont = 0;
    Info.dwCount = 0;

    DWORD dwLength = sizeof(WCHAR) * (wcslen(pwszKeywordObject) + 1);
    *((HHKEYINFO*)(((DWORD_PTR)pwszKeywordObject)+dwLength)) = Info;

    // There are three kinds of lookup matches:
    //
    //  1. Exact - found hits must be completely indentical to the
    //             keyword we are looking up.
    //             "FOOBAR" == "FOOBAR"
    //
    //  2. Equivalent - the keyword must only differ by case or prefixes
    //                  and we continue to find all keywords, not just the
    //                  first one, that meets this criteria.
    //                  "_foobar" == "FooBar" == "FOOBAR"
    //
    //  3. Fragment - find the first hit where only the first non-prefixed
    //                characters need to match while ignoring case.
    //                "~fo" == "FOOBAR" (assuming nothing else was a closer match)

    //  We have three ways that we perform such lookups:
    //
    //  1. Index tab - Tries Exact first then uses Fragment lookups.
    //
    //  2. F1 Lookups - Tries Exact first then uses Equivalent lookups.
    //
    //  3. A/Klinks - Tries Exact first then uses Equivalent lookups.

    // Centaur just doesn't do the right thing for non-exact,
    // a.k.a. prefix, lookups!
    //
    // For exact matches, try the first found keyword and verify it.
    // If it does not match, then try a fragment lookup.
    //
    // For fragment matches, we need to first try the exact match
    // technique noted above.
    // If it does not match, then try a partial (size of lookup word),
    // case-insensitive lookup.
    // If it does not match, and then try the *next* entry in the same fashion.

    BYTE KeywordObjectTry[HHWW_MAX_KEYWORD_OBJECT_SIZE];
    WCHAR* pwszKeywordObjectTry = (WCHAR*) KeywordObjectTry;

    // Try exact matches first
    if( SUCCEEDED(m_pWordWheel->Lookup( &KeywordObject, (BOOL) TRUE, (LONG*) &dwIndexFirst )) ) {
      if( SUCCEEDED(m_pWordWheel->Lookup( dwIndexFirst, &KeywordObjectTry, sizeof(KeywordObjectTry) )) ) {
        if( !(wcscmp( pwszKeywordObjectTry, pwszKeywordObject ) == 0) ) {
          dwIndexFirst = HHWW_ERROR;
        }
      }
    }

    // Try equivalent match next
    if( pdwIndexLast && (dwIndexFirst == HHWW_ERROR) ) {

      // skip over any special chars
      const WCHAR* pwszKeyword = NULL;
      for( pwszKeyword = pwszKeywordObject; pwszKeyword; pwszKeyword++ ) {
        if( !(( (*pwszKeyword) == L'_') || ( (*pwszKeyword) == L'~')) )
          break;
      }

      // Try a prefix lookup
      if( SUCCEEDED(m_pWordWheel->Lookup( pwszKeyword, (BOOL) FALSE, (LONG*) &dwIndexFirst )) ) {
        if( SUCCEEDED(m_pWordWheel->Lookup( dwIndexFirst, &KeywordObjectTry, sizeof(KeywordObjectTry) )) ) {

          // validate the hit, if it fails, try the next index value
          DWORD dwTryFirst = dwIndexFirst;
          dwIndexFirst = HHWW_ERROR;
          for( DWORD dwTry = dwTryFirst; dwTry <= dwTryFirst+1 ; dwTry++ ) {

            if( SUCCEEDED(m_pWordWheel->Lookup( dwTry, &KeywordObjectTry, sizeof(KeywordObjectTry) )) ) {
              // try it without prefixes in the input string
              if( wcsicmp( pwszKeywordObjectTry, pwszKeyword ) == 0 ) {
                dwIndexFirst = dwTry;
                break;
              } // try it with the prefixes back in
              else if( ((DWORD_PTR) pwszKeyword) != ((DWORD_PTR) pwszKeywordObject) ) {
                if( wcsicmp( pwszKeywordObjectTry, pwszKeywordObject ) == 0 ) {
                  dwIndexFirst = dwTry;
                  break;
                }
              } // ignore prefixes in found hit
              else if( (*pwszKeywordObjectTry == L'_') || (*pwszKeywordObjectTry == L'~') ) {
                const WCHAR* pwszKeyword = NULL;
                for( pwszKeyword = pwszKeywordObjectTry; pwszKeyword; pwszKeyword++ ) {
                  if( !(( (*pwszKeyword) == L'_') || ( (*pwszKeyword) == L'~')) )
                    break;
                }
                if( wcsicmp( pwszKeywordObject, pwszKeyword ) == 0 ) {
                  dwIndexFirst = dwTry;
                  break;
                }
              }


            }
          }
        }
      }

    }

    // Try fragment match last
    if( bFragment && (dwIndexFirst == HHWW_ERROR) ) {

      // skip over any special chars
      const WCHAR* pwszKeyword = NULL;
      for( pwszKeyword = pwszKeywordObject; pwszKeyword; pwszKeyword++ ) {
        if( !(( (*pwszKeyword) == L'_') || ( (*pwszKeyword) == L'~')) )
          break;
      }

      while( TRUE ) {

        if( SUCCEEDED(m_pWordWheel->Lookup( pwszKeyword, (BOOL) FALSE, (LONG*) &dwIndexFirst )) ) {
          int iLen = wcslen( pwszKeyword );
          if( SUCCEEDED(m_pWordWheel->Lookup( dwIndexFirst, &KeywordObjectTry, sizeof(KeywordObjectTry) )) ) {

            // validate the hit, if it fails, try the next index value
            DWORD dwTryFirst = dwIndexFirst;
            dwIndexFirst = HHWW_ERROR;
            for( DWORD dwTry = dwTryFirst; dwTry <= dwTryFirst+1; dwTry++ ) {

              if( SUCCEEDED(m_pWordWheel->Lookup( dwTry, &KeywordObjectTry, sizeof(KeywordObjectTry) )) ) {
                // try it without prefixes in the input string
                int iLen2 = min(iLen, (int) wcslen(pwszKeywordObjectTry));
                if( wcsnicmp( pwszKeywordObjectTry, pwszKeyword, iLen2 ) == 0 ) {
                  dwIndexFirst = dwTry;
                  break;
                } // try it with the prefixes back in
                else if( ((DWORD_PTR) pwszKeyword) != ((DWORD_PTR) pwszKeywordObject) ) {
                  int iLen = wcslen( pwszKeywordObject );
                  if( wcsnicmp( pwszKeywordObjectTry, pwszKeywordObject, iLen2 ) == 0 ) {
                    dwIndexFirst = dwTry;
                    break;
                  }
                } // ignore prefixes in found hit
                else if( (*pwszKeywordObjectTry == L'_') || (*pwszKeywordObjectTry == L'~') ) {
                  const WCHAR* pwszKeyword = NULL;
                  for( pwszKeyword = pwszKeywordObjectTry; pwszKeyword; pwszKeyword++ ) {
                    if( !(( (*pwszKeyword) == L'_') || ( (*pwszKeyword) == L'~')) )
                      break;
                  }
                  if( wcsnicmp( pwszKeywordObject, pwszKeyword, iLen2 ) == 0 ) {
                    dwIndexFirst = dwTry;
                    break;
                  }
                } // for framgent lookups only, when all else fails,
                  // simply trust the first try (works half the time)
                else if( dwTry == dwTryFirst+1 ) {
                  dwIndexFirst = dwTryFirst;
                  break;
                }
              }


            }
          }
        }

        // for fragments, we need to keep trying until we get a hit by
        // trimming the trailing chars one at a time until we get a match
        if( KeywordObject[0] && (dwIndexFirst == HHWW_ERROR) ) {
          DWORD dwLength = wcslen(pwszKeywordObject);
          if( dwLength <= 1 )
            break;
          pwszKeywordObject[dwLength-1] = L'\0';
          *((HHKEYINFO*)(((DWORD_PTR)KeywordObject)+(dwLength*sizeof(WCHAR)))) = Info;
          continue;
        }
        break;

      }
    }

    // if equivalent match found then find the real first and last equivalent
    if( pdwIndexLast && (dwIndexFirst != HHWW_ERROR) ) {
      DWORD dwIndexFirstTry = dwIndexFirst;
      DWORD dwIndexLastTry  = dwIndexFirst;

      // skip over any special chars
      const WCHAR* pwszKeyword = NULL;
      for( pwszKeyword = pwszKeywordObject; pwszKeyword; pwszKeyword++ ) {
        if( !(( (*pwszKeyword) == L'_') || ( (*pwszKeyword) == L'~')) )
          break;
      }

      // find the first one
      for( dwIndexFirstTry--; dwIndexFirstTry != (DWORD)-1; dwIndexFirstTry-- ) {
        if( SUCCEEDED(m_pWordWheel->Lookup( dwIndexFirstTry, &KeywordObjectTry, sizeof(KeywordObjectTry) )) ) {
          const WCHAR* pwszBuffer = NULL;
          for( pwszBuffer = pwszKeywordObjectTry; pwszBuffer; pwszBuffer++ ) {
            if( !(( (*pwszBuffer) == L'_') || ( (*pwszBuffer) == L'~')) )
              break;
          }
          if( !(_wcsicmp( pwszBuffer, pwszKeyword ) == 0) )
            break;
          dwIndexFirst = dwIndexFirstTry;
        }
      }

      // find the last one
      *pdwIndexLast = dwIndexLastTry;
      for( dwIndexLastTry++; dwIndexLastTry <= m_dwCount; dwIndexLastTry++ ) {
        if( SUCCEEDED(m_pWordWheel->Lookup( dwIndexLastTry, &KeywordObjectTry, sizeof(KeywordObjectTry) )) ) {
          const WCHAR* pwszBuffer = NULL;
          for( pwszBuffer = pwszKeywordObjectTry; pwszBuffer; pwszBuffer++ ) {
            if( !(( (*pwszBuffer) == L'_') || ( (*pwszBuffer) == L'~')) )
              break;
          }
          if( !(_wcsicmp( pwszBuffer, pwszKeyword ) == 0) )
            break;
          *pdwIndexLast = dwIndexLastTry;
        }
      }
    }

  }

  return dwIndexFirst;
}

DWORD CWordWheel::GetIndex( const CHAR* pszKeyword, BOOL bFragment, DWORD* pdwIndexLast )
{
  DWORD dwReturn = HHWW_ERROR;

  if( pszKeyword && *pszKeyword ) {
    WCHAR wszKeyword[HHWW_MAX_KEYWORD_LENGTH+1];
    if( MultiByteToWideChar(CP_ACP, 0, pszKeyword, -1, wszKeyword, HHWW_MAX_KEYWORD_LENGTH+1) )
      dwReturn = GetIndex( wszKeyword, bFragment, pdwIndexLast );
  }

  return dwReturn;
}

BOOL CWordWheel::GetString( DWORD dwKeyword, WCHAR* pwszBuffer, DWORD cchBuffer, BOOL bFull, BOOL bCacheAll )
{
  BOOL bReturn = FALSE;

  if( pwszBuffer && cchBuffer>0 ) {
    if( (bReturn = GetIndexData( dwKeyword, bCacheAll ) ) ) {
      DWORD dwLength = 0;
      if( bFull )
        dwLength = wcslen(m_CachedEntry.m_wszFullKeyword)+1;
      else
        dwLength = wcslen(m_CachedEntry.m_wszKeyword)+1;
      if( dwLength <= cchBuffer )
        if( bFull )
          wcscpy( pwszBuffer, m_CachedEntry.m_wszFullKeyword );
        else
          wcscpy( pwszBuffer, m_CachedEntry.m_wszKeyword );
      else
        *pwszBuffer = L'\0';
    }
  }

  return bReturn;
}

BOOL CWordWheel::GetString( DWORD dwKeyword, CHAR* pszBuffer, DWORD cchBuffer, BOOL bFull, BOOL bCacheAll )
{
  BOOL bReturn = FALSE;

  if( pszBuffer && cchBuffer>0 ) {
    WCHAR wszBuffer[HHWW_MAX_KEYWORD_LENGTH+1];
    if( bReturn = GetString( dwKeyword, wszBuffer, cchBuffer, bFull, bCacheAll ) ) {
      if( WideCharToMultiByte(CP_ACP, 0, wszBuffer, -1, pszBuffer, cchBuffer, NULL, NULL) == 0 )
        bReturn = TRUE;
    }
  }

  return bReturn;
}

DWORD CWordWheel::GetLevel( DWORD dwKeyword )
{
  DWORD dwReturn = HHWW_ERROR;

  if( GetIndexData( dwKeyword ) )
    dwReturn = m_CachedEntry.m_dwLevel;

  return dwReturn;
}

DWORD CWordWheel::GetLevelOffset( DWORD dwKeyword )
{
  DWORD dwReturn = HHWW_ERROR;

  if( GetIndexData( dwKeyword ) )
    dwReturn = m_CachedEntry.m_dwLevelOffset;

  return dwReturn;
}

BOOL CWordWheel::IsPlaceHolder( DWORD dwKeyword )
{
  BOOL bReturn = FALSE;

  if( GetIndexData( dwKeyword ) ) {
    if( m_CachedEntry.m_dwFlags & HHWW_SEEALSO ) {
      if( wcscmp( m_CachedEntry.m_wszSeeAlso, m_CachedEntry.m_wszFullKeyword ) == 0 ) {
        bReturn = TRUE;
      }
    }
  }

  return bReturn;
}

BOOL CWordWheel::GetSeeAlso( DWORD dwKeyword, WCHAR* pwszBuffer, DWORD cchBuffer )
{
  BOOL bReturn = FALSE;

  if( pwszBuffer && cchBuffer>0 ) {
    if( (bReturn = GetIndexData( dwKeyword ) ) ) {
      if( m_CachedEntry.m_dwFlags & HHWW_SEEALSO ) {
        if( (DWORD) (wcslen(m_CachedEntry.m_wszSeeAlso)+1) <= cchBuffer )
          wcscpy( pwszBuffer, m_CachedEntry.m_wszSeeAlso );
        else
          *pwszBuffer = L'\0';
      }
      else
        bReturn = FALSE;
    }
  }

  return bReturn;
}

BOOL CWordWheel::GetSeeAlso( DWORD dwKeyword, CHAR* pszBuffer, DWORD cchBuffer )
{
  BOOL bReturn = FALSE;

  if( pszBuffer && cchBuffer>0 ) {
    WCHAR wszBuffer[HHWW_MAX_KEYWORD_LENGTH+1];
    if( bReturn = GetSeeAlso( dwKeyword, wszBuffer, cchBuffer ) ) {
      if( WideCharToMultiByte(CP_ACP, 0, wszBuffer, -1, pszBuffer, cchBuffer, NULL, NULL) == 0 )
        bReturn = TRUE;
    }
  }

  return bReturn;
}

DWORD CWordWheel::GetHitCount( DWORD dwKeyword )
{
  DWORD dwReturn = HHWW_ERROR;

  if( GetIndexHitData( dwKeyword ) )
    dwReturn = m_CachedResults.GetCount();

  return dwReturn;
}

DWORD CWordWheel::GetHit( DWORD dwKeyword, DWORD dwHit, CExTitle** ppTitle )
{
  DWORD dwReturn = HHWW_ERROR;

  if( GetIndexHitData( dwKeyword ) ) {
    dwReturn = m_CachedResults.GetAt( dwHit )->GetURLId();
    if( ppTitle != NULL )
      *ppTitle = m_CachedResults.GetAt( dwHit )->GetTitle();
  }

  return dwReturn;
}

inline BOOL CWordWheel::GetIndexHitData( const VOID* pcvKeywordObject, DWORD cbSize, HHKEYINFO* pInfo, DWORD dwKeyword )
{
  if( !((pInfo->wFlags) & HHWW_UID_OVERFLOW) && pInfo->dwCount ) {
    m_CachedResults.SetIndex( dwKeyword, pInfo->dwCount );
    for( int i = 0; i < (int) pInfo->dwCount; i++ ) {
      DWORD dwURLId = *((UNALIGNED DWORD*) (((DWORD_PTR)pcvKeywordObject) + cbSize + (i*sizeof(DWORD))) );
      CExTitle* pTitle = m_pDatabase->GetTitle();
      // if we are reading a word wheel that is to be merged then
      // translate the URL Ids into 12/20 format
      if( m_dwTitleId ) {
        dwURLId = (m_dwTitleId<<20) + dwURLId;
      }
      // if we are reading a collection file then
      // translate the URL Ids to standard format
      // and set the title pointer appropriately
      else if( m_pDatabase->IsCollection() ) {
        DWORD dwTitleId = dwURLId>>20;
        // v1.1a creates bogus entries in the chw file.  So
        // to workaround this we need to set the title id to 1
        // and the url id to 0 when the title id is greater than
        // the title count
        if( dwTitleId > m_pDatabase->GetTitleMap()->GetCount() ) {
          dwTitleId = 1;
          dwURLId = 0;
        }
        else if( dwTitleId ) {
          dwURLId = dwURLId & 0x000FFFFF;
          pTitle = m_pDatabase->GetTitleMap()->GetAt(dwTitleId-1)->GetTitle();
        }
      }
      m_CachedResults.GetAt( i )->SetURLId( dwURLId );
      m_CachedResults.GetAt( i )->SetTitle( pTitle );
    }
  }

  return TRUE;
}


BOOL CWordWheel::GetIndexData( DWORD dwKeyword, BOOL bCacheAll )
{
  BOOL bReturn = FALSE;

  if( Init() ) {

    if( m_CachedEntry.m_dwIndex != dwKeyword ) {

      BYTE KeywordObject[HHWW_MAX_KEYWORD_OBJECT_SIZE];
      const VOID* pcvKeywordObject = KeywordObject;
      if( SUCCEEDED(m_pWordWheel->Lookup( dwKeyword, KeywordObject, sizeof(KeywordObject) ) ) ) {
        m_CachedEntry.m_dwIndex = dwKeyword;
        wcscpy( m_CachedEntry.m_wszFullKeyword, (WCHAR*) pcvKeywordObject );
        DWORD cbSize = sizeof(WCHAR) * (wcslen((WCHAR*)pcvKeywordObject) + 1);
        HHKEYINFO* pInfo = (HHKEYINFO*)(((DWORD_PTR)(pcvKeywordObject))+cbSize);
        m_CachedEntry.m_dwFlags = (DWORD) pInfo->wFlags;
        m_CachedEntry.m_dwLevel = (DWORD) pInfo->wLevel;
        m_CachedEntry.m_dwLevelOffset = pInfo->dwLevelOffset;
        cbSize += sizeof(HHKEYINFO);
        if( pInfo->wLevel )
          wcscpy( m_CachedEntry.m_wszKeyword, (WCHAR*) (((DWORD_PTR)pcvKeywordObject)+(pInfo->dwLevelOffset*sizeof(WCHAR))) );
        else
          wcscpy( m_CachedEntry.m_wszKeyword, (WCHAR*) pcvKeywordObject );
        if( (pInfo->wFlags) & HHWW_SEEALSO ) {
          wcscpy( m_CachedEntry.m_wszSeeAlso, (WCHAR*)(((DWORD_PTR)pcvKeywordObject)+cbSize) );
        }
        if( bCacheAll ) {
          GetIndexHitData( pcvKeywordObject, cbSize, pInfo, dwKeyword );
        }
      }
    }

    if( dwKeyword < GetCount() )
      bReturn = TRUE;
  }

  return bReturn;
}

BOOL CWordWheel::GetIndexHitData( DWORD dwKeyword )
{
  BOOL bReturn = FALSE;

  if( Init() ) {

    if( m_CachedResults.GetIndex() != dwKeyword ) {

      BYTE KeywordObject[HHWW_MAX_KEYWORD_OBJECT_SIZE];
      const VOID* pcvKeywordObject = KeywordObject;
      if( SUCCEEDED(m_pWordWheel->Lookup( dwKeyword, KeywordObject, sizeof(KeywordObject) ) ) ) {
        DWORD cbSize = sizeof(WCHAR) * (wcslen((WCHAR*)pcvKeywordObject) + 1);
        HHKEYINFO* pInfo = (HHKEYINFO*)(((DWORD_PTR)(pcvKeywordObject))+cbSize);
        cbSize += sizeof(HHKEYINFO);
        GetIndexHitData( pcvKeywordObject, cbSize, pInfo, dwKeyword );
      }
    }

    if( dwKeyword < GetCount() )
      bReturn = TRUE;

  }

  return bReturn;
}

/////////////////////////////////////////////////////////////////////////////
// class CWordWheelCompiler implementation

void CWordWheelCompiler::_CWordWheelCompiler()
{
  m_bInit = FALSE;
  m_pszDatabase = NULL;
  m_pwszKeywordLinks = NULL;
  m_pwszAssociativeLinks = NULL;
  m_lcid = 0;

  m_pFileSystem = NULL;
  m_pDatabase = NULL;
  m_pPersistStorageDatabase = NULL;

  m_pBuildCollectKeywordLinks = NULL;
  m_pBuildCollectAssociativeLinks = NULL;
  m_pPropList = NULL;

  m_pStorageKeywordLinks = NULL;
  m_pStorageAssociativeLinks = NULL;
  m_pPersistStorageKeywordLinks = NULL;
  m_pPersistStorageAssociativeLinks = NULL;
}

CWordWheelCompiler::CWordWheelCompiler( const CHAR* pszDatabase, const WCHAR* pwszKeywordLinks, const WCHAR* pwszAssociativeLinks, LCID lcid )
{
  _CWordWheelCompiler();
  m_pszDatabase = pszDatabase;
  m_pwszKeywordLinks = pwszKeywordLinks;
  m_pwszAssociativeLinks = pwszAssociativeLinks;
  m_lcid = lcid;
}

CWordWheelCompiler::~CWordWheelCompiler()
{
  Free();
}

HRESULT CWordWheelCompiler::Initialize()
{
  HRESULT hr = S_FALSE;

  // bail out if we are already initialized
  if( m_bInit )
    return S_OK;

  // bail out if word wheel stream names not specified
  if( !m_pwszKeywordLinks || !*m_pwszKeywordLinks ||
      !m_pwszAssociativeLinks || !*m_pwszAssociativeLinks )
    return S_FALSE;

  // if the database is specified then use it otherwise generate
  //   a temporary filename
  char szTempPath[MAX_PATH];
  GetTempPath( sizeof(szTempPath), szTempPath );

  if( m_pszDatabase && *m_pszDatabase ) {
    strcpy( m_szDatabase, m_pszDatabase );
  }
  else {
    GetTempFileName( szTempPath,"TFS",0, m_szDatabase );
  }

  // create the file system (delete the old one if it exists
  if( IsFile( m_szDatabase ) )
    DeleteFile( m_szDatabase );

  m_pFileSystem = new CFileSystem;
  if( !m_pFileSystem || FAILED( m_pFileSystem->Init() ) || FAILED( m_pFileSystem->CreateUncompressed( m_szDatabase ) ) ) {
    return S_FALSE;
  }

  // get ITDatabase ptr.
  if( SUCCEEDED(hr = CoCreateInstance(CLSID_IITDatabaseLocal, NULL, CLSCTX_INPROC_SERVER,
              IID_IITDatabase, (void**)&m_pDatabase) ) ) {
    if( SUCCEEDED(hr = m_pDatabase->QueryInterface( IID_IPersistStorage, (void**)&m_pPersistStorageDatabase ) ) ) {
      if( SUCCEEDED(hr = m_pPersistStorageDatabase->InitNew( m_pFileSystem->GetITStorageDocObj() ) ) ) {
        m_bInit = TRUE;
      }
    }
  }

  // create the sorter object
  DWORD dwSorterInstance;
  m_pDatabase->CreateObject( CLSID_HHSysSort, &dwSorterInstance );

  // Create Build Collection objects
  if( SUCCEEDED(hr = CoCreateInstance( CLSID_IITWordWheelUpdate, NULL, CLSCTX_INPROC_SERVER,
    IID_IITBuildCollect, (VOID**)&m_pBuildCollectKeywordLinks ) ) ) {

    if( SUCCEEDED(hr = CoCreateInstance( CLSID_IITWordWheelUpdate, NULL, CLSCTX_INPROC_SERVER,
      IID_IITBuildCollect, (VOID**)&m_pBuildCollectAssociativeLinks ) ) ) {

      // Create keyword Property List (used for both AssociativeLinks and KeywordLinks)
      if( SUCCEEDED(hr = CoCreateInstance( CLSID_IITPropList, NULL, CLSCTX_INPROC_SERVER, IID_IITPropList, (VOID**)&m_pPropList) ) ) {
        m_bInit = TRUE;
      }
    }
  }

  // create the substorage files
  DWORD dwLen = 0;
  CHAR* psz = NULL;

  // KeywordLinks
  WCHAR wszKeywordLinks[MAX_PATH];
  m_pBuildCollectKeywordLinks->GetTypeString( wszKeywordLinks, NULL ); // Get the "$WW" prefix
  wcscat( wszKeywordLinks, m_pwszKeywordLinks );
  m_pFileSystem->GetITStorageDocObj()->CreateStorage( wszKeywordLinks, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorageKeywordLinks);
  m_pBuildCollectKeywordLinks->QueryInterface( IID_IPersistStorage, (void**)&m_pPersistStorageKeywordLinks );
  m_pPersistStorageKeywordLinks->InitNew( m_pStorageKeywordLinks );

  // AssociativeLinks
  WCHAR wszAssociativeLinks[MAX_PATH];
  m_pBuildCollectAssociativeLinks->GetTypeString( wszAssociativeLinks, NULL ); // Get the "$WW" prefix
  wcscat( wszAssociativeLinks, m_pwszAssociativeLinks );
  m_pFileSystem->GetITStorageDocObj()->CreateStorage( wszAssociativeLinks, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorageAssociativeLinks);
  m_pBuildCollectAssociativeLinks->QueryInterface( IID_IPersistStorage, (void**)&m_pPersistStorageAssociativeLinks );
  m_pPersistStorageAssociativeLinks->InitNew( m_pStorageAssociativeLinks );

  // get local information
  char szCodePage[20] = "1252";
  if( m_lcid == ((DWORD)-1) )
    m_lcid = GetSystemDefaultLCID();
  GetLocaleInfo(m_lcid,LOCALE_IDEFAULTANSICODEPAGE,szCodePage,sizeof(szCodePage) );
  DWORD dwCodePage = Atoi( szCodePage );

  // apply sorter object information to the new word wheels
  VARARG vaDword = {0};
  vaDword.dwArgc = 2;
  vaDword.Argv[0] =  (void *)(INT_PTR)IHHSK100_KEYTYPE_UNICODE_SZ;
  vaDword.Argv[1] = (void*) 0;
  VARARG vaEmpty = {0};
  m_pBuildCollectKeywordLinks->InitHelperInstance( dwSorterInstance, m_pDatabase,
        dwCodePage, m_lcid, vaDword, vaEmpty );
  m_pBuildCollectAssociativeLinks->InitHelperInstance( dwSorterInstance, m_pDatabase,
        dwCodePage, m_lcid, vaDword, vaEmpty );

  if( FAILED(hr) ) {
    Free();
    m_bInit = FALSE;
  }
  else
    m_bInit = TRUE;

  return hr;
}

HRESULT CWordWheelCompiler::Free()
{
  HRESULT hr = S_FALSE;

  if( m_pPersistStorageKeywordLinks ) {
    m_pPersistStorageKeywordLinks->Release();
    m_pPersistStorageKeywordLinks = NULL;
  }

  if( m_pPersistStorageAssociativeLinks ) {
    m_pPersistStorageAssociativeLinks->Release();
    m_pPersistStorageAssociativeLinks = NULL;
  }

  if( m_pStorageKeywordLinks ) {
    m_pStorageKeywordLinks->Release();
    m_pStorageKeywordLinks = NULL;
  }

  if( m_pStorageAssociativeLinks ) {
    m_pStorageAssociativeLinks->Release();
    m_pStorageAssociativeLinks = NULL;
  }

  if( m_pPropList ) {
    m_pPropList->Release();
    m_pPropList = NULL;
  }

  if( m_pBuildCollectAssociativeLinks ) {
    m_pBuildCollectAssociativeLinks->Release();
    m_pBuildCollectAssociativeLinks = NULL;
  }

  if( m_pBuildCollectKeywordLinks ) {
    m_pBuildCollectKeywordLinks->Release();
    m_pBuildCollectKeywordLinks = NULL;
  }

  if( m_pPersistStorageDatabase ) {
    m_pPersistStorageDatabase->Release();
    m_pPersistStorageDatabase = NULL;
  }

  if( m_pDatabase ) {
    m_pDatabase->Close();
    m_pDatabase->Release();
    m_pDatabase = NULL;
  }

  if( m_pFileSystem ) {
    delete m_pFileSystem;
    m_pFileSystem = NULL;
  }

  m_bInit = FALSE;

  hr = S_OK;

  return hr;
}

HRESULT CWordWheelCompiler::Build()
{
  HRESULT hr = S_FALSE;

  if( Init() ) {
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();

    // KeywordLinks
    m_pPersistStorageKeywordLinks->Save( m_pStorageKeywordLinks, TRUE );
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();
    m_pPersistStorageKeywordLinks->Release();
    m_pPersistStorageKeywordLinks = NULL;
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();
    m_pStorageKeywordLinks->Commit(STGC_DEFAULT);
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();

    // AssociativeLinks
    m_pPersistStorageAssociativeLinks->Save( m_pStorageAssociativeLinks, TRUE );
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();
    m_pPersistStorageAssociativeLinks->Release();
    m_pPersistStorageAssociativeLinks = NULL;
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();
    m_pStorageAssociativeLinks->Commit(STGC_DEFAULT);

#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();

    // Database == $OBJINST file
    m_pPersistStorageDatabase->Save( m_pFileSystem->GetITStorageDocObj(), TRUE );
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();
    m_pPersistStorageDatabase->Release();
    m_pPersistStorageDatabase = NULL;
#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();
    m_pFileSystem->GetITStorageDocObj()->Commit(STGC_DEFAULT);

#ifdef CHIINDEX
    if ( m_bAnimation )
#endif
        NextAnimation();

  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\window.cpp ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#include "header.h"

#ifdef _DEBUG
#undef THIS_FILE
static const char THIS_FILE[] = __FILE__;
#endif

#include <commctrl.h>
#include "strtable.h"
#include "hha_strtable.h"
#include "contain.h"
#include "resource.h"
#include "secwin.h"
#include "state.h"
#include "highlite.h"
// CSizebar class for registration.
#include "sizebar.h"

// Custom NavPane for registration
#include "custmtab.h"
#include "unicode.h"

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"

#define DEFAULT_WINDOW_WIDTH 300

static const char txtNavWind[] = ">navwin";

#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring

// Forward Reference
void GetMonitorRect(HWND hwnd, LPRECT prc, BOOL fWork) ;
void multiMonitorRectFromRect(/*in*/  RECT rcScreenCoords,  /*out*/ LPRECT prc, /*in*/  BOOL fWork) ;
void multiMonitorRectFromPoint(/*in*/  POINT ptScreenCoords, /*out*/ LPRECT prc, /*in*/  BOOL fWork) ;

/***************************************************************************

    FUNCTION:   CreateHelpWindow

    PURPOSE:    Create a help window

    PARAMETERS:
        pszType --  (optional) specifies a window type to create. Type must
                    have been specified previously
        hwndCaller -- this will be the parent of the window

    RETURNS:    HWND on success, NULL on failure

    COMMENTS:
        Reallocates pahwnd if more slots are necessary.

    MODIFICATION DATES:
        26-Feb-1996 [ralphw]

***************************************************************************/

CHHWinType* CreateHelpWindow(PCSTR pszType, LPCTSTR pszFile, HWND hwndCaller, CHmData* phmData)
{
    static BOOL fRegistered = FALSE;

    ASSERT(pahwnd != NULL);

    // Generate a default window type, if a name isn't given.
    char szName[20];
    const char* pType  = pszType ;
    if (IsEmptyString(pszType))
    {
        static int iWindowNum = 1;

        // If the caller didn't specify a window type, then create a name
        // based off the current window number.
        wsprintf(szName, "win%u", iWindowNum++);
        pType = szName ;
    }

    // When we create a Window slot, we need the filename. However, if we are looking up a URL
    // we might not have a filename. So, pass NULL. This is a HOLE.
    CHHWinType* phh = FindOrCreateWindowSlot(pType, pszFile ? pszFile
                                                            : phmData ? phmData->GetCompiledFile()
                                                            : NULL);
    if (! phh )
       return NULL;

    phh->m_phmData = phmData;

    if (phmData)
   {
      // Count references
      phmData->AddRef();

      //--- Get the windows state.
        WINDOW_STATE wstate;
        ZERO_STRUCTURE(wstate);

        CState* pstate = phmData->m_pTitleCollection->GetState();
        if (SUCCEEDED(pstate->Open(pType, STGM_READ)))
        {
            DWORD cbRead;
            pstate->Read(&wstate.cbStruct, sizeof(int), &cbRead);
            //
            // This looks funky until you understand that CState only supports atomic reads and writes from the beginning
            // of the stream. i.e. It does not maintain a file position pointer. <mc>
            //
            if ( wstate.cbStruct )
                pstate->Read(&wstate, wstate.cbStruct, &cbRead);
            pstate->Close();
        }

        if (wstate.cbStruct)
      {

         if (IsRectEmpty(phh->GetWinRect()) || phh->IsProperty(HHWIN_PROP_USER_POS))
         {
               phh->fNotExpanded = wstate.fNotExpanded;
                CopyRect(&phh->rcWindowPos, &wstate.rcPos);
                phh->iNavWidth = wstate.iNavWidth;
                phh->rcNav.left = 0;
                phh->rcNav.right = wstate.iNavWidth;
            }

            if (phh->m_phmData->m_pTitleCollection->m_pSearchHighlight)
                phh->m_phmData->m_pTitleCollection->m_pSearchHighlight->EnableHighlight(wstate.fHighlight);
            phh->m_fLockSize = wstate.fLockSize;
            phh->m_fNoToolBarText = wstate.fNoToolBarText;
            phh->curNavType = wstate.curNavType;
        }
    }


    if (phh->idNotify) {
        HHN_NOTIFY hhcomp;
        hhcomp.hdr.hwndFrom = NULL;
        hhcomp.hdr.idFrom = phh->idNotify;
        hhcomp.hdr.code = HHN_WINDOW_CREATE;
        hhcomp.pszUrl = pType;
        if (IsWindow(hwndCaller))
        {
            SendMessage(hwndCaller, WM_NOTIFY, phh->idNotify, (LPARAM) &hhcomp);
        }
    }

    // If this window type hasn't been defined, do so now

    if (!phh->GetTypeName())
    {
        phh->SetTypeName(pType);
        phh->SetDisplayState(SW_SHOW);
    }

    if (!fRegistered) {
        RegisterOurWindow();
        fRegistered = TRUE;
    }

    phh->hwndCaller = hwndCaller;

    if (IsRectEmpty(phh->GetWinRect()))
   {
        // Create a default window relative to the display size
        RECT rcScreen ;
        GetScreenResolution(hwndCaller, &rcScreen);
        phh->SetTop(rcScreen.top + 10);
        phh->SetBottom(phh->GetTop() + 450);

        if (phh->IsExpandedNavPane() && !phh->iNavWidth)
            phh->iNavWidth = DEFAULT_NAV_WIDTH;

        // If navwidth specified, balance navigation pane width and HTML pane width
        phh->SetLeft(rcScreen.right - DEFAULT_WINDOW_WIDTH - 5 -
            (phh->IsProperty(HHWIN_PROP_TRI_PANE) ? phh->iNavWidth : 0));
        phh->SetRight(phh->GetLeft() + DEFAULT_WINDOW_WIDTH +
            (phh->IsProperty(HHWIN_PROP_TRI_PANE) ? phh->iNavWidth : 0));
    }

    if (!(phh->dwStyles & WS_CHILD))
        CheckWindowPosition(phh->GetWinRect(), TRUE); // Multimon support

    /*
     * The help author has the option of adding their own extended and
     * standard window styles. In addition, they can shut off all the
     * extended and normal styles that we would normally use, and just
     * use their own styles. In addition, they can specify all the
     * standard styles, but with no title bar.
     */

    phh->hwndHelp =
        CreateWindowEx(
            phh->GetExStyles() | (phh->IsProperty(HHWIN_PROP_NODEF_EXSTYLES) ?
                0 : WS_EX_APPWINDOW | ((phh->IsProperty(HHWIN_PROP_ONTOP) ?
                    WS_EX_TOPMOST : 0))),
            txtHtmlHelpWindowClass, NULL,
            phh->GetStyles() | WS_CLIPCHILDREN,
            phh->GetLeft(), phh->GetTop(), phh->GetWidth(), phh->GetHeight(),
            hwndCaller, NULL,

            // REVIEW: Should we use the caller's hinstance instead?

            _Module.GetModuleInstance(), NULL);

#ifdef _DEBUG
    ULONG err = GetLastError() ;
#endif

    if (!IsValidWindow(*phh)) {
        OOM();    // BUGBUG: bogus error message if hwndCaller is NULL
        return NULL;
    }

	// This next section of code turns of the Win98/Win2K WS_EX_LAYOUTRTL (mirroring)
	// style in the event it is turned on (inherited from the parent window).
	//

	// Get the extended window styles
	//
	long lExStyles = GetWindowLongA(phh->hwndHelp, GWL_EXSTYLE);
	
	// Check if mirroring is turned on
	//
	if(lExStyles & WS_EX_LAYOUTRTL) 
	{
		// turn off the mirroring bit
		//
		lExStyles ^= WS_EX_LAYOUTRTL;
		
		SetWindowLongA(phh->hwndHelp, GWL_EXSTYLE, lExStyles) ;

		// This is to update layout in the client area
		// InvalidateRect(hWnd, NULL, TRUE) ;
	}
	
    SendMessage(phh->hwndHelp, WM_SETFONT, (WPARAM)_Resource.GetAccessableUIFont(), 0);

    HMENU hmenu = GetSystemMenu(*phh, FALSE);
    AppendMenu(hmenu, MF_SEPARATOR, (UINT) -1, NULL);

    // before adding the jump runl to the system menu check if NoRun is set for this system Bug 7819
    if (NoRun() == FALSE)
        HxAppendMenu(hmenu, MF_STRING, ID_JUMP_URL, GetStringResource(IDS_JUMP_URL));
    if (IsHelpAuthor(hwndCaller)) {
#if 0  // bug 5449
        PCSTR psz = pGetDllStringResource(IDS_WINDOW_INFO);
        if (!IsEmptyString(psz))
            HxAppendMenu(hmenu, MF_ENABLED | MF_STRING, IDM_WINDOW_INFO,
                pGetDllStringResource(IDS_WINDOW_INFO));
#endif
        HxAppendMenu(hmenu, MF_ENABLED | MF_STRING, IDM_VERSION,
            pGetDllStringResource(IDS_HHCTRL_VERSION));
    }
   else
        HxAppendMenu(hmenu, MF_ENABLED | MF_STRING, IDM_VERSION, GetStringResource(IDS_ABOUT));

#ifdef _DEBUG
    HxAppendMenu(hmenu, MF_STRING, ID_VIEW_MEMORY, "Debug: memory usage...");
    HxAppendMenu(hmenu, MF_STRING, ID_DEBUG_BREAK, "Debug: call DebugBreak()");
#endif

    // Load MSDN's Menu.
    if (phh->IsProperty(HHWIN_PROP_MENU))
    {
        HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(HH_MENU)) ;
        ASSERT(hMenu) ;
        BOOL b = SetMenu(phh->hwndHelp, hMenu) ;
        ASSERT(b) ;
    }

    if (phh->IsProperty(HHWIN_PROP_TRI_PANE) ||
            phh->IsProperty(HHWIN_PROP_NAV_ONLY_WIN)) {
        if (phh->IsProperty(HHWIN_PROP_NOTB_TEXT))
            phh->m_fNoToolBarText = TRUE;

        if (!phh->IsProperty(HHWIN_PROP_NO_TOOLBAR))
        {
            TBBUTTON abtn[MAX_TB_BUTTONS];
            ClearMemory(abtn, sizeof(abtn));
            int cButtons = 0 ;
            cButtons = phh->CreateToolBar(abtn);

            if ( cButtons <= 0)
            {
                // No Toolbar buttons. Turn off this bit.
                phh->fsWinProperties &= ~HHWIN_PROP_NO_TOOLBAR ;
            }
            else
            {
                phh->hwndToolBar = CreateWindow("ToolbarWindow32", NULL, WS_CHILD | TBSTYLE_FLAT |
                                                TBSTYLE_TOOLTIPS | TBSTYLE_EX_DRAWDDARROWS | CCS_NORESIZE |
                                                CCS_NOPARENTALIGN | TBSTYLE_WRAPABLE |
                                                (phh->IsProperty(HHWIN_PROP_MENU) ? 0 : CCS_NODIVIDER) |
                                                (phh->m_fNoToolBarText ? 0 : TBSTYLE_WRAPABLE),
                                                 0, 0, 100, 30, *phh, (HMENU)ID_TOOLBAR,
                                                _Module.GetModuleInstance(), NULL);
                if (! phh->hwndToolBar )
                   return NULL;

                SendMessage(phh->hwndToolBar, TB_SETBITMAPSIZE, 0, (LPARAM)MAKELONG(TB_BMP_CX,TB_BMP_CY));
                SendMessage(phh->hwndToolBar, TB_SETBITMAPSIZE, 0, (LPARAM)MAKELONG(TB_BTN_CX,TB_BTN_CY));

                SendMessage(phh->hwndToolBar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), (LPARAM)0);
                SendMessage(phh->hwndToolBar, TB_ADDBUTTONS, cButtons, (LPARAM)abtn);
                SendMessage(phh->hwndToolBar, WM_SETFONT, (WPARAM)_Resource.GetAccessableUIFont(), 0);


                phh->m_hImageListGray = ImageList_LoadImage(_Module.GetResourceInstance(),
                                                            MAKEINTRESOURCE(IDB_TOOLBAR16G),
                                                            TB_BMP_CX, 0, RGB(255,0,255), IMAGE_BITMAP, 0);
                SendMessage(phh->hwndToolBar, TB_SETIMAGELIST, 0, (LPARAM)(HIMAGELIST) phh->m_hImageListGray);

                phh->m_hImageList = ImageList_LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOLBAR16),
                                                        TB_BMP_CX, 0, RGB(255,0,255), IMAGE_BITMAP, 0);
                SendMessage(phh->hwndToolBar, TB_SETHOTIMAGELIST, 0, (LPARAM)(HIMAGELIST) phh->m_hImageList);

                if (!phh->m_fNoToolBarText)
                {
                    for (int pos = 1; pos <= phh->m_ptblBtnStrings->CountStrings(); pos++)
                    {
                        char szBuf[256];
                        strcpy(szBuf, phh->m_ptblBtnStrings->GetPointer(pos));
                        szBuf[strlen(szBuf) + 1] = '\0';    // two terminating NULLs
                       // Under W2K, send wide string to control (support for MUI)
                       //
                       if(g_bWinNT5)
                       {
                          WCHAR wszBuf[256];
                          memset(wszBuf,0,sizeof(wszBuf));
                     
                          // get codepage of default UI
                          //
                          DWORD cp = CodePageFromLCID(MAKELCID(_Module.m_Language.GetUiLanguage(),SORT_DEFAULT));
                     
                          MultiByteToWideChar(cp , 0, szBuf, -1, wszBuf, sizeof(wszBuf) / 2);
                     
                          SendMessageW(phh->hwndToolBar, TB_ADDSTRINGW, 0, (LPARAM) wszBuf);
                       }
                       else
                          SendMessage(phh->hwndToolBar, TB_ADDSTRING, 0, (LPARAM) szBuf);
                    }

                    TCHAR szScratch[MAX_PATH];
                    LoadString(_Module.GetResourceInstance(), IDS_WEB_TB_TEXTROWS, szScratch, sizeof(szScratch));
                    int nRows = Atoi(szScratch);

                    SendMessage(phh->hwndToolBar, TB_SETMAXTEXTROWS, nRows, 0);

                    /*
                     * Since we changed the window after we created it, we need to
                     * force a recalculation which we do by changing the size of the
                     * window ever so slightly. This causes the toolbar to
                     * recalculate itself to be the exact size.
                     */
                    phh->WrapTB();
                }
            }
        }
        phh->CalcHtmlPaneRect();

        if (phh->IsProperty(HHWIN_PROP_NAV_ONLY_WIN)) {
            phh->CreateOrShowNavPane();
            ShowWindow(*phh, phh->GetShowState());
        }
        else
            phh->CreateOrShowHTMLPane();
    }

    if (IsValidWindow(*phh) ) {

        if (!phh->IsProperty(HHWIN_PROP_NAV_ONLY_WIN))
        {
            phh->m_pCIExpContainer = new CContainer;
            HRESULT hr;
            BOOL bInstallEventSink = (BOOL)strcmp(phh->pszType, txtPrintWindow+1);

            if (IsValidWindow(phh->hwndHTML)) {
                hr = phh->m_pCIExpContainer->Create(phh->hwndHTML, &phh->rcHTML, bInstallEventSink);
            }
            else {
                RECT rc;
                phh->GetClientRect(&rc);
                hr = phh->m_pCIExpContainer->Create(*phh, &rc, bInstallEventSink);
            }

            if (!SUCCEEDED(hr)) {
                DEBUG_ReportOleError(hr);
                DestroyWindow(*phh);
                return NULL;
            }
        }

        if (phh->IsExpandedNavPane() && phh->AnyValidNavPane()) {
            phh->fNotExpanded = TRUE;
            BOOL fSaveLoack = phh->m_fLockSize;
            phh->m_fLockSize = TRUE;
            phh->ToggleExpansion(false);
            phh->m_fLockSize = fSaveLoack;
        }

        /*
         * 30-Sep-1996  [ralphw] For some reason, specifying the caption
         * when the window is created, doesn't work. So, we use
         * SetWindowText to specify the caption.
         */

        // Set the window title (figure out which string is displayable)
		//
		// Rules:
		//
		// if (TitleLanguage = DefaultSystemLocale)
		//    Display title string from CHM
		//
		// else
		//
		// if(Satellite DLL language == DefaultSystemLocale)
		//    Display default title from Satellite DLL
		//
		// else
		//    Display "HTML Help"
		//

        LANGID langidTitle  = 0xFEFE;
		LANGID langidSystem = LANGIDFROMLCID(GetSystemDefaultLCID());
        LANGID langidUI     = _Module.m_Language.GetUiLanguage(); 
		
		if(phh->m_phmData && phh->m_phmData->GetInfo())
            langidTitle = LANGIDFROMLCID((phh->m_phmData->GetInfo())->GetLanguage());
			
        if(langidTitle == langidSystem || PRIMARYLANGID(langidTitle) == LANG_ENGLISH )
		{
            if (phh->GetCaption())
                SetWindowText(*phh, phh->GetCaption());
			else
                if (phh->m_phmData && phh->m_phmData->GetDefaultCaption())
                    SetWindowText(*phh, phh->m_phmData->GetDefaultCaption());
    		    else
                    SetWindowText(*phh, "HTML Help");
		}
		else
		{
		    if(langidUI == langidSystem)
			{
                CStr cszDefaultCaption = GetStringResource(IDS_HTML_HELP);
                SetWindowText(*phh, cszDefaultCaption);
			}
			else
                SetWindowText(*phh, "HTML Help");
		}
		
        ShowWindow(*phh, phh->GetShowState());
        if (IsValidWindow(phh->hwndToolBar))
            ShowWindow(phh->hwndToolBar, phh->GetShowState());
        if (IsValidWindow(phh->hwndHTML))
            ShowWindow(phh->hwndHTML, phh->GetShowState());
        if (phh->IsExpandedNavPane() && IsValidWindow(phh->hwndNavigation))
            ShowWindow(phh->hwndNavigation, phh->GetShowState());

        if ( phh->IsProperty(HHWIN_PROP_MENU) && phmData && phmData->m_sysflags.fDoSS )
        {
           HMENU hMenuMain, hMenuSub;

           hMenuMain = GetMenu(phh->hwndHelp);
           hMenuSub = GetSubMenu(hMenuMain, 2);
           AppendMenu(hMenuSub, MF_SEPARATOR, 0, NULL);
           HxAppendMenu(hMenuSub, MF_STRING, HHM_DEFINE_SUBSET, GetStringResource(IDS_DEFINE_SUBSET));
        }

#ifdef _DEBUG
        if (phh->IsProperty(HHWIN_PROP_TRI_PANE) && phh->IsProperty(HHWIN_PROP_TAB_HISTORY))
            phh->CreateHistoryTab();    // start tracking history immediately
#endif

#if 0
27-Sep-1996 [ralphw] Never returns the window...
        HWND hwndIE = (HWND) phh->m_pCIExpContainer->m_pWebBrowserApp->GetHwnd();
        if (IsValidWindow(hwndIE)) {
            char szClass[256];
            GetClassName(hwndIE, szClass, sizeof(szClass));
            DWORD dwStyle = GetWindowLong(hwndIE, GWL_STYLE);
            DWORD dwexStyle = GetWindowLong(hwndIE, GWL_EXSTYLE);
        }
#endif
    }

    return phh;
}

/***************************************************************************

    FUNCTION:   CheckWindowPosition

    PURPOSE:    Make certain the window doesn't cover any portion of the tray,
                and that it has a certain minimum size.

    PARAMETERS:
        prc
        fAllowShrinkage

    RETURNS:

    COMMENTS:

    MODIFICATION DATES:
        25-Feb-1996 [ralphw]

***************************************************************************/

// REVIEW: 25-Feb-1996  [ralphw] WinHelp did this, and set it to 200. I
// dropped it down to 16 -- enough to see the window, but without forcing
// it quite so large.

const int HELP_WIDTH_MINIMUM  = 16;
const int HELP_HEIGHT_MINIMUM = 16;

void CheckWindowPosition(RECT* prc, BOOL fAllowShrinkage)
{
    GetWorkArea(); // Multimon support

    // Make certain we don't go off the edge of the screen

    if (prc->left < g_rcWorkArea.left) {
        int diff = g_rcWorkArea.left - prc->left;
        prc->left = g_rcWorkArea.left;
        prc->right += diff;
    }
    if (prc->top < g_rcWorkArea.top) {
        int diff = g_rcWorkArea.top - prc->top;
        prc->top = g_rcWorkArea.top;
        prc->bottom += diff;
    }

    /*
     * If the right side of the window is off the work area, move the
     * window to the left. If we don't have enough room for the window when
     * moved all the way to the left, then shrink the window (won't work for
     * dialogs).
     */

    if (prc->right > g_rcWorkArea.right) {
        int diff = prc->right - g_rcWorkArea.right;
        if (diff < prc->left) {
            prc->left -= diff;
            prc->right = g_rcWorkArea.right;
        }
        else if (fAllowShrinkage) {
            diff -= prc->left;
            prc->left = g_rcWorkArea.left;
            prc->right -= diff;
        }
        else {// Can't shrink, so shove to the left side
            prc->left = g_rcWorkArea.left;
        }
    }

    // Same question about the bottom of the window being off the work area

    if (prc->bottom > g_rcWorkArea.bottom) {
        int diff = prc->bottom > g_rcWorkArea.bottom;
        if (diff < prc->top) {
            prc->top -= diff;
            prc->bottom = g_rcWorkArea.bottom;
        }
        else if (fAllowShrinkage) {
            diff -= prc->top;
            prc->top = g_rcWorkArea.top;
            prc->bottom -= diff;
        }
        else // Can't shrink, so shove to the top
            prc->top = g_rcWorkArea.top;
    }

    // Force minimum window size

    if (RECT_WIDTH(prc) < HELP_WIDTH_MINIMUM) {
        prc->right = prc->left + HELP_WIDTH_MINIMUM;

        // Width is now correct, but we could be off the work area. Start over

        CheckWindowPosition(prc, fAllowShrinkage);
    }
    if (RECT_HEIGHT(prc) < HELP_HEIGHT_MINIMUM) {
        prc->bottom = prc->top + HELP_HEIGHT_MINIMUM;

        // Height is now correct, but we could be off the work area. Start over

        CheckWindowPosition(prc, fAllowShrinkage);
    }
}

void GetScreenResolution(HWND hWnd, RECT* prc /*out*/)
{
    ASSERT(prc) ;
   if (prc)
   {
      if (IsWindow(hWnd) )
      {
         // Use the hWnd to get the monitor.
         GetMonitorRect(hWnd, prc, TRUE /*Get Work Area*/) ;
      }
      else
      {
         // hWnd isn't valid, use default monitor.
         POINT pt;
         pt.x=pt.y=0;
         multiMonitorRectFromPoint(pt, prc, TRUE) ;
      }
   }
}

void GetWorkArea()
{
   // Get the size of the entire virtual screen.
   if (!g_cxScreen)
   {
      g_cxScreen = GetSystemMetrics(SM_CXVIRTUALSCREEN) ;
      g_cyScreen = GetSystemMetrics(SM_CYVIRTUALSCREEN) ;
   }

   // The tray must be handled externally.

   if (IsRectEmpty(&g_rcWorkArea))
   {
      g_rcWorkArea.left = GetSystemMetrics(SM_XVIRTUALSCREEN) ;
      g_rcWorkArea.right   = g_rcWorkArea.left  + g_cxScreen ;
      g_rcWorkArea.top  = GetSystemMetrics(SM_YVIRTUALSCREEN) ;
      g_rcWorkArea.bottom = g_rcWorkArea.top + g_cyScreen ;
   }
}

void RegisterOurWindow()
{
    WNDCLASS wc;

    ZeroMemory(&wc, sizeof(WNDCLASS));  // clear all members

    wc.lpfnWndProc = HelpWndProc;
    wc.hInstance = _Module.GetModuleInstance();
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.lpszClassName = txtHtmlHelpWindowClass;
    wc.hIcon = LoadIcon(_Module.GetResourceInstance(), "Icon!HTMLHelp");
    wc.hbrBackground = (HBRUSH) COLOR_WINDOW;

    VERIFY(RegisterClass(&wc));

   ASSERT(sizeof(WNDCLASSA)==sizeof(WNDCLASSW)); //lazy hack - just use the wcA
    wc.lpfnWndProc = ChildWndProc;
    wc.lpszClassName = (LPCSTR)L"HH Child"; //txtHtmlHelpChildWindowClass;
    wc.hbrBackground = (HBRUSH) COLOR_BTNSHADOW;

   if (NULL == RegisterClassW((CONST WNDCLASSW *)&wc))
   {
      if (ERROR_CALL_NOT_IMPLEMENTED == GetLastError())
      {
         wc.lpszClassName = txtHtmlHelpChildWindowClass;
         VERIFY(RegisterClass(&wc));
      }
   }

    // Register the window class for the sizebar.
    CSizeBar::RegisterWindowClass() ;

    // Register the window class for the custom nav pane frame window.
    CCustomNavPane::RegisterWindowClass() ;
}

CHHWinType* FindHHWindowIndex(HWND hwnd)
{
    static int iLastWindow = 0;
    static HWND hwndLastWindow = NULL;

    if (pahwnd && hwndLastWindow == hwnd && IsValidWindow(hwnd))
        return pahwnd[iLastWindow];

    hwndLastWindow = hwnd;
    while(IsValidWindow(hwnd)) {
        char szClassName[50];
        GetClassName(hwnd, szClassName, sizeof(szClassName));
        if (strcmp(szClassName, txtHtmlHelpWindowClass) == 0)
            break;
        hwnd = GetParent(hwnd);
    }

    if (pahwnd && pahwnd[iLastWindow] && pahwnd[iLastWindow]->hwndHelp == hwnd)
        return pahwnd[iLastWindow];

    for (iLastWindow = 0; iLastWindow < g_cWindowSlots; iLastWindow++) {
        if (pahwnd && pahwnd[iLastWindow] && pahwnd[iLastWindow]->hwndHelp == hwnd)
            return pahwnd[iLastWindow];
    }
    iLastWindow = 0;
    hwndLastWindow = NULL;
    return NULL;
}

void doHHWindowJump(PCSTR pszUrl, HWND hwndChild)
{
    CHHWinType* phh = FindHHWindowIndex(hwndChild);
    if( !phh )
      return;

    if (phh->IsProperty(HHWIN_PROP_NAV_ONLY_WIN)) {
        CStr cszUrl(pszUrl);
        cszUrl += txtNavWind;
        OnDisplayTopic(*phh, cszUrl, 0);
        return;
    }
    ASSERT(phh->m_pCIExpContainer);
    if (phh && phh->m_pCIExpContainer)
   {
        phh->m_pCIExpContainer->m_pWebBrowserApp->Navigate(pszUrl, NULL, NULL, NULL, NULL);
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  GetMonitorRect
//
//  gets the "screen" or work area of the monitor that the passed
//  window is on.  this is used for apps that want to clip or
//  center windows.
//
//  the most common problem apps have with multimonitor systems is
//  when they use GetSystemMetrics(SM_C?SCREEN) to center or clip a
//  window to keep it on screen.  If you do this on a multimonitor
//  system the window we be restricted to the primary monitor.
//
//  this is a example of how you used the new Win32 multimonitor APIs
//  to do the same thing.
//
void GetMonitorRect(HWND hwnd, LPRECT prc, BOOL fWork)
{
   // Preconditions
   ASSERT(hwnd != NULL) ;
   ASSERT(::IsWindow(hwnd)) ;

    // Core
   MONITORINFO mi;

    mi.cbSize = sizeof(mi);
    GetMonitorInfo(MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST), &mi);

    if (fWork)
        *prc = mi.rcWork;
    else
        *prc = mi.rcMonitor;
}

///////////////////////////////////////////////////////////////////////////////
//
// Get the rectangle of the monitor containing the rectangle.
//
void multiMonitorRectFromRect(/*in*/  RECT rcScreenCoords,
                       /*out*/ LPRECT prc,
                       /*in*/  BOOL fWork)
{
   //Preconditions
   ASSERT(prc != NULL) ;
// ASSERT(AfxIsValidAddress(prc, sizeof(RECT))) ;

   // Get monitor which contains this rectangle.
   HMONITOR hMonitor = ::MonitorFromRect(&rcScreenCoords, MONITOR_DEFAULTTOPRIMARY) ;
   ASSERT(hMonitor != NULL) ;

   // Prepare to get the information for this monitor.
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);

   // Get the rect of this monitor.
    VERIFY(GetMonitorInfo(hMonitor, &mi));

   // Return the rectangle.
    if (fWork)
        *prc = mi.rcWork;
    else
        *prc = mi.rcMonitor;
}

///////////////////////////////////////////////////////////////////////////////
//
// Get the rectangle of the monitor containing a point.
//
void multiMonitorRectFromPoint(/*in*/  POINT ptScreenCoords,
                        /*out*/ LPRECT prc,
                        /*in*/  BOOL fWork)
{
   // precondition
   ASSERT(prc != NULL) ;
// ASSERT(AfxIsValidAddress(prc, sizeof(RECT))) ;

   // Get the monitor which contains the point.
   HMONITOR hMonitor = MonitorFromPoint(ptScreenCoords, MONITOR_DEFAULTTOPRIMARY) ;
   ASSERT(hMonitor != NULL) ;

   // Prepare to get the information for this monitor.
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);

   // Get the rect of this monitor.
    VERIFY(GetMonitorInfo(hMonitor, &mi));

   // Return the rectangle.
    if (fWork)
        *prc = mi.rcWork;
    else
        *prc = mi.rcMonitor;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\vlist.cpp ===
#include "header.h"
#include "vlist.h"
#include "cpaldc.h"
#include "hhctrl.h"
#include <winuser.h>
#include <commctrl.h>

CVirtualListCtrl::CVirtualListCtrl(LCID lcid)
{
    m_cItems = 0;
    m_iTopItem = 0;
    m_iSelItem = 0;
    m_cyItem = 0;
    m_cItemsPerPage = 0;
    m_fFocus = 0;
    m_hFont = 0;
    m_hWndParent = m_hWnd = 0;
    m_langid = PRIMARYLANGID(LANGIDFROMLCID(GetUserDefaultLCID()));
    m_lcid = lcid;
    m_fBiDi = g_fBiDi;
    m_RTL_Style = g_RTL_Style;

    //
    // Maybe this goo below can go away ?
    //
    m_cyBackBmp = 0;
    m_cxBackBmp = 0;
    m_hpalBackGround = 0;
    m_hbrBackGround = 0;
    m_hbmpBackGround = 0;
    m_clrForeground = (COLORREF) -1;
    m_clrBackground = (COLORREF) -1;
}

CVirtualListCtrl::~CVirtualListCtrl()
{
   if ( IsValidWindow(m_hWnd) )
      DestroyWindow(m_hWnd);

   WNDCLASSEX wci;

   if ( GetClassInfoEx(_Module.GetModuleInstance(), "hh_kwd_vlist", &wci) )
      UnregisterClass("hh_kwd_vlist", _Module.GetModuleInstance());
}

void CVirtualListCtrl::RedrawCurrentItem()
{
    RECT rc;

    GetItemRect(m_iSelItem, &rc);
    InvalidateRect(m_hWnd, &rc, TRUE);
}

BOOL CVirtualListCtrl::SetItemCount(int cItems)
{
    int scroll;

    if (cItems < 0)
        return FALSE;

    scroll = cItems - 1;
    if (scroll < 0)
        scroll = 0;

    m_cItems = cItems;
    m_iSelItem = m_iTopItem = 0;
    SetScrollRange(m_hWnd, SB_VERT, 0, scroll, TRUE);
    InvalidateRect(m_hWnd, NULL, FALSE);           // for now
    return TRUE;
}

BOOL CVirtualListCtrl::SetSelection(int iSel, BOOL bNotify /* default = TRUE */)
{
    if (iSel < 0 || iSel >= m_cItems)
        return FALSE;

    if (m_iSelItem != iSel)
    {
        RedrawCurrentItem();
        m_iSelItem = iSel;
        RedrawCurrentItem();
        EnsureVisible(iSel);
        if ( bNotify )
           ItemSelected(iSel);
    }
    return TRUE;
}

int CVirtualListCtrl::GetSelection()
{
    return m_iSelItem;
}

int CVirtualListCtrl::GetTopIndex()
{
    return m_iTopItem;
}

BOOL CVirtualListCtrl::SetTopIndex(int iItem)
{
    if (m_cItemsPerPage >= m_cItems || iItem < 0)
        iItem = 0;
    else if (iItem > m_cItems - m_cItemsPerPage)
        iItem = m_cItems - m_cItemsPerPage;

    if (iItem != m_iTopItem)
    {
        m_iTopItem = iItem;
        SetScrollPos(m_hWnd, SB_VERT, iItem, TRUE);
        InvalidateRect(m_hWnd, NULL, FALSE);           // for now
    }
    return TRUE;
}

BOOL CVirtualListCtrl::EnsureVisible(int iItem)
{
    if (iItem < m_iTopItem)
        SetTopIndex(iItem);
    else if (iItem >= m_iTopItem + m_cItemsPerPage)
        SetTopIndex(iItem - m_cItemsPerPage + 1);
    return TRUE;
}

BOOL CVirtualListCtrl::GetItemRect(int iItem, RECT* prc)
{
    RECT rcClient;
    int y;

    GetClientRect(m_hWnd, &rcClient);
    y = (iItem - m_iTopItem)*m_cyItem;
    prc->left = rcClient.left;
    prc->top = y;
    prc->right = rcClient.right;
    prc->bottom = y+m_cyItem;
    return TRUE;
}

const int LEVEL_PAD = 12;

LRESULT CVirtualListCtrl::DrawItem(HDC hDC, int iItem, RECT* prc, BOOL fSel, BOOL fFocus)
{
    WCHAR szText[512];
    COLORREF clrFore;
    COLORREF clrDisabled;
    COLORREF clrBack;
    int iLevel;
    int pad = 0;

    if (fSel)
    {
        clrFore = GetSysColor(COLOR_HIGHLIGHTTEXT);
        clrDisabled = GetSysColor(COLOR_GRAYTEXT);
        clrBack = GetSysColor(COLOR_HIGHLIGHT);
    }
    else
    {
        clrFore = (m_clrForeground == -1)?GetSysColor(COLOR_WINDOWTEXT):m_clrForeground;
        clrDisabled = GetSysColor(COLOR_GRAYTEXT);
        clrBack = (m_clrBackground == -1)?GetSysColor(COLOR_WINDOW):m_clrBackground;
    }

    szText[0] = 0x00;
    DWORD dwFlags = 0;
    if (iItem >= 0 && iItem < m_cItems)
        GetItemText(iItem,&iLevel,&dwFlags,szText,(sizeof(szText)/2));
    BOOL bDisabled = (dwFlags & 0x1);
    if( bDisabled )
      SetTextColor(hDC,clrDisabled);
    else
      SetTextColor(hDC,clrFore);
    SetBkColor(hDC,clrBack);

    if ( iLevel > 1 )
       pad = ((iLevel - 1) * LEVEL_PAD);
    else
       pad = 2;

#if 0
    if (m_fBiDi)
    {
       /*
        * Using ExtTextOut with ETO_RTLREADING fails to clear the entire
        * line. So, we clear the background with FillRect first and then
        * display the text.
        */
       SIZE size;
       GetTextExtentPointW(hDC, szText, wcslen(szText), &size);
       int pos = prc->right - 2 - size.cx - pad;
       if (pos < 2)
           pos = 2;

       HBRUSH hbrush = CreateSolidBrush(fSel ? GetSysColor(COLOR_HIGHLIGHT) : GetSysColor(COLOR_WINDOW));
       FillRect(hDC, prc, hbrush);
       DeleteObject(hbrush);
       IntlExtTextOutW(hDC, prc->left + pos, prc->top, ETO_OPAQUE | ETO_RTLREADING, prc, szText, wcslen(szText), 0);
    }
    else
#endif
    SIZE size;
    GetTextExtentPointW(hDC, szText, wcslen(szText), &size);
    int pos = prc->right - 2 - size.cx - pad;
    //if (pos < 2)
    //    pos = 2;

    if (m_fBiDi)
       IntlExtTextOutW(hDC, pos, prc->top, ETO_OPAQUE|ETO_CLIPPED|ETO_RTLREADING, prc, szText, wcslen(szText), 0);
    else
       IntlExtTextOutW(hDC, prc->left + pad, prc->top, ETO_OPAQUE | ETO_CLIPPED, prc, szText, wcslen(szText), 0);

    if (fFocus && fSel)
        DrawFocusRect(hDC, prc);

    return 0;
}

LRESULT CVirtualListCtrl::Notify(int not, NMHDR * pNMHdr)
{
    NMHDR nmhdr;

    if (!pNMHdr)
        pNMHdr = &nmhdr;

    pNMHdr->hwndFrom = m_hWnd;
    pNMHdr->idFrom = GetDlgCtrlID(m_hWnd);
    pNMHdr->code = not;

    return SendMessage(m_hWndParent, WM_NOTIFY, pNMHdr->idFrom, (LPARAM)pNMHdr);
}

LRESULT CVirtualListCtrl::ItemSelected(int i)
{
    return Notify(VLN_SELECT);
}

LRESULT CVirtualListCtrl::ItemDoubleClicked(int i)
{
    return Notify(NM_DBLCLK);
}

LRESULT CVirtualListCtrl::GetItemText(int iItem, int* piLevel, DWORD* pdwFlags, WCHAR* lpwsz, int cchMax)
{
    VLC_ITEM it;

    *lpwsz = 0;

    it.iItem = iItem;
    it.lpwsz = lpwsz;
    it.cchMax = cchMax;

    Notify(VLN_GETITEM,(NMHDR*)&it);
    *piLevel = it.iLevel;
    *pdwFlags = it.dwFlags;
    return S_OK;
}

LRESULT CVirtualListCtrl::StaticWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CVirtualListCtrl* pThis;
    PAINTSTRUCT ps;
    HDC hDC;
    RECT rc;
    SIZE cs;
    int i;

    pThis = (CVirtualListCtrl*)GetWindowLongPtr(hWnd,0);
    switch (msg)
    {
        case WM_CREATE:
            pThis = (CVirtualListCtrl*)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd,0,(LONG_PTR)pThis);
            pThis->m_hWnd = hWnd;
            break;

        case WM_SETFONT:
            pThis->m_hFont = (HFONT)wParam;
            // FALL THRU to WM_SIZE

        case WM_SIZE:
            GetClientRect(hWnd, &rc);
            hDC = GetDC(hWnd);
            SaveDC(hDC);
            if (pThis->m_hFont)
                SelectObject(hDC, pThis->m_hFont);
            GetTextExtentPoint(hDC, "CC", 2, &cs);
            pThis->m_cyItem = cs.cy;
            if (pThis->m_cyItem)
                pThis->m_cItemsPerPage = ((rc.bottom - rc.top) / pThis->m_cyItem);
            else
                pThis->m_cItemsPerPage = 0;
            {
               SCROLLINFO si;
               si.cbSize = sizeof(SCROLLINFO);
               si.fMask = SIF_PAGE;
               si.nPage = pThis->m_cItemsPerPage;
               SetScrollInfo(hWnd, SB_VERT, &si, TRUE );
            }
            RestoreDC(hDC, -1);
            ReleaseDC(hWnd, hDC);
            break;

        case WM_PAINT:
            hDC = BeginPaint(hWnd, &ps);
            SaveDC(hDC);
            if (pThis->m_hFont)
                SelectObject(hDC, pThis->m_hFont);

            for (i = 0; i <= pThis->m_cItemsPerPage; i++)
            {
                pThis->GetItemRect(pThis->m_iTopItem + i, &rc);
                pThis->DrawItem(hDC, pThis->m_iTopItem + i, &rc, pThis->m_iTopItem + i == pThis->m_iSelItem, pThis->m_fFocus);
            }
            RestoreDC(hDC, -1);
            EndPaint(hWnd, &ps);
            break;

        case WM_SETFOCUS:
            pThis->m_fFocus = 1;
            pThis->RedrawCurrentItem();
            pThis->Notify(NM_SETFOCUS);
            break;

        case WM_KILLFOCUS:
            pThis->m_fFocus = 0;
            pThis->RedrawCurrentItem();
            pThis->Notify(NM_KILLFOCUS);
            break;

        case WM_KEYDOWN:
            switch (wParam)
            {
                case VK_UP:
                    i = pThis->m_iSelItem - 1;
                    goto go_there;

                case VK_DOWN:
                    i = pThis->m_iSelItem + 1;
                    goto go_there;

                case VK_PRIOR:
                    i = pThis->m_iSelItem - pThis->m_cItemsPerPage;
                    goto go_there;

                case VK_NEXT:
                    i = pThis->m_iSelItem + pThis->m_cItemsPerPage;
go_there:
                    if (i < 0)
                        i = 0;
                    else if (i >= pThis->m_cItems)
                        i = pThis->m_cItems - 1;
                    pThis->SetSelection(i);
                    break;

                case VK_HOME:
                    pThis->SetSelection(0);
                    break;

                case VK_END:
                    pThis->SetSelection(pThis->m_cItems - 1);
                    break;

                case VK_RETURN:
                    pThis->Notify(NM_RETURN);
                    break;

                case VK_TAB:
                    pThis->Notify(VLN_TAB);
                    break;
            }
            break;

        case WM_MOUSEWHEEL:
          if (! SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &i, 0) )
             i = 3;
          if( (short) HIWORD(wParam) > 0 )
            pThis->SetTopIndex(pThis->m_iTopItem - i);
          else
            pThis->SetTopIndex(pThis->m_iTopItem + i);
          break;

        case WM_VSCROLL:
            switch (LOWORD(wParam))
            {
                case SB_LINEUP:
                    pThis->SetTopIndex(pThis->m_iTopItem - 1);
                    break;

                case SB_LINEDOWN:
                    pThis->SetTopIndex(pThis->m_iTopItem + 1);
                    break;

                case SB_PAGEUP:
                    pThis->SetTopIndex(pThis->m_iTopItem - pThis->m_cItemsPerPage);
                    break;

                case SB_PAGEDOWN:
                    pThis->SetTopIndex(pThis->m_iTopItem + pThis->m_cItemsPerPage);
                    break;

                case SB_BOTTOM:
                    pThis->SetTopIndex(pThis->m_cItems);
                    break;

                case SB_TOP:
                    pThis->SetTopIndex(0);
                    break;

                case SB_THUMBPOSITION:
                case SB_THUMBTRACK:
                    if( pThis->m_cItems > 65535 )
                    {
                       SCROLLINFO si;
                       si.cbSize = sizeof(SCROLLINFO);
                       si.fMask = SIF_TRACKPOS;
                       GetScrollInfo(hWnd, SB_VERT, &si);
                       pThis->SetTopIndex( si.nTrackPos );
                    }
                    else
                       pThis->SetTopIndex( HIWORD( wParam ) );
                    break;
            }
            break;

        case WM_LBUTTONDOWN:
            SetFocus(hWnd);
            if (pThis->m_cyItem)
                pThis->SetSelection(pThis->m_iTopItem + (HIWORD(lParam) / pThis->m_cyItem));
            pThis->Notify(NM_CLICK);
            break;

        case WM_LBUTTONDBLCLK:
            SetFocus(hWnd);
            if (pThis->m_cyItem)
                if (pThis->m_iSelItem == (pThis->m_iTopItem + (HIWORD(lParam) / pThis->m_cyItem)))
                    pThis->ItemDoubleClicked(pThis->m_iSelItem);
            break;

        case WM_RBUTTONDOWN:
            SetFocus(hWnd);
            pThis->Notify(NM_RCLICK);
            break;

        case WM_RBUTTONDBLCLK:
            SetFocus(hWnd);
            pThis->Notify(NM_RDBLCLK);
            break;

        case WM_GETDLGCODE:
            return DLGC_WANTARROWS;
            break;

        case WM_ERASEBKGND:
            if ( pThis->m_hbmpBackGround )
            {
                RECT rc;
                HDC hdc = (HDC) wParam;
                GetClientRect(hWnd, &rc);
                CPalDC dc(pThis->m_hbmpBackGround);
                HPALETTE hpalTmp = NULL;
                if (pThis->m_hpalBackGround) {
                    hpalTmp = SelectPalette(hdc, pThis->m_hpalBackGround, FALSE);
                    RealizePalette(hdc);
                }
                for (int left = 0; left <= rc.right; left += pThis->m_cxBackBmp) {
                    for (int top = 0; top <= rc.bottom; top += pThis->m_cyBackBmp) {
                        BitBlt(hdc, left, top, min(pThis->m_cxBackBmp, rc.right - left),
                               min(pThis->m_cyBackBmp, rc.bottom - top), dc, 0, 0, SRCCOPY);
                    }
                }
                if (hpalTmp)
                    SelectPalette(hdc, hpalTmp, FALSE);
                return TRUE;
            }
            else if ( pThis->m_hbrBackGround )
            {
                RECT rc;
                GetClipBox((HDC) wParam, &rc);
                FillRect((HDC) wParam, &rc, pThis->m_hbrBackGround);
                return TRUE;
            }
            else
               return DefWindowProc(hWnd, msg, wParam, lParam);

        default:
            return DefWindowProc(hWnd, msg, wParam, lParam);
    }
    return 0;
}

//
// Something Ralphs code must use. Maybe this can go away ?
// 09-Nov-1997  [ralphw] Nope, it can't go away.
//
void CVirtualListCtrl::PaintParamsSetup(COLORREF clrBackground, COLORREF clrForeground, LPCSTR pszBackBitmap)
{
    if (clrBackground != -1 && clrForeground != -1) {
        HDC hdc = GetWindowDC(m_hWnd);
        // If the colors are the same, then ignore them both
        if (GetHighContrastFlag() || GetNearestColor(hdc, clrBackground) == GetNearestColor(hdc, clrForeground))
            m_clrBackground = m_clrForeground = (COLORREF) -1;
        ReleaseDC(m_hWnd, hdc);
    }

    if (m_clrBackground != -1)
        m_hbrBackGround = CreateSolidBrush(m_clrBackground);
    if ( pszBackBitmap ) {
        char szBitmap[MAX_PATH];
        if (ConvertToCacheFile(pszBackBitmap, szBitmap) &&
                LoadGif(szBitmap, &m_hbmpBackGround, &m_hpalBackGround, NULL)) {
            BITMAP bmp;
            GetObject(m_hbmpBackGround, sizeof(BITMAP), &bmp);
            m_cxBackBmp = bmp.bmWidth;
            m_cyBackBmp = bmp.bmHeight;
        }
    }
}

HWND CVirtualListCtrl::CreateVlistbox(HWND hWndParent, RECT* prc)
{
    WNDCLASS wc;
    WNDCLASSEX wci;

    if (! GetClassInfoEx(_Module.GetModuleInstance(), "hh_kwd_vlist", &wci) )
    {
       wc.style = CS_DBLCLKS; // | CS_HREDRAW | CS_VREDRAW;
       wc.lpfnWndProc = StaticWindowProc;
       wc.hIcon = NULL;
       wc.cbClsExtra = 0;
       wc.cbWndExtra = sizeof(CVirtualListCtrl*);
       wc.hInstance = _Module.GetModuleInstance();
       wc.hCursor = LoadCursor(NULL, IDC_ARROW);
       wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
       wc.lpszMenuName = NULL;
       wc.lpszClassName = "hh_kwd_vlist";

       if (! RegisterClass(&wc) )
          return FALSE;
    }
    CreateWindowEx(WS_EX_CLIENTEDGE | g_RTL_Style | (m_fBiDi ? WS_EX_LEFTSCROLLBAR : 0),
            "hh_kwd_vlist", NULL,
            WS_CHILD|WS_BORDER|WS_VISIBLE|WS_GROUP|WS_TABSTOP|WS_VSCROLL,
            prc->left, prc->top, (prc->right - prc->left), (prc->bottom - prc->top), hWndParent,
            (HMENU) IDC_KWD_VLIST, _Module.GetModuleInstance(), this);

    m_hWndParent = hWndParent;
    return m_hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\iterror.h ===
#ifndef __ITERROR_H__
#define __ITERROR_H__


#ifdef __cplusplus
extern "C" {
#endif


// define the old error types in terms of HRESULTs
typedef HRESULT* PHRESULT;

#define ERR     HRESULT
#define ERRB    HRESULT
#define LPERRB  HRESULT*
#define RC      HRESULT


#define	SetErrCode(a,b)	SetErr(a, b)
#define	SetErrReturn(a)	SetErr(0, a)


HRESULT PASCAL SetErr (HRESULT* phr, HRESULT ErrCode);


/*************************************************************************
 *
 *                  CALLBACK FUNCTIONS PROTOTYPES
 *
 * User callback functions are needed in case:
 *  - The application needs to support interrupt
 *  - The application needs to display error messages its way
 *  - The application needs to know the status of the process
 *************************************************************************/
typedef ERR (FAR PASCAL *ERR_FUNC) (DWORD dwFlag, LPVOID pUserData, LPVOID pMessage);

/*************************************************************************
 * Call back structure
 *  Contains information about all callback functions
 *************************************************************************/ 

#define ERRFLAG_INTERRUPT      0x01 // The processes should be cancelled
#define ERRFLAG_STATUS         0x02 // High-level status messages
#define ERRFLAG_STATUS_VERBOSE 0x04 // Low-level status messages
#define ERRFLAG_ERROR          0x08 // Warning & Error messages
#define ERRFLAG_STRING         0x10 // Debug string messages

typedef struct fCallBack_msg
{
    ERR_FUNC MessageFunc;
    LPVOID pUserData;
    DWORD  dwFlags;
} FCALLBACK_MSG, FAR * PFCALLBACK_MSG;


// ***********************************************************************
// This structure should be filled out and passed back in the case of
// an error.
// ***********************************************************************
typedef WORD HCE;   // User errors
typedef WORD EP;    // Error Phase
typedef struct
{
    LPCSTR  pchFile;
    LONG    iLine;
    DWORD   iTopic;
    DWORD   fCustom; // If true then var1 is LPCSTR to custom error message
    DWORD   var1, var2, var3;   // Error parameters

    EP      ep;                 // Error Phase
    HCE     errCode;
} ERRC, FAR *PERRC;

#define CALLBACKKEY 0x524A4A44

typedef struct
{
    DWORD dwReserved;
    DWORD dwKey;
    FCALLBACK_MSG Callback;
} CUSTOMSTRUCT, FAR *PCUSTOMSTRUCT;

// Error Phase values
#define epNoFile       0
#define epLine         1
#define epTopic        2
#define epOffset       3
#define epMVBtopic	   4
#define epAliasLine	   5
#define epByteOffset   6


//
// The InfoTech error codes
//
#define E_NOTEXIST          _HRESULT_TYPEDEF_(0x80001000L)
#define E_DUPLICATE         _HRESULT_TYPEDEF_(0x80001001L)
#define E_BADVERSION        _HRESULT_TYPEDEF_(0x80001002L)
#define E_BADFILE           _HRESULT_TYPEDEF_(0x80001003L)
#define E_BADFORMAT         _HRESULT_TYPEDEF_(0x80001004L)
#define E_NOPERMISSION      _HRESULT_TYPEDEF_(0x80001005L)
#define E_ASSERT            _HRESULT_TYPEDEF_(0x80001006L)
#define E_INTERRUPT         _HRESULT_TYPEDEF_(0x80001007L)
#define E_NOTSUPPORTED      _HRESULT_TYPEDEF_(0x80001008L)
#define E_OUTOFRANGE        _HRESULT_TYPEDEF_(0x80001009L)                  
#define E_GROUPIDTOOBIG     _HRESULT_TYPEDEF_(0x8000100AL)
#define E_TOOMANYTITLES     _HRESULT_TYPEDEF_(0x8000100BL)
#define E_NOMERGEDDATA      _HRESULT_TYPEDEF_(0x8000100CL)
#define E_NOTFOUND          _HRESULT_TYPEDEF_(0x8000100DL)
#define E_CANTFINDDLL       _HRESULT_TYPEDEF_(0x8000100EL)
#define E_NOHANDLE          _HRESULT_TYPEDEF_(0x8000100FL) 
#define E_GETLASTERROR      _HRESULT_TYPEDEF_(0x80001010L)
#define E_BADPARAM			_HRESULT_TYPEDEF_(0x80001011L)
#define E_INVALIDSTATE		_HRESULT_TYPEDEF_(0x80001012L)
#define E_NOTOPEN           _HRESULT_TYPEDEF_(0x80001013L)
#define E_ALREADYOPEN       _HRESULT_TYPEDEF_(0x80001013L)
#define E_UNKNOWN_TRANSPORT _HRESULT_TYPEDEF_(0x80001016L)
#define E_UNSUPPORTED_TRANSPORT _HRESULT_TYPEDEF_(0x80001017L)
#define E_BADFILTERSIZE     _HRESULT_TYPEDEF_(0x80001018L)
#define E_TOOMANYOBJECTS    _HRESULT_TYPEDEF_(0x80001019L)
#define E_NAMETOOLONG       _HRESULT_TYPEDEF_(0x80001020L)

#define E_FILECREATE        _HRESULT_TYPEDEF_(0x80001030L) 
#define E_FILECLOSE         _HRESULT_TYPEDEF_(0x80001031L)
#define E_FILEREAD          _HRESULT_TYPEDEF_(0x80001032L)
#define E_FILESEEK          _HRESULT_TYPEDEF_(0x80001033L)
#define E_FILEWRITE         _HRESULT_TYPEDEF_(0x80001034L)
#define E_FILEDELETE        _HRESULT_TYPEDEF_(0x80001035L)
#define E_FILEINVALID       _HRESULT_TYPEDEF_(0x80001036L)
#define E_FILENOTFOUND      _HRESULT_TYPEDEF_(0x80001037L)
#define E_DISKFULL          _HRESULT_TYPEDEF_(0x80001038L)

#define E_TOOMANYTOPICS     _HRESULT_TYPEDEF_(0x80001050L)
#define E_TOOMANYDUPS       _HRESULT_TYPEDEF_(0x80001051L)
#define E_TREETOOBIG        _HRESULT_TYPEDEF_(0x80001052L)
#define E_BADBREAKER        _HRESULT_TYPEDEF_(0x80001053L)
#define E_BADVALUE          _HRESULT_TYPEDEF_(0x80001054L)
#define E_ALL_WILD          _HRESULT_TYPEDEF_(0x80001055L)
#define E_TOODEEP           _HRESULT_TYPEDEF_(0x80001056L)
#define E_EXPECTEDTERM      _HRESULT_TYPEDEF_(0x80001057L)
#define E_MISSLPAREN        _HRESULT_TYPEDEF_(0x80001058L)
#define E_MISSRPAREN        _HRESULT_TYPEDEF_(0x80001059L)
#define E_MISSQUOTE         _HRESULT_TYPEDEF_(0x8000105AL)
#define E_NULLQUERY         _HRESULT_TYPEDEF_(0x8000105BL)
#define E_STOPWORD          _HRESULT_TYPEDEF_(0x8000105CL)
#define E_BADRANGEOP        _HRESULT_TYPEDEF_(0x8000105DL)
#define E_UNMATCHEDTYPE     _HRESULT_TYPEDEF_(0x8000105EL)
#define E_WORDTOOLONG       _HRESULT_TYPEDEF_(0x8000105FL)
#define E_BADINDEXFLAGS     _HRESULT_TYPEDEF_(0x80001060L)
#define E_WILD_IN_DTYPE		_HRESULT_TYPEDEF_(0x80001061L)   
#define E_NOSTEMMER			_HRESULT_TYPEDEF_(0x80001062L)

// Property list and result set errors
#define E_MISSINGPROP		_HRESULT_TYPEDEF_(0x80001080L)
#define E_PROPLISTNOTEMPTY  _HRESULT_TYPEDEF_(0x80001081L)
#define E_PROPLISTEMPTY     _HRESULT_TYPEDEF_(0x80001082L)
#define E_ALREADYINIT       _HRESULT_TYPEDEF_(0x80001083L)
#define E_NOTINIT           _HRESULT_TYPEDEF_(0x80001084L)
#define E_RESULTSETEMPTY	_HRESULT_TYPEDEF_(0x80001085L)
#define E_TOOMANYCOLUMNS	_HRESULT_TYPEDEF_(0x80001086L)
#define E_NOKEYPROP			_HRESULT_TYPEDEF_(0x80001087L)

#ifdef __cplusplus
}
#endif

#endif  // __ITERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itdb.h ===
// ITDB.H:	ITDatabase interface declaration

#ifndef __ITDB_H__
#define __ITDB_H__

// {8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITDatabase, 
0x8fa0d5a2, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {66673452-8C23-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITDatabase, 
0x66673452, 0x8c23, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa9-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITDatabaseLocal, 
0x4662daa9, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Guaranteed to be an invalid value for dwObjInstance params in IITDatabase
// methods.
#define	IITDB_OBJINST_NULL	((DWORD) 0xFFFFFFFF)


DECLARE_INTERFACE_(IITDatabase, IUnknown)
{
	STDMETHOD(Open)(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags) PURE;
	STDMETHOD(Close)(void) PURE;

	// Creates an unnamed object that can be referenced in the future
	// by *pdwObjInstance.  Note that the value in *pdwObjInstance will be
	// persisted by the database when it is asked to save via
	// IPersistStorage::Save.
	STDMETHOD(CreateObject)(REFCLSID rclsid, DWORD *pdwObjInstance) PURE;

	// Retrieves a specified IUnknown-based interface on the object identified
	// by dwObjInstance.
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj) PURE;

	// To obtain a pointer to a named object's persistence the object's full
	// name (including any object-specific type prefix) should be passed in
	// lpswszObject.  If *lpwszObject is NULL, then the database's own storage
	// will be returned.  If lpwszObject is NULL, then dwObjInstance will be
	// used to identify the object and locate its persistence.  On exit,
	// *ppvPersistence will be either an IStorage* or an IStream*, depending
	// on what the caller specified with the fStream param.  The caller should
	// assume that only read operations can be performed on *ppvPersistence.
	// If the specified object's persistence doesn't exist, or if it exists
	// but is of the wrong type, then STG_E_FILENOTFOUND will be returned. 
	STDMETHOD(GetObjectPersistence)(LPCWSTR lpwszObject, DWORD dwObjInstance,
									LPVOID *ppvPersistence, BOOL fStream) PURE;
};

typedef IITDatabase* LPITDB;

#endif		// __ITDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itgroup.h ===
// ITGROUP.H:  IITGroup interface declaration

#ifndef __ITGROUP_H__
#define __ITGROUP_H__

//#include <comdef.h>

// {B1A6CA91-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(IID_IITGroup, 
0xb1a6ca91, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258914-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(IID_IITGroupArray, 
0x98258914, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#ifdef ITPROXY

// {B1A6CA92-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(CLSID_IITGroup, 
0xb1a6ca92, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258915-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(CLSID_IITGroupArray, 
0x98258915, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#else

// {4662daab-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupLocal, 
0x4662daab, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daac-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupArrayLocal, 
0x4662daac, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Forward declarations
interface IITDatabase;

DECLARE_INTERFACE_(IITGroup, IUnknown)
{

	STDMETHOD(Initiate)(DWORD lcGrpItem) PURE;
	STDMETHOD(CreateFromBitVector)(LPBYTE lpBits, DWORD dwSize, DWORD dwItems) PURE;
	STDMETHOD(CreateFromBuffer)(HANDLE h) PURE;
    STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker) PURE;
    STDMETHOD(Free)(void) PURE;
	STDMETHOD(CopyOutBitVector)(IITGroup* pIITGroup) PURE;
    STDMETHOD(AddItem)(DWORD dwGrpItem) PURE;
    STDMETHOD(RemoveItem)(DWORD dwGrpItem) PURE;
	STDMETHOD(FindTopicNum)(DWORD dwCount, LPDWORD lpdwOutputTopicNum) PURE;
	STDMETHOD(FindOffset)(DWORD dwTopicNum, LPDWORD lpdwOutputOffset) PURE;
    STDMETHOD(GetSize)(LPDWORD dwGrpSize) PURE;
	STDMETHOD(Trim)(void) PURE;
	STDMETHOD(And)(IITGroup* pIITGroup) PURE;
	STDMETHOD(And)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroup) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Not)(void) PURE;
	STDMETHOD(Not)(IITGroup* pIITGroupOut) PURE;
	STDMETHOD(IsBitSet)(DWORD dwTopicNum) PURE;
	STDMETHOD(CountBitsOn)(LPDWORD lpdwTotalNumBitsOn) PURE;
	STDMETHOD(Clear)(void) PURE;
    STDMETHOD_(LPVOID, GetLocalImageOfGroup)(void) PURE;
    STDMETHOD(PutRemoteImageOfGroup)(LPVOID lpGroupIn) PURE;

};

typedef IITGroup* LPITGROUP;

#define ITGP_MAX_GROUPARRAY_ENTRIES 32   // maximum number of groups allowed in a collection
#define ITGP_ALL_ENTRIES (-1L)
#define ITGP_OPERATOR_OR   0
#define ITGP_OPERATOR_AND  1

DECLARE_INTERFACE_(IITGroupArray, IITGroup)
{
	// composite group interface
	STDMETHOD(InitEntry)(IITDatabase *piitDB, LPCWSTR lpwszName, LONG& lEntryNum) PURE;
	STDMETHOD(InitEntry)(IITGroup *piitGroup, LONG& lEntryNum) PURE;
	STDMETHOD(SetEntry)(LONG lEntryNum) PURE;
	STDMETHOD(ClearEntry)(LONG lEntryNum) PURE;
	STDMETHOD(SetDefaultOp)(LONG cDefaultOp) PURE;
	STDMETHOD(ToString)(LPWSTR *ppwBuffer) PURE;
};

typedef IITGroupArray* LPIITGroupArray;
#endif // __ITGROUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itpropl.h ===
// ITPROPL.H:	ITPropertyList interface declaration

#ifndef __ITPROPL_H__
#define __ITPROPL_H__

#include <ocidl.h>

// {1F403BB1-9997-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITPropList, 
0x1f403bb1, 0x9997, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daae-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITPropList, 
0x4662daae, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

typedef DWORD PROPID;

// Operations you can do on a property
#define PROP_ADD    0x00000000
#define PROP_DELETE 0x00000001
#define PROP_UPDATE 0x00000002

// Type of data
#define TYPE_VALUE   0x00000000
#define TYPE_POINTER 0x00000001
#define TYPE_STRING  0x00000002

// Class definition of CProperty
class CProperty
{
public:
    PROPID dwPropID;        // property ID
    DWORD cbData;           // Amount of data
    DWORD dwType;           // What type this is
    union
    {
        LPCWSTR lpszwData;  // String
        LPVOID lpvData;     // Any kind of data
        DWORD  dwValue;     // Numerical data
    };
	BOOL fPersist;          // TRUE to persist this property

};

typedef CProperty* LPPROP;


// Interface def. for IITPropList
DECLARE_INTERFACE_(IITPropList, IPersistStreamInit)
{

    // dwOperation = operation (add, delete, update, etc.) to perform on property list
	STDMETHOD(Set)(PROPID PropID, DWORD dwData, DWORD dwOperation) PURE;
	STDMETHOD(Set)(PROPID PropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation) PURE;
    STDMETHOD(Set)(PROPID PropID, LPCWSTR lpszwString, DWORD dwOperation) PURE;
    STDMETHOD(Add)(CProperty& Prop) PURE;

    STDMETHOD(Get)(PROPID PropID, CProperty& Property) PURE;
    STDMETHOD(Clear)() PURE;

    // set persistence state on property
    STDMETHOD(SetPersist)(PROPID PropID, BOOL fPersist) PURE;   // single property
    STDMETHOD(SetPersist)(BOOL fPersist) PURE;          // all properties in list

    // for enumerating properties
    STDMETHOD(GetFirst)(CProperty& Property) PURE;
    STDMETHOD(GetNext)(CProperty& Property) PURE;
    STDMETHOD(GetPropCount)(LONG &cProp) PURE;

	// persist header and data separately
	STDMETHOD(SaveHeader)(LPVOID lpvData, DWORD dwHdrSize) PURE;
	STDMETHOD(SaveData)(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize) PURE;
	STDMETHOD(GetHeaderSize)(DWORD& dwHdrSize) PURE;
	STDMETHOD(GetDataSize)(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize) PURE;
	STDMETHOD(SaveDataToStream)(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream) PURE;

    // persist to a memory buffer
    STDMETHOD(LoadFromMem)(LPVOID lpvData, DWORD dwBufSize) PURE;
    STDMETHOD(SaveToMem)(LPVOID lpvData, DWORD dwBufSize) PURE;

};

typedef IITPropList* LPITPROPLIST;

#endif		// __ITPROPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itrs.h ===
// ITRS.H:	ITResultSet interface declaration

#ifndef __ITRS_H__
#define __ITRS_H__


// {3BB91D41-998B-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITResultSet, 
0x3bb91d41, 0x998b, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daa7-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITResultSet, 
0x4662daa7, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// maximum number of columns in a row set
#define MAX_COLUMNS  256

// Column priorities
typedef enum
{
    PRIORITY_LOW = 0,
    PRIORITY_NORMAL = 1,
    PRIORITY_HIGH = 2,

} PRIORITY;


// Forward declarations
class CProperty;

typedef struct tagROWSTATUS
{
    LONG lRowFirst;
    LONG cRows;
    LONG cProperties;
    LONG cRowsTotal;

} ROWSTATUS, *LPROWSTATUS;


typedef struct tagCOLUMNSTATUS
{
    LONG cPropCount;
    LONG cPropsLoaded;

} COLUMNSTATUS, *LPCOLUMNSTATUS;


// Used by IITResultSet::SetColumnHeap.
typedef SCODE (__stdcall *PFNCOLHEAPFREE)(LPVOID);


DECLARE_INTERFACE_(IITResultSet, IUnknown)
{
    // Initialization
    STDMETHOD(SetColumnPriority)(LONG lColumnIndex, PRIORITY ColumnPriority) PURE;
	STDMETHOD(SetColumnHeap)(LONG lColumnIndex, LPVOID lpvHeap,
										PFNCOLHEAPFREE pfnColHeapFree) PURE;
    STDMETHOD(SetKeyProp)(PROPID PropID) PURE;
    STDMETHOD(Add)(LPVOID lpvHdr) PURE;
    STDMETHOD(Add)(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority) PURE;

    // Build result set
	STDMETHOD(Append)(LPVOID lpvHdr, LPVOID lpvData) PURE;
	STDMETHOD(Set)(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD dwData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpwStr) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData) PURE;
	STDMETHOD(Copy)(IITResultSet* pRSCopy) PURE;
	STDMETHOD(AppendRows)(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
									LONG& lRowFirstDest) PURE;


    // Obtain info about result set
    STDMETHOD(Get)(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop) PURE;
    STDMETHOD(GetKeyProp)(PROPID& KeyPropID) PURE;
    STDMETHOD(GetColumnPriority)(LONG lColumnIndex, PRIORITY& ColumnPriority) PURE;
    STDMETHOD(GetRowCount)(LONG& lNumberOfRows) PURE;
	STDMETHOD(GetColumnCount)(LONG& lNumberOfColumns) PURE;
	STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID) PURE;
    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue,
		                 DWORD& cbSize, PRIORITY& ColumnPriority) PURE;

	STDMETHOD(GetColumnFromPropID)(PROPID PropID, LONG& lColumnIndex) PURE;

    // Clear result set
    STDMETHOD(Clear)() PURE;
    STDMETHOD(ClearRows)() PURE;
    STDMETHOD(Free)() PURE;

    // Asynchronous support
    STDMETHOD(IsCompleted)() PURE;      // returns S_OK or S_FALSE
    STDMETHOD(Cancel)() PURE;
    STDMETHOD(Pause)(BOOL fPause) PURE;

    STDMETHOD(GetRowStatus)(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus) PURE;
    STDMETHOD(GetColumnStatus)(LPCOLUMNSTATUS lpColStatus) PURE;
};

typedef IITResultSet* LPITRS;


#endif		// __ITRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itquery.h ===
// ITQUERY.H:	IITIndex and IITQuery interface declarations

#ifndef __ITQUERY_H__
#define __ITQUERY_H__

#include "iterror.h"

// {8fa0d5a3-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITIndex, 
0x8fa0d5a3, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {A38D3483-8C49-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITIndex, 
0xa38d3483, 0x8c49, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daad-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITIndexLocal, 
0x4662daad, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// {8fa0d5ac-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITQuery, 
0x8fa0d5ac, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa6-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITQuery, 
0x4662daa6, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// Defines
#define IMPLICIT_AND            0x0000
#define IMPLICIT_OR             0x0001
#define COMPOUNDWORD_PHRASE     0x0010 // use PHRASE opr for compound words
#define QUERYRESULT_RANK        0x0100 // Ranked the result. If not highest hit 1st (topics in UID order)
#define QUERYRESULT_UIDSORT     0x0200 // Result topics are 1st in 1st out
#define QUERYRESULT_SKIPOCCINFO 0x8000 // Topic list only, no occurrence info

#define STEMMED_SEARCH	        0x00010000
#define RESULTSET_ASYNC			0x00020000
#define QUERY_GETTERMS			0x00080000	// Return with each set of occurrence
											// data a pointer to the term string
											// that the data is associated with.

// Standard properties
#define STDPROP_SEARCHBASE  500
#define STDPROP_FIELD			STDPROP_SEARCHBASE
#define STDPROP_LENGTH			(STDPROP_SEARCHBASE + 1)
#define STDPROP_COUNT			(STDPROP_SEARCHBASE + 2)
#define STDPROP_OFFSET			(STDPROP_SEARCHBASE + 3)
#define STDPROP_TERM_UNICODE_ST	(STDPROP_SEARCHBASE + 4)

// Don't know signature of callbacks yet
typedef void (*LPFNCBBREAK)(void);    
typedef void (*LPFNRESULTCB)(void);


// Forward declarations
interface IITResultSet;
interface IITQuery;
interface IITDatabase;
interface IITGroup;

DECLARE_INTERFACE_(IITIndex, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* pITDB, LPCWSTR lpszIndexMoniker, BOOL fInsideDB) PURE;
	STDMETHOD(Close)(void) PURE;

	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;
	STDMETHOD(GetWordBreakerInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(CreateQueryInstance)(IITQuery** ppITQuery) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITResultSet* pITResult) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITGroup* pITGroup) PURE;
};

typedef IITIndex* PITINDEX;


DECLARE_INTERFACE_(IITQuery, IUnknown)
{
	STDMETHOD(SetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(SetCommand)(LPCWSTR lpszCommand) PURE;
	STDMETHOD(SetOptions)(DWORD dwFlags) PURE;
	STDMETHOD(SetProximity)(WORD wNear) PURE;
	STDMETHOD(SetGroup)(IITGroup* pITGroup) PURE;
	STDMETHOD(SetResultCount)(LONG cRows) PURE;

	STDMETHOD(GetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(GetCommand)(LPCWSTR& lpszCommand) PURE;
	STDMETHOD(GetOptions)(DWORD& dwFlags) PURE;
	STDMETHOD(GetProximity)(WORD& wNear) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;
	STDMETHOD(GetResultCount)(LONG& cRows) PURE;

	STDMETHOD(ReInit)() PURE;

};

typedef IITQuery* PITQUERY;


#endif		// __ITQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itstem.h ===
// ITSTEM.H:	(from Tripoli) IStemmer, IStemSink
//				(from InfoTech) IStemmerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITSTEM_H__
#define __ITSTEM_H__

#include <comdef.h>


#ifndef __IStemSink_FWD_DEFINED__
#define __IStemSink_FWD_DEFINED__
typedef interface IStemSink IStemSink;
#endif 	/* __IStemSink_FWD_DEFINED__ */


#ifndef __IStemmer_FWD_DEFINED__
#define __IStemmer_FWD_DEFINED__
typedef interface IStemmer IStemmer;
#endif 	/* __IStemmer_FWD_DEFINED__ */


#ifndef __IStemmerConfig_FWD_DEFINED__
#define __IStemmerConfig_FWD_DEFINED__
typedef interface IStemmerConfig IStemmerConfig;
#endif 	/* __IStemmerConfig_FWD_DEFINED__ */


DECLARE_INTERFACE_(IStemmer, IUnknown)
{
    STDMETHOD(Init)(ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
    STDMETHOD(StemWord)(WCHAR const *pwcInBuf, ULONG cwc,
									IStemSink *pStemSink) PURE;   
};

typedef IStemmer *PISTEM;


DECLARE_INTERFACE_(IStemSink, IUnknown)
{
    STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
    STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef IStemSink *PISTEMSNK;


DECLARE_INTERFACE_(IStemmerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the stemming
	// behavior of IStemmer::StemWord.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets info that controls certain aspects of stemming.
	// This method currently accepts only the following set of flags
	// in grfStemFlags:
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfStemFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfStemFlags, DWORD *pdwReserved) PURE;

	// Will load external stemmer data, such as word part lists, etc.
	// The format of the data in the stream is entirely
	// implementation-specific.
	STDMETHOD(LoadExternalStemmerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;
};

typedef IStemmerConfig *PISTEMC;



#endif	// __ITSTEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itwbrk.h ===
// ITWBRK.H:	(from Tripoli) IWordBreaker, IWordSink, IPhraseSink, IStem
//				(from InfoTech) IWordBreakerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITWBRK_H__
#define __ITWBRK_H__

#include <comdef.h>
#include <itstem.h>


#ifndef __IPhraseSink_FWD_DEFINED__
#define __IPhraseSink_FWD_DEFINED__
typedef interface IPhraseSink IPhraseSink;
#endif 	/* __IPhraseSink_FWD_DEFINED__ */


#ifndef __IWordSink_FWD_DEFINED__
#define __IWordSink_FWD_DEFINED__
typedef interface IWordSink IWordSink;
#endif 	/* __IWordSink_FWD_DEFINED__ */


#ifndef __IWordBreaker_FWD_DEFINED__
#define __IWordBreaker_FWD_DEFINED__
typedef interface IWordBreaker IWordBreaker;
#endif 	/* __IWordBreaker_FWD_DEFINED__ */


#ifndef __IWordBreakerConfig_FWD_DEFINED__
#define __IWordBreakerConfig_FWD_DEFINED__
typedef interface IWordBreakerConfig IWordBreakerConfig;
#endif 	/* __IWordBreakerConfig_FWD_DEFINED__ */


#ifndef __IITStopWordList_FWD_DEFINED__
#define __IITStopWordList_FWD_DEFINED__
typedef interface IITStopWordList IITStopWordList;
#endif 	/* __IITStopWordList_FWD_DEFINED__ */


// Supporting definitions for IWordBreaker.
typedef struct tagTEXT_SOURCE TEXT_SOURCE;
typedef SCODE (__stdcall *PFNFILLTEXTBUFFER)(TEXT_SOURCE *pTextSource);

typedef struct tagTEXT_SOURCE
{
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
} TEXT_SOURCE;


DECLARE_INTERFACE_(IWordBreaker, IUnknown)
{
	STDMETHOD(Init)(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
	STDMETHOD(BreakText)(TEXT_SOURCE *pTextSource, IWordSink *pWordSink,
											IPhraseSink *pPhraseSink) PURE;
	STDMETHOD(ComposePhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
						WCHAR const *pwcModifier, ULONG cwcModifier,
						ULONG ulAttachmentType, WCHAR *pwcPhrase,
												ULONG *pcwcPhrase) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
};

typedef IWordBreaker *PIWBRK;


// Break word types that can be passed to
// IWordBreakerConfig::SetBreakWordType.
#define IITWBC_BREAKTYPE_TEXT		((DWORD) 0)
#define IITWBC_BREAKTYPE_NUMBER		((DWORD) 1)
#define IITWBC_BREAKTYPE_DATE		((DWORD) 2)
#define IITWBC_BREAKTYPE_TIME		((DWORD) 3)
#define IITWBC_BREAKTYPE_EPOCH		((DWORD) 4)


// Breaker control flags that can be passed to
// IWordBreakerConfig::SetControlInfo.
#define IITWBC_BREAK_ACCEPT_WILDCARDS	0x00000001  // Interpret wildcard chars
													// as such.
#define IITWBC_BREAK_AND_STEM           0x00000002  // Stem words after breaking
													// them.

// External data types that can be passed to
// IWordBreakerConfig::LoadExternalBreakerData.
#define IITWBC_EXTDATA_CHARTABLE		((DWORD) 0)		
#define IITWBC_EXTDATA_STOPWORDLIST		((DWORD) 1)


DECLARE_INTERFACE_(IWordBreakerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the word breaking
	// behavior of IWordBreaker::BreakText.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the type of words the breaker should expect
	// to see in all subsequent calls to IWordBreaker::BreakText.
	// Returns S_OK if the type is understood by the breaker
	//  object; E_INVALIDARG otherwise.
	STDMETHOD(SetBreakWordType)(DWORD dwBreakWordType) PURE;
	STDMETHOD(GetBreakWordType)(DWORD *pdwBreakWordType) PURE;

	// Sets/gets info that controls certain aspects of word breaking.
	// This method currently accepts only the following set of flags
	// in grfBreakFlags:
	//		IITWBC_BREAK_ACCEPT_WILDCARDS
	//		IITWBC_BREAK_AND_STEM
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfBreakFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfBreakFlags, DWORD *pdwReserved) PURE;

	// Will load external breaker data, such as a table containing
	// char-by-char break information or a list of stop words.
	// Although the format of the data in the stream is entirely
	// implementation-specific, this interface does define a couple
	// of general types for that data which can be passed in
	// dwStreamDataType:
	//		IITWBC_EXTDATA_CHARTABLE
	//		IITWBC_EXTDATA_STOPWORDLIST
	STDMETHOD(LoadExternalBreakerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;

	// These methods allow a stemmer to be associated with the breaker.  The
	// breaker will take responsibility for calling
	// IPersistStreamInit::Load/Save when it is loaded/saved if the stemmer
	// supports that interface.
	STDMETHOD(SetWordStemmer)(REFCLSID rclsid, IStemmer *pStemmer) PURE;
	STDMETHOD(GetWordStemmer)(IStemmer **ppStemmer) PURE;
};

typedef IWordBreakerConfig *PIWBRKC;


// Supporting definitions for IWordSink.
typedef enum tagWORDREP_BREAK_TYPE
{
    WORDREP_BREAK_EOW = 0,
    WORDREP_BREAK_EOS = 1,
    WORDREP_BREAK_EOP = 2,
    WORDREP_BREAK_EOC = 3
} WORDREP_BREAK_TYPE;


DECLARE_INTERFACE_(IWordSink, IUnknown)
{
	STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc,
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc, 
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(StartAltPhrase)(void) PURE;
	STDMETHOD(EndAltPhrase)(void) PURE;
	STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType) PURE;
};

typedef IWordSink *PIWRDSNK;


DECLARE_INTERFACE_(IPhraseSink, IUnknown)
{
	STDMETHOD(PutSmallPhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
								WCHAR const *pwcModifier, 
								ULONG cwcModifier,
								ULONG ulAttachmentType) PURE;
	STDMETHOD(PutPhrase)(WCHAR const *pwcPhrase, ULONG cwcPhrase) PURE;
};

typedef IPhraseSink *PIPHRSNK;


// Function or macro that can be used by a breaker implementation
// to pull characters from the caller's text source.
#ifdef __cplusplus

inline WCHAR WBreakGetWChar(TEXT_SOURCE *pTextSource )
{
    if ( pTextSource->iCur == pTextSource->iEnd )
    {
        if ( FAILED(pTextSource->pfnFillTextBuffer( pTextSource ) ) )
            return 0xFFFF;  // UniCode EOF
    }

    return pTextSource->awcBuffer[pTextSource->iCur++];
};

#else

#define WBreakGetWChar( pTextSource )\
    (pTextSource->iCur==pTextSource->iEnd)\
    ? (FAILED(pTextSource->pfnFillTextBuffer( pTextSource )) \
       ? 0xFFFF\
       : pTextSource->awcBuffer[pTextSource->iCur++])\
    : pTextSource->awcBuffer[pTextSource->iCur++]

#endif


DECLARE_INTERFACE_(IITStopWordList, IUnknown)
{
	STDMETHOD(AddWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
	STDMETHOD(LookupWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef	IITStopWordList	*PIITSTWDL;


#endif		// __ITWBRK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\initguid.cpp ===
// INITGUID.CPP -- Code file where the DLL's guid structures are instantiated.

// Note: Do not use precompiled headers with this file! They can cause problems
// because we need to change the interpretation of DEFINE_GUID by defining the
// symbol INITGUID. In some cases using precompiled headers generates incorrect
// code for that case.

#define INITGUID

// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#define NOATOM
#define NOCOMM
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOEXTDEVMODEPROPSHEET
#define NOIME
#define NOKANJI
#define NOLOGERROR
#define NOMCX
#define NOPROFILER
#define NOSCALABLEFONT
#define NOSERVICE
#define NOSOUND

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>

// place all interfaces here that need their objects instantiated

// Tome
#include "MSITStg.h"

// Centaur
#include "itquery.h"
#include "itgroup.h"
#include "itpropl.h"
#include "itrs.h"
#include "itdb.h"
#include "itww.h"

// Centaur compiler
#include "itcc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\info.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _SYSTEM_H_
#define _SYSTEM_H_

#include "..\hhctrl\fs.h"

typedef enum {
    TAG_DEFAULT_TOC,        // needed if no window definitions
    TAG_DEFAULT_INDEX,      // needed if no window definitions
    TAG_DEFAULT_HTML,       // needed if no window definitions
    TAG_DEFAULT_CAPTION,    // needed if no window definitions
    TAG_SYSTEM_FLAGS,
    TAG_DEFAULT_WINDOW,
    TAG_SHORT_NAME,    // short name of title (ex. root filename)
    TAG_HASH_BINARY_INDEX,
    TAG_INFO_TYPES,
    TAG_COMPILER_VERSION,   // specifies the version of the compiler used
    TAG_TIME,               // the time the file was compiled
} SYSTEM_TAG_TYPE;

typedef struct {
    WORD tag;
    WORD cbTag;
} SYSTEM_TAG;

typedef struct {
    LCID    lcid;
    BOOL    fDBCS;  // Don't use bitflags! Can't assume byte-order
    BOOL    fFTI;   // full-text search enabled
    BOOL    fKeywordLinks;
    BOOL    fALinks;
  FILETIME FileTime; // title uniqueness (should match .chi file)
} SYSTEM_FLAGS;

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation - read in the title informaton file (#SYSTEM) settings for each title
//

class CTitleInformation
{
public:
    CTitleInformation( CFileSystem* pFileSystem );
    ~CTitleInformation();

    inline LPCSTR   GetShortName() { Init(); return m_pszShortName; }
    inline LPCSTR   GetTitleName() { Init(); return m_pszTitleName; }
    inline FILETIME GetFileTime() { Init(); return m_Settings.FileTime; }
    inline LCID     GetLanguage() { Init(); return m_Settings.lcid; }
    inline BOOL     IsKeywordLinks() { Init(); return m_Settings.fKeywordLinks; }
    inline BOOL     IsAssociativeLinks() { Init(); return m_Settings.fALinks; }
    inline BOOL     IsFullTextSearch() { Init(); return m_Settings.fFTI; }
    inline BOOL     IsDoubleByte() { Init(); return m_Settings.fDBCS; }
    inline LPCSTR   GetCompilerVersion() { Init(); return m_pszCompilerVersion; }

    HRESULT Initialize();

private:
    inline BOOL     Init() { if( !m_bInit ) Initialize(); return m_bInit; }

    BOOL           m_bInit;         // self-initing class
    CFileSystem*   m_pFileSystem;   // title file system handle
    SYSTEM_FLAGS   m_Settings;      // simple title information settings
    LPCSTR         m_pszShortName;  // short title name
    LPCSTR         m_pszTitleName;  // title name
    LPCSTR         m_pszCompilerVersion; // compiler version
};

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation2 - get title informaton without going through the file system
//

class CTitleInformation2
{
public:
    CTitleInformation2( LPCTSTR pszPathName );
    ~CTitleInformation2();

    inline LPCTSTR  GetShortName() { Init(); return m_pszShortName; }
    inline FILETIME GetFileTime()  { Init(); return m_FileTime; }
    inline LCID     GetLanguage()  { Init(); return m_lcid; }

    HRESULT Initialize();

private:
    inline BOOL    Init() { if( !m_bInit ) Initialize(); return m_bInit; }

    BOOL           m_bInit;        // self-initing class
    LPCTSTR        m_pszPathName;  // title pathname
    LPCTSTR        m_pszShortName; // short title name
    LCID           m_lcid;         // language
    FILETIME       m_FileTime;     // file time
};

HRESULT DumpTitleInformation( CFileSystem* pFileSystem );
HRESULT DumpTitleInformation2( CFileSystem* pFileSystem );

#endif // _SYSTEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itwbrkid.h ===
// ITWBRKID.H:	IIDs and other GUIDs related to word breaking and stemming.

#ifndef __ITWBRKID_H__
#define __ITWBRKID_H__

#include <comdef.h>

//----------------------------------------------------------------------
//------			Word Breaking Definitions				------------
//----------------------------------------------------------------------

// {D53552C8-77E3-101A-B552-08002B33B0E6}
DEFINE_GUID(IID_IWordBreaker, 
0xD53552C8, 0x77E3, 0x101A, 0xB5, 0x52, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC907054-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IWordSink, 
0xCC907054, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC906FF0-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IPhraseSink, 
0xCC906FF0, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {8fa0d5a6-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IWordBreakerConfig, 
0x8fa0d5a6, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daaf-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITStdBreaker, 
0x4662daaf, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------			Stop Word List Definitions				------------
//----------------------------------------------------------------------

// {8fa0d5ad-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITStopWordList, 
0x8fa0d5ad, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------				Stemming Definitions				------------
//----------------------------------------------------------------------

// {efbaf140-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemmer, 
0xefbaf140, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {fe77c330-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemSink, 
0xfe77c330, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {8fa0d5a7-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IStemmerConfig, 
0x8fa0d5a7, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5a8-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_ITEngStemmer, 
0x8fa0d5a8, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITWBRKID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itww.h ===
// ITWW.H:	IITWordWheel interface declaration

#ifndef __ITWW_H__
#define __ITWW_H__

// {8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITWordWheel, 
0x8fa0d5a4, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {D73725C2-8C12-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITWordWheel, 
0xd73725c2, 0x8c12, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa8-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelLocal, 
0x4662daa8, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Word-wheel open flags
#define ITWW_OPEN_CONNECT	0x00000000    // connect to server on open (the default)
#define ITWW_OPEN_NOCONNECT	0x00000001    // don't connect to server on open

// Constants for IITWordWheel::Lookup.
#define ITWW_CBKEY_MAX		1024		// Max size of keys allowed in Word Wheels.

// Forward declarations
interface IITDatabase;
interface IITResultSet;
interface IITGroup;
interface IITPropList;
interface IITQuery;

DECLARE_INTERFACE_(IITWordWheel, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags=0) PURE;
	STDMETHOD(Close)(void) PURE;

	// Returns the code page ID and locale ID that the word wheel was built and
	// sorted with.
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Returns in *pdwObjInstance the ID of the external sort instance being used by
	// this word wheel.  The instance ID can be passed to IITDatabase::GetObject to
	// to obtain an interface pointer on the instantiated instance.  If the word
	// wheel doesn't use external sorting, then IITDB_OBJINST_NULL.
	STDMETHOD(GetSorterInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(Count)(LONG *pcEntries) PURE;

	// To be safe, the length of lpvKeyBuf should always be at least ITWW_CBKEY_MAX. 
	STDMETHOD(Lookup)(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf) PURE;
	STDMETHOD(Lookup)(LONG lEntry, IITResultSet* lpITResult, LONG cEntries) PURE;
	STDMETHOD(Lookup)(LPCVOID lpcvPrefix, BOOL fExactMatch, LONG *plEntry) PURE;

	STDMETHOD(SetGroup)(IITGroup* piitGroup) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;

	STDMETHOD(GetDataCount)(LONG lEntry, DWORD *pdwCount) PURE;
	STDMETHOD(GetData)(LONG lEntry, IITResultSet* lpITResult) PURE;
	STDMETHOD(GetDataColumns)(IITResultSet* pRS) PURE;
};

typedef IITWordWheel* LPITWORDWHEEL;

#endif		// __ITWW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhctrl\wwheel.h ===
// WWheel.h - HTML Help Word Wheel support
//
// Covers both KeywordLinks and AssociativeLinks
//
//

#ifndef __WWHEEL_H__
#define __WWHEEL_H__

#include <windows.h>

// InfoTech headers
#include "itww.h"
#include "itdb.h"
#include "itrs.h"
#include "itpropl.h"
#include "itcc.h"

#include "fs.h"

// make Don's stuff work
#include <stdio.h>
#ifdef HHCTRL
#include "parserhh.h"
#else
#include "parser.h"
#endif
#include "collect.h"
#include "hhtypes.h"
#include "toc.h"

#include "system.h"

// Centaur defines
#ifndef ITWW_CBKEY_MAX  //defined in itww.h
  #define ITWW_CBKEY_MAX 1024 
#endif

#ifndef ITWW_CBREC_MAX  // itww.h does not define this
  #define ITWW_CBREC_MAX 8
#endif

// global defines
#define HHWW_MAX_KEYWORD_OBJECT_SIZE       (ITWW_CBKEY_MAX-ITWW_CBREC_MAX)
#define HHWW_MAX_KEYWORD_LENGTH            (((HHWW_MAX_KEYWORD_OBJECT_SIZE-sizeof(HHKEYINFO)-sizeof(DWORD))/sizeof(WCHAR))-sizeof(WCHAR))

#define HHWW_FONT                          0x1 // bit 0
#define HHWW_SEEALSO                       0x2 // bit 1
#define HHWW_UID_OVERFLOW                  0x4 // bit 2
#define HHWW_PLACEHOLDER                   0x8 // bit 3
#define HHWW_KEYWORDLINKS                  0x1 // bit 0
#define HHWW_ASSOCIATIVELINKS              0x2 // bit 2

#define HHWW_ERROR                         ((DWORD)-1)
#define HHWW_MAX_LEVELS                    255

#define HHWW_LEVEL_DELIMITER_CHAR          0x01
#define HHWW_LEVEL_DELIMITER_STRING        ",\x01"
#define HHWW_LEVEL_DELIMITER_CHAR_OUTPUT   ' '
#define HHWW_LEVEL_DELIMITER_STRING_OUTPUT ", "

// the format of our sort key object is as follows:
//
//  + Null terminated MBCS string
//  + HHKEYINFO structure 
//  + trailing UIDs (DWORD) or the SeeAlso string
//
//  TODO: If we overflow the buffer then the UIDs are stored in the
//  occurence data and the SeeAlso string stored as a property
//  (STDPROP_USERPROP_BASE+1).  For now we truncate overflow data.

// Our sort key information struct
#pragma pack(push, 2)
typedef struct _hhkeyinfo
{
  WORD  wFlags; // indicates what data is stored with this keyword
  WORD  wLevel; 
  DWORD dwLevelOffset;
  DWORD dwFont;
  DWORD dwCount; // number of UIDs that follow this structure in the sortkey
} HHKEYINFO;
#pragma pack(pop)

// forward references
class CExTitle;
class CExCollection;
class CWordWheel;
class CTitleDatabase;

/////////////////////////////////////////////////////////////////////////////
// class CTitleMapEntry

class CTitleMapEntry SI_COUNT(CTitleMapEntry) {

public:
  inline CTitleMapEntry() { m_pTitle = NULL; m_pWordWheel = NULL; m_pDatabase = NULL; m_pKeywordLinks = NULL; m_pAssociativeLinks = NULL; m_pszShortName = NULL; m_dwIndex = HHWW_ERROR; m_dwId = 0; }
  inline ~CTitleMapEntry() { if( m_pszShortName ) delete [] (CHAR*) m_pszShortName; }

  inline DWORD           GetId() { return m_dwId; }
  inline DWORD           SetId( DWORD dwId ) { m_dwId = dwId; return m_dwId; }
  inline CExTitle*       GetTitle() { return m_pTitle; }
  inline CExTitle*       SetTitle( CExTitle* pTitle ) { m_pTitle = pTitle; return m_pTitle; }
  inline CTitleDatabase* GetDatabase() { return m_pDatabase; }
  inline CTitleDatabase* SetDatabase( CTitleDatabase* pDatabase ) { m_pDatabase = pDatabase; return m_pDatabase; }
  inline CWordWheel*     GetWordWheel() { return m_pWordWheel; }
  inline CWordWheel*     SetWordWheel( CWordWheel* pWordWheel ) { m_pWordWheel = pWordWheel; return m_pWordWheel; }
  inline CWordWheel*     GetKeywordLinks() { return m_pKeywordLinks; }
  inline CWordWheel*     SetKeywordLinks( CWordWheel* pKeywordLinks ) { m_pKeywordLinks = pKeywordLinks; return m_pKeywordLinks; }
  inline CWordWheel*     GetAssociativeLinks() { return m_pAssociativeLinks; }
  inline CWordWheel*     SetAssociativeLinks( CWordWheel* pAssociativeLinks ) { m_pAssociativeLinks = pAssociativeLinks; return m_pAssociativeLinks; }
  inline DWORD           GetIndex() { return m_dwIndex; }
  inline DWORD           SetIndex( DWORD dwIndex ) { m_dwIndex = dwIndex; return m_dwIndex; }
  inline const CHAR*     SetShortName( const CHAR* pszShortName )
  { //HH BUG 2807 --- See CheckWordWheels for more info.
    if (pszShortName)
    {
        int iLen = (int)strlen( pszShortName );
        if( iLen ) {
          m_pszShortName = new char[iLen+1];
          strcpy( (CHAR*) m_pszShortName, pszShortName );
        }
    }
    return m_pszShortName;
  }
  inline const CHAR*     GetShortName() { if( m_pTitle ) return m_pTitle->GetInfo2()->GetShortName(); return m_pszShortName; }
  inline FILETIME        GetFileTime() { if( m_pTitle ) return m_pTitle->GetInfo2()->GetFileTime(); return m_FileTime; }
  inline FILETIME        SetFileTime( FILETIME FileTime ) { m_FileTime = FileTime; return m_FileTime; }
  inline LCID            GetLanguage() { if( m_pTitle ) return m_pTitle->GetInfo2()->GetLanguage(); return m_lcid; }
  inline LCID            SetLanguage( LCID lcid ) { m_lcid = lcid; return m_lcid; }

private:
  DWORD           m_dwId;
  DWORD           m_dwIndex;
  CExTitle*       m_pTitle;
  CTitleDatabase* m_pDatabase;
  CWordWheel*     m_pWordWheel;
  CWordWheel*     m_pKeywordLinks;
  CWordWheel*     m_pAssociativeLinks;
  const CHAR*     m_pszShortName;
  FILETIME        m_FileTime;
  LCID            m_lcid;
};

/////////////////////////////////////////////////////////////////////////////
// class CTitleMap

class CTitleMap SI_COUNT(CTitleMap) {

public:
  inline CTitleMap() { _CTitleMap(); m_bInit = TRUE; }
  inline CTitleMap( const CHAR* pszDatabase ) { _CTitleMap(); m_pszDatabase = pszDatabase; }
  inline ~CTitleMap() { Free(); }

  BOOL Initialize();
  BOOL Free();

  inline DWORD           GetCount() { Init(); return m_dwCount; }
  inline DWORD           SetCount( DWORD dwCount ) { Free(); m_dwCount = dwCount; if( m_dwCount ) m_pEntries = new CTitleMapEntry[dwCount]; else m_pEntries = NULL; return m_dwCount; }
  inline CExTitle*       GetTitle( DWORD dwIndex ) { Init(); if( dwIndex < m_dwCount ) return ((CTitleMapEntry*)(m_pEntries+dwIndex))->GetTitle(); else return NULL; }
  inline CExTitle*       SetTitle( DWORD dwIndex, CExTitle* pTitle ) { ((CTitleMapEntry*)(m_pEntries+dwIndex))->SetTitle(pTitle); return pTitle; }
  inline CTitleMapEntry* GetAt( DWORD dwIndex ) { Init(); if( (m_dwCount != HHWW_ERROR) && (dwIndex < m_dwCount) ) return m_pEntries+dwIndex; else return NULL; }
  inline const CHAR*     GetDatabase() { return m_pszDatabase; }
  inline void            Sort( int (FASTCALL *compare)(const void*, const void*)) { Init(); QSort( m_pEntries, m_dwCount, sizeof(CTitleMapEntry), compare ); }

private:
  BOOL            m_bInit;
  const CHAR*     m_pszDatabase;
  DWORD           m_dwCount;
  CTitleMapEntry* m_pEntries;

  inline void _CTitleMap() { m_pszDatabase = NULL; m_bInit = FALSE; m_dwCount = HHWW_ERROR; m_pEntries = NULL; }
  inline BOOL Init() { if( !m_bInit ) Initialize(); return m_bInit; }
};

/////////////////////////////////////////////////////////////////////////////
// class CTitleDatabase declaration (Shared Centaur object)

class CTitleDatabase SI_COUNT(CTitleDatabase) {

public:
  CTitleDatabase( CExCollection* pCollection );
  CTitleDatabase( CExTitle* pTitle );
  CTitleDatabase( const CHAR* pszDatabase );
  CTitleDatabase( const WCHAR* pwszDatabase );
  ~CTitleDatabase();

  BOOL  Initialize(CHAR *pszFileName = NULL);
  BOOL  Free();

  inline CExCollection* GetCollection() { return m_pCollection; }
  inline CExTitle*      GetTitle() { return m_pTitle; }
  inline BOOL           IsCollection() { Init(); return m_bCollection; }
  inline IITDatabase*   GetDatabase() { Init(); return m_pDatabase; }
  inline CTitleMap*     GetTitleMap() { Init(); return m_pTitleMap; }
  inline CWordWheel*    GetKeywordLinks() { Init(); return m_pKeywordLinks; }
  inline CWordWheel*    GetAssociativeLinks() { Init(); return m_pAssociativeLinks; }
  BOOL                  MergeWordWheels();
  BOOL                  CheckWordWheels();
  BOOL                  BuildWordWheels();

  inline const CHAR*         GetPathname() { Init(); return m_pszDatabase; }
#ifdef CHIINDEX
  inline BOOL           SetAnimation( BOOL bState) { m_bAnimation = bState; return m_bAnimation;}
#endif

private:
  BOOL             m_bInit;
  const WCHAR*     m_pwszDatabase;
  const CHAR*      m_pszDatabase;
  CHAR             m_szFullPath[_MAX_PATH];
  CExCollection*   m_pCollection;
  CExTitle*        m_pTitle;
  IITDatabase*     m_pDatabase;
  BOOL             m_bCollection;
  CTitleMap*       m_pTitleMap;
  CWordWheel*      m_pKeywordLinks;
  CWordWheel*      m_pAssociativeLinks;
#ifdef CHIINDEX
  BOOL             m_bAnimation;        // TRUE to display animation during wordwheel build
#endif

  void _CTitleDatabase();
  inline BOOL Init() { if( !m_bInit ) Initialize(); return m_bInit; }
};

/////////////////////////////////////////////////////////////////////////////
// class CResultsEntry

class CResultsEntry SI_COUNT(CResultsEntry) {
public:
  inline CResultsEntry() {}
  inline ~CResultsEntry() {}
  inline DWORD GetURLId() { return  m_dwURLId; }
  inline DWORD SetURLId( DWORD dwURLId ) { m_dwURLId = dwURLId; return m_dwURLId; }
  inline CExTitle* GetTitle() { return m_pTitle; }
  inline CExTitle* SetTitle( CExTitle* pTitle ) { m_pTitle = pTitle; return m_pTitle; }
private:
  DWORD     m_dwURLId;
  CExTitle* m_pTitle; 
};

/////////////////////////////////////////////////////////////////////////////
// class CResults declaration

class CResults SI_COUNT(CResults) {
public:
  inline CResults() { m_dwIndex = HHWW_ERROR; m_pEntries = NULL; }
  inline ~CResults() { Free(); }
  inline DWORD GetIndex() { return m_dwIndex; }
  inline DWORD SetIndex( DWORD dwIndex, DWORD dwSize )
  {
    m_dwIndex = dwIndex;
    Free();
    m_dwSize = dwSize;
    if( m_dwSize )
      m_pEntries = new CResultsEntry[dwSize];
    else
      m_pEntries = NULL;
    return m_dwIndex;
  }
  inline DWORD GetCount() { return m_dwSize; }
  inline CResultsEntry* GetAt( DWORD dwIndex ) { if(dwIndex < m_dwSize) return m_pEntries+dwIndex; else return NULL; }
private:
  DWORD m_dwIndex;
  DWORD m_dwSize;
  CResultsEntry* m_pEntries;

  inline BOOL Free() { if( m_pEntries ) { delete [] m_pEntries; m_pEntries = NULL; } return TRUE; }
};

/////////////////////////////////////////////////////////////////////////////
// class CWordWheelEntry declaration

class CWordWheelEntry SI_COUNT(CWordWheelEntry) {
public:
  inline CWordWheelEntry() { m_dwIndex = HHWW_ERROR; }
  inline ~CWordWheelEntry() {}

  DWORD  m_dwIndex;
  WCHAR  m_wszFullKeyword[HHWW_MAX_KEYWORD_LENGTH+1];
  WCHAR  m_wszKeyword[HHWW_MAX_KEYWORD_LENGTH+1];
  DWORD  m_dwLevel;
  DWORD  m_dwLevelOffset;
  DWORD  m_dwFlags;
  DWORD  m_dwFont;
  WCHAR  m_wszSeeAlso[HHWW_MAX_KEYWORD_LENGTH+1];
};

/////////////////////////////////////////////////////////////////////////////
// class CWordWheel declaration

class CWordWheel SI_COUNT(CWordWheel) {

public:
  CWordWheel( CTitleDatabase* pDatabase, const WCHAR* pwszWordWheel, DWORD dwTitleId = 0 );
  CWordWheel( CTitleDatabase* pDatabase, const CHAR* pszWordWheel, DWORD dwTitleId = 0 );
  ~CWordWheel();

  DWORD AddRef();
  DWORD Release();

  BOOL  Initialize();
  BOOL  Free();
  DWORD GetCount();
  DWORD GetIndex( const WCHAR* pwszKeyword, BOOL bFragment = TRUE, DWORD* pdwIndexLast = NULL );
  DWORD GetIndex( const CHAR* pszKeyword, BOOL bFragment = TRUE, DWORD* pdwIndexLast = NULL );
  BOOL  GetString( DWORD dwKeyword, WCHAR* pwszBuffer, DWORD cchBuffer = (DWORD)-1, BOOL bFull = FALSE, BOOL bCacheAll = FALSE );
  BOOL  GetString( DWORD dwKeyword, CHAR* pszBuffer, DWORD cchBuffer = (DWORD)-1, BOOL bFull = FALSE, BOOL bCacheAll = FALSE );
  DWORD GetLevel( DWORD dwKeyword );
  DWORD GetLevelOffset( DWORD dwKeyword );
  BOOL  GetSeeAlso( DWORD dwKeyword, WCHAR* pwszBuffer, DWORD cchBuffer = (DWORD)-1 );
  BOOL  GetSeeAlso( DWORD dwKeyword, CHAR* pszBuffer, DWORD cchBuffer = (DWORD)-1 );
  BOOL  IsPlaceHolder( DWORD dwKeyword );
  DWORD GetHitCount( DWORD dwKeyword );
  DWORD GetHit( DWORD dwKeyword, DWORD dwHit, CExTitle** ppTitle = NULL );

  inline BOOL GetSorterInstance( DWORD* pdwSorterInstance ) { if( Init() ) { m_pWordWheel->GetSorterInstance(pdwSorterInstance); return TRUE; } return FALSE; }
  inline BOOL GetLocaleInfo( DWORD* pdwCodePageId, LCID* plcid ) { if( Init() ) { m_pWordWheel->GetLocaleInfo(pdwCodePageId, plcid); return TRUE; } return FALSE; }
  inline CTitleDatabase* GetDatabase() { Init(); return m_pDatabase; }
  inline IITWordWheel* GetWordWheel() { Init(); return m_pWordWheel; }

  BOOL  GetIndexData( DWORD dwKeyword, BOOL bCacheAll = FALSE );

private:
  DWORD            m_dwRefCount;
  const WCHAR*     m_pwszWordWheel;
  const WCHAR*     m_pwszWordWheelIn;
  const CHAR*      m_pszWordWheelIn;
  BOOL             m_bInit;
  IITWordWheel*    m_pWordWheel;
  CTitleDatabase*  m_pDatabase;
  CWordWheelEntry  m_CachedEntry;
  CResults         m_CachedResults;
  DWORD            m_dwCount;
  DWORD            m_dwTitleId;

  void _CWordWheel();
  inline BOOL Init() { if( !m_bInit ) Initialize(); return m_bInit; }

  BOOL  GetIndexHitData( DWORD dwKeyword );
  inline BOOL  GetIndexHitData( const VOID* pcvKeywordObject, DWORD cbSize, HHKEYINFO* pInfo, DWORD dwKeyword );

};

/////////////////////////////////////////////////////////////////////////////
// class CWordWheelCompiler declaration

class CWordWheelCompiler SI_COUNT(CWordWheelCompiler) {

public:
  CWordWheelCompiler( const CHAR* pszDatabase, const WCHAR* pwszKeywordLinks, const WCHAR* pwszAssociativeLinks, LCID lcid = ((DWORD)-1));
  ~CWordWheelCompiler();

  IITBuildCollect* m_pBuildCollectKeywordLinks;
  IITBuildCollect* m_pBuildCollectAssociativeLinks;
  IITPropList*     m_pPropList;

  HRESULT Initialize();
  HRESULT Free();
  HRESULT Build();
#ifdef CHIINDEX
  inline BOOL      SetAnimation( BOOL bState ) { m_bAnimation = bState; return m_bAnimation;}
#endif

private:
  BOOL             m_bInit;
  const CHAR*      m_pszDatabase;
  const WCHAR*     m_pwszKeywordLinks;
  const WCHAR*     m_pwszAssociativeLinks;
  LCID             m_lcid;

  CHAR             m_szDatabase[MAX_PATH];
  CFileSystem*     m_pFileSystem;
  IITDatabase*     m_pDatabase;
  IPersistStorage* m_pPersistStorageDatabase;

  IStorage*        m_pStorageKeywordLinks;
  IStorage*        m_pStorageAssociativeLinks;
  IPersistStorage* m_pPersistStorageKeywordLinks;
  IPersistStorage* m_pPersistStorageAssociativeLinks;
#ifdef CHIINDEX
  BOOL             m_bAnimation;
#endif

  void _CWordWheelCompiler();
  inline BOOL Init() { if( !m_bInit ) Initialize(); return m_bInit; }
};

#endif // __WWHEEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itsort.h ===
// ITSORT.H:	IITSortKey, IITSortKeyConfig, and related definitions.

#ifndef __ITSORT_H__
#define __ITSORT_H__

#include <comdef.h>


// Some standard definitions for sort key types.  In general, key types (and
// their #defines) are specific to a particular implementation of a sort object.
// However, in the interest of making it easier to call a variety of sort object
// implementations, we define some standard key type definitions that can be
// used across different implementations.
// New sort objects should feel free to add arbitrary key formats, which could
// include a variety of custom binary formats tailored to specific applications
// (e.g. a binary key that provides indirection to a dictionary of strings).
// Note that the format of the key type must always allow its length to be
// determined without any other data than the key itself, as follows:
//		1) length is constant for the key type (e.g. DWORD is always 4 bytes)
//		2) key includes length information (e.g. a WORD prefix indicating
//			how many memory units (bytes, words, etc.) the key contains
//		3) key must contain an explicit terminator (e.g. null terminated strings).
#define IITSK_KEYTYPE_WORD			((DWORD) 18)	// Binary word
#define IITSK_KEYTYPE_DWORD			((DWORD) 19)	// Binary dword
#define IITSK_KEYTYPE_ANSI_SZ		((DWORD) 30)	// NULL-term. MBCS string
#define IITSK_KEYTYPE_UNICODE_SZ	((DWORD) 31)	// NULL-term. Unicode string


// Valid parameters that can be returned by IITSortKey::Compare in *pgrfReason.
#define IITSK_COMPREASON_UNKNOWN		((DWORD) 0x80000000)

// Valid parameters that can be passed to IITSortKey::IsRelated.
#define IITSK_KEYRELATION_PREFIX		((DWORD) 0)
#define IITSK_KEYRELATION_INFIX			((DWORD) 1)
#define IITSK_KEYRELATION_SUFFIX		((DWORD) 2)


DECLARE_INTERFACE_(IITSortKey, IUnknown)
{
	// Returns in *pcbSize the size of the key in bytes (including any
	// length information).
	STDMETHOD(GetSize)(LPCVOID lpcvKey, DWORD *pcbSize) PURE;

	// On exit, *plResult is set according to strcmp conventions:
	//	< 0, = 0, > 0, depending on whether lpcvKey1 is less than, equal to, or
	// greater than lpcvKey2.  If pgrfReason is not NULL, *pgrfReason may be
	// filled in on exit with one or more bit flags giving more information about
	// the result of the comparison if the result was affected by something other
	// than raw lexical comparison (e.g. special character mappings).  If
	// *pgrfReason contains 0 on exit, that means the comparison result
	// was purely lexical; if *pgrfReason contains IITSK_COMPREASON_UNKNOWN,
	// then the sort object implementation wasn't able to provide additional
	// information about the comparison result.
	STDMETHOD(Compare)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LONG *plResult, DWORD *pgrfReason) PURE;

	// Returns S_OK if lpcvKey1 is related to lpcvKey2 according to
	// dwKeyRelation; else S_FALSE.  If the value specified for dwKeyRelation
	// is not supported, E_INVALIDARG will be returned.  If pgrfReason is not
	// NULL, *pgrfReason will be filled in just as it would be by
	// IITSortKey::Compare.
	STDMETHOD(IsRelated)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						 DWORD dwKeyRelation, DWORD *pgrfReason) PURE;

	// Converts a key of one type into a key of another type.  This is intended
	// mainly for converting an uncompressed key into a compressed key,
	// but a sort object is free to provide whatever conversion combinations
	// it wants to.  *pcbSizeOut should contain the size of the buffer pointed
	// to by lpvKeyOut.  The caller can obtain a guaranteed adequate buffer size
	// through *pcbSizeOut by passing 0 on entry.
	//
	// The following errors are returned:
	//		E_INVALIDARG:	the specified conversion is not supported, i.e.
	//						one or both of the REFGUID params is invalid.
	//		E_FAIL:			the buffer pointed to by lpvKeyOut was too small
	//						to hold the converted key.
	STDMETHOD(Convert)(DWORD dwKeyTypeIn, LPCVOID lpcvKeyIn,
						DWORD dwKeyTypeOut, LPVOID lpvKeyOut,
						DWORD *pcbSizeOut) PURE;
};

typedef IITSortKey *PIITSKY;


// Sort flags that can be passed to IITSortKeyConfig::SetControlInfo.
#define IITSKC_SORT_STRINGSORT           0x00001000  /* use string sort method */
#define IITSKC_NORM_IGNORECASE           0x00000001  /* ignore case */
#define IITSKC_NORM_IGNORENONSPACE       0x00000002  /* ignore nonspacing chars */
#define IITSKC_NORM_IGNORESYMBOLS        0x00000004  /* ignore symbols */
#define IITSKC_NORM_IGNOREKANATYPE       0x00010000  /* ignore kanatype */
#define IITSKC_NORM_IGNOREWIDTH          0x00020000  /* ignore width */


// External data types that can be passed to
// IITSortKeyConfig::LoadExternalSortData.
#define IITWBC_EXTDATA_SORTTABLE	((DWORD) 2)		


DECLARE_INTERFACE_(IITSortKeyConfig, IUnknown)
{
	// Sets/gets locale info that will affect the comparison results
	// returned from all subsequent calls to IITSortKey::Compare.
	// Returns S_OK if locale described by params is supported
	// by the sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the sort key type that the sort object will expect
	// to see in the following method calls that take keys as params:
	//		IITSortKey::GetSize, Compare, IsRelated
	// Returns S_OK if the sort key type is understood by the
	// sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetKeyType)(DWORD dwKeyType) PURE;
	STDMETHOD(GetKeyType)(DWORD *pdwKeyType) PURE;

	// Sets/gets data that controls how sort key comparisons are made.
	// This method currently accepts only the following set of flags
	// in grfSortFlags:
	//
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfSortFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfSortFlags, DWORD *pdwReserved) PURE;

	// Will load external sort data, such as tables containing the relative
	// sort order of specific characters for a textual key type, from the
	// specified stream.  The format of the data is entirely implementation
	// specific, with the value passed in dwExtDataType providing a hint.
	STDMETHOD(LoadExternalSortData)(IStream *pStream, DWORD dwExtDataType) PURE;
};

typedef IITSortKeyConfig *PIITSKYC;


#endif		// __ITSORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itsortid.h ===
// ITSORTID.H:	IIDs and other GUIDs related to sorting.

#ifndef __ITSORTID_H__
#define __ITSORTID_H__

#include <comdef.h>

// {8fa0d5a0-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKey, 
0x8fa0d5a0, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5a1-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKeyConfig, 
0x8fa0d5a1, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662dab0-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITSysSort, 
0x4662dab0, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITSORTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\itcc.h ===
/************************************************************************
 *
 * ITCC.H
 *
 * Copyright (c) Microsoft Corporation 1993 - 1997
 * All rights reserved.
 *
 *************************************************************************
 *
 * Module intent:
 *
 * This module contains the API (Application Programming Interface)
 * for creating and updating ITIR objects and storages
 *
 *************************************************************************
 *
 * Current owner: JohnRush
 *
 ************************************************************************/

#ifndef _ITCC_H // {
#define _ITCC_H

#include "itpropl.h"
#include "itdb.h"

// Document property macros
#define STDPROP_UID         1
#define STDPROP_TITLE       2
#define STDPROP_USERDATA    3
#define STDPROP_KEY         4

#define STDPROP_SORTKEY		100
#define STDPROP_DISPLAYKEY	101
#define STDPROP_SORTORDINAL 102

#define STDPROP_INDEX_TEXT    200
#define STDPROP_INDEX_VFLD    201
#define STDPROP_INDEX_DTYPE   202
#define STDPROP_INDEX_LENGTH  203
#define STDPROP_INDEX_BREAK   204

#define STDPROP_INDEX_TERM              210
#define STDPROP_INDEX_TERM_RAW_LENGTH   211

#define STDPROP_USERPROP_BASE   0x00010000
#define STDPROP_USERPROP_MAX    0x7FFFFFFF

// Property destinations for word wheels
#define SZ_WWDEST_GLOBAL    L"GLOBAL"
#define SZ_WWDEST_KEY       L"KEY"
#define SZ_WWDEST_OCC       L"OCC"


// {4662daa2-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCmdInt,
0x4662daa2, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa3-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITSvMgr,
0x4662daa3, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4CF34C30-9BF9-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITCmdInt,
0x4cf34c30, 0x9bf9, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4E7DA031-9C11-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITSvMgr,
0x4e7da031, 0x9c11, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4662daa5-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelUpdate,
0x4662daa5, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
    
// {8fa0d5a5-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITBuildCollect,
0x8fa0d5a5, 0xdedf, 0x11d0, 0x9a, 0x61, 0x0, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa4-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupUpdate,
0x4662daa4, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITIndexBuild,
0x8fa0d5aa, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWWFilterBuild,
0x8fa0d5ab, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

struct VARARG
{
    DWORD   dwArgc;
    void    *Argv[20];
};

// Document class
class CSvDoc
{
public:
    virtual HRESULT WINAPI ResetDocTemplate (void) PURE;

    virtual HRESULT WINAPI AddObjectEntry(LPCWSTR lpObjName, IITPropList *pPL) PURE;
    virtual HRESULT WINAPI AddObjectEntry
        (LPCWSTR lpObjName, LPCWSTR szPropDest, IITPropList *pPL) PURE;
};

// Service manager class
DECLARE_INTERFACE_(IITSvMgr, IUnknown)
{
    STDMETHOD(Initiate)(IStorage *pistgStorage, IStream *piistmLog) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(Build)(void) PURE;
	STDMETHOD(SetPropDest)
        (LPCWSTR szObjectName, LPCWSTR szDestination, IITPropList *pPL) PURE;
	STDMETHOD(CreateBuildObject)(LPCWSTR pwstrObjectName, REFCLSID refclsid) PURE;
    STDMETHOD(GetBuildObject)
        (LPCWSTR pwstrObjectName, REFIID refiid, void **pInterface) PURE;

	STDMETHOD(CreateDocTemplate)(CSvDoc **ppDoc) PURE;
	STDMETHOD(FreeDocTemplate)(CSvDoc *pDoc) PURE;
	STDMETHOD(AddDocument)(CSvDoc *pDoc) PURE;

	STDMETHOD(HashString)(IN LPCWSTR lpwstr, OUT DWORD *pdwHash) PURE;
};

// Command Interpreter Interface
DECLARE_INTERFACE_(IITCmdInt, IUnknown)
{
	STDMETHOD(Initiate)(IITSvMgr *piitsv) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(LoadFromStream)(IStream *pMVPStream, IStream *pLogStream) PURE;
};

typedef struct tagHelperInfo
{
    UINT    CodePage;
    LCID    lcid;
    DWORD   argc1;
    DWORD   *argv1;
    DWORD   argc2;
    LPWSTR  *argv2;
} HelperInfo, *PHelperInfo;

// This structure is sent to IITBuildCollect::SetBuildStats
typedef struct tagIITBOCI
{
    DWORD dwSize;   // Must be set to size of this structure
    DWORD dwMaxUID; // The highest uid authored for this title
} ITBuildObjectControlInfo;

DECLARE_INTERFACE_(IITBuildCollect, IUnknown)
{
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams) PURE;
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString) PURE;
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList) PURE;
	STDMETHOD(Close)(void) PURE;
    STDMETHOD(GetTypeString)(LPWSTR wstrType, DWORD *pLength) PURE;
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci) PURE;
};


#endif // _ITCC_H }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\atlinc.h ===
// ATLINC.H:  Common includes used primarily for ATL

#ifndef __ATLINC_H__
#define __ATLINC_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_FREE_THREADED
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
#include "module.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CHtmlHelpModule _Module;
#include <atlcom.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\cstr.h ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef __CSTR_H__
#define __CSTR_H__

#include "lcmem.h"

class CStr
{
public:
    CStr(PCSTR pszOrg) { psz = lcStrDup(pszOrg); }
    CStr(LPCWSTR  pszNew) {
        psz = NULL;
        *this = pszNew;
    }
    CStr(int idResource) { psz = lcStrDup(GetStringResource(idResource)); }

    CStr(void) { psz = NULL; }

    // Get a format string from a resource id and merge the string:
    // Equivalent to wsprintf(buffer, GetStringResource(id), pszString)

    CStr(int idFormatString, PCSTR pszSubString);

    // Get the text of a window

    CStr(HWND hwnd);

    ~CStr() {
        if (psz)
            lcFree(psz); }

    void FormatString(int idFormatString, PCSTR pszSubString);
    PSTR GetArg(PCSTR pszSrc, BOOL fCheckComma = FALSE);
    int  GetText(HWND hwnd, int id_or_sel = -1);
    BOOL IsEmpty(void) { return (psz ? (BOOL) (*psz == '\0') : TRUE); }
    BOOL IsNonEmpty(void) const { return (psz ? (BOOL) (*psz != '\0') : FALSE); }
    int  SizeAlloc(void) { return (psz ? lcSize(psz) : 0); }
    int  strlen(void) { return (psz ? ::strlen(psz) : 0); }
    void ReSize(int cbNew) {
            if (!psz)
                psz = (PSTR) lcMalloc(cbNew);
            else
                psz = (PSTR) lcReAlloc(psz, cbNew);
        }

    void TransferPointer(PSTR* ppsz) {
        *ppsz = psz;
        psz = NULL;
    }
    void TransferPointer(PCSTR* ppsz) {
        *ppsz = psz;
        psz = NULL;
    }

    operator PCSTR() { return (PCSTR) psz; }
    operator PSTR() { return psz; }       // as a C string
    void operator+=(PCSTR pszCat)
        {
            ASSERT(psz);
            ASSERT(pszCat);
            psz = (PSTR) lcReAlloc(psz, strlen() + ::strlen(pszCat) + 1);
            strcat(psz, pszCat);
        }
    void operator=(PCSTR pszNew)
        {
            ASSERT(pszNew);
            // Duplicate first in case we are assigning part of ourselves
            PSTR pszTmp = lcStrDup(pszNew);
            if (psz)
                lcFree(psz);
            psz = pszTmp;
        }
    void operator=(LPCWSTR pszNew);

    PSTR psz;
};

class CWStr
{
public:
    CWStr() : pw(NULL) {}
    CWStr(HWND hwnd);
    CWStr(PCSTR psz) {
        pw = NULL;
        *this = psz;
    }
    CWStr(int idResource) { pw = lcStrDupW(GetStringResourceW(idResource)); }

    ~CWStr() { if (pw) lcFree(pw); }

    void operator=(PCWSTR pszNew)
    {
        ASSERT(pszNew);
        PWSTR pszTmp = lcStrDupW(pszNew);
        if (pw)
            lcFree(pw);
        pw = pszTmp;
    }
    void operator=(PCSTR psz);
    operator LPWSTR() { return (LPWSTR) pw; };
    int Length()     { return pw ? lstrlenW(pw) : 0; }
    int ByteLength() { return Length()*sizeof(WCHAR); }
//private:
    LPWSTR pw;
};

#endif // __CSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\util.h ===
// zero fill functions
#define ZERO_INIT_CLASS(base_class) \
    ClearMemory((PBYTE) ((base_class*) this) + sizeof(base_class*), \
        sizeof(*this) - sizeof(base_class*));
#define ZERO_STRUCTURE(foo) ClearMemory(&foo, sizeof(foo))
#define ClearMemory(p, cb) memset(p, 0, cb)

// memory functions
#define lcMalloc(x) malloc((size_t)x)
#define lcFree(x)   free((void*)x)

// message box functions
int MsgBox(int idString, UINT nType = MB_OK );
int MsgBox(PCSTR pszMsg, UINT nType = MB_OK );

PCSTR FindFilePortion( PCSTR pszFile );
int JulianDate(int nDay, int nMonth, int nYear);
HRESULT FileTimeToDateTimeString( FILETIME FileTime, LPTSTR pszDateTime );
int FileTimeToJulianDate( FILETIME FileTime );

// system directory functions
typedef UINT (WINAPI *PFN_GETWINDOWSDIRECTORY)( LPTSTR lpBuffer, UINT uSize );
typedef enum { HH_SYSTEM_WINDOWS_DIRECTORY, HH_USERS_WINDOWS_DIRECTORY } SYSDIRTYPES;

UINT HHGetWindowsDirectory( LPSTR lpBuffer, UINT uSize, UINT uiType = HH_SYSTEM_WINDOWS_DIRECTORY );
UINT HHGetHelpDirectory( LPSTR lpBuffer, UINT uSize );
UINT HHGetGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize , BOOL *pbNewPath);
HRESULT HHGetHelpDataPath( LPSTR pszPath );
BOOL IsDirectory( LPCSTR lpszPathname );
DWORD       CreatePath(PSTR pszPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\fs.h ===
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _FS_H_
#define _FS_H_

#include <unknwn.h>
#include "msitstg.h"

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

//
// Sub-File System
//
class CSubFileSystem
{

public:
   CSubFileSystem(class CFileSystem* pfs);
   ~CSubFileSystem();

   HRESULT CreateSub(PCSTR pszPathName);
   HRESULT CreateUncompressedSub(PCSTR pszPathName);
   HRESULT OpenSub(PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   ULONG WriteSub(const void* pData, int cb);
   ULONG SeekSub(int cb, int iOrigin);
   HRESULT CreateSystemFile(PCSTR pszPathName);
   HRESULT CreateUncompressedSystemFile(PCSTR pszPathName);
   HRESULT SetSize(unsigned uSize);
   HRESULT DeleteSub() ;

   inline HRESULT ReadSub(void* pData, ULONG cb, ULONG* pcbRead) {
      return m_pStream->Read(pData, cb, pcbRead);
   }

   inline ULONG GetUncompressedSize(void) { return SeekSub(0,2); }

   inline HRESULT Stat(STATSTG *pstatstg, DWORD grfStatFalg)
   {
      return m_pStream->Stat(pstatstg,grfStatFalg);
   }

   inline HRESULT CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER* pcbWritten)
   {
      return m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
   }

   inline IStream * GetStream(void)
   {
      return m_pStream;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   class CFileSystem* m_pFS;
   IStorage*          m_pStorage;
   IStream*           m_pStream;
   char               m_szPathName[MAX_PATH]; // Needed for delete.
};

//
// File System
//
class CFileSystem
{
   friend class CSubFileSystem;

public:
   CFileSystem();
   ~CFileSystem();

   HRESULT Init(void);
   HRESULT Create( PCSTR pszPathName );
   HRESULT CreateUncompressed( PCSTR pszPathName );
   HRESULT Open( PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   HRESULT Compact(LPCSTR lpszFileName);
   HRESULT Close(void);

   inline HRESULT GetPathName( LPSTR pszPathName ) { strcpy(pszPathName, m_szPathName); return S_OK; }

   inline IITStorage* GetITStorageObj(void) const
   {
      return m_pITStorage;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   IITStorage*   m_pITStorage;
   IStorage*     m_pStorage;
   char          m_szPathName[MAX_PATH];

};

#endif // _FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\gwintype.h ===
#ifndef __GWINTYPE_H__
#define __GWINTYPE_H__
/////////////////////////////////////////////////////////////////////
//
//
// gwintype.h ---	Header file for CGlobalWinTypes
//
//
/*
	Contains an array of global window type names. Names are added to this array, when
	HH_SET_WIN_TYPE is called with a NULL pszFile parameter. This class provides backwards
	compatibility with code which called HH_SET_WIN_TYPE with the second parameter NULL.

Created:	7 Jul 98
By:			dalero

*/

/////////////////////////////////////////////////////////////////////
//
// CGlobalWinTypes
//
class CGlobalWinTypes
{
public:
//--- Construction

	// Ctor
	CGlobalWinTypes() ;

	// Dtor
	virtual ~CGlobalWinTypes() ;

public:
//--- Operations

	// Add a window type to the list.
	void Add(LPCSTR pszWinType) ;

	// Is the window type in the list.
	bool Find(LPCSTR pszWinType) ;
	bool Find(LPCWSTR pszWinType) ;

private:
//--- Helper functions

    // Allocate the array.
    LPCSTR* AllocateArray(int elements) ;

    // Deallocate the array. Does not free the members.
    void DeallocateArray(LPCSTR* p) ;

    // Destroy the array, including all members.
    void DestroyArray() ;

private:
//--- Member variables

    // Pointer to the array.
    LPCSTR* m_NameArray;

    // The number of allocated elements in the array.
    int m_maxindex ;

    // The last used index
    int m_lastindex ;

};

#endif // __GWINTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\collect.cpp ===
//*********************************************************************************************************************************************
//
//      File: collect.cpp
//  Author: Donald Drake
//  Purpose: Implements classes to support collections

#include "header.h"
#include "string.h"
#ifdef HHCTRL
#include "parserhh.h"
#include "toc.h"
#else
#include "stdio.h"
#include "windows.h"
#include "parser.h"
extern DWORD GetTitleVersion(const CHAR *szFileName);
extern LANGID GetLangId(const CHAR *szFileName);
#endif
#include "collect.h"

// Use CRT version in hhsetup

// Instance count checking:
AUTO_CLASS_COUNT_CHECK(CFolder);
AUTO_CLASS_COUNT_CHECK(CTitle);

#ifndef HHCTRL
#define Atoi atoi
#undef _splitpath
#endif

char gszColReg[MAX_PATH];
WCHAR *CreateUnicodeFromAnsi(LPSTR psz);

class CAnsi {
public:
    char *m_pszChar;
    CAnsi(WCHAR *);
    ~CAnsi();
    operator CHAR *() { return (CHAR *) m_pszChar; }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper functions
DWORD AllocSetValue(const CHAR *value, CHAR **dest)
{
   if (*dest)
      delete [] *dest;

   // REVIEW: confirm that len gets optimized out of existence

   int len = strlen(value) + 1;

   *dest = new CHAR[len];

   if (*dest == NULL)
      return F_MEMORY;

   strcpy(*dest, value);
   return F_OK;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CPointerList implementation
void foo(void)
{

}

void CPointerList::RemoveAll()
{
   LISTITEM *p;

   while (m_pHead)
   {
      p = m_pHead->Next;
      delete m_pHead;
      m_pHead = p;
   }
}

CPointerList::~CPointerList()
{
   RemoveAll();
}

LISTITEM *CPointerList::Add(void *p)
{
   LISTITEM *pItem = new LISTITEM;

   if (pItem)
   {
      pItem->pItem = p;
      pItem->Next = m_pHead;
      m_pHead = pItem;
      return pItem;
   }
   return NULL;
}

LISTITEM *CPointerList::First()
{
   return m_pHead;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CColList implementation

CColList::CColList()
{
	m_dwColNo = 0;
    m_szFileName = NULL;
	m_pNext = NULL;
}

void CColList::SetFileName(CHAR *sz)
{
	if (sz)
	    AllocSetValue(sz, &m_szFileName);
}

CColList::~CColList()
{
	if (m_szFileName)
		delete m_szFileName;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CCollection implementation

CCollection::CCollection()
{
    m_bRemoved = FALSE;
    m_pwcSampleLocation = NULL;
    m_pwcMasterCHM = NULL;
    m_bFailNoFile = FALSE;
    m_bDirty = FALSE;
   m_szSampleLocation = NULL;
   m_szFileName = NULL;
    m_pwcFileName = NULL;
   m_szMasterCHM = NULL;
   m_pFirstTitle = NULL;
   m_pTitleTail = NULL;
   m_pColListHead = NULL;
   m_pColListTail = NULL;
   m_pLocationTail = NULL;
   m_pFirstLocation = NULL;
   m_pRootFolder = NULL;
   m_locationnum = 0;
   m_dwNextColNo = 1;
   m_dwColNo = 0;
   m_dwTitleRefCount = 0;
   m_dwRef = 0;
   m_dwVersion = 0;
   m_bFindMergedChms = FALSE;
   for (int i = 0; i < MAX_LEVELS; i++)
      m_pParents[i] = NULL;

   m_dwCurLevel = 0;
   m_dwLastLevel = 0;
   m_bConfirmTitles = FALSE;
   m_MasterLangId = ENGLANGID;
   gszColReg[0] = NULL;
#ifdef HHSETUP
   CoInitialize(NULL);   
#endif
}

CCollection::~CCollection()
{
   Close();
#ifdef HHSETUP
   CoUninitialize();   
#endif
}

DWORD CCollection::Release()
{
   if (m_dwRef == 0)
      return 0;
   m_dwRef--;
   return m_dwRef;
}

void CCollection::DeleteChildren(CFolder **p)
{
   if (!p || !(*p))
      return;

   CFolder *pChild, *pNext;
   if (pChild = (*p)->GetFirstChildFolder())
      DeleteChildren(&pChild);
   pNext = (*p)->GetNextFolder();
   delete (*p);
   *p = NULL;
   do {
      if (pNext)
         DeleteChildren(&pNext);
   } while (pNext && (pNext = pNext->GetNextFolder()));
}

void CCollection::SetSampleLocation(const CHAR *sz)
{
   if (!sz)
      return;
    Dirty();
   AllocSetValue(sz, &m_szSampleLocation);
}

CHAR *CCollection::GetSampleLocation()
{
   return m_szSampleLocation;
}


BOOL CCollection::GetMasterCHM(CHAR **szName, LANGID *pLang)
{
   *pLang = m_MasterLangId;
   *szName = m_szMasterCHM;
   if (m_szMasterCHM == NULL)
      return FALSE;
   return ((strlen(m_szMasterCHM) ? TRUE : FALSE));
}

void CCollection::SetMasterCHM(const CHAR *sz, LANGID lang)
{
   if (!sz)
      return;
    Dirty();
   m_MasterLangId = lang;
   AllocSetValue(sz, &m_szMasterCHM);
}

// Opens and loads the contents of the file into data structures
DWORD CCollection::Open(const CHAR * FileName)
{
   DWORD dw;
   BOOL bOld = FALSE;
   BOOL bTryAgain = FALSE;
   if (m_pRootFolder == NULL)
   {
      m_pRootFolder = new CFolder;
      if (m_pRootFolder == NULL)
         return F_MEMORY;
      m_pParents[0] = m_pRootFolder;
   }

   CHAR szBuffer[MAX_PATH];
   const CHAR *sz = szBuffer;
   BOOL bNewPath;
   HHGetGlobalCollectionPathname(szBuffer, sizeof(szBuffer), &bNewPath);

   dw = ParseFile(sz);

#ifdef HHCTRL  // hhsetup should only be concerned about the good location for this file
   if (dw == F_NOFILE && bNewPath)
   {
     // try windows dir for backward compatibity
try_again:
     bNewPath=FALSE;
     HHGetOldGlobalCollectionPathname(szBuffer, sizeof(szBuffer));
     dw = ParseFile(sz);
     bOld = TRUE;
   }
#endif

   if (dw != F_OK && dw != F_NOFILE)
      return dw;

   if (dw == F_NOFILE && m_bFailNoFile)
      return F_NOFILE;

   // save the hhcolreg file and path for save calls...  
   strcpy(gszColReg, sz);

   if (bNewPath && m_dwNextColNo < STARTINGCOLNO)
      m_dwNextColNo += STARTINGCOLNO;


   if (FileName)
      dw = ParseFile(FileName);

   if (dw != F_OK && dw != F_NOFILE)
      return dw;

   if (dw == F_NOFILE && m_bFailNoFile)
      return F_NOFILE;

   // now that we moved the file, if we did not get any titles found for the collection at runtime
   // and we have not looked at the old hhcolreg location let try it.

#ifdef HHCTRL // runtime only, I really hate this
    if (m_RefTitles.First() == NULL && bOld == FALSE && bTryAgain == FALSE)
    {
        Close();
        ConfirmTitles();
        m_bFailNoFile = TRUE;
        bTryAgain = TRUE;
        if (m_pRootFolder == NULL)
        {
            m_pRootFolder = new CFolder;
            if (m_pRootFolder == NULL)
                return F_MEMORY;
            m_pParents[0] = m_pRootFolder;
        }
        goto try_again;
    }

   // did we find any titles that matched
   if (m_RefTitles.First() == NULL)
   {
      return F_REFERENCED;
   }
#endif


   dw = AllocSetValue(FileName, &m_szFileName);

   m_bDirty = FALSE;
 
   CColList *pCol;

   if ((pCol = FindCollection(m_szFileName)) == NULL)
   {
	   // collection has never been added 
	   pCol = AddCollection();
	   pCol->SetFileName(m_szFileName);
#ifdef HHCTRL
	   if (m_dwColNo)
		   pCol->SetColNo(m_dwColNo);
	   else
	   {
   		   pCol->SetColNo(m_dwNextColNo);
  		   m_dwNextColNo++;
           if (bNewPath && m_dwNextColNo < STARTINGCOLNO)
            m_dwNextColNo += STARTINGCOLNO;
	   }
#else
  	   pCol->SetColNo(m_dwNextColNo);
	   m_dwNextColNo++;
       if (bNewPath && m_dwNextColNo < STARTINGCOLNO)
          m_dwNextColNo += STARTINGCOLNO;
#endif
	   m_bDirty = TRUE;
   }
   m_dwColNo = pCol->GetColNo();

   return dw;
}

CColList * CCollection::FindCollection(CHAR *szFileName)
{
   CColList *p = m_pColListHead;
   while (p)
   {
	   if (stricmp(p->GetFileName(), szFileName) == 0)
			return p;
	   p = p->GetNext();
   }
   return NULL;
}

CColList * CCollection::AddCollection()
{

   CColList *newCol = new CColList;
   if (!newCol)
   {
      return NULL;
   }

   if (m_pColListHead == NULL)
   {
      m_pColListHead = newCol;
   }
   else
   {
      m_pColListTail->SetNext(newCol);
   }
   m_pColListTail = newCol;
   return newCol;
}

void CCollection::RemoveCollectionEntry(CHAR *szFileName)
{
   CColList *p = m_pColListHead;
   CColList *pPrev = NULL;
   while (p)
   {
	   if (stricmp(p->GetFileName(), szFileName) == 0)
	   {
	      if (pPrev)
		  {
			  pPrev->SetNext(p->GetNext());
		  }
		  else
		  {
		      m_pColListHead = p->GetNext();
		  }
		  if (m_pColListTail == p)
			  m_pColListTail = pPrev;
		  delete p;
		  break;
	   }
	   pPrev = p;
	   p = p->GetNext();
   }
}



DWORD CCollection::AllocCopyValue(CParseXML *parser, CHAR *token, CHAR **dest)
{
   CHAR *sz;

   if (!parser || !token || !dest)
      return F_NULL;

   sz = parser->GetValue(token);
   if (*dest)
      delete [] *dest;

   int len = strlen(sz) + 1;

   *dest = new CHAR[len];
   if (*dest == NULL)
      return F_MEMORY;

   strcpy(*dest, sz);
   return F_OK;
}

DWORD CCollection::ParseFile(const CHAR *FileName)
{
   CParseXML parser;
   CHAR *token;
   CHAR *sz;
   DWORD dw;

   if (!FileName)
      return F_NULL;

   if ((dw = parser.Start(FileName)) != F_OK)
      return dw;


   for (token = parser.GetToken(); token;)
   {
      if (token[0] == '/')
      {
         dw = m_Strings.GetTail(&sz);
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if (strcmp(sz, &token[1]) != 0)
         {
            parser.End();
            delete sz;
            return F_TAGMISSMATCH;
         }
         delete sz;
         if (strcmp(token, "/Folder") == 0)
            m_dwCurLevel--;
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "XML") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
	  else if (stricmp(parser.GetFirstWord(token), "Collections") == 0)
	  {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
	  }		 
      else if (stricmp(parser.GetFirstWord(token), "Collection") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleCollectionEntry(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "HTMLHelpCollection") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleCollection(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "NextCollectionId") == 0)
      {
         m_dwNextColNo = atoi(parser.GetValue(token));
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Folders") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Folder") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleFolder(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "HTMLHelpDocInfo") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Locations") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (stricmp(parser.GetFirstWord(token), "Location") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleLocation(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else if (strcmp(parser.GetFirstWord(token), "DocCompilations") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
         continue;
      }
      else if (strcmp(parser.GetFirstWord(token), "DocCompilation") == 0)
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         if ((dw = HandleTitle(&parser, token)) != F_OK)
         {
            parser.End();
            return dw;
         }
         continue;
      }
      else
      {
         dw = m_Strings.AddTail(parser.GetFirstWord(token));
         if (dw != F_OK)
         {
            parser.End();
            return dw;
         }
         token = parser.GetToken();
      }
   }

   // make sure all tags have been popped
   dw = F_OK;
   while (m_Strings.GetTail(&sz) == F_OK)
   {
      delete sz;
      dw = F_MISSINGENDTAG;
   }
   parser.End();
   return dw;
}
DWORD CCollection::HandleCollectionEntry(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;

   CColList *newCol = AddCollection();
   
   if (!newCol)
   {
      return F_MEMORY;
   }

   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "colname") == 0)
      {
          newCol->SetFileName(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "colnum") == 0)
      {
		  newCol->SetColNo( atoi(parser->GetValue(token)));
      }
      else
         break;
   }
   return F_OK;
}

DWORD CCollection::HandleCollection(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;

   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "homepage") == 0)
      {
            // need to be backward compatable with this tag
      }
      else if (stricmp(parser->GetFirstWord(token), "masterchm") == 0)
      {
            SetMasterCHM( parser->GetValue(token), ENGLANGID);
      }
      else if (stricmp(parser->GetFirstWord(token), "samplelocation") == 0)
      {
            SetSampleLocation( parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "masterlangid") == 0)
      {
         m_MasterLangId = (LANGID)atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "refcount") == 0)
      {
         m_dwRef = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "version") == 0)
      {
         m_dwVersion = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "showhomepage") == 0)
      {
            // need to be backward compatable with this tag
      }
	  else if (stricmp(parser->GetFirstWord(token), "findmergedchms") == 0)
	  {
		 m_bFindMergedChms = atoi(parser->GetValue(token));
	  }
      else if (stricmp(parser->GetFirstWord(token), "CollectionNum") == 0)
      {
         m_dwColNo = atoi(parser->GetValue(token));
      }
      else
         break;
   }
   return F_OK;
}

DWORD CCollection::HandleFolder(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;
   CFolder *newFolder = new CFolder;
   if (newFolder == NULL)
      return F_MEMORY;

   m_dwCurLevel++;
   while (TRUE)
   {
      token = parser->GetToken();

      if (stricmp(parser->GetFirstWord(token), "TitleString") == 0)
      {
            newFolder->SetTitle(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "FolderOrder") == 0)
      {
            newFolder->SetOrder(atoi(parser->GetValue(token)));
      }
      else if (stricmp(parser->GetFirstWord(token), "LangId") == 0)
      {
            newFolder->SetLanguage((LANGID)atoi(parser->GetValue(token)));
      }
      else
         break;
   }

   CHAR *pTitle;
   pTitle = newFolder->GetTitle();
   if (pTitle && pTitle[0] == '=')
   {
      if (CheckTitleRef(pTitle, newFolder->GetLanguage()) != F_OK)
      {
         delete newFolder;
         return F_OK;
      }
      AddRefedTitle(newFolder);
   }

   m_pParents[m_dwCurLevel - 1]->AddChildFolder(newFolder);
   m_pParents[m_dwCurLevel] = newFolder;

   return F_OK;
}

DWORD CCollection::AddRefedTitle(CFolder *pFolder)
{
      m_dwTitleRefCount++;
      m_RefTitles.Add(pFolder);
      return F_OK;
}


DWORD CCollection::HandleLocation(CParseXML *parser, CHAR *token)
{
   if (!parser || !token)
      return F_NULL;
   CLocation *newLocation = NewLocation();

   if (newLocation == NULL)
      return F_MEMORY;

   newLocation->m_ColNum = 0;
   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "LocName") == 0)
      {
            newLocation->SetId(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleString") == 0)
      {
            newLocation->SetTitle(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LocPath") == 0)
      {
            newLocation->SetPath(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "Volume") == 0)
      {
            newLocation->SetVolume(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LocColNum") == 0)
      {
            newLocation->m_ColNum = atoi(parser->GetValue(token));
      }
      else
         break;
   }

   return F_OK;
}


DWORD CCollection::HandleTitle(CParseXML *parser, CHAR *token)
{

   if (!parser || !token)
      return F_NULL;

   LOCATIONHISTORY *pNew;
   CTitle *newTitle = NewTitle();
   DWORD dw;

    CHAR *pSampleLocation = NULL;
    BOOL bMerge = FALSE;

   if (newTitle == NULL)
      return F_MEMORY;

   while (TRUE)
   {
      token = parser->GetToken();
      if (stricmp(parser->GetFirstWord(token), "DocCompId") == 0)
      {
            newTitle->SetId(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleString") == 0)
      {
            // no longer do anything with titlestring but need to support for backward compatiblity
            continue;
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleSampleLocation") == 0)
      {
                if (newTitle->m_pTail == NULL)
                {
                    // old style global.col, save this for the locations to follow
                    AllocCopyValue(parser, token, &pSampleLocation);
                }
                else
               if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->SampleLocation))) != F_OK)
                  return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "DocCompLanguage") == 0)
      {
            newTitle->SetLanguage((LANGID)atoi(parser->GetValue(token)));
      }
      else if (stricmp(parser->GetFirstWord(token), "SupportsMerge") == 0)
      {
                if (newTitle->m_pTail == NULL)
                {
                    // old style global.col, save this for the locations to follow
                    bMerge = (BOOL)atoi(parser->GetValue(token));
                }
                else
               newTitle->m_pTail->bSupportsMerge = (BOOL)atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LocationHistory") == 0)
      {
            pNew = newTitle->NewLocationHistory();

            if (pNew == NULL)
               return F_MEMORY;

                if (pSampleLocation)
               if ((dw = AllocSetValue(pSampleLocation, &(newTitle->m_pTail->SampleLocation))) != F_OK)
                  return dw;

                newTitle->m_pTail->bSupportsMerge = bMerge;

            dw = m_Strings.AddTail(parser->GetFirstWord(token));
            if (dw != F_OK)
            {
               return dw;
            }
      }
      else if (stricmp(parser->GetFirstWord(token), "/LocationHistory") == 0)
      {
         CHAR *sz;
         dw = m_Strings.GetTail(&sz);
         if (dw != F_OK)
         {
            return dw;
         }

         if (strcmp(sz, &token[1]) != 0)
         {
            delete sz;
            return F_TAGMISSMATCH;
         }
         delete sz;
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->FileName))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "QueryLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->QueryFileName))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "TitleQueryLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->QueryLocation))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "IndexLocation") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->IndexFileName))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "LocationRef") == 0)
      {
         if ((dw = AllocCopyValue(parser, token, &(newTitle->m_pTail->LocationId))) != F_OK)
            return dw;
      }
      else if (stricmp(parser->GetFirstWord(token), "Version") == 0)
      {
         newTitle->m_pTail->Version = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "LastPromptedVersion") == 0)
      {
         newTitle->m_pTail->LastPromptedVersion = atoi(parser->GetValue(token));
      }
      else if (stricmp(parser->GetFirstWord(token), "ColNum") == 0)
      {
         newTitle->m_pTail->CollectionNumber = atoi(parser->GetValue(token));
      }
      else
         break;
   }

    if (pSampleLocation)
        delete pSampleLocation;

   return F_OK;
}

// Saves any changes made to the internal data structures to the file.
DWORD CCollection::Save()
{
   CHAR szBuffer[MAX_LINE_LEN];
   DWORD dwWritten;

#ifdef HHSETUP  // only hhsetup needs to rewrite the users .col file
                // don't want the control to add any new tags to old
                // collections, which would break uninstall and update
   // if no root folders delete the collection file
   if (m_bRemoved == TRUE)
   {
      DeleteFile(m_szFileName);
      m_bRemoved = FALSE;
   }
   else
   {
      if ((m_fh = CreateFile(m_szFileName, GENERIC_WRITE, FILE_SHARE_READ,  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE) {
         return F_NOFILE;
      }

      strcpy(szBuffer, "<XML>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      // write out collection information
      strcpy(szBuffer, "<HTMLHelpCollection>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<masterchm value=\"%s\"/>\r\n", (m_szMasterCHM ? m_szMasterCHM : ""));
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<masterlangid value=%d/>\r\n", m_MasterLangId);
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<samplelocation value=\"%s\"/>\r\n", (m_szSampleLocation ? m_szSampleLocation : ""));
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<collectionnum value=%d/>\r\n", m_dwColNo);
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<refcount value=%d/>\r\n", m_dwRef);
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<version value=%d/>\r\n", m_dwVersion);
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      wsprintf(szBuffer, "<findmergedchms value=%d/>\r\n", m_bFindMergedChms);
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      // write out folders
      strcpy(szBuffer,"<Folders>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }
      m_dwCurLevel = 0;

      if (WriteFolders(&m_pRootFolder) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }


      // close tags
      strcpy(szBuffer, "</Folders>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      strcpy(szBuffer, "</HTMLHelpCollection>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      strcpy(szBuffer, "</XML>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
         CloseHandle(m_fh);
            return F_WRITE;
        }

      CloseHandle(m_fh);
   }

#endif

   // save the global titles and locations
   // open collection file
   if ((m_fh = CreateFile(gszColReg, GENERIC_WRITE, FILE_SHARE_READ,  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE) {
      return F_NOFILE;
   }

   // write out XML tag
   strcpy(szBuffer, "<XML>\r\n");
   if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   strcpy(szBuffer, "<HTMLHelpDocInfo>\r\n");
   if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   wsprintf(szBuffer, "<NextCollectionId value=%d/>\r\n", m_dwNextColNo);
   if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   // write out the collection list
   strcpy(szBuffer, "<Collections>\r\n");
   if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
   {
       CloseHandle(m_fh);
       return F_WRITE;
   }

   CColList *pCol = m_pColListHead;

   while (pCol)
   {
      strcpy(szBuffer, "<Collection>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }
      wsprintf(szBuffer, "\t<ColNum value=%d/>\r\n",  pCol->GetColNo());
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }
      wsprintf(szBuffer, "\t<ColName value=\"%s\"/>\r\n",  (pCol->GetFileName() ? pCol->GetFileName() : ""));
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }
      strcpy(szBuffer, "</Collection>\r\n");
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
      {
          CloseHandle(m_fh);
          return F_WRITE;
      }

      pCol = pCol->GetNext();
   }
   strcpy(szBuffer, "</Collections>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }

   // write out the locations
   strcpy(szBuffer, "<Locations>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }

   CLocation *p = FirstLocation();

   while (p)
   {
      strcpy(szBuffer, "<Location>\r\n");
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<LocColNum value=%d/>\r\n",  p->m_ColNum);
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<LocName value=\"%s\"/>\r\n",  (p->GetId() ? p->GetId() : ""));
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<TitleString value=\"%s\"/>\r\n", (p->GetTitle() ? p->GetTitle() : ""));
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<LocPath value=\"%s\"/>\r\n", (p->GetPath() ? p->GetPath() : ""));
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<Volume value=\"%s\"/>\r\n", (p->GetVolume() ? p->GetVolume() : ""));
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      strcpy(szBuffer, "</Location>\r\n");
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }

      p = p->GetNextLocation();
   }
   strcpy(szBuffer, "</Locations>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }


   // write out the titles
   strcpy(szBuffer, "<DocCompilations>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        CloseHandle(m_fh);
        return F_WRITE;
    }

   CTitle *pTitle = GetFirstTitle();
   LOCATIONHISTORY *pHist;
   while (pTitle)
   {
      strcpy(szBuffer, "<DocCompilation>\r\n");
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<DocCompId value=\"%s\"/>\r\n", (pTitle->GetId() ? pTitle->GetId() : ""));
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      wsprintf(szBuffer, "\t<DocCompLanguage value=%d/>\r\n", pTitle->GetLanguage());
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }

      pHist = pTitle->m_pHead;

      while (pHist)
      {
         strcpy(szBuffer, "\t<LocationHistory>\r\n");
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<ColNum value=%d/>\r\n",  pHist->CollectionNumber);
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<TitleLocation value=\"%s\"/>\r\n", (pHist->FileName ? pHist->FileName : ""));
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<IndexLocation value=\"%s\"/>\r\n", (pHist->IndexFileName ? pHist->IndexFileName : ""));
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<QueryLocation value=\"%s\"/>\r\n", (pHist->QueryFileName ? pHist->QueryFileName : ""));
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<LocationRef value=\"%s\"/>\r\n", (pHist->LocationId ? pHist->LocationId : ""));
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<Version value=%ld/>\r\n", pHist->Version);
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<LastPromptedVersion value=%ld/>\r\n", pHist->LastPromptedVersion);
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
          wsprintf(szBuffer, "\t\t<TitleSampleLocation value=\"%s\"/>\r\n", (pHist->SampleLocation ? pHist->SampleLocation : ""));
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
          wsprintf(szBuffer, "\t\t<TitleQueryLocation value=\"%s\"/>\r\n", (pHist->QueryLocation ? pHist->QueryLocation : ""));
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         wsprintf(szBuffer, "\t\t<SupportsMerge value=%d/>\r\n", pHist->bSupportsMerge);
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         strcpy(szBuffer, "\t</LocationHistory>\r\n");
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                CloseHandle(m_fh);
                return F_WRITE;
            }
         pHist = pHist->pNext;
      }
      strcpy(szBuffer, "</DocCompilation>\r\n");
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            CloseHandle(m_fh);
            return F_WRITE;
        }
      pTitle = pTitle->GetNextTitle();
   }

   strcpy(szBuffer, "</DocCompilations>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
         CloseHandle(m_fh);
         return F_WRITE;
    }
   strcpy(szBuffer, "</HTMLHelpDocInfo>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
         CloseHandle(m_fh);
         return F_WRITE;
    }
   strcpy(szBuffer,"</XML>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
         CloseHandle(m_fh);
         return F_WRITE;
    }
   if (CloseHandle(m_fh) == FALSE)
        return F_CLOSE;

   // make sure we can open this file for read
   if ((m_fh = CreateFile(gszColReg, GENERIC_READ, FILE_SHARE_READ,  NULL, OPEN_EXISTING , FILE_ATTRIBUTE_NORMAL, NULL )) == INVALID_HANDLE_VALUE) {
      return F_EXISTCHECK;
   }

   if (CloseHandle(m_fh) == FALSE)
        return F_CLOSE;

   return F_OK;
}

BOOL CCollection::WriteFolders(CFolder **p)
{
    BOOL b = TRUE;
   if (!p || !(*p))
      return FALSE;

   CFolder *pChild;

   pChild = (*p)->GetFirstChildFolder();

   if (pChild)
      b = WriteFolder(&pChild);

   delete *p;
   *p = NULL;
    return b;
}

BOOL CCollection::WriteFolder(CFolder **p)
{
   if (!p || !(*p))
      return FALSE;

   CHAR szBuffer[MAX_LINE_LEN];
   DWORD dwWritten;

   CFolder *pChild, *pNext;
   DWORD i;
   // write this folder
   // tab over the indent level
   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel; i++)
   {
      if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }
   strcpy(szBuffer, "<Folder>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel+1; i++)
   {
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }
   wsprintf(szBuffer,  "<TitleString value=\"%s\"/>\r\n", (*p)->GetTitle());
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel+1; i++)
   {
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
    }

   wsprintf(szBuffer,  "<FolderOrder value=%d/>\r\n", (*p)->GetOrder());
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   CHAR *pTitle = (*p)->GetTitle();
   if (pTitle[0] == '=')
   {
      strcpy(szBuffer, "\t");
      for (i = 0; i < m_dwCurLevel+1; i++)
      {
            if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
            {
                return FALSE;
            }
      }
      wsprintf(szBuffer,  "<LangId value=%d/>\r\n", (*p)->GetLanguage());
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }

   m_dwCurLevel++;
   if (pChild = (*p)->GetFirstChildFolder())
   {
      if (WriteFolder(&pChild) == FALSE)
            return FALSE;
   }
   if (m_dwCurLevel)
      m_dwCurLevel--;

   strcpy(szBuffer, "\t");
   for (i = 0; i < m_dwCurLevel; i++)
   {
        if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
        {
            return FALSE;
        }
   }
   strcpy(szBuffer, "</Folder>\r\n");
    if (WriteFile(m_fh, szBuffer, strlen(szBuffer), &dwWritten, NULL) == FALSE)
    {
        return FALSE;
    }

   pNext = (*p)->GetNextFolder();
   delete (*p);
   *p = NULL;
   do {
      if (pNext)
      {
         if (WriteFolder(&pNext) == FALSE)
                return FALSE;
      }
   } while (pNext && (pNext = pNext->GetNextFolder()));
    return TRUE;
}

DWORD CCollection::Close()
{
   m_locationnum = 0;
   gszColReg[0] = NULL;
   m_dwNextColNo = 1;
   m_dwColNo = 0;
   m_dwTitleRefCount = 0;
   m_dwRef = 0;
   m_dwVersion = 0;
   for (int i = 0; i < MAX_LEVELS; i++)
      m_pParents[i] = NULL;
   m_dwCurLevel = 0;
   m_dwLastLevel = 0;
   m_bConfirmTitles = FALSE;
   m_MasterLangId = ENGLANGID;
   m_bFindMergedChms = FALSE;
   m_Strings.RemoveAll();

   if (m_szFileName)
   {
      delete m_szFileName;
      m_szFileName = NULL;
   }

   if (m_pwcFileName)
   {
      delete m_pwcFileName;
      m_pwcFileName = NULL;
   }

   if (m_szMasterCHM)
   {
      delete m_szMasterCHM;
      m_szMasterCHM = NULL;
   }

   if (m_pwcMasterCHM)
   {
      delete m_pwcMasterCHM;
      m_pwcMasterCHM = NULL;
   }

   if (m_szSampleLocation)
   {
      delete m_szSampleLocation;
      m_szSampleLocation = NULL;
   }

   // clean up col list
   CColList *pCol, *pColNext;
   for (pCol = m_pColListHead; pCol; pCol = pColNext)
   {
      pColNext = pCol->GetNext();
	  delete pCol;
   }

   m_pColListHead = NULL;
   m_pColListTail = NULL;

   // clean up locations
   CLocation *p, *pNext;
   for (p = m_pFirstLocation; p; p=pNext)
   {
      pNext = p->GetNextLocation();
      delete p;
   }

   m_pFirstLocation=NULL;
   m_pLocationTail = NULL;
   // clean up titles
   CTitle *pTitle, *pNextTitle;
   for (pTitle = m_pFirstTitle; pTitle; pTitle=pNextTitle)
   {
      pNextTitle = pTitle->GetNextTitle();
      delete pTitle;
   }

   m_pFirstTitle = NULL;
   m_pTitleTail = NULL;
   // clean up folder
   if (m_pRootFolder)
   {
      DeleteChildren(&m_pRootFolder);
   }
   m_pRootFolder = NULL;
   return F_OK;
}

// Returns the first title
CTitle * CCollection::GetFirstTitle()
{
   return m_pFirstTitle;
}

// Locates a title based on id
CTitle * CCollection::FindTitle(const CHAR * Id, LANGID LangId)
{
   if (!Id)
      return NULL;

   CTitle *p;

   p = m_pFirstTitle;

   while (p)
   {
      if (stricmp(p->GetId(), Id) == 0 &&
            (LangId == 0 || p->GetLanguage() == LangId)) // Ignore LangId if its zero.
        {
         return p;
        }
      p = p->GetNextTitle();
   }
   return NULL;
}

#ifdef HHCTRL
// Try multiple LangIds before failing
CTitle * CCollection::FindTitleNonExact(const CHAR * Id, LANGID DesiredLangId)
{
    CTitle* pTitle = NULL ;

    CLanguageEnum* pEnum = _Module.m_Language.GetEnumerator(DesiredLangId) ;
    ASSERT(pEnum) ;
    LANGID langid = pEnum->start() ;
    while (langid != c_LANGID_ENUM_EOF)
    {
        pTitle = FindTitle(Id, langid);
        if (pTitle)
        {
            break ; //Found It!
        }

        langid = pEnum->next() ;
    }

    // Cleanup.
    if (pEnum)
    {
        delete pEnum ;
    }

    return pTitle;
}
#endif // #ifdef HHCTRL

// Returns the first location
CLocation* CCollection::FirstLocation()
{
   return m_pFirstLocation;
}

// Finds a location based on a name
CLocation * CCollection::FindLocation(const CHAR * Id, UINT* puiVolumeOrder )
{
   if (!Id)
      return NULL;

   CLocation *p;

   p = m_pFirstLocation;

    if( puiVolumeOrder )
      *puiVolumeOrder = 0;

   while (p)
   {
        if( puiVolumeOrder )
          *puiVolumeOrder = (*puiVolumeOrder)+1;

      if (stricmp(p->GetId(), Id) == 0 && (p->m_ColNum == m_dwColNo|| p->m_ColNum == 0))
         return p;
      p = p->GetNextLocation();
   }
   return NULL;
}

DWORD CCollection::CheckTitleRef(const CHAR *pId, const LANGID Lang)
{
   if (m_bConfirmTitles == FALSE)
      return F_OK;

   if (pId[0] != '=')
      return F_OK;

   CTitle *pTitle;
   if ((pTitle = FindTitle(&pId[1], Lang)) == NULL)
      return F_NOTITLE;

   LOCATIONHISTORY *p;

   p = pTitle->m_pHead;

   while (p)
   {
      if (p->CollectionNumber == GetColNo())
         return F_OK;
      p = p->pNext;
   }

   return F_NOTITLE;
}

//Adds a new folder to the top level of the table of contents, with the given name and order and returns a pointer to that folder object.  A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
CFolder * CCollection::AddFolder(const CHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId)
{
   if (!szName)
   {
      if (pDWORD)
         *pDWORD = F_NULL;
      return NULL;
   }

   if (CheckTitleRef(szName, LangId) != F_OK)
   {
      if (pDWORD)
         *pDWORD = F_NOTITLE;
      return NULL;
   }

   CFolder *pNew;

   pNew = new CFolder;

   DWORD dwrc = F_OK;

   if (pNew)
   {
      pNew->SetTitle(szName);
      pNew->SetOrder(Order);
      pNew->SetLanguage(LangId);
      dwrc = m_pRootFolder->AddChildFolder(pNew);

      if (dwrc != F_OK)
      {
	 if (pDWORD)
            *pDWORD = dwrc;
         delete pNew;
         return NULL;
      }

      Dirty();
      return pNew;
   }

   if (pDWORD) 
      *pDWORD = F_MEMORY;
   return NULL;
}

CTitle * CCollection::NewTitle()
{
   CTitle *newTitle = new CTitle;
   if (newTitle == NULL)
      return NULL;

   if (m_pFirstTitle == NULL)
   {
      m_pFirstTitle = newTitle;
   }
   else
   {
      m_pTitleTail->SetNextTitle(newTitle);
   }
   m_pTitleTail = newTitle;

   return newTitle;
}

// Adds a title based on the provided information. A return of NULL indicates a failure and pDWORD will be  populated with one of  above DWORD codes.
// Note: you must add or find a CLocation object or pass null to indication no location is in use (local file).
CTitle * CCollection::AddTitle(const CHAR * Id, const CHAR * FileName,
   const CHAR * IndexFile, const CHAR * Query, const CHAR *SampleLocation,  LANGID Lang, UINT uiFlags,
   CLocation *pLocation,  DWORD *pDWORD, BOOL bSupportsMerge, const CHAR *QueryLocation)
{
   if (!Id || !FileName || !IndexFile)
      return NULL;
   DWORD dwrc;

   CTitle *pTitle;

   // check if the title exist
   if (pTitle = FindTitle(Id, Lang))
   {
      // add location
      dwrc = pTitle->AddLocationHistory(m_dwColNo, FileName, IndexFile, Query, pLocation, SampleLocation, QueryLocation, bSupportsMerge);
      if (pDWORD)
          *pDWORD = dwrc;
   }
   else
   {
      // just add the title then
      pTitle = NewTitle();
      if (pTitle == NULL)
      {
         if (pDWORD) 
	    *pDWORD = F_MEMORY;
         return NULL;
      }
      pTitle->SetId(Id);
      pTitle->SetLanguage(Lang);
      dwrc = pTitle->AddLocationHistory(m_dwColNo, FileName, IndexFile, Query, pLocation, SampleLocation, QueryLocation, bSupportsMerge);
      if (pDWORD)
          *pDWORD = dwrc;
   }
   Dirty();
   return pTitle;
}

CLocation * CCollection::NewLocation()
{
   CLocation *p = new CLocation;
   if (!p)
   {
      return NULL;
   }
   if (m_pFirstLocation == NULL)
   {
      m_pFirstLocation = p;
   }
   else
   {
      m_pLocationTail->SetNextLocation(p);
   }
   m_pLocationTail = p;
   return p;
}

// Adds location based on the given information. A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
CLocation * CCollection::AddLocation(const CHAR * Title, const CHAR * Path, const CHAR * Id, const CHAR * Volume, DWORD *pDWORD)
{
   if (!Title || !Path || !Id || !Volume)
      return NULL;

   CLocation *p;

   p = FindLocation(Id);

   // if not found then add new location entry
   if (!p)
      p = NewLocation();

   if (!p)
   {
      if (pDWORD) 
         *pDWORD = F_MEMORY;
      return NULL;
   }

   p->SetTitle(Title);
   p->SetPath(Path);
   p->SetId(Id);
   p->SetVolume(Volume);
   p->m_ColNum = m_dwColNo;
   if (pDWORD)
      *pDWORD = F_OK;
    Dirty();
   return p;
}


// removing objects
DWORD CCollection::DeleteFolder(CFolder *pDelete)
{

   if (!pDelete)
      return F_NULL;

   CFolder *pParent;
   CFolder *pPrev = NULL;
   CFolder *p;

   if ((pParent = pDelete->GetParent()) == NULL)
      return F_NOPARENT;

   p = pParent->GetFirstChildFolder();

   while (p)
   {
      if (p == pDelete)
      {
         // is this the head
         if  (!pPrev)
         {
            pParent->SetFirstChildFolder(p->GetNextFolder());
         }
         else
         {
            // fixup the list
            pPrev->SetNextFolder(p->GetNextFolder());
         }

         DeleteChildren(&pDelete);
       Dirty();
         return F_OK;

      }
      pPrev = p;
      p = p->GetNextFolder();
   }

   return F_NOTFOUND;
}

DWORD CCollection::DeleteTitle(CTitle *pDelete)
{
   if (!pDelete)
      return F_NULL;
   // remove all location history entries for this collection
   LOCATIONHISTORY *pHist, *pHistPrev;
   pHistPrev = NULL;
   pHist = pDelete->m_pHead;

   while (pHist)
   {
      if (pHist->CollectionNumber == m_dwColNo)
      {
         // head
         if (pHist == pDelete->m_pHead)
         {
            // and tail
            if (pHist == pDelete->m_pTail)
            {
               pDelete->m_pHead = NULL;
               pDelete->m_pTail = NULL;
               DeleteLocalFiles(pHist, pDelete);
               delete pHist;
               break;
            }
            pDelete->m_pHead = pHist->pNext;
            DeleteLocalFiles(pHist, pDelete);
            delete pHist;
            pHist = pDelete->m_pHead;
            pHistPrev = NULL;
            continue;
         }

         // tail
         if (pHist == pDelete->m_pTail)
         {
            pDelete->m_pTail = pHistPrev;
            if (pHistPrev)
               pHistPrev->pNext = NULL;
            DeleteLocalFiles(pHist, pDelete);
            delete pHist;
            break;
         }

         pHistPrev->pNext = pHist->pNext;
         DeleteLocalFiles(pHist, pDelete);
         delete pHist;
         pHist = pHistPrev->pNext;
      }
      else
      {
         pHistPrev = pHist;
         pHist = pHist->pNext;
      }
   }
    Dirty();

   // if no history remains remove the title
   if (pDelete->m_pHead != NULL)
      return F_OK;

   CTitle *p, *pPrev;

   p = m_pFirstTitle;
   pPrev = NULL;

   if (p== NULL)
      return F_NOTFOUND;

   while (p)
   {
      if (p == pDelete)
      {
         // is this the head
         if  (!pPrev)
         {
            m_pFirstTitle = p->GetNextTitle();
         }
         // is this the tail
         else if (p == m_pTitleTail)
         {
            m_pTitleTail = pPrev;
            pPrev->SetNextTitle(p->GetNextTitle());
         }
         else
         {
            // fixup the list
            pPrev->SetNextTitle(p->GetNextTitle());
         }

         delete p;
         return F_OK;
      }
      pPrev = p;
      p = p->GetNextTitle();
   }
   return F_NOTFOUND;
}

void CCollection::DeleteLocalFiles(LOCATIONHISTORY *pThisHist, CTitle *pTitle)
{
   if (m_bRemoveLocalFiles == FALSE)
        return;

   LOCATIONHISTORY *pHist;
   pHist = pTitle->m_pHead;

   // if the chm or chi is in use don't delete
   while (pHist)
   {
         if (strcmp(pHist->FileName, pThisHist->FileName) == 0)
            return;
         if (strcmp(pHist->IndexFileName, pThisHist->IndexFileName) == 0)
            return;
         pHist = pHist->pNext;
   }

   // if these are local files delete them
   char drive[_MAX_DRIVE+1];
   char dir[_MAX_DIR];
   char fname[_MAX_FNAME];
   char ext[_MAX_EXT];

   _splitpath( pThisHist->FileName, drive, dir, fname, ext );

    if(drive[1] == ':')
   {
       drive[2] = '\\';
      drive[3] = 0;
   }

   if (GetDriveType(drive) == DRIVE_FIXED)
   {
      // delete the title
      if (DeleteFile(pThisHist->FileName) == FALSE)
         m_bAllFilesDeleted = FALSE;
      // could need to check for and delete samples stuff here
   }

    // if files are different
    if (strcmp(pThisHist->IndexFileName, pThisHist->FileName))
   {
        _splitpath( pThisHist->IndexFileName, drive, dir, fname, ext );

        if(drive[1] == ':')
       {
          drive[2] = '\\';
          drive[3] = 0;
       }

      if (GetDriveType(drive) == DRIVE_FIXED)
      {
          // delete the index
          if (DeleteFile(pThisHist->IndexFileName) == FALSE)
              m_bAllFilesDeleted = FALSE;
          // could need to check for and delete samples stuff here
       }
    }
}


// only used from HHSETUP
LANGID CCollection::GetLangId(const CHAR *szFileName)
{
#ifdef HHSETUP
    return ::GetLangId(szFileName);
#else
    return 0;
#endif
}


DWORD CCollection::DeleteLocation(CLocation *pDelete)
{
   if (!pDelete)
      return F_NULL;
   CLocation *p, *pPrev;

   p = m_pFirstLocation;
   pPrev = NULL;

   if (p== NULL)
      return F_NOTFOUND;

   while (p)
   {
      if (p == pDelete)
      {
         // is this the head
         if  (!pPrev)
         {
            m_pFirstLocation = p->GetNextLocation();
         }
         // is this the tail
         else if (p == m_pLocationTail)
         {
            m_pLocationTail = pPrev;
            pPrev->SetNextLocation(NULL);
         }
         else
         {
            // fixup the list
            pPrev->SetNextLocation(p->GetNextLocation());
         }

         delete p;
       Dirty();
         return F_OK;
      }
      pPrev = p;
      p = p->GetNextLocation();
   }
   return F_NOTFOUND;
}


DWORD CCollection::RemoveCollection(BOOL bRemoveLocalFiles)
{
   // if release returns a positive ref count then don't delete
   if (Release())
      return F_OK;

   m_bRemoveLocalFiles = bRemoveLocalFiles;
   m_bAllFilesDeleted = TRUE;
   m_bRemoved = TRUE;

   CTitle *pT = GetFirstTitle();
   CTitle *pNext;
   while (pT)
   {
       pNext = pT->GetNextTitle();
       DeleteTitle(pT);
       pT  = pNext;
   }

   // delete locations for this collection
   CLocation *pL = FirstLocation();
   CLocation *pNextLoc;

   while (pL)
   {
        pNextLoc = pL->GetNextLocation();
        if (pL->m_ColNum == m_dwColNo)
            DeleteLocation(pL);
        pL = pNextLoc;
   }
	
   RemoveCollectionEntry(m_szFileName);

   Dirty();
   if (m_bRemoveLocalFiles == TRUE && m_bAllFilesDeleted == FALSE)
        return F_DELETE;
    return F_OK;
}

void CCollection::DeleteFolders(CFolder **p)
{
   CFolder *pChild, *pNext;
   if (pChild = (*p)->GetFirstChildFolder())
      DeleteFolders(&pChild);
   pNext = (*p)->GetNextFolder();

   // check if this is a title
   const CHAR *pTitle = (*p)->GetTitle();

   if (pTitle && pTitle[0] == '=')  // if so delete it.
   {
      CTitle *pT;

      pT = FindTitle(&pTitle[1], (*p)->GetLanguage());
      if (pT)
         DeleteTitle(pT);
   }

   delete (*p);
   *p = NULL;
   do {
      if (pNext)
         DeleteFolders(&pNext);
   } while (pNext && (pNext = pNext->GetNextFolder()));
}


// Merges the currently installed titles for the collection into the specified filename (path determined internally)
BOOL CCollection::MergeKeywords(CHAR * pwzFilename )
{
   return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CFolder implementation

CFolder::CFolder()
 {
   Title = NULL;
   pwcTitle = NULL;
   Order = 0;
   LangId = ENGLANGID;
   pNext = NULL;
   pKid = NULL;
   pParent = NULL;
   iLevel = 0;
   f_HasHash = 0;
   f_IsOrphan = 1;       // Assume the worst.
}

CFolder::~CFolder()
{
   if (Title)
      delete Title;
   if(pwcTitle)
       delete pwcTitle;
}

void CFolder::SetTitle(const  CHAR *sz)
{
   AllocSetValue(sz, &Title);
}

void CFolder::SetExTitlePtr(CExTitle* pTitle)
{
   CFolder* pTmp;

   pExTitle = pTitle;
   f_IsOrphan = 0;

   pTmp = pParent;
   while ( pTmp )
   {
      pTmp->f_IsOrphan = 0;
      pTmp = pTmp->pParent;
   }
}

void CFolder::SetOrder(DWORD newOrder)
{
   Order = newOrder;
}

DWORD CFolder::GetOrder()
{
   return Order;
}

// Returns the next sibling folder given a folder entry
CFolder * CFolder::GetNextFolder()
{
   return pNext;
}

// Returns the first child of a given folder if it exists
CFolder * CFolder::GetFirstChildFolder()
{
   return pKid;
}

CFolder * CFolder::AddChildFolder(const CHAR *szName, DWORD Order, DWORD *pError, LANGID LangId)
{
   CFolder *pFolder = new CFolder;

   if (pFolder == NULL)
      return NULL;

   pFolder->SetTitle(szName);
   pFolder->SetOrder(Order);
   pFolder->SetLanguage(LangId);

   DWORD dwrc = AddChildFolder(pFolder);
   if (pError)
      *pError = dwrc;
   return pFolder;
}

DWORD CFolder::AddChildFolder(CFolder *newFolder)
{
   CFolder* pTmp;
   newFolder->SetParent(this);
   if (pKid == NULL)
   {
      pKid = newFolder;
   }
   else
   {
      if (newFolder->GetOrder() < pKid->GetOrder())
      {
         // make this the first child
         newFolder->pNext = pKid;
         pKid = newFolder;
      }
      else
      {
         // search for an insertion point
         CFolder *pNext = pKid->pNext;
         CFolder *pPrev = pKid;
         while (pNext)
         {
            if (newFolder->GetOrder() < pNext->GetOrder())
            {
               newFolder->pNext = pNext;
               break;
            }
            pPrev = pNext;
            pNext = pNext->pNext;
         }
         pPrev->pNext = newFolder;
      }
   }
   //
   // Setup members to facilitate subsetting...
   //
   if ( newFolder->Title && newFolder->Title[0] == '=' )
   {
      newFolder->f_HasHash = 1;
      //
      // Leaf nodes will be rendered as open books in the subset dialog.
      //
      newFolder->f_A_Open = 1;
      newFolder->f_F_Open = 1;
   }
   pTmp = newFolder->pParent;
   while ( pTmp )
   {
      newFolder->iLevel++;
      pTmp = pTmp->pParent;
   }
   newFolder->iLevel--;
   return F_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CTitle implementation

void CTitle::SetId(const CHAR *sz)
{
   AllocSetValue(sz, &Id);
}

void CTitle::SetLanguage(LANGID l)
{
   Language = l;
}

CHAR *CTitle::GetId()
{
   return Id;
}

LANGID CTitle::GetLanguage()
{
   return Language;
}

LOCATIONHISTORY *CTitle::NewLocationHistory()
{
   LOCATIONHISTORY *p;

   p = new LOCATIONHISTORY;

   if (p == NULL)
      return NULL;

   p->SampleLocation = NULL;
   p->QueryLocation = NULL;
   p->FileName = NULL;
   p->IndexFileName = NULL;
   p->QueryFileName = NULL;
   p->LocationId = NULL;
   p->Version = 0;
   p->LastPromptedVersion = 0;
    p->bSupportsMerge = FALSE;
   p->pNext = NULL;

   if (m_pHead == NULL)
   {
      m_pHead = p;
   }
   else
   {
      m_pTail->pNext = p;
   }
   m_pTail = p;

   return p;
}


DWORD CTitle::AddLocationHistory(DWORD ColNo, const CHAR *FileName, const CHAR *IndexFile, const CHAR *Query, const CLocation *pLocation,  const CHAR *SampleLocation, const CHAR *QueryLocation, BOOL bSupportsMerge)
{
   LOCATIONHISTORY *p;
   // get version information
    DWORD dwNewVersion;
#ifdef HHSETUP
    if (IndexFile)
       dwNewVersion = GetTitleVersion(IndexFile);
    else  if (FileName)
       dwNewVersion = GetTitleVersion(FileName);
    else
        dwNewVersion = 0;
#else
    dwNewVersion = 0;
#endif

   // see of any current entries match is new one if so update the existing item.
    if (m_pHead)
   {
      p = m_pHead;

      while (p)
      {
            if (p->CollectionNumber == ColNo &&
                ((FileName == NULL && p->FileName[0] == NULL) || (FileName &&strcmp(p->FileName, FileName) == 0)) &&
                ((IndexFile == NULL && p->IndexFileName[0] == NULL) || (IndexFile &&strcmp(p->IndexFileName, IndexFile) == 0)) &&
                ((Query == NULL && p->QueryFileName[0] == NULL) || (Query &&strcmp(p->QueryFileName, Query) == 0)) &&
                ((SampleLocation == NULL && p->SampleLocation[0] == NULL) || (SampleLocation &&strcmp(p->SampleLocation, SampleLocation) == 0)) &&
                ((QueryLocation == NULL && p->QueryLocation[0] == NULL) || (QueryLocation &&strcmp(p->QueryLocation, QueryLocation) == 0)) &&
                p->bSupportsMerge == bSupportsMerge)
            {
                if (pLocation && strcmp(pLocation->GetId(), p->LocationId) != 0)
                {
                    p = p->pNext;
                    continue;
                }
                // everything matches just update the version number
                p->Version = dwNewVersion;
                return F_OK;
            }
           p = p->pNext;
      }
    }

    // see if we already have this version if so update to location
    if (m_pHead)
   {
      p = m_pHead;

      while (p)
      {
            if (p->Version == dwNewVersion && p->CollectionNumber == ColNo)
            {
                // same version update location
                p->bSupportsMerge = bSupportsMerge;
               if (FileName)
                  AllocSetValue(FileName, &p->FileName);
                else
                    p->FileName = NULL;

               if (IndexFile)
                  AllocSetValue(IndexFile, &p->IndexFileName);
                else
                    p->IndexFileName = NULL;

               if (SampleLocation)
                     AllocSetValue(SampleLocation, &p->SampleLocation);
                else
                    p->SampleLocation = NULL;

               if (QueryLocation)
                     AllocSetValue(QueryLocation, &p->QueryLocation);
                else
                    p->QueryLocation = NULL;

               if (Query)
                  AllocSetValue(Query, &p->QueryFileName);
                else
                    p->QueryFileName = NULL;

               if (pLocation)
                  AllocSetValue(pLocation->GetId() , &p->LocationId);
                else
                    p->LocationId = NULL;

                return F_OK;
            }
         p = p->pNext;
      }
    }

    p = NewLocationHistory();

   if (p == NULL)
      return F_MEMORY;

   p->Version = dwNewVersion;
   p->CollectionNumber = ColNo;
    p->bSupportsMerge = bSupportsMerge;
   if (FileName)
      AllocSetValue(FileName, &p->FileName);
   if (IndexFile)
      AllocSetValue(IndexFile, &p->IndexFileName);
   if (SampleLocation)
         AllocSetValue(SampleLocation, &p->SampleLocation);
   if (QueryLocation)
         AllocSetValue(QueryLocation, &p->QueryLocation);
   else
      AllocSetValue("", &p->QueryLocation);

   if (Query)
      AllocSetValue(Query, &p->QueryFileName);
   else
      AllocSetValue("", &p->QueryFileName);
      
   if (pLocation)
      AllocSetValue(pLocation->GetId() , &p->LocationId);

   return F_OK;
}

LOCATIONHISTORY * CTitle::GetLocation(DWORD Index)
{
   LOCATIONHISTORY *p;

   p = m_pHead;
   for (DWORD i = 0; p && i < Index; i++)
      p++;

   return p;
}

CTitle* CTitle::GetNextTitle()
{
   return NextTitle;
}

CTitle::~CTitle()
{
   if (Id) delete Id;
    if (pwcId)
       delete pwcId;

   // clean up location history
   LOCATIONHISTORY *p, *pNext;
   for (p = m_pHead; p; p=pNext)
   {
      pNext = p->pNext;
      if (p->FileName) delete p->FileName;
      if (p->IndexFileName) delete p->IndexFileName;
      if (p->QueryFileName) delete p->QueryFileName;
      if (p->LocationId) delete p->LocationId;
      if (p->SampleLocation) delete p->SampleLocation;
      if (p->QueryLocation) delete p->QueryLocation;
      delete p;
   }
}

CTitle::CTitle()
{
   Id = NULL;
   pwcId = NULL;
   Language = 0;
   NextTitle = NULL;
   m_pHead = NULL;
   m_pTail = NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CLocation implementation

// BUGBUG: 29-May-1997  [ralphw] This is a lot of code overhead to call
// functions that do nothing but return a value or exectue a single line
// of code. These should all be inlined, at least for the OCX version
// to cut down code size.

void CLocation::SetId(const CHAR *sz)
{
   AllocSetValue(sz, &Id);
}

void CLocation::SetTitle(const CHAR *sz)
{
   AllocSetValue(sz, &Title);
}

void CLocation::SetPath(const CHAR *sz)
{
   AllocSetValue(sz, &Path);
}

void CLocation::SetVolume(const CHAR *sz)
{
   AllocSetValue(sz, &Volume);
}

CHAR * CLocation::GetId() const
{
   return Id;
}

CHAR * CLocation::GetTitle()
{
   return Title;
}

CHAR * CLocation::GetPath()
{
   return Path;
}

CHAR * CLocation::GetVolume()
{
   return Volume;
}

// Returns the next location
CLocation * CLocation::GetNextLocation()
{
   return NextLocation;
}

// UNICODE APIs /////////////////////////////////////////////////////////////////////////////////////////////////
//

void CFolder::SetTitle(const WCHAR *pTitle)
{
    CAnsi cszTemp((WCHAR *)pTitle);
    SetTitle((char *)cszTemp);
}

const WCHAR * CFolder::GetTitleW()
{
    if(pwcTitle)
        delete [] pwcTitle;

    pwcTitle = CreateUnicodeFromAnsi(Title);

    return pwcTitle;
}

CFolder * CFolder::AddChildFolder(const WCHAR *szName, DWORD Order, DWORD *pError, LANGID LangId)
{
    CAnsi cszTemp1((WCHAR *)szName);
    return AddChildFolder((CHAR *)cszTemp1,Order,pError,LangId);
}


const WCHAR * CTitle::GetIdW()
{
    if(pwcId)
        delete [] pwcId;

    pwcId = CreateUnicodeFromAnsi(Id);

   return pwcId;
}

void CTitle::SetId(const WCHAR *pszId)
{
    CAnsi cszTemp1((WCHAR *)pszId);
    SetId((CHAR *)cszTemp1);
}

DWORD CTitle::AddLocationHistory(DWORD ColNo, const WCHAR *FileName, const WCHAR *IndexFile, const WCHAR *Query, const CLocation *pLocation, const WCHAR *Sample, const WCHAR *QueryLocation, BOOL bSupportsMerge)
{
    CAnsi cszTemp1((WCHAR *)FileName);
    CAnsi cszTemp2((WCHAR *)IndexFile);
    CAnsi cszTemp3((WCHAR *)Query);
    CAnsi cszTemp4((WCHAR *)Sample);
    CAnsi cszTemp5((WCHAR *)QueryLocation);
    return AddLocationHistory(ColNo, (CHAR *)cszTemp1, (CHAR *)cszTemp2, (CHAR *)cszTemp3, pLocation, (CHAR *)cszTemp4, (CHAR *)cszTemp5, bSupportsMerge);
}

void CLocation::SetId(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetId((CHAR *)cszTemp1);
}

void CLocation::SetTitle(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetTitle((CHAR *)cszTemp1);
}

void CLocation::SetPath(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetPath((CHAR *)cszTemp1);
}

void CLocation::SetVolume(const WCHAR *pwcTemp)
{
    CAnsi cszTemp1((WCHAR *)pwcTemp);
   SetVolume((CHAR *)cszTemp1);
}

const WCHAR * CLocation::GetIdW()
{
    if(pwcId)
        delete [] pwcId;

    pwcId = CreateUnicodeFromAnsi(Id);

   return pwcId;
}

const WCHAR * CLocation::GetTitleW()
{
    if(pwcTitle)
        delete [] pwcTitle;

    pwcTitle = CreateUnicodeFromAnsi(Title);

   return pwcTitle;
}

const WCHAR * CLocation::GetPathW()
{
    if(pwcPath)
        delete [] pwcPath;

    pwcPath = CreateUnicodeFromAnsi(Path);

    return pwcPath;
}

const WCHAR * CLocation::GetVolumeW()
{
    if(pwcVolume)
        delete [] pwcVolume;

    pwcVolume = CreateUnicodeFromAnsi(Volume);

    return pwcVolume;
}

DWORD CCollection::CheckTitleRef(const WCHAR *pId, const LANGID Lang)
{
    CAnsi cszTemp1((WCHAR *)pId);
    return CheckTitleRef(cszTemp1, Lang);
}

void CCollection::SetSampleLocation(const WCHAR *pwcItem1)
{
    CAnsi cszTemp1((WCHAR *)pwcItem1);
    SetSampleLocation(cszTemp1);
}

const WCHAR * CCollection::GetSampleLocationW()
{
    if(m_pwcSampleLocation)
        delete [] m_pwcSampleLocation;

    m_pwcSampleLocation = CreateUnicodeFromAnsi(m_szSampleLocation);

   return m_pwcSampleLocation;
}

void CCollection::SetMasterCHM(const WCHAR *szName, LANGID Lang)
{
    CAnsi cszTemp1((WCHAR *)szName);
    SetMasterCHM(cszTemp1, Lang);
}

BOOL CCollection::GetMasterCHM(WCHAR ** szName, LANGID *pLang)
{
   *pLang = m_MasterLangId;
    *szName = NULL;
   if (m_szMasterCHM == NULL)
      return FALSE;

    if(m_pwcMasterCHM)
        delete [] m_pwcMasterCHM;

    m_pwcMasterCHM = CreateUnicodeFromAnsi(m_szMasterCHM);

    *szName = m_pwcMasterCHM;

    return ((strlen(m_szMasterCHM) ? TRUE : FALSE));
}

DWORD CCollection::Open(const WCHAR * FileName)
{
    CAnsi cszTemp1((WCHAR *)FileName);
    return Open(cszTemp1);
}

CTitle * CCollection::FindTitle(const WCHAR * Id, LANGID LangId)
{
    CAnsi cszTemp1((WCHAR *)Id);
    return FindTitle(cszTemp1, LangId);
}

CLocation * CCollection::FindLocation(const WCHAR * Name, UINT* puiVolumeOrder)
{
    CAnsi cszTemp1((WCHAR *)Name);
    return FindLocation(cszTemp1,puiVolumeOrder);
}

CFolder * CCollection::AddFolder(const WCHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId)
{
    CAnsi cszTemp1((WCHAR *)szName);
    return AddFolder(cszTemp1, Order, pDWORD, LangId);
}

CTitle * CCollection::AddTitle(const WCHAR * Id, const WCHAR * FileName,
                               const WCHAR * IndexFile, const WCHAR * Query,
                               const WCHAR *SampleLocation, LANGID Lang,
                               UINT uiFlags, CLocation *pLocation,
                               DWORD *pDWORD,  BOOL bSupportsMerge,
                               const WCHAR *QueryLocation)
{
    CAnsi cszTemp1((WCHAR *)Id);
    CAnsi cszTemp2((WCHAR *)FileName);
    CAnsi cszTemp3((WCHAR *)IndexFile);
    CAnsi cszTemp4((WCHAR *)Query);
    CAnsi cszTemp5((WCHAR *)SampleLocation);
    CAnsi cszTemp6((WCHAR *)QueryLocation);
    return AddTitle(cszTemp1, cszTemp2, cszTemp3, cszTemp4,cszTemp5, Lang, uiFlags, pLocation, pDWORD, bSupportsMerge, cszTemp6);
}

CLocation * CCollection::AddLocation(const WCHAR * Title, const WCHAR * Path, const WCHAR * Id, const WCHAR * Volume, DWORD *pDWORD)
{
    CAnsi cszTemp1((WCHAR *)Title);
    CAnsi cszTemp2((WCHAR *)Path);
    CAnsi cszTemp3((WCHAR *)Id);
    CAnsi cszTemp4((WCHAR *)Volume);
    return AddLocation(cszTemp1, cszTemp2,cszTemp3,cszTemp4,pDWORD);
}


BOOL CCollection::MergeKeywords(WCHAR * pwzFilename )
{
    CAnsi cszTemp1((WCHAR *)pwzFilename);
    return MergeKeywords(cszTemp1);
}

const WCHAR *CCollection::GetCollectionFileNameW(void)
{
    if(m_pwcFileName)
        delete [] m_pwcFileName;

    m_pwcFileName = CreateUnicodeFromAnsi(m_szFileName);

    return m_pwcFileName;
}

LANGID CCollection::GetLangId(const WCHAR *FileName)
{
    CAnsi cszTemp1((WCHAR *)FileName);
    return GetLangId(cszTemp1);
}

WCHAR *CreateUnicodeFromAnsi(LPSTR psz)
{
    LPWSTR pwsz;
    int i;

    if(!psz)
        return NULL;

    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0)
        return NULL;

    pwsz = (LPWSTR) new WCHAR[i];

    if (!pwsz)
        return NULL;

    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i * sizeof(WCHAR));
    return pwsz;
}


CAnsi::CAnsi(WCHAR *pwcString)
{
    m_pszChar = NULL;

    int i;

    i =  WideCharToMultiByte(CP_ACP, 0, pwcString, -1, NULL, 0, NULL, NULL);

    if (i <= 0)
        return;

    m_pszChar = (CHAR *) new CHAR[i];

    WideCharToMultiByte(CP_ACP, 0, pwcString, -1, m_pszChar, i, NULL, NULL);
    m_pszChar[i - 1] = 0;
}

CAnsi::~CAnsi()
{
    if(m_pszChar)
        delete [] m_pszChar;
}


#ifdef HHCTRL

//
// CSlotLookupTable implementation...
//

int FASTCALL CSlotLookupTable::ltqs_callback(const void *elem1, const void *elem2)
{
   struct _slt* p1 = (struct _slt*)elem1;
   struct _slt* p2 = (struct _slt*)elem2;

   if ( p1->hash > p2->hash )
      return 1;
   else if ( p2->hash > p1->hash )
      return -1;
   else
      return 1;
}

CSlotLookupTable::CSlotLookupTable()
{
   m_pSLT = NULL;
   m_uiTotalCnt = m_uiHashCnt = m_uiTotalAllocated = 0;
}

CSlotLookupTable::~CSlotLookupTable()
{
   if ( m_pSLT )
      lcFree(m_pSLT);
}

void CSlotLookupTable::AddValue(CFolder* pFolder)
{
   if ( (m_uiTotalCnt &&  (!(m_uiTotalCnt % 8))) || (m_uiTotalAllocated == 0) )
   {
      m_uiTotalAllocated += 8;
      m_pSLT = (struct _slt*)lcReAlloc(m_pSLT, sizeof(struct _slt) * m_uiTotalAllocated);
   }
   m_pSLT[m_uiTotalCnt].pCFolder = pFolder;
   if ( pFolder->f_HasHash )
   {
      m_pSLT[m_uiTotalCnt].hash = pFolder->pExTitle->m_dwHash;
      m_uiHashCnt++;
   }
   else
      m_pSLT[m_uiTotalCnt].hash = (unsigned)(-1);
   m_uiTotalCnt++;
}

void CSlotLookupTable::SortAndAssignSlots(void)
{
   unsigned i;

   // First, sort by hash.
   //
   qsort(m_pSLT, m_uiTotalCnt, sizeof(struct _slt), ltqs_callback);
   //
   // Next, run through the table and assign the slots back to the CFolders.
   //
   for (i = 0; i < m_uiTotalCnt; i++)
      m_pSLT[i].pCFolder->dwSlot = i;
}

CFolder* CSlotLookupTable::HashToCFolder(HASH hash)
{
   if (! m_pSLT )
      return NULL;

   int mid,low = 0;
   int high = m_uiHashCnt - 1;

   while ( low <= high )
   {
      mid = ((low + high) / 2);
      if ( m_pSLT[mid].hash == hash )
         return m_pSLT[mid].pCFolder;                // Found it!
      else if ( m_pSLT[mid].hash > hash )
         high = mid - 1;
      else
         low = mid + 1;
   }
   return NULL;   // Oh bad!
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhdump\util.cpp ===
#include <windows.h>
#include "util.h"

#ifndef ASSERT
#if defined(_DEBUG) || defined(DEBUG)
#define ASSERT(b) if(!b) MessageBox(NULL, "FAILED: #b", "ASSERT", MB_OK );
#else
#define ASSERT(b)
#endif
#endif

#define MAX_STRING_RESOURCE_LEN 1024
LPCSTR g_pszMsgBoxTitle = "HTML Help Dumper Tool";

int MsgBox(int idString, UINT nType)
{
    char szMsg[MAX_STRING_RESOURCE_LEN + 1];
    if (LoadString(GetModuleHandle(NULL), idString, szMsg,
            sizeof(szMsg)) == 0) {
        return 0;
    }
    return MessageBox(GetActiveWindow(), szMsg, g_pszMsgBoxTitle, nType);
}

int MsgBox(PCSTR pszMsg, UINT nType)
{
    return MessageBox(GetActiveWindow(), pszMsg, g_pszMsgBoxTitle, nType);
}

PCSTR FindFilePortion( PCSTR pszFile )
{
  PCSTR psz = strrchr(pszFile, '\\');
  if (psz)
    pszFile = psz + 1;
  psz = strrchr(pszFile, '/');
  if (psz)
    return psz + 1;
  psz = strrchr(pszFile, ':');
  return (psz ? psz + 1 : pszFile);
}

typedef enum { JAN=1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } MONTHS;

int DaysInMonth(int nMonth, int nYear)
{
  switch( nMonth ) {
    case SEP: case APR: case JUN: case NOV:
      return 30;

    case FEB:
      return (nYear % 4) == 0 ? 29 : 28;      // handle leap year

    default:
      return 31;
  }
}

int JulianDate(int nDay, int nMonth, int nYear)
{
  int nDayOfYear = 0;
  int iMonth;

  for( iMonth = JAN ; iMonth < nMonth ; iMonth++ )
    nDayOfYear += DaysInMonth(iMonth, nYear);

  return( (nYear % 10) * 1000 + nDayOfYear + nDay );
}

#define YRMASK        0xFE00
#define YRSHIFT       9

#define MONMASK       0x01E0
#define MONSHIFT      5

#define DAYMASK       0x001F
#define DAYSHIFT      0

#define HRMASK        0xF800
#define HRSHIFT       11
#define MINMASK       0x07E0
#define MINSHIFT      5
#define SECMASK       0x001F
#define SECSHIFT      0

HRESULT FileTimeToDateTimeString( FILETIME FileTime, LPTSTR pszDateTime )
{
  HRESULT hr = S_FALSE;

  WORD wDosDate = 0;
  WORD wDosTime = 0;
  if( FileTimeToDosDateTime( &FileTime, &wDosDate, &wDosTime ) ) {
    DWORD dwDay    = (wDosDate & DAYMASK) >> DAYSHIFT;
    DWORD dwMonth  = (wDosDate & MONMASK) >> MONSHIFT;
    DWORD dwYear   = (((wDosDate & YRMASK) >> YRSHIFT) + 80) % 100;
    DWORD dwHour   = (wDosTime & HRMASK) >> HRSHIFT;
    DWORD dwMinute = (wDosTime & MINMASK) >> MINSHIFT;
    DWORD dwSecond = ((wDosTime & SECMASK) >> SECSHIFT) * 2;
    LPCSTR pszAMPM = NULL;

    if( dwHour >= 12 ) 
      pszAMPM = "PM";
    else
      pszAMPM = "AM";
    if( dwHour > 12 )
      dwHour -= 12;
    if( dwHour == 0 )
      dwHour = 12;

    wsprintf( pszDateTime, "%02d/%02d/%02d %02d:%02d %s", 
      dwMonth, dwDay, dwYear, dwHour, dwMinute, pszAMPM );

    hr = S_OK;
  }

  return hr;
}

int FileTimeToJulianDate( FILETIME FileTime )
{
  int iReturn = 0;

  WORD wDosDate = 0;
  WORD wDosTime = 0;
  if( FileTimeToDosDateTime( &FileTime, &wDosDate, &wDosTime ) ) {
    DWORD dwDay    = (wDosDate & DAYMASK) >> DAYSHIFT;
    DWORD dwMonth  = (wDosDate & MONMASK) >> MONSHIFT;
    DWORD dwYear   = ((wDosDate & YRMASK) >> YRSHIFT) + 1980;
    iReturn = JulianDate( dwDay, dwMonth, dwYear );
  }

  return iReturn;
}

///////////////////////////////////////////////////////////
//
// Get the windows directory for the system or the user
//
// Note, Windows NT Terminal Server has changed the system API
// of GetWindowsDirectory to return a per-user system directory.
// Inorder to determine this condtion we need to check kernel32
// for the GetSystemWindowsDirectory API and if it exists use
// this one instead.
//
UINT HHGetWindowsDirectory( LPSTR lpBuffer, UINT uSize, UINT uiType )
{
  UINT uiReturn = 0;
  PFN_GETWINDOWSDIRECTORY pfnGetUsersWindowsDirectory = NULL;
  PFN_GETWINDOWSDIRECTORY pfnGetSystemWindowsDirectory = NULL;

  // determine which system API to call for each case
  HINSTANCE hInst = LoadLibrary( "Kernel32" );
  if( !hInst )
    return uiReturn;

  pfnGetSystemWindowsDirectory = (PFN_GETWINDOWSDIRECTORY) GetProcAddress( hInst, "GetSystemWindowsDirectoryA" );
  pfnGetUsersWindowsDirectory = (PFN_GETWINDOWSDIRECTORY) GetProcAddress( hInst, "GetWindowsDirectoryA" );
  ASSERT( pfnGetUsersWindowsDirectory ); // if NULL then we have a bug!

  if( !pfnGetSystemWindowsDirectory ) {
    pfnGetSystemWindowsDirectory = pfnGetUsersWindowsDirectory;
  }


  if( uiType == HH_SYSTEM_WINDOWS_DIRECTORY )
    uiReturn = pfnGetSystemWindowsDirectory( lpBuffer, uSize );
  else if( uiType == HH_USERS_WINDOWS_DIRECTORY )
    uiReturn = pfnGetUsersWindowsDirectory( lpBuffer, uSize );
  else
    uiReturn = 0;

  FreeLibrary( hInst );
  return uiReturn;
}

LPSTR CatPath(LPSTR lpTop, LPCSTR lpTail)
{
    //
    // make sure we have a slash at the end of the first element
    //
    LPSTR p;

    p = lpTop + strlen(lpTop);
    p = CharPrev(lpTop,p);
    if (*p != '\\' && *p != '/')
    {
        strcat(lpTop,"\\");
    }

    //
    // strip any leading slash from the second element
    //

    while (*lpTail == '\\') lpTail = CharNext(lpTail);

    //
    // add them together
    //

    strcat(lpTop, lpTail);

    return lpTop;
}


#pragma data_seg(".text", "CODE")

static const char txtGlobal[] = "global.col";
static const char txtColReg[] = "hhcolreg.dat";
static const char txtHelp[]   = "help";
static const char txtHHDat[]  = "hh.dat";

#pragma data_seg()

///////////////////////////////////////////////////////////
//
// Get the help directory
//
// Note, this is always relative to the system's windows
// directory and not the user's windows directory.
// See HHGetWindowsDirectory for details on this.
//
UINT HHGetHelpDirectory( LPTSTR lpBuffer, UINT uSize )
{
  UINT uiReturn = 0;

  uiReturn = HHGetWindowsDirectory( lpBuffer, uSize );
  CatPath( lpBuffer, txtHelp );

  return uiReturn;
}

DWORD CreatePath(char *szPath)
{
   char szTmp[MAX_PATH],*p,*q,szTmp2[MAX_PATH];
   DWORD dwErr;

   strcpy(szTmp2,szPath);
   memset(szTmp,0,sizeof(szTmp));
   q = szTmp2;
   p = szTmp;

   while (*q)
   {
      if (*q == '/' || *q == '\\')
      {
         if (szTmp[1] == ':' && strlen(szTmp) <= 3)
         {
            if(IsDBCSLeadByte(*q))
         {
                *p++ = *q++;
            if(*q)
                    *p++ = *q++;
         }
         else
                *p++ = *q++;
            continue;
         }
         if (!::CreateDirectory(szTmp,0))
         {
            if ( (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS)
               return(dwErr);
         }
      }
      if(IsDBCSLeadByte(*q))
     {
          *p++ = *q++;
          if(*q)
            *p++ = *q++;
     }
     else
          *p++ = *q++;
   }
   if (!::CreateDirectory(szTmp,0))
   {
            if ((dwErr = GetLastError()) != ERROR_ALREADY_EXISTS)
               return(dwErr);
   }

   return(FALSE);
}

///////////////////////////////////////////////////////////
//
// Get the full pathname to the global collections file
//
// Note, this is in always in the system's help directory.
//
UINT HHGetGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize, BOOL *pbNewPath )
{
  UINT uiReturn = 0;

  *pbNewPath = TRUE;
  uiReturn = HHGetHelpDataPath( lpBuffer );

  if (uiReturn != S_OK)
  {
     *pbNewPath = FALSE;
     uiReturn = HHGetHelpDirectory( lpBuffer, uSize );
     if( !IsDirectory(lpBuffer) )
        CreatePath( lpBuffer );
  }   
  CatPath( lpBuffer, txtColReg );

  return uiReturn;
}

BOOL IsDirectory( LPCSTR lpszPathname )
{
  DWORD dwAttribs = GetFileAttributes( lpszPathname );
  if( dwAttribs != (DWORD) -1 )
    if( dwAttribs & FILE_ATTRIBUTE_DIRECTORY )
      return TRUE;
  return FALSE;
}

static const char txtProfiles[]        = "Profiles";
static const char txtUser[]            = "Default User";
static const char txtAllUsers[]        = "All Users";
static const char txtApplicationData[] = "Application Data";
static const char txtMicrosoft[]       = "Microsoft";
static const char txtHTMLHelp[]        = "HTML Help";
typedef HRESULT (WINAPI *PFN_SHGETFOLDERPATH)( HWND hWnd, int nFolder, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath );
#ifndef CSIDL_FLAG_CREATE
#define CSIDL_COMMON_APPDATA 0x0023      
#define CSIDL_FLAG_CREATE 0x8000
#endif


///////////////////////////////////////////////////////////
//
// Get the full path to where the common help data files lives
//  hhcolreg.dat, *.chw and *.chs
//
// Note, if the subdirectories of the path does not exist
// we will create them
//
HRESULT HHGetHelpDataPath( LPSTR pszPath )
{
  HRESULT hResult = S_OK;
  PFN_SHGETFOLDERPATH pfnSHGetFolderPath = NULL;

  HINSTANCE hInst = LoadLibrary( "Shell32" );
  if( !hInst )
    return S_FALSE;

  pfnSHGetFolderPath = (PFN_SHGETFOLDERPATH) GetProcAddress( hInst, "SHGetFolderPathA" );

  // if this function does not exist then we need to similate the return path of
  // "%windir%\Profiles\All Users\Application Data"
  if( pfnSHGetFolderPath ) {
    // now call it
    hResult = pfnSHGetFolderPath( NULL, CSIDL_FLAG_CREATE | CSIDL_COMMON_APPDATA, NULL, 0, pszPath);
    if (pszPath[0] == NULL)
    {
       FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
       return S_FALSE;
    }
  }
  else
  {
    FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
    return S_FALSE;
  }
  FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
      
  // append "Microsoft"
  CatPath( pszPath, txtMicrosoft );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  // append "HTML Help"
  CatPath( pszPath, txtHTMLHelp );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  return hResult;
}


///////////////////////////////////////////////////////////
//
// Get the full pathname to the user's data file
//
// Note, this is always relative to the users's windows
// directory and not the system's windows directory.
// See HHGetWindowsDirectory for details on this.
//
UINT HHGetUsersDataPathname( LPTSTR lpBuffer, UINT uSize )
{
  UINT uiReturn = 0;

  uiReturn = HHGetWindowsDirectory( lpBuffer, uSize, HH_USERS_WINDOWS_DIRECTORY );
  CatPath( lpBuffer, txtHHDat );

  return uiReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\collect.h ===
//*********************************************************************************************************************************************
//
//      File: collect.h
//  Author: Donald Drake
//  Purpose: Defines classes to support titles, collections, locations and folders

#ifndef _COLLECT_H
#define _COLLECT_H

#undef CLASS_IMPORT_EXPORT
#ifdef HHCTRL // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#ifndef HHCTRL

#undef COUNT
#define COUNT(x)

#undef MI_COUNT
#define MI_COUNT(x)

#undef SI_COUNT
#define SI_COUNT(x)

#undef MI2_COUNT
#define MI2_COUNT(x)

#undef AUTO_CLASS_COUNT_CHECK
#define AUTO_CLASS_COUNT_CHECK(x)

#undef CHECK_CLASS_COUNT
#define CHECK_CLASS_COUNT(x)

#undef DUMP_CLASS_COUNT
#define DUMP_CLASS_COUNT(x)

#endif

#ifdef HHCTRL
#include "parserhh.h"
#else
#include "parser.h"
#endif

#define  F_MSDN         0x0001
#define  F_TITLELOCAL   0x0002
#define  F_INDEXLOCAL   0x0004
#define  STARTINGCOLNO 10000

#define ENGLANGID 1033

#define MAX_LEVELS 100

typedef struct LocationHistory {
   CHAR * SampleLocation;
   CHAR * FileName;
   CHAR * IndexFileName;
   CHAR * QueryFileName;
   CHAR * LocationId;
   DWORD CollectionNumber;
   DWORD Version;
   DWORD LastPromptedVersion;
   BOOL bSupportsMerge;
   LocationHistory *pNext;
   CHAR * QueryLocation;
} LOCATIONHISTORY;

DWORD CLASS_IMPORT_EXPORT AllocSetValue(const CHAR *value, CHAR **dest);

// forward declarations
class CLocation;
class CTitle;
class CCollection;
class CFolder;
class CSlotLookupTable;
class CExTitle;
class CColList;

typedef struct ListItem {
   void *pItem;
   ListItem *Next;
} LISTITEM;

class CLASS_IMPORT_EXPORT CPointerList {
private:
   LISTITEM *m_pHead;

public:
   CPointerList()
   {
      m_pHead = NULL;
   }

   ~CPointerList();
   void RemoveAll();
   LISTITEM *Add(void *);
   LISTITEM *First();
   LISTITEM *Next(LISTITEM *p) { return p->Next; }
};

#ifdef HHCTRL // define this only when building the HHCtrl DLL

//
// <mc>
// This lookup table will facilitate a quick translation of a "slot" number into a CFolder* as well as a
// HASH value into a CFolder*. This will be done using two DWORDS per CFolder object, one for the HASH value
// and one for the CFolder*. After ALL the CFolders for a given collection have been created and this lookup
// table is fully populated the SortAndAssignSlots() member will be called. This will sort the table by HASH
// value and will assign the slot values back to the CFolders according to the sorted order. This will make
// slot --> CFolder* lookup a simple array index and will also allow us to use a bsearch for the
// HASH --> CFolder* lookup. Note that only leaf level CFolders have useful hash values, for the non leaf
// CFolders we will assign a hash of -1, these items in the table will then appear at the end of the table
// and will not interfear with a bsearch operation when translating a hash into a pSLT.
// </mc>
//
class CSlotLookupTable
{
public:
   CSlotLookupTable();
   ~CSlotLookupTable();

   static int FASTCALL ltqs_callback(const void *elem1, const void *elem2);
   void AddValue(CFolder* pFolder);
   void SortAndAssignSlots(void);
   CFolder* HashToCFolder(HASH hash);

   CFolder* SlotToCFolder(DWORD dwSlot)
   {
      if ( dwSlot > 0 && dwSlot <= m_uiTotalCnt )        // Slot 0 reserved for error case.
         return m_pSLT[dwSlot].pCFolder;
      else
         return NULL;
   }

private:
   struct _slt
   {
      HASH  hash;
      CFolder* pCFolder;
   };

   struct _slt*  m_pSLT;
   unsigned  m_uiTotalAllocated;
   unsigned  m_uiTotalCnt;
   unsigned  m_uiHashCnt;
};

#endif

class CLASS_IMPORT_EXPORT CFolder SI_COUNT(CFolder)
{
private:
   CHAR *Title;                           // name of the folder
   WCHAR *pwcTitle;
   DWORD Order;
   LANGID LangId;
   DWORD dwSlot;
   CExTitle* pExTitle;
   CFolder *pNext, *pKid, *pParent;
   //
   // This DWORD value is being added to support .CHM level subsetting.
   //
   WORD                     iLevel;
   WORD                     f_Filter:    1;  // render into filter LB.
   WORD                     f_Available: 1;  // render into Available LB.
   WORD                     f_F_Open:    1;  // Expanded or closed ?
   WORD                     f_A_Open:    1;  // Expanded or closed ?
   WORD                     f_HasHash:   1;  // Does Node have a prefix hash ?
   WORD                     f_IsOrphan:  1;  // Is this node an orphane ?
   WORD                     f_IsVisable: 1;  // Indicates membership in the currently selected TOC subset.

public:
   CFolder();
   ~CFolder();
   BOOL bIsVisable() { return (BOOL)f_IsVisable; }
   void SetTitle(const  CHAR *);
   void SetTitle(const  WCHAR *);
   void SetExTitlePtr(CExTitle* pTitle);
   CHAR *GetTitle() {  return Title; }
   const WCHAR *GetTitleW();
   void SetLanguage(LANGID Id) { LangId = Id; }
   LANGID GetLanguage() { return LangId; }
   void SetOrder(DWORD);
   DWORD GetOrder();
   // Returns the next sibling folder given a folder entry
   CFolder * GetNextFolder();
   void SetNextFolder(CFolder *p) { pNext = p; }
   // Returns the first child of a given folder if it exists
   CFolder * GetFirstChildFolder();
   void SetFirstChildFolder(CFolder *p) { pKid = p; }
   // Add a new folder as child of a given folder
   CFolder * AddChildFolder(const CHAR *szName, DWORD Order, DWORD *pError, LANGID LangId = ENGLANGID);
   CFolder * AddChildFolder(const WCHAR *szName, DWORD Order, DWORD *pError, LANGID LangId = ENGLANGID);
   DWORD AddChildFolder(CFolder *newFolder);
   void SetParent(CFolder *p) { pParent = p; }
   CFolder * GetParent() { return pParent; }

friend class CSlotLookupTable;
friend class CDefineSS;
friend class CStructuralSubset;

};

class CLASS_IMPORT_EXPORT CCollection SI_COUNT(CCollection)
{
public:
   CCollection();
   ~CCollection();
   void ConfirmTitles() { m_bConfirmTitles = TRUE; }
   void SetSampleLocation(const CHAR *);
   CHAR *GetSampleLocation();
   void SetMasterCHM(const CHAR *szName, LANGID Lang);
   BOOL GetMasterCHM(CHAR ** szName, LANGID *Lang);
   // Opens and loads the contents of the file into data structures
   DWORD Open(const CHAR * FileName);
   void SetSampleLocation(const WCHAR *);
   void SetFindMergedCHMS(BOOL bFind) { m_bFindMergedChms = bFind; }
   BOOL GetFindMergedCHMS() { return m_bFindMergedChms; }
   const WCHAR *GetSampleLocationW();
   void SetMasterCHM(const WCHAR *szName, LANGID Lang);
   BOOL GetMasterCHM(WCHAR ** szName, LANGID *Lang);
   // Opens and loads the contents of the file into data structures
   DWORD Open(const WCHAR * FileName);
   // Saves any changes made to the internal data structures to the file.
   DWORD Save();
   DWORD Close();

   void AddRef() { m_dwRef++; }

   DWORD GetVersion() { return m_dwVersion; }
   void SetVersion(DWORD dw) { m_dwVersion = dw; }
   // navigating the collection
   // Returns the first folder in the collection
   CFolder * GetRootFolder() { return m_pRootFolder; }
   CFolder * GetVisableRootFolder() { return m_pRootFolder->GetFirstChildFolder(); } // Returns the visable root.
   // Returns the first title
   CTitle * GetFirstTitle();
   // Locates a title based on id
   CTitle * FindTitle(const CHAR * Id, LANGID LangId = ENGLANGID);
   CTitle * FindTitle(const WCHAR * Id, LANGID LangId = ENGLANGID);
    // Try multiple LangIds, before failing.
#ifdef HHCTRL
    CTitle * FindTitleNonExact(const CHAR * Id, LANGID LangId) ;
#endif // #ifdef HHCTRL


   // Returns the first location
   CLocation* FirstLocation();
   // Finds a location based on a name
   CLocation * FindLocation(const CHAR * Name, UINT* puiVolumeOrder = NULL );

   // collection entry management
   CColList * FindCollection(CHAR *szFileName);
   CColList * AddCollection();
   void RemoveCollectionEntry(CHAR *szFileName);

   //Adds a new folder to the top level of the table of contents, with the given name and order and returns a pointer to that folder object.  A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
   CFolder * AddFolder(const CHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId = ENGLANGID);

   DWORD DeleteFolder(CFolder *);
   //Adds a title based on the provided information.
   //A return of NULL indicates a failure and pDWORD will be
   //populated with one of  above DWORD codes.  Note: you must add or
   //find a CLocation object or pass null to indication no location is in
   // use (local file).
   CTitle * AddTitle(const CHAR * Id, const CHAR * FileName, const CHAR * IndexFile,
              const CHAR * Query, const CHAR *SampleLocation, LANGID Lang,
              UINT uiFlags, CLocation *pLocation,  DWORD *pDWORD,
              BOOL bSupportsMerge = FALSE, const CHAR *QueryLocation = NULL);


   // Adds location based on the given information. A return of NULL indicates a failure and pDWORD will be populated with one of  above DWORD codes.
   CLocation * AddLocation(const CHAR * Title, const CHAR * Path, const CHAR * Id, const CHAR * Volume, DWORD *pDWORD);

   CLocation * FindLocation(const WCHAR * Name, UINT* puiVolumeOrder = NULL );
   CFolder * AddFolder(const WCHAR * szName, DWORD Order, DWORD *pDWORD, LANGID LangId = ENGLANGID);
   CTitle * AddTitle(const WCHAR * Id, const WCHAR * FileName,
              const WCHAR * IndexFile, const WCHAR * Query,
              const WCHAR *SampleLocation, LANGID Lang, UINT uiFlags,
              CLocation *pLocation,  DWORD *pDWORD,
              BOOL bSupportsMerge = FALSE, const WCHAR *QueryLocation = NULL);
   CLocation * AddLocation(const WCHAR * Title, const WCHAR * Path, const WCHAR * Id, const WCHAR * Volume, DWORD *pDWORD);

   DWORD RemoveCollection(BOOL bRemoveLocalFiles = FALSE);

   DWORD GetRefTitleCount() { return m_dwTitleRefCount; }
   // Merges the currently installed titles for the collection into the specified filename (path determined internally)
   BOOL MergeKeywords(CHAR * pwzFilename );
   BOOL MergeKeywords(WCHAR * pwzFilename );
   DWORD GetColNo() { return m_dwColNo; }
   PCSTR GetCollectionFileName(void) { return m_szFileName; }
   const WCHAR *GetCollectionFileNameW(void);
   BOOL IsDirty() { return m_bDirty;}
   void IncrementRefTitleCount() { m_dwTitleRefCount++; }
   void DecrementRefTitleCount() { m_dwTitleRefCount--; }
   void Dirty() { m_bDirty = TRUE; }

   LANGID GetLangId(const CHAR *FileName);
   LANGID GetLangId(const WCHAR *FileName);
private:  // functions

   DWORD AddRefedTitle(CFolder *pFolder);
   // removing objects
   DWORD DeleteTitle(CTitle *);
   void DeleteLocalFiles(LOCATIONHISTORY *pHist, CTitle *pTitle);
   DWORD DeleteLocation(CLocation *);

   DWORD CheckTitleRef(const CHAR *pId, const LANGID Lang);
   DWORD CheckTitleRef(const WCHAR *pId, const LANGID Lang);
   DWORD ParseFile(const CHAR *FileName);
   DWORD HandleCollection(CParseXML *parser, CHAR *sz);
   DWORD HandleCollectionEntry(CParseXML *parser, CHAR *sz);
   DWORD HandleFolder(CParseXML *parser, CHAR *token);
   DWORD HandleLocation(CParseXML *parser, CHAR *token);
   DWORD HandleTitle(CParseXML *parser, CHAR *token);
   void DeleteChildren(CFolder **p);
   void DeleteFolders(CFolder **p);
   BOOL WriteFolders(CFolder **p);
   BOOL WriteFolder(CFolder **p);
   DWORD AllocCopyValue(CParseXML *parser, CHAR *token, CHAR **dest);
   CTitle *NewTitle();
   CLocation *NewLocation();

private:
   BOOL m_bRemoveLocalFiles;
   BOOL m_bRemoved;
   DWORD Release();
   CHAR * m_szFileName;
   WCHAR * m_pwcFileName;
   CHAR * m_szMasterCHM;
   WCHAR * m_pwcMasterCHM;
   CHAR * m_szSampleLocation;
   WCHAR * m_pwcSampleLocation;
   LANGID m_MasterLangId;
   CTitle * m_pFirstTitle;
   CTitle * m_pTitleTail;
   CLocation * m_pFirstLocation;
   CLocation * m_pLocationTail;
   CFolder *m_pRootFolder;
   DWORD m_locationnum;
   CFIFOString m_Strings;
   CFolder *m_pParents[MAX_LEVELS];
   DWORD m_dwCurLevel;
   DWORD m_dwLastLevel;
   DWORD m_dwNextColNo;
   DWORD m_dwColNo;
   DWORD m_dwTitleRefCount;
   BOOL m_bConfirmTitles;
   BOOL m_bFindMergedChms;
   DWORD m_dwRef;
   DWORD m_dwVersion;
   HANDLE m_fh;
   BOOL m_bDirty;
   CColList *m_pColListHead;
   CColList *m_pColListTail;
public:
   CPointerList  m_RefTitles;
   BOOL m_bFailNoFile;
   BOOL m_bAllFilesDeleted;
};

class CColList
{
private:
	DWORD m_dwColNo;
	CHAR * m_szFileName;
	CColList *m_pNext;
public:
	CColList();
	~CColList();
	void SetColNo(DWORD dw) { m_dwColNo = dw; }
	void SetFileName(CHAR *szFileName);
	DWORD GetColNo() { return m_dwColNo; }
	CHAR *GetFileName() { return m_szFileName; }
	CColList *GetNext() { return m_pNext; }
	void SetNext(CColList *p) { m_pNext = p; }
};

class CLASS_IMPORT_EXPORT CTitle SI_COUNT(CTitle)
{
private:
   CHAR * Id;                      // Title identifier
   WCHAR *pwcId;
   LANGID  Language;               // language identifier
   CTitle *NextTitle;              // pointer to the next title
public:
   LOCATIONHISTORY *m_pHead, *m_pTail;
   void SetId(const CHAR *);
   void SetId(const WCHAR *);
   void SetLanguage(LANGID);
   CHAR * GetId();
   const WCHAR * GetIdW();
   LANGID GetLanguage();
   LOCATIONHISTORY *GetLocation(DWORD Index);
   CTitle* GetNextTitle();
   ~CTitle();
   CTitle();
   LOCATIONHISTORY *NewLocationHistory();
   DWORD AddLocationHistory(DWORD ColNo, const CHAR *FileName, const CHAR *IndexFile, const CHAR *Query, const CLocation *pLocation, const CHAR *Sample, const CHAR *QueryLocation, BOOL bSupportsMerge);
   DWORD AddLocationHistory(DWORD ColNo, const WCHAR *FileName, const WCHAR *IndexFile, const WCHAR *Query, const CLocation *pLocation, const WCHAR *Sample, const WCHAR *QueryLocation, BOOL bSupportsMerge);
   void SetNextTitle(CTitle *p) { NextTitle = p; }
};

class CLASS_IMPORT_EXPORT CLocation SI_COUNT(CLocation)
{
private:
   CHAR * Id;
   CHAR * Title;                          // Friendly name for the title
   CHAR * Path;                           // location of the device
   CHAR * Volume;
   WCHAR * pwcId;
   WCHAR * pwcTitle;                          // Friendly name for the title
   WCHAR * pwcPath;                           // location of the device
   WCHAR * pwcVolume;
   CLocation *NextLocation;        // pointer to the next location if it exists
public:
   DWORD m_ColNum;
   CLocation()
   {
      Id = NULL;
      Title = NULL;
      Path = NULL;
      Volume = NULL;
      NextLocation = NULL;
        pwcId = NULL;
        pwcTitle = NULL;
        pwcPath = NULL;
        pwcVolume = NULL;
    }

   ~CLocation()
   {
      if (Id)
         delete Id;
      if (Title)
         delete Title;
      if (Path)
         delete Path;
      if (Volume)
         delete Volume;
      if (pwcId)
         delete pwcId;
      if (pwcTitle)
         delete pwcTitle;
      if (pwcPath)
         delete pwcPath;
      if (pwcVolume)
         delete pwcVolume;
   }

   void SetNextLocation(CLocation *p) { NextLocation = p; }
   void SetId(const CHAR *);
   void SetTitle(const CHAR *);
   void SetPath(const CHAR *);
   void SetVolume(const CHAR *);
   CHAR * GetId() const;
   CHAR * GetTitle();
   CHAR * GetPath();
   CHAR * GetVolume();
   void SetId(const WCHAR *);
   void SetTitle(const WCHAR *);
   void SetPath(const WCHAR *);
   void SetVolume(const WCHAR *);
   const WCHAR * GetIdW();
   const WCHAR * GetTitleW();
   const WCHAR * GetPathW();
   const WCHAR * GetVolumeW();

   // Returns the next location
   CLocation *GetNextLocation();
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\info.h ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _SYSTEM_H_
#define _SYSTEM_H_

#include "..\hhctrl\fs.h"

typedef enum {
    TAG_DEFAULT_TOC,        // needed if no window definitions
    TAG_DEFAULT_INDEX,      // needed if no window definitions
    TAG_DEFAULT_HTML,       // needed if no window definitions
    TAG_DEFAULT_CAPTION,    // needed if no window definitions
    TAG_SYSTEM_FLAGS,
    TAG_DEFAULT_WINDOW,
    TAG_SHORT_NAME,    // short name of title (ex. root filename)
    TAG_HASH_BINARY_INDEX,
    TAG_INFO_TYPES,
    TAG_COMPILER_VERSION,   // specifies the version of the compiler used
    TAG_TIME,               // the time the file was compiled
} SYSTEM_TAG_TYPE;

typedef struct {
    WORD tag;
    WORD cbTag;
} SYSTEM_TAG;

typedef struct {
    LCID    lcid;
    BOOL    fDBCS;  // Don't use bitflags! Can't assume byte-order
    BOOL    fFTI;   // full-text search enabled
    BOOL    fKeywordLinks;
    BOOL    fALinks;
  FILETIME FileTime; // title uniqueness (should match .chi file)
} SYSTEM_FLAGS;

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation - read in the title informaton file (#SYSTEM) settings for each title
//

class CTitleInformation
{
public:
    CTitleInformation( CFileSystem* pFileSystem );
    ~CTitleInformation();

    inline LPCSTR   GetShortName() { Init(); return m_pszShortName; }
    inline LPCSTR   GetTitleName() { Init(); return m_pszTitleName; }
    inline FILETIME GetFileTime() { Init(); return m_Settings.FileTime; }
    inline LCID     GetLanguage() { Init(); return m_Settings.lcid; }
    inline BOOL     IsKeywordLinks() { Init(); return m_Settings.fKeywordLinks; }
    inline BOOL     IsAssociativeLinks() { Init(); return m_Settings.fALinks; }
    inline BOOL     IsFullTextSearch() { Init(); return m_Settings.fFTI; }
    inline BOOL     IsDoubleByte() { Init(); return m_Settings.fDBCS; }
    inline LPCSTR   GetCompilerVersion() { Init(); return m_pszCompilerVersion; }

    HRESULT Initialize();

private:
    inline BOOL     Init() { if( !m_bInit ) Initialize(); return m_bInit; }

    BOOL           m_bInit;         // self-initing class
    CFileSystem*   m_pFileSystem;   // title file system handle
    SYSTEM_FLAGS   m_Settings;      // simple title information settings
    LPCSTR         m_pszShortName;  // short title name
    LPCSTR         m_pszTitleName;  // title name
    LPCSTR         m_pszCompilerVersion; // compiler version
};

/////////////////////////////////////////////////////////////////////////////////////////////
// CTitleInformation2 - get title informaton without going through the file system
//

class CTitleInformation2
{
public:
    CTitleInformation2( LPCTSTR pszPathName );
    ~CTitleInformation2();

    inline LPCTSTR  GetShortName() { Init(); return m_pszShortName; }
    inline FILETIME GetFileTime()  { Init(); return m_FileTime; }
    inline LCID     GetLanguage()  { Init(); return m_lcid; }

    HRESULT Initialize();

private:
    inline BOOL    Init() { if( !m_bInit ) Initialize(); return m_bInit; }

    BOOL           m_bInit;        // self-initing class
    LPCTSTR        m_pszPathName;  // title pathname
    LPCTSTR        m_pszShortName; // short title name
    LCID           m_lcid;         // language
    FILETIME       m_FileTime;     // file time
};

HRESULT DumpTitleInformation( CFileSystem* pFileSystem );
HRESULT DumpTitleInformation2( CFileSystem* pFileSystem );

#endif // _SYSTEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\hhctrlex.h ===
// Copyright  1995-1997  Microsoft Corporation.  All Rights Reserved.

// This header file can only be used by non-UNICODE programs

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _HHCTRLEX_H_
#define _HHCTRLEX_H_

#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus

PSTR  stristr(PCSTR pszMain, PCSTR pszSub);  // case-insensitive string search
PSTR  FirstNonSpace(PCSTR psz); 			 // return pointer to first non-space character
PSTR  StrChr(PCSTR pszString, char ch); 	 // DBCS-aware character search
PSTR  StrRChr(PCSTR pszString, char ch);	 // DBCS-aware character search
DWORD WinHelpHashFromSz(PCSTR pszKey);		 // converts string into a WinHelp-compatible hash number

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _HHCTRLEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\initguid.cpp ===
// INITGUID.CPP -- Code file where the DLL's guid structures are instantiated.

// Note: Do not use precompiled headers with this file! They can cause problems
// because we need to change the interpretation of DEFINE_GUID by defining the
// symbol INITGUID. In some cases using precompiled headers generates incorrect
// code for that case.

#define INITGUID

// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#define NOATOM
#define NOCOMM
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOEXTDEVMODEPROPSHEET
#define NOIME
#define NOKANJI
#define NOLOGERROR
#define NOMCX
#define NOPROFILER
#define NOSCALABLEFONT
#define NOSERVICE
#define NOSOUND

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>

// place all interfaces here that need their objects instantiated

// Tome
#include "MSITStg.h"

// Centaur
#include "itquery.h"
#include "itgroup.h"
#include "itpropl.h"
#include "itrs.h"
#include "itdb.h"
#include "itww.h"

// Centaur compiler
#include "itcc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\funcs.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

#define SETTHIS(hwnd)        SetWindowLong(hwnd, GWL_USERDATA, reinterpret_cast<LONG>(this));
#define GETTHIS(Class,hwnd)  (reinterpret_cast<Class*>(GetWindowLong(hwnd, GWL_USERDATA)))
#define DESTROYIFVALID(hwnd) if (IsValidWindow(hwnd)) DestroyWindow(hwnd);

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

#define UnregisterControlObject UnregisterAutomationObject

#define ELEMENTS(array) (sizeof(array) / sizeof(array[0]))

#define HH_URL_PREFIX_LESS  1
#define HH_URL_UNQUALIFIED  2
#define HH_URL_QUALIFIED    3
#define HH_URL_JAVASCRIPT   ((UINT)-2)
#define HH_URL_UNKNOWN      ((UINT)-1)

// *********************** Assertion Definitions ************************** //

// Get rid of any previously defined versions

#undef ASSERT
#undef VERIFY

#ifndef THIS_FILE
#define THIS_FILE __FILE__
#endif

// *********************** Function Prototypes **************************** //

#if defined(_DEBUG)
void AssertErrorReport(PCSTR pszExpression, UINT line, LPCSTR pszFile);
#endif

class CStr; // forward reference

// functions formerly in hhctrlex.h
#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus
//PSTR  stristr(PCSTR pszMain, PCSTR pszSub);  // case-insensitive string search
PSTR  FirstNonSpace(PCSTR psz); 			 // return pointer to first non-space character
WCHAR *FirstNonSpaceW(WCHAR *psz); 			 // return pointer to first non-space character
//PSTR  StrChr(PCSTR pszString, char ch); 	 // DBCS-aware character search
PSTR  StrRChr(PCSTR pszString, char ch);	 // DBCS-aware character search
DWORD WinHelpHashFromSz(PCSTR pszKey);		 // converts string into a WinHelp-compatible hash number
#ifdef __cplusplus
}
#endif // __cplusplus

BOOL __cdecl _FormatMessage(LPCSTR szTemplate, LPSTR szBuf, UINT cchBuf, ...);

LRESULT WINAPI HelpWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ChildWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

DWORD       CreatePath(PSTR pszPath);
void        AddTrailingBackslash(PSTR psz);
LPSTR       CatPath(LPSTR lpTop, LPCSTR lpTail);
HWND        ChangeHtmlTopic(PCSTR pszFile, HWND hwndChild, BOOL bHighlight = FALSE);
BOOL        CheckForLicense();
BOOL        CheckLicenseKey(LPWSTR wszCheckme);
void        CheckWindowPosition(RECT* prc, BOOL fAllowShrinkage);
void        ConvertBackSlashToForwardSlash(PSTR pszUrl);
void        ConvertSpacesToEscapes(PCSTR pszSrc, CStr* pcszDst);
BOOL        ConvertToCacheFile(PCSTR pszSrc, PSTR pszDst);
int         ConvertWz(const WCHAR * pwz, char * psz, int len);
HPALETTE    CreateBIPalette(PBITMAPINFOHEADER pbihd);
HRESULT     CreateComponentCategory(GUID catid, WCHAR* catDescription);
void        CreateDefaultWindowType(PCSTR pszCompiledFile, PCSTR pszWindow);
BOOL        CreateFolder(PCSTR pszPath);
int         IEColorToWin32Color( PCWSTR pwsz );
HFONT       CreateUserFont(PCSTR pszFont, COLORREF* pclrFont = NULL, HDC hDC = NULL, INT charset = -1);
HFONT       CreateUserFontW(WCHAR *pszFont, COLORREF* pclrFont = NULL, HDC hDC = NULL, INT charset = -1);
void        DeleteAllHmData();
BOOL        DeleteKeyAndSubKeys(HKEY hk, LPSTR pszSubKey);
BOOL        DlgOpenFile(HWND hwndParent, PCSTR pszFile, CStr* pcsz);
BOOL        DlgOpenDirectory(HWND hwndParent, CStr* pcsz);
void        doAuthorMsg(UINT idStringFormatResource, PCSTR pszSubString);
HWND        doDisplayIndex(HWND hwndCaller, LPCSTR pszFile, LPCTSTR pszKeyword);
HWND        doDisplayToc(HWND hwndCaller, LPCSTR pszFile, DWORD dwData);
void        doHhctrlVersion(HWND hwndParent, PCSTR pszCHMVersion);
void        doHHWindowJump(PCSTR pszUrl, HWND hwndChild);
BOOL        doJumpUrl(HWND hwndParent, PCSTR pszCurUrl, PSTR pszDstUrl);
void        doRelatedTopics(HWND);
HWND        doTpHelpWmHelp(HWND hwndMain, LPCSTR pszFile, DWORD ulData);
HWND        doTpHelpContextMenu(HWND hwndMain, LPCSTR pszFile, DWORD ulData);
BOOL        FindDarwinURL(PCSTR pszGUID, PCSTR pszChmFile, CStr* pcszResult);
PCSTR       FindEqCharacter(PCSTR pszLine);
PCSTR       FindFilePortion(PCSTR pszFile);
HWND        FindMessageParent(HWND hwndChild);
BOOL        FindThisFile(HWND hwndParent, PCSTR pszFile, CStr* pcszFile, BOOL fAskUser = TRUE);
HWND        FindTopLevelWindow(HWND hwnd);
DWORD       GetButtonDimensions(HWND hwnd, HFONT hFont, PCSTR psz);
PCSTR       GetCompiledName(PCSTR pszName, CStr* pcsz);
BOOL        GetHighContrastFlag(void);
PSTR        GetLeftOfEquals(PCSTR pszString);
BSTR        GetLicenseKey(void);
HWND        GetParentSize(RECT* prcParent, HWND hwndParent, int padding, int navpos);
HWND        GetParkingWindow(void);
void        GetRegWindowsDirectory(PSTR pszDstPath);
void        GetScreenResolution(HWND hWnd, RECT* prc);
void        GetWorkArea() ;
DWORD       GetStaticDimensions(HWND hwnd, HFONT hFont, PCSTR psz, int max_len );
DWORD       GetStaticDimensionsW(HWND hwnd, HFONT hFont, WCHAR *psz, int max_len );
PCSTR       GetStringResource(int idString);
PCSTR       GetStringResource(int idString, HINSTANCE);
PCWSTR      GetStringResourceW(int idString);
PCWSTR      GetStringResourceW(int idString, HINSTANCE);
HASH        HashFromSz(PCSTR pszKey);
int         HHA_Msg(UINT command, WPARAM wParam = 0, LPARAM lParam = 0);
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
HWND        xHtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD dwData);
HWND        xHtmlHelpW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD dwData);
BOOL        IsCollectionFile(PCSTR pszFile);
BOOL        IsCompiledURL( PCSTR pszFile );
UINT        GetURLType( PCSTR pszURL );
BOOL        IsCompiledHtmlFile(PCSTR pszFile, CStr* pcszFile = NULL);
BOOL        IsHelpAuthor(HWND hwndCaller);
BOOL        IsSamePrefix(PCWSTR pwszMain, PCWSTR pwszSub, int cchPrefix = -1);
BOOL        IsSamePrefix(PCSTR pszMain, PCSTR pszSub, int cbPrefix = -1);
BOOL        IsThisAWinHelpFile(HWND hwndCaller, PCSTR pszFile);
BOOL        IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);
BOOL        IsValidString(LPCSTR lpsz, int nLength = -1);
BOOL        IsValidString(LPCWSTR lpsz, int nLength = -1);
void        ItDoesntWork(void);
LPWSTR      MakeWideStr(LPSTR psz, UINT codepage);
LPWSTR      MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR      MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR      MakeWideStrFromWide(LPWSTR, BYTE bType);
void        MemMove(void * dst, const void * src, int count);
BOOL        MoveClientWindow(HWND hwndParent, HWND hwndChild, const RECT *prc, BOOL fRedraw);
LPVOID      OleAlloc(UINT cb);
void        OleFree(LPVOID pb);
HRESULT     OleInitMalloc(void);
HWND        OnDisplayPopup(HWND hwndCaller, LPCSTR pszFile, DWORD dwData);
HWND        OnDisplayTopic(HWND hwndCaller, LPCSTR pszFile, DWORD dwData);
HWND        OnHelpContext(HWND hwndCaller, LPCSTR pszFile, DWORD dwData);
void        OOM(void);
BOOL        PaintShadowBackground(HWND hwnd, HDC hdc, COLORREF clrBackground = (COLORREF) -1);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);
void        QSort(void *pbase, UINT num, UINT width, int (FASTCALL *compare)(const void *, const void *));
BOOL        RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject);
HRESULT     RegisterCLSIDInCategory(REFCLSID clsid, GUID catid);
BOOL        RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId);
void        RegisterOurWindow();
BOOL        RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject);
BOOL        RegSetMultipleValues(HKEY hkey, ...);
void        RemoveTrailingSpaces(PSTR pszString);
void        SendStringToParent(PCSTR pszMsg);
PSTR        StrToken(PSTR pszList, PCSTR pszDelimeters);
PSTR        SzTrimSz(PSTR pszOrg);
BOOL        UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
HRESULT     UnRegisterCLSIDInCategory(REFCLSID clsid, GUID catid);
BOOL        UnregisterData(void);
BOOL        UnregisterTypeLibrary(REFCLSID riidLibrary);
BOOL        UnregisterUnknownObject(REFCLSID riidObject);

UINT HHGetHelpDirectory( LPSTR lpBuffer, UINT uSize );
UINT HHGetGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize , BOOL *pbNewPath);
UINT HHGetOldGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize );

HRESULT HHGetUserDataPath( LPSTR pszPath );
HRESULT HHGetUserDataPath( LPSTR pszPath );
HRESULT HHGetHelpDataPath( LPSTR pszPath );
HRESULT HHGetUserDataPathname( LPSTR lpBuffer, UINT uSize );
HRESULT HHGetCurUserDataPath( LPSTR pszPath );

// Internal API definitions.
#include "hhpriv.h"
// Look for the information in the hhcolreg.dat file.
int         GetLocationFromTitleTag(LPCSTR szCollection, HH_TITLE_FULLPATH* pTitleFullPath) ;

int FASTCALL CompareIntPointers(const void *pval1, const void *pval2);
void FASTCALL Itoa(int val, PSTR pszDst);
int FASTCALL Atoi(PCSTR psz);

// *********************** Debug/Internal Functions ********************** //

#ifdef _DEBUG

// IASSERT is available in _DEBUG builds

#define IASSERT(exp) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(#exp, __LINE__, THIS_FILE)); \
    }

#define IASSERT_COMMENT(exp, pszComment) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(pszComment, __LINE__, THIS_FILE)); \
    }

#else

#define IASSERT(exp)
#define IASSERT_COMMENT(exp, pszComment)

#endif

#ifdef _DEBUG

#define ASSERT(exp) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(#exp, __LINE__, THIS_FILE)); \
    }

#define ASSERT_COMMENT(exp, pszComment) \
    { \
        ((exp) ? (void) 0 : \
            AssertErrorReport(pszComment, __LINE__, THIS_FILE)); \
    }

#define FAIL(pszComment) AssertErrorReport(pszComment, __LINE__, THIS_FILE);

#define VERIFY(exp)     ASSERT(exp)
#define VERIFY_RESULT(exp1, exp2)   ASSERT((exp1) == (exp2))
#define DEBUG_ReportOleError doReportOleError
void doReportOleError(HRESULT hres);
__inline void DBWIN(PCSTR psz) {
    SendStringToParent(psz);
    SendStringToParent("\r\n");
}

#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else // non-debugging version

#define ASSERT(exp)
#define ASSERT_COMMENT(exp, pszComment)
#define VERIFY(exp) ((void)(exp))
#define VERIFY_RESULT(exp1, exp2) ((void)(exp))
#define DEBUG_ReportOleError(hres)
#define DBWIN(psz)
#define FAIL(pszComment)
#define CHECK_POINTER(val)

#define THIS_FILE  __FILE__

#endif

// zero fill everything after the vtbl pointer
#define ZERO_INIT_CLASS(base_class) \
    ClearMemory((PBYTE) ((base_class*) this) + sizeof(base_class*), \
        sizeof(*this) - sizeof(base_class*));
#define ZERO_STRUCTURE(foo) ClearMemory(&foo, sizeof(foo))
#define ClearMemory(p, cb) memset(p, 0, cb)

__inline void StrCopyWide(LPWSTR psz1, LPCWSTR psz2) {
    while (*psz1++ = *psz2++);
}

// HHA functions

extern int (__stdcall *pDllMsgBox)(int idFormatString, PCSTR pszSubString, UINT nType);
extern PCSTR (__stdcall *pGetDllStringResource)(int idFormatString);

void WINAPI AWMessagePump(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\ipserver.h ===
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _IPSERVER_H_
#define _IPSERVER_H_

#include <windows.h>
//#include <basetyps.h>
#include <docobj.h> 				   // for offsetof()
#include <olectl.h>

//=--------------------------------------------------------------------------=
// we don't want to use the CRTs, and would like some memory tracking in the
// debug case, so we'll override these guys
//=--------------------------------------------------------------------------=

void * _cdecl operator new(size_t size);
void  _cdecl operator delete(void *ptr);

//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=

#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions

#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.

#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define QUICK_RELEASE(ptr)	   if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)	   if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface

#define Data1_IAdviseSink				   0x0000010f
#define Data1_IAdviseSink2				   0x00000125
#define Data1_IAdviseSinkEx 			   0x3af24290
#define Data1_IBindCtx					   0x0000000e
#define Data1_ICDataDoc 				   0xF413E4C0
#define Data1_IClassFactory 			   0x00000001
#define Data1_IClassFactory2			   0xb196b28f
#define Data1_IConnectionPoint			   0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95				   0x9a4bbfb5
#define Data1_IControl					   0xa7fddba0
#define Data1_ICreateErrorInfo			   0x22f03340
#define Data1_ICreateTypeInfo			   0x00020405
#define Data1_ICreateTypeLib			   0x00020406
#define Data1_IDataAdviseHolder 		   0x00000110
#define Data1_IDataFrame				   0x97F254E0
#define Data1_IDataFrameExpert			   0x73687490
#define Data1_IDataObject				   0x0000010e
#define Data1_IDispatch 				   0x00020400
#define Data1_IDropSource				   0x00000121
#define Data1_IDropTarget				   0x00000122
#define Data1_IEnumCallback 			   0x00000108
#define Data1_IEnumConnectionPoints 	   0xb196b285
#define Data1_IEnumConnections			   0xb196b287
#define Data1_IEnumFORMATETC			   0x00000103
#define Data1_IEnumGeneric				   0x00000106
#define Data1_IEnumHolder				   0x00000107
#define Data1_IEnumMoniker				   0x00000102
#define Data1_IEnumOLEVERB				   0x00000104
#define Data1_IEnumSTATDATA 			   0x00000105
#define Data1_IEnumSTATSTG				   0x0000000d
#define Data1_IEnumString				   0x00000101
#define Data1_IEnumOleUndoActions		   0xb3e7c340
#define Data1_IEnumUnknown				   0x00000100
#define Data1_IEnumVARIANT				   0x00020404
#define Data1_IErrorInfo				   0x1cf2b120
#define Data1_IExternalConnection		   0x00000019
#define Data1_IFont 					   0xbef6e002
#define Data1_IFontDisp 				   0xbef6e003
#define Data1_IFormExpert				   0x5aac7f70
#define Data1_IGangConnectWithDefault	   0x6d5140c0
#define Data1_IInternalMoniker			   0x00000011
#define Data1_ILockBytes				   0x0000000a
#define Data1_IMalloc					   0x00000002
#define Data1_IMarshal					   0x00000003
#define Data1_IMessageFilter			   0x00000016
#define Data1_IMoniker					   0x0000000f
#define Data1_IMsoCommandTarget 		   0xb722bccb
#define Data1_IMsoDocument				   0xb722bcc5
#define Data1_IOleInPlaceComponent		   0x5efc7970
#define Data1_IMsoView					   0xb722bcc6
#define Data1_IOleAdviseHolder			   0x00000111
#define Data1_IOleCache 				   0x0000011e
#define Data1_IOleCache2				   0x00000128
#define Data1_IOleCacheControl			   0x00000129
#define Data1_IOleClientSite			   0x00000118
#define Data1_IOleCompoundUndoAction	   0xa1faf330
#define Data1_IOleContainer 			   0x0000011b
#define Data1_IOleControl				   0xb196b288
#define Data1_IOleControlSite			   0xb196b289
#define Data1_IOleInPlaceActiveObject	   0x00000117
#define Data1_IOleInPlaceFrame			   0x00000116
#define Data1_IOleInPlaceObject 		   0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite			   0x00000119
#define Data1_IOleInPlaceSiteEx 		   0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow		   0x00000115
#define Data1_IOleItemContainer 		   0x0000011c
#define Data1_IOleLink					   0x0000011d
#define Data1_IOleManager				   0x0000011f
#define Data1_IOleObject				   0x00000112
#define Data1_IOlePresObj				   0x00000120
#define Data1_IOlePropertyFrame 		   0xb83bb801
#define Data1_IOleStandardTool			   0xd97877c4
#define Data1_IOleUndoAction			   0x894ad3b0
#define Data1_IOleUndoActionManager 	   0xd001f200
#define Data1_IOleWindow				   0x00000114
#define Data1_IPSFactory				   0x00000009
#define Data1_IPSFactoryBuffer			   0xd5f569d0
#define Data1_IParseDisplayName 		   0x0000011a
#define Data1_IPerPropertyBrowsing		   0x376bd3aa
#define Data1_IPersist					   0x0000010c
#define Data1_IPersistFile				   0x0000010b
#define Data1_IPersistPropertyBag		   0x37D84F60
#define Data1_IPersistStorage			   0x0000010a
#define Data1_IPersistStream			   0x00000109
#define Data1_IPersistStreamInit		   0x7fd52380
#define Data1_IPicture					   0x7bf80980
#define Data1_IPictureDisp				   0x7bf80981
#define Data1_IPointerInactive			   0x55980ba0
#define Data1_IPropertyNotifySink		   0x9bfbbc02
#define Data1_IPropertyPage 			   0xb196b28d
#define Data1_IPropertyPage2			   0x01e44665
#define Data1_IPropertyPage3			   0xb83bb803
#define Data1_IPropertyPageInPlace		   0xb83bb802
#define Data1_IPropertyPageSite 		   0xb196b28c
#define Data1_IPropertyPageSite2		   0xb83bb804
#define Data1_IProvideClassInfo 		   0xb196b283
#define Data1_IProvideDynamicClassInfo	   0x6d5140d1
#define Data1_IQuickActivate			   0xcf51ed10
#define Data1_IRequireClasses			   0x6d5140d0
#define Data1_IRootStorage				   0x00000012
#define Data1_IRunnableObject			   0x00000126
#define Data1_IRunningObjectTable		   0x00000010
#define Data1_ISelectionContainer		   0x6d5140c6
#define Data1_IServiceProvider			   0x6d5140c1
#define Data1_ISimpleFrameSite			   0x742b0e01
#define Data1_ISpecifyPropertyPages 	   0xb196b28b
#define Data1_IStdMarshalInfo			   0x00000018
#define Data1_IStorage					   0x0000000b
#define Data1_IStream					   0x0000000c
#define Data1_ISupportErrorInfo 		   0xdf0b3d60
#define Data1_ITypeComp 				   0x00020403
#define Data1_ITypeInfo 				   0x00020401
#define Data1_ITypeLib					   0x00020402
#define Data1_IUnknown					   0x00000000
#define Data1_IViewObject				   0x0000010d
#define Data1_IViewObject2				   0x00000127
#define Data1_IViewObjectEx 			   0x3af24292
#define Data1_IWeakRef					   0x0000001a
#define Data1_ICategorizeProperties 	   0x4d07fc10

#define QI_INHERITS(pObj, itf)				\
	case Data1_##itf:						\
	  if(DO_GUIDS_MATCH(riid, IID_##itf))	 \
	  { 									\
		*ppvObjOut = (void *)(itf *)pObj;	\
	  } 									\
	  break;

#endif // _IPSERVER_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\fs.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "header.h"

#include "fs.h"

static const WCHAR txtwUncompressed[] =  L"uncompressed";

CFileSystem::CFileSystem()
{
   m_pITStorage    = NULL;
   m_pStorage      = NULL;
   m_szPathName[0] = 0;
}

CFileSystem::~CFileSystem()
{
  ReleaseObjPtr(m_pStorage);
  ReleaseObjPtr(m_pITStorage);
}

HRESULT CFileSystem::Init(void)
{
   if (! m_pITStorage) {
      IClassFactory* pICFITStorage;

      HRESULT hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **) &pICFITStorage);

      if (!SUCCEEDED(hr))
         return hr;

      hr = pICFITStorage->CreateInstance(NULL, IID_ITStorage,(void **) &m_pITStorage);
      ReleaseObjPtr( pICFITStorage );

      if (!SUCCEEDED(hr))
         return hr;

   }
   return S_OK;
}

typedef struct tagITSControlData
{
   UINT cdwFollowing;          // Must be 6 or 13
   DWORD cdwITFS_Control;      // Must be 5
   DWORD dwMagicITS;           // Must be MAGIC_ITSFS_CONTROL (see below)
   DWORD dwVersionITS;         // Must be 1
   DWORD cbDirectoryBlock;     // Size in bytes of directory blocks (Default is 8192)
   DWORD cMinCacheEntries;     // Least upper bound on the number of directory blocks
                               // which we'll cache in memory. (Default is 20)
   DWORD fFlags;               // Control bit flags (see below).
                               // Default value is fDefaultIsCompression.
   UINT  cdwControlData;       // Must be 6
   DWORD dwLZXMagic;           // Must be LZX_MAGIC (see below)
   DWORD dwVersion;            // Must be 2
   DWORD dwMulResetBlock;      // Number of blocks between compression resets.  (Default: 4)
   DWORD dwMulWindowSize;      // Maximum number of blocks kept in data history (Default: 4)
   DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
   DWORD dwOptions;            // Option flags (Default: fOptimizeCodeStreams)
} ITCD;

HRESULT CFileSystem::Create( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 13;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 4096;     // default = 8192
   itcd.cMinCacheEntries  = 10;       // default = 20
   itcd.fFlags            = 1;        // 0 == Uncompressed, 1 == Compressed.
   itcd.cdwControlData        = 6;
   itcd.dwLZXMagic            = LZX_MAGIC;
   itcd.dwVersion             = 2;
   itcd.dwMulResetBlock       = 2;    // Default = 4
   itcd.dwMulWindowSize       = 2;    // Default = 4
   itcd.dwMulSecondPartition  = 1;    // Default = 2
   itcd.dwOptions             = 0;    // Default = fOptimizeCodeStreams

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

// NOTE: The below function is required for the ITIR full-text indexer to
//     initialize.  I'm working to find out why this is and what impact
//     the below has on the file system.
//
HRESULT CFileSystem::CreateUncompressed( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 6;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 8192;     // default = 8192
   itcd.cMinCacheEntries  = 20;        // default = 20
   itcd.fFlags            = 0;        // 0 == Uncompressed, 1 == Compressed.

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CFileSystem::Open(PCSTR pszPathName, DWORD dwAccess)
{
   HRESULT hr = S_OK;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgOpenStorage( (LPCWSTR) wsz, NULL, dwAccess, NULL, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return hr;
}

HRESULT CFileSystem::Compact(LPCSTR pszPathName)
{
   WCHAR wszPathName[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, wszPathName, sizeof(wszPathName));
   m_pITStorage->Compact(wszPathName, COMPACT_DATA_AND_PATH);

   return S_OK;
}

HRESULT CFileSystem::Close()
{
   ReleaseObjPtr(m_pStorage);

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Here are a set of "sub" file I/O calls.
//
//
CSubFileSystem::CSubFileSystem(CFileSystem* pFS)
{
   m_pFS = pFS;
   m_pStorage = NULL;
   m_pStream = NULL;
   m_szPathName[0] = 0;
}

CSubFileSystem::~CSubFileSystem()
{
   if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
      ReleaseObjPtr(m_pStorage);

   ReleaseObjPtr(m_pStream);
}

HRESULT CSubFileSystem::CreateSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';

      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);

      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;
   IStorageITEx* pIStorageEx;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateSystemFile(PCSTR pszPathName)
{
   m_pStorage = m_pFS->m_pStorage;
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   HRESULT hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSystemFile(PCSTR pszPathName)
{
   IStorageITEx* pIStorageEx;
   HRESULT hr;

   m_pStorage = m_pFS->m_pStorage;

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::OpenSub(PCSTR pszPathName, DWORD dwAccess)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   if ((pszFilePortion = FindFilePortion(pszPathName)) &&
         pszFilePortion > pszPathName + 2) // +2 to support / && ./
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, dwAccess, NULL, 0, &m_pStorage);

      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage ? m_pFS->m_pStorage : m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->OpenStream(wszStream, NULL, dwAccess, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

ULONG CSubFileSystem::WriteSub(const void* pData, int cb)
{
   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   ULONG cbWritten;

   HRESULT hr = m_pStream->Write(pData, cb, &cbWritten);

   if (!SUCCEEDED(hr) || (cbWritten != (ULONG)cb) )
   {
      return (ULONG) -1;
   }
   // REVIEW: 30-May-1997  [ralphw] Why are we returning this? We fail if
   // we don't write cb bytes.
   return cbWritten;
}

/*
 * iOrigin:
 *    0 = Seek from beginning.
 *    1 = Seek from current.
 *    2 = Seek from end.
 */
ULONG CSubFileSystem::SeekSub(int cb, int iOrigin)
{
   LARGE_INTEGER liCount = {0,0};
   ULARGE_INTEGER liNewPos;

   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   liCount.LowPart = cb;
   HRESULT hr =  m_pStream->Seek(liCount, iOrigin, &liNewPos);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return liNewPos.LowPart;
}

//
// Pre-allocate the size of the stream.
//

HRESULT CSubFileSystem::SetSize(unsigned uSize)
{
   ULARGE_INTEGER liSize = {0,0};
   HRESULT hr;

   if ( !m_pStorage || !m_pStream )
      return E_FAIL;

   liSize.LowPart = uSize;
   hr =  m_pStream->SetSize(liSize);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return hr;
}

//
// Delete substorage.
//
HRESULT
CSubFileSystem::DeleteSub()
{
    if (m_pStorage)
    {
        if (m_pStream)
        {
            // Release the stream.
            ReleaseObjPtr(m_pStream) ;
        }

        // Now delete the storage.
        WCHAR element[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szPathName, -1, (PWSTR) element, MAX_PATH);

        HRESULT hr = m_pStorage->DestroyElement(element) ;
        if (SUCCEEDED(hr))
        {
            // Get back to the constructor state.
            if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
            {
                ReleaseObjPtr(m_pStorage);
            }
            return S_OK ;
        }
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\ctable.h ===
//  Copyright (C) Microsoft Corporation 1993-1997

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef DESCRIPTION

        The CTable class is used for storing strings or data which will be
        freed in one call when the destructor is called.

#endif // DESCRIPTION

#ifndef _CTABLE_INCLUDED
#define _CTABLE_INCLUDED

typedef struct {
    int cb;
    PCSTR pMem;
} TABLE_FREED_MEMORY;

const int OFF_FILENAME   = 5;           // offset to filename

class CTable ;

class CTable SI_COUNT(CTable)
{
public:
    CTable();
    CTable(int cbStrings); // cbStrings == maximum memory allocated for strings
    virtual ~CTable();
    const CTable& operator=(const CTable& tblSrc);  // copy constructor

    UINT GetPosFromPtr(PCSTR psz);

    // Used for ALink -- adds index, hit number, and string

    void  AddIndexHitString(UINT index, UINT hit, PCSTR pszString);
    UINT  GetIndex(int pos) { ASSERT(pos > 0 && pos < endpos); return *(UINT*) ppszTable[pos]; };
    UINT  GetHit(int pos) { ASSERT(pos > 0 && pos < endpos); return *(UINT*) (ppszTable[pos] + sizeof(UINT)); };
    PSTR  GetIHPointer(int pos) { ASSERT(pos > 0 && pos < endpos); return  (ppszTable[pos] + (sizeof(UINT) * 2)); };

    /*
     REVIEW: this is the complete set from ..\common\ctable.h. We use
     very few of these. Theoretically, this shouldn't have any impact
     on the size of WinHelp (linker should toss all non-used functions).
     One alternative would be to create a derived class from the
     ctable.h/ctable.cpp in the ..\common directory, and add the
     above functions to the derived class.
     */

    int   AddData(int cb, const void* pdata);
    int   AddIntAndString(int lVal, PCSTR psz);
    int   AddString(PCSTR  pszString);
    int   AddString(PCWSTR  pszString);
    int   AddString(PCSTR pszStr1, PCSTR pszStr2);
    int   AddString(HASH hash, PCSTR psz) {
                    return AddIntAndString((int) hash, psz); };
    int   CountStrings(void) const { return endpos - 1; }
    void  Empty(void);
    void  FreeMemory(PCSTR psz, int cb);
    BOOL  GetIntAndString(int* plVal, PSTR pszDst);
    int   GetInt(int pos) { return *(int *) ppszTable[pos]; }
    BOOL  GetHashAndString(HASH* phash, PSTR pszDst) {
                    return GetIntAndString((int*) phash, pszDst); };
    BOOL  GetHashAndString(HASH* phash, PSTR pszDst, int pos) {
                    SetPosition(pos);
                    return GetIntAndString((int*) phash, pszDst); };
    PSTR  GetHashStringPointer(int pos) { return ppszTable[pos] + sizeof(HASH); };
    PSTR  GetPointer(int pos) const { return ppszTable[pos]; };
    int   GetPosition(void) const { return curpos; }
    BOOL  GetString(PSTR pszDst);
    BOOL  GetString(PSTR pszDst, int pos) const;
    int   IsPrimaryStringInTable(PCSTR pszString) const;
    int   IsSecondaryStringInTable(PCSTR pszString) const;
    int   IsStringInTable(PCSTR pszString) const;
    int   IsStringInTable(HASH hash, PCSTR pszString) const;
    int   IsCSStringInTable(PCSTR pszString) const;
    BOOL  ReplaceString(PCSTR pszNewString, int pos);
    BOOL FASTCALL SetPosition(int pos = 1);
    virtual void  SortTable(int sortoffset = 0);
    void FASTCALL SetSorting(LCID lcid, DWORD fsCompareI = 0, DWORD fsCompare = 0);
    void  SortTablei(int sortoffset = 0);
    PSTR  TableMalloc(int cb);
    void  IncreaseTableBuffer(void);
    int   IsHashInTable(HASH hash);
    __inline PCSTR* GetStringPointers() { return (PCSTR*) ppszTable; }

    /*
     * Use this for efficient memory allocation for strings that will not
     * be freed until the entire CIndex is freed.
     */

    __inline PCSTR StrDup(PCSTR psz) { return strcpy(TableMalloc(strlen(psz) + 1), psz); }

    // Warning! all variables must match hha\ctable.h

    PSTR    pszBase;
    PSTR *  ppszTable;

    int     cbMaxBase;
    int     cbMaxTable;

    int     endpos;
    int     maxpos;

protected:
    int     curpos;
    int     CurOffset;
    int     cbStrings;
    int     cbPointers;
    int     SortColumn;
    LCID    lcid;
    DWORD   fsCompareI;
    DWORD   fsCompare;
    DWORD   fsSortFlags;
    int     m_sortoffset;

    TABLE_FREED_MEMORY* m_pFreed;   // pointer to freed memory
    int m_cFreedMax;                // number of allocated items
    int m_cFreedItems;              // current number of freed items

    // following are used by sort

    PSTR    pszTmp;
    int     j, sTmp;

    void  doSort(int left, int right);
    void  doLcidSort(int left, int right);
    void  doSorti(int left, int right);
    void  InitializeTable();
    void  Cleanup(void);

};

// retrieves only MBCS strings from the base CTable
// and converts them to Unicode according to the codepage
//
class CWTable : private CTable
{
public:

  CWTable( UINT CodePage );
  CWTable( int cbStrings, UINT CodePage );
  virtual ~CWTable();

  // new methods that return Unicode buffers
  HRESULT GetStringW( int pos, WCHAR* pwsz, int cch );
  HRESULT GetHashStringW( int pos, WCHAR* pwsz, int cch );
  inline UINT GetCodePage() { return m_CodePage; }

  // stuff from CTable we want to give access to
  CTable::CountStrings;
  CTable::AddString;
  CTable::IsStringInTable;
  CTable::AddIntAndString;
  CTable::SetSorting;
  CTable::SortTable;
  CTable::GetInt;

  // stuff from CTable that returns the MBCS string--BEWARE!!!
  CTable::GetString;
  CTable::GetStringPointers;
  CTable::GetHashStringPointer;


private:

  void _CWTable( UINT CodePage );


  UINT m_CodePage;

};

#endif  // _CTABLE_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itcat.h ===
// ITCAT.H:	IITCatalog interface declaration

#ifndef __ITCAT_H__
#define __ITCAT_H__

#include <comdef.h>

// {F21B1A31-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(IID_IITCatalog,
0xf21b1a31, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#ifdef ITPROXY

// {F21B1A32-A9F2-11d0-A871-00AA006C7D01}
DEFINE_GUID(CLSID_IITCatalog,
0xf21b1a32, 0xa9f2, 0x11d0, 0xa8, 0x71, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daaa-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCatalogLocal,
0x4662daaa, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Forward declarations
interface IITDatabase;
interface IITResultSet;

DECLARE_INTERFACE_(IITCatalog, IUnknown)
{
	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszwName = NULL) PURE;
	STDMETHOD(Close)(void) PURE;
	STDMETHOD(Lookup)(IITResultSet* pRSIn, IITResultSet* pRSOut = NULL) PURE;
	STDMETHOD(GetColumns)(IITResultSet* pRS) PURE;
};

typedef IITCatalog* LPITCATALOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\hhpriv.h ===
///////////////////////////////////////////////////////////
//
//
// private.h --- Private API
//
//
#ifndef __PRIVATE_H__
#define __PRIVATE_H__

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

#pragma pack(push, 8) // REVIEW: Why doesn't htmlhelp.h have this?

//////////////////////////////////////////////////////////
//
// Private APIs
//
#define HH_TITLE_PATHNAME           0x00ff
#define HH_HELP_CONTEXT_COLLECTION  0x00fe   // Does a HELP Context in the Collection Space
#define HH_PRETRANSLATEMESSAGE2     0x0100   // Fix for millinium pretranslate problem. Bug 7921

// Reloads the navigation panes with data from new CHM.
#define HH_RELOAD_NAV_DATA          0x00fb  // (hwndCaller, pszFile>windowtype, NULL)

// Gets a pointer to the WebBrowser control.
#define HH_GET_BROWSER_INTERFACE    0x00fa // (hWndOfBrowserParent, NULL,,IWebBrowser)

// For Microsoft Installer -- dwData is a pointer to the GUID string
#define HH_SET_GUID             0x001A
// For Microsoft Installer -- dwData is a pointer to the GUID string
#define HH_SET_BACKUP_GUID      0x001B

///////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct tagHH_TITLE_FULLPATH
{
    LCID lcid ;             // [in]     The LCID of the collection to find.
    LPCSTR szTag ;          // [in]     The tag to be looked up. (CHM name = tag for UI chm's) .
    BSTR fullpathname ;    // [out]    The full pathname to the CHM.
} HH_TITLE_FULLPATH ;

///////////////////////////////////////////////////////////////////////////////
//
//
//
typedef struct tagHH_COLLECTION_CONTEXT
{
    LPCSTR      szTag;
    LCID        lcid;   // lcid of the context.
    DWORD        id ;
} HH_COLLECTION_CONTEXT;

///////////////////////////////////////////////////////////////////////////////
//
// Nav Data structure for reloading the nav panes.
//
typedef struct tagHH_NAVDATA
{
    LPCWSTR pszName ;   // Name of the window type. Must be global.
    LPCWSTR pszFile ;   // Name of the CHM file which contains the new nav data.
} HH_NAVDATA ;

#pragma pack(pop)

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __PRIVATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itcc.h ===
/************************************************************************
 *
 * ITCC.H
 *
 * Copyright (c) Microsoft Corporation 1993 - 1997
 * All rights reserved.
 *
 *************************************************************************
 *
 * Module intent:
 *
 * This module contains the API (Application Programming Interface)
 * for creating and updating ITIR objects and storages
 *
 *************************************************************************
 *
 * Current owner: JohnRush
 *
 ************************************************************************/

#ifndef _ITCC_H // {
#define _ITCC_H

#include "itpropl.h"
#include "itdb.h"

// Document property macros
#define STDPROP_UID         1
#define STDPROP_TITLE       2
#define STDPROP_USERDATA    3
#define STDPROP_KEY         4

#define STDPROP_SORTKEY		100
#define STDPROP_DISPLAYKEY	101
#define STDPROP_SORTORDINAL 102

#define STDPROP_INDEX_TEXT    200
#define STDPROP_INDEX_VFLD    201
#define STDPROP_INDEX_DTYPE   202
#define STDPROP_INDEX_LENGTH  203
#define STDPROP_INDEX_BREAK   204

#define STDPROP_INDEX_TERM              210
#define STDPROP_INDEX_TERM_RAW_LENGTH   211

#define STDPROP_USERPROP_BASE   0x00010000
#define STDPROP_USERPROP_MAX    0x7FFFFFFF

// Property destinations for word wheels
#define SZ_WWDEST_GLOBAL    L"GLOBAL"
#define SZ_WWDEST_KEY       L"KEY"
#define SZ_WWDEST_OCC       L"OCC"


// {4662daa2-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITCmdInt,
0x4662daa2, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa3-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITSvMgr,
0x4662daa3, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4CF34C30-9BF9-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITCmdInt,
0x4cf34c30, 0x9bf9, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4E7DA031-9C11-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITSvMgr,
0x4e7da031, 0x9c11, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4662daa5-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelUpdate,
0x4662daa5, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
    
// {8fa0d5a5-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITBuildCollect,
0x8fa0d5a5, 0xdedf, 0x11d0, 0x9a, 0x61, 0x0, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa4-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupUpdate,
0x4662daa4, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITIndexBuild,
0x8fa0d5aa, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWWFilterBuild,
0x8fa0d5ab, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

struct VARARG
{
    DWORD   dwArgc;
    void    *Argv[20];
};

// Document class
class CSvDoc
{
public:
    virtual HRESULT WINAPI ResetDocTemplate (void) PURE;

    virtual HRESULT WINAPI AddObjectEntry(LPCWSTR lpObjName, IITPropList *pPL) PURE;
    virtual HRESULT WINAPI AddObjectEntry
        (LPCWSTR lpObjName, LPCWSTR szPropDest, IITPropList *pPL) PURE;
};

// Service manager class
DECLARE_INTERFACE_(IITSvMgr, IUnknown)
{
    STDMETHOD(Initiate)(IStorage *pistgStorage, IStream *piistmLog) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(Build)(void) PURE;
	STDMETHOD(SetPropDest)
        (LPCWSTR szObjectName, LPCWSTR szDestination, IITPropList *pPL) PURE;
	STDMETHOD(CreateBuildObject)(LPCWSTR pwstrObjectName, REFCLSID refclsid) PURE;
    STDMETHOD(GetBuildObject)
        (LPCWSTR pwstrObjectName, REFIID refiid, void **pInterface) PURE;

	STDMETHOD(CreateDocTemplate)(CSvDoc **ppDoc) PURE;
	STDMETHOD(FreeDocTemplate)(CSvDoc *pDoc) PURE;
	STDMETHOD(AddDocument)(CSvDoc *pDoc) PURE;

	STDMETHOD(HashString)(IN LPCWSTR lpwstr, OUT DWORD *pdwHash) PURE;
};

// Command Interpreter Interface
DECLARE_INTERFACE_(IITCmdInt, IUnknown)
{
	STDMETHOD(Initiate)(IITSvMgr *piitsv) PURE;
	STDMETHOD(Dispose)(void) PURE;
	STDMETHOD(LoadFromStream)(IStream *pMVPStream, IStream *pLogStream) PURE;
};

typedef struct tagHelperInfo
{
    UINT    CodePage;
    LCID    lcid;
    DWORD   argc1;
    DWORD   *argv1;
    DWORD   argc2;
    LPWSTR  *argv2;
} HelperInfo, *PHelperInfo;

// This structure is sent to IITBuildCollect::SetBuildStats
typedef struct tagIITBOCI
{
    DWORD dwSize;   // Must be set to size of this structure
    DWORD dwMaxUID; // The highest uid authored for this title
} ITBuildObjectControlInfo;

DECLARE_INTERFACE_(IITBuildCollect, IUnknown)
{
    STDMETHOD(SetConfigInfo)(IITDatabase *piitdb, VARARG vaParams) PURE;
	STDMETHOD(InitHelperInstance)(DWORD dwHelperObjInstance,
        IITDatabase *pITDatabase, DWORD dwCodePage,
        LCID lcid, VARARG vaDword, VARARG vaString) PURE;
	STDMETHOD(SetEntry)(LPCWSTR szDest, IITPropList *pPropList) PURE;
	STDMETHOD(Close)(void) PURE;
    STDMETHOD(GetTypeString)(LPWSTR wstrType, DWORD *pLength) PURE;
    STDMETHOD(SetBuildStats)(ITBuildObjectControlInfo &itboci) PURE;
};


#endif // _ITCC_H }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\hhsetup.cpp ===
// ------------------------------------------------------------------------
//
//                        Microsoft Visual Studio
//               Copyright (c) 1997 Microsoft Corporation
//
// ------------------------------------------------------------------------
// MODULE    : hhsetup.cpp
// PURPOSE   : stub dll
// FUNCTIONS :
// COMMENTS  :
// ------------------------------------------------------------------------
#define   STRICT               // strict type checking enabled
// #define   _UNICODE            // make the application Unicode compliant (C/C++)
// #define   UNICODE             // make the application Unicode compliant (Win32)
#include <Windows.H>           // required for all Windows applications

#include "fs.h"
#include "info.h"
#include "util.h"
#include "stdio.h"

// public defines
// ------------------------------------------------------------------------

// public data
// ------------------------------------------------------------------------

// public function prototypes
// -----------------------------------------------------------------------
DWORD GetTitleVersion(const TCHAR *szFileName);
DWORD GetFileVersion(const TCHAR *szFileName);
LANGID GetLangId(const TCHAR *szFileName);
// private defines
// ------------------------------------------------------------------------

// private data
// ------------------------------------------------------------------------
static HINSTANCE g_hInstance = 0;

// private function prototypes
// -----------------------------------------------------------------------

// callback procedures prototypes
// -----------------------------------------------------------------------

// ========================================================================
//           ==  Standard Windows Entry Point Function ==
// ========================================================================

// ------------------------------------------------------------------------
// DllMain
//
// @Doc   WINDOWS BOTH
// @Func  DllMain is the Win32 internal entry point.  DllMain is called
//        by the C run-time library from the _DllMainCRTStartup entry
//        point.  The DLL entry point gets called (entered) on the
//        following events: "Process Attach", "Thread Attach",
//        "Thread Detach" or "Process Detach".
// @Parm: (NONE)
// @RDesc:(NONE)
// @Comm: (NONE)
// ------------------------------------------------------------------------
BOOL WINAPI DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved )
{
  switch( dwReason ) {

   case DLL_PROCESS_ATTACH:
    // to your init stuff here
    g_hInstance = hDll;
    break;

   case DLL_THREAD_ATTACH:
   case DLL_THREAD_DETACH:
     break;

   case DLL_PROCESS_DETACH:
     // free you init stuff here
     g_hInstance = 0;
     break;

  }

  return( TRUE );
  UNREFERENCED_PARAMETER( lpReserved );
}

DWORD GetTitleVersion(const TCHAR *szFileName)
{
  WCHAR wszFileSysName[MAX_PATH];  // UNICODE filename buffer
  CHAR  szFileSysName[MAX_PATH];   // MBCS filename buffer
  HRESULT hr;

   // Create destination storage names
  LPTSTR pszFilename = NULL;
  GetFullPathName( szFileName, MAX_PATH, szFileSysName, &pszFilename );
  if (0 == MultiByteToWideChar(CP_ACP, 0, szFileSysName, -1, wszFileSysName, MAX_PATH)) {
    return  GetFileVersion(szFileName);
  }

  CFileSystem* pFileSystem = new CFileSystem;
  pFileSystem->Init();
  if (!(SUCCEEDED(pFileSystem->Open( szFileSysName ))))
  {
    delete pFileSystem;
    return GetFileVersion(szFileName);
  }
  // open the title information file (#SYSTEM)
  CSubFileSystem* pSubFileSystem = new CSubFileSystem(pFileSystem);
  hr = pSubFileSystem->OpenSub("#SYSTEM");
  if (FAILED(hr))
  {
        pFileSystem->Close();  
        delete pFileSystem;
        return GetFileVersion(szFileName);
  }

  // check the version of the title information file (#SYSTEM)

  DWORD dwVersion;
  DWORD cbRead;
  hr = pSubFileSystem->ReadSub(&dwVersion, sizeof(dwVersion), &cbRead);
  if (FAILED(hr) || cbRead != sizeof(dwVersion)) {
        pFileSystem->Close();  
        delete pFileSystem;
        delete pSubFileSystem;
        return GetFileVersion(szFileName);
  }

  // read in each and every item (skip those tags we don't care about)

  SYSTEM_TAG tag;
  SYSTEM_FLAGS   Settings;      // simple title information settings
  for(;;) {

      // get the tag type

      hr = pSubFileSystem->ReadSub(&tag, sizeof(SYSTEM_TAG), &cbRead);
      if (FAILED(hr) || cbRead != sizeof(SYSTEM_TAG))
          break;

      // handle each tag according to it's type
      switch (tag.tag) {

          // where all of our simple settings are stored

          case TAG_SYSTEM_FLAGS: {
            memset( &Settings , 0 , sizeof(SYSTEM_FLAGS));
            DWORD cbSettings = sizeof(Settings);
            DWORD cbTag = tag.cbTag;
            DWORD cbReadIn = 0;
            if( cbTag > cbSettings )
              cbReadIn = cbSettings;
            else
              cbReadIn = cbTag;
             hr = pSubFileSystem->ReadSub( &Settings, cbReadIn, &cbRead );
             if( cbTag > cbSettings )
                 hr = pSubFileSystem->SeekSub( cbTag-cbSettings, SEEK_CUR );
             delete pSubFileSystem;
             pFileSystem->Close();  
             delete pFileSystem;
             return Settings.FileTime.dwHighDateTime;            
             }

             // skip those we don't care about or don't know about

            default: {
                hr = pSubFileSystem->SeekSub( tag.cbTag, SEEK_CUR );
                break;
            }
        }

        if (FAILED(hr)) {
            pFileSystem->Close();  
            delete pFileSystem;
            delete pSubFileSystem;
            return GetFileVersion(szFileName);
        }
    }

    delete pSubFileSystem;

    pFileSystem->Close();  
    delete pFileSystem;
  
    return GetFileVersion(szFileName);
}

DWORD GetFileVersion(const TCHAR *szFileName)
{
    FILETIME FileTime1, FileTime2, FileTime3;
    DWORD dw = 0;
    HANDLE fHandle;

    fHandle = CreateFile(szFileName, GENERIC_READ , FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);

    if (fHandle != INVALID_HANDLE_VALUE)
        if (GetFileTime( fHandle,  &FileTime1, &FileTime2, &FileTime3) == TRUE)
            dw = FileTime3.dwHighDateTime;

    CloseHandle(fHandle);

    return dw;
}

LANGID GetLangId(const TCHAR *szFileName)
{
  HANDLE hFile = CreateFile( szFileName, GENERIC_READ, FILE_SHARE_READ,
    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

  if( hFile == INVALID_HANDLE_VALUE )
    return 0;

  DWORD dwFileStamp = 0;
  LCID FileLocale = 0;
  DWORD dwRead = 0;

  SetFilePointer( hFile, 4*sizeof(UINT), NULL, FILE_BEGIN );
  ReadFile( hFile, (void*) &dwFileStamp, sizeof( dwFileStamp ), &dwRead, NULL );
  ReadFile( hFile, (void*) &FileLocale, sizeof( FileLocale ), &dwRead, NULL );
  CloseHandle( hFile );

  return (LANGID) FileLocale;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itdb.h ===
// ITDB.H:	ITDatabase interface declaration

#ifndef __ITDB_H__
#define __ITDB_H__

// {8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITDatabase, 
0x8fa0d5a2, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {66673452-8C23-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITDatabase, 
0x66673452, 0x8c23, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa9-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITDatabaseLocal, 
0x4662daa9, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// Guaranteed to be an invalid value for dwObjInstance params in IITDatabase
// methods.
#define	IITDB_OBJINST_NULL	((DWORD) 0xFFFFFFFF)


DECLARE_INTERFACE_(IITDatabase, IUnknown)
{
	STDMETHOD(Open)(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags) PURE;
	STDMETHOD(Close)(void) PURE;

	// Creates an unnamed object that can be referenced in the future
	// by *pdwObjInstance.  Note that the value in *pdwObjInstance will be
	// persisted by the database when it is asked to save via
	// IPersistStorage::Save.
	STDMETHOD(CreateObject)(REFCLSID rclsid, DWORD *pdwObjInstance) PURE;

	// Retrieves a specified IUnknown-based interface on the object identified
	// by dwObjInstance.
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj) PURE;

	// To obtain a pointer to a named object's persistence the object's full
	// name (including any object-specific type prefix) should be passed in
	// lpswszObject.  If *lpwszObject is NULL, then the database's own storage
	// will be returned.  If lpwszObject is NULL, then dwObjInstance will be
	// used to identify the object and locate its persistence.  On exit,
	// *ppvPersistence will be either an IStorage* or an IStream*, depending
	// on what the caller specified with the fStream param.  The caller should
	// assume that only read operations can be performed on *ppvPersistence.
	// If the specified object's persistence doesn't exist, or if it exists
	// but is of the wrong type, then STG_E_FILENOTFOUND will be returned. 
	STDMETHOD(GetObjectPersistence)(LPCWSTR lpwszObject, DWORD dwObjInstance,
									LPVOID *ppvPersistence, BOOL fStream) PURE;
};

typedef IITDatabase* LPITDB;

#endif		// __ITDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itgroup.h ===
// ITGROUP.H:  IITGroup interface declaration

#ifndef __ITGROUP_H__
#define __ITGROUP_H__

//#include <comdef.h>

// {B1A6CA91-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(IID_IITGroup, 
0xb1a6ca91, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258914-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(IID_IITGroupArray, 
0x98258914, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#ifdef ITPROXY

// {B1A6CA92-A479-11d0-9741-00AA006117EB}
DEFINE_GUID(CLSID_IITGroup, 
0xb1a6ca92, 0xa479, 0x11d0, 0x97, 0x41, 0x0, 0xaa, 0x0, 0x61, 0x17, 0xeb);

// {98258915-B6AB-11d0-9D92-00A0C90F55A5}
DEFINE_GUID(CLSID_IITGroupArray, 
0x98258915, 0xb6ab, 0x11d0, 0x9d, 0x92, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xa5);

#else

// {4662daab-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupLocal, 
0x4662daab, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daac-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITGroupArrayLocal, 
0x4662daac, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Forward declarations
interface IITDatabase;

DECLARE_INTERFACE_(IITGroup, IUnknown)
{

	STDMETHOD(Initiate)(DWORD lcGrpItem) PURE;
	STDMETHOD(CreateFromBitVector)(LPBYTE lpBits, DWORD dwSize, DWORD dwItems) PURE;
	STDMETHOD(CreateFromBuffer)(HANDLE h) PURE;
    STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker) PURE;
    STDMETHOD(Free)(void) PURE;
	STDMETHOD(CopyOutBitVector)(IITGroup* pIITGroup) PURE;
    STDMETHOD(AddItem)(DWORD dwGrpItem) PURE;
    STDMETHOD(RemoveItem)(DWORD dwGrpItem) PURE;
	STDMETHOD(FindTopicNum)(DWORD dwCount, LPDWORD lpdwOutputTopicNum) PURE;
	STDMETHOD(FindOffset)(DWORD dwTopicNum, LPDWORD lpdwOutputOffset) PURE;
    STDMETHOD(GetSize)(LPDWORD dwGrpSize) PURE;
	STDMETHOD(Trim)(void) PURE;
	STDMETHOD(And)(IITGroup* pIITGroup) PURE;
	STDMETHOD(And)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroup) PURE;
	STDMETHOD(Or)(IITGroup* pIITGroupIn, IITGroup* pIITGroupOut) PURE;
	STDMETHOD(Not)(void) PURE;
	STDMETHOD(Not)(IITGroup* pIITGroupOut) PURE;
	STDMETHOD(IsBitSet)(DWORD dwTopicNum) PURE;
	STDMETHOD(CountBitsOn)(LPDWORD lpdwTotalNumBitsOn) PURE;
	STDMETHOD(Clear)(void) PURE;
    STDMETHOD_(LPVOID, GetLocalImageOfGroup)(void) PURE;
    STDMETHOD(PutRemoteImageOfGroup)(LPVOID lpGroupIn) PURE;

};

typedef IITGroup* LPITGROUP;

#define ITGP_MAX_GROUPARRAY_ENTRIES 32   // maximum number of groups allowed in a collection
#define ITGP_ALL_ENTRIES (-1L)
#define ITGP_OPERATOR_OR   0
#define ITGP_OPERATOR_AND  1

DECLARE_INTERFACE_(IITGroupArray, IITGroup)
{
	// composite group interface
	STDMETHOD(InitEntry)(IITDatabase *piitDB, LPCWSTR lpwszName, LONG& lEntryNum) PURE;
	STDMETHOD(InitEntry)(IITGroup *piitGroup, LONG& lEntryNum) PURE;
	STDMETHOD(SetEntry)(LONG lEntryNum) PURE;
	STDMETHOD(ClearEntry)(LONG lEntryNum) PURE;
	STDMETHOD(SetDefaultOp)(LONG cDefaultOp) PURE;
	STDMETHOD(ToString)(LPWSTR *ppwBuffer) PURE;
};

typedef IITGroupArray* LPIITGroupArray;
#endif // __ITGROUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itpropl.h ===
// ITPROPL.H:	ITPropertyList interface declaration

#ifndef __ITPROPL_H__
#define __ITPROPL_H__

#include <ocidl.h>

// {1F403BB1-9997-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITPropList, 
0x1f403bb1, 0x9997, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daae-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITPropList, 
0x4662daae, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

typedef DWORD PROPID;

// Operations you can do on a property
#define PROP_ADD    0x00000000
#define PROP_DELETE 0x00000001
#define PROP_UPDATE 0x00000002

// Type of data
#define TYPE_VALUE   0x00000000
#define TYPE_POINTER 0x00000001
#define TYPE_STRING  0x00000002

// Class definition of CProperty
class CProperty
{
public:
    PROPID dwPropID;        // property ID
    DWORD cbData;           // Amount of data
    DWORD dwType;           // What type this is
    union
    {
        LPCWSTR lpszwData;  // String
        LPVOID lpvData;     // Any kind of data
        DWORD  dwValue;     // Numerical data
    };
	BOOL fPersist;          // TRUE to persist this property

};

typedef CProperty* LPPROP;


// Interface def. for IITPropList
DECLARE_INTERFACE_(IITPropList, IPersistStreamInit)
{

    // dwOperation = operation (add, delete, update, etc.) to perform on property list
	STDMETHOD(Set)(PROPID PropID, DWORD dwData, DWORD dwOperation) PURE;
	STDMETHOD(Set)(PROPID PropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation) PURE;
    STDMETHOD(Set)(PROPID PropID, LPCWSTR lpszwString, DWORD dwOperation) PURE;
    STDMETHOD(Add)(CProperty& Prop) PURE;

    STDMETHOD(Get)(PROPID PropID, CProperty& Property) PURE;
    STDMETHOD(Clear)() PURE;

    // set persistence state on property
    STDMETHOD(SetPersist)(PROPID PropID, BOOL fPersist) PURE;   // single property
    STDMETHOD(SetPersist)(BOOL fPersist) PURE;          // all properties in list

    // for enumerating properties
    STDMETHOD(GetFirst)(CProperty& Property) PURE;
    STDMETHOD(GetNext)(CProperty& Property) PURE;
    STDMETHOD(GetPropCount)(LONG &cProp) PURE;

	// persist header and data separately
	STDMETHOD(SaveHeader)(LPVOID lpvData, DWORD dwHdrSize) PURE;
	STDMETHOD(SaveData)(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize) PURE;
	STDMETHOD(GetHeaderSize)(DWORD& dwHdrSize) PURE;
	STDMETHOD(GetDataSize)(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize) PURE;
	STDMETHOD(SaveDataToStream)(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream) PURE;

    // persist to a memory buffer
    STDMETHOD(LoadFromMem)(LPVOID lpvData, DWORD dwBufSize) PURE;
    STDMETHOD(SaveToMem)(LPVOID lpvData, DWORD dwBufSize) PURE;

};

typedef IITPropList* LPITPROPLIST;

#endif		// __ITPROPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\iterror.h ===
#ifndef __ITERROR_H__
#define __ITERROR_H__


#ifdef __cplusplus
extern "C" {
#endif


// define the old error types in terms of HRESULTs
typedef HRESULT* PHRESULT;

#define ERR     HRESULT
#define ERRB    HRESULT
#define LPERRB  HRESULT*
#define RC      HRESULT


#define	SetErrCode(a,b)	SetErr(a, b)
#define	SetErrReturn(a)	SetErr(0, a)


HRESULT PASCAL SetErr (HRESULT* phr, HRESULT ErrCode);


/*************************************************************************
 *
 *                  CALLBACK FUNCTIONS PROTOTYPES
 *
 * User callback functions are needed in case:
 *  - The application needs to support interrupt
 *  - The application needs to display error messages its way
 *  - The application needs to know the status of the process
 *************************************************************************/
typedef ERR (FAR PASCAL *ERR_FUNC) (DWORD dwFlag, LPVOID pUserData, LPVOID pMessage);

/*************************************************************************
 * Call back structure
 *  Contains information about all callback functions
 *************************************************************************/ 

#define ERRFLAG_INTERRUPT      0x01 // The processes should be cancelled
#define ERRFLAG_STATUS         0x02 // High-level status messages
#define ERRFLAG_STATUS_VERBOSE 0x04 // Low-level status messages
#define ERRFLAG_ERROR          0x08 // Warning & Error messages
#define ERRFLAG_STRING         0x10 // Debug string messages

typedef struct fCallBack_msg
{
    ERR_FUNC MessageFunc;
    LPVOID pUserData;
    DWORD  dwFlags;
} FCALLBACK_MSG, FAR * PFCALLBACK_MSG;


// ***********************************************************************
// This structure should be filled out and passed back in the case of
// an error.
// ***********************************************************************
typedef WORD HCE;   // User errors
typedef WORD EP;    // Error Phase
typedef struct
{
    LPCSTR  pchFile;
    LONG    iLine;
    DWORD   iTopic;
    DWORD   fCustom; // If true then var1 is LPCSTR to custom error message
    DWORD   var1, var2, var3;   // Error parameters

    EP      ep;                 // Error Phase
    HCE     errCode;
} ERRC, FAR *PERRC;

#define CALLBACKKEY 0x524A4A44

typedef struct
{
    DWORD dwReserved;
    DWORD dwKey;
    FCALLBACK_MSG Callback;
} CUSTOMSTRUCT, FAR *PCUSTOMSTRUCT;

// Error Phase values
#define epNoFile       0
#define epLine         1
#define epTopic        2
#define epOffset       3
#define epMVBtopic	   4
#define epAliasLine	   5
#define epByteOffset   6


//
// The InfoTech error codes
//
#define E_NOTEXIST          _HRESULT_TYPEDEF_(0x80001000L)
#define E_DUPLICATE         _HRESULT_TYPEDEF_(0x80001001L)
#define E_BADVERSION        _HRESULT_TYPEDEF_(0x80001002L)
#define E_BADFILE           _HRESULT_TYPEDEF_(0x80001003L)
#define E_BADFORMAT         _HRESULT_TYPEDEF_(0x80001004L)
#define E_NOPERMISSION      _HRESULT_TYPEDEF_(0x80001005L)
#define E_ASSERT            _HRESULT_TYPEDEF_(0x80001006L)
#define E_INTERRUPT         _HRESULT_TYPEDEF_(0x80001007L)
#define E_NOTSUPPORTED      _HRESULT_TYPEDEF_(0x80001008L)
#define E_OUTOFRANGE        _HRESULT_TYPEDEF_(0x80001009L)                  
#define E_GROUPIDTOOBIG     _HRESULT_TYPEDEF_(0x8000100AL)
#define E_TOOMANYTITLES     _HRESULT_TYPEDEF_(0x8000100BL)
#define E_NOMERGEDDATA      _HRESULT_TYPEDEF_(0x8000100CL)
#define E_NOTFOUND          _HRESULT_TYPEDEF_(0x8000100DL)
#define E_CANTFINDDLL       _HRESULT_TYPEDEF_(0x8000100EL)
#define E_NOHANDLE          _HRESULT_TYPEDEF_(0x8000100FL) 
#define E_GETLASTERROR      _HRESULT_TYPEDEF_(0x80001010L)
#define E_BADPARAM			_HRESULT_TYPEDEF_(0x80001011L)
#define E_INVALIDSTATE		_HRESULT_TYPEDEF_(0x80001012L)
#define E_NOTOPEN           _HRESULT_TYPEDEF_(0x80001013L)
#define E_ALREADYOPEN       _HRESULT_TYPEDEF_(0x80001013L)
#define E_UNKNOWN_TRANSPORT _HRESULT_TYPEDEF_(0x80001016L)
#define E_UNSUPPORTED_TRANSPORT _HRESULT_TYPEDEF_(0x80001017L)
#define E_BADFILTERSIZE     _HRESULT_TYPEDEF_(0x80001018L)
#define E_TOOMANYOBJECTS    _HRESULT_TYPEDEF_(0x80001019L)
#define E_NAMETOOLONG       _HRESULT_TYPEDEF_(0x80001020L)

#define E_FILECREATE        _HRESULT_TYPEDEF_(0x80001030L) 
#define E_FILECLOSE         _HRESULT_TYPEDEF_(0x80001031L)
#define E_FILEREAD          _HRESULT_TYPEDEF_(0x80001032L)
#define E_FILESEEK          _HRESULT_TYPEDEF_(0x80001033L)
#define E_FILEWRITE         _HRESULT_TYPEDEF_(0x80001034L)
#define E_FILEDELETE        _HRESULT_TYPEDEF_(0x80001035L)
#define E_FILEINVALID       _HRESULT_TYPEDEF_(0x80001036L)
#define E_FILENOTFOUND      _HRESULT_TYPEDEF_(0x80001037L)
#define E_DISKFULL          _HRESULT_TYPEDEF_(0x80001038L)

#define E_TOOMANYTOPICS     _HRESULT_TYPEDEF_(0x80001050L)
#define E_TOOMANYDUPS       _HRESULT_TYPEDEF_(0x80001051L)
#define E_TREETOOBIG        _HRESULT_TYPEDEF_(0x80001052L)
#define E_BADBREAKER        _HRESULT_TYPEDEF_(0x80001053L)
#define E_BADVALUE          _HRESULT_TYPEDEF_(0x80001054L)
#define E_ALL_WILD          _HRESULT_TYPEDEF_(0x80001055L)
#define E_TOODEEP           _HRESULT_TYPEDEF_(0x80001056L)
#define E_EXPECTEDTERM      _HRESULT_TYPEDEF_(0x80001057L)
#define E_MISSLPAREN        _HRESULT_TYPEDEF_(0x80001058L)
#define E_MISSRPAREN        _HRESULT_TYPEDEF_(0x80001059L)
#define E_MISSQUOTE         _HRESULT_TYPEDEF_(0x8000105AL)
#define E_NULLQUERY         _HRESULT_TYPEDEF_(0x8000105BL)
#define E_STOPWORD          _HRESULT_TYPEDEF_(0x8000105CL)
#define E_BADRANGEOP        _HRESULT_TYPEDEF_(0x8000105DL)
#define E_UNMATCHEDTYPE     _HRESULT_TYPEDEF_(0x8000105EL)
#define E_WORDTOOLONG       _HRESULT_TYPEDEF_(0x8000105FL)
#define E_BADINDEXFLAGS     _HRESULT_TYPEDEF_(0x80001060L)
#define E_WILD_IN_DTYPE		_HRESULT_TYPEDEF_(0x80001061L)   
#define E_NOSTEMMER			_HRESULT_TYPEDEF_(0x80001062L)

// Property list and result set errors
#define E_MISSINGPROP		_HRESULT_TYPEDEF_(0x80001080L)
#define E_PROPLISTNOTEMPTY  _HRESULT_TYPEDEF_(0x80001081L)
#define E_PROPLISTEMPTY     _HRESULT_TYPEDEF_(0x80001082L)
#define E_ALREADYINIT       _HRESULT_TYPEDEF_(0x80001083L)
#define E_NOTINIT           _HRESULT_TYPEDEF_(0x80001084L)
#define E_RESULTSETEMPTY	_HRESULT_TYPEDEF_(0x80001085L)
#define E_TOOMANYCOLUMNS	_HRESULT_TYPEDEF_(0x80001086L)
#define E_NOKEYPROP			_HRESULT_TYPEDEF_(0x80001087L)

#ifdef __cplusplus
}
#endif

#endif  // __ITERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itquery.h ===
// ITQUERY.H:	IITIndex and IITQuery interface declarations

#ifndef __ITQUERY_H__
#define __ITQUERY_H__

#include "iterror.h"

// {8fa0d5a3-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITIndex, 
0x8fa0d5a3, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {A38D3483-8C49-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITIndex, 
0xa38d3483, 0x8c49, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daad-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITIndexLocal, 
0x4662daad, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// {8fa0d5ac-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITQuery, 
0x8fa0d5ac, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa6-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITQuery, 
0x4662daa6, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// Defines
#define IMPLICIT_AND            0x0000
#define IMPLICIT_OR             0x0001
#define COMPOUNDWORD_PHRASE     0x0010 // use PHRASE opr for compound words
#define QUERYRESULT_RANK        0x0100 // Ranked the result. If not highest hit 1st (topics in UID order)
#define QUERYRESULT_UIDSORT     0x0200 // Result topics are 1st in 1st out
#define QUERYRESULT_SKIPOCCINFO 0x8000 // Topic list only, no occurrence info

#define STEMMED_SEARCH	        0x00010000
#define RESULTSET_ASYNC			0x00020000
#define QUERY_GETTERMS			0x00080000	// Return with each set of occurrence
											// data a pointer to the term string
											// that the data is associated with.

// Standard properties
#define STDPROP_SEARCHBASE  500
#define STDPROP_FIELD			STDPROP_SEARCHBASE
#define STDPROP_LENGTH			(STDPROP_SEARCHBASE + 1)
#define STDPROP_COUNT			(STDPROP_SEARCHBASE + 2)
#define STDPROP_OFFSET			(STDPROP_SEARCHBASE + 3)
#define STDPROP_TERM_UNICODE_ST	(STDPROP_SEARCHBASE + 4)

// Don't know signature of callbacks yet
typedef void (*LPFNCBBREAK)(void);    
typedef void (*LPFNRESULTCB)(void);


// Forward declarations
interface IITResultSet;
interface IITQuery;
interface IITDatabase;
interface IITGroup;

DECLARE_INTERFACE_(IITIndex, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* pITDB, LPCWSTR lpszIndexMoniker, BOOL fInsideDB) PURE;
	STDMETHOD(Close)(void) PURE;

	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;
	STDMETHOD(GetWordBreakerInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(CreateQueryInstance)(IITQuery** ppITQuery) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITResultSet* pITResult) PURE;
	STDMETHOD(Search)(IITQuery* pITQuery, IITGroup* pITGroup) PURE;
};

typedef IITIndex* PITINDEX;


DECLARE_INTERFACE_(IITQuery, IUnknown)
{
	STDMETHOD(SetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(SetCommand)(LPCWSTR lpszCommand) PURE;
	STDMETHOD(SetOptions)(DWORD dwFlags) PURE;
	STDMETHOD(SetProximity)(WORD wNear) PURE;
	STDMETHOD(SetGroup)(IITGroup* pITGroup) PURE;
	STDMETHOD(SetResultCount)(LONG cRows) PURE;

	STDMETHOD(GetResultCallback)(FCALLBACK_MSG *pfcbkmsg) PURE;
	STDMETHOD(GetCommand)(LPCWSTR& lpszCommand) PURE;
	STDMETHOD(GetOptions)(DWORD& dwFlags) PURE;
	STDMETHOD(GetProximity)(WORD& wNear) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;
	STDMETHOD(GetResultCount)(LONG& cRows) PURE;

	STDMETHOD(ReInit)() PURE;

};

typedef IITQuery* PITQUERY;


#endif		// __ITQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itsort.h ===
// ITSORT.H:	IITSortKey, IITSortKeyConfig, and related definitions.

#ifndef __ITSORT_H__
#define __ITSORT_H__

#include <comdef.h>


// Some standard definitions for sort key types.  In general, key types (and
// their #defines) are specific to a particular implementation of a sort object.
// However, in the interest of making it easier to call a variety of sort object
// implementations, we define some standard key type definitions that can be
// used across different implementations.
// New sort objects should feel free to add arbitrary key formats, which could
// include a variety of custom binary formats tailored to specific applications
// (e.g. a binary key that provides indirection to a dictionary of strings).
// Note that the format of the key type must always allow its length to be
// determined without any other data than the key itself, as follows:
//		1) length is constant for the key type (e.g. DWORD is always 4 bytes)
//		2) key includes length information (e.g. a WORD prefix indicating
//			how many memory units (bytes, words, etc.) the key contains
//		3) key must contain an explicit terminator (e.g. null terminated strings).
#define IITSK_KEYTYPE_WORD			((DWORD) 18)	// Binary word
#define IITSK_KEYTYPE_DWORD			((DWORD) 19)	// Binary dword
#define IITSK_KEYTYPE_ANSI_SZ		((DWORD) 30)	// NULL-term. MBCS string
#define IITSK_KEYTYPE_UNICODE_SZ	((DWORD) 31)	// NULL-term. Unicode string


// Valid parameters that can be returned by IITSortKey::Compare in *pgrfReason.
#define IITSK_COMPREASON_UNKNOWN		((DWORD) 0x80000000)

// Valid parameters that can be passed to IITSortKey::IsRelated.
#define IITSK_KEYRELATION_PREFIX		((DWORD) 0)
#define IITSK_KEYRELATION_INFIX			((DWORD) 1)
#define IITSK_KEYRELATION_SUFFIX		((DWORD) 2)


DECLARE_INTERFACE_(IITSortKey, IUnknown)
{
	// Returns in *pcbSize the size of the key in bytes (including any
	// length information).
	STDMETHOD(GetSize)(LPCVOID lpcvKey, DWORD *pcbSize) PURE;

	// On exit, *plResult is set according to strcmp conventions:
	//	< 0, = 0, > 0, depending on whether lpcvKey1 is less than, equal to, or
	// greater than lpcvKey2.  If pgrfReason is not NULL, *pgrfReason may be
	// filled in on exit with one or more bit flags giving more information about
	// the result of the comparison if the result was affected by something other
	// than raw lexical comparison (e.g. special character mappings).  If
	// *pgrfReason contains 0 on exit, that means the comparison result
	// was purely lexical; if *pgrfReason contains IITSK_COMPREASON_UNKNOWN,
	// then the sort object implementation wasn't able to provide additional
	// information about the comparison result.
	STDMETHOD(Compare)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						LONG *plResult, DWORD *pgrfReason) PURE;

	// Returns S_OK if lpcvKey1 is related to lpcvKey2 according to
	// dwKeyRelation; else S_FALSE.  If the value specified for dwKeyRelation
	// is not supported, E_INVALIDARG will be returned.  If pgrfReason is not
	// NULL, *pgrfReason will be filled in just as it would be by
	// IITSortKey::Compare.
	STDMETHOD(IsRelated)(LPCVOID lpcvKey1, LPCVOID lpcvKey2,
						 DWORD dwKeyRelation, DWORD *pgrfReason) PURE;

	// Converts a key of one type into a key of another type.  This is intended
	// mainly for converting an uncompressed key into a compressed key,
	// but a sort object is free to provide whatever conversion combinations
	// it wants to.  *pcbSizeOut should contain the size of the buffer pointed
	// to by lpvKeyOut.  The caller can obtain a guaranteed adequate buffer size
	// through *pcbSizeOut by passing 0 on entry.
	//
	// The following errors are returned:
	//		E_INVALIDARG:	the specified conversion is not supported, i.e.
	//						one or both of the REFGUID params is invalid.
	//		E_FAIL:			the buffer pointed to by lpvKeyOut was too small
	//						to hold the converted key.
	STDMETHOD(Convert)(DWORD dwKeyTypeIn, LPCVOID lpcvKeyIn,
						DWORD dwKeyTypeOut, LPVOID lpvKeyOut,
						DWORD *pcbSizeOut) PURE;
};

typedef IITSortKey *PIITSKY;


// Sort flags that can be passed to IITSortKeyConfig::SetControlInfo.
#define IITSKC_SORT_STRINGSORT           0x00001000  /* use string sort method */
#define IITSKC_NORM_IGNORECASE           0x00000001  /* ignore case */
#define IITSKC_NORM_IGNORENONSPACE       0x00000002  /* ignore nonspacing chars */
#define IITSKC_NORM_IGNORESYMBOLS        0x00000004  /* ignore symbols */
#define IITSKC_NORM_IGNOREKANATYPE       0x00010000  /* ignore kanatype */
#define IITSKC_NORM_IGNOREWIDTH          0x00020000  /* ignore width */


// External data types that can be passed to
// IITSortKeyConfig::LoadExternalSortData.
#define IITWBC_EXTDATA_SORTTABLE	((DWORD) 2)		


DECLARE_INTERFACE_(IITSortKeyConfig, IUnknown)
{
	// Sets/gets locale info that will affect the comparison results
	// returned from all subsequent calls to IITSortKey::Compare.
	// Returns S_OK if locale described by params is supported
	// by the sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the sort key type that the sort object will expect
	// to see in the following method calls that take keys as params:
	//		IITSortKey::GetSize, Compare, IsRelated
	// Returns S_OK if the sort key type is understood by the
	// sort object; E_INVALIDARG otherwise.
	STDMETHOD(SetKeyType)(DWORD dwKeyType) PURE;
	STDMETHOD(GetKeyType)(DWORD *pdwKeyType) PURE;

	// Sets/gets data that controls how sort key comparisons are made.
	// This method currently accepts only the following set of flags
	// in grfSortFlags:
	//
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfSortFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfSortFlags, DWORD *pdwReserved) PURE;

	// Will load external sort data, such as tables containing the relative
	// sort order of specific characters for a textual key type, from the
	// specified stream.  The format of the data is entirely implementation
	// specific, with the value passed in dwExtDataType providing a hint.
	STDMETHOD(LoadExternalSortData)(IStream *pStream, DWORD dwExtDataType) PURE;
};

typedef IITSortKeyConfig *PIITSKYC;


#endif		// __ITSORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itrs.h ===
// ITRS.H:	ITResultSet interface declaration

#ifndef __ITRS_H__
#define __ITRS_H__


// {3BB91D41-998B-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITResultSet, 
0x3bb91d41, 0x998b, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daa7-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITResultSet, 
0x4662daa7, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// maximum number of columns in a row set
#define MAX_COLUMNS  256

// Column priorities
typedef enum
{
    PRIORITY_LOW = 0,
    PRIORITY_NORMAL = 1,
    PRIORITY_HIGH = 2,

} PRIORITY;


// Forward declarations
class CProperty;

typedef struct tagROWSTATUS
{
    LONG lRowFirst;
    LONG cRows;
    LONG cProperties;
    LONG cRowsTotal;

} ROWSTATUS, *LPROWSTATUS;


typedef struct tagCOLUMNSTATUS
{
    LONG cPropCount;
    LONG cPropsLoaded;

} COLUMNSTATUS, *LPCOLUMNSTATUS;


// Used by IITResultSet::SetColumnHeap.
typedef SCODE (__stdcall *PFNCOLHEAPFREE)(LPVOID);


DECLARE_INTERFACE_(IITResultSet, IUnknown)
{
    // Initialization
    STDMETHOD(SetColumnPriority)(LONG lColumnIndex, PRIORITY ColumnPriority) PURE;
	STDMETHOD(SetColumnHeap)(LONG lColumnIndex, LPVOID lpvHeap,
										PFNCOLHEAPFREE pfnColHeapFree) PURE;
    STDMETHOD(SetKeyProp)(PROPID PropID) PURE;
    STDMETHOD(Add)(LPVOID lpvHdr) PURE;
    STDMETHOD(Add)(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority) PURE;

    // Build result set
	STDMETHOD(Append)(LPVOID lpvHdr, LPVOID lpvData) PURE;
	STDMETHOD(Set)(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD dwData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpwStr) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData) PURE;
	STDMETHOD(Copy)(IITResultSet* pRSCopy) PURE;
	STDMETHOD(AppendRows)(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
									LONG& lRowFirstDest) PURE;


    // Obtain info about result set
    STDMETHOD(Get)(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop) PURE;
    STDMETHOD(GetKeyProp)(PROPID& KeyPropID) PURE;
    STDMETHOD(GetColumnPriority)(LONG lColumnIndex, PRIORITY& ColumnPriority) PURE;
    STDMETHOD(GetRowCount)(LONG& lNumberOfRows) PURE;
	STDMETHOD(GetColumnCount)(LONG& lNumberOfColumns) PURE;
	STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID) PURE;
    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue,
		                 DWORD& cbSize, PRIORITY& ColumnPriority) PURE;

	STDMETHOD(GetColumnFromPropID)(PROPID PropID, LONG& lColumnIndex) PURE;

    // Clear result set
    STDMETHOD(Clear)() PURE;
    STDMETHOD(ClearRows)() PURE;
    STDMETHOD(Free)() PURE;

    // Asynchronous support
    STDMETHOD(IsCompleted)() PURE;      // returns S_OK or S_FALSE
    STDMETHOD(Cancel)() PURE;
    STDMETHOD(Pause)(BOOL fPause) PURE;

    STDMETHOD(GetRowStatus)(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus) PURE;
    STDMETHOD(GetColumnStatus)(LPCOLUMNSTATUS lpColStatus) PURE;
};

typedef IITResultSet* LPITRS;


#endif		// __ITRS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itsortid.h ===
// ITSORTID.H:	IIDs and other GUIDs related to sorting.

#ifndef __ITSORTID_H__
#define __ITSORTID_H__

#include <comdef.h>

// {8fa0d5a0-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKey, 
0x8fa0d5a0, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5a1-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITSortKeyConfig, 
0x8fa0d5a1, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662dab0-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITSysSort, 
0x4662dab0, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITSORTID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itstem.h ===
// ITSTEM.H:	(from Tripoli) IStemmer, IStemSink
//				(from InfoTech) IStemmerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITSTEM_H__
#define __ITSTEM_H__

#include <comdef.h>


#ifndef __IStemSink_FWD_DEFINED__
#define __IStemSink_FWD_DEFINED__
typedef interface IStemSink IStemSink;
#endif 	/* __IStemSink_FWD_DEFINED__ */


#ifndef __IStemmer_FWD_DEFINED__
#define __IStemmer_FWD_DEFINED__
typedef interface IStemmer IStemmer;
#endif 	/* __IStemmer_FWD_DEFINED__ */


#ifndef __IStemmerConfig_FWD_DEFINED__
#define __IStemmerConfig_FWD_DEFINED__
typedef interface IStemmerConfig IStemmerConfig;
#endif 	/* __IStemmerConfig_FWD_DEFINED__ */


DECLARE_INTERFACE_(IStemmer, IUnknown)
{
    STDMETHOD(Init)(ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
    STDMETHOD(StemWord)(WCHAR const *pwcInBuf, ULONG cwc,
									IStemSink *pStemSink) PURE;   
};

typedef IStemmer *PISTEM;


DECLARE_INTERFACE_(IStemSink, IUnknown)
{
    STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
    STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef IStemSink *PISTEMSNK;


DECLARE_INTERFACE_(IStemmerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the stemming
	// behavior of IStemmer::StemWord.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets info that controls certain aspects of stemming.
	// This method currently accepts only the following set of flags
	// in grfStemFlags:
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfStemFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfStemFlags, DWORD *pdwReserved) PURE;

	// Will load external stemmer data, such as word part lists, etc.
	// The format of the data in the stream is entirely
	// implementation-specific.
	STDMETHOD(LoadExternalStemmerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;
};

typedef IStemmerConfig *PISTEMC;



#endif	// __ITSTEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\header.h ===
// Copyright (C) 1996-1997 Microsoft Corporation. All rights reserved.

#ifndef __HEADER_H__
#define __HEADER_H__

#ifndef STRICT
#define STRICT
#endif

#ifndef INLINE
#define INLINE __inline         // Remove for profiling
#endif

#define  MAX_TOPIC_NAME 256
#define  MAX_STRING_RESOURCE_LEN 256
#define  STRING_SEP_CHAR    '|'
const int MAX_FLAGS = 3;

const char CH_MACRO = '!';  // means a macro in a .hhc file

typedef unsigned long HASH;

#define _WINUSERP_  // so winuserp.h doesn't get pulled (which causes fatal errors)

//////////////////////////////////// Includes ///////////////////////////////

// Don't mess with the order header files are included
#include <windows.h>
#include <winnls.h>
#include <ole2.h>
#include <stddef.h>
#include <malloc.h>
#include <crtdbg.h>

#include "IPServer.h"

#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_STREAM
#define NO_SHLWAPI_GDI
#include <shlwapi.h>

//
// W2K contants which aren't in our headers.
//
#ifndef WM_CHANGEUISTATE
//--- New messages in NT5 only.
#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE  0x0129
//--- LOWORD(wParam) values in WM_*UISTATE.
#define UIS_SET         1
#define UIS_CLEAR       2
#define UIS_INITIALIZE  3
//--- HIWORD(wParam) values in WM_*UISTATE
#define UISF_HIDEFOCUS  0x1
#define UISF_HIDEACCEL  0x2
#endif

// Debugging Support Class --- ClassObjectCount
#include "objcnt.h"

#undef StrChr
#undef StrRChr
#include "unicode.h"
#include "funcs.h"
#include "cstr.h"
#include "shared.h"
#include "lcmem.h"
#include "ctable.h"
#include "wmp.h"

// Language Information
#include "language.h"

// Get the ATL includes.
#include "atlinc.h"

#ifdef HHCTRL
// Include the definitions for HTML Help API
#include "htmlhelp.h"

// Include out global resource cache
#include "rescache.h"
#endif

/////////////////////////////////////////////////////////////////////////////

// map as many CRT functions to Win32, ShlWAPI, or private functions as we can
//

// UNICODE
#define wcscat    StrCatW
#define wcscpy    StrCpyW
#define _wcscpy   StrCpyW
#define wcsncpy   StrCpyNW
#define _wcsncpy  StrCpyNW
#define wcscmp    StrCmpW
#define _wcscmp   StrCmpW
#define wcsicmp   StrCmpIW
#define _wcsicmp  StrCmpIW
#define wcsnicmp  StrCmpNIW
#define wcslen    lstrlenW

// intrinsics -- no need to map these
// #define strcat    lstrcatA
// #define strlen    lstrlenA
// #define strcpy    lstrcpyA
// #define strcmp    lstrcmpA

// ANSI
#define StrChr    StrChrA
#define strchr    StrChrA
#define strncpy   lstrcpynA
#define stricmp   lstrcmpiA
#define _stricmp  lstrcmpiA
#define strcmpi   lstrcmpiA
#define _strcmpi  lstrcmpiA
#define strncmp   StrCmpNA
#define strnicmp  StrCmpNIA
#define _strnicmp StrCmpNIA
#define strstr    StrStrA
#define stristr   StrStrIA

// #define strncat   StrCatN --> not supported in IE3 shlwapi

// MISC
#define splitpath  SplitPath
#define _splitpath SplitPath
#define atoi       Atoi
#define isspace    IsSpace
#define strpbrk    StrPBrk
#define qsort      QSort
#define tolower    ToLower
#define strrchr    StrRChr

#ifdef _DEBUG
#define STATIC      // because icecap doesn't believe in static functions
#else
#define STATIC static
#endif

// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL

const int GUID_STR_LEN = 40;

typedef enum {
    ACT_NOTHING,
    ACT_ABOUT_BOX,
    ACT_CONTENTS,
    ACT_INDEX,
    ACT_RELATED_TOPICS,
    ACT_TEXT_POPUP,
    ACT_WINHELP,
    ACT_HHCTRL_VERSION,
    ACT_SPLASH,
    ACT_SHORTCUT,
    ACT_CLOSE,
    ACT_MINIMIZE,
    ACT_MAXIMIZE,
    ACT_KEYWORD_SEARCH,
    ACT_TCARD,      // data stored in m_pszActionData, not m_ptblItems
    ACT_HHWIN_PRINT,    // tell hhwin to print the current frameset
    ACT_KLINK,
    ACT_ALINK,
    ACT_SAMPLE,
} CTRL_ACTION;

// The type of image to display for the control

typedef enum {
    IMG_BITMAP,
    IMG_CHILD_WINDOW,
    IMG_TEXT,
    IMG_RELATED,    // Related topics
    IMG_BUTTON,
} IMAGE_TYPE;

enum THRD_COMMAND {
    THRD_ANY,
    THRD_TERMINATE,
};

typedef enum {
    SK_SET,
    SK_CUR,
    SK_END
} SEEK_TYPE;

#define CH_OPEN_PAREN     '('
#define CH_CLOSE_PAREN    ')'
#define CH_COLON          ':'
#define CH_SEMICOLON      ';'
#define CH_START_QUOTE     '`'
#define CH_END_QUOTE      '\''
#define CH_QUOTE          '"'
#define CH_BACKSLASH      '\\'
#define CH_FORWARDSLASH   '/'
#define CH_EQUAL          '='
#define CH_SPACE          ' '
#define CH_COMMA          ','
#define CH_LEFT_BRACKET   '['
#define CH_RIGHT_BRACKET  ']'
#define CH_TAB            '\t'

// Same errors as used by hha.dll

typedef enum {              // File System errors
    FSERR_NONE = 0,         // no error
    FSERR_CANCELLED,        // user cancelled
    FSERR_CANT_OPEN,        // can't open file
    FSERR_CANT_READ,        // error while reading the file
    FSERR_CANT_WRITE,       // error while writing to the file
    FSERR_INVALID_FORMAT,   // invalid file format
    FSERR_TRUNCATED,        // file is truncated
    FSERR_INSF_MEMORY,      // insuficient global memory
    FSERR_INTERNAL,         // internal error
    FSERR_24BIT_NOT_SUPPORTED, // not supported by this file format
    FSERR_REALLY_A_BMP,     // This is really a BMP file.
    FSERR_MONO_NOT_SUPPORTED,
    FSERR_256_NOT_SUPPORTED,
    FSERR_NOROOM_FOR_TMP,   // insufficient room in windows directory
    FSERR_NON_FLASH_EPS,    // not a Flash EPS file
    FSERR_GETDIBITS_FAILURE,
    FSERR_ACCESS_DENIED,
    FSERR_INS_FILE_HANDLES,
    FSERR_INVALID_PATH,
    FSERR_FILE_NOT_FOUND,
    FSERR_DISK_FULL,
    FSERR_UNSUPPORTED_FORMAT,
    FSERR_UNSUPPORTED_GIF_FORMAT,
    FSERR_INVALID_GIF_COLOR,
    FSERR_UNSUPPORTED_GIF_EXTENSION,
    FSERR_CORRUPTED_FILE,
    FSERR_TRY_FILTER,   // native doesn't support, so use filter
    FSERR_UNSUPPORTED_JPEG,
    FSERR_UNSUPPORTED_OUTPUT_FORMAT,

} FSERR;

#define MAX_SS_NAME_LEN             51           // 50 char limit + NULL

#define TAMSG_IE_ACCEL         1
#define TAMSG_TAKE_FOCUS       2
#define TAMSG_NOT_IE_ACCEL     3

#define ANY_PROCESS_ID 0

#define WS_EX_LAYOUT_RTL 0x00400000L // Right to left mirroring (Win98 and NT5 only)

extern DWORD g_RTL_Style; // additional windows style for RTL layout (all platforms)
extern DWORD g_RTL_Mirror_Style; // additional windows style for RTL mirroring
extern BOOL  g_fThreadRunning;  // TRUE if our thread is doing something
extern HANDLE  g_hsemNavigate;
extern const CLSID *g_pLibid;
extern BOOL     g_fMachineHasLicense;
extern BOOL     g_fCheckedForLicense;
extern BOOL     g_fServerHasTypeLibrary;
extern HWND     g_hwndParking;
extern BOOL g_fDualCPU;   // -1 until initialized, then TRUE or FALSE
extern CRITICAL_SECTION g_CriticalSection;
extern HINSTANCE    g_hinstOcx;
extern HBRUSH   g_hbrBackGround;    // background brush
extern HBITMAP  g_hbmpSplash;
extern HPALETTE g_hpalSplash;
extern HWND     g_hwndSplash;
extern int      g_cWindowSlots; // current number of allocated window slots
extern int      g_curHmData;
extern int      g_cHmSlots;
extern UINT     g_fuBiDiMessageBox;
extern BOOL     g_fCoInitialized;   // means we called CoInitialize()

extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;
extern BOOL g_fSysWin95;        // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;        // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;  // we're under Win95 or Windows NT SUR { > 3/51)
extern BOOL g_bWinNT5;          // we're under NT5
extern BOOL g_bWin98;          // we're under Win98
extern BOOL g_fBiDi;            // TRUE if this is a BiDi system
extern BOOL g_bBiDiUi;          // TRUE when we have a localized Hebrew or Arabic UI
extern BOOL g_bArabicUi;        // TRUE when we have a Arabic UI
extern BOOL g_fRegisteredSpash; // TRUE if Splash window has been registered
extern BOOL g_fNonFirstKey; // accept keyboard entry for non-first level index keys
extern BOOL g_bMsItsMonikerSupport;  // "ms-its:" moniker supported starting with IE 4
extern BOOL g_fIE3;               // affects which features we can support

extern BOOL     g_fDBCSSystem;
extern LCID     g_lcidSystem;       // Only used for input to CompareString. used in util.cpp stristr()
extern LANGID   g_langSystem;       // used only by fts.cpp, ipserver.cpp and rescache.cpp

extern const char g_szLibName[];
extern const CLSID *g_pLibid;

extern CTable* g_ptblItems;

extern const char g_szReflectClassName[]; // "CtlFrameWork_ReflectWindow";
extern UINT MSG_MOUSEWHEEL;

extern const char txtInclude[];    // ":include";
extern const char txtFileHeader[]; // "file:";
extern const char txtHttpHeader[]; // "http:";
extern const char txtFtpHeader[]; // "ftp:";
extern const char txtZeroLength[]; // "";
extern const char txtHtmlHelpWindowClass[];
extern const char txtHtmlHelpChildWindowClass[];
extern const char txtSizeBarChildWindowClass[];
extern const char txtSysRoot[];
extern const char txtMkStore[]; // "mk:@MSITStore:";
extern const char txtItsMoniker[]; // "its:";
extern const char txtMsItsMoniker[]; // "ms-its:";
extern const char txtHlpDir[];  // "Help";
extern const char txtOpenCmd[]; // "htmlfile\\shell\\open\\command";
extern const char txtDoubleColonSep[]; // "::";
extern const char txtSepBack[];      // "::/";
extern const char txtDefExtension[]; // ".chm";
extern const char txtCollectionExtension[]; // ".col";
extern const char txtChmColon[]; // ".chm::";
extern const char txtDefFile[];      // "::/default.htm";

// Internal window types
extern const char txtDefWindow[];  // Per-chm version.
extern const char txtGlobalDefWindow[] ; // Global version.

// Special windows --- The filename parameter is ignored for these windows.
extern const char txtPrintWindow[] ;

#include "Util.H"

// inline function only support for hour glass

struct CHourGlass
{
    CHourGlass()
        { hcurRestore = SetCursor(LoadCursor(NULL,
            (LPCTSTR) IDC_WAIT)); }
    ~CHourGlass()
        { SetCursor(hcurRestore); }

    void Restore()
        { SetCursor(hcurRestore); }

    HCURSOR hcurRestore;
};

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

class CBusy
{
public:

  CBusy() { m_iBusyCount = 0; }

  BOOL Set( BOOL bBusy )
  {
    if( bBusy )
      m_iBusyCount++;
    else
      m_iBusyCount--;
    if( m_iBusyCount < 0 )
      m_iBusyCount = 0;
    return IsBusy();
  }
  inline BOOL IsBusy() { return (BOOL) m_iBusyCount; }

private:

  BOOL m_iBusyCount;
};

extern CBusy g_Busy;


#endif // __HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itwbrk.h ===
// ITWBRK.H:	(from Tripoli) IWordBreaker, IWordSink, IPhraseSink, IStem
//				(from InfoTech) IWordBreakerConfig
//				(from Tripoli and InfoTech) Supporting definitions.

#ifndef __ITWBRK_H__
#define __ITWBRK_H__

#include <comdef.h>
#include <itstem.h>


#ifndef __IPhraseSink_FWD_DEFINED__
#define __IPhraseSink_FWD_DEFINED__
typedef interface IPhraseSink IPhraseSink;
#endif 	/* __IPhraseSink_FWD_DEFINED__ */


#ifndef __IWordSink_FWD_DEFINED__
#define __IWordSink_FWD_DEFINED__
typedef interface IWordSink IWordSink;
#endif 	/* __IWordSink_FWD_DEFINED__ */


#ifndef __IWordBreaker_FWD_DEFINED__
#define __IWordBreaker_FWD_DEFINED__
typedef interface IWordBreaker IWordBreaker;
#endif 	/* __IWordBreaker_FWD_DEFINED__ */


#ifndef __IWordBreakerConfig_FWD_DEFINED__
#define __IWordBreakerConfig_FWD_DEFINED__
typedef interface IWordBreakerConfig IWordBreakerConfig;
#endif 	/* __IWordBreakerConfig_FWD_DEFINED__ */


#ifndef __IITStopWordList_FWD_DEFINED__
#define __IITStopWordList_FWD_DEFINED__
typedef interface IITStopWordList IITStopWordList;
#endif 	/* __IITStopWordList_FWD_DEFINED__ */


// Supporting definitions for IWordBreaker.
typedef struct tagTEXT_SOURCE TEXT_SOURCE;
typedef SCODE (__stdcall *PFNFILLTEXTBUFFER)(TEXT_SOURCE *pTextSource);

typedef struct tagTEXT_SOURCE
{
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
} TEXT_SOURCE;


DECLARE_INTERFACE_(IWordBreaker, IUnknown)
{
	STDMETHOD(Init)(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
	STDMETHOD(BreakText)(TEXT_SOURCE *pTextSource, IWordSink *pWordSink,
											IPhraseSink *pPhraseSink) PURE;
	STDMETHOD(ComposePhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
						WCHAR const *pwcModifier, ULONG cwcModifier,
						ULONG ulAttachmentType, WCHAR *pwcPhrase,
												ULONG *pcwcPhrase) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
};

typedef IWordBreaker *PIWBRK;


// Break word types that can be passed to
// IWordBreakerConfig::SetBreakWordType.
#define IITWBC_BREAKTYPE_TEXT		((DWORD) 0)
#define IITWBC_BREAKTYPE_NUMBER		((DWORD) 1)
#define IITWBC_BREAKTYPE_DATE		((DWORD) 2)
#define IITWBC_BREAKTYPE_TIME		((DWORD) 3)
#define IITWBC_BREAKTYPE_EPOCH		((DWORD) 4)


// Breaker control flags that can be passed to
// IWordBreakerConfig::SetControlInfo.
#define IITWBC_BREAK_ACCEPT_WILDCARDS	0x00000001  // Interpret wildcard chars
													// as such.
#define IITWBC_BREAK_AND_STEM           0x00000002  // Stem words after breaking
													// them.

// External data types that can be passed to
// IWordBreakerConfig::LoadExternalBreakerData.
#define IITWBC_EXTDATA_CHARTABLE		((DWORD) 0)		
#define IITWBC_EXTDATA_STOPWORDLIST		((DWORD) 1)


DECLARE_INTERFACE_(IWordBreakerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the word breaking
	// behavior of IWordBreaker::BreakText.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the type of words the breaker should expect
	// to see in all subsequent calls to IWordBreaker::BreakText.
	// Returns S_OK if the type is understood by the breaker
	//  object; E_INVALIDARG otherwise.
	STDMETHOD(SetBreakWordType)(DWORD dwBreakWordType) PURE;
	STDMETHOD(GetBreakWordType)(DWORD *pdwBreakWordType) PURE;

	// Sets/gets info that controls certain aspects of word breaking.
	// This method currently accepts only the following set of flags
	// in grfBreakFlags:
	//		IITWBC_BREAK_ACCEPT_WILDCARDS
	//		IITWBC_BREAK_AND_STEM
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfBreakFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfBreakFlags, DWORD *pdwReserved) PURE;

	// Will load external breaker data, such as a table containing
	// char-by-char break information or a list of stop words.
	// Although the format of the data in the stream is entirely
	// implementation-specific, this interface does define a couple
	// of general types for that data which can be passed in
	// dwStreamDataType:
	//		IITWBC_EXTDATA_CHARTABLE
	//		IITWBC_EXTDATA_STOPWORDLIST
	STDMETHOD(LoadExternalBreakerData)(IStream *pStream,
										DWORD dwExtDataType) PURE;

	// These methods allow a stemmer to be associated with the breaker.  The
	// breaker will take responsibility for calling
	// IPersistStreamInit::Load/Save when it is loaded/saved if the stemmer
	// supports that interface.
	STDMETHOD(SetWordStemmer)(REFCLSID rclsid, IStemmer *pStemmer) PURE;
	STDMETHOD(GetWordStemmer)(IStemmer **ppStemmer) PURE;
};

typedef IWordBreakerConfig *PIWBRKC;


// Supporting definitions for IWordSink.
typedef enum tagWORDREP_BREAK_TYPE
{
    WORDREP_BREAK_EOW = 0,
    WORDREP_BREAK_EOS = 1,
    WORDREP_BREAK_EOP = 2,
    WORDREP_BREAK_EOC = 3
} WORDREP_BREAK_TYPE;


DECLARE_INTERFACE_(IWordSink, IUnknown)
{
	STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc,
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc, 
						ULONG cwcSrcLen, ULONG cwcSrcPos) PURE;
	STDMETHOD(StartAltPhrase)(void) PURE;
	STDMETHOD(EndAltPhrase)(void) PURE;
	STDMETHOD(PutBreak)(WORDREP_BREAK_TYPE breakType) PURE;
};

typedef IWordSink *PIWRDSNK;


DECLARE_INTERFACE_(IPhraseSink, IUnknown)
{
	STDMETHOD(PutSmallPhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
								WCHAR const *pwcModifier, 
								ULONG cwcModifier,
								ULONG ulAttachmentType) PURE;
	STDMETHOD(PutPhrase)(WCHAR const *pwcPhrase, ULONG cwcPhrase) PURE;
};

typedef IPhraseSink *PIPHRSNK;


// Function or macro that can be used by a breaker implementation
// to pull characters from the caller's text source.
#ifdef __cplusplus

inline WCHAR WBreakGetWChar(TEXT_SOURCE *pTextSource )
{
    if ( pTextSource->iCur == pTextSource->iEnd )
    {
        if ( FAILED(pTextSource->pfnFillTextBuffer( pTextSource ) ) )
            return 0xFFFF;  // UniCode EOF
    }

    return pTextSource->awcBuffer[pTextSource->iCur++];
};

#else

#define WBreakGetWChar( pTextSource )\
    (pTextSource->iCur==pTextSource->iEnd)\
    ? (FAILED(pTextSource->pfnFillTextBuffer( pTextSource )) \
       ? 0xFFFF\
       : pTextSource->awcBuffer[pTextSource->iCur++])\
    : pTextSource->awcBuffer[pTextSource->iCur++]

#endif


DECLARE_INTERFACE_(IITStopWordList, IUnknown)
{
	STDMETHOD(AddWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
	STDMETHOD(LookupWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef	IITStopWordList	*PIITSTWDL;


#endif		// __ITWBRK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itwbrkid.h ===
// ITWBRKID.H:	IIDs and other GUIDs related to word breaking and stemming.

#ifndef __ITWBRKID_H__
#define __ITWBRKID_H__

#include <comdef.h>

//----------------------------------------------------------------------
//------			Word Breaking Definitions				------------
//----------------------------------------------------------------------

// {D53552C8-77E3-101A-B552-08002B33B0E6}
DEFINE_GUID(IID_IWordBreaker, 
0xD53552C8, 0x77E3, 0x101A, 0xB5, 0x52, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC907054-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IWordSink, 
0xCC907054, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC906FF0-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IPhraseSink, 
0xCC906FF0, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {8fa0d5a6-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IWordBreakerConfig, 
0x8fa0d5a6, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daaf-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITStdBreaker, 
0x4662daaf, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------			Stop Word List Definitions				------------
//----------------------------------------------------------------------

// {8fa0d5ad-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITStopWordList, 
0x8fa0d5ad, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------				Stemming Definitions				------------
//----------------------------------------------------------------------

// {efbaf140-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemmer, 
0xefbaf140, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {fe77c330-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemSink, 
0xfe77c330, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {8fa0d5a7-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IStemmerConfig, 
0x8fa0d5a7, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5a8-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_ITEngStemmer, 
0x8fa0d5a8, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


#endif // __ITWBRKID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\language.h ===
#ifndef __LANGUAGE_H__
#define __LANGUAGE_H__
//////////////////////////////////////////////////////////////////////////
//
//
//	language.h --- Header for language related classes.
//
//
/*
    This file contains classes related to managing the UI language of HHCTRL.

*/
//////////////////////////////////////////////////////////////////////////
//
// Forwards
//
class CLanguage ;

//////////////////////////////////////////////////////////////////////////
//
// Constants
//
const LANGID c_LANGID_ENUM_EOF= static_cast<LANGID>(-1) ;

//////////////////////////////////////////////////////////////////////////
//
// CLanguageEnum
//
/*
    This class enumerates the langids to attempt. If you are trying to access
    some object using a langid and that object may not be in that particular langid,
    you should use this class to get an array of langids to try.

    NOTE: This class should only be obtained from the CLanguage class below.
*/
class CLanguageEnum
{
//--- Relationships
    friend CLanguage ;

//--- Construction
private:
    // Will return the langid passed in first. This is the 
    CLanguageEnum(LANGID langid1 = NULL, LANGID langid2 = NULL, bool bSysOnly = false) ;

public:
    virtual ~CLanguageEnum() ;

//--- Access
public:
    LANGID start() ; 
    LANGID next() ; // The last LANGID is always 0 which can be used as a "search for anything" flag. After the 0, next returns c_LANGID_ENUM_EOF .

//--- Member variables
private:
    // Current index into array.
    int m_index ;

    // number of items in the array.
    int m_items ;

    // Number of LangIds to search
    LANGID* m_langids;
};

//////////////////////////////////////////////////////////////////////////
//
// CLanguage
//
class CLanguage
{
//--- Construction
public:
    CLanguage() ;
    virtual ~CLanguage() ;

//--- Access
public:
    // All of the access functions are self initializing.

    // Returns the language identifier of the ui/resources.
    LANGID GetUiLanguage() ;

    // Set the LangId for the resources you want to use --- Used by external clients. Loads the correct satellite dll.
    LANGID SetUiLanguage(LANGID langid) ; // Returns the actually langid the control is set to.

    // Returns an enumerator to enumerate the possible ui languages. Caller responsible for deleting.
    CLanguageEnum* GetEnumerator(LANGID langidOther = NULL) {_Init(); return _GetEnumerator(langidOther); }

    // Load the satellite dll --- Called by the module.cpp. 
    HINSTANCE LoadSatellite() {_Init(); return m_hSatellite ; } // This may appear wierd, but m_hSatellite is NULL if m_langid is 0x0409.

    // Return's the user's os ui language. 
    LANGID GetUserOsUiLanguage() ;  //REVIEW: Move to COsLanguage class?

//--- Private Member functions
private:
    void _Init() {if (!m_langid) _LoadSatellite(); }

    // Non-auto load.
    void _LoadSatellite() ;

    // Non-auto load.
    CLanguageEnum* _GetEnumerator(LANGID landidOther = NULL) ;

    // Enumerate only the sys lcids and english lcids. Used by satellite dlls.
    CLanguageEnum*  _GetSysEnumerator(LANGID landidOther = NULL) ; 
 

//--- Member variables
private:
    // Language ID of the user interface. This is either set by the client or by default when we load the satellite.
    LANGID m_langid ;

    // Satellite instance handle. If m_langid is 0x0409 (english) we don't have a satellite dll.
    HINSTANCE m_hSatellite ;

	// Function Pointer type for Get*DefaultUILanguage Functions
	typedef LANGID (WINAPI *FntPtr_GetDefaultUILanguage)();

	// Function pointer to the Get*DefaultUILanguage
	FntPtr_GetDefaultUILanguage m_fpGetUserDefaultUILanguage ;
    FntPtr_GetDefaultUILanguage m_fpGetSystemDefaultUILanguage ;

	// Pointer to the Module handle.
	HMODULE m_hNlsModule;

};


#endif //__LANGUAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\itww.h ===
// ITWW.H:	IITWordWheel interface declaration

#ifndef __ITWW_H__
#define __ITWW_H__

// {8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITWordWheel, 
0x8fa0d5a4, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {D73725C2-8C12-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITWordWheel, 
0xd73725c2, 0x8c12, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa8-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITWordWheelLocal, 
0x4662daa8, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Word-wheel open flags
#define ITWW_OPEN_CONNECT	0x00000000    // connect to server on open (the default)
#define ITWW_OPEN_NOCONNECT	0x00000001    // don't connect to server on open

// Constants for IITWordWheel::Lookup.
#define ITWW_CBKEY_MAX		1024		// Max size of keys allowed in Word Wheels.

// Forward declarations
interface IITDatabase;
interface IITResultSet;
interface IITGroup;
interface IITPropList;
interface IITQuery;

DECLARE_INTERFACE_(IITWordWheel, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags=0) PURE;
	STDMETHOD(Close)(void) PURE;

	// Returns the code page ID and locale ID that the word wheel was built and
	// sorted with.
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Returns in *pdwObjInstance the ID of the external sort instance being used by
	// this word wheel.  The instance ID can be passed to IITDatabase::GetObject to
	// to obtain an interface pointer on the instantiated instance.  If the word
	// wheel doesn't use external sorting, then IITDB_OBJINST_NULL.
	STDMETHOD(GetSorterInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(Count)(LONG *pcEntries) PURE;

	// To be safe, the length of lpvKeyBuf should always be at least ITWW_CBKEY_MAX. 
	STDMETHOD(Lookup)(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf) PURE;
	STDMETHOD(Lookup)(LONG lEntry, IITResultSet* lpITResult, LONG cEntries) PURE;
	STDMETHOD(Lookup)(LPCVOID lpcvPrefix, BOOL fExactMatch, LONG *plEntry) PURE;

	STDMETHOD(SetGroup)(IITGroup* piitGroup) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;

	STDMETHOD(GetDataCount)(LONG lEntry, DWORD *pdwCount) PURE;
	STDMETHOD(GetData)(LONG lEntry, IITResultSet* lpITResult) PURE;
	STDMETHOD(GetDataColumns)(IITResultSet* pRS) PURE;
};

typedef IITWordWheel* LPITWORDWHEEL;

#endif		// __ITWW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\objcnt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//
//  objcnt.h    --- Support for counting object instances.
//
//
#ifndef __OBJCNT_H__
#define __OBJCNT_H__

/*
    This class catches class instance leaks. If you new a class, but do
    not delete it, this class will find it.

    The nice thing about this class is that it is very simple to use.

    Simple Instructions
    -------------------

    Assume X is the name of the class you want to count objects:

    1. Inherit your class X from SI_COUNT(X). 
    2. Add the following line to a .CPP file in global scope:
        AUTO_CLASS_COUNT_CHECK(X) ;

    For more information refer to the detailed directions below.

    Detailed Instructions
    ---------------------

    1. Inherit from one of the *_COUNT macros passing the name of the class your are tracking.

        If your class does not inherit from another class use SI_COUNT (Single Inheritance Count):

            class CHmData SI_COUNT(CHmData) // No ':'.
            {
                ....
            };
           

            // Notice that you do not use the ':' between the class name and the SI_COUNT macros.

        If your class inherits from another class use MI_COUNT (Multiple Inheritances) instead of
        SI_COUNT:

            class CExMergedTitleNode : MI_COUNT(CExMergerTitleNode)
                                        public CTitleNode
            {
                ...
            } ;
        

            // Notice that you need the ':' when using MI_COUNT. However, DO NOT use the ending comma ','.


        If your class has to inherit from another class first, for example CHHWinType, use MI2_COUNT and
        place it last on the inheritance chain:

            class CHHWinType :  public HH_WINTYPE
                                MI2_COUNT(CHHWinType)
            {
                ...
            };

            // Notice that there isn't a comma before MI2_COUNT.

  
    2.  If you want to automatically, check the allocation/deallocation count at CRT shutdown, 
        use the AUTO_CLASS_COUNT_CHECK macro. In a .CPP file outside the scope of a function, 
        place the following line:

            AUTO_CLASS_COUNT_CHECK(CExNode);

        where CExNode is the name of the class you want to automatically count.
    
        This macro creates a class which will call the check routine when it goes out of scope. 
        This will happen when the CRTs are unloaded.


    3. If you want to check the class object count at a specific instance, use the CHECK_CLASS_COUNT macro.

            CHECK_CLASS_COUNT(CExNode) ;

        This creates a function call to the Check function.

        This was used in the CloseWindow function in secwin.cpp to find out what was and wasn't cleaned up
        after closing a window.


    4.  The best way to catch the messages is to place a break point on the line below with the DebugBreak call.
    
        A message box will normally be displayed showing the count. However, due to the threading issues
        sometimes the thread goes away before the Messsage box is visible. 



*/
///////////////////////////////////////////////////////////////////////////////
//
// Global Helper function
//

///////////////////////////////////////////////////////////////////////////////
//
// Forwards
//
template <typename X> class CAutoClassCountCheck;

///////////////////////////////////////////////////////////////////////////////
//
// CClassObjectCount
//
template <typename X>
class CClassObjectCount
{
  
    friend class CAutoClassCountCheck<X> ;

public:
    
    // Constructor
    CClassObjectCount()
    {
        m_construct++ ;
    }

    // Destructor
    ~CClassObjectCount()
    {
        m_destruct++ ;
    }

    // Dump the statistics.
    static void Dump(const char* szName)
    {
#if 0
        char buf[256] ;
        wsprintf(buf, "construct:%d\ndestruct:%d", m_construct, m_destruct) ;
        MessageBox(NULL, buf, szName, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
#else
        char buf2[1024];
        wsprintf( buf2, "*** Memory Leak: %s class, construct:%d, destruct:%d\r\n", szName, m_construct, m_destruct );
        OutputDebugString( buf2 );
#endif
    }

    // Check to see if everything was deallocated.
    static void Check(const char* szName)
    {
        if (m_construct != m_destruct)
        {
            //--- PLACE BREAK POINT HERE ---
            //DebugBreak() ;
            Dump(szName) ;
        }
    }

private:
    // Member variables.
    static int m_construct;
    static int m_destruct;
};

///////////////////////////////////////////////////////////////////////////////
//
// statics
//
template <typename X>
int CClassObjectCount<X>::m_construct = 0;

template <typename X>
int CClassObjectCount<X>::m_destruct = 0;


///////////////////////////////////////////////////////////////////////////////
//
// CAutoClassCountCheck
//
template <typename X>
class CAutoClassCountCheck
{
public:
    CAutoClassCountCheck(const char* name)
    {
        m_name = name ;
    }

    virtual ~CAutoClassCountCheck() 
    {
        CClassObjectCount<X>::Check(m_name);
    }

public:
    const char* m_name ;
};




///////////////////////////////////////////////////////////////////////////////
//
// Macros
//
#ifdef _DEBUG 

/////////////////// DEBUG MACROS /////////////////// 

// Don't use this macro directly
#define COUNT(x) private CClassObjectCount<x>

// Use with multiple inheritance. Always first.
#define MI_COUNT(x) COUNT(x),

// Use with single inheritance. Always first.
#define SI_COUNT(x) : COUNT(x)

// Use with multiple inheritance. Always last.
#define MI2_COUNT(x) ,COUNT(x)

// Create a class which calls check on exit.
#define AUTO_CLASS_COUNT_CHECK(x) \
    CAutoClassCountCheck<x> _dumpclass_##x(#x) 

// Check the class count.
#define CHECK_CLASS_COUNT(x) \
    CClassObjectCount<x>::Check(#x) 

// Dump the class count
#define DUMP_CLASS_COUNT(x)\
    CClassObjectCount<x>::Dump(#x) 

#else

/////////////////// RELEASE MACROS /////////////////// 

#define COUNT(x) 
#define MI_COUNT(x) 
#define SI_COUNT(x)
#define MI2_COUNT(x)

#define AUTO_CLASS_COUNT_CHECK(x) 

#define CHECK_CLASS_COUNT(x) 
#define DUMP_CLASS_COUNT(x)
#endif

#endif __OBJCNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\parser.h ===
//*********************************************************************************************************************************************
//
//      File: Parser.h
//  Author: Donald Drake
//  Purpose: Defines classes to support parsing tokens from a xml file

#ifndef _PARSER_H
#define _PARSER_H

#include <stdio.h>

#undef CLASS_IMPORT_EXPORT
#ifdef HHCTRL // define this only when building the HHCtrl DLL
  #define CLASS_IMPORT_EXPORT /**/
#else
 #ifdef HHSETUP // define this only when building the HHSetup DLL
  #define CLASS_IMPORT_EXPORT __declspec( dllexport )
 #else
  #define CLASS_IMPORT_EXPORT __declspec( dllimport )
 #endif
#endif

#define MAX_LINE_LEN 1024

#define F_OK 0
#define F_NOFILE 1
#define F_READ 2
#define F_WRITE 3
#define F_MEMORY 4
#define F_EOF 5
#define F_END 6
#define F_TAGMISSMATCH 7
#define F_MISSINGENDTAG 8
#define F_NOTFOUND 9
#define F_NOPARENT 10
#define F_NULL 11
#define F_NOTITLE 12
#define F_LOCATION 13
#define F_REFERENCED 14
#define F_DUPLICATE 15
#define F_DELETE 16
#define F_CLOSE 17
#define F_EXISTCHECK 19

class CParseXML {
private: // data

	CHAR m_cCurToken[MAX_LINE_LEN];
	CHAR m_cCurWord[MAX_LINE_LEN];
	CHAR m_cCurBuffer[MAX_LINE_LEN];
	FILE *m_fh;
	CHAR * m_pCurrentIndex;
	DWORD m_dwError;

private: // functions
	DWORD Read();
	DWORD SetError(DWORD dw) { m_dwError = dw; return m_dwError; }
public:

	CParseXML() {
		m_fh = NULL;
		m_cCurBuffer[0] = '\0';
		m_pCurrentIndex = NULL;
		m_dwError = F_OK;
	}

	~CParseXML() {
		End();
	}

	CHAR * GetFirstWord(CHAR *);
	CHAR * GetValue(CHAR *);

	DWORD Start(const CHAR *szFile);
	void End();
	CHAR *GetToken();
	DWORD GetError() { return m_dwError; }
};

// class to support a FIFO queue of strings
typedef struct  fifo {
	CHAR *string;
	fifo *prev;
} FIFO;

class CLASS_IMPORT_EXPORT  CFIFOString {
private:

	FIFO *m_fifoTail;

public:

	CFIFOString() { m_fifoTail = NULL; }
	~CFIFOString();
	void RemoveAll();

	DWORD AddTail(CHAR *sz);
	DWORD GetTail(CHAR **sz);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\unicode.h ===
// unicode.h - Unicode functions that work on all 32-bit Window platform

#pragma once

#ifndef __UNICODE_H__
#define __UNICODE_H__

// C/C++ differences
#ifndef INLINE
#ifdef __cplusplus
#define INLINE inline
#else
#define INLINE __inline
#endif
#endif

#define CP_UNICODE          1200 // Unicode
#define IN_RANGE(v, r1, r2) ((r1) <= (v) && (v) <= (r2))


//====================
// From VS6 minar.h
//====================

class CBufImpl
{
private:
    BYTE * m_pData;
    int    m_cb;
    
    HRESULT _SetByteSize (int cb);

public:
    CBufImpl() : m_pData(NULL), m_cb(0) {}
    ~CBufImpl()  { Clear(); }

    void    Clear             ();
    HRESULT SetByteSize       (int cb);
    HRESULT SetByteSizeShrink (int cb);
    int     GetByteSize       () { return m_cb; }
    BYTE *  ByteData          () { return m_pData; }
};

inline HRESULT CBufImpl::SetByteSize (int cb)
{
    if (cb <= m_cb)
        return S_OK;
    return _SetByteSize(cb);
}

//---------------------------------------------------------------
template <class T> class CMinimalArray : public CBufImpl
{
public:
    HRESULT SetSize       (int cel) { return SetByteSize(cel*sizeof(T)); }
    HRESULT SetSizeShrink (int cel) { return SetByteSizeShrink(cel*sizeof(T)); }
    int     Size    ()        { return GetByteSize()/sizeof(T); }
    operator T*     ()        { return (T*)ByteData(); }
    T*      GetData ()        { return (T*)ByteData(); }
};


//====================
// From VS6 intlutil.h
//====================

/////////////////////////////////////////////////////////////////
// GetDefaultFont - Get default monospaced font for a codepage
//
// IN   cp   Codepage -- usually result of GetACP().
// IN   plf  Address of uninitialized LOGFONT structure.
// OUT  plf  Fully initialized LOGFONT struct.
//
void GetDefaultFont(UINT cp, LOGFONT * plf, BYTE *pbySize);

BOOL IsStringDisplayable(const char *pszString, UINT codepage);

/////////////////////////////////////////////////////////////////
// locale/codepage mappings
//
#define LCIDCP_CURRENT (2)
#define LCIDCP_GUESSED (1)
#define LCIDCP_UNKNOWN (0)
int WINAPI LCIDFromCodePage(UINT cp, LCID * plcid);

UINT WINAPI CodePageFromLCID(LCID lcid);
UINT WINAPI CodepageFromCharset(BYTE cs);
BOOL WINAPI IsSupportedFontCodePage(UINT cp);

BOOL WINAPI IsDbcsGdi ();
BOOL WINAPI IsWin95OrLess ();
BOOL WINAPI IsNT ();
BOOL WINAPI WideAPIHack ();
UINT WINAPI GetFontCodePage (HDC hdc);
BOOL IntlGetTextExtentPoint32W (HDC hdc, LPCWSTR lpString, int cbString, LPSIZE lpSize, UINT *pCP = NULL);
BOOL IntlExtTextOutW (HDC hdc, int X, int Y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpString, UINT cbCount, CONST INT *lpDx, UINT *pCP = NULL); 
BOOL IntlTextOutW(HDC hdc, int nXStart, int nYStart, LPCWSTR lpString, int cbString, UINT *pCP = NULL);
BOOL IntlGetTextExtentExPointW(HDC hdc, LPCWSTR lpString, int cbString, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize, UINT *pCP = NULL);

BOOL HxAppendMenu(HMENU hMenu, UINT uFlags, UINT uIDNewItem, LPCTSTR lpNewItem);

BOOL HxSetWindowText(HWND hWnd, LPCTSTR lpString);

BOOL IntlExtTextOut( HDC hdc, int X, int Y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpString, UINT cbCount, CONST INT *lpDx, UINT* pCP );

inline BOOL IntlTextOutW (HDC hdc, int nXStart, int nYStart, LPCWSTR lpString, int cch, UINT *pCP)
{
    // WARNING: this is not completely generic.
    // This does work for the ways we use TextOut.
    return IntlExtTextOutW(hdc, nXStart, nYStart, 0, NULL, lpString, cch, NULL, pCP);
}

inline BOOL IsImeLanguage(LANGID wLang)
{
    wLang = PRIMARYLANGID(wLang);
    if (LANG_NEUTRAL  == wLang) return FALSE;
    if (LANG_ENGLISH  == wLang) return FALSE;
    if (LANG_JAPANESE == wLang) return TRUE;
    if (LANG_KOREAN   == wLang) return TRUE;
    if (LANG_CHINESE  == wLang) return TRUE;
    return FALSE;
}

inline BOOL IsImeCharSet(BYTE charset)
{
    if (ANSI_CHARSET        == charset) return FALSE;
    if (SHIFTJIS_CHARSET    == charset) return TRUE;
    if (GB2312_CHARSET      == charset) return TRUE;
    if (CHINESEBIG5_CHARSET == charset) return TRUE;
    if (HANGEUL_CHARSET     == charset) return TRUE;
    if (JOHAB_CHARSET       == charset) return TRUE;
    return FALSE;
}

#endif // __UNICODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\module.h ===
//////////////////////////////////////////////////////////////////////////
//
//
// module.h - CHtmlHelpModule
//
//
/*
    HTMLHelp specific module class.
    * Implements support for satellite DLL resources.
*/

#ifndef __CHtmlHelpModule__
#define __CHtmlHelpModule__

// Declaration of CLanguage
#include "language.h"

// array of global window type names
#include "gwintype.h"

//////////////////////////////////////////////////////////////////////////
//
// CHtmlHelpModule
//
class CHtmlHelpModule : public CComModule
{
public:
    // Construction
    CHtmlHelpModule()
        : m_bResourcesInitialized(false)
    {
       szCurSS[0] = '\0';
       m_cp = -1;
    }

    // Destructor
    ~CHtmlHelpModule() {}

public:
    //
    // Operations
    //
    // Blocks CComModule's version. This isn't a virtual.
    HINSTANCE GetResourceInstance() { InitResources() ; return m_hInstResource; }
    UINT GetCodePage() { return ((m_cp == -1)?CP_ACP:m_cp); }
    void SetCodePage(UINT cp) { if ( m_cp == -1 ) m_cp = cp; }

private:
    // Self initialize the resources
    void InitResources() { if (!m_bResourcesInitialized) LoadSatellite(); }

    // Load the satellite dll.
    void LoadSatellite() ;

private:
    //
    // Member Variables
    //

    bool m_bResourcesInitialized;
    UINT m_cp;

public:
    // UI Language information.
    CLanguage m_Language ;

    // Contains an array of global window type names.
    CGlobalWinTypes m_GlobalWinTypes ;

    // Current subset name (?)
    TCHAR szCurSS[51];
} ;
#endif //__CHtmlHelpModule__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hhsetup.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\verdef.h ===
#ifdef HHCTRL
#define IDS_VERSION_STRING		"HTML Help Control Version 4.74.9120"
#endif

#define VERSION 			"4.74.9120"
#define VER_PRODUCTVERSION_STR		"4.74.9120\0"
#define VER_PRODUCTVERSION		4,74,9120,0
#define VER_PRODUCTVERSION_DW		(0x04740000 | 9120)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\lcmem.h ===
// Copyright (C) 1993-1997 Microsoft Corporation. All rights reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef LCMEM_H
#define LCMEM_H

#define THIS_FILE __FILE__

#define CHECK_AND_FREE(x) if (x) { lcFree(x) ; x = NULL ; }

// map all memory functions to CRT except for HHW which
// uses the exported functions from HHA
#ifdef HHW

// exported by HHA
void* STDCALL rmalloc(int cb);
void* STDCALL rcalloc(int cb);
void  STDCALL rfree(void* pv);
void* STDCALL rrealloc(void* pv, int cb);
void  STDCALL rclearfree(void** pv);
int   STDCALL lcSize(void* pv);

// map the lc functions to those exported by HHA
#define lcMalloc(cb)      rmalloc(cb)
#define lcCalloc(cb)      rcalloc(cb)
#define lcFree(pv)        rfree((void*) (pv))
#define lcClearFree(pv)   rclearfree((void**) (pv))
#define lcReAlloc(pv, cb) rrealloc((void*) (pv), cb)

#else // HHA and HHCTRL

#include <malloc.h>
#include <crtdbg.h>

#define lcMalloc(cb)      malloc(cb)
__inline void* lcCalloc(int cb) { void* pv = lcMalloc(cb); ZeroMemory(pv, cb); return pv; }
#define lcFree(pv)        free((void*) pv)
#define lcClearFree(pv) { lcFree(*pv); *pv = NULL; }
#define lcReAlloc(pv, cb) realloc(pv, cb)

#define lcSize(pv)        _msize(pv)

#endif // HHW

// common to all
#define lcHeapCheck()

PSTR lcStrDup(PCSTR psz);
PWSTR lcStrDupW(PCWSTR psz);

#ifdef HHCTRL
void OnReportMemoryUsage();
#endif

class CMem
{
public:
    PBYTE pb;
#ifndef HHCTRL
    PSTR  psz; // identical to pb, used for casting convenience
#endif

    CMem(void);
    CMem(int size);
    ~CMem(void) {
        if(pb)
            lcFree(pb);
    }

#ifndef HHCTRL
    int size(void);
    void resize(int cb);
#endif

    void ReAlloc(int cbNewSize) {
        pb = (PBYTE) lcReAlloc(pb, cbNewSize);
#ifndef HHCTRL
        psz = (PSTR) pb;
#endif
    }
    void Malloc(int cb) {
        _ASSERT(!pb);
        pb = (PBYTE) lcMalloc(cb);
#ifndef HHCTRL
        psz = (PSTR) pb;
#endif
    }

    operator void*() { return (void*) pb; };
    operator PCSTR() { return (PCSTR) pb; };
    operator PSTR()  { return (PSTR) pb; };
    operator PBYTE() { return pb; };
    operator LPWSTR() { return (LPWSTR) pb; };
};

#endif // LCMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\util.cpp ===
#include <windows.h>
#include "util.h"

#ifndef ASSERT
#if defined(_DEBUG) || defined(DEBUG)
#define ASSERT(b) if(!b) MessageBox(NULL, "FAILED: #b", "ASSERT", MB_OK );
#else
#define ASSERT(b)
#endif
#endif

#define MAX_STRING_RESOURCE_LEN 1024
LPCSTR g_pszMsgBoxTitle = "HTML Help Dumper Tool";

int MsgBox(int idString, UINT nType)
{
    char szMsg[MAX_STRING_RESOURCE_LEN + 1];
    if (LoadString(GetModuleHandle(NULL), idString, szMsg,
            sizeof(szMsg)) == 0) {
        return 0;
    }
    return MessageBox(GetActiveWindow(), szMsg, g_pszMsgBoxTitle, nType);
}

int MsgBox(PCSTR pszMsg, UINT nType)
{
    return MessageBox(GetActiveWindow(), pszMsg, g_pszMsgBoxTitle, nType);
}

PCSTR FindFilePortion( PCSTR pszFile )
{
  PCSTR psz = strrchr(pszFile, '\\');
  if (psz)
    pszFile = psz + 1;
  psz = strrchr(pszFile, '/');
  if (psz)
    return psz + 1;
  psz = strrchr(pszFile, ':');
  return (psz ? psz + 1 : pszFile);
}

typedef enum { JAN=1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC } MONTHS;

int DaysInMonth(int nMonth, int nYear)
{
  switch( nMonth ) {
    case SEP: case APR: case JUN: case NOV:
      return 30;

    case FEB:
      return (nYear % 4) == 0 ? 29 : 28;      // handle leap year

    default:
      return 31;
  }
}

int JulianDate(int nDay, int nMonth, int nYear)
{
  int nDayOfYear = 0;
  int iMonth;

  for( iMonth = JAN ; iMonth < nMonth ; iMonth++ )
    nDayOfYear += DaysInMonth(iMonth, nYear);

  return( (nYear % 10) * 1000 + nDayOfYear + nDay );
}

#define YRMASK        0xFE00
#define YRSHIFT       9

#define MONMASK       0x01E0
#define MONSHIFT      5

#define DAYMASK       0x001F
#define DAYSHIFT      0

#define HRMASK        0xF800
#define HRSHIFT       11
#define MINMASK       0x07E0
#define MINSHIFT      5
#define SECMASK       0x001F
#define SECSHIFT      0

HRESULT FileTimeToDateTimeString( FILETIME FileTime, LPTSTR pszDateTime )
{
  HRESULT hr = S_FALSE;

  WORD wDosDate = 0;
  WORD wDosTime = 0;
  if( FileTimeToDosDateTime( &FileTime, &wDosDate, &wDosTime ) ) {
    DWORD dwDay    = (wDosDate & DAYMASK) >> DAYSHIFT;
    DWORD dwMonth  = (wDosDate & MONMASK) >> MONSHIFT;
    DWORD dwYear   = (((wDosDate & YRMASK) >> YRSHIFT) + 80) % 100;
    DWORD dwHour   = (wDosTime & HRMASK) >> HRSHIFT;
    DWORD dwMinute = (wDosTime & MINMASK) >> MINSHIFT;
    DWORD dwSecond = ((wDosTime & SECMASK) >> SECSHIFT) * 2;
    LPCSTR pszAMPM = NULL;

    if( dwHour >= 12 ) 
      pszAMPM = "PM";
    else
      pszAMPM = "AM";
    if( dwHour > 12 )
      dwHour -= 12;
    if( dwHour == 0 )
      dwHour = 12;

    wsprintf( pszDateTime, "%02d/%02d/%02d %02d:%02d %s", 
      dwMonth, dwDay, dwYear, dwHour, dwMinute, pszAMPM );

    hr = S_OK;
  }

  return hr;
}

int FileTimeToJulianDate( FILETIME FileTime )
{
  int iReturn = 0;

  WORD wDosDate = 0;
  WORD wDosTime = 0;
  if( FileTimeToDosDateTime( &FileTime, &wDosDate, &wDosTime ) ) {
    DWORD dwDay    = (wDosDate & DAYMASK) >> DAYSHIFT;
    DWORD dwMonth  = (wDosDate & MONMASK) >> MONSHIFT;
    DWORD dwYear   = ((wDosDate & YRMASK) >> YRSHIFT) + 1980;
    iReturn = JulianDate( dwDay, dwMonth, dwYear );
  }

  return iReturn;
}

///////////////////////////////////////////////////////////
//
// Get the windows directory for the system or the user
//
// Note, Windows NT Terminal Server has changed the system API
// of GetWindowsDirectory to return a per-user system directory.
// Inorder to determine this condtion we need to check kernel32
// for the GetSystemWindowsDirectory API and if it exists use
// this one instead.
//
UINT HHGetWindowsDirectory( LPSTR lpBuffer, UINT uSize, UINT uiType )
{
  UINT uiReturn = 0;
  PFN_GETWINDOWSDIRECTORY pfnGetUsersWindowsDirectory = NULL;
  PFN_GETWINDOWSDIRECTORY pfnGetSystemWindowsDirectory = NULL;

  // determine which system API to call for each case
  HINSTANCE hInst = LoadLibrary( "Kernel32" );
  if( !hInst )
    return uiReturn;

  pfnGetSystemWindowsDirectory = (PFN_GETWINDOWSDIRECTORY) GetProcAddress( hInst, "GetSystemWindowsDirectoryA" );
  pfnGetUsersWindowsDirectory = (PFN_GETWINDOWSDIRECTORY) GetProcAddress( hInst, "GetWindowsDirectoryA" );
  ASSERT( pfnGetUsersWindowsDirectory ); // if NULL then we have a bug!

  if( !pfnGetSystemWindowsDirectory ) {
    pfnGetSystemWindowsDirectory = pfnGetUsersWindowsDirectory;
  }


  if( uiType == HH_SYSTEM_WINDOWS_DIRECTORY )
    uiReturn = pfnGetSystemWindowsDirectory( lpBuffer, uSize );
  else if( uiType == HH_USERS_WINDOWS_DIRECTORY )
    uiReturn = pfnGetUsersWindowsDirectory( lpBuffer, uSize );
  else
    uiReturn = 0;

  FreeLibrary( hInst );
  return uiReturn;
}

LPSTR CatPath(LPSTR lpTop, LPCSTR lpTail)
{
    //
    // make sure we have a slash at the end of the first element
    //
    LPSTR p;

    p = lpTop + strlen(lpTop);
    p = CharPrev(lpTop,p);
    if (*p != '\\' && *p != '/')
    {
        strcat(lpTop,"\\");
    }

    //
    // strip any leading slash from the second element
    //

    while (*lpTail == '\\') lpTail = CharNext(lpTail);

    //
    // add them together
    //

    strcat(lpTop, lpTail);

    return lpTop;
}


#pragma data_seg(".text", "CODE")

static const char txtGlobal[] = "global.col";
static const char txtColReg[] = "hhcolreg.dat";
static const char txtHelp[]   = "help";
static const char txtHHDat[]  = "hh.dat";

#pragma data_seg()

///////////////////////////////////////////////////////////
//
// Get the help directory
//
// Note, this is always relative to the system's windows
// directory and not the user's windows directory.
// See HHGetWindowsDirectory for details on this.
//
UINT HHGetHelpDirectory( LPTSTR lpBuffer, UINT uSize )
{
  UINT uiReturn = 0;

  uiReturn = HHGetWindowsDirectory( lpBuffer, uSize );
  CatPath( lpBuffer, txtHelp );

  return uiReturn;
}

DWORD CreatePath(char *szPath)
{
   char szTmp[MAX_PATH],*p,*q,szTmp2[MAX_PATH];
   DWORD dwErr;

   strcpy(szTmp2,szPath);
   memset(szTmp,0,sizeof(szTmp));
   q = szTmp2;
   p = szTmp;

   while (*q)
   {
      if (*q == '/' || *q == '\\')
      {
         if (szTmp[1] == ':' && strlen(szTmp) <= 3)
         {
            if(IsDBCSLeadByte(*q))
         {
                *p++ = *q++;
            if(*q)
                    *p++ = *q++;
         }
         else
                *p++ = *q++;
            continue;
         }
         if (!::CreateDirectory(szTmp,0))
         {
            if ( (dwErr = GetLastError()) != ERROR_ALREADY_EXISTS)
               return(dwErr);
         }
      }
      if(IsDBCSLeadByte(*q))
     {
          *p++ = *q++;
          if(*q)
            *p++ = *q++;
     }
     else
          *p++ = *q++;
   }
   if (!::CreateDirectory(szTmp,0))
   {
            if ((dwErr = GetLastError()) != ERROR_ALREADY_EXISTS)
               return(dwErr);
   }

   return(FALSE);
}

///////////////////////////////////////////////////////////
//
// Get the full pathname to the global collections file
//
// Note, this is in always in the system's help directory.
//
UINT HHGetGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize, BOOL *pbNewPath )
{
  UINT uiReturn = 0;

  *pbNewPath = TRUE;
  uiReturn = HHGetHelpDataPath( lpBuffer );

  if (uiReturn != S_OK)
  {
     *pbNewPath = FALSE;
     uiReturn = HHGetHelpDirectory( lpBuffer, uSize );
     if( !IsDirectory(lpBuffer) )
        CreatePath( lpBuffer );
  }   
  CatPath( lpBuffer, txtColReg );

  return uiReturn;
}

BOOL IsDirectory( LPCSTR lpszPathname )
{
  DWORD dwAttribs = GetFileAttributes( lpszPathname );
  if( dwAttribs != (DWORD) -1 )
    if( dwAttribs & FILE_ATTRIBUTE_DIRECTORY )
      return TRUE;
  return FALSE;
}

static const char txtProfiles[]        = "Profiles";
static const char txtUser[]            = "Default User";
static const char txtAllUsers[]        = "All Users";
static const char txtApplicationData[] = "Application Data";
static const char txtMicrosoft[]       = "Microsoft";
static const char txtHTMLHelp[]        = "HTML Help";
typedef HRESULT (WINAPI *PFN_SHGETFOLDERPATH)( HWND hWnd, int nFolder, HANDLE hToken, DWORD dwFlags, LPTSTR pszPath );
#ifndef CSIDL_FLAG_CREATE
#define CSIDL_COMMON_APPDATA 0x0023      
#define CSIDL_FLAG_CREATE 0x8000
#endif


///////////////////////////////////////////////////////////
//
// Get the full path to where the common help data files lives
//  hhcolreg.dat, *.chw and *.chs
//
// Note, if the subdirectories of the path does not exist
// we will create them
//
HRESULT HHGetHelpDataPath( LPSTR pszPath )
{
  HRESULT hResult = S_OK;
  PFN_SHGETFOLDERPATH pfnSHGetFolderPath = NULL;

  HINSTANCE hInst = LoadLibrary( "Shell32" );
  if( !hInst )
    return S_FALSE;

  pfnSHGetFolderPath = (PFN_SHGETFOLDERPATH) GetProcAddress( hInst, "SHGetFolderPathA" );

  // if this function does not exist then we need to similate the return path of
  // "%windir%\Profiles\All Users\Application Data"
  if( pfnSHGetFolderPath ) {
    // now call it
    hResult = pfnSHGetFolderPath( NULL, CSIDL_FLAG_CREATE | CSIDL_COMMON_APPDATA, NULL, 0, pszPath);
    if (pszPath[0] == NULL)
    {
       FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
       return S_FALSE;
    }
  }
  else
  {
    FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
    return S_FALSE;
  }
  FreeLibrary( hInst );  // since we already have a copy of Shell32 loaded, free it
      
  // append "Microsoft"
  CatPath( pszPath, txtMicrosoft );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  // append "HTML Help"
  CatPath( pszPath, txtHTMLHelp );
  if( !IsDirectory(pszPath) )
    if( !CreateDirectory( pszPath, NULL ) )
      return S_FALSE;

  return hResult;
}


///////////////////////////////////////////////////////////
//
// Get the full pathname to the user's data file
//
// Note, this is always relative to the users's windows
// directory and not the system's windows directory.
// See HHGetWindowsDirectory for details on this.
//
UINT HHGetUsersDataPathname( LPTSTR lpBuffer, UINT uSize )
{
  UINT uiReturn = 0;

  uiReturn = HHGetWindowsDirectory( lpBuffer, uSize, HH_USERS_WINDOWS_DIRECTORY );
  CatPath( lpBuffer, txtHHDat );

  return uiReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\wmp.h ===
// Copyright  1996-1997  Microsoft Corporation.  All Rights Reserved.

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _WMP_H_
#define _WMP_H_

// This head file contains private messages for talking between
// HHCTRL.OCX, HtmlHelp windows, HTML Help Workshop, Flash, and other
// components of the HTML Help retail and SDK set

const int MAX_PASS_STRING = (32 * 1024); // maximum string to send to parent

enum PRIVATE_MESSAGES  {

    // HTML Help Workshop messages

    WMP_STOP_RUN_DLG = (WM_USER + 0x100),
    WMP_UPDATE_VIEW_UI,         // wParam = id, Param = CCmdUI*
    WMP_IS_COMMAND_SUPPORTED,   // wParam = id
    WMP_MSG,                    // general message
    WMP_SETHLP_FILE,
    WMP_BUILD_COMPLETE,
    WMP_HWND_GRINDER,
    WMP_AUTO_MINIMIZE,
    WMP_AUTO_CMD_LINE,
    WMP_SET_TMPDIR,
    WMP_STOP_GRINDING,
    WMP_STOP_COMPILING,
    WMP_ERROR_COUNT,
    WMP_NO_ACTIVATE,
    WMP_KILL_TCARD,
    WMP_FLASH_COMMAND_LINE,
    WMP_INITIALIZE_HTML,
    WMP_LOG_MSG,    // wParam == PCSTR
    WMP_LOAD_LAST_PROJECT,
    WMP_CLEAR_LOG,
    WMP_STARTUP_HELP,   // display startup HTML file
    WMP_GRIND_MESSAGE,  // message box with grind window as the owner: wParam == psz, lParam == nType

    // HHA messages

    WMP_WINDOW_CAPTURE = (WM_USER + 0x1C0), // lParam == POINTS
    WMP_WINDOW_HILIGHT, // wParam == TRUE/FALSE to hilight, remove hilight, // lParam == POINTS
    WMP_KEYBOARD_HOOK,  // wParam == virtual key code, // lParam == see KeyboardProc value in API description of keyboard hooks

    // THIS CANNOT CHANGE! It is documented externally

    WMP_HH_MSG = (WM_USER + 0x1C3),         // Notifies window that a string is in shared memory

    // Flash messages

    WMP_SET_TEXT =          (WM_USER + 0x200),
    WMP_SET_INFO_FILE,
    WMP_ADD_PATTERN,
    WMP_CHANGE_SRC,
    WMP_BROWSE_OPEN,
    WMP_BACKCOLOR_CHANGED,
    WMP_PERFORM_CAPTURE,    // wParam == POINTS, lParam == capture type
    WMP_WHAT_ARE_YOU_DOING,
    WMP_KILL_CAPTURE,
    WMP_FOCUS_MAIN,
    WMP_AUTO_SIZE,
    WMP_MOUSE_HOOK,
    WMP_UPDATE_STATUS_BAR,
    WMP_COMMAND_LINE,       // (WM_USER + 0x20d)
    WMP_CANCEL,
    WMP_CHECK_BROWSE_DIR,   // wParam == pszFolder
    WMP_CONVERT_MFILES,     // file stored in g_pszMfile

    // HTML Help messages

    WMP_AUTHOR_MSG, // wParam = idResource, lParam = lcStrDup of string -- processing message will free the string
    WMP_USER_MSG,   // wParam = idResource, lParam = lcStrDup of string or NULL -- processing message will free the string
    WMP_PRINT_COMPLETE,     // wParam = TRUE/FALSE (for success or failure)
    WMP_GET_CUR_FILE,   // returns pointer to current compiled HTML file
    WMP_JUMP_TO_URL,    // wParam = LocalAlloc of URL string

    WMP_ANSI_API_CALL = (WM_USER + 0x280),       // lParam = pHhDataA
    WMP_UNICODE_API_CALL,    // lParam = pHhDataW
    WMP_HH_WIN_CLOSING,
    WMP_FORCE_HH_API_CLOSE, // forceably close all HH windows and HH_API window
    WMP_HH_COMMAND_LINE = (WM_USER + 0x284),    // TODO: Remove: Currently unused, but not removed because of possible side affects.
    WMP_HH_TAB_KEY,     // control has received TAB downkey
    WMP_HH_ANSI_THREAD_API,     // wParam = HH_ANSI_DATA*
    WMP_HH_UNI_THREAD_API,      // wParam = HH_UNICODE_DATA*
    WMP_HH_TRANS_ACCELERATOR,   // wParam = CHAR
};

typedef enum {
    HHA_DEBUG_ERROR,    // Displays string in wParam, asks permission to call DebugBreak();
    HHA_SEND_STRING_TO_PARENT,  // Sends string in wParam to hhw.exe
    HHA_SEND_RESID_TO_PARENT,   // sends resource string in hha.dll to hhw.exe
    HHA_FIND_PARENT,            // finds hhw.exe's window handle
    HHA_SEND_RESID_AND_STRING_TO_PARENT,
} HHA_MSG;

#endif      // _WMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\parser.cpp ===
//*********************************************************************************************************************************************
//
//      File: Parser.cpp
//  Author: Donald Drake
//  Purpose: Implements classes to support parsing tokens from a xml file

#include "header.h"
#include "stdio.h"
#include "string.h"
#include "TCHAR.h"
#include "windows.h"
#include "parser.h"

DWORD CParseXML::Start(const CHAR *szFile)
{
	m_fh = fopen(szFile,  "r");

	if (m_fh == NULL)
		return F_NOFILE;

	if (SetError(Read()) != F_OK)
			return GetError();

	return F_OK;
}

void CParseXML::End()
{
	if (m_fh != NULL)
	{
		fclose(m_fh);
		m_fh = NULL;
	}
}


DWORD CParseXML::Read()
{
	if (fgets(m_cCurBuffer, MAX_LINE_LEN, m_fh) == NULL)
	{
		if (feof(m_fh))
			return F_EOF;
		return F_READ;
	}
	m_pCurrentIndex = m_cCurBuffer;
	return F_OK;
}

CHAR * CParseXML::GetFirstWord(CHAR *sz)
{
	if (sz == NULL)
		return NULL;

	// ignore starting white space
	for (CHAR *pChar = sz; *pChar && *pChar== ' ';  pChar = CharNext(pChar));

	memset(m_cCurWord, 0, MAX_LINE_LEN);

	CHAR *pWord = m_cCurWord;
	for (;*pChar && *pChar != ' ' && *pChar != '=' && *pChar != '\n' && *pChar != '\t' ;pChar = CharNext(pChar), pWord = CharNext(pWord))
	{
		*pWord = *pChar;
		if (IsDBCSLeadByte(*pChar))
		{
			*(pWord+1) = *(pChar+1);
		}
	}
	*pWord = NULL;
	return m_cCurWord;
}

CHAR * CParseXML::GetValue(CHAR *sz)
{
	// get location of word value then find = sign
	CHAR *pChar;
	CHAR *p;

	p = sz;

	// BUGBUG temp hack to fix build, parser.cpp and parserhh.cpp will 
	// soon be merged
	pChar = NULL;
	while (*p)
	{
		if ((*p == 'v' || *p == 'V') &&
			(*(p+1) == 'a' || *(p+1) == 'A') &&
			(*(p+2) == 'l' || *(p+2) == 'L') &&
			(*(p+3) == 'u' || *(p+3) == 'U') &&
			(*(p+4) == 'e' || *(p+4) == 'E'))
		{
			pChar = p;
			break;
		}
		p = CharNext(p);
	}
	
	// did not find the value tag
	if (pChar == NULL)
		return NULL;

	for (; *pChar && *pChar != '='; pChar = CharNext(pChar));

	if (*pChar == '=')
	{
		memset(m_cCurWord, 0, MAX_LINE_LEN);
		CHAR *pWord = m_cCurWord;
		// ignore white space
		pChar = CharNext(pChar);
		for (; *pChar && *pChar == ' '; pChar = CharNext(pChar));
		for ( ; *pChar ; pChar = CharNext(pChar))
		{
			if (*pChar == '/' && *(pChar+1) == NULL)
				break;
			if (*pChar != 34)
			{
				*pWord = *pChar;
				if (IsDBCSLeadByte(*pChar))
				{
					*(pWord+1) = *(pChar+1);
				}
				pWord = CharNext(pWord);
			}
		}
		*pWord = NULL;
		return m_cCurWord;
	}
	return NULL; // did not find the = sign
}

CHAR *CParseXML::GetToken()
{
	// start looking for <
	while (TRUE)
	{
		if (*m_pCurrentIndex == NULL)
		{
			if (SetError(Read()) != F_OK)
				return NULL;
		}
	
		if (*m_pCurrentIndex != '<')
		{
			m_pCurrentIndex = CharNext(m_pCurrentIndex);
			continue;
		}

		// found a < skip it and start building the token
		memset(m_cCurToken, 0, MAX_LINE_LEN);
		CHAR *pWord  = m_cCurToken;
		while (TRUE)
		{
			m_pCurrentIndex = CharNext(m_pCurrentIndex);
			if (*m_pCurrentIndex == NULL)
				if (SetError(Read()) != F_OK)
					return NULL;

			if (*m_pCurrentIndex == '>')
			{
				m_pCurrentIndex = CharNext(m_pCurrentIndex);
				return m_cCurToken;
			}
			*pWord = *m_pCurrentIndex;
			if (IsDBCSLeadByte(*m_pCurrentIndex))
			{
				*(pWord+1) = *(m_pCurrentIndex+1);
			}
			pWord = CharNext(pWord);
		}
	}
}

// class to support a FIFO queue of strings

void CFIFOString::RemoveAll()
{
	FIFO *prev;
	while (m_fifoTail)
	{
		prev = m_fifoTail->prev;
		delete [] m_fifoTail->string;
		delete m_fifoTail;
		m_fifoTail = prev;
	}
}

CFIFOString::~CFIFOString()
{
	RemoveAll();
}

DWORD CFIFOString::AddTail(CHAR *sz)
{
FIFO *entry;
int len;

	entry = new FIFO;
	if (entry == NULL)
		return F_MEMORY;

	len = _tcslen(sz) + 1;

	entry->string = new CHAR[len];

	_tcscpy(entry->string, sz);

	entry->prev = NULL;

	if (m_fifoTail)
	{
		entry->prev  = m_fifoTail;
	}
	m_fifoTail = entry;
	return F_OK;
}

DWORD CFIFOString::GetTail(CHAR **sz)
{
int len;
FIFO *entry;

	if (m_fifoTail == NULL)
		return F_END;

	len = _tcslen(m_fifoTail->string) + 1;

	*sz= new CHAR[len];

	if (*sz == NULL)
		return F_MEMORY;

	_tcscpy(*sz, m_fifoTail->string);

	entry = m_fifoTail->prev;

	delete [] m_fifoTail->string;
	delete m_fifoTail;
	m_fifoTail = entry;
	return F_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\shared.h ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

// Functions in hhctrl.ocx that are called by hh.exe

#ifdef __cplusplus
extern "C" {
#endif	// __cplusplus

HMODULE 	LoadHHA(HWND hwnd, HINSTANCE hinst);
void		AuthorMsg(UINT idStringFormatResource, PCSTR pszSubString, HWND hwndParent, void* phhctrl);

#ifdef __cplusplus
}
#endif // __cplusplus

extern BOOL 	g_fTriedHHA;	// whether or not we tried to find HHA.dll
extern HMODULE	g_hmodHHA;		// HHA.dll module handle

__inline BOOL IsHelpAuthor(void) { return (BOOL)(g_hmodHHA != NULL); }
__inline int RECT_WIDTH(RECT rc) { return rc.right - rc.left; };
__inline int RECT_HEIGHT(RECT rc) { return rc.bottom - rc.top; };
__inline int RECT_WIDTH(const RECT* prc) { return prc->right - prc->left; };
__inline int RECT_HEIGHT(const RECT* prc) { return prc->bottom - prc->top; };
__inline BOOL IsValidWindow(HWND hwnd) { return (BOOL) (hwnd && IsWindow(hwnd)); };
__inline BOOL IsSpace(char ch) { return (ch == ' ' || ch == '\t'); }
__inline BOOL IsDigit(char ch) { return (ch >= '0' && ch <= '9'); }
__inline BOOL IsEmptyString(PCSTR psz) { return ((psz == NULL) || (!psz[0])); }
__inline BOOL IsNonEmpty(PCSTR psz) { return (IsEmptyString(psz) == FALSE); }
__inline BOOL IsNonEmptyString(PCSTR psz) { return (IsEmptyString(psz) == FALSE); }
__inline BOOL isSameString(PCSTR psz1, PCSTR psz2) { return (psz1 && psz2 ? IsSamePrefix(psz1, psz2, -1) : FALSE); }
__inline BOOL isSameString(PCWSTR pwsz1, PCWSTR pwsz2) { return (pwsz1 && pwsz2 ? IsSamePrefix(pwsz1, pwsz2, -1) : FALSE); }
__inline UCHAR ToLower(char ch) { return (UCHAR) CharLower((LPTSTR) (DWORD_PTR) (UCHAR) ch); };
__inline UCHAR ToUpper(char ch) { return (UCHAR) CharUpper((LPTSTR) (DWORD_PTR) (UCHAR) ch); };

__inline BOOL IsEmptyStringW(LPCWSTR psz) { return ((psz == NULL) || (!psz[0])); } //REVIEW: Is this kosher?
__inline BOOL IsNonEmptyW(LPCWSTR psz) { return (IsEmptyStringW(psz) == FALSE); }
__inline BOOL IsNonEmptyStringW(LPCWSTR psz) { return (IsEmptyStringW(psz) == FALSE); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hhsetup\util.h ===
// zero fill functions
#define ZERO_INIT_CLASS(base_class) \
    ClearMemory((PBYTE) ((base_class*) this) + sizeof(base_class*), \
        sizeof(*this) - sizeof(base_class*));
#define ZERO_STRUCTURE(foo) ClearMemory(&foo, sizeof(foo))
#define ClearMemory(p, cb) memset(p, 0, cb)

// message box functions
int MsgBox(int idString, UINT nType = MB_OK );
int MsgBox(PCSTR pszMsg, UINT nType = MB_OK );

PCSTR FindFilePortion( PCSTR pszFile );
int JulianDate(int nDay, int nMonth, int nYear);
HRESULT FileTimeToDateTimeString( FILETIME FileTime, LPTSTR pszDateTime );
int FileTimeToJulianDate( FILETIME FileTime );

// system directory functions
typedef UINT (WINAPI *PFN_GETWINDOWSDIRECTORY)( LPTSTR lpBuffer, UINT uSize );
typedef enum { HH_SYSTEM_WINDOWS_DIRECTORY, HH_USERS_WINDOWS_DIRECTORY } SYSDIRTYPES;

UINT HHGetWindowsDirectory( LPSTR lpBuffer, UINT uSize, UINT uiType = HH_SYSTEM_WINDOWS_DIRECTORY );
UINT HHGetHelpDirectory( LPSTR lpBuffer, UINT uSize );
UINT HHGetGlobalCollectionPathname( LPTSTR lpBuffer, UINT uSize , BOOL *pbNewPath);
HRESULT HHGetHelpDataPath( LPSTR pszPath );
BOOL IsDirectory( LPCSTR lpszPathname );
DWORD       CreatePath(PSTR pszPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\hlink\hlink.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    hlink.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 1-Mar-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(HlinkClone)
STUBFUNC(HlinkCreateBrowseContext)
STUBFUNC(HlinkCreateExtensionServices)
STUBFUNC(HlinkCreateFromData)
STUBFUNC(HlinkCreateFromMoniker)
STUBFUNC(HlinkCreateFromString)
STUBFUNC(HlinkCreateShortcut)
STUBFUNC(HlinkCreateShortcutFromMoniker)
STUBFUNC(HlinkCreateShortcutFromString)
STUBFUNC(HlinkGetSpecialReference)
STUBFUNC(HlinkGetValueFromParams)
STUBFUNC(HlinkIsShortcut)
STUBFUNC(HlinkNavigate)
STUBFUNC(HlinkNavigateToStringReference)
STUBFUNC(HlinkOnNavigate)
STUBFUNC(HlinkOnRenameDocument)
STUBFUNC(HlinkParseDisplayName)
STUBFUNC(HlinkPreprocessMoniker)
STUBFUNC(HlinkQueryCreateFromData)
STUBFUNC(HlinkResolveMonikerForData)
STUBFUNC(HlinkResolveShortcut)
STUBFUNC(HlinkResolveShortcutToMoniker)
STUBFUNC(HlinkResolveShortcutToString)
STUBFUNC(HlinkResolveStringForData)
STUBFUNC(HlinkSetSpecialReference)
STUBFUNC(HlinkTranslateURL)
STUBFUNC(HlinkUpdateStackItem)
STUBFUNC(OleSaveToStreamEx)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\fid.c ===
/*****************************************************************************
 *                                                                           *
 * FID.C                                                                     *
 *                                                                           *
 * Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 * All Rights reserved.                                                      *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 * Module Intent                                                             *
 *                                                                           *
 * Low level file access layer, Windows version.                             *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 * Current Owner: UNDONE                                                     *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 * Released by Development:	                                               *
 *                                                                           *
 *****************************************************************************/

/*****************************************************************************
 *
 * Revision History:
 *       -- Mar 92      adapted from WinHelp FID.C, DAVIDJES
 *			9/26/95     davej	Autodoc'd
 *          3/05/97     erinfox Change errors to HRESULTS
 *****************************************************************************/

/*****************************************************************************
 *
 * Issues:
 * How to communicate super large (> DWORD) seeks over MOS.  See FoSeekFid
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;	/* For error report */

#include <mvopsys.h>
#include <iterror.h>

#ifdef _32BIT
#define	FP_OFF
#endif

#include <direct.h>
#include <orkin.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>

#ifdef MOSMAP
#include <mapfile.h>
#endif

#ifndef _MAC
#include <dos.h>	/* for FP_OFF macros and file attribute constants */
#endif

#include <io.h>	 /* for tell() and eof() */
#include <errno.h>		          /* this is for chsize() */


/***************************************************************************
 *
 *		                           Defines
 *
 ***************************************************************************/

#define UCBMAXRW		((WORD)0xFFFE)
#define LCBSIZESEG	((ULONG)0x10000)

/***************************************************************************
 *
 *		                           Macros
 *
 ***************************************************************************/

#define _WOpenMode(w) (_rgwOpenMode[ (w) & wRWMask ] | \
			_rgwShare[ ((w) & wShareMask) >> wShareShift ] )


/***************************************************************************
 *
 *		                  Private Functions
 *
 ***************************************************************************/

HRESULT	PASCAL FAR RcMapDOSErrorW(WORD);

/***************************************************************************
 *
 *		                  Public Functions
 *
 ***************************************************************************/

/***************************************************************************
 * @doc	INTERNAL
 *
 *	@func BOOL PASCAL FAR | FidFlush |
 *
 *	@parm	FID |fid|
 *
 *	@rdesc TRUE if file flushed OK, FALSE if could not flush.
 *
 ***************************************************************************/

// Fill in non-win-32

PUBLIC BOOL PASCAL FAR FidFlush(FID fid)
{
 	BOOL bSuccess=TRUE;
#ifdef _WIN32
	bSuccess=FlushFileBuffers(fid);
#else
    Need code here
#endif
#ifdef _DEBUGMVFS
	DPF2("FidFlush: fid %ld, returned %d\n", (LONG)fid, bSuccess);
#endif
	return bSuccess;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FID PASCAL FAR | FidCreateFm |
 *		Create a file
 *
 *  @parm	FM | fm |
 *		the file moniker
 *
 *  @parm	WORD | wOpenMode |
 *		read/write/share mode
 *
 *  @parm	WORD | wPerm |
 *		file permissions
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	fidNil on failure, valid fid otherwise
 *
 ***************************************************************************/

PUBLIC FID FAR PASCAL FidCreateFm(FM fm, WORD wOpenMode,
    WORD wPerm, PHRESULT phr)
{
#ifdef MOSMAP // {
	// Disable function
	SetErrCode(phr, ERR_NOTSUPPORTED);
	return fidNil;
#else // } {
	FID	fid;
	QAFM qafm;

	if (fm == fmNil)
	{
		SetErrCode(phr, E_INVALIDARG);
		return fidNil;
	}

	qafm = (QAFM)fm;
	//qafm = _GLOBALLOCK((HANDLE)fm);

#ifdef _WIN32
	fid = CreateFile((LPSTR)qafm->rgch,
		((wOpenMode&wRead)?GENERIC_READ:0)|((wOpenMode&wWrite)?GENERIC_WRITE:0),
		((wOpenMode&wShareRead)?FILE_SHARE_READ:0)|((wOpenMode&wShareWrite)?FILE_SHARE_WRITE:0),
		NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	// Note:  Some really cool optimizations can be made by specifying how the file
	// is intended to be used!
#else
	fid =_lcreat((LPSTR)qafm->rgch, _rgwPerm[ (wPerm) & wRWMask ]);
#endif
	if (fid == fidNil)
		SetErrCode(phr, E_FILECREATE);
	//_GLOBALUNLOCK((HANDLE)fm);
#ifdef _DEBUGMVFS
	DPF2("FidCreateFm: fid %ld for '%s'.\n", (LONG)fid, (LPSTR)qafm->rgch);
#endif
	return fid;
#endif //}
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FID PASCAL FAR | FidOpenFm |
 *		Open a file in binary mode.
 *
 *  @parm	FM | fm |
 *		the file moniker
 *
 *  @parm	WORD | wOpenMode |
 *		read/write/share modes.   Undefined if wRead and wWrite both unset.
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	fidNil on failure, else a valid FID.
 *
 ***************************************************************************/
PUBLIC FID FAR PASCAL FidOpenFm(FM fm, WORD wOpenMode, PHRESULT phr)
{
	FID fid;
	QAFM qafm;

	if (fm == fmNil)
	{
		SetErrCode(phr, E_INVALIDARG);
		return fidNil;
	}

	qafm = (QAFM)fm;
	//qafm = _GLOBALLOCK((HANDLE)fm);

#ifdef MOSMAP // {
	// Open File Mapping, or get ref to existing one
	if ((fid = (HFILE)MosOpenMapFile((LPSTR)qafm->rgch)) == fidNil)
		SetErrCode(phr, ERR_FAILED);
#else // } {

#ifdef _WIN32
	if ((fid = CreateFile((LPSTR)qafm->rgch,
		((wOpenMode&wRead)?GENERIC_READ:0)|((wOpenMode&wWrite)?GENERIC_WRITE:0),
		((wOpenMode&wShareRead)?FILE_SHARE_READ:0)|((wOpenMode&wShareWrite)?FILE_SHARE_WRITE:0),
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == fidNil)
#else
	if ((fid = _lopen((LPSTR)qafm->rgch, _WOpenMode(wOpenMode))) == fidNil)
#endif // _WIN32
		SetErrCode(phr, RcGetDOSError());
#endif //}

	//_GLOBALUNLOCK((HANDLE)fm);
#ifdef _DEBUGMVFS
	DPF2("FidOpenFm: fid %ld for '%s'.\n", (LONG)fid, (LPSTR)qafm->rgch);
#endif
	return fid;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | LcbReadFid |
 *		Read data from a file.
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *  @parm	QV | qv |
 *		pointer to user's buffer assumed huge enough for data
 *
 *  @parm	LONG | lcb |
 *		count of bytes to read (must be less than 2147483648)
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	count of bytes actually read or -1 on error
 *
 ***************************************************************************/
PUBLIC LONG FAR PASCAL LcbReadFid(FID fid, QV qv, LONG lcb, PHRESULT phr)
{
	LONG    lcbTotalRead = (LONG)0;
#ifdef MOSMAP // {
	// Read map file
	lcbTotalRead = MosReadMapFile((LPVOID)fid, qv, lcb) ;
	if (lcbTotalRead == -1)
#else // } {
#ifdef _WIN32
   
   if (!ReadFile(fid, qv, lcb, &lcbTotalRead, NULL))
   	SetErrCode(phr, RcGetDOSError());
   	
#else
	BYTE	HUGE *hpb = (BYTE HUGE *)qv;
	WORD 	ucb, ucbRead;

	do {
		ucb = (WORD)min(lcb, UCBMAXRW);
		ucb = (WORD)min((ULONG) ucb, LCBSIZESEG - (ULONG) FP_OFF(hpb));
		ucbRead = _lread(fid, hpb, ucb);

		if (ucbRead == (WORD)-1)
		{
			if (!lcbTotalRead)
			{
				lcbTotalRead = (LONG)-1;
			}
			break;
		}
		else
		{
			lcbTotalRead += ucbRead;
			lcb -= ucbRead;
			hpb += ucbRead;
		}
	} while (lcb > 0 && ucb == ucbRead);

	if (ucbRead == (WORD)-1)
		SetErrCode(phr, ERR_CANTREAD);

#endif
#endif //}
#ifdef _DEBUGMVFS
	DPF2("LcbReadFid: fid %ld returned %ld bytes.\n", (LONG)fid, lcbTotalRead);
#endif
	return lcbTotalRead;
}


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | LcbWriteid |
 *		Write data to a file.
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *  @parm	QV | qv |
 *		pointer to user's buffer assumed huge enough for data
 *
 *  @parm	LONG | lcb |
 *		count of bytes to read (must be less than 2147483648)
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	count of bytes actually read or -1 on error
 *
 ***************************************************************************/
PUBLIC LONG FAR PASCAL LcbWriteFid(FID fid, QV qv, LONG	lcb, PHRESULT phr)
{
	LONG    lcbTotalWrote = (LONG)0;

#ifdef MOSMAP // {
	// Disable function
	SetErrCode(phr, ERR_NOTSUPPORTED);
	return 0;
#else // } {
#ifdef _WIN32
	if (!WriteFile(fid, qv, lcb, &lcbTotalWrote, NULL))
	   	SetErrCode(phr, RcGetDOSError());

#else
	BYTE	HUGE *hpb = (BYTE HUGE *)qv;
	WORD	ucb, ucbWrote;
	
	if (lcb == 0L)
	{
		phr->err = S_OK;
		return 0L;
	}

	do
		{
		ucb = (WORD)min(lcb, (ULONG) UCBMAXRW);
		ucb = (WORD)min((ULONG) ucb, LCBSIZESEG - (WORD) FP_OFF(hpb));
		ucbWrote = _lwrite(fid, hpb, ucb);

		if (ucbWrote == (WORD)-1)
		{
			if (!lcbTotalWrote)
				lcbTotalWrote = -1L;
			break;
		}
		else
		{
			lcbTotalWrote += ucbWrote;
			lcb -= ucbWrote;
			hpb += ucbWrote;
		}
	} while (lcb > 0 && ucb == ucbWrote);

	if (ucb != ucbWrote)
	{
    	if (ucbWrote == (WORD)-1L) 
    		SetErrCode (phr, RcGetDOSError());
    	else
    		SetErrCode (phr, E_DISKFULL);
	}
#endif
#endif // }
#ifdef _DEBUGMVFS
	DPF2("LcbWriteFid: fid %ld wrote %ld bytes.\n", (LONG)fid, lcbTotalWrote);
#endif
	return lcbTotalWrote;

}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | RcCloseFid |
 *		Close a file.
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *	@rdesc	rcSuccess or something else
 *
 ***************************************************************************/
PUBLIC HRESULT FAR PASCAL RcCloseFid(FID fid)
{
#ifdef MOSMAP // {
	if (MosCloseMapFile((LPVOID)fid) == HFILE_ERROR)
	{
#else // } {
#ifdef _WIN32
	if (!CloseHandle(fid))		
	{
#else
	if (_lclose( fid) == (HFILE)-1 )
	{
#endif
#endif //}
#ifdef _DEBUGMVFS
		DPF2("RcCloseFid: fid %ld was NOT closed(%d).\n", (LONG)fid, 0);
#endif
		return E_FILECLOSE;
	}
#ifdef _DEBUGMVFS
	DPF2("RcCloseFid: fid %ld was closed(%d).\n", (LONG)fid, 1);
#endif
	return S_OK;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | LTellFid |
 *		Return current file position in an open file.
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	offset from beginning of file in bytes; -1L on error.
 *
 ***************************************************************************/
LONG FAR PASCAL LTellFid(FID fid, PHRESULT phr)
{
	LONG l;

#ifdef MOSMAP // {
	l = MosSeekMapFile((LPVOID)fid, 0L, 1) ;
#else // } {
#ifdef _WIN32
    DWORD dwHigh = 0L;
	l = SetFilePointer(fid, 0L, &dwHigh, FILE_CURRENT);
	// OK, just plain no support for +4gig files here...
	if ((l==(LONG)-1L) || (dwHigh))
		SetErrCode(phr, E_FILESEEK);
#else
	l = _llseek(fid, 0L, 1);
#endif
#endif //}
	if ( l == (LONG)-1L )
		SetErrCode(phr, E_FILESEEK);
#ifdef _DEBUGMVFS
	DPF2("LTellFid: fid %ld is at %ld\n", (LONG)fid, l);
#endif
	return l;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	LONG PASCAL FAR | LSeekFid |
 *		Move file pointer to a specified location.  It is an error
 *		to seek before beginning of file, but not to seek past end
 *		of file.
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *  @parm	LONG | lPos |
 *		offset from origin
 *
 *  @parm	WORD | wOrg |
 *		one of: wSeekSet: beginning of file, wSeekCur: current file pos,
 *		wSeekEnd: end of file
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	offset in bytes from beginning of file or -1L on error
 *
 ***************************************************************************/

PUBLIC LONG FAR PASCAL LSeekFid(FID fid, LONG lPos, WORD wOrg, PHRESULT phr)
{
	LONG l;
#ifdef MOSMAP // {
	l = MosSeekMapFile((LPVOID)fid, lPos, wOrg) ;
#else // } {
#ifdef _WIN32
    DWORD dwHigh = 0L;
	l = SetFilePointer(fid, lPos, &dwHigh, wOrg);
	// OK, just plain no support for +4gig files here...
	if ((l!=lPos) || (dwHigh))
		SetErrCode(phr, E_FILESEEK);
#else
	l = _llseek(fid, lPos, wOrg);
	if (l == (LONG)-1L)
		SetErrCode(phr, E_FILESEEK);
#endif
#endif //}
#ifdef _DEBUGMVFS
	DPF2("LSeekFid: fid %ld is at %ld\n", (LONG)fid, l);
#endif
	return l;
}


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET PASCAL FAR | FoSeekFid |
 *		Move file pointer to a specified location.  It is an error
 *		to seek before beginning of file, but not to seek past end
 *		of file.  This function is meant to handle offsets larger than 4
 *		gigabytes.
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *  @parm	FILEOFFSET | foPos |
 *		offset from origin
 *
 *  @parm	WORD | wOrg |
 *		one of: wSeekSet: beginning of file, wSeekCur: current file pos,
 *		wSeekEnd: end of file
 *
 *  @parm	PHRESULT | phr |
 *		Error return
 *
 *	@rdesc	offset in bytes from beginning of file or -1L on error
 *
 ***************************************************************************/
PUBLIC FILEOFFSET FAR PASCAL FoSeekFid(FID fid, FILEOFFSET foPos, WORD wOrg, PHRESULT phr)
{
	DWORD dw;
	DWORD dwHigh=0L;
	FILEOFFSET foSeeked;

#ifdef MOSMAP // {
	SetErrCode(phr,ERR_NOTSUPPORTED);
	return -1L;
	//l = MosSeekMapFile((LPVOID)fid, lPos, wOrg) ;
#else // } {
#ifdef _WIN32
	dwHigh=(LONG)foPos.dwHigh;
	dw = SetFilePointer((HANDLE)fid, foPos.dwOffset, &dwHigh, wOrg);	
#else // not really supported for 16-bit
	dw = (DWORD)_llseek(fid, foPos.dwOffset, wOrg);
#endif
#endif //}
	foSeeked.dwOffset=dw;
	foSeeked.dwHigh=dwHigh;
	if (dw == (LONG)-1L)
	{
		if (GetLastError()!=NO_ERROR)
			SetErrCode(phr, E_FILESEEK);
		else
			*phr = S_OK;
	}
#ifdef _DEBUGMVFS
	DPF2("FoSeekFid: fid %ld is at %ld\n", (LONG)fid, foPos.dwOffset);
#endif
	return foSeeked;
}


#if 0
#if !defined ( _WIN32 )
/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BOOL PASCAL FAR | FEofFid |
 *		Tells ye if ye're at the end of the file.
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *	@rdesc	TRUE if at EOF, FALSE if not or error has occurred (?)
 *
 ***************************************************************************/
PUBLIC BOOL PASCAL FAR FEofFid(FID fid)
{
	WORD wT;

	if (( wT = eof( fid) ) == (WORD)-1 )
		SetErrCode(RcGetDOSError());
	else
		SetErrCode(rcSuccess);

	return (BOOL)(wT == 1);
}
#endif // !defined ( _WIN32 )
#endif

PUBLIC HRESULT PASCAL FAR RcGetDOSError (void)
{

#ifdef _WIN32
	//  NT does not support errno in the multi threaded environment.

	switch( GetLastError() )
	{
    	case  NO_ERROR:
    		return  S_OK;

    	case  ERROR_ACCESS_DENIED:
    		return  E_NOPERMISSION;
        
    	case  ERROR_INVALID_HANDLE:
    		return  E_HANDLE;

    	case  ERROR_HANDLE_DISK_FULL:
    	case  ERROR_DISK_FULL:
    		return  E_DISKFULL;

    	default:
    		return  E_INVALIDARG;
	}
#else
	switch (errno) {
		case EACCES:
			return E_NOPERMISSION;
			break;

		case EBADF:
			return E_INVALIDARG;
			break;

		case ENOSPC:
			return E_DISKFULL;
			break;

		default:
			return E_INVALIDARG;
			break;
	}
#endif // _WIN32
}


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | RcChSizeFid |
 *		Change the size of a file
 *
 *  @parm	FID | fid |
 *		valid FID of an open file
 *
 *  @parm	LONG | lcb |
 *		New size of file
 *
 *	@rdesc	Returns S_OK if all OK, else the error.
 *
 ***************************************************************************/
PUBLIC HRESULT PASCAL FAR RcChSizeFid(FID fid, LONG lcb)
{
#if !defined ( _WIN32 )
	if (chsize( fid, lcb) == -1 )
		return RcGetDOSError();
	else
#endif // !defined ( _WIN32 )
	return S_OK;
}


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | RcUnlinkFm |
 *		Delete a DOS file given the filename
 *
 *  @parm	FM | fm |
 *		Name of file to remove.  (An FM is the same as an LPSTR).
 *
 *	@rdesc	Returns S_OK if all OK, else the error.
 *
 ***************************************************************************/
PUBLIC HRESULT PASCAL FAR EXPORT_API RcUnlinkFm(FM fm)
{
#ifdef MOSMAP // {
	// Disable function
	return ERR_NOTSUPPORTED;
#else // } {
	QAFM qafm = (QAFM)fm;
	//QAFM qafm = _GLOBALLOCK((HANDLE)fm);
	OFSTRUCT ofStruct;
	int fRet = S_OK;

	if (OpenFile((LPSTR)qafm->rgch, &ofStruct, OF_DELETE) == HFILE_ERROR)
		 fRet = E_FILEDELETE;
	//_GLOBALUNLOCK((HANDLE)fm);
	return fRet;
#endif // }
}


#ifdef _IT_FULL_CRT  // {
#ifndef _MAC // {
/* This function was previously present in dlgopen.c. It has been brought */
/* here as it is making INT21 call. */
/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BOOL PASCAL FAR | FDriveOk |
 *		Cheks if the drive specified with thwe file name is OK.
 *
 *  @parm	LPSTR | szFile |
 *		Name of file
 *
 *	@rdesc	TRUE if drive is OK.
 *
 ***************************************************************************/
PUBLIC BOOL PASCAL FAR EXPORT_API FDriveOk(LPSTR szFile)
/* -- Check if drive is valid */
	{
	 // the static variables here are static only because we are in a DLL
	 // and need to pass a near pointer to them to a C Run-Time routine.
	 // These should be Locally-Alloc'd so they don't waste space in
	 // our data segment.

	static int	 wDiskCur;    
	int	 wDisk;

	wDiskCur = _getdrive();

	/* change to new disk if specified */
	if ((wDisk = (int)((*szFile & 0xdf) - ('A' - 1))) != wDiskCur) {
		if (_chdrive (wDisk) == (int)-1)
			return FALSE;
	}
	return TRUE;
}
#endif // } _MAC
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\fm.c ===
/*****************************************************************************
 *                                                                            *
 *  FM.c                                                                      *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1990 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Routines for manipulating FMs (File Monikers, equivalent to file names).  *
 *  WINDOWS LAYER
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                     *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Revision History:
 *    -- Mar 92  adapted from WinHelps FM.C
 * 26-Jun-1992 RussPJ    #293 - Now using OpenFile(OF_EXIST) instead of
 *                       access().
 * 29-Jun-1992 RussPJ    #723 - Using OF_SHARE_DENY_NONE for OpenFile() call.
 * 18/10/94 a-kevct      Fixed FmNewTemp to use "higher temperature" filenames
 *                       so that problems with calling it twice in rapid succession
 *                       are avoided.
 * 7/28/95				 FM changed to just an LPSTR !!! - davej
 * 3/05/97     erinfox   Change errors to HRESULTS
 *
 *****************************************************************************/

#include <mvopsys.h>
#include <stdlib.h>     /* for _MAX_ constants & min and max macros*/
#include <dos.h>        /* for FP_OFF macros and file attribute constants */
#include <io.h>         /* for tell() and eof() */
#include <direct.h>     /* for getcwd */
#include <string.h>
#include <misc.h>
#include <iterror.h>
#include <wrapstor.h>
#include <orkin.h>

#ifndef _NT
#include <errno.h>
#endif

#include <_mvutil.h>

static char s_aszModule[] = __FILE__;   /* For error report */

/*****************************************************************************
 *                                                                            *
 *                               Defines                                      *
 *                                                                            *
 *****************************************************************************/
#define cbPathName    _MAX_PATH
#define cbMessage     50

/*****************************************************************************
 *                                                                            *
 *                               Variables                                    *
 *                                                                            *
 *****************************************************************************/


void InitRandomPrefix(char *sz, int cb);

PRIVATE BOOL PASCAL NEAR fIsTrailByte(SZ psz,SZ pch);

// InitRandomPrefix
//
// Given a buffer at least cb + 1 chars long,
// fills sz[0] through sz[ch-1] with random alphabetic chars
// and null terminates at sz[cb].
//
// 
#ifdef _IT_FULL_CRT
void InitRandomPrefix(char *sz, int cb)
{
  while (--cb >= 0)
    *sz++ = 'A' + rand() % 26;
  *sz = '\0';  
}
#endif

/***************************************************************************
 *
 -  Name: SnoopPath()
 -
 *  Purpose:
 *    Looks through a string for the various components of a file name and
 *    returns the offsets into the string where each part starts.
 *
 *  Arguments:
 *    sz      - string to snoop
 *    *iDrive - offset for the drive specification if present
 *    *iDir   - offset for the directory path if present
 *    *iBase  - offset to the filename if present
 *    *iExt   - offset to the extension (including dot) if present
 *
 *  Returns:
 *    sets the index parameters for each respective part.  the index is set
 *    to point to the end of the string if the part is not present (thus
 *    making it point to a null string).
 *
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
void    FAR PASCAL SnoopPath (LPSTR  sz, int far * iDrive, int far *iDir, 
     int far *iBase, int far *iExt)
{

    short i = 0;
    short cb = (short) STRLEN(sz);
    BOOL  fDir = FALSE;

    *iDrive = *iExt = cb;
    *iDir = *iBase = 0;

    while (*(sz + i))
    {
        switch (*(sz + i))
        {
            case ':':
                *iDrive = 0;
                *iDir = i + 1;
                *iBase = i + 1;
                break;

            case '/':
            case '\\':
                 // make sure we are not looking at a trail byte
                 if(fIsTrailByte(sz,sz+i))
                    break;

                fDir = TRUE;
                *iBase = i + 1;
                *iExt = cb;
                break;

            case '.':
                *iExt = i;
                break;

            default:
                break;

        }
        i++;
    }

    if (!fDir)
        *iDir = i;
    else if (*iBase == '.')
        *iExt = cb;
}

/***************************************************************************\
*
- Function:     fIsTrailByte(psz, pch)
-
* Purpose:      Determine if pch is the trail byte of a DBC.
*
* ASSUMES
*
*   args IN:    psz      - the beginning of the string
*               pch      - the character to test
*
* Notes:        This function is necessary because the Shift-JIS trail byte
*               ranges include the value 0x5C (backslash) and we need to 
*               know the difference between a real backslash and a DBC that
*               has this trail byte value.
*
\***************************************************************************/

PRIVATE BOOL PASCAL NEAR fIsTrailByte(SZ psz,SZ pch)
{
#if JRUSH
    return (IsDBCSLeadByte (*(pch - 1)));
#else
    SZ pchTemp = psz;
   
    if(pch==psz || pch<psz)
        return FALSE;

    while(1)
    {
        pchTemp = CharNext(pchTemp);

        if(pchTemp==pch)
            return FALSE; // it's a lead byte
        if(pchTemp>pch) 
            return TRUE;  // we stepped past it - must have been a trail byte
    }
#endif
}

/***************************************************************************
 *
 -  Name:       SzGetDir
 -
 *  Purpose:    returns the rooted path of a DIR
 *
 *  Arguments:  dir - DIR (must be one field only, and must be an actual dir -
 *                      not dirPath)
 *              sz - buffer for storage (should be at least cchMaxPath)
 *
 *  Returns:    sz - fine
 *              NULL - OS Error (check rcIOError)
 *
 *  Globals Used: rcIOError
 *
 *  +++
 *
 *
 ***************************************************************************/

// Hey! what about dirTemp?  This wasn't handled before so I'm not going
// to add it.  But someday the case should be handled.

PRIVATE SZ PASCAL NEAR SzGetDir(DIR dir, SZ sz, PHRESULT phr)
{
    int i=0;
    QCH qch;
    char    LocalBuffer1[_MAX_PATH];

    if (sz == NULL)
    {
        SetErrCode (phr, E_INVALIDARG);
        return(NULL);
    };

    switch (dir)
    {
        case dirCurrent:
            if (GETCWD(LocalBuffer1, cchMaxPath) == NULL)
            {
                SetErrCode (phr, RcGetDOSError());
                sz = NULL;
            }
            else
            {
                STRCPY (sz, LocalBuffer1);
            }
            break;

        case dirHelp:
#ifdef _WIN64
            GetModuleFileName((HINSTANCE)GetWindowLongPtr(GetActiveWindow(),
                GWLP_HINSTANCE),
#elif _32BIT
            GetModuleFileName((HINSTANCE)GetWindowLong(GetActiveWindow(),
                GWL_HINSTANCE),
#else
            GetModuleFileName((HINSTANCE)GetWindowWord(GetActiveWindow(),
                GWW_HINSTANCE),
#endif
                sz, cchMaxPath);
            qch = sz + STRLEN(sz);
            while ((*qch != '\\' && !fIsTrailByte(sz,qch)) && *qch != '/')
                --qch;
            *qch = '\0';
            break; /* dirHelp */

        case dirSystem:
            i = GetWindowsDirectory((LPSTR)sz, cchMaxPath);
            if (i > cchMaxPath || i == 0)
            {
                SetErrCode (phr, E_FAIL);
                sz = NULL;
            }
            break; /* dirSystem */

        default:
            SetErrCode (phr, E_INVALIDARG);
            sz = NULL;
            break;
    }

    if (sz != NULL)
    {
        qch = sz+STRLEN(sz);

        /*------------------------------------------------------------*
        | Make sure that the string ends with a slash.
         *------------------------------------------------------------*/
        if ((*(qch-1) != '\\' && *(qch-1) != '/') || fIsTrailByte(sz,qch-1))
        {
            *qch++='\\';
            *qch='\0';
        }
        assert(qch < sz+_MAX_PATH && *qch=='\0');
    }

    return sz;
}


/***************************************************************************
 *
 -  Name:       FmNew
 -
 *  Purpose:    Allocate and initialize a new FM
 *
 *  Arguments:  sz - filename string
 *
 *  Returns:    FM (handle to fully canonicalized filename)
 *
 *  Globals Used: rcIOError
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/


FM EXPORT_API PASCAL FAR FmNew(LPSTR sz, PHRESULT phr)
{
    QAFM  qafm;
    FM    fm = fmNil;
    char    LocalBuffer1[_MAX_PATH];
    char    LocalBuffer2[_MAX_PATH];
#ifndef _IT_FULL_CRT
    LPSTR lpAddr;
#endif

    STRCPY(LocalBuffer2, sz);         
    
#ifdef _IT_FULL_CRT
    if (_fullpath(LocalBuffer1, LocalBuffer2, _MAX_PATH) == NULL)
#else
    if (0 == GetFullPathName(LocalBuffer2, _MAX_PATH, LocalBuffer1, &lpAddr))
#endif
    {
        SetErrCode (phr, E_FAIL);
        return(NULL);
        
    }
    else
    {
		fm = (FM) NewMemory( (WORD)(lstrlen(LocalBuffer1)+1) );
		//fm = (FM) _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE|GMEM_MOVEABLE,
        //    (LONG)lstrlen(LocalBuffer1)+1);
        if (fm == fmNil)
        {
            SetErrCode (phr, E_OUTOFMEMORY);
            return fm;
        }
		qafm = (QAFM)fm;
        //qafm = (QAFM) _GLOBALLOCK(fm);
        STRCPY(qafm->rgch, LocalBuffer1);      
        // Convert to upper case to make it less likely that two
        // FMs will contain different strings yet refer to the
        // same file.        
        AnsiUpper(qafm->rgch);
        //_GLOBALUNLOCK((HANDLE)fm);
    }

    return fm;
}


/***************************************************************************
 *
 -  Name:       FmNewSzDir
 -
 *  Purpose:    Create an FM describing the file "sz" in the directory "dir"
 *              If sz is a simple filename the FM locates the file in the
 *              directory specified.  If there is a drive or a rooted path
 *              in the filename the directory parameter is ignored.
 *              Relative paths are allowed and will reference off the dir
 *              parameter or the default (current) directory as appropriate.
 *
 *              This does not create a file or expect one to exist at the
 *              final destination (that's what FmNewExistSzDir is for), all
 *              wind up with is a cookie to a fully qualified path name.
 *
 *  Arguments:  sz - filename ("File.ext"),
 *                or partial pathname ("Dir\File.ext"),
 *                or current directory ("c:File.ext"),
 *                or full pathname ("C:\Dir\Dir\File.ext")
 *              dir - dirCurrent et al.
 *
 *  Returns:    the new FM, or fmNil if error
 *              sz is unchanged
 *
 *  Globals Used:
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
PUBLIC FM PASCAL FAR FmNewSzDir(LPSTR sz, DIR dir, PHRESULT phr)
{
    char  nsz[_MAX_PATH];
    int iDrive, iDir, iBase, iExt; 
    int cb;

    if (sz == NULL || *sz == '\0')
    {
        SetErrCode (phr, E_INVALIDARG);
        return NULL;
    }

    cb = (int) STRLEN(sz);
    SnoopPath(sz, &iDrive, &iDir, &iBase, &iExt);

    if (*(sz + iBase) == '\0')    /* no name */
    {
        *nsz = '\0';        /* force error */
    }
    else if (*(sz + iDrive) || (*(sz + iDir) == '\\' &&
        !fIsTrailByte(sz,sz+iDir)) || *(sz + iDir) == '/')
    {
        /* there's a drive or root slash so we have an implicit directory spec */
        /* and we can ignore the directory parameter and use what was passed. */
        STRCPY(nsz, sz);
    }

    else
    {

        /* dir & (dir-1) checks to make sure there is only one bit set which is */
        /* followed by a check to make sure that it is also a permitted bit */
        assert(((dir & (dir-1)) == (WORD)0)
             && (dir & (dirCurrent|dirTemp|dirHelp|dirSystem|dirPath)));

        if (SzGetDir(dir, nsz, phr) == NULL)
            return NULL;

        SzNzCat(nsz, sz + iDir, (WORD)max(1, iBase - iDir));
        SzNzCat(nsz, sz + iBase, (WORD)max(1, iExt - iBase));
        STRCAT(nsz, sz + iExt);
    }

    /* We've got all the parameters, now make the FM */
    return FmNew(nsz, phr);
}



FM PASCAL FmNewExistSzDir(LPSTR sz, DIR dir, PHRESULT phr)
{
    char  nsz[_MAX_PATH];
    FM  fm = fmNil;
    OFSTRUCT of;
    char  szANSI[_MAX_PATH];
    int iDrive, iDir, iBase, iExt; 
    int cb;
    DIR idir, xdir;

    if (sz == NULL || *sz == '\0')
    {
        SetErrCode (phr, E_INVALIDARG);
        return NULL;
    }

    cb = (int) STRLEN(sz);
    SnoopPath(sz, &iDrive, &iDir, &iBase, &iExt);

    if (*(sz + iBase) == '\0')         /* no name */
    {
        SetErrCode (phr, E_INVALIDARG);
        return NULL;
    }
    if (*(sz + iDrive) || (*(sz + iDir) == '\\' && !fIsTrailByte(sz,sz+iDir)) || *(sz + iDir) == '/')
    {     /* was given a drive or rooted path, so ignore dir parameter */
        fm = FmNew(sz, phr);
        if (!FExistFm(fm))
        {
            DisposeFm(fm);
            SetErrCode (phr, E_NOTEXIST);
            fm = fmNil;
        }
        return fm;
    }

    for (idir = dirFirst, fm = fmNil; idir <= dirLast && fm==fmNil;
        idir <<= 1)
    {
        xdir = dir & idir;
        if (xdir == dirPath)
        {
            /* search $PATH using the full string which will catch
            the case of a relative path and also do the right thing
            searching $PATH */
            if (OpenFile(sz, (LPOFSTRUCT)&of,
                OF_EXIST | OF_SHARE_DENY_NONE) != (HFILE)-1)
            {
                OemToAnsi(of.szPathName, szANSI);
                fm = FmNew(szANSI, phr);
            }
        }
        else if (xdir)
        {
            if (SzGetDir(xdir, nsz, phr) != NULL)
            {
                SzNzCat(nsz, sz + iDir, (WORD)max(1, iBase - iDir));
                SzNzCat(nsz, sz + iBase, (WORD)max(1, iExt - iBase));
                STRCAT(nsz, sz + iExt);
                fm = FmNew(nsz, phr);
                if (!FValidFm(fm))
                {
                    SetErrCode (phr, E_FAIL);
                }
                else if (!FExistFm(fm))
                {
                    DisposeFm(fm);
                    fm=fmNil;
                }
            }
        }
    } /* for */
    if ((!FValidFm(fm)))
        SetErrCode (phr, E_NOTEXIST);

    return fm;
}


/***************************************************************************
 *
 -  Name:       FmNewTemp
 -
 *  
 *  Purpose:    Create a unique FM for a temporary file
 *
 *  Arguments:  LPSTR Filename: filename's template
 *
 *  Returns:    the new FM, or fmNil if failure
 *
 *  Globals Used: rcIOError
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
FM PASCAL FmNewTemp(LPSTR filename, PHRESULT phr)
{
    char  nsz[_MAX_PATH];
    FM  fm = fmNil;
    char template[5];
    int i;

    if (filename == NULL || *filename == 0)
    {
        // WARNING: we MUST generate our own random
        // prefix here since GetTempFileName does NOT
        // always return a unique name when called twice
        // in very rapid succession.
#ifndef _IT_FULL_CRT
        /* InitRandomPrefix calls rand, which pulls in the c run-time
         * startup code.  Since this is never called we remove the
         * functionality */
        if(phr)
        {
            ITASSERT(FALSE);
            SetErrCode(phr, E_NOTSUPPORTED);
        }
        return fmNil;
#else
        char szPrefix[4];
        InitRandomPrefix(szPrefix, 3);
        GETTEMPFILENAME(0, szPrefix, 0, nsz);
#endif
    }
    else
    {
        for (i = 0; *filename && i < 5; filename++)
        {
            if ((*filename | 0x20) >= 'a' && (*filename | 0x20) <= 'z')
            {
                template[i] = *filename;
                i++;
            }
        }
        template[i] = 0;
        GETTEMPFILENAME(0, template, 0, nsz);
    }
    fm = FmNew(nsz, phr);

    if (fm && RcUnlinkFm(fm) != S_OK)
    {
        DisposeFm(fm);
        SetErrCode (phr, E_FAIL);
        return fmNil;
    }

    return fm;
}

/***************************************************************************
 *
 -  Name:       FmNewSameDirFmSz
 -
 *  Purpose:    Makes a new FM to a file called sz in the same directory
 *              as the file described by fm.
 *
 *  Arguments:  fm - original fm
 *              sz - new file name (including extention, if desired)
 *
 *  Returns:    new FM or fmNil and sets the rc global on failure
 *
 *  Globals Used:
 *    rcIOError
 *
 *  +++
 *
 *  Notes:
 *    This will ignore the passed FM if the filename is fully qualified.
 *    This is in keeping consistent with the other functions above that
 *    ignore the directory parameter in such a case.  It will fail if it
 *    is given a drive with anything but a rooted path.
 *
 ***************************************************************************/
FM PASCAL FmNewSameDirFmSz(FM fm, LPSTR szName, PHRESULT phr)
{
    char  nszNew[_MAX_PATH];
    QAFM  qafm;
    FM    fmNew = fmNil;
    int   iDrive, iDir, iBase, iExt;

    if (!FValidFm(fm) || szName == NULL || *szName == '\0')
    {
        SetErrCode (phr, E_INVALIDARG);
        return fmNil;
   }

    qafm = (QAFM)_GLOBALLOCK((HANDLE)fm);

    /* check for a drive or rooted file name and just return it if it is so */
    SnoopPath(szName, &iDrive, &iDir, &iBase, &iExt);

    if (*(szName + iDrive) || (*(szName + iDir) == '\\' && !fIsTrailByte(szName,szName+iDir)) || *(szName +iDir) == '/')
        STRCPY(nszNew, szName);
    else
    {
        if (*(szName + iDrive) != '\0')
        {
            fmNew = fmNil;
            goto bail_out;
        }
        else
        {
            SnoopPath(qafm->rgch, &iDrive, &iDir, &iBase, &iExt);
            STRNCPY(nszNew, qafm->rgch, iBase);
            *(nszNew + iBase) = '\0';
            STRCAT(nszNew, szName);
        }
    }

    fmNew = FmNew((SZ)nszNew, phr);

bail_out:

    _GLOBALUNLOCK((HANDLE)fm);

    return fmNew;
}


/***************************************************************************
 *
 -  DisposeFm
 -
 *  Purpose
 *    You must call this routine to free the memory used by an FM, which
 *    was created by one of the FmNew* routines
 *
 *  Arguments
 *    fm - original FM
 *
 *  Returns
 *    nothing
 *
 *  Globals Used:
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
VOID PASCAL DisposeFm (FM fm)
{
    if (FValidFm(fm))
        DisposeMemory(fm);
        //_GLOBALFREE ((HANDLE)fm);
}



/***************************************************************************
 *
 -  Name:        FmCopyFm
 -
 *  Purpose:    return an FM to the same file as the passed one
 *
 *  Arguments:  fm
 *
 *  Returns:    FM - for now, it's a real copy.  Later, we may implement caching
 *                              and counts.
 *                              If fmNil, either it's an error (check WGetIOError()) or the
 *                              original fm was nil too
 *
 *  Globals Used:       rcIOError (indirectly)
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
FM PASCAL FmCopyFm(FM fmSrc, PHRESULT phr)
{
    FM fmDest = fmNil;
    QAFM qafmSrc, qafmDest;

    if (!FValidFm(fmSrc))
    {
        SetErrCode (phr, E_INVALIDARG);
        return fmNil;
    }

	qafmSrc = (QAFM)fmSrc;
    //qafmSrc = (QAFM)_GLOBALLOCK((HANDLE)fmSrc);
    fmDest = (FM) NewMemory((WORD)(lstrlen(qafmSrc->rgch) + 1));
    //fmDest = (FM) _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE|GMEM_MOVEABLE,
    //    (size_t)lstrlen(qafmSrc->rgch) + 1);
    if (fmDest == fmNil)
    {
        SetErrCode(phr, E_OUTOFMEMORY);
        //_GLOBALUNLOCK((HANDLE)fmSrc);
        return fmNil;
    }

    qafmDest = (QAFM)fmDest;
    //qafmDest = (QAFM)_GLOBALLOCK((HANDLE)fmDest);
    STRCPY(qafmDest->rgch, qafmSrc->rgch);

    //_GLOBALUNLOCK((HANDLE)fmSrc);
    //_GLOBALUNLOCK((HANDLE)fmDest);

    return fmDest;
}



/***************************************************************************
 *
 -  Name:        FExistFm
 -
 *  Purpose:    Does the file exist?
 *
 *  Arguments:  FM
 *
 *  Returns:    TRUE if it does
 *              FALSE if it doesn't, or if there's an error
 *              (call _ to find out what error it was)
 *
 *  Globals Used: rcIOError
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
BOOL PASCAL FExistFm(FM fm)
{
    QAFM      qafm;
    BOOL      fExist;
    OFSTRUCT  ofs;
    HRESULT        rc;
    char      LocalBuffer1[_MAX_PATH];
    HRESULT      errb;

    if (!FValidFm(fm))
    {
        SetErrCode(&errb, E_INVALIDARG);
        return FALSE;
    }

    qafm = (QAFM)fm;
    //qafm = _GLOBALLOCK((HANDLE)fm);
    STRCPY(LocalBuffer1, qafm->rgch);      /* bring the filename into near space */
    //_GLOBALUNLOCK((HANDLE)fm);

    // try in both modes!
    fExist = (OpenFile(LocalBuffer1, &ofs,
               OF_EXIST | OF_SHARE_DENY_NONE) != (HFILE)-1)
            || (OpenFile(LocalBuffer1, &ofs, OF_EXIST) != (HFILE)-1);

    rc = S_OK;

    if (!fExist)
    {
#ifdef _NT
        if( GetLastError() != ERROR_FILE_NOT_FOUND )
#else
        if( errno != ENOENT )
#endif // _NT
            rc = RcGetDOSError();
    }

    SetErrCode(&errb, rc);

    return fExist;
}



/***************************************************************************
 *
 -  CbPartsFm
 -
 *  Purpose:
 *      Before calling szPartsFm, call this routine to find out how much
 *      space to allocate for the string.
 *
 *  Arguments:
 *      FM - the File Moniker you'll be extracting the string from
 *      INT iPart - the parts of the full pathname you want
 *
 *  Returns:
 *      The length in bytes, INCLUDING the terminating null, of the string
 *      specified by iPart of the filename of FM, or -1 if error
 *
 *  Globals Used:
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
int PASCAL FAR EXPORT_API CbPartsFm(FM fm, int grfPart)
{
    char rgch[_MAX_PATH];

    if (!FValidFm(fm))
        return -1;

    (void)SzPartsFm(fm, rgch, _MAX_PATH, grfPart);

    return ((int) STRLEN(rgch) + 1);   /* add space for the null */
}



/***************************************************************************
 *
 -  SzPartsFm
 -
 *  Purpose:
 *      Extract a string from an FM
 *
 *  Arguments:
 *      FM - the File Moniker you'll be extracting the string from
 *      SZ szDest - destination string
 *      INT cbDest - bytes allocated for the string
 *      INT iPart - the parts of the full pathname you want
 *
 *  Returns:
 *      szDest, or NULL if error (?)
 *
 *  Globals Used:
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
LPSTR PASCAL SzPartsFm(FM fm, LPSTR szDest, int cbDest,
    int iPart)
{
    QAFM  qafm;
    int   iDrive, iDir, iBase, iExt;
    int   cb;
    HRESULT  errb;

    if (!FValidFm(fm) || szDest == NULL || cbDest < 1)
    {
        SetErrCode (&errb, E_INVALIDARG);
        return NULL;
    }

    qafm = (QAFM) fm;
    //qafm = (QAFM) _GLOBALLOCK(fm);

    /* special case so we don't waste effort */
    if (iPart == partAll)
    {
        STRNCPY(szDest, qafm->rgch, cbDest);
        *(szDest + cbDest - 1) = '\0';
        //_GLOBALUNLOCK((HANDLE)fm);
        return szDest;
    }

    SnoopPath(qafm->rgch, &iDrive, &iDir, &iBase, &iExt);

    *szDest = '\0';

    if (iPart & partDrive)
    {
        cb = max(0, iDir - iDrive);
        SzNzCat(szDest, qafm->rgch + iDrive, (WORD)(min(cb + 1, cbDest) - 1));
        cbDest -= cb;
    }

    if (iPart & partDir)
    {
        cb = max(0, iBase - iDir);
        SzNzCat(szDest, qafm->rgch + iDir, (WORD)(min(cb + 1, cbDest) - 1));
        cbDest -= cb;
    }

    if (iPart & partBase)
    {
        cb = max(0, iExt - iBase);
        SzNzCat(szDest, qafm->rgch + iBase, (WORD)(min(cb + 1, cbDest) - 1));
        cbDest -= cb;
    }

    if (iPart & partExt)
    {
        SzNzCat(szDest, qafm->rgch + iExt, (WORD)(cbDest - 1));
    }

    //_GLOBALUNLOCK((HANDLE)fm);

    return szDest;
}



/***************************************************************************
 *
 -  Name:       FSameFmFm
 -
 *  Purpose:    Compare two FM's
 *
 *  Arguments:  fm1, fm2
 *
 *  Returns:    TRUE or FALSE
 *
 *  Globals Used:
 *
 *  +++
 *
 *  Notes:      case insensitive compare is used because strings are
 *              upper cased at FM creation time
 *
 ***************************************************************************/
BOOL PASCAL  FSameFmFm(FM fm1, FM fm2)

{
    QAFM qafm1;
    QAFM qafm2;
    BOOL fSame;

    if (fm1 == fm2)
        return TRUE;

    if (!FValidFm(fm1) || !FValidFm(fm2))
        return FALSE;

    qafm1 = (QAFM)fm1;
	qafm2 = (QAFM)fm2;
    //qafm1 = _GLOBALLOCK(fm1);
    //qafm2 = _GLOBALLOCK(fm2);
    fSame = STRCMP(qafm1->rgch, qafm2->rgch) == 0;

    //_GLOBALUNLOCK(fm1);
    //_GLOBALUNLOCK(fm2);

    return fSame;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\htmlhelp\init.cpp ===
// Copyright (C) Microsoft Corporation 1996-1997, All Rights reserved.

#include "windows.h"
#include "htmlhelp.h"

#pragma data_seg(".text", "CODE")
static const char txtHHCtrl[] = "hhctrl.ocx";
static const char txtInProc[] = "CLSID\\{ADB880A6-D8FF-11CF-9377-00AA003B7A11}\\InprocServer32";
#pragma data_seg()

HWND (WINAPI *pHtmlHelpA)(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData);
HWND (WINAPI *pHtmlHelpW)(HWND hwndCaller, PCWSTR pszFile, UINT uCommand, DWORD_PTR dwData);

static BOOL GetRegisteredLocation(LPTSTR pszPathname)
{
    BOOL bReturn = FALSE;

    HKEY hKey;
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, txtInProc, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        DWORD dwSize = MAX_PATH;
        if (RegQueryValueEx(hKey, "", 0, 0, (PBYTE) pszPathname, &dwSize) == ERROR_SUCCESS) {
            bReturn = TRUE;
        }
    }
    else
        return FALSE;

    RegCloseKey(hKey);

    return bReturn;
}

extern "C"
HWND WINAPI HtmlHelpA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
    static HMODULE   g_hmodHHCtrl;
    static BOOL      g_fTriedAndFailed;

    if (!g_hmodHHCtrl && !g_fTriedAndFailed) {
        char szHHCtrl[MAX_PATH];
        if (GetRegisteredLocation(szHHCtrl))
            g_hmodHHCtrl = LoadLibrary(szHHCtrl);   // try registered location
        if (!g_hmodHHCtrl)
            g_hmodHHCtrl = LoadLibrary(txtHHCtrl);  // try normal location
        if (g_hmodHHCtrl == NULL) {
            g_fTriedAndFailed = TRUE;
            return NULL;
        }
    }
    if (!pHtmlHelpA) {
        (FARPROC&) pHtmlHelpA = GetProcAddress(g_hmodHHCtrl, ATOM_HTMLHELP_API_ANSI);
        if (pHtmlHelpA == NULL) {
            g_fTriedAndFailed = TRUE;
            return NULL;
        }
    }
    return pHtmlHelpA(hwndCaller, pszFile, uCommand, dwData);
}

extern "C"
HWND WINAPI HtmlHelpW(HWND hwndCaller, PCWSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
    static HMODULE   g_hmodHHCtrl;
    static BOOL      g_fTriedAndFailed;

    if (!g_hmodHHCtrl && !g_fTriedAndFailed) {
        char szHHCtrl[MAX_PATH];
        if (GetRegisteredLocation(szHHCtrl))
            g_hmodHHCtrl = LoadLibrary(szHHCtrl);   // try registered location
        if (!g_hmodHHCtrl)
            g_hmodHHCtrl = LoadLibrary(txtHHCtrl);
        if (g_hmodHHCtrl == NULL) {
            g_fTriedAndFailed = TRUE;
            return NULL;
        }
    }
    if (!pHtmlHelpW) {
        (FARPROC&) pHtmlHelpW = GetProcAddress(g_hmodHHCtrl, ATOM_HTMLHELP_API_UNICODE);
        if (pHtmlHelpW == NULL) {
            g_fTriedAndFailed = TRUE;
            return NULL;
        }
    }
    return pHtmlHelpW(hwndCaller, pszFile, uCommand, dwData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\chartab.c ===
/*************************************************************************
*                                                                        *
*  CHARTAB.C                                                             *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*    Character table indexing and retrieval. The reasons this module is  *
*    not put together with ansiusa are:                                  *
*       - Like stop words, this involves indexing and retrieval          *
*       - It is word breaker independent                                 *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: Binh Nguyen                                            *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>
#include <mem.h>
#include <memory.h>
#include <iterror.h>
#include <_mvutil.h>
#include <mvsearch.h>
#include "common.h"

#ifdef _DEBUG
static BYTE NEAR *s_aszModule = __FILE__;      // Used by error return functions.
#endif

#define         SLASH            '/'
#define         RETURN           '\r'
#define         NEWLINE          '\n'
#define         INBUF_SIZE       256     // Maximum buffer size to store a line
#define         BYTE_MAX         256     // Maximum number of characters
#define         LIGATURE_BYTES   3       // Number of bytes/ligature

/* External variables */

extern BYTE LigatureTable[];
extern CHARMAP DefaultCMap[];

/*************************************************************************
 *
 *                           API FUNCTIONS
 *      Those functions should be exported in a .DEF file
 *************************************************************************/
PUBLIC LPV EXPORT_API FAR PASCAL MVCharTableLoad (HFPB, LSZ, PHRESULT);
PUBLIC LPV EXPORT_API FAR PASCAL MVCharTableGetDefault (PHRESULT);
PUBLIC VOID EXPORT_API FAR PASCAL MVCharTableDispose (LPVOID);
PUBLIC HRESULT EXPORT_API PASCAL FAR MVCharTableFileBuild (HFPB, LPVOID, LSZ);
PUBLIC LPV EXPORT_API FAR PASCAL MVCharTableIndexLoad(HFPB, LSZ, PHRESULT);


/*************************************************************************
 *
 *                        INTERNAL PRIVATE FUNCTIONS
 *      All of them should be declared near
 *************************************************************************/
PRIVATE LPB NEAR PASCAL GetNumber (HFPB, LPB, LPB, int FAR *, WORD FAR *);
PRIVATE LPCHARTAB PASCAL NEAR CharTableCreate (int);
PRIVATE VOID PASCAL NEAR StripCRLF (LPB, WORD);
PRIVATE VOID PASCAL NEAR GetWord (LSZ FAR *, LST);

PUBLIC VOID PASCAL FAR FreeHandle2 (HANDLE hd)
{
    if (hd) {
        _GLOBALUNLOCK(hd);
        _GLOBALFREE(hd);
    }
}

/*************************************************************************
 *      @doc    EXTERNAL API INDEX
 *
 *      @func   LPCHARTAB FAR PASCAL | MVCharTableLoad |
 *              Open an ASCII file and read in the description of the character
 *              tables. It then converts them into binary format ready to be used
 *              The format of the file is:
 *                      Size    // How many entries
 *                      char class, normalized value, sorted value, mac display value
 *                          ........
 *                      char class, normalized value, sorted value, mac display value
 *              Comments are preceded by // and ignored until EOL
 *    A description of the ligature table, if any, is to followed the
 *    charmap table
 *
 *		@parm	HFPB | hfpbIn |
 *				Handle to system file or subfile; NULL if file is external.
 *
 *      @parm   LSZ | lszFilename |
 *              DOS filen containing the description of the tables
 *
 *      @parm   PHRESULT | phr |
 *              Error buffer
 *
 *      @rdesc
 *              The function returns a pointer to the memory block containing
 *              tables, or NULL if failed. The error buffer will contain
 *              description for the cause of the failure
 *
 *      @comm   About ligature table, there are some assumptions:
 *              If there is no wcLigature, then the default table is used
 *              if (wcLigature == 0) no ligature should be used
 *              if wcLigature != 0, the author provides a ligature table.
 *************************************************************************/
PUBLIC LPVOID EXPORT_API FAR PASCAL MVCharTableLoad (HFPB hfpbIn,
	LSZ lszFilename, PHRESULT phr)
{
    register WORD j;                // Scratch index variable
    register WORD i;                // Scratch index variable
    register LPB lpbBuf;            // Pointer to input buffer
    WORD cbRead;                    // How many bytes have read (left)
    int wcTabEntries;               // Number of table entries
    int wTmp;                       // Scratch variable
    HFPB hfpb;						// Handle of char table file
	BOOL fOpenedFile;				// TRUE if we have to close the file
    BYTE Buffer [INBUF_SIZE];       // Input buffer
    LPCMAP lpCMap;                  // Pointer to character table entries
    LPCHARTAB lpCharTab = NULL;     // Pointer to general char table struct
    int wcLigature;
    LPB   lpbChar;                  // Scratch pointer

	/* Open subfile if necessary, (and system file if necessary) */
	if ((fOpenedFile = FsTypeFromHfpb(hfpb = hfpbIn) != FS_SUBFILE) &&
		(hfpb = (HANDLE)FileOpen
			(hfpbIn, lszFilename, hfpbIn ? FS_SUBFILE : REGULAR_FILE,
			READ, phr)) == 0)
	{
        SetErrCode (phr, E_FILENOTFOUND);
        return NULL;
    }

    *phr = E_BADFORMAT;

    /* Fill in the buffer */
    if ((cbRead =
			(WORD) FileRead(hfpb, lpbBuf = Buffer, INBUF_SIZE, phr)) == 0 ||
		FAILED(*phr))
	{
        goto ErrorExit;
    }

    /* Get the table size */
    lpbBuf = GetNumber (hfpb, Buffer, lpbBuf, &wcTabEntries, &cbRead);
    if (wcTabEntries == 0 || wcTabEntries > BYTE_MAX) {
        goto ErrorExit;
    }

    /* Allocate memory for the character table */
    if ((lpCharTab = CharTableCreate (wcTabEntries)) == NULL)
	{
        SetErrCode (phr, E_OUTOFMEMORY);
		if (fOpenedFile)
			FileClose (hfpb);
        return NULL;
    }
    lpCMap = (LPCMAP)lpCharTab->lpCMapTab;
    lpCharTab->wcTabEntries = (WORD) wcTabEntries;

    /* Now read in invidual char table entry */
    for (i = (WORD) wcTabEntries; i > 0; i--, lpCMap++) {
        if ((lpbBuf = GetNumber (hfpb, Buffer, lpbBuf, &wTmp,
           &cbRead)) == NULL) {
          /* Missing item */
            goto ErrorExit;
       }
        lpCMap->Class = (WORD) wTmp;
      
        if ((lpbBuf = GetNumber (hfpb, Buffer, lpbBuf, &wTmp,
           &cbRead)) == NULL) {
          /* Missing item */
            goto ErrorExit;
       }
        lpCMap->SortOrder = (WORD) wTmp;
      
        if ((lpbBuf = GetNumber (hfpb, Buffer, lpbBuf, &wTmp,
           &cbRead)) == NULL) {
          /* Missing item */
            goto ErrorExit;
       }
        lpCMap->Norm = (BYTE)wTmp;
      
        if ((lpbBuf = GetNumber (hfpb, Buffer, lpbBuf, &wTmp,
           &cbRead)) == NULL) {
          /* Missing item */
            goto ErrorExit;
       }
        lpCMap->WinCaseSensitiveNorm = (BYTE)wTmp;
      
        if ((lpbBuf = GetNumber (hfpb, Buffer, lpbBuf, &wTmp,
           &cbRead)) == NULL) {
          /* Missing item */
            goto ErrorExit;
       }
        lpCMap->MacDisplay = (BYTE)wTmp;
        
        if ((lpbBuf = GetNumber (hfpb, Buffer, lpbBuf, &wTmp,
           &cbRead)) == NULL) {
          /* Missing item */
            goto ErrorExit;
       }
       lpCMap->MacCaseSensitiveNorm = (BYTE)wTmp;
    }

    /*
     * Check for valid table, ie. all reserved characters should not
     * be modified
     */

    /* Check for valid reserved type */

    lpCMap = &(((LPCMAP)lpCharTab->lpCMapTab)[1]);
    if (lpCMap->Class != CLASS_TYPE)
        goto ErrorExit;
    
    /* Check for ligatures */
    if ((lpbBuf = GetNumber (hfpb, Buffer, lpbBuf,
        &wcLigature, &cbRead)) == NULL) {

        /* No ligature table present, use default */

        lpCharTab->wcLigature = DEF_LIGATURE_COUNT;     
        lpCharTab->fFlag = USE_DEF_LIGATURE;
        lpCharTab->lpLigature = LigatureTable;
    }
    else {
        if ((lpCharTab->wcLigature = (WORD) wcLigature) != 0) {

            /* Ligature table present */

            /* Allocate memory block. Notice that we allocate 3 extra bytes
             * They will serve as sentinels for the end of the ligature
             * table, thus eliminating the need of having to know beforehand
             * what is the size of the table
             */
            if ((lpCharTab->hLigature = _GLOBALALLOC (DLLGMEM_ZEROINIT,
                LIGATURE_BYTES * (wcLigature + 1))) == 0) {
                SetErrCode (phr, E_OUTOFMEMORY);
                goto ErrorExit;
            }
            lpbChar = lpCharTab->lpLigature =
                (LPB)_GLOBALLOCK(lpCharTab->hLigature);

            /* Read in the entries */

            for (i = (WORD) wcLigature; i > 0; i--) {
                for (j = LIGATURE_BYTES; j > 0; j--) {
                    if (lpbBuf = GetNumber (hfpb, Buffer, lpbBuf,
                        &wTmp, &cbRead)) {
                        /* Update entry */
                        *lpbChar ++ = (BYTE)wTmp;
                    }
                    else {
                        /* Missing item */
                        goto ErrorExit;
                    }
                }
            }
            lpCharTab->fFlag = LIGATURE_PROVIDED;
        }
        else
            lpCharTab->fFlag = NO_LIGATURE;
    }
   
    if (fOpenedFile)
		FileClose (hfpb);
    return ((LPV)lpCharTab);

ErrorExit:
    if (fOpenedFile)
		FileClose (hfpb);
    MVCharTableDispose (lpCharTab);
    return NULL;
}

/*************************************************************************
 *      @doc    API INDEX
 *
 *      @func   HRESULT PASCAL FAR | MVCharTableFileBuild |
 *              Incorporate the character table into the system file
 *
 *      @parm   HFPB | hfpbSysFile |
 *              Handle to system file. It is non-zero, then the system file is
 *              already open, else the function will open the system file
 *
 *      @parm   LPCHARTAB | lpCharTab |
 *              Pointer to character table information structure
 *
 *      @parm   LSZ | lszFilename |
 *              File name. If hpfbSysFile is 0, the format is:
 *              dos filename[!charfilename], else it is the name of the character
 *              file itself
 *
 *      @rdesc ERR_SUCCESS if succeeded, other errors if failed. 
 *
 *      @comm   About ligature table, there are some assumptions:
 *              If hLigature == 0 {
 *                      if (wcLigature == 0)
 *                              There is no ligature table
 *                      else
 *                              We use the default ligature table. There is no need
 *                              to write out the table data
 *              }
 *              else
 *                      The author provides a ligature table.
 *************************************************************************/

PUBLIC HRESULT EXPORT_API PASCAL FAR MVCharTableFileBuild (HFPB hfpbSysFile,
    LPCHARTAB lpCharTab, LSZ lszFilename)
{
    HFPB hfpbCharTab;                       // Pointer to final index file info.
	BOOL fCreatedFile;
    CHARTAB_HDR CharTab_hdr;        // Character table header
    BYTE Dummy[CHARTAB_HDR_SIZE]; // Dummy buffer to write 0
    FILEOFFSET foOffset;                         // File's offset
	FILEOFFSET foStart;
    WORD CharTabSize;
    WORD CharLigatureSize;
//    char szFullFilename[MAX_PATH];
    HRESULT hr = S_OK;


    if (lpCharTab == NULL || lpCharTab->wcTabEntries == 0)
    {
        /* Nothing to build */
        return E_INVALIDARG;
    }

    /* If hfpbSysFile != 0, allocate a temp HFPB to use for the system file */
    //if (!(fCloseSysFile = (char)(hfpbSysFile == 0))) {
    //  if ((hfpb = ALLOCTEMPFPB (hfpbSysFile, phr)) == NULL) 
    //      return ERR_FAILED;
    //}

    if ((fCreatedFile =
			FsTypeFromHfpb(hfpbCharTab = hfpbSysFile) != FS_SUBFILE) &&
		0 == (hfpbCharTab = FileCreate
				(hfpbSysFile, lszFilename,
						hfpbSysFile ? FS_SUBFILE : REGULAR_FILE, &hr)))
    {
        return hr;
    }

	// If we didn't open the file, we need to find out where the file seek
	// pointer is initially so that we only seek relative to that starting
	// position (i.e. the caller owns the part of the file that comes before).
	foStart = (fCreatedFile ? MakeFo(0,0) :
				FileSeek (hfpbCharTab, MakeFo (0, 0), wFSSeekCur, &hr));

	if (FAILED(hr))
		goto exit01;

    /* Write out the CharTab file header */
    CharTab_hdr.FileStamp = CHRTAB_STAMP;
    CharTab_hdr.version = CHARTABVER;

    CharTabSize = lpCharTab->wcTabEntries * sizeof(CHARMAP);
    /* the ligature table size:
     *   - is 0 if we are going to use the default table
     *   - Is non-0 if the author provides a ligature table
     */
    switch (lpCharTab->fFlag)
    {
        case NO_LIGATURE:
        case USE_DEF_LIGATURE:
            CharLigatureSize = 0;
            break;
        default:
            CharLigatureSize = lpCharTab->wcLigature * LIGATURE_BYTES;
    }

    CharTab_hdr.dwTabSize = CharTabSize + CharLigatureSize;
    CharTab_hdr.wcTabEntries = lpCharTab->wcTabEntries;
    CharTab_hdr.wcLigature = lpCharTab->wcLigature;
    CharTab_hdr.fFlag = lpCharTab->fFlag;

    MEMSET(Dummy, (BYTE)0, CHARTAB_HDR_SIZE);

    /* Write all zero to the header */
    if (FileSeekWrite(hfpbCharTab, Dummy, FoAddFo(foStart, foNil),
			CHARTAB_HDR_SIZE, &hr) != CHARTAB_HDR_SIZE)
    {
        goto exit01;
    }

    if (FileSeekWrite(hfpbCharTab, &CharTab_hdr, FoAddFo(foStart, foNil),
			sizeof(CHARTAB_HDR), &hr) != sizeof(CHARTAB_HDR))
    {
        goto exit01;
    }

    foOffset = FoAddFo(foStart, MakeFo(CHARTAB_HDR_SIZE,0L));

    /* Write out the character table buffer */
    if (FileSeekWrite(hfpbCharTab, lpCharTab->lpCMapTab, foOffset,
        CharTabSize, &hr) != CharTabSize)
    {
        goto exit01;
    }

    if (CharLigatureSize)
    {
        foOffset = FoAddDw(foOffset,CharTabSize);

        /* Write out the ligature table */
        if (FileSeekWrite(hfpbCharTab, lpCharTab->lpLigature, foOffset,
            CharLigatureSize, &hr) != CharLigatureSize)
        {
            goto exit01;
        }
    }

    hr = S_OK;

exit01:
	// Close file if we created it.
	if (fCreatedFile)
		FileClose(hfpbCharTab);  // Removed fRet= here.
    
    return hr;
}

/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   VOID PASCAL NEAR | GetWord |
 *              This function will scan and get a word from the input buffer
 *
 *      @parm   LSZ FAR | *lplszBuf |
 *              Pointer to input buffer. The content will be updated on exit
 *
 *      @parm   LST | lstWord |
 *              Buffer to received parsed word
 *************************************************************************/
PRIVATE VOID PASCAL NEAR GetWord (LSZ FAR *lplszBuf, LST lstWord)
{
    LST  lstWordStart;
    LSZ  lszBuf = *lplszBuf;

    /* Remember the beginning of the word */
    lstWordStart = lstWord++;

    /* Skip all beginning blanks */
    while (*lszBuf == ' ')
        lszBuf++;

    /* Now keep accumulating the word's characters */
    for (;;) {
        switch (*lszBuf) {
            case 0:
            case ' ':
                goto exit0;

            case '/':
                if (*(lszBuf + 1) == '/') { 
                    /* Skip the inline comment */
                    while (*lszBuf)
                        lszBuf++;
                    goto exit0;
                }

            default:
                *lstWord++ = *lszBuf++;
        }
    }

exit0:
    *lplszBuf = lszBuf;
    *lstWordStart = (BYTE)(lstWord - lstWordStart - 1);
}

/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   VOID PASCAL NEAR | StripCRLF |
 *              This function will change all CR, LF in the input buffer into
 *              0, all tabs into blank
 *
 *      @parm   LPB | lpbBuf |
 *              Input buffer
 *
 *      @parm   WORD | BufSize |
 *              Length of the buffer
 *************************************************************************/
PRIVATE VOID PASCAL NEAR StripCRLF (LPB lpbBuf, WORD BufSize)
{
    for (; BufSize > 0; BufSize --)
    {
        switch (*lpbBuf)
        {
            case RETURN:
            case NEWLINE:
                *lpbBuf = 0;
                break;
            case '\t':
                *lpbBuf = ' ';
                break;
        }
        lpbBuf++;
    }
}


/*************************************************************************
 *      @doc    API RETRIEVAL
 *
 *      @func   LPCHARTAB FAR PASCAL | MVCharTableIndexLoad |
 *              This function will load a character table from a
 *              system file.
 *
 *      @parm   HANDLE | hfpbSysFile |
 *              If non-zero, this is the handle of an already opened system file
 *
 *      @parm   LSZ | lszFilename |
 *              If hpfbSysFile is non-zero, this is the name of the CharTab's subfile
 *              else this is the combined filename with the format
 *              "dos_filename[CharTab_filename]"
 *              If the subfile's name is not specified, the default CharTab's file
 *              name will be used
 *
 *      @parm   PHRESULT | phr |
 *              Pointer to error buffer
 *
 *      @rdesc  If succeeded, the function will return a pointer the loaded
 *              CharTab, else NULL. The error buffer will contain information
 *              about the cause of the failure
 *
 *      @comm   About ligature table, there are some assumptions:
 *              If hLigature == 0 {
 *                      if (wcLigature == 0)
 *                              There is no ligature table
 *                      else
 *                              We use the default ligature table. There is no need
 *                              to write out the table data
 *              }
 *              else
 *                      The author provides a ligature table.
 *************************************************************************/
PUBLIC  LPVOID EXPORT_API FAR PASCAL MVCharTableIndexLoad(HFPB hfpbSysFile,
    LSZ lszFilename, PHRESULT phr)
{
    HANDLE hfpbCharTabFile;
	BOOL	fOpenedFile;
    LPCHARTAB       lpCharTab = NULL;
    CHARTAB_HDR FAR *lpCharTabHdr;
    CHARTAB_HDR CharTabHdr;
	FILEOFFSET foStart;

#if _MAC
    int MacClipMap[256], i;
    LPCMAP lpCMapEntry;
#endif

	*phr = S_OK;
    lpCharTabHdr = &CharTabHdr;

	/* Open subfile, (and system file if necessary) */
	if ((fOpenedFile =
			FsTypeFromHfpb(hfpbCharTabFile = hfpbSysFile) != FS_SUBFILE) &&
		(hfpbCharTabFile = (HANDLE)FileOpen
			(hfpbSysFile, lszFilename, hfpbSysFile ? FS_SUBFILE : REGULAR_FILE,
			READ, phr)) == 0)
	{
exit0:
		return (LPV)lpCharTab;
	}

	// If we didn't open the file, we need to find out where the file seek
	// pointer is initially so that we only seek relative to that starting
	// position (i.e. the caller owns the part of the file that comes before).
	foStart = (fOpenedFile ? MakeFo(0,0) :
				FileSeek (hfpbCharTabFile, MakeFo (0, 0), wFSSeekCur, phr));

    /* Read in the header file, and make sure that is a CharTab file */
    if (FAILED(*phr) ||
		FileSeekRead(hfpbCharTabFile, (LPV)lpCharTabHdr, FoAddFo(foStart, foNil),
        sizeof(CHARTAB_HDR), phr) != sizeof(CHARTAB_HDR)) {
exit1:
        /* Close the subfile if we opened it */
		if (fOpenedFile)
			FileClose(hfpbCharTabFile);

        /* Close the system file if we open it, the handle will be
         * released in the process */

        goto exit0;
    }

    /* MAC code. They will be optimized out */

    lpCharTabHdr->FileStamp = SWAPWORD(lpCharTabHdr->FileStamp);
    lpCharTabHdr->version = SWAPWORD(lpCharTabHdr->version);
    lpCharTabHdr->wcTabEntries = SWAPWORD(lpCharTabHdr->wcTabEntries);
    lpCharTabHdr->wcLigature = SWAPWORD(lpCharTabHdr->wcLigature);
    lpCharTabHdr->fFlag = SWAPWORD(lpCharTabHdr->fFlag);
    lpCharTabHdr->dwTabSize = SWAPLONG(lpCharTabHdr->dwTabSize);

    /* Check to see if the data read in is valid */
    if (lpCharTabHdr->FileStamp !=  CHRTAB_STAMP)
    {   // File stamp
        SetErrCode(phr, E_BADVERSION);
        goto exit1;
    }
    /* Allocate memory for the character table. Note that there may be
     * some inefficiency im memory usage, since there are 3-bytes per
     * ligature entry, and several more for each charmap entry.
     */
    if ((lpCharTab = CharTableCreate ((lpCharTabHdr->wcTabEntries +
        lpCharTabHdr->wcLigature))) == NULL) {
        SetErrCode(phr, E_OUTOFMEMORY);
        goto exit1;
    }

    lpCharTab->wcTabEntries = lpCharTabHdr->wcTabEntries;
    lpCharTab->fFlag = lpCharTabHdr->fFlag;
    lpCharTab->hLigature = 0;

    /* Read in the CharTab bitmap data */
    if (FileSeekRead(hfpbCharTabFile,
        (LPV)lpCharTab->lpCMapTab, FoAddFo(foStart, MakeFo(CHARTAB_HDR_SIZE,0)),
        (WORD)lpCharTabHdr->dwTabSize, phr) !=
        (WORD)lpCharTabHdr->dwTabSize)
    {
        MVCharTableDispose(lpCharTab);
        lpCharTab = NULL;
        goto exit1;
    }

#if _MAC
   /* Create the mapping from Mac to Windows. This is to deal with the
    * situation people entering data on a Mac and look for that string
    */
    lpCMapEntry = (LPCMAP)lpCharTab->lpCMapTab;

    for (i = lpCharTab->wcTabEntries; i > 0; i--)  
    {
        // erinfox: swap class
        lpCMapEntry[i].Class = SWAPWORD(lpCMapEntry[i].Class);

        lpCMapEntry[i].SortOrder = SWAPWORD(lpCMapEntry[i].SortOrder);
		if (lpCMapEntry[i].MacDisplay != 0)
        {
            lpCMapEntry[lpCMapEntry[i].MacDisplay].MacToWin = i;
        }
    }

    /* Change the Mac clipboard mapping. I am using the 256 value.
     * The character table hasthe mapping based on the Windows indices
     * but since the WinToMap mapping will change all the character
     * values to their corresponding Mac, the new values have to be
     * used as indices, ie. there is a need to remap the
     * MacCaseSensitiveNorm column based on the new Mac indices
     */
    MEMSET (MacClipMap, 0, 256);
    for ( i = 0; i < lpCharTab->wcTabEntries; i++)
    {
        MacClipMap[lpCMapEntry[i].MacDisplay] =
            lpCMapEntry[i].MacCaseSensitiveNorm;
    }

    /* Reset the mapping. */
    /* Change all 0's to 32 (space) to avoid truncation */
    for ( i = 0; i < lpCharTab->wcTabEntries; i++)
    {
        if ((lpCMapEntry[i].MacCaseSensitiveNorm = MacClipMap[i]) == 0)
            lpCMapEntry[i].MacCaseSensitiveNorm = 32;
    }
#endif /* _MAC */
   
    /* Look for ligature */
    switch (lpCharTab->fFlag) {
        case NO_LIGATURE:
            break;

        case USE_DEF_LIGATURE:
            lpCharTab->wcLigature = DEF_LIGATURE_COUNT;
            lpCharTab->fFlag = USE_DEF_LIGATURE;
            lpCharTab->hLigature = 0;
            lpCharTab->lpLigature = LigatureTable;
            break;

        default:
            lpCharTab->lpLigature = (LPB)lpCharTab->lpCMapTab +
                lpCharTabHdr->wcTabEntries * sizeof(CHARMAP);
            lpCharTab->wcLigature = lpCharTabHdr->wcLigature;
    }
    goto exit1;
}

/*************************************************************************
 *  @doc    API RETRIEVAL
 *  @func   LPCTAB FAR PASCAL | MVCharTableGetDefault |
 *      Retrieve the default character mapping table used by MV
 *  @parm   PHRESULT | phr |
 *      Pointer to error buffer
 *  @rdesc
 *      Pointer to character mapping table if successful, NULL otherwise.
 *      In case of error, phr will contain the error code
 *************************************************************************/
PUBLIC LPV EXPORT_API FAR PASCAL MVCharTableGetDefault (PHRESULT phr)
{
    LPCHARTAB  lpCharTab = NULL;
#if _MAC
    int i;
    LPCMAP lpCMapEntry;
#endif /* _MAC */

    /* Allocate memory for the character table. Note that there may be
     * some inefficiency im memory usage, since there are 3-bytes per
     * ligature entry, and several more for each charmap entry.
     */
    if ((lpCharTab = CharTableCreate (MAX_CHAR_COUNT +
      DEF_LIGATURE_COUNT)) == NULL) {
        SetErrCode(phr, E_OUTOFMEMORY);
        return NULL;
    }

    lpCharTab->wcTabEntries = MAX_CHAR_COUNT;
    lpCharTab->wcLigature = DEF_LIGATURE_COUNT;
    lpCharTab->fFlag = USE_DEF_LIGATURE;
    lpCharTab->hLigature = 0;
    lpCharTab->lpLigature = LigatureTable;
    lpCharTab->lpCMapTab = DefaultCMap;
   
#if _MAC
    /* Create the mapping from Mac to Windows. This is to deal with the
     * situation people entering data on a Mac and look for that string
     */
    lpCMapEntry = (LPCMAP)lpCharTab->lpCMapTab;
   
    for (i = lpCharTab->wcTabEntries; i > 0; i--)  {
        if (lpCMapEntry[i].MacDisplay != 0)  {
            lpCMapEntry[lpCMapEntry[i].MacDisplay].MacToWin = i;
        }
    }
   
    /* Create the clipboard case sensitive column */
#endif /* _MAC */
   
    return(lpCharTab);
   
}

/*************************************************************************
 *      @doc    API INDEX RETRIEVAL
 *
 *      @func   VOID FAR PASCAL | MVCharTableDispose |
 *              Free all memory associated with the character table
 *
 *      @parm   LPCHARTAB | lpCharTab |
 *              Pointer to character table structure
 *************************************************************************/
PUBLIC VOID EXPORT_API FAR PASCAL MVCharTableDispose (LPCHARTAB lpCharTab)
{
    HANDLE hBuf;

    if (lpCharTab == NULL)
        return;
    if (hBuf = lpCharTab->hLigature) {
        FreeHandle2(hBuf);
        lpCharTab->hLigature = NULL;
    }
	FreeHandle2(lpCharTab->hStruct);
}


/*************************************************************************
 *      @doc    API INDEX RETRIEVAL
 *
 *      @func   VOID FAR PASCAL | MVCharTableSetWildcards |
 *              Change the property of '*' and '?' to CLASS_WILDCARD.
 *
 *      @parm   LPCHARTAB | lpCharTab |
 *              Pointer to character table structure
 *************************************************************************/
PUBLIC VOID EXPORT_API FAR PASCAL MVCharTableSetWildcards (LPCHARTAB lpCharTab)
{
	if (lpCharTab == NULL)
		return;
		
	(lpCharTab->lpCMapTab)['*'].Class = CLASS_WILDCARD;
	(lpCharTab->lpCMapTab)['?'].Class = CLASS_WILDCARD;
}


/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   LPB NEAR PASCAL | GetNumber |
 *              This function will try to get to a number in an ASCII and then
 *              retrieve it. It will fill up the input buffer if necessary
 *
 *      @parm   HFPB | hfpb |
 *              Handle of opened file
 *
 *      @parm   LPB | Buffer |
 *              Buffer to store the input data
 *
 *      @parm   LPB | lpbBuf |
 *              Current location pointer into the input buffer
 *
 *      @parm   int far * | lpNum |
 *              Place to store the retrieved number
 *
 *      @parm   WORD FAR * | lpcbRead |
 *              How many bytes are left in the input buffer
 *
 *      @rdesc  If succeeded, the function will return the last location
 *              of the input buffer, else NULL if failed. If succeeded, the
 *              number is stored in *lpNum, the number of bytes left in the input
 *              buffer is updated
 *************************************************************************/
PRIVATE LPB NEAR PASCAL GetNumber (HFPB hfpb, LPB Buffer, LPB lpbBuf,
    int far *lpNum, WORD FAR *lpcbRead)
{
    register WORD fSkipComment = 0;
    register WORD cbRead = *lpcbRead;
    WORD number = 0;
    BYTE fGetNum = FALSE;
	HRESULT hr;

    for (;;) {
        /* Check for empty buffer, and read in new data if necessary */
        if (cbRead == 0) {
            cbRead = (WORD) FileRead(hfpb, lpbBuf = Buffer, INBUF_SIZE, &hr);
            if (cbRead == 0 || FAILED(hr)) {
                if (fGetNum == FALSE)
                    lpbBuf = NULL;  // Return error
                break;
            }
        }

        if (*lpbBuf == RETURN || *lpbBuf == NEWLINE) {
            /* EOL, reset variables, exit if we already got a number */
            fSkipComment = 0;
            if (fGetNum)
                break;
        }
        else if (fSkipComment != 2) {
            /* We are not inside a comment, so look for a number */
            if (*lpbBuf >= '0' && *lpbBuf <= '9') {
                /* Get the number */
                number = number * 10 + *lpbBuf - '0';
                fGetNum = TRUE;
            }
            else if (*lpbBuf == SLASH) {
                if (fGetNum)
                    break;
                fSkipComment++; // Increment slash count
            }
            else {
                if (fGetNum)
                    break;
                fSkipComment = 0;
            }
        }
        cbRead--;
        lpbBuf++;
    }

    /* Update the variables */
    *lpcbRead = cbRead;
    *lpNum = number;
    return lpbBuf;
}


/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   LPCHARTAB PASCAL NEAR | CharTableCreate |
 *              Allocate memory necessary for the character table. The amount
 *              needed is based on the number of entries
 *
 *      @parm   WORD | wcTabEntries |
 *              Number of entries in the character table
 *
 *************************************************************************/
PRIVATE LPCHARTAB PASCAL NEAR CharTableCreate (int wcTabEntries)
{
    HANDLE hMem;
    LPCHARTAB lpCharTab;

    /* Allocate memory for the character table */
    if ((hMem = _GLOBALALLOC (DLLGMEM_ZEROINIT,
        sizeof(CHARTAB) + wcTabEntries * sizeof(CHARMAP))) == NULL) {
        return NULL;
    }
    lpCharTab = (LPCHARTAB)_GLOBALLOCK(hMem);
    lpCharTab->lpCMapTab = (LPCMAP)(lpCharTab + 1);
    lpCharTab->hStruct = hMem;
    return lpCharTab;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\fileoff.c ===
/*****************************************************************************
 *                                                                            *
 *  FILEOFF.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1995.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  File Offset data type to replace using LONG for file offsets to handle    *
 *	files larger than 4 gigs in size.    									  *
 *  WARNING: To support 68K retail version, some functions don't have the
 *  Pascal  keyword. MSVC 4.0 had a bug that caused structure parameter to    *
 *  destroyed                                                                 *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                     *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Created 07/28/95 - davej
 *          3/05/97     erinfox Change errors to HRESULTS
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;    /* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <fileoff.h>

/*****************************************************************************
 *                                                                            *
 *                               Globals									  *
 *                                                                            *
 *****************************************************************************/

FILEOFFSET EXPORT_API foNil = {0L, 0L};
FILEOFFSET EXPORT_API foMax = {0xffffffffL,0x7ffffffeL};
FILEOFFSET EXPORT_API foMin = {0x00000000L,0x80000001L};
FILEOFFSET EXPORT_API foInvalid = {0xffffffffL, 0xffffffffL};

/*****************************************************************************
 *                                                                            *
 *                               Defines                                      *
 *                                                                            *
 *****************************************************************************/


/*****************************************************************************
 *                                                                            *
 *                               Prototypes                                   *
 *                                                                            *
 *****************************************************************************/

/***************************************************************************
 *                                                                           *
 *                         Private Functions                                 *
 *                                                                           *
 ***************************************************************************/

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET PASCAL FAR | MakeFo |
 *		Make a file offset from two dwords
 *
 *  @parm	DWORD | dwLo |
 *		Low order dword
 *
 *  @parm	DWORD | dwHi |
 *		High order dword
 *
 *	@rdesc	Returns a double DWORD file offset struct
 *
 *	@comm
 *		Use this function to build file offsets that can be passed to other
 *		functions that need them as input.
 *
 ***************************************************************************/
 
FILEOFFSET	PASCAL FAR EXPORT_API MakeFo(DWORD dwLo, DWORD dwHi)
{
 	FILEOFFSET fo;
	fo.dwOffset=dwLo;
	fo.dwHigh=dwHi;
	return fo;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	FILEOFFSET PASCAL FAR | FoFromSz |
 *		Convert a variable byte value to a FILEOFFSET
 *
 *  @parm	LPBYTE | szBytes |
 *		Byte array containing variable byte length
 *
 *	@rdesc	Returns a double DWORD file offset struct from data of the form:
 *		If High Bit Set, more bits follow (up to 9 bytes for 64 bits).
 *		max for: 	1 byte  = 127
 *					2 bytes	= 16384
 *					3 bytes = 2 M
 *					4 bytes = 268 M
 *					5 bytes = 34 G
 *					6 bytes = 4 T
 *					7 bytes = 562 T
 *					8 bytes = 72 Q
 *					9 bytes = 9223 Q (virtually infinite)
 *					
 *	@comm
 *		Only a maximum of 9 bytes will be read from szBytes in the worst
 *		case (or likely if szBytes points to invalid data).  Use <f LenSzFo>
 *		to get the length of a byte array for advancing to the next encoded
 *		offset for example.
 *
 ***************************************************************************/

FILEOFFSET PASCAL FAR EXPORT_API FoFromSz(LPBYTE sz)
{
 	register DWORD offset;
	register FILEOFFSET fo;
 	register DWORD high=0L;

	for (;;)
	{
		offset=*sz;				// Insert Segment A
		if (!(*(sz++)&0x80))
			break;
	 	offset&=0x7f;
		offset|=((DWORD)(*sz))<<7;		// Insert Segment B
		if (!(*(sz++)&0x80))
			break;
	 	offset&=0x3fff;
		offset|=((DWORD)(*sz))<<14;		// Insert Segment C
		if (!(*(sz++)&0x80))
			break;
	 	offset&=0x1fffff;
		offset|=(((DWORD)*sz))<<21;		// Insert Segment D
		if (!(*(sz++)&0x80))
			break;
	 	offset&=0xfffffff;
		offset|=((DWORD)(*sz))<<28;		// Insert Segment E
		high|=(*sz)>>4;
		if (!(*(sz++)&0x80))
			break;
	 	high&=0x7;
		high|=(((DWORD)*sz))<<3;			// Insert Segment F;
		if (!(*(sz++)&0x80))
			break;
	 	high&=0x3ff;
		high|=((DWORD)(*sz))<<10;		// Insert Segment G
		if (!(*(sz++)&0x80))
			break;
		high&=0x1ffff;
		high|=((DWORD)(*sz))<<17;		// Insert Segment H
		if (!(*(sz++)&0x80))
			break;
	 	high&=0xffffff;
		high|=((DWORD)(*sz))<<24;		// Segment I
		break;
	}

	fo.dwOffset=offset;
	fo.dwHigh=high;
	
	return fo;
}


/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	WORD PASCAL FAR | FoToSz |
 *		Convert a file offset to a string
 *
 *  @parm	FILEOFFSET | fo |
 *		File offset to convert to string representation
 *
 *  @parm	LPBYTE | szBytes |
 *		Byte array to contain variable byte address
 *
 *	@rdesc	Returns number of bytes copied.
 *		See <f LcbFromSz> for description of byte array format
 *
 *	@comm
 *		The byte array should contain at least 9 valid bytes should be allocated, 
 *		since at most the 9 bytes starting at <p szBytes> may be filled in. 
 *
 ***************************************************************************/

WORD PASCAL FAR EXPORT_API FoToSz(FILEOFFSET fo, LPBYTE sz)
{
	register DWORD offset = fo.dwOffset;
	register DWORD high	 = fo.dwHigh;
	WORD wSize=1;
	
	for (;;)
	{
		*sz=(BYTE)(offset&0x7f);		// A byte
		offset>>=7;
		if (!(offset|high))
			break;
	 	wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)(offset&0x7f);	// B byte
		offset>>=7;
		if (!(offset|high))
			break;
	 	wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)(offset&0x7f);	// C byte
		offset>>=7;
		if (!(offset|high))
			break;
		wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)(offset&0x7f);	// D byte
		offset>>=7;
		if (!(offset|high))
			break;
	 	wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)(offset&0x0f);	// E byte
		*sz|=(BYTE)((high&0x07)<<4);
		high>>=3;
		if (!high)
			break;
	 	wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)(high&0x7f);	// F Byte
		high>>=7;
		if (!high)
			break;
	 	wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)(high&0x7f);	// G Byte
		high>>=7;
		if (!high)
			break;
		wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)(high&0x7f);	// H Byte
		high>>=7;
		if (!high)
			break;
	 	wSize++;
		*(sz++)|=0x80;
		*sz=(BYTE)high;		// I byte
		break;
	}

	return wSize;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	WORD PASCAL FAR | LenSzFo |
 *		Find number of bytes comprising this byte-array address code
 *
 *  @parm	LPBYTE | szBytes |
 *		Byte array containing variable byte address
 *
 *	@rdesc	Returns number of bytes in byte-array for this address
 *
 ***************************************************************************/

WORD PASCAL FAR EXPORT_API LenSzFo(LPBYTE sz)
{
	register WORD wLen=1;
	while ((*(sz++))&0x80)
		wLen++;
	
	return wLen;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	FILEOFFSET FAR | FoAddDw |
 *		Add a dword to a file offset
 *
 *  @parm	FILEOFFSET | fo |
 *		Byte array containing variable byte length
 *
 *	@parm	DWORD | dwAdd |
 *		Add this amount to the file offset
 *
 *	@rdesc	Returns the sum of the file offset fo and dwAdd as a FILEOFFSET.
 *		Since only a dword is added, the dwHigh dword will never increase
 *		more than one.
 *
 *
 ***************************************************************************/

FILEOFFSET FAR EXPORT_API FoAddDw(FILEOFFSET fo, DWORD dwAdd)
{
	register FILEOFFSET foSum = fo;

	foSum.dwOffset+=dwAdd;
	
	if (foSum.dwOffset<fo.dwOffset) 	
		foSum.dwHigh++;			
	
	return foSum;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET FAR | FoAddFo |
 *		Add a file offset to another file offset
 *
 *  @parm	FILEOFFSET | fo1 |
 *		File Offset 1
 *
 *	@parm	FILEOFFSET | fo2 |
 *		File Offset 2
 *
 *	@rdesc	Returns the sum fo1 + fo2 as a FILEOFFSET.
 *
 *
 ***************************************************************************/

FILEOFFSET FAR EXPORT_API FoAddFo(FILEOFFSET fo1, FILEOFFSET fo2)
{
	FILEOFFSET foSum;
	
	foSum.dwOffset=fo1.dwOffset+fo2.dwOffset;
	foSum.dwHigh=fo2.dwHigh+fo1.dwHigh+((foSum.dwOffset<fo1.dwOffset)?1:0);
	
	return foSum;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET FAR | FoSubFo |
 *		Subtract file offsets, return a file offset
 *
 *  @parm	FILEOFFSET | fo1 |
 *		File Offset 1
 *
 *	@parm	FILEOFFSET | fo2 |
 *		File Offset 2
 *
 *	@rdesc	Returns fo1 - fo2 as a FILEOFFSET.
 *
 *  @comm	A Negative result will have 0xffffffff for the the dwHigh
 *		member, and the dwOffset should be interpreted as a signed
 *		value.
 *
 ***************************************************************************/

FILEOFFSET FAR EXPORT_API FoSubFo(FILEOFFSET fo1, FILEOFFSET fo2)
{
	FILEOFFSET foSum;
	
	foSum.dwOffset=fo1.dwOffset-fo2.dwOffset;
	foSum.dwHigh=fo1.dwHigh-fo2.dwHigh-((fo1.dwOffset<fo2.dwOffset)?1:0);

	return foSum;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET FAR | FoMultFo |
 *		Multiply two offset values
 *
 *  @parm	FILEOFFSET | fo1 |
 *		File Offset 1
 *
 *	@parm	FILEOFFSET | fo2 |
 *		File Offset 2
 *
 *	@rdesc	Returns fo1 * fo2 as a FILEOFFSET.
 *
 *  @comm	If both fo1 and fo2 are less than 0xffffffff, then the result
 *		is guaranteed to fit in a FILEOFFSET, otherwise, the result may
 *		not be correct if overflow occurs.
 *
 ***************************************************************************/

FILEOFFSET FAR EXPORT_API FoMultFo(FILEOFFSET fo1, FILEOFFSET fo2)
{
 	DWORD dwTop0,dwTop1,dwTop2,dwTop3;
	DWORD dwBot0,dwBot1,dwBot2,dwBot3;
	DWORD dwRes0=0;
	DWORD dwRes1=0;
	DWORD dwRes2=0;
	DWORD dwRes3=0;
	DWORD dwTemp;
	FILEOFFSET foResult;

	// Get terms
	dwTop0=(DWORD)HIWORD(fo1.dwHigh);
	dwTop1=(DWORD)LOWORD(fo1.dwHigh);
	dwTop2=(DWORD)HIWORD(fo1.dwOffset);
	dwTop3=(DWORD)LOWORD(fo1.dwOffset);

	dwBot0=(DWORD)HIWORD(fo2.dwHigh);
	dwBot1=(DWORD)LOWORD(fo2.dwHigh);
	dwBot2=(DWORD)HIWORD(fo2.dwOffset);
	dwBot3=(DWORD)LOWORD(fo2.dwOffset);

	// Do term by term multiplication and accumulate column results
	dwTemp=dwTop3*dwBot3;
	dwRes3+=LOWORD(dwTemp);
	dwRes2+=HIWORD(dwTemp);

	dwTemp=dwTop2*dwBot3;
	dwRes2+=LOWORD(dwTemp);
	dwRes1+=HIWORD(dwTemp);

	dwTemp=dwTop1*dwBot3;
	dwRes1+=LOWORD(dwTemp);
	dwRes0+=HIWORD(dwTemp);

	dwTemp=dwTop0*dwBot3;
	dwRes0+=LOWORD(dwTemp);
	
	
	dwTemp=dwTop3*dwBot2;
	dwRes2+=LOWORD(dwTemp);
	dwRes1+=HIWORD(dwTemp);

	dwTemp=dwTop2*dwBot2;
	dwRes1+=LOWORD(dwTemp);
	dwRes0+=HIWORD(dwTemp);

	dwTemp=dwTop1*dwBot2;
	dwRes0+=LOWORD(dwTemp);
	

	dwTemp=dwTop3*dwBot1;
	dwRes1+=LOWORD(dwTemp);
	dwRes0+=HIWORD(dwTemp);

	dwTemp=dwTop2*dwBot1;
	dwRes0+=LOWORD(dwTemp);
	

	dwTemp=dwTop3*dwBot0;
	dwRes0+=LOWORD(dwTemp);
	
	// Do the carry
	dwRes2+=HIWORD(dwRes3);
	dwRes1+=HIWORD(dwRes2);
	dwRes0+=HIWORD(dwRes1);
	
	// Make the result
	foResult.dwOffset=MAKELONG((dwRes3&0xffff),(dwRes2&0xffff));
	foResult.dwHigh=MAKELONG((dwRes1&0xffff),(dwRes0&0xffff));

	return foResult;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET PASCAL FAR | FoMultFo |
 *		Multiply two offset values
 *
 *  @parm	DWORD | dw1 |
 *		Mutplicand
 *
 *	@parm	FILEOFFSET | dw2 |
 *		Multplier
 *
 *	@rdesc	Returns dw1 * dw2 as a FILEOFFSET.
 *
 ***************************************************************************/

FILEOFFSET 	PASCAL FAR EXPORT_API FoMultDw(DWORD dw1, DWORD dw2)
{
 	DWORD dwTop2,dwTop3;
	DWORD dwBot2,dwBot3;
	DWORD dwRes0=0;
	DWORD dwRes1=0;
	DWORD dwRes2=0;
	DWORD dwRes3=0;
	DWORD dwTemp;
	FILEOFFSET foResult;

	// Get terms
	dwTop2=(DWORD)HIWORD(dw1);
	dwTop3=(DWORD)LOWORD(dw1);

	dwBot2=(DWORD)HIWORD(dw2);
	dwBot3=(DWORD)LOWORD(dw2);

	// Do term by term multiplication and accumulate column results
	dwTemp=dwTop3*dwBot3;
	dwRes3+=LOWORD(dwTemp);
	dwRes2+=HIWORD(dwTemp);

	dwTemp=dwTop2*dwBot3;
	dwRes2+=LOWORD(dwTemp);
	dwRes1+=HIWORD(dwTemp);
	
	dwTemp=dwTop3*dwBot2;
	dwRes2+=LOWORD(dwTemp);
	dwRes1+=HIWORD(dwTemp);

	dwTemp=dwTop2*dwBot2;
	dwRes1+=LOWORD(dwTemp);
	dwRes0+=HIWORD(dwTemp);
	
	// Do the carry
	dwRes2+=HIWORD(dwRes3);
	dwRes1+=HIWORD(dwRes2);
	dwRes0+=HIWORD(dwRes1);
	
	// Make the result
	foResult.dwOffset=MAKELONG((dwRes3&0xffff),(dwRes2&0xffff));
	foResult.dwHigh=MAKELONG((dwRes1&0xffff),(dwRes0&0xffff));

	return foResult;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	DWORD PASCAL FAR | DwSubFo |
 *		Return the difference of two file offsets
 *
 *  @parm	FILEOFFSET | foA |
 *		File offset
 *
 *	@parm	FILEOFFSET | foB |
 *		File offset to subtract from foA
 *
 *	@rdesc	Returns the difference foA - foB as a DWORD.  Result undefined
 *		for differences greater than the dword size of a long.
 *
 *	@comm
 *		If a negative value is expected, the returned dword may be interpreted
 *		as a signed value. 
 *
 ***************************************************************************/

DWORD FAR EXPORT_API DwSubFo(FILEOFFSET foA, FILEOFFSET foB)
{
 	// When foA.dwHigh = foB.dwHigh+1, it still works.
 	return foA.dwOffset-foB.dwOffset;	
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET PASCAL FAR | FoIsNil |
 *		Check whether the file offset is Nil.  Nil is defined to be {0L,0L}.
 *
 *  @parm	FILEOFFSET | fo |
 *		File offset to check
 *
 *	@rdesc	Returns TRUE if the file offset is equivalent to Nil.
 *
 ***************************************************************************/

BOOL PASCAL FAR EXPORT_API FoIsNil(FILEOFFSET fo)
{
 	return ((fo.dwOffset==foNil.dwOffset) && (fo.dwHigh==foNil.dwHigh))?TRUE:FALSE;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET PASCAL FAR | FoEquals |
 *		Compare any two file offsets for equality
 *
 *  @parm	FILEOFFSET | fo1 |
 *		File offset to check
 *
 *  @parm	FILEOFFSET | fo2 |
 *		File offset to check against
 *
 *	@rdesc	Returns TRUE if fo1 == fo2
 *
 ***************************************************************************/

BOOL PASCAL FAR EXPORT_API FoEquals(FILEOFFSET fo1, FILEOFFSET fo2)
{
 	return ((fo1.dwOffset==fo2.dwOffset) && (fo1.dwHigh==fo2.dwHigh))?TRUE:FALSE;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET PASCAL FAR | FoCompare |
 *		Compare any two file offsets
 *
 *  @parm	FILEOFFSET | fo1 |
 *		File offset to check
 *
 *  @parm	FILEOFFSET | fo2 |
 *		File offset to check against
 *
 *	@rdesc	Returns	negative if fo1 <lt> fo2, 0 if fo1 == fo2, positive if 
 *		fo1 > fo2
 *
 ***************************************************************************/

short int PASCAL FAR EXPORT_API FoCompare(FILEOFFSET foLeft, FILEOFFSET foRight)
{
 	if (foLeft.dwHigh==foRight.dwHigh)
	{	
		if (foLeft.dwOffset<foRight.dwOffset)
			return -1;
		else if (foLeft.dwOffset>foRight.dwOffset)
			return 1;
		else
			return 0;
	}
	else if ((long)foLeft.dwHigh<(long)foRight.dwHigh)
		return -1;
	else
		return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\freelist.c ===
/*****************************************************************************
 *                                                                            *
 *  FREELIST.C                                                                 *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1995.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Free List manager functions.  List can handle 8-byte file offsets and 	  *
 *  8-byte file lengths														  *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  davej                                                *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Created 07/17/95 - davej
 *          3/05/97    erinfox Change errors to HRESULTS
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;    /* For error report */

#include <mvopsys.h>
#include <orkin.h>
#include <misc.h>
#include <mem.h>
#include <freelist.h>

/*****************************************************************************
 *                                                                            *
 *                               Defines                                      *
 *                                                                            *
 *****************************************************************************/


/*****************************************************************************
 *                                                                            *
 *                               Prototypes                                   *
 *                                                                            *
 *****************************************************************************/

/***************************************************************************
 *                                                                           *
 *                         Private Functions                                 *
 *                                                                           *
 ***************************************************************************/


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HFREELIST PASCAL FAR | FreeListInit |
 *		Create or read in a free list
 *
 *	@parm	WORD | wMaxBlocks |
 *		Number of free list entries
 *
 *	@parm	PHRESULT | phr |
 *		Error code return if return value is NULL
 *
 *	@rdesc	Returns handle to a FREELIST, otherwise NULL if error.
 *
 ***************************************************************************/

PUBLIC HFREELIST PASCAL FAR EXPORT_API FreeListInit( WORD wMaxBlocks, PHRESULT phr)
{	
	HFREELIST hFreeList = NULL;
	QFREELIST qFreeList = NULL;
	
	if (!wMaxBlocks)
	{
		SetErrCode(phr, E_INVALIDARG);
		return NULL;
	}
	
	if (!(hFreeList=_GLOBALALLOC(GMEM_ZEROINIT| GMEM_MOVEABLE,
		sizeof(FREEITEM)*wMaxBlocks+sizeof(FREELISTHDR))))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		return NULL;
	}

	if (!(qFreeList=_GLOBALLOCK(hFreeList)))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		goto exit1;
	}

	qFreeList->flh.wMaxBlocks=wMaxBlocks;
	
	_GLOBALUNLOCK(hFreeList);

	return hFreeList;

	exit1:
		_GLOBALFREE(hFreeList);
		return NULL;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HFREELIST PASCAL FAR | FreeListInitFromMem |
 *		Initialize a freelist structure from a memory image.  Memory image is
 *		always in Intel byte ordering format.
 *
 *	@parm	LPVOID | lpvMem |
 *		Pointer to memory image of free list
 *
 *	@parm	PHRESULT | phr |
 *		Error code return valid if return value is NULL
 *
 *	@rdesc	Returns handle to a FREELIST, otherwise NULL if error.
 *
 ***************************************************************************/

PUBLIC HFREELIST PASCAL FAR EXPORT_API FreeListInitFromMem( LPVOID lpvMem, PHRESULT phr )
{
 	QFREELIST qFreeListMem;
	QFREELIST qFreeList;
	HFREELIST hFreeList = NULL;
	WORD wMaxBlocks;
	WORD wNumBlocks;
	DWORD dwLostBytes;
	
	if (!lpvMem)
	{
		SetErrCode(phr, E_INVALIDARG);
		return NULL;
	}

	qFreeListMem = (QFREELIST)lpvMem;
	wMaxBlocks = qFreeListMem->flh.wMaxBlocks;
	wNumBlocks = qFreeListMem->flh.wNumBlocks;
	dwLostBytes = qFreeListMem->flh.dwLostBytes;

	// Mac-ify
	wMaxBlocks = SWAPWORD(wMaxBlocks);
	wNumBlocks = SWAPWORD(wNumBlocks);
	dwLostBytes = SWAPLONG(wNumBlocks);
	
	if (! wMaxBlocks )
	{
	 	SetErrCode(phr, E_ASSERT);
		return NULL;
	}
	
	if (!(hFreeList=_GLOBALALLOC(GMEM_ZEROINIT| GMEM_MOVEABLE,
		sizeof(FREEITEM)*wMaxBlocks+sizeof(FREELISTHDR))))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		goto exit0;
	}

	if (!(qFreeList=_GLOBALLOCK(hFreeList)))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		goto exit1;
	}

	QVCOPY( qFreeList, qFreeListMem, sizeof(FREELISTHDR) + wMaxBlocks * sizeof(FREEITEM));

#ifdef _BIG_E	
	{
		QFREEITEM qCurrent = qFreeList->afreeitem;
		WORD wBlock;
	
		qFreeList->flh.wNumBlocks = wNumBlocks;
		qFreeList->flh.wMaxBlocks = wMaxBlocks;
		qFreeList->flh.dwLostBytes = dwLostBytes;

		for (wBlock=0;wBlock<wNumBlocks;wBlock++,qCurrent++)
		{
	 	 	qCurrent->foStart.dwOffset = SWAPLONG(qCurrent->foStart.dwOffset);
			qCurrent->foStart.dwHigh = SWAPLONG(qCurrent->foStart.dwHigh);
			qCurrent->foBlock.dwOffset = SWAPLONG(qCurrent->foBlock.dwOffset);
			qCurrent->foBlock.dwHigh = SWAPLONG(qCurrent->foBlock.dwHigh);
		}
	}
#endif // _BIG_E
	
	_GLOBALUNLOCK(hFreeList);

	return hFreeList;

	exit1:
		_GLOBALFREE(hFreeList);
	exit0:
		return NULL;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HFREELIST PASCAL FAR | FreeListRealloc |
 *		Realloc a freelist structure.  Memory image is
 *		always in Intel byte ordering format.
 *
 *	@parm	HFREELIST | hOldFreeList |
 *		Header to the old FreeList.
 *
 *	@parm	WORD | wMaxBlocks |
 *		New number of blocks.
 *
 *	@parm	PHRESULT | phr |
 *		Error code return valid if return value is NULL
 *
 *	@rdesc	Returns handle to a FREELIST, otherwise NULL if error.
 *
 ***************************************************************************/

PUBLIC HFREELIST PASCAL FAR EXPORT_API FreeListRealloc( HFREELIST hOldFreeList, WORD wNewMaxBlocks, PHRESULT phr )
{
 	QFREELIST qFreeListMem;
	QFREELIST qFreeList;
	HFREELIST hFreeList = NULL;
	WORD wMaxBlocks;
	
	if (!hOldFreeList)
	{
		SetErrCode(phr, E_INVALIDARG);
		return NULL;
	}

	if (!wNewMaxBlocks)
	{
		SetErrCode(phr, E_INVALIDARG);
		return NULL;
	}

	if (!(qFreeListMem=_GLOBALLOCK(hOldFreeList)))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		goto exit00;
	}

	wMaxBlocks = qFreeListMem->flh.wMaxBlocks;

	if (! wMaxBlocks )
	{
	 	SetErrCode(phr, E_ASSERT);
		goto exit0;
	}

    // Allocating new Freelist	
	if (!(hFreeList=_GLOBALALLOC(DLLGMEM_ZEROINIT,
		sizeof(FREEITEM)*wNewMaxBlocks+sizeof(FREELISTHDR))))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		goto exit0;
	}

	if (!(qFreeList=_GLOBALLOCK(hFreeList)))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		goto exit1;
	}

    // Copying old one on new...
	QVCOPY( qFreeList, qFreeListMem, sizeof(FREELISTHDR) + wMaxBlocks * sizeof(FREEITEM));

    // ...Except the number of wMaxBlocks!
    qFreeList->flh.wMaxBlocks = wNewMaxBlocks;

	_GLOBALUNLOCK(hFreeList);
    _GLOBALUNLOCK(hOldFreeList);
    FreeListDestroy(hOldFreeList); // Bye bye, old one!

	return hFreeList;

	exit1:
		_GLOBALFREE(hFreeList);
	exit0:
        _GLOBALUNLOCK(hOldFreeList);
    exit00:
		return NULL;
}

/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	LONG PASCAL FAR | FreeListBlockUsed |
 *		Returns the number of blocks used by the free list.
 *
 *	@parm	HFREELIST | hFreeList |
 *		List to get size of
 *
 *	@parm	PHRESULT | phr |
 *		Error return valid if return value is zero.
 *
 *	@rdesc	Number of bytes used by free list
 *
 ***************************************************************************/

PUBLIC LONG PASCAL FAR EXPORT_API FreeListBlockUsed( HFREELIST hFreeList, PHRESULT phr )
{
	QFREELIST qFreeList;
	LONG lcbSize=0L;
	WORD wNumBlocks=0L;
	
 	if (!hFreeList)
	{
		SetErrCode(phr, E_INVALIDARG);
		return 0L;
	}

	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
	{	SetErrCode(phr,E_OUTOFMEMORY);
		goto exit0;
	}
	
	lcbSize=qFreeList->flh.wMaxBlocks;

	_GLOBALUNLOCK(hFreeList);
	
	exit0:
		return lcbSize;
}


/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | FreeListGetMem |
 *		Fill memory at lpvMem with freelist data.  Call FreeListSize first
 *		to make sure the memory is large enough.  Memory image will always
 *		be in Intel byte ordering format.
 *
 *	@parm	HFREELIST | hFreeList |
 *		List to retrieve
 *
 *	@parm	LPVOID | lpvMem |
 *		Pointer to memory to contain free list data
 *
 *	@rdesc	S_OK or other error
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API FreeListGetMem( HFREELIST hFreeList, LPVOID lpvMem )
{
 	QFREELIST qFreeListMem;
	QFREELIST qFreeList;
	WORD wMaxBlocks;
	WORD wNumBlocks;
	DWORD dwLostBytes;
	HRESULT rc = S_OK;
	
	if ((!lpvMem) || (!hFreeList))
	{
		return E_INVALIDARG;
	}
	
	qFreeListMem = (QFREELIST)lpvMem;
	
	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
	{	rc=E_OUTOFMEMORY;
		goto exit0;
	}
	
	wMaxBlocks=qFreeList->flh.wMaxBlocks;
	wNumBlocks=qFreeList->flh.wNumBlocks;
	dwLostBytes=qFreeList->flh.dwLostBytes;
	
	QVCOPY( qFreeListMem, qFreeList, sizeof(FREELISTHDR) + wMaxBlocks * sizeof(FREEITEM));

#ifdef _BIG_E	
	{
		QFREEITEM qCurrent = qFreeListMem->afreeitem;
		WORD wBlock;
	
		qFreeListMem->flh.wNumBlocks = SWAPWORD( qFreeList->flh.wNumBlocks );
		qFreeListMem->flh.wMaxBlocks = SWAPWORD( qFreeList->flh.wMaxBlocks );
		qFreeListMem->flh.dwLostBytes = SWAPLONG( qFreeList->flh.dwLostBytes );
		

		for (wBlock=0;wBlock<wNumBlocks;wBlock++,qCurrent++)
		{
	 	 	qCurrent->foStart.dwOffset = SWAPLONG(qCurrent->foStart.dwOffset);
			qCurrent->foStart.dwHigh = SWAPLONG(qCurrent->foStart.dwHigh);
			qCurrent->foBlock.dwOffset = SWAPLONG(qCurrent->foBlock.dwOffset);
			qCurrent->foBlock.dwHigh = SWAPLONG(qCurrent->foBlock.dwHigh);
		}
	}
#endif // _BIG_E
	
	_GLOBALUNLOCK(hFreeList);

	exit0:
		return rc;
 	
}

/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	HRESULT PASCAL FAR | FreeListDestroy |
 *		Remove all memory associated with the free list
 *
 *	@parm	HFREELIST | hFreeList |
 *		List to destroy
 *
 *	@rdesc	S_OK or E_INVALIDARG
 *
 *	@comm
 *		The handle <p hFreeList> is no longer valid after this call.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API FreeListDestroy( HFREELIST hFreeList )
{
	if (!hFreeList)
		return E_INVALIDARG;

	_GLOBALFREE(hFreeList);

	return S_OK;
}

/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	LONG PASCAL FAR | FreeListSize |
 *		Returns the number of bytes used by the free list.
 *
 *	@parm	HFREELIST | hFreeList |
 *		List to get size of
 *
 *	@parm	PHRESULT | phr |
 *		Error return valid if return value is zero.
 *
 *	@rdesc	Number of bytes used by free list
 *
 ***************************************************************************/

PUBLIC LONG PASCAL FAR EXPORT_API FreeListSize( HFREELIST hFreeList, PHRESULT phr )
{
	QFREELIST qFreeList;
	LONG lcbSize=0L;
	WORD wNumBlocks=0L;
	
 	if (!hFreeList)
	{
		SetErrCode(phr, E_INVALIDARG);
		return 0L;
	}

	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
	{	SetErrCode(phr,E_OUTOFMEMORY);
		goto exit0;
	}
	
	lcbSize=sizeof(FREELISTHDR)+qFreeList->flh.wMaxBlocks*sizeof(FREEITEM);

	_GLOBALUNLOCK(hFreeList);
	
	exit0:
		return lcbSize;
}

/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	LONG PASCAL FAR | FreeListSize |
 *		Returns the number of bytes used by the memory image of a free list.
 *
 *	@parm	LPVOID | lpvMem |
 *		Memory image of list to get size of
 *
 *	@parm	PHRESULT | phr |
 *		Error return valid if return value is zero.
 *
 *	@rdesc	Number of bytes used in free list image
 *
 ***************************************************************************/

PUBLIC LONG PASCAL FAR EXPORT_API FreeListSizeFromMem( LPVOID lpvMem, PHRESULT phr )
{
	QFREELIST qFreeList;
	LONG lcbSize=0L;
	WORD wNumBlocks=0L;
	
	if (!lpvMem)
	{
	 	SetErrCode(phr,E_INVALIDARG);
		return 0L;
	}

	qFreeList = (QFREELIST)lpvMem;
	
	wNumBlocks = qFreeList->flh.wNumBlocks;
	lcbSize=sizeof(FREELISTHDR)+wNumBlocks*sizeof(FREEITEM);

	return lcbSize;
}


/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	HRESULT FAR | FreeListAdd |
 *		Add a block to the free list.  The free list is maintained in order
 *		by block starting address.  Blocks are merged if adjacent.
 *
 *	@parm	HFREELIST | hFreeList |
 *		List to add entry to
 *
 *	@parm	FILEOFFSET | foStart |
 *		Starting address of free block to add
 *
 *	@parm	FILEOFFSET | foBlock |
 *		Size of block to add
 *
 *	@rdesc	S_OK, E_OUTOFMEMORY or ?
 *
 *	@comm	If all entries in the free list are filled, then the block
 *		with the smallest size is thrown out.  This function is the heart
 *		of the FreeList object.
 *
 ***************************************************************************/

PUBLIC HRESULT FAR EXPORT_API FreeListAdd(HFREELIST hFreeList, FILEOFFSET foStart, FILEOFFSET foBlock)
{
	QFREELIST 	qFreeList;
	WORD 		wNumBlocks;
	HRESULT 			rc = S_OK;
	QFREEITEM	qPrevious = NULL;
	QFREEITEM 	qCurrent;
	BOOL 		bInserted = FALSE;
	BOOL		bFullList = FALSE;
	short		iLo, iHi, iMid, iSpan, iFound;
	
	if (!hFreeList)
		return E_INVALIDARG;
	
	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
		return E_OUTOFMEMORY;
		
	wNumBlocks=qFreeList->flh.wNumBlocks;
	
	bFullList=(wNumBlocks==qFreeList->flh.wMaxBlocks);
	
	if (wNumBlocks)
	{
		iLo=0;
		iHi=wNumBlocks-1;
		iSpan=iHi-iLo+1;
		iFound=-1;
		
		while (iSpan>0)
		{	
			iMid=(iLo+iHi)/2;
			//if (lifStart > qFreeList->afreeitem[iMid].lifStart)
			if (FoCompare(foStart,qFreeList->afreeitem[iMid].foStart)>0)
			{	
				if (iSpan==1)
				{	
					iFound=iLo;
					break;
				}
				iLo=min(iHi,iMid+1);
			}
			else
			{	if (iSpan==1)
				{	
					iFound=iLo-1;
					break;
				}
			 	iHi=max(iLo,iMid-1);
			}
		
			iSpan=iHi-iLo+1;		
		}

		// Number of blocks _after_ current block
		wNumBlocks=qFreeList->flh.wNumBlocks-iFound-1;

		// wFound == -1, insert at beginning,
		// else insert _after_ wFound
		qCurrent=qFreeList->afreeitem+(iFound+1);
		if (iFound!=-1)
			qPrevious=qCurrent-1;
			
		if ((!qPrevious) || 
				(!FoEquals(FoAddFo(qPrevious->foStart,qPrevious->foBlock),foStart)))
		{	// Cannot merge with previous
			//if ((wNumBlocks) && (qCurrent->foStart!=foStart+lcbBlock))
			if ((!wNumBlocks) || (!FoEquals(qCurrent->foStart,FoAddFo(foStart,foBlock))))
			{	// Cannot merge with next, insert new item

				if (bFullList)
				{	// Remove smallest item
					FILEOFFSET foSmallest = foMax;
					WORD wSmallestBlock = (WORD)-1;
					QFREEITEM qTemp = qFreeList->afreeitem;
					WORD wBlockTemp = 0;
					
					// First we must find the smallest block
					for (wBlockTemp=0;wBlockTemp < qFreeList->flh.wNumBlocks;wBlockTemp++)
					{	
						if (FoCompare(qTemp->foBlock,foSmallest)<0)
						{	
							foSmallest=qTemp->foBlock;
							wSmallestBlock=wBlockTemp;
						}
						qTemp++;
					}

					// If our new block is smaller than the smallest, skip adding it in at all
					if (FoCompare(foBlock,foSmallest)<=0)
					{
						goto exit1;
					}

					qFreeList->flh.dwLostBytes+=foSmallest.dwOffset;

					// Remove smallest block, leaving hole at end of list
					if (wSmallestBlock!=qFreeList->flh.wMaxBlocks-1)
					{
						QVCOPY(qFreeList->afreeitem+wSmallestBlock, 
							qFreeList->afreeitem+wSmallestBlock+1, 
							sizeof(FREEITEM)*(qFreeList->flh.wMaxBlocks-wSmallestBlock-1));						
					}
					qFreeList->flh.wNumBlocks--;
					wNumBlocks--;
					// If the block found is before current, current must slide back one
					if ((int)wSmallestBlock <= iFound) 
					{	qCurrent=qPrevious;
						wNumBlocks++;
					}					
				}
			
				// Insert Item
				if (wNumBlocks)
					QVCOPY(qCurrent+1, qCurrent, sizeof(FREEITEM)*wNumBlocks);
					
				qCurrent->foStart=foStart;
				qCurrent->foBlock=foBlock;
				qFreeList->flh.wNumBlocks++;
			}
			else
			{	// Merge with next
				qCurrent->foStart=foStart;
				qCurrent->foBlock=FoAddFo(qCurrent->foBlock,foBlock);
			}
		}
		else
		{	// Merge with previous
			qPrevious->foBlock=FoAddFo(qPrevious->foBlock,foBlock);
			
			if (FoEquals(FoAddFo(qPrevious->foStart,qPrevious->foBlock),qCurrent->foStart))
			{	
				// it fills a hole, merge with next
				qPrevious->foBlock=FoAddFo(qPrevious->foBlock,qCurrent->foBlock);

				// Scoot all next blocks back by one if any
				if (wNumBlocks)
				{
					QVCOPY(qCurrent, qCurrent+1, sizeof(FREEITEM)*wNumBlocks);
					qFreeList->flh.wNumBlocks--;
					// wNumBlocks--;  // not really needed, we break out
				}
			}
		}
	}
	else // first one
	{
		qCurrent=qFreeList->afreeitem;
		qCurrent->foStart=foStart;
		qCurrent->foBlock=foBlock;
		qFreeList->flh.wNumBlocks++;
	}

	exit1:
		_GLOBALUNLOCK(hFreeList);

    return S_OK;
}


/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	FILEOFFSET PASCAL FAR | FreeListGetBestFit |
 *		Gives the location of the block with best fit, and removes that area
 *		from the free list.
 *
 *	@parm	HFREELIST | hFreeList |
 *		Free List to pull block from
 *
 *	@parm	FILEOFFSET | foBlockDesired |
 *		Size of block to retrieve
 *
 *	@parm	PHRESULT | phr |
 *		Error return valid if return value is foNil
 *
 *	@rdesc	Location of block, or foNil if error
 *
 ***************************************************************************/

PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FreeListGetBestFit(HFREELIST hFreeList, FILEOFFSET foBlockDesired, PHRESULT phr)
{
	QFREELIST 	qFreeList;
	FILEOFFSET 	foStart=foNil;
	WORD 		wNumBlocks;
	WORD		wBlock;
	WORD		wBestBlock=(WORD)-1;
	FILEOFFSET	foMinLeftOver = foMax;
	QFREEITEM 	qCurrent;
	QFREEITEM	qBestBlock;
	
	if (!hFreeList)
	{
	 	SetErrCode(phr,E_INVALIDARG);
		goto exit0;
	}
	
	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
	{	SetErrCode(phr,E_OUTOFMEMORY);
		goto exit0;
	}
	
	wNumBlocks=qFreeList->flh.wNumBlocks;
	qCurrent=qFreeList->afreeitem;
	
	for (wBlock=0;wBlock<wNumBlocks;wBlock++)
	{
		FILEOFFSET foDiff = FoSubFo(qCurrent->foBlock,foBlockDesired);
		if ((FoCompare(foDiff,foNil)>=0) && (FoCompare(foDiff,foMinLeftOver)<0))
		{
		 	foMinLeftOver=foDiff;	// if zero, break
			wBestBlock=wBlock;
			qBestBlock=qCurrent;
		}
		qCurrent++;
	}

	if (wBestBlock!=(WORD)-1)
	{
	 	foStart=qBestBlock->foStart;
		qBestBlock->foStart=FoAddFo(qBestBlock->foStart,foBlockDesired);
		qBestBlock->foBlock=FoSubFo(qBestBlock->foBlock,foBlockDesired);
		if (phr)
			*phr=S_OK;
		
		if (FoIsNil(qBestBlock->foBlock))
		{
			WORD wBlocksFollowing = wNumBlocks-wBestBlock-1;
			// Remove block from list
			if (wBlocksFollowing)
				QVCOPY(qBestBlock,qBestBlock+1,sizeof(FREEITEM)*wBlocksFollowing);

			qFreeList->flh.wNumBlocks--;
		}
	}
	else
	{
		if (phr)
			*phr =E_NOTEXIST;	// Normal OK condition, do not use SetErrCode!		
	}

	_GLOBALUNLOCK(hFreeList);
	
	exit0:
		return foStart;
}

/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	FILEOFFSET PASCAL FAR | FreeListGetBlockAt |
 *		If a free block exists at foStart, the size of the block is returned
 *		and is taken out of the free list.
 *
 *	@parm	HFREELIST | hFreeList |
 *		Free List to pull block from
 *
 *	@parm	FILEOFFSET | foStart |
 *		Starting address of block
 *
 *	@parm	PHRESULT | phr |
 *		Error return valid if return value is foNil
 *
 *	@rdesc	Size of block pulled, or foNil if error occurred (E_NOTEXIST mostly)
 *
 *	@comm
 *		Block from foStart of returned length removed from list.
 *
 ***************************************************************************/

PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FreeListGetBlockAt(HFREELIST hFreeList, FILEOFFSET foStart, PHRESULT phr )
{
	QFREELIST 	qFreeList;
	QFREEITEM 	qCurrent;
	FILEOFFSET 	foBlock = foNil;
	WORD 		wNumBlocks;
	short		iLo, iHi, iMid, iSpan, iFound;
	
	if (!hFreeList)
	{	
		SetErrCode(phr,E_INVALIDARG);
		goto exit0;
	}
	
	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
	{	
		SetErrCode(phr,E_OUTOFMEMORY);
		goto exit0;
	}
	
	wNumBlocks=qFreeList->flh.wNumBlocks;
	
	if (wNumBlocks)
	{
		iLo=0;
		iHi=wNumBlocks-1;
		iSpan=iHi-iLo+1;
		iFound=-1;
		
		while (iSpan>0)
		{	
			short iCompare;
			iMid=(iLo+iHi)/2;
			
			iCompare=FoCompare(foStart,qFreeList->afreeitem[iMid].foStart);
			
			if (iCompare>0)
			{	
				if (iSpan==1)
				{	
					iFound=iLo;
					break;
				}
				iLo=min(iHi,iMid+1);
			}
			else if (iCompare<0)
			{	if (iSpan==1)
				{	
					iFound=iLo-1;
					break;
				}
			 	iHi=max(iLo,iMid-1);
			}
			else
			{	
				iFound=iMid;
				break;

			}
		
			iSpan=iHi-iLo+1;		
		}

		if (iFound!=-1)
		{
			qCurrent=qFreeList->afreeitem+iFound;
			
			assert(FoCompare(foStart,qCurrent->foStart)>=0);
			
			if (FoCompare(foStart,FoAddFo(qCurrent->foStart,qCurrent->foBlock))<0)
			{
				// We found a block that can start here!
				// Return length to end of block
				foBlock=FoAddFo(FoSubFo(qCurrent->foStart,foStart),qCurrent->foBlock);
				qCurrent->foBlock=FoSubFo(qCurrent->foBlock,foBlock);

				// phr should already be set to this before function is called
				// SetErrCode(phr,S_OK);
		
				if (FoIsNil(qCurrent->foBlock))
				{
					// Grabbed entire block, so remove it from list
					WORD wBlocksFollowing = wNumBlocks-iFound-1;
					if (wBlocksFollowing)
						QVCOPY(qCurrent,qCurrent+1,sizeof(FREEITEM)*wBlocksFollowing);

					qFreeList->flh.wNumBlocks--;
				}
			}
			else
			{
			 	SetErrCode(phr,E_NOTEXIST);
			}
		}
		else
		{
		 	SetErrCode(phr,E_NOTEXIST);
		}
	}

	_GLOBALUNLOCK(hFreeList);
	
	exit0:
		return foBlock;
}

/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	HRESULT PASCAL FAR | FreeListGetLastBlock |
 *		If any blocks are in the list, return the offset and size of the
 *		last block in the list. 
 *
 *	@parm	HFREELIST | hFreeList |
 *		Free List to pull block from
 *
 *	@parm	FILEOFFSET * | pfoStart |
 *		Starting address of block
 *
 *	@parm	FILEOFFSET * | pfoSize |
 *		Size of last block
 *
 *	@parm	FILEOFFSET * | foEof |
 *		End of valid file that free list is representing.  The last block must
 *		end at or past the end of file to be returned (otherwise it isn't really
 *		the last in the structure being represented, as there will be data after
 *		the last block...
 *
 *	@rdesc	S_OK if last block exists, else E_NOTEXIST
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API FreeListGetLastBlock(HFREELIST hFreeList,
	FILEOFFSET * pfoStart, FILEOFFSET * pfoSize, FILEOFFSET foEof)
{
	QFREELIST 	qFreeList;
	QFREEITEM 	qCurrent;
	WORD 		wNumBlocks;
	HRESULT 		errb;
	
	errb=S_OK;

	if (!hFreeList)
	{	
		SetErrCode(&errb,E_INVALIDARG);
		goto exit0;
	}
	
	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
	{	
		SetErrCode(&errb,E_OUTOFMEMORY);
		goto exit0;
	}
	
	wNumBlocks=qFreeList->flh.wNumBlocks;
	
	if (wNumBlocks)
	{	
		qCurrent=qFreeList->afreeitem+(wNumBlocks-1);

		if (FoCompare(FoAddFo(qCurrent->foStart,qCurrent->foBlock),foEof) >= 0)
		{
			*pfoStart=qCurrent->foStart;
			*pfoSize=qCurrent->foBlock;
			// Always Grabs entire block, so remove it from list
			qFreeList->flh.wNumBlocks--;
		}
		else
			SetErrCode(&errb,E_NOTEXIST);
	}
	else
		SetErrCode(&errb,E_NOTEXIST);

	_GLOBALUNLOCK(hFreeList);

	exit0:
		return errb;
}

/***************************************************************************
 *
 *	@doc	INTERNAL 
 *
 *	@func	HRESULT PASCAL FAR | FreeListGetStats |
 *		Get stats like number of bytes in free list, and # of bytes lost
 *
 *	@parm	HFREELIST | hFreeList |
 *		Free List to query
 *
 *	@parm	LPFREELISTSTATS | lpStats |
 *		Pointer to status struct:
 *		
 *  @struct FREELISTSTATS | Structure for statistics
 *	@field DWORD | dwBytesInFreeList | Number of bytes being kept track of by
 *		freelist.
 *	@field DWORD | dwBytesLostForever | Number of bytes free list has lost track of
 *	@field DWORD | dwSmallestBlock | Size of smallest block being kept track of.
 *	@field DWORD | dwLargestBlock | Size of largest block being kept track of.
 *	@field WORD  | wNumBlocks | Number of blocks being kept track of.
 *
 *	@rdesc	S_OK if OK, else an error
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API FreeListGetStats(HFREELIST hFreeList, LPFREELISTSTATS lpStats)
{
	QFREELIST 	qFreeList;
	WORD 		wNumBlocks;
	
	if (!hFreeList)
	 	return E_INVALIDARG;
	
	if (!(qFreeList = _GLOBALLOCK(hFreeList)))
		return E_OUTOFMEMORY;
	
	lpStats->wNumBlocks=wNumBlocks=qFreeList->flh.wNumBlocks;
	lpStats->dwBytesLostForever=qFreeList->flh.dwLostBytes;	
	lpStats->dwBytesInFreeList=0L;
	lpStats->dwSmallestBlock=0L;
	lpStats->dwLargestBlock=0L;
	
	if (wNumBlocks)
	{
	 	FILEOFFSET foSmallest = foMax;
		FILEOFFSET foLargest = foMin;
		QFREEITEM qTemp = qFreeList->afreeitem;
		WORD wBlockTemp = 0;
		
		// First we must find the smallest block
		for (wBlockTemp=0;wBlockTemp < wNumBlocks;wBlockTemp++)
		{	
			lpStats->dwBytesInFreeList+=qTemp->foBlock.dwOffset;
			if (FoCompare(qTemp->foBlock,foSmallest)<0)
				foSmallest=qTemp->foBlock;
			if (FoCompare(qTemp->foBlock, foLargest)>0)
				foLargest=qTemp->foBlock;
			qTemp++;
		}
		lpStats->dwSmallestBlock=(DWORD)foSmallest.dwOffset;
		lpStats->dwLargestBlock=(DWORD)foLargest.dwOffset;
	}

	_GLOBALUNLOCK(hFreeList);

	return S_OK;
}

/***************************************************************************
 *
 *	Cute little memory block manager incorporating the free list!
 *  65200 bytes are allocated for use by anyone using NewMemory() and
 *  DisposeMemory().  Mainly this is used by the FM construct for filenames,
 *  avoiding the overhead of GlobalLock and GlobalAlloc.  Of course, this 
 *  could be debatable depending on how fast the Free List works.  The only
 *  linear search in the Free List is finding the best fit block.  Anyway,
 *  feel free to replace the scheme below if something more ingenious comes
 *  to mind.  This is still faster than using GlobalAllocks at least in the
 *  case where FM.C uses this routine.
 *
 ***************************************************************************/
 
#define MEMORYBLOCK_FREEITEMS 1024

typedef struct _memory_block
{
 	HFREELIST hfl;
	LPSTR lpEom;
	LONG lcbFree;
	char lpMemory[1];
} MEMORY_BLOCK;

typedef MEMORY_BLOCK FAR * LPMB;

LONG PASCAL NEAR MemoryBlockStatus(LPMB lpmb)
{
 	assert(lpmb);
 	return lpmb->lcbFree;
}

LPMB PASCAL NEAR MemoryBlockInit( LONG lcbSize )
{
	HANDLE hmb;
	LPMB lpmb;
	HRESULT errb;

	if (!(hmb=_GLOBALALLOC(DLLGMEM_ZEROINIT,sizeof(MEMORY_BLOCK)+lcbSize)))
		return NULL;
	if (!(lpmb=(LPMB)_GLOBALLOCK(hmb)))
	{
	 	_GLOBALFREE(hmb);
		return NULL;
	}
	
	lpmb->lpEom=lpmb->lpMemory;
	lpmb->lcbFree=lcbSize;
	if (!(lpmb->hfl=FreeListInit(MEMORYBLOCK_FREEITEMS,&errb)))
	{
	 	_GLOBALUNLOCK(hmb);
		_GLOBALFREE(hmb);
		return NULL;
	}
	return lpmb;
}

HRESULT PASCAL NEAR MemoryBlockDestroy( LPMB lpmb)
{
 	assert(lpmb);
	
	FreeListDestroy(lpmb->hfl);
	_GLOBALUNLOCK(GlobalHandle(lpmb));
	_GLOBALFREE(GlobalHandle(lpmb));
	
	return S_OK;
}


LPSTR PASCAL NEAR MemoryBlockNew(LPMB lpmb, WORD wcbSize)
{
	HRESULT errb;
	LPSTR lpMemory = NULL;
	FILEOFFSET foFound;
	FILEOFFSET foSize;
	WORD FAR * lpw;	 
	
	foSize.dwOffset=(LONG)wcbSize+sizeof(WORD);
	foSize.dwHigh=0;
	
	errb=S_OK;
	foFound=FreeListGetBestFit(lpmb->hfl,foSize,&errb);
	if (errb==S_OK)
	{
	 	lpw=(WORD FAR *)(lpMemory=lpmb->lpMemory+foFound.dwOffset);
		lpMemory+=sizeof(WORD);
		*(LPUW)lpw = wcbSize;
	}
	else
	{
		if ((LONG)wcbSize+(LONG)sizeof(WORD)>(LONG)lpmb->lcbFree)
			return NULL;
		lpw=(WORD FAR *)(lpMemory=lpmb->lpEom);
		lpMemory+=sizeof(WORD);
		lpmb->lpEom+=(LONG)wcbSize+sizeof(WORD);
		lpmb->lcbFree-=(LONG)wcbSize+sizeof(WORD);
		*(LPUW)lpw = wcbSize;
	} 
	return lpMemory;
}

void PASCAL NEAR MemoryBlockDispose(LPMB lpmb, LPSTR lpMemory)
{
	WORD FAR *lpw;
	FILEOFFSET fo,foLen;
	assert(lpMemory);
	lpw=(WORD FAR *)(lpMemory-sizeof(WORD));

	fo.dwOffset=(DWORD)(lpMemory-sizeof(WORD)-lpmb->lpMemory);
	fo.dwHigh=0;
#ifdef _RISC_PATCH //Misalignment problems
	foLen.dwOffset=(DWORD)(*(LPUW)lpw+2); // Size of lpw, which is hardcoded to two bytes.
#else	
	foLen.dwOffset=(DWORD)*lpw+sizeof(WORD);
#endif
	foLen.dwHigh=0;

	FreeListAdd(lpmb->hfl, fo, foLen);
}


// Global common memory block implementation - for everyone to use!!!

LPMB glpmb=NULL;
LONG gctMemoryBlocks=0;

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	LPSTR PASCAL FAR | NewMemory |
 *		Allocates memory from an always locked memory block
 *
 *	@parm	WORD | wcbSize |
 *		Amount to allocate (total allocations must to surpass 65200 bytes)
 *
 *	@rdesc	Pointer to an allocated and locked memory block, or NULL if error
 *
 *  @comm	The first time <f NewMemory> is called, a block of 65200 byes
 *		is allocated, and this block is only released when the last corresponding
 *		<f DisposeMemory> call is made.  Currently this API is used exclusively
 *		by the FM routines for allocating strings for temporary usage.
 *
 ***************************************************************************/

PUBLIC LPSTR PASCAL FAR EXPORT_API NewMemory( WORD wcbSize )
{
 	LPSTR lpNew=NULL;

 	if (wcbSize)
	{
		if (!glpmb)
		{
			if (!(glpmb=MemoryBlockInit(65200L)))
				return NULL;
		}
		
		if (lpNew=MemoryBlockNew(glpmb, wcbSize))
			gctMemoryBlocks++;			
	}
	return lpNew;
}

/***************************************************************************
 *
 *	@doc	PRIVATE
 *
 *	@func	void PASCAL FAR | DisposeMemory |
 *		Frees the memory previous allocated with NewMemory
 *
 *	@parm	LPSTR | szMemory |
 *		Start of memory block to free (must have been returned 
 *	 	from NewMemory)
 *
 ***************************************************************************/

PUBLIC void PASCAL FAR EXPORT_API DisposeMemory( LPSTR lpMemory)
{
	assert(lpMemory);
	MemoryBlockDispose(glpmb, lpMemory);
	if (!(--gctMemoryBlocks))
	{
		MemoryBlockDestroy(glpmb);
		glpmb=NULL;
	}
}

/***************************************************************************
 *
 *	@doc	INTERNAL API
 *
 *	@func	WORD PASCAL FAR | StatusOfMemory |
 *		Returns the number of bytes left that can be allocated
 *
 *	@rdesc	Number of bytes left in global memory block
 *
 ***************************************************************************/

PUBLIC WORD PASCAL FAR EXPORT_API StatusOfMemory( void )
{	
	if (glpmb)
		return (WORD)MemoryBlockStatus(glpmb);
	else
		return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\ftsdata.c ===
/*************************************************************************
*                                                                        *
*  GLOBDATA.C                                                            *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   This module contains global, read-only data. Those data can be       *
*    shared between different DLL. Isolate them into one module will     *
*    will facilitate their changes if necessary                          *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: BinhN                                                  *
*                                                                        *
**************************************************************************/
#include <mvopsys.h>
#include <mem.h>
#include <_mvutil.h>
#include <mvsearch.h>
#include "common.h"

/* Character mapping table for handling of ligature */

BYTE LigatureTable[] = {
   140,  111,  101,   // OE change to oe
   156,  111,  101,   // oe change to oe
   198,  97,   101,   // AE changed to ae
   230,  97,   101,   // ae changed to ae
   223,  115,  115 ,  // essetz changed to ss 
   0,    0,    0,     // Sentinels
};


CHARMAP DefaultCMap[256] =  {
//
// Character table entries descriptions
//
// CLASS ORDER   NORMAL   WIN     MAC    MAC MAC TO PAD   DESCRIPTION
//                      CLIPBRD        CLIPBRD WIN
   0,      0,      0,      0,      0,      0,   0,   0,   //NO_CLASS          0  
   7,      1,      1,      1,      1,      1,   0,   0,   //CLASS_TYPE        1  
   0,      2,      2,      2,      2,      2,   0,   0,   //NO_CLASS          2  
   0,      3,      3,      3,      3,      3,   0,   0,   //NO_CLASS          3  
   0,      4,      4,      4,      4,      4,   0,   0,   //NO_CLASS          4  
   0,      5,      5,      5,      5,      5,   0,   0,   //NO_CLASS          5  
   0,      6,      6,      6,      6,      6,   0,   0,   //NO_CLASS          6  
   0,      7,      7,      7,      7,      7,   0,   0,   //NO_CLASS          7  
   0,      8,      8,      8,      8,      8,   0,   0,   //NO_CLASS          8  
   0,      9,      9,      9,      9,      9,   0,   0,   //NO_CLASS          9  
   0,     10,     10,     10,     10,     10,   0,   0,   //NO_CLASS         10  
   0,     11,     11,     11,     11,     11,   0,   0,   //NO_CLASS         11  
   0,     12,     12,     12,     12,     12,   0,   0,   //NO_CLASS         12  
   0,     13,     13,     13,     13,     13,   0,   0,   //NO_CLASS         13  
   0,     14,     14,     14,     20,     20,   0,   0,   //NO_CLASS         14  
   0,     15,     15,     15,     15,     15,   0,   0,   //NO_CLASS         15  
   0,     16,     16,     16,     16,     16,   0,   0,   //NO_CLASS         16  
   0,     17,     17,     17,     17,     17,   0,   0,   //NO_CLASS         17  
   0,     18,     18,     18,     18,     18,   0,   0,   //NO_CLASS         18  
   0,     19,     19,     19,     19,     19,   0,   0,   //NO_CLASS         19  
   0,     32,     20,     20,     20,     20,   0,   0,   //NO_CLASS         20  
   0,     21,     21,     21,     21,     21,   0,   0,   //NO_CLASS         21  
   0,     22,     22,     22,     22,     22,   0,   0,   //NO_CLASS         22  
   0,     23,     23,     23,     23,     23,   0,   0,   //NO_CLASS         23  
   0,     24,     24,     24,     24,     24,   0,   0,   //NO_CLASS         24  
   0,     25,     25,     25,     25,     25,   0,   0,   //NO_CLASS         25  
   0,     26,     26,     26,     26,     26,   0,   0,   //NO_CLASS         26  
   0,     27,     27,     27,     27,     27,   0,   0,   //NO_CLASS         27  
   0,     28,     28,     28,     28,     28,   0,   0,   //NO_CLASS         28  
   0,     29,     29,     29,     29,     29,   0,   0,   //NO_CLASS         29  
   0,     30,     30,     30,     30,     30,   0,   0,   //NO_CLASS         30  
   0,     31,     31,     31,     31,     31,   0,   0,   //NO_CLASS         31  
   0,     32,     32,     32,     32,     32,   0,   0,   //NO_CLASS         32  
   0,     35,     33,     33,     33,     33,   0,   0,   //NO_CLASS         33 !
   0,     40,     34,     34,     34,     34,   0,   0,   //NO_CLASS         34 "
   0,     45,     35,     35,     35,     35,   0,   0,   //NO_CLASS         35 #
   0,     50,     36,     36,     36,     36,   0,   0,   //NO_CLASS         36 $
   0,     55,     37,     37,     37,     37,   0,   0,   //NO_CLASS         37 %
   0,     60,     38,     38,     38,     38,   0,   0,   //NO_CLASS         38 &
   6,     65,     39,     39,     39,     39,   0,   0,   //CLASS_STRIP      39 '
   0,     70,     40,     40,     40,     40,   0,   0,   //NO_CLASS         40 (
   0,     75,     41,     41,     41,     41,   0,   0,   //NO_CLASS         41 )
   9,     80,     42,     42,     42,     42,   0,   0,   //CLASS_WILDCARD   42 *
   0,     85,     43,     43,     43,     43,   0,   0,   //NO_CLASS         43 +
   4,     90,     44,     44,     44,     44,   0,   0,   //CLASS_NSTRIP     44 ,
   0,     95,     45,     45,     45,     45,   0,   0,   //NO_CLASS         45 -
   5,    100,     46,     46,     46,     46,   0,   0,   //CLASS_NKEEP      46 .
   0,    105,     47,     47,     47,     47,   0,   0,   //NO_CLASS         47 /
   3,   1120,     48,     48,     48,     48,   0,   0,   //CLASS_DIGIT      48 0
   3,   1130,     49,     49,     49,     49,   0,   0,   //CLASS_DIGIT      49 1
   3,   1140,     50,     50,     50,     50,   0,   0,   //CLASS_DIGIT      50 2
   3,   1150,     51,     51,     51,     51,   0,   0,   //CLASS_DIGIT      51 3
   3,   1160,     52,     52,     52,     52,   0,   0,   //CLASS_DIGIT      52 4
   3,   1170,     53,     53,     53,     53,   0,   0,   //CLASS_DIGIT      53 5
   3,   1180,     54,     54,     54,     54,   0,   0,   //CLASS_DIGIT      54 6
   3,   1190,     55,     55,     55,     55,   0,   0,   //CLASS_DIGIT      55 7
   3,   1200,     56,     56,     56,     56,   0,   0,   //CLASS_DIGIT      56 8
   3,   1210,     57,     57,     57,     57,   0,   0,   //CLASS_DIGIT      57 9
   0,    110,     58,     58,     58,     58,   0,   0,   //NO_CLASS         58 :
   0,    115,     59,     59,     59,     59,   0,   0,   //NO_CLASS         59 ;
   0,    120,     60,     60,     60,     60,   0,   0,   //NO_CLASS         60 <
   0,    125,     61,     61,     61,     61,   0,   0,   //NO_CLASS         61 =
   0,    130,     62,     62,     62,     62,   0,   0,   //NO_CLASS         62 >
   9,    135,     63,     63,     63,     63,   0,   0,   //CLASS_WILDCARD   63 ?
   0,    140,     64,     64,     64,     64,   0,   0,   //NO_CLASS         64 @
   2,   1230,     97,     65,     65,     65,   0,   0,   //CLASS_CHAR       65 A
   2,   1250,     98,     66,     66,     66,   0,   0,   //CLASS_CHAR       66 B
   2,   1270,     99,     67,     67,     67,   0,   0,   //CLASS_CHAR       67 C
   2,   1290,    100,     68,     68,     68,   0,   0,   //CLASS_CHAR       68 D
   2,   1310,    101,     69,     69,     69,   0,   0,   //CLASS_CHAR       69 E
   2,   1330,    102,     70,     70,     70,   0,   0,   //CLASS_CHAR       70 F
   2,   1350,    103,     71,     71,     71,   0,   0,   //CLASS_CHAR       71 G
   2,   1370,    104,     72,     72,     72,   0,   0,   //CLASS_CHAR       72 H
   2,   1390,    105,     73,     73,     73,   0,   0,   //CLASS_CHAR       73 I
   2,   1410,    106,     74,     74,     74,   0,   0,   //CLASS_CHAR       74 J
   2,   1430,    107,     75,     75,     75,   0,   0,   //CLASS_CHAR       75 K
   2,   1450,    108,     76,     76,     76,   0,   0,   //CLASS_CHAR       76 L
   2,   1470,    109,     77,     77,     77,   0,   0,   //CLASS_CHAR       77 M
   2,   1490,    110,     78,     78,     78,   0,   0,   //CLASS_CHAR       78 N
   2,   1510,    111,     79,     79,     79,   0,   0,   //CLASS_CHAR       79 O
   2,   1530,    112,     80,     80,     80,   0,   0,   //CLASS_CHAR       80 P
   2,   1550,    113,     81,     81,     81,   0,   0,   //CLASS_CHAR       81 Q
   2,   1570,    114,     82,     82,     82,   0,   0,   //CLASS_CHAR       82 R
   2,   1590,    115,     83,     83,     83,   0,   0,   //CLASS_CHAR       83 S
   2,   1610,    116,     84,     84,     84,   0,   0,   //CLASS_CHAR       84 T
   2,   1630,    117,     85,     85,     85,   0,   0,   //CLASS_CHAR       85 U
   2,   1650,    118,     86,     86,     86,   0,   0,   //CLASS_CHAR       86 V
   2,   1670,    119,     87,     87,     87,   0,   0,   //CLASS_CHAR       87 W
   2,   1690,    120,     88,     88,     88,   0,   0,   //CLASS_CHAR       88 X
   2,   1710,    121,     89,     89,     89,   0,   0,   //CLASS_CHAR       89 Y
   2,   1730,    122,     90,     90,     90,   0,   0,   //CLASS_CHAR       90 Z
   0,    145,     91,     91,     91,     91,   0,   0,   //NO_CLASS         91 [
   0,    150,     92,     92,     92,     92,   0,   0,   //NO_CLASS         92  
   0,    155,     93,     93,     93,     93,   0,   0,   //NO_CLASS         93 ]
   0,    160,     94,     94,     94,     94,   0,   0,   //NO_CLASS         94 ^
   1,    165,     95,     95,     95,     95,   0,   0,   //CLASS_NORM       95 _
   0,    170,     96,     96,     96,     96,   0,   0,   //NO_CLASS         96 `
   1,   1230,     97,     97,     97,     97,   0,   0,   //CLASS_NORM       97 a
   1,   1250,     98,     98,     98,     98,   0,   0,   //CLASS_NORM       98 b
   1,   1270,     99,     99,     99,     99,   0,   0,   //CLASS_NORM       99 c
   1,   1290,    100,    100,    100,    100,   0,   0,   //CLASS_NORM      100 d
   1,   1310,    101,    101,    101,    101,   0,   0,   //CLASS_NORM      101 e
   1,   1330,    102,    102,    102,    102,   0,   0,   //CLASS_NORM      102 f
   1,   1350,    103,    103,    103,    103,   0,   0,   //CLASS_NORM      103 g
   1,   1370,    104,    104,    104,    104,   0,   0,   //CLASS_NORM      104 h
   1,   1390,    105,    105,    105,    105,   0,   0,   //CLASS_NORM      105 i
   1,   1410,    106,    106,    106,    106,   0,   0,   //CLASS_NORM      106 j
   1,   1430,    107,    107,    107,    107,   0,   0,   //CLASS_NORM      107 k
   1,   1450,    108,    108,    108,    108,   0,   0,   //CLASS_NORM      108 l
   1,   1470,    109,    109,    109,    109,   0,   0,   //CLASS_NORM      109 m
   1,   1490,    110,    110,    110,    110,   0,   0,   //CLASS_NORM      110 n
   1,   1510,    111,    111,    111,    111,   0,   0,   //CLASS_NORM      111 o
   1,   1530,    112,    112,    112,    112,   0,   0,   //CLASS_NORM      112 p
   1,   1550,    113,    113,    113,    113,   0,   0,   //CLASS_NORM      113 q
   1,   1570,    114,    114,    114,    114,   0,   0,   //CLASS_NORM      114 r
   1,   1590,    115,    115,    115,    115,   0,   0,   //CLASS_NORM      115 s
   1,   1610,    116,    116,    116,    116,   0,   0,   //CLASS_NORM      116 t
   1,   1630,    117,    117,    117,    117,   0,   0,   //CLASS_NORM      117 u
   1,   1650,    118,    118,    118,    118,   0,   0,   //CLASS_NORM      118 v
   1,   1670,    119,    119,    119,    119,   0,   0,   //CLASS_NORM      119 w
   1,   1690,    120,    120,    120,    120,   0,   0,   //CLASS_NORM      120 x
   1,   1710,    121,    121,    121,    121,   0,   0,   //CLASS_NORM      121 y
   1,   1730,    122,    122,    122,    122,   0,   0,   //CLASS_NORM      122 z
   0,    175,    123,    123,    123,    123,   0,   0,   //NO_CLASS        123 {
   0,    180,    124,    124,    124,    124,   0,   0,   //NO_CLASS        124 |
   0,    185,    125,    125,    125,    125,   0,   0,   //NO_CLASS        125 }
   0,    190,    126,    126,    126,    126,   0,   0,   //NO_CLASS        126 ~
   0,    191,    127,    127,    127,    127,   0,   0,   //NO_CLASS        127 
   0,    192,    128,    128,     32,     32,   0,   0,   //NO_CLASS        128 
   0,    193,    129,    129,     32,     32,   0,   0,   //NO_CLASS        129 
   0,    195,    130,    130,    226,    226,   0,   0,   //NO_CLASS        130 
   0,    200,    131,    131,    196,    196,   0,   0,   //NO_CLASS        131 
   0,    205,    132,    132,    227,    227,   0,   0,   //NO_CLASS        132 
   0,    210,    133,    133,    201,    201,   0,   0,   //NO_CLASS        133 
   0,    215,    134,    134,    160,    160,   0,   0,   //NO_CLASS        134 
   0,    220,    135,    135,    224,    224,   0,   0,   //NO_CLASS        135 
   0,    225,    136,    136,     94,     94,   0,   0,   //NO_CLASS        136 
   0,    230,    137,    137,    228,    228,   0,   0,   //NO_CLASS        137 
   2,   1590,    115,    138,     32,     32,   0,   0,   //CLASS_CHAR      138 
   0,    240,    139,    139,    220,    220,   0,   0,   //NO_CLASS        139 
  12,   1510,    111,    140,    206,    206,   0,   0,   //CLASS_LIGATURE  140 
   0,    246,    141,    141,     32,     32,   0,   0,   //NO_CLASS        141 
   0,    247,    142,    142,     32,     32,   0,   0,   //NO_CLASS        142 
   0,    248,    143,    143,     32,     32,   0,   0,   //NO_CLASS        143 
   0,    249,    144,    144,     32,     32,   0,   0,   //NO_CLASS        144 
1024,    250,    145,    145,    212,    212,   0,   0,   //CLASS_LQUOTE    145 '
1280,    255,    146,    146,    213,    213,   0,   0,   //CLASS_RQUOTE    146 '
1536,    260,    147,    147,    210,    210,   0,   0,   //CLASS_LDBLQUOTE 147 "
1792,    265,    148,    148,    211,    211,   0,   0,   //CLASS_RDBLQUOTE 148 "
 256,    270,    149,    149,    165,    165,   0,   0,   //CLASS_BULLET    149 
 512,    275,    150,    150,    208,    208,   0,   0,   //CLASS_ENDASH    150 -
 768,    280,    151,    151,    209,    209,   0,   0,   //CLASS_EMDASH    151 -
   0,    285,    152,    152,    126,    126,   0,   0,   //NO_CLASS        152 
   0,    290,    153,    153,    170,    170,   0,   0,   //NO_CLASS        153 
   2,   1590,    115,    154,     32,     32,   0,   0,   //CLASS_CHAR      154 
   0,    305,    155,    155,    221,    221,   0,   0,   //NO_CLASS        155 
  12,   1510,    111,    156,    207,    207,   0,   0,   //CLASS_LIGATURE  156 
   0,    311,    157,    157,     32,     32,   0,   0,   //NO_CLASS        157 
   0,    312,    158,    158,     32,     32,   0,   0,   //NO_CLASS        158 
   2,   1710,    121,    159,    217,    217,   0,   0,   //CLASS_CHAR      159 
   0,    316,    160,    160,    160,    160,   0,   0,   //NO_CLASS        160  
   0,    320,    161,    161,    193,    193,   0,   0,   //NO_CLASS        161 
   0,    325,    162,    162,    162,    162,   0,   0,   //NO_CLASS        162 
   0,    330,    163,    163,    163,    163,   0,   0,   //NO_CLASS        163 
   0,    335,    164,    164,    219,    219,   0,   0,   //NO_CLASS        164 
   0,    340,    165,    165,    180,    180,   0,   0,   //NO_CLASS        165 
   0,    345,    166,    166,     32,     32,   0,   0,   //NO_CLASS        166 
   0,    350,    167,    167,    164,    164,   0,   0,   //NO_CLASS        167 
   0,    355,    168,    168,    172,    172,   0,   0,   //NO_CLASS        168 
   0,    360,    169,    169,    169,    169,   0,   0,   //NO_CLASS        169 
   0,    365,    170,    170,    187,    187,   0,   0,   //NO_CLASS        170 
   0,    370,    171,    171,    199,    199,   0,   0,   //NO_CLASS        171 
   0,    375,    172,    172,    194,    194,   0,   0,   //NO_CLASS        172 
   0,    380,    173,    173,     45,     45,   0,   0,   //NO_CLASS        173 
   0,    385,    174,    174,    168,    168,   0,   0,   //NO_CLASS        174 
   0,    390,    175,    175,    248,    248,   0,   0,   //NO_CLASS        175 
   0,    395,    176,    176,    161,    161,   0,   0,   //NO_CLASS        176 
   0,    400,    177,    177,    177,    177,   0,   0,   //NO_CLASS        177 
   0,    405,    178,    178,     32,     32,   0,   0,   //NO_CLASS        178 
   0,    410,    179,    179,     32,     32,   0,   0,   //NO_CLASS        179 
   0,    415,    180,    180,    171,    171,   0,   0,   //NO_CLASS        180 
   0,    420,    181,    181,    181,    181,   0,   0,   //NO_CLASS        181 
   0,    425,    182,    182,    166,    166,   0,   0,   //NO_CLASS        182 
   0,    430,    183,    183,    225,    225,   0,   0,   //NO_CLASS        183 
   0,    435,    184,    184,    252,    252,   0,   0,   //NO_CLASS        184 
   0,    440,    185,    185,     32,     32,   0,   0,   //NO_CLASS        185 
   0,    445,    186,    186,    188,    188,   0,   0,   //NO_CLASS        186 
   0,    450,    187,    187,    200,    200,   0,   0,   //NO_CLASS        187 
   0,    455,    188,    188,     32,     32,   0,   0,   //NO_CLASS        188 
   0,    460,    189,    189,     32,     32,   0,   0,   //NO_CLASS        189 
   0,    465,    190,    190,     32,     32,   0,   0,   //NO_CLASS        190 
   0,    470,    191,    191,    192,    192,   0,   0,   //NO_CLASS        191 
   2,   1230,     97,    192,    203,    203,   0,   0,   //CLASS_CHAR      192 
   2,   1230,     97,    193,    231,    231,   0,   0,   //CLASS_CHAR      193 
   2,   1230,     97,    194,    229,    229,   0,   0,   //CLASS_CHAR      194 
   2,   1230,     97,    195,    204,    204,   0,   0,   //CLASS_CHAR      195 
   2,   1230,     97,    196,    128,    128,   0,   0,   //CLASS_CHAR      196 
   2,   1230,     97,    197,    129,    129,   0,   0,   //CLASS_CHAR      197 
  12,   1230,     97,    198,    174,    174,   0,   0,   //CLASS_LIGATURE  198 
   2,   1270,     99,    199,    130,    130,   0,   0,   //CLASS_CHAR      199 
   2,   1310,    101,    200,    233,    233,   0,   0,   //CLASS_CHAR      200 
   2,   1310,    101,    201,    131,    131,   0,   0,   //CLASS_CHAR      201 
   2,   1310,    101,    202,    230,    230,   0,   0,   //CLASS_CHAR      202 
   2,   1310,    101,    203,    232,    232,   0,   0,   //CLASS_CHAR      203 
   2,   1390,    105,    204,    237,    237,   0,   0,   //CLASS_CHAR      204 
   2,   1390,    105,    205,    234,    234,   0,   0,   //CLASS_CHAR      205 
   2,   1390,    105,    206,    235,    235,   0,   0,   //CLASS_CHAR      206 
   2,   1390,    105,    207,    236,    236,   0,   0,   //CLASS_CHAR      207 
   2,   1290,    100,    208,     32,     32,   0,   0,   //CLASS_CHAR      208 
   2,   1490,    110,    209,    132,    132,   0,   0,   //CLASS_CHAR      209 
   2,   1510,    111,    210,    241,    241,   0,   0,   //CLASS_CHAR      210 
   2,   1510,    111,    211,    238,    238,   0,   0,   //CLASS_CHAR      211 
   2,   1510,    111,    212,    239,    239,   0,   0,   //CLASS_CHAR      212 
   2,   1510,    111,    213,    205,    205,   0,   0,   //CLASS_CHAR      213 
   2,   1510,    111,    214,    133,    133,   0,   0,   //CLASS_CHAR      214 
   0,    475,    215,    215,     32,     32,   0,   0,   //NO_CLASS        215 
   2,   1510,    111,    216,    175,    175,   0,   0,   //CLASS_CHAR      216 
   2,   1630,    117,    217,    244,    244,   0,   0,   //CLASS_CHAR      217 
   2,   1630,    117,    218,    242,    242,   0,   0,   //CLASS_CHAR      218 
   2,   1630,    117,    219,    243,    243,   0,   0,   //CLASS_CHAR      219 
   2,   1630,    117,    220,    134,    134,   0,   0,   //CLASS_CHAR      220 
   2,   1710,    121,    221,     32,     32,   0,   0,   //CLASS_CHAR      221 
   2,   1090,    222,    222,     32,     32,   0,   0,   //CLASS_CHAR      222 
  12,   1590,    115,    223,    167,    167,   0,   0,   //CLASS_LIGATURE  223 
   2,   1230,     97,    224,    136,    136,   0,   0,   //CLASS_CHAR      224 
   2,   1230,     97,    225,    135,    135,   0,   0,   //CLASS_CHAR      225 
   2,   1230,     97,    226,    137,    137,   0,   0,   //CLASS_CHAR      226 
   2,   1230,     97,    227,    139,    139,   0,   0,   //CLASS_CHAR      227 
   2,   1230,     97,    228,    138,    138,   0,   0,   //CLASS_CHAR      228 
   2,   1230,     97,    229,    140,    140,   0,   0,   //CLASS_CHAR      229 
  12,   1230,     97,    230,    190,    190,   0,   0,   //CLASS_LIGATURE  230 
   2,   1270,     99,    231,    141,    141,   0,   0,   //CLASS_CHAR      231 
   2,   1310,    101,    232,    143,    143,   0,   0,   //CLASS_CHAR      232 
   2,   1310,    101,    233,    142,    142,   0,   0,   //CLASS_CHAR      233 
   2,   1310,    101,    234,    144,    144,   0,   0,   //CLASS_CHAR      234 
   2,   1310,    101,    235,    145,    145,   0,   0,   //CLASS_CHAR      235 
   2,   1390,    105,    236,    147,    147,   0,   0,   //CLASS_CHAR      236 
   2,   1390,    105,    237,    146,    146,   0,   0,   //CLASS_CHAR      237 
   2,   1390,    105,    238,    148,    148,   0,   0,   //CLASS_CHAR      238 
   2,   1390,    105,    239,    149,    149,   0,   0,   //CLASS_CHAR      239 
   2,   1290,    111,    240,     32,     32,   0,   0,   //CLASS_CHAR      240 
   2,   1490,    110,    241,    150,    150,   0,   0,   //CLASS_CHAR      241 
   2,   1510,    111,    242,    152,    152,   0,   0,   //CLASS_CHAR      242 
   2,   1510,    111,    243,    151,    151,   0,   0,   //CLASS_CHAR      243 
   2,   1510,    111,    244,    153,    153,   0,   0,   //CLASS_CHAR      244 
   2,   1510,    111,    245,    155,    155,   0,   0,   //CLASS_CHAR      245 
   2,   1510,    111,    246,    154,    154,   0,   0,   //CLASS_CHAR      246 
   0,    102,    247,    247,    214,    214,   0,   0,   //NO_CLASS        247 
   2,   1510,    111,    248,    191,    191,   0,   0,   //CLASS_CHAR      248 
   2,   1630,    117,    249,    157,    157,   0,   0,   //CLASS_CHAR      249 
   2,   1630,    117,    250,    156,    156,   0,   0,   //CLASS_CHAR      250 
   2,   1630,    117,    251,    158,    158,   0,   0,   //CLASS_CHAR      251 
   2,   1630,    117,    252,    159,    159,   0,   0,   //CLASS_CHAR      252 
   2,   1710,    121,    253,     32,     32,   0,   0,   //CLASS_CHAR      253 
   2,   1100,    254,    254,     32,     32,   0,   0,   //CLASS_CHAR      254 
   2,   1710,    121,    255,    216,    216,   0,   0,   //CLASS_CHAR      255 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\iofts.h ===
/****************************************
 *                                      *
 *	File parameter block structure.     *
 *                                      *
 ****************************************/

typedef	struct	FileParmBlock 
{
	GHANDLE	hStruct;	// This structure's handle. MUST BE 1ST FIELD!!!
	INTERRUPT_FUNC lpfnfInterCb;
						// A user-supplied function that's called
						//  every time an I/O function makes a
						//  physical I/O.  This field exists to allow
						//  the user to interrupt an involved process
						//  by forcing the I/O calls to return error.
	LPV	lpvInterCbParms;
						// A user-supplied pointer that's passed along
						//  to "lpfnfInterCb".
	union {
		HFS	hfs;		// handle to file system
		HF hf;			// handle to sub-file
#ifdef _WIN32
		HANDLE hFile;	// handle to regular DOS file
#else
	  	HFILE hFile;
#endif
	} fs;
	HANDLE hBuf;		// Handle to DOS I/O buffer
	BYTE fFileType;		// Flags which tells what kind of file is that
	BYTE ioMode;		// File I/O mode (READ, READ_WRITE, OPENED_HFS)
	CRITICAL_SECTION cs;	// @field When doing subfile seek/read combos, ensure OK
} FPB, FAR * LPFPB;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\iofts.c ===
/*************************************************************************
*                                                                        *
*  IOFTS.C                                                               *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1990-1994                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*   Provide disk I/O for various types of files currently supported,     *
*   which include: FS system file, FS subfile, regular files             *
*   The I/O functions supported are:                                     *
*      - File exist                                                      *
*      - File open, create                                               *
*      - File seek/write                                                 *
*      - File sequential write                                           *
*      - File seek/read                                                  *
*      - File sequential read                                            *
*      - File close                                                      *
*                                                                        *
*   Comments:                                                            *
*      There are some PLATFORM DEPENDENT codes in the modules for        *
*      calls such as _lopen, _lread, _lwrite.                            *
*      There are calls that are not supported, such as create a          *
*      regular DOS file, since we never use them. Those calls can be     *
*      implemented when the need arises                                  *
**************************************************************************
*                                                                        *
*  Written By   : Binh Nguyen                                            *
*  Current Owner: Binh Nguyen                                            *
*                                                                        *
**************************************************************************/

#include <mvopsys.h>
#include <mem.h>
#include <misc.h>
//#include <mvsearch.h>
#include <iterror.h>
#include <wrapstor.h>
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <string.h>
#include <_mvutil.h>
#include "iofts.h"

#ifdef _DEBUG
static	BYTE NEAR s_aszModule[] = __FILE__;	// Used by error return functions.
#endif


PRIVATE HANDLE NEAR PASCAL IoftsWin32Create(LPCSTR lpstr, DWORD w);
PRIVATE HANDLE NEAR PASCAL IoftsWin32Open(LPCSTR lpstr, DWORD w);

#ifdef _WIN32
#define	CREAT(sz, w) IoftsWin32Create(sz, w)
#define	OPEN(sz, w)	IoftsWin32Open(sz, w)
#define _COMMIT(hfile)	(FlushFileBuffers(hfile) ? 0 : GetLastError())

/* seek origins */
#if !defined(wFSSeekSet)
#define wFSSeekSet      FILE_BEGIN
#define wFSSeekCur      FILE_CURRENT
#define wFSSeekEnd      FILE_END
#endif // !defined(wFSSeekSet)

#else // if ! _NT

#define	CREAT	_lcreat
#define	OPEN	_lopen
#define _COMMIT _commit

/* seek origins */
#define wFSSeekSet      0
#define wFSSeekCur      1
#define wFSSeekEnd      2

#endif // ! _NT

#define OPENED_HFS (BYTE)0x80



/*************************************************************************
 * 	                  INTERNAL PRIVATE FUNCTIONS
 *
 *	Those functions should be declared NEAR
 *************************************************************************/


// return pointer to portion of filename after !
// fill lszTemp with copy of first half before !

LPCSTR NEAR PASCAL GetSubFilename(LPCSTR lszFilename, LSZ lszTemp)
{
	LSZ lszTempOriginal = lszTemp;
	LPCSTR lszFilenameOriginal=lszFilename;

	if (lszTemp)
	{	while ((*lszFilename) && (*lszFilename!='!')) 	
		{
		 	*lszTemp++=*lszFilename++;
		}
		*lszTemp=0x00;
	}
	else
	{
	 	while ((*lszFilename) && (*lszFilename!='!'))
		{
		 	lszFilename++;
		}
	}

	if (*lszFilename=='!')
		lszFilename++;

	if (!*lszFilename)
	{
		if (lszTempOriginal)
			*lszTempOriginal=0x00;
		lszFilename=lszFilenameOriginal; 	
	}
	return lszFilename;
}

LPSTR FAR PASCAL CreateDefaultFilename(LPCSTR szFilename, LPCSTR szDefault, LPSTR szFullName)
{
	LPCSTR szSubFilename = GetSubFilename(szFilename,szFullName);
	
	// Use default if no "!" was found.
	if (!*szFullName)
	 	wsprintf(szFullName,"%s!%s",szFilename,szDefault);
	else
		lstrcpy(szFullName,szFilename);
	return szFullName;
}

// Get an Hfs based on HFPB and Filename
// if bCreate==FALSE, open for READ ONLY
// if bCreate==TRUE, open for READ WRITE (create if non existant)

HFS FAR PASCAL HfsFromHfpb(HFPB hfpb)
{
	LPFPB lpfpbFS;
	HFS hfs=NULL;

	if (!hfpb)
		return NULL;
 	
 	lpfpbFS = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpbFS->cs);
	hfs=lpfpbFS->fs.hfs;
	_LEAVECRITICALSECTION(&lpfpbFS->cs);
	_GLOBALUNLOCK(hfpb);
	return hfs;
}


HFS FAR PASCAL GetHfs(HFPB hfpbSysFile, LPCSTR lszFilename,
	BOOL bCreate, PHRESULT phr)
{
	HFS hfs = NULL;
	
	if (!hfpbSysFile)
	{
		BYTE lszTemp[cbMAX_PATH];
		LPCSTR lszSubFilename;
		
		lszSubFilename=GetSubFilename(lszFilename,lszTemp);
		if (*lszSubFilename)
		{	
			FM fm;
		 	fm = FmNewSzDir((LPSTR)lszTemp, dirCurrent, NULL);
			if (bCreate)
			{
				hfs = HfsOpenFm(fm, FSH_READWRITE, phr);
				if (!hfs)
				{	
					if (!FileExist(NULL, lszTemp, FS_SYSTEMFILE))
					{
						hfs = HfsCreateFileSysFm(fm, NULL, phr);
					}
				}
			}
			else
				hfs = HfsOpenFm(fm, FSH_READONLY, phr);

			DisposeFm(fm);
		}
		else
			SetErrCode(phr,E_INVALIDARG);
	}
	else
	{
	 	LPFPB lpfpbFS = (LPFPB)_GLOBALLOCK(hfpbSysFile);
		_ENTERCRITICALSECTION(&lpfpbFS->cs);
		hfs=lpfpbFS->fs.hfs;
		if (!hfs)
			SetErrCode(phr,E_ASSERT);
		_LEAVECRITICALSECTION(&lpfpbFS->cs);
		_GLOBALUNLOCK(hfpbSysFile);
	}

	return hfs;
}


// if hfpbSysFile==NULL, and fFileType==FS_SUBFILE, then
//  lszFilename must contain filesys!subfile

PUBLIC HRESULT FAR PASCAL FileExist (HFPB hfpbSysFile, LPCSTR lszFilename,
	int fFileType)
{
	HFS hfs=NULL;
	FM fm;
    HRESULT errb;
	HRESULT rc=E_ASSERT;


	if (lszFilename == NULL )
	{
		SetErrCode (&errb, E_INVALIDARG);
		return 0;
	}

	errb=S_OK;

	switch (fFileType)
	{
		case FS_SYSTEMFILE:

			fm = FmNewSzDir((LPSTR)lszFilename, dirCurrent, NULL);
			if (FExistFm(fm))
				errb=S_OK;
			else
				errb=E_NOTEXIST;
			DisposeFm(fm);

			break;

		case FS_SUBFILE:
			hfs = GetHfs(hfpbSysFile,lszFilename,FALSE,&errb);

			if (hfs)
			{
				if (FAccessHfs(hfs,GetSubFilename(lszFilename,NULL),
					FACCESS_EXISTS,&errb))
					rc=S_OK;
				else
				 	rc = errb;
			
				// if it wasn't given to us above, remove it now
				if (!hfpbSysFile)
				 	RcCloseHfs(hfs);				
			}
			else
				rc=errb;
			break;
		
		case REGULAR_FILE:
			/* There is no need to call this function for DOS files.  */

			fm = FmNewSzDir((LPSTR)lszFilename, dirCurrent, NULL);
			if (FExistFm(fm))
				errb=S_OK;
			else
				errb=E_NOTEXIST;
			DisposeFm(fm);
			break;

		default:
			SetErrCode(&errb,E_INVALIDARG);
			return 0;
	}

	return errb;
}

#ifndef ITWRAP
PUBLIC HFPB FAR PASCAL FileCreate (HFPB hfpbSysFile, LPCSTR lszFilename,
	int fFileType, PHRESULT phr)
{
	LPFPB lpfpb;	/* Pointer to file parameter block */
	FM fm;
	//HRESULT rc;		/* Default open error code */
	HANDLE hMem;
	HFPB hfpb;

	/* Check for valid filename */
	if (lszFilename == NULL )
	{
		SetErrCode (phr, E_INVALIDARG);
		return 0;
	}

	/* Allocate a file's parameter block */
	if (!(hMem = _GLOBALALLOC(GMEM_ZEROINIT, sizeof(FPB))))
	{	
		SetErrCode(phr,ERR_MEMORY);
		return NULL;
	}

	if (!(lpfpb = (LPFPB)_GLOBALLOCK(hMem)))
	{
	 	_GLOBALUNLOCK(hMem);
		SetErrCode(phr,ERR_MEMORY);
		return NULL;
	}

	_INITIALIZECRITICALSECTION(&lpfpb->cs);
	lpfpb->hStruct=hMem;

	switch (fFileType)
	{
		case FS_SYSTEMFILE:
			fm = FmNewSzDir((LPSTR)lszFilename, dirCurrent, NULL);
			lpfpb->fs.hfs = HfsCreateFileSysFm(fm, NULL, phr);
			DisposeFm(fm);
			if (lpfpb->fs.hfs== NULL)
			{
				goto ErrorExit;
			}
			break;


		case FS_SUBFILE:
		{	HFS hfs = GetHfs(hfpbSysFile,lszFilename,TRUE,phr);
			if (hfs)
			{	
				lpfpb->fs.hf = HfCreateFileHfs(hfs,GetSubFilename(lszFilename,
					NULL),HFOPEN_READWRITE,phr);
				 
				lpfpb->ioMode = OF_READWRITE;
				
				if (lpfpb->fs.hf == 0)
				{
					if (!hfpbSysFile)
					 	RcCloseHfs(hfs);				
					goto ErrorExit;
				}
				else
				{
				 	if (!hfpbSysFile)
						lpfpb->ioMode|=OPENED_HFS;
				}
			}
			else
			{
			 	goto ErrorExit;
			}
			break;
		}
		case REGULAR_FILE:
			/* Open the file */
			/* PLATFORM DEPENDENT code: _lcreat */
			if ((lpfpb->fs.hFile = (HFILE_GENERIC)CREAT (lszFilename, 0))
			    == HFILE_GENERIC_ERROR)
			{
				SetErrCode(phr,ERR_FILECREAT_FAILED);
				goto ErrorExit;
			}
			lpfpb->ioMode = OF_READWRITE;
			break;
	}

	/* Set the filetype */
	lpfpb->fFileType = fFileType;

	_GLOBALUNLOCK(hfpb = lpfpb->hStruct);
	return hfpb;

ErrorExit:
	_DELETECRITICALSECTION(&lpfpb->cs);
	_GLOBALFREE(hMem);
	return 0;
}
#endif

#ifndef ITWRAP
PUBLIC HFPB FAR PASCAL FileOpen (HFPB hfpbSysFile, LPCSTR lszFilename,
	int fFileType, int ioMode, PHRESULT phr)
{
	LPFPB lpfpb;	/* Pointer to file parameter block */
	FM fm;
	//HRESULT rc;		/* Default open error code */
	HANDLE hMem;
	HFPB hfpb;

	/* Check for valid filename */
	if (lszFilename == NULL )
	{
		SetErrCode (phr, E_INVALIDARG);
		return 0;
	}

	/* Allocate a file's parameter block */
	if (!(hMem = _GLOBALALLOC(GMEM_ZEROINIT, sizeof(FPB))))
	{	
		SetErrCode(phr,ERR_MEMORY);
		return NULL;
	}

	if (!(lpfpb = (LPFPB)_GLOBALLOCK(hMem)))
	{
	 	_GLOBALUNLOCK(hMem);
		SetErrCode(phr,ERR_MEMORY);
		return NULL;
	}

	_INITIALIZECRITICALSECTION(&lpfpb->cs);
	lpfpb->hStruct=hMem;

	switch (fFileType)
	{
		case FS_SYSTEMFILE:
			fm = FmNewSzDir((LPSTR)lszFilename, dirCurrent, NULL);
			lpfpb->fs.hfs = HfsOpenFm(fm,(BYTE)((ioMode==READ)?
				FSH_READONLY:FSH_READWRITE), phr);
			DisposeFm(fm);
			if (lpfpb->fs.hfs== NULL)
			{
				goto ErrorExit;
			}
			break;

		case FS_SUBFILE:
		{	
			HFS	hfs = GetHfs(hfpbSysFile,lszFilename,FALSE,phr);
			if (hfs)
			{	
				lpfpb->fs.hf = HfOpenHfs(hfs,GetSubFilename(lszFilename,
					NULL),(BYTE)((ioMode==READ)?HFOPEN_READ:HFOPEN_READWRITE),phr);
				 
				lpfpb->ioMode = ioMode;
				
				if (lpfpb->fs.hf == 0)
				{
					if (!hfpbSysFile)
					 	RcCloseHfs(hfs);
					SetErrCode (phr, E_NOTEXIST);				
					goto ErrorExit;
				}
				else
				{
				 	if (!hfpbSysFile)
						lpfpb->ioMode|=OPENED_HFS;
				}
			}
			else
			{
				SetErrCode (phr, E_NOTEXIST);				
			 	goto ErrorExit;
			}
			break;
		}
		case REGULAR_FILE:
			/* Set the IO mode and appropriate error messages */
			if (ioMode == READ)
			{
				/* Open the file */
				/* PLATFORM DEPENDENT code: _lopen */
				if ((lpfpb->fs.hFile = (HFILE_GENERIC)OPEN (lszFilename,
				    ioMode)) == HFILE_GENERIC_ERROR) 
				{
					SetErrCode(phr,E_NOTEXIST);
					goto ErrorExit;
				}

			}
			else
			{
				ioMode = OF_READWRITE;
				/* Open the file */
				/* PLATFORM DEPENDENT code: _lcreat */
				if ((lpfpb->fs.hFile = (HFILE_GENERIC)OPEN(lszFilename, ioMode))
				    == HFILE_GENERIC_ERROR)
				{
					SetErrCode(phr,ERR_FILECREAT_FAILED);
					goto ErrorExit;
				}
			}
			lpfpb->ioMode = ioMode;
	}

	/* Set the filetype */
	lpfpb->fFileType = fFileType;

	_GLOBALUNLOCK(hfpb = lpfpb->hStruct);
	return hfpb;

ErrorExit:
	_DELETECRITICALSECTION(&lpfpb->cs);
	_GLOBALFREE(hMem);
	return 0;
}
#endif

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET FAR PASCAL | FileSeek |
 *		Seek to a location in a file
 *
 *	@parm	HFPB | hfpb |
 *		Handle to file paramter block
 *
 *	@parm	FILEOFFSET | foSeek |
 *		Location to seek to
 *
 * 	@parm	WORD | wOrigin |
 *		Base of seek (0=begin, 1=current, 2=end)
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer.
 *
 *	@rdesc	Returns the location actually seeked to
 *
 *************************************************************************/

PUBLIC FILEOFFSET FAR PASCAL FileSeek(HFPB hfpb, FILEOFFSET fo, WORD wOrigin, PHRESULT phr)
{
	LPFPB	lpfpb;
	HRESULT fCallBackRet;
	FILEOFFSET foSeeked=foInvalid;
	
	if (hfpb == NULL)
	{
		SetErrCode(phr, E_HANDLE);
		return foSeeked;
	}
		
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	/* Execute user's status functions */
	if (lpfpb->lpfnfInterCb != NULL &&
		(fCallBackRet = (*lpfpb->lpfnfInterCb)(lpfpb->lpvInterCbParms))
		!= S_OK)
	{
		SetErrCode(phr, fCallBackRet);
		goto ErrorExit;
	}

	if (phr)
		*phr = S_OK;
	
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:
			/* We should not seek a system file */
			SetErrCode(phr, E_ASSERT);
			goto ErrorExit;
			break;

		case FS_SUBFILE:
			foSeeked=FoSeekHf(lpfpb->fs.hf,fo,wOrigin,phr);
			break;

		case REGULAR_FILE:
			/* Regular files */
#ifdef _WIN32			
			foSeeked=fo;
			foSeeked.dwOffset=SetFilePointer(lpfpb->fs.hFile, fo.dwOffset, &foSeeked.dwHigh,(DWORD)wOrigin);
#else
			foSeeked.dwHigh=0L;
			foSeeked.dwOffset=(DWORD)_llseek(lpfpb->fs.hFile, fo.dwOffset, wOrigin);
#endif			
			if (!FoEquals(fo,foSeeked))
			{
				SetErrCode (phr, E_FILESEEK);				
			}
			break;
	}

ErrorExit:
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return foSeeked;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET FAR PASCAL | FileSize |
 *		Get the size of an opened file
 *
 *	@parm	HFPB | hfpb |
 *		Handle to file paramter block
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer.
 *
 *	@rdesc	Returns the size of the file.  If an error occurs, it returns
 *		foInvalid, and phr contains the error info.  For files under 2 gigs, 
 *		just look at the .dwOffset member of the returned file offset.
 *
 *************************************************************************/

PUBLIC FILEOFFSET FAR PASCAL FileSize(HFPB hfpb, PHRESULT phr)
{
	LPFPB	lpfpb;
	FILEOFFSET foSeeked=foInvalid;
	FILEOFFSET foTemp;
	
	if (hfpb == NULL)
	{
		SetErrCode(phr, E_HANDLE);
		return foSeeked;
	}
		
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	if (phr)
		*phr = S_OK;
	
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:
			/* We should not get the size of a system file */
			SetErrCode(phr, E_ASSERT);
			goto ErrorExit;
			break;

		case FS_SUBFILE:
			foSeeked=FoSizeHf(lpfpb->fs.hf, phr);
			break;

		case REGULAR_FILE:
			/* Regular files */
#ifdef _WIN32			
			// foTemp has current file position
			foTemp=foNil;
			foTemp.dwOffset=SetFilePointer(lpfpb->fs.hFile, 0L, &foTemp.dwHigh, FILE_CURRENT);
			foSeeked=foNil;
			foSeeked.dwOffset=SetFilePointer(lpfpb->fs.hFile, 0L, &foSeeked.dwHigh, FILE_END);
			SetFilePointer(lpfpb->fs.hFile,foTemp.dwOffset,&foTemp.dwHigh, FILE_BEGIN);
#else
			foTemp.dwHigh=0L;
			foTemp.dwOffset=(DWORD)_llseek(lpfpb->fs.hFile, 0L, FILE_CURRENT);
			foSeeked=foNil;
			foSeeked.dwOffset=(DWORD)_llseek(lpfpb->fs.hFile, 0L, FILE_END);
			_llseek(lpfpb->fs.hFile, foTemp.dwOffset, FILE_BEGIN);
#endif			
			break;
	}

ErrorExit:
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return foSeeked;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	FILEOFFSET FAR PASCAL | FileOffset |
 *		Get the offset of a file if baggage
 *
 *	@parm	HFPB | hfpb |
 *		Handle to file paramter block (of baggage file)
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer.
 *
 *	@rdesc	Returns the offset the file lives inside it's parent file.  
 *		This is the offset into an M20 of a baggage file, or zero for any 
 *		other type of file.  If an error occurs, it returns
 *		foInvalid, and phr contains the error info.  For files under 2 gigs, 
 *		just look at the .dwOffset member of the returned file offset.
 *
 *************************************************************************/

PUBLIC FILEOFFSET FAR PASCAL FileOffset(HFPB hfpb, PHRESULT phr)
{
	LPFPB	lpfpb;
	FILEOFFSET foOffset=foInvalid;
	
	if (hfpb == NULL)
	{
		SetErrCode(phr, E_HANDLE);
		return foOffset;
	}
		
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	if (phr)
		*phr = S_OK;
	
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:
			/* We should not get the size of a system file */
			foOffset=foNil;
			goto ErrorExit;
			break;

		case FS_SUBFILE:
			foOffset=FoOffsetHf(lpfpb->fs.hf, phr);
			break;

		case REGULAR_FILE:
			/* Regular files */
			foOffset=foNil;
			goto ErrorExit;
			break;
	}

ErrorExit:
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return foOffset;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	LONG FAR PASCAL | FileSeekRead |
 *		Returns the number of bytes read
 *
 *	@parm	HFPB | hfpb |
 *		Handle to file paramter block
 *
 *	@parm	LPV	| lpvData |
 *		Buffer to read into.
 *
 *	@parm	FILEOFFSET | foSeek |
 *		File offset to read at.
 *
 *	@parm	LONG | lcbSize |
 *		How many bytes to read.
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer.
 *
 *	@rdesc	Returns the number of bytes actually read
 *
 *************************************************************************/

PUBLIC LONG FAR PASCAL FileSeekRead(HFPB hfpb, LPV lpvData, FILEOFFSET fo,
	LONG lcbSize, PHRESULT phr)
{
	LONG lRead=0L;
	LPFPB	lpfpb;
	HRESULT fCallBackRet;
	FILEOFFSET foSeeked=foInvalid;

	if (hfpb == NULL)
	{
		SetErrCode(phr, E_HANDLE);
		return 0L;
	}
		
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	/* Execute user's status functions */
	if (lpfpb->lpfnfInterCb != NULL &&
		(fCallBackRet = (*lpfpb->lpfnfInterCb)(lpfpb->lpvInterCbParms))
		!= S_OK)
	{
		SetErrCode(phr, fCallBackRet);
		goto ErrorExit;
	}
	
	if (phr)
		*phr = S_OK;
	
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:

			/* We should not read from a system file */

			SetErrCode(phr, E_ASSERT);
			goto ErrorExit;
			break;

		case FS_SUBFILE:
			foSeeked=fo;
			foSeeked=FoSeekHf(lpfpb->fs.hf,fo,0,phr);
			if (!FoEquals(foSeeked,fo))
			{
				SetErrCode (phr, E_FILESEEK);
				goto ErrorExit;
			}
			lRead=LcbReadHf(lpfpb->fs.hf, lpvData,  lcbSize, phr);
			break;
			
		case REGULAR_FILE:
			/* Regular files */
			/* PLATFORM DEPENDENT code: _lread */
#ifdef _WIN32			
			foSeeked=fo;
			foSeeked.dwOffset=SetFilePointer(lpfpb->fs.hFile, fo.dwOffset, &foSeeked.dwHigh,0);
#else
			foSeeked.dwHigh=0L;
			foSeeked.dwOffset=(DWORD)_llseek(lpfpb->fs.hFile, fo.dwOffset, 0);
#endif			
			if (!FoEquals(fo,foSeeked))
			{
				SetErrCode (phr, E_FILESEEK);				
				goto ErrorExit;
			}

#ifdef _WIN32
			ReadFile(lpfpb->fs.hFile, lpvData, lcbSize, &lRead, NULL);
#else
			lRead=_lread(lpfpb->fs.hFile, lpvData, lcbSize);
#endif
			break;
	}

ErrorExit:
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return lRead;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	WORD FAR PASCAL | FileRead |
 *		Read a number of bytes from a file
 *
 *	@parm	LPV	| lpvData |
 *		Buffer to read into.
 *
 *	@parm	LONG | lcbSize |
 *		How many bytes to read.
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer.
 *
 *	@rdesc	Returns the number of bytes actually read.
 *
 *************************************************************************/

PUBLIC	LONG FAR PASCAL FileRead(HFPB hfpb, LPV lpvData,
	LONG lcbSize, PHRESULT phr)
{
	LONG lRead=0L;
	LPFPB	lpfpb;
	HRESULT  fCallBackRet;

	if (hfpb == NULL || lpvData == NULL)
	{
		SetErrCode(phr, E_INVALIDARG);
		return 0L;
	}
		
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	/* Execute user's status functions */
	if (lpfpb->lpfnfInterCb != NULL &&
		(fCallBackRet = (*lpfpb->lpfnfInterCb)(lpfpb->lpvInterCbParms))
		!= S_OK)
	{
		SetErrCode(phr, fCallBackRet);
		goto ErrorExit;
	}
	
	if (phr)
		*phr = S_OK;
	
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:

			/* We should not read from a system file */

			SetErrCode(phr, E_ASSERT);
			goto ErrorExit;
			break;

		case FS_SUBFILE:
			lRead=LcbReadHf(lpfpb->fs.hf, lpvData,  lcbSize, phr);
			break;
			
		case REGULAR_FILE:
			/* Regular files */
			/* PLATFORM DEPENDENT code: _lread */
#ifdef _WIN32
			ReadFile(lpfpb->fs.hFile, lpvData, lcbSize, &lRead, NULL);
#else
			lRead=_lread(lpfpb->fs.hFile, lpvData, lcbSize);
#endif
			break;
	}

ErrorExit:
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return lRead;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	int FAR PASCAL | FileSeekWrite |
 *		Write number of bytes to a file at some specific location
 *
 *	@parm	HFPB | hfpb |
 *		Handle to file parameter block 
 *
 *	@parm	LPV	| lpvData |
 *		Buffer to write.
 *
 *	@parm	FILEOFFSET | foSeek |
 *		File offset to write at.
 *
 *	@parm	LONG | lcbSize |
 *		How many bytes to write.
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer.
 *
 *	@rdesc	Returns the number of bytes written
 *
 *************************************************************************/

PUBLIC LONG FAR PASCAL FileSeekWrite(HFPB hfpb, LPV lpvData,
	FILEOFFSET fo, LONG lcbSize, PHRESULT phr)
{
	LONG lWrote=0L;
	LPFPB	lpfpb;
	HRESULT  fCallBackRet;
	FILEOFFSET foSeeked=foInvalid;

	if (hfpb == NULL)
	{
		SetErrCode(phr, E_HANDLE);
		return 0L;
	}
		
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	/* Execute user's status functions */
	if (lpfpb->lpfnfInterCb != NULL &&
		(fCallBackRet = (*lpfpb->lpfnfInterCb)(lpfpb->lpvInterCbParms)) != S_OK)
	{
		SetErrCode(phr, fCallBackRet);
		goto ErrorExit;
	}
	
	if (phr)
		*phr = S_OK;
	
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:

			/* We should not read from a system file */
			SetErrCode(phr, E_ASSERT);
			goto ErrorExit;
			break;

		case FS_SUBFILE:
			foSeeked=FoSeekHf(lpfpb->fs.hf,fo,0,phr);
			if (!FoEquals(foSeeked,fo))
			{
				SetErrCode (phr, E_FILESEEK);
				goto ErrorExit;
			}
			lWrote=LcbWriteHf(lpfpb->fs.hf, lpvData,  lcbSize, phr);
			break;
			
		case REGULAR_FILE:
			/* Regular files */
			/* PLATFORM DEPENDENT code: _lread */
#ifdef _WIN32			
			foSeeked=fo;
			foSeeked.dwOffset=SetFilePointer(lpfpb->fs.hFile, fo.dwOffset, &foSeeked.dwHigh,0);
#else
			foSeeked.dwHigh=0L;
			foSeeked.dwOffset=(DWORD)_llseek(lpfpb->fs.hFile, fo.dwOffset, 0);
#endif			
			if (!FoEquals(fo,foSeeked))
			{
				SetErrCode (phr, E_FILESEEK);				
				goto ErrorExit;
			}

#ifdef _WIN32
			WriteFile(lpfpb->fs.hFile, lpvData, lcbSize, &lWrote, NULL);
#else
			lWrote=_lread(lpfpb->fs.hFile, lpvData, lcbSize);
#endif
			break;
	}

    if (lWrote != lcbSize)
        SetErrCode (phr, E_DISKFULL);
ErrorExit:
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return lWrote;

}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	LONG FAR PASCAL | FileWrite |
 *		Write data to a file
 *
 *	@parm	HFPB | hfpb |
 *		Handle to file parameter block 
 *
 *	@parm	LPV	| lpvData |
 *		Buffer to write.
 *
 *	@parm	LONG | lcbSize |
 *		How many bytes to write.
 *
 *	@parm	PHRESULT | phr |
 *		Error buffer.
 *
 *	@rdesc	Returns the number of bytes written
 *
 *************************************************************************/

PUBLIC LONG FAR PASCAL FileWrite(HFPB	hfpb, LPV lpvData,
	LONG lcbSize, PHRESULT phr)
{
	LONG lWrote=0L;
	LPFPB	lpfpb;
	HRESULT fCallBackRet;

	if (hfpb == NULL)
	{
		SetErrCode(phr, E_HANDLE);
		return 0L;
	}
		
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	/* Execute user's status functions */
	if (lpfpb->lpfnfInterCb != NULL &&
		(fCallBackRet = (*lpfpb->lpfnfInterCb)(lpfpb->lpvInterCbParms))
		!= S_OK)
	{
		SetErrCode(phr, fCallBackRet);
		goto ErrorExit;
	}
	
	if (phr)
		*phr = S_OK;
	
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:
			/* We should not read from a system file */
			SetErrCode(phr, E_ASSERT);
			goto ErrorExit;
			break;

		case FS_SUBFILE:
			lWrote=LcbWriteHf(lpfpb->fs.hf, lpvData,  lcbSize, phr);
			break;
			
		case REGULAR_FILE:
			/* Regular files */
			/* PLATFORM DEPENDENT code: _lread */
#ifdef _WIN32
			WriteFile(lpfpb->fs.hFile, lpvData, lcbSize, &lWrote, NULL);
#else
			lWrote=_lwrite(lpfpb->fs.hFile, lpvData, lcbSize);
#endif
			break;
	}

    if (lWrote != lcbSize)
        SetErrCode (phr, E_DISKFULL);
ErrorExit:
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return lWrote;
}

/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	VOID | SetFCallBack |
 *		This function provides a simple interface to set the user's
 *		interrupt function and parameters. The function will be called
 *		everytime we do an I/O
 *
 *	@parm	GHANDLE | hfpb |
 *		File's parameter block
 *
 *	@parm	INTERRUPT_FUNC | lpfnfInterCb |
 *		User's interrupt function
 *
 *	@parm	LPV | lpvInterCbParms |
 *		User's function parameters
 *************************************************************************/

PUBLIC VOID SetFCallBack (GHANDLE hfpb, INTERRUPT_FUNC lpfnfInterCb,
	LPV lpvInterCbParms)
{
	LPFPB	lpfpb;

	if (hfpb == 0)
		return;
	if (lpfpb = (LPFPB)_GLOBALLOCK(hfpb))
	{
		_ENTERCRITICALSECTION(&lpfpb->cs);
		lpfpb->lpfnfInterCb = lpfnfInterCb;
		lpfpb->lpvInterCbParms = lpvInterCbParms;
		_LEAVECRITICALSECTION(&lpfpb->cs);
	}
	_GLOBALUNLOCK(hfpb);
}

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	VOID PASCAL | GetFSName |
 *
 *		Given a filename which may include a system file and a sub-system
 *		filename separated by '!', this function will break the given name
 *		into separate components. If there is no sub-system filename, it
 *		will use the default name
 *
 *	@parm	LSZ | lszFName |
 *		Pointer to filename to be parsed
 *
 *	@parm	LSZ | aszNameBuf |
 *		Common buffer to store the two names
 *
 *	@parm	LSZ FAR * | lplszSubFilename |
 *		Pointer to subfile name to be updated
 *
 *	@parm	LSZ | lszDefaultName |
 *		Default subname to be used
 *************************************************************************/
PUBLIC VOID PASCAL FAR GetFSName(LSZ lszFName, LSZ aszNameBuf,
	LSZ FAR *lplszSubFilename, LSZ lszDefaultName)
{
	register LSZ lsztmp = aszNameBuf;

	/* Look for the '!' delimiter */
	for (lsztmp = aszNameBuf;
		(*lsztmp = *lszFName) && *lsztmp != '!'; lsztmp++, lszFName++);

	*lsztmp++ = 0;

	if (*lszFName == 0)
	{
    	/* No subfile's name specified, use default */
		*lplszSubFilename = lszDefaultName;
	}
	else
	{
    	/* Copy the index subfile's name */
		*lplszSubFilename = lsztmp;
		lszFName++;	// Skip the !
		while (*lsztmp++ = *lszFName++);
	}
}

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	int PASCAL | IsFsName |
 *
 *		Given a filename, determine if it is a sub-system filename or not
 *		The idea is to search for '!', which is a sub-system filename
 *		delimiter
 *
 *	@parm	LSZ | lszFName |
 *		Pointer to filename to be parsed
 *
 *	@rdesc	TRUE if the name is a sub-system file name, FALSE otherwise
 *************************************************************************/
PUBLIC int PASCAL FAR IsFsName (register LSZ lszFName)
{
	if (lszFName)
	{
		for (; *lszFName; lszFName ++)
		{
			if (*lszFName == '!')
				return TRUE;
		}
	}
	return FALSE;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	int FAR PASCAL | FileFlush |
 *		Flush the file 
 *
 *	@parm	HANDLE | hfpb |
 *		If non-zero, handle to a file parameter block
 *
 *	@rdesc	S_OK if ereything is OK, else various errors
 *************************************************************************/

PUBLIC int FAR PASCAL FileFlush(HFPB hfpb)
{
	HRESULT errDos;
	LPFPB	lpfpb;


	if (hfpb == NULL)
		return E_HANDLE;

	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:
			errDos = E_ASSERT;
			break;

		case FS_SUBFILE:
			errDos=RcFlushHf(lpfpb->fs.hf);
			break;

		case REGULAR_FILE:
			if ((errDos = (WORD)_COMMIT(lpfpb->fs.hFile)) != 0)
				errDos = E_FILEWRITE;
			break;
	}

	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK (hfpb);
	return errDos;
}


/*************************************************************************
 *	@doc	INTERNAL
 *
 *	@func	int FAR PASCAL | FileClose |
 *		Close the file and get rid of the file parameter block
 *
 *	@parm	HANDLE | hfpb |
 *		If non-zero, handle to a file parameter block
 *
 *	@rdesc	S_OK if ereything is OK, else various errors
 *************************************************************************/
#ifndef ITWRAP
PUBLIC HRESULT FAR PASCAL FileClose(HFPB hfpb)
{
	HRESULT rc;
	LPFPB	lpfpb;


	if (hfpb == NULL)
		return E_HANDLE;

	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	rc = S_OK;
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:
			rc = RcCloseHfs(lpfpb->fs.hfs);
			break;

		case FS_SUBFILE:
		{
			HFS hfs=NULL;
			if (lpfpb->ioMode&OPENED_HFS)
				hfs=HfsGetFromHf(lpfpb->fs.hf);	
			rc = RcCloseHf(lpfpb->fs.hf);
			if (hfs)
				rc = RcCloseHfs(hfs);
			break;
		}
		case REGULAR_FILE:
#ifdef _WIN32
			rc = (!CloseHandle(lpfpb->fs.hFile))?ERR_CLOSEFAILED:S_OK;
#else			
			rc = (_lclose(lpfpb->fs.hFile))?ERR_CLOSEFAILED:S_OK;
#endif
			break;
	}

	_LEAVECRITICALSECTION(&lpfpb->cs);
	_DELETECRITICALSECTION(&lpfpb->cs);

	/* Free the file parameter block structure */
	_GLOBALFREE(lpfpb->hStruct);

	return rc;
}
#endif
/*************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	int FAR PASCAL | FileUnlink |
 *		Unlink a file. This function is an example of difference between
 *		platforms. The filename is a far pointer under Windows, but
 *		_unlink() requires a near pointer in medium model. What happens
 *		is that we have to copy the name into an allocated near buffer
 *		for _unlink()
 *
 *	@parm	LPCSTR | lszFilename |
 *		Pointer to filename
 *
 *	@parm	int | iFileType |
 *		Any of FS_SYSTEMFILE, FS_SUBFILE, or REGULAR_FILE.
 *
 *	@rdesc	Return S_OK, ERR_MEMORY, or return value of _unlink()
 *
 *************************************************************************/
PUBLIC HRESULT FAR PASCAL FileUnlink (HFPB hfpbSysFile, LPCSTR lszFilename, int fFileType)
{
	OFSTRUCT ofStruct;
	HRESULT rc;
	HRESULT errb;
	FM fm;

	switch (fFileType)
	{
		case FS_SYSTEMFILE:
			fm = FmNewSzDir((LPSTR)lszFilename, dirCurrent, NULL);
			rc = RcDestroyFileSysFm(fm);
			DisposeFm(fm);
			break;

		case FS_SUBFILE:
		{	
			HFS hfs = GetHfs(hfpbSysFile,lszFilename,TRUE,&errb);
			if (hfs)
			{
				rc=RcUnlinkFileHfs(hfs, GetSubFilename(lszFilename,NULL));
				if (!hfpbSysFile)
				 	RcCloseHfs(hfs);				
			}
			else
				rc=errb;
			break;
		}
		case REGULAR_FILE:
			if ((HFILE) OpenFile(lszFilename, &ofStruct, OF_DELETE) != (HFILE_ERROR))
				rc=S_OK;
			else
				rc=E_FILEDELETE;
			break;

		default:
			rc=E_ASSERT;
	}
	return rc;
}

#if !defined(MOSMAP) // {
#ifdef _NT // {
// Can't have NULL as path... must be a string
WORD EXPORT_API PASCAL FAR GetTempFileNameEx(
	LPCSTR lpszPath,	/* address of name of dir. where temp. file is created	*/
	LPCSTR lpszPrefix,	/* address of prefix of temp. filename	*/
	WORD uUnique,	/* number used to create temp. filename	*/
	LPSTR lpszTempFile	/* address buffer that will receive temp. filename	*/
)
{
	char lpszBuf[_MAX_PATH] ;

	if (!lpszPath)
	{
		if (sizeof(lpszBuf) >= GetTempPath(sizeof(lpszBuf), lpszBuf))
			lpszPath = lpszBuf ;
		else
			// default to current directory
			lpszPath = "." ;
	}

	// Now call the regular function
	return (WORD) GetTempFileName(lpszPath, lpszPrefix, uUnique, lpszTempFile) ;
}
#endif // _NT }
#endif // MOSMAP }



/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	LPFBI PASCAL FAR | FileBufAlloc |
 *		Allocate an I/O buffer associated with a file. This is to speed
 *		up I/O
 *
 *	@parm	HFPB | hfpb |
 *		Handle to file parameter block for an already opened file
 *
 *	@parm	WORD | Size |
 *		Size of the buffer
 *
 *	@rdesc	Pointer to a file buffer info if everything is OK, NULL
 *		if out of memory, or invalid file handle
 *************************************************************************/

PUBLIC LPFBI PASCAL FAR EXPORT_API FileBufAlloc (HFPB hfpb, WORD Size)
{
	LPFBI lpfbi;	/* Pointer to file buffer info */
	LPFPB lpfpb;
	HANDLE hMem;
	/* Sanity check, the file must be already opened */
	if (hfpb == 0)
		return NULL;

	/* Allocate the structure. All fields are zeroed */

	if (!(hMem=_GLOBALALLOC(GMEM_ZEROINIT,sizeof(FBI) + Size)))
	{
	 	return NULL;
	}

	if (!(lpfbi=(LPFBI)_GLOBALLOCK(hMem)))
	{
	 	_GLOBALFREE(hMem);
		return NULL;
	}
	
	/* Initialize the fields */
	lpfbi->lrgbBuf = (LPB)lpfbi + sizeof(FBI);
    lpfbi->hStruct = hMem;

	/* Get the DOS file handle associated with the file parameter block */
	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);
	lpfbi->hFile = lpfpb->fs.hFile;

	/* Update fields */
	lpfbi->cbBufSize = Size;
	lpfbi->hfpb = hfpb;

	/* For read only file, assume the file's size is huge */
	if (lpfpb->ioMode == READ)
		lpfbi->foExtent = foMax;

	_LEAVECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);
	return lpfbi;
}

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	int PASCAL FAR | FileBufFlush |
 *		Flush the buffer to the disk
 *
 *	@parm	LPFBI | lpfbi |
 *		Pointer to file buffer info
 *
 *	@rdesc	S_OK if everything is OK, else errors
 *************************************************************************/

PUBLIC int PASCAL FAR FileBufFlush (LPFBI lpfbi)
{
	LONG lWrote;
	WORD cByteWritten;
	HRESULT errb;
	int fRet;

	/* Sanity check */
	if (lpfbi == NULL)
		return E_INVALIDARG;

	/* Calculate how many bytes are to be written */
	cByteWritten = lpfbi->ibBuf;

	lWrote = FileSeekWrite(lpfbi->hfpb, lpfbi->lrgbBuf,
		lpfbi->foExtent, cByteWritten, &errb);

	fRet=errb;

	if (lWrote==(LONG)cByteWritten)
	{	
		fRet=S_OK;
		/* Update the the current offset into the file */
		lpfbi->foExtent=lpfbi->fo=(FoAddDw(lpfbi->fo,cByteWritten));
		lpfbi->ibBuf = lpfbi->cbBuf = 0;
	}
	return fRet;
}

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	VOID PASCAL FAR | FileBufFree |
 *		Free all memory associated with the file buffer info
 *
 *	@parm	LPFBI | lpfbi |
 *		Pointer to file buffer info
 *************************************************************************/

PUBLIC VOID PASCAL FAR FileBufFree (LPFBI lpfbi)
{
	if (lpfbi == NULL)
		return;
	_GLOBALFREE(lpfbi->hStruct);
}

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	BOOL FAR PASCAL | FileBufRewind |
 *		This function will:
 *			- Flush the file, update the file size
 *			- Reset the logical file offset to 0
 *		It prepares the file for reading
 *		
 *	@parm	LPFBI | lpfbi |
 *		Pointer to file parameter info block
 *
 *	@rdesc	Error code or S_OK
 *************************************************************************/

PUBLIC BOOL FAR PASCAL FileBufRewind (LPFBI lpfbi)
{
	int fRet;

	/* Sanity check */
	if (lpfbi == NULL)
		return E_INVALIDARG;

	/* Flush the buffer. This will reset the size of the file (foExtent) */
	if ((fRet = FileBufFlush(lpfbi)) != S_OK)
		return fRet;

#if 0
	/* Make sure that things go out to disk */
	if ((fRet = FileFlush(lpfbi->hfpb)) != S_OK)
		return fRet;
#endif

	/* Reset the offset of the file */
	lpfbi->fo = foNil;
	return S_OK;
}

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	int FAR PASCAL | FileBufFill |
 *		This function helps with file reads.  It copies the left-over
 *		data in the I/O buffer to the start of the buffer, then fills
 *		the rest of the buffer with new data.
 *	
 *	@parm	LPFBI | lpfbi |
 *		File buffer info.
 *
 *	@parm	PHRESULT | phr |
 *		Error return.
 *
 *	@rdesc	The function returns the number of bytes read, or cbIO_ERROR
 *		if error
 *************************************************************************/

PUBLIC	int FAR PASCAL FileBufFill (LPFBI lpfbi, PHRESULT phr)
{
	WORD  	cbRead;			// Number of bytes read.
	WORD	cbByteLeft;		// Number of bytes left
	DWORD	dwFileByteLeft;

	if (FoCompare(lpfbi->foExtent,lpfbi->fo)<=0)
		return 0;
	
	dwFileByteLeft = FoSubFo(lpfbi->foExtent,lpfbi->fo).dwOffset;
	
	if (lpfbi->cbBuf < lpfbi->ibBuf)
	{
		SetErrCode (phr, E_INVALIDARG);
		return cbIO_ERROR;
	}

	/* Preserve left-over data. */

	if (cbByteLeft = lpfbi->cbBuf - lpfbi->ibBuf)
	{
		MEMCPY(lpfbi->lrgbBuf, lpfbi->lrgbBuf + lpfbi->ibBuf, cbByteLeft);
		lpfbi->ibBuf = 0;
		lpfbi->cbBuf = cbByteLeft;
	}
	else
	{
		/* There is nothing left. The buffer is considered to be empty */
		lpfbi->cbBuf = lpfbi->ibBuf = 0;
	}

	/*	Get new data. */

	cbRead = lpfbi->cbBufSize - cbByteLeft;
	if ((DWORD)cbRead > dwFileByteLeft)
		cbRead = (WORD)dwFileByteLeft;

	if ((cbRead = (WORD)FileSeekRead(lpfbi->hfpb, lpfbi->lrgbBuf + cbByteLeft,
		lpfbi->fo, cbRead, phr)) != cbIO_ERROR)
	{
		lpfbi->cbBuf = cbByteLeft + cbRead;
		lpfbi->fo=FoAddDw(lpfbi->fo,cbRead);		
	}
	return cbRead;
}

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	BOOL FAR PASCAL | FileBufBackPatch |
 *		This function will batchpatch a file at a certain location, in
 *		memory or at a some physical offset
 *
 *	@parm	LPFBI | lpfbi |
 *		Pointer to file buffer info block
 *
 *	@parm	LPV | lpvData |
 *		Pointer to data tempplate
 *
 *	@parm	FO | fo |
 *		File offset to write it at.
 *
 *	@parm	WORD | cbBytes |
 *		How many bytes to write.
 *
 *	@rdesc	Error code of S_OK
 *************************************************************************/

PUBLIC BOOL FAR PASCAL FileBufBackPatch(LPFBI lpfbi, LPV lpvData,
	FILEOFFSET fo, WORD	cbBytes)
{
	HRESULT errb;
	if (FoCompare(fo,lpfbi->fo)>=0)
	{		// Not flushed, do copy.
		MEMCPY(lpfbi->lrgbBuf + (short)FoSubFo(fo,lpfbi->fo).dwOffset, lpvData, cbBytes);
		return S_OK;
	}
	return (FileSeekWrite(lpfbi->hfpb, lpvData, fo, cbBytes, &errb)==(LONG)cbBytes)?S_OK:errb;
}

#ifndef ITWRAP
PRIVATE HANDLE NEAR PASCAL IoftsWin32Create(LPCSTR lpstr, DWORD w)
{
	SECURITY_ATTRIBUTES sa;
	HANDLE hfile;

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = 0;

	hfile= CreateFile(lpstr, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
		&sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	return hfile;
}

PRIVATE HANDLE NEAR PASCAL IoftsWin32Open(LPCSTR lpstr, DWORD w)
{
	SECURITY_ATTRIBUTES sa;

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = 0;

	return CreateFile(lpstr, (w == READ) ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, &sa,OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
}
#endif

/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	HSFB PASCAL FAR | FpbFromHfs |
 *			Allocate a file parameter buffer, set to hfs
 *
 *	@parm	HFS | hfsHandle |
 *			Handle of an HFS system file
 *
 *	@parm	PHRESULT | phr |
 *			Error buffer
 *
 *	@rdesc	Return a pointer to the newly allocated file parameter block
 *			if succeeded, else NULL
 *************************************************************************/

PUBLIC HSFB PASCAL FAR FpbFromHfs(HFS hfsHandle, PHRESULT phr)
{
	HFPB hfpb;
	LPFPB  lpfpb;

    if ((hfpb = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
	    (WORD)sizeof(FPB))) == NULL)
	{
	    SetErrCode(phr, E_OUTOFMEMORY);
	    return NULL;
    }
    lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_INITIALIZECRITICALSECTION(&lpfpb->cs);
    lpfpb->hStruct = hfpb;
    lpfpb->lpvInterCbParms = NULL;
	lpfpb->lpfnfInterCb = NULL;	  
	lpfpb->fFileType=FS_SYSTEMFILE;
	lpfpb->fs.hfs = (HFS)hfsHandle;
	_GLOBALUNLOCK(hfpb);

	return hfpb;
}


/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	HSFB PASCAL FAR | FpbFromHf |
 *			Allocate a file parameter buffer, set to hf
 *
 *	@parm	HF | hfHandle |
 *			Handle of a subfile.
 *
 *	@parm	PHRESULT | phr |
 *			Error buffer
 *
 *	@rdesc	Return a pointer to the newly allocated file parameter block
 *			if succeeded, else NULL
 *************************************************************************/

PUBLIC HSFB PASCAL FAR FpbFromHf(HF hfHandle, PHRESULT phr)
{
	HFPB hfpb;
	LPFPB  lpfpb;

    if ((hfpb = _GLOBALALLOC(GMEM_MOVEABLE | GMEM_ZEROINIT,
	    (WORD)sizeof(FPB))) == NULL)
	{
	    SetErrCode(phr, E_OUTOFMEMORY);
	    return NULL;
    }
    lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
    lpfpb->hStruct = hfpb;
    lpfpb->lpvInterCbParms = NULL;
	lpfpb->lpfnfInterCb = NULL;	  
	lpfpb->fFileType=FS_SUBFILE;
	lpfpb->fs.hf = (HF)hfHandle;
	_INITIALIZECRITICALSECTION(&lpfpb->cs);
	_GLOBALUNLOCK(hfpb);

	return hfpb;
}


/*************************************************************************
 *	@doc	PRIVATE
 *
 *	@func	DWORD PASCAL FAR | FsTypeFromHfpb |
 *			Returns the type of file pointed to by a FPB.
 *
 *	@parm	HFPB | hfpb |
 *			Handle to a file parameter block.
 *
 *	@rdesc	Returns one of the following if successful:
 *			FS_SYSTEMFILE, FS_SUBFILE, REGULARFILE
			Returns 0 if unsuccessful.
 *************************************************************************/

PUBLIC DWORD PASCAL FAR FsTypeFromHfpb(HFPB hfpb)
{
	LPFPB	lpfpb;
	DWORD	dwFileType = 0;

	if (hfpb != NULL)
	{
		lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
		_ENTERCRITICALSECTION(&lpfpb->cs);
		dwFileType = (DWORD) lpfpb->fFileType;
		_LEAVECRITICALSECTION(&lpfpb->cs);
		_GLOBALUNLOCK(hfpb);
	}

	return (dwFileType);
}

// Frees the critical section and the HFPB
PUBLIC VOID PASCAL FAR FreeHfpb(HFPB hfpb)
{
 	LPFPB  lpfpb;

    lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_DELETECRITICALSECTION(&lpfpb->cs);

    _GLOBALUNLOCK(hfpb);
    _GLOBALFREE(hfpb);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\iterr.c ===
#include <mvopsys.h>
#include <iterror.h>

/****************************************************************************
 *
 *	@func	HRESULT SetErr |
 *    Save the error and its location into the error buffer
 *	@parm	HRESULT* phr |
 *    Pointer to the hresult
 *	@parm	HRESULT ErrCode |
 *    Error code
 * @parm	int iUserCode |
 *    Any information that the SDE wants to associate with the error
 * @rdesc
 *    The error code
 ****************************************************************************/
HRESULT PASCAL SetErr (PHRESULT phr, HRESULT ErrCode)
{
	if (phr == NULL)
		return ErrCode;

    return (*phr = ErrCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\itdfguid.h ===
// This files is where I am going to put all the GUID fixups for the 64bit project
#ifdef IA64

#define INITGUID
#include <guiddef.h>
// #include <coguid.h>
 // allocate from section:
#pragma section(".rdata")
#define RDATA_SECTION __declspec(allocate(".rdata"))

EXTERN_C RDATA_SECTION const GUID IID_IDispatch;

EXTERN_C RDATA_SECTION const GUID IID_IPersistStreamInit;
EXTERN_C RDATA_SECTION const GUID IID_IPersistStream;
EXTERN_C RDATA_SECTION const GUID IID_IPersistStorage;

EXTERN_C RDATA_SECTION const GUID IID_IConnectionPointContainer;

EXTERN_C RDATA_SECTION const GUID IID_IErrorInfo;

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

#else
	#pragma message("itdfguid.h is IA64 specific!")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\str.c ===
/*****************************************************************************
 *
 *  STR.C
 *
 *  Copyright (C) Microsoft Corporation 1990 - 1994.
 *  All Rights reserved.
 *
 ******************************************************************************
 *
 *  Module Intent
 *   String abstraction layer for WIN/PM
 *
 ******************************************************************************
 *
 *  Testing Notes
 *
 ******************************************************************************
 *
 *  Current Owner: UNDONE  
 *
 ******************************************************************************
 *
 *  Released by Development:     (date)
 *
 ******************************************************************************
 *
 *  Revision History:
 *       -- Mar 92.  Adapted from WinHelps STR.C. DAVIDJES
 *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;	/* For error report */


#include <mvopsys.h>
#include <orkin.h>
#include <string.h>
#include <misc.h>
#include <iterror.h>
#include <wrapstor.h>
#include <_mvutil.h>

/* Put all functions into the same segment to avoid memory fragmentation
 * and load time surplus for the MAC
 */
// #pragma code_seg ("MVFS")

/***************************************************************************
 *
 -  Name:        SzNzCat(szDest, szSrc, cch)
 -
 *  Purpose:
 *    concatenation of szSrc to szDest up to cch characters.  make sure
 *    the destination is still \000 terminated.  will copy up to cch-1
 *    characters.  this means that cch should account for the \000 when
 *    passed in.
 *
 *  Arguments:
 *    szDest - the SZ to append onto
 *    szSrc  - the SZ which will be appended to szDest
 *    cch    - the max count of characters to copy and space for the \000
 *
 *  Returns:
 *    szDest
 *
 *  Globals Used:
 *
 *  +++
 *
 *  Notes:
 *
 ***************************************************************************/
SZ FAR PASCAL SzNzCat(SZ szDest, SZ szSrc, WORD cch)
{
	SZ  sz = szDest+lstrlen(szDest);

	STRNCPY(sz, szSrc, cch);
	*(sz + cch) = '\000';

	return szDest;
}




/***************************************************************************
 *
- Function:     WCmpSt(st1, st2)
-
 * Purpose:      Compare two STs for equality.
 *
 * ASSUMES
 *
 *   args IN:    st1, st2 - the STs to compare
 *
 * PROMISES
 *
 *   returns:    -1 for st1 < st2; 0 for st1 == st2; 1 for st1 > st2
 *
 ***************************************************************************/
SHORT FAR PASCAL WCmpSt(st1, st2)
ST  st1, st2;
{
	unsigned char cb;
	char          dcb = *st1 - *st2, dch = 0;


	for (cb = min( *st1, *st2), st1++, st2++; cb > 0; cb++, st1++, st2++ )
		{
		if (dch = *st1 - *st2) break;
		}

	if (dch)
		return dch < 0 ? -1 : 1;

	return dcb < 0 ? -1 : (dcb > 0 ? 1 : 0);
}

/*******************************************************************
 *
 *  The following stuff is for international string comparisons.
 *  These functions are insensitive to case and accents.  For a
 *  function that distinguishes between all char values, we use
 *  _fstrcmp(), which behaves just like strcmp().
 *
 *  The tables in maps.h were generated from the ones used in help 2.5
 *  which were stolen from Opus international stuff.
 *
 *  There are two loops for speed.  These should be redone in assembly.
 *
 *******************************************************************/

#include "maps.h" /* the two mapping tables */









/*------------------------------------ WCmpiSz -----------------------------*/
SHORT FAR PASCAL WCmpiSz(SZ lpstrOne, SZ lpstrTwo, BYTE far *qbLigatures)

/**************************************************
OWNER: Matthew W. Smith (MATTSMI)
DATE DOCUMENTED: March 5, 1992

@doc INTERNAL

@api int FAR PASCAL | WCmpiSz | compares two LPSTRs
			   without case sensitivity.

@parm LPSTR | lpstrOne | first string for comparison.

@parm LPSTR | lpstrTwo | other string for comparison.

@parm BYTE far * | qbLigatures | ligature table loaded from the
			      file system or from hardwiring (by default).

@comm
		 This routine is analogous to strcmpi() except it
		 uses long pointers.  It is unlike lstrcmpi() in
		 that it is truly case insensitive.

	 This routine is unlike CompareLPSTRi in that it works
	 off of Microsoft's standard internal international
	 character set table.

		 The return value is:

		 0    if lpstrOne = lpstrTwo
		 1    if lpstrOne > lpstrTwo
		 -1   if lpstrOne < lpstrTwo

		NOTE: this version differs from CompareTableLPSTRi() in that
		ligature expansion (which is viewer-compiler specific is undertaken).
		This is done by drawing on a ligature table (LPSTR) kept globally
		during compilation -- see LoadLigatureTable().

		This routine draws on the standard Help character sort order
		table in utilib.c -- it is an extern global here.

		NOTE: this routine assumes that the ligature table available
		to it (rgchLigatureSortTableGlobal) uses the OEM and not ANSI character
		set.

 ***************************************************/

/*-----------------------------------------------------------------------*/
{       /*** WCmpiSz ***/

		 int  i=0, j=0;
		 unsigned char ch1, ch2, ch;
		 BYTE cLigs, c;
		 unsigned char ch1Next='\0';
		 unsigned char ch2Next='\0';
		 BOOL fDontExpandCh1=FALSE;
		 BOOL fDontExpandCh2=FALSE;


		 if (!qbLigatures)
			  cLigs=0;
		 else
			   cLigs=qbLigatures[0];

		 ch1=lpstrOne[0];
		 ch2=lpstrTwo[0];

		 while (ch1 && ch2)
		 {
			  /***************************
			  CHECK FOR LIGATURE EXPANSION
			  ****************************/
			  for (c=1; c<=cLigs; c++)
			  {
			      ch=qbLigatures[(c-1)*3+1];

			      if (!fDontExpandCh1 && (ch1 == ch))
			      {
			          ch1=qbLigatures[(c-1)*3+2];
			          ch1Next=qbLigatures[(c-1)*3+3];
			      }

			      if (!fDontExpandCh2 && (ch2 == ch))
			      {
			          ch2=qbLigatures[(c-1)*3+2];
			          ch2Next=qbLigatures[(c-1)*3+3];
			      }
			  }

			  ch1=mpchordNorm[ch1];
			  ch2=mpchordNorm[ch2];
			  fDontExpandCh1=FALSE;
			  fDontExpandCh2=FALSE;

			  /*************************************************
			  EITHER BREAK BECAUSE THE CHARACTERS WERE DIFFERENT
			  OR GET THE NEXT CHARACTER FOR COMPARISION
			  **************************************************/
			  if (ch1 != ch2)
			   break;
			else
			  {
			      if (ch1Next)
			      {
			          ch1=ch1Next;
			          ch1Next='\0';
			          fDontExpandCh1=TRUE;    // SETTING THIS FLAG PREVENTS ENDLESS RECURSION
			      }
			      else ch1=lpstrOne[++i];

			      if (ch2Next)
			      {
			          ch2=ch2Next;
			          ch2Next='\0';
			          fDontExpandCh2=TRUE;    // SETTING THIS FLAG PREVENTS ENDLESS RECURSION
			      }
			      else ch2=lpstrTwo[++j];
			  }
		 }

		 /**********************************
		 IF STRINGS BOTH TERMINATED AT THE
		 SAME TIME WITHOUT DIFF BEING FOUND
		 THEY ARE THE SAME
		 ***********************************/
		 if (!ch1 && !ch2)
		return(0);


		 /**************************************
		 IF ONE TERMINATED AND NO DIFF WAS
		 FOUND WHEN IT DID, THEN THE TERMINATING
		 STRING COMES FIRST . . .
		 ***************************************/
		 if (!ch1)
		return(-1);
		 else if (!ch2)
		return(1);


		 /*********************************
		 DIFF WAS FOUND; RETURN ACCORDINGLY
		 **********************************/
		 if (ch1 < ch2)
		return(-1);
		 else
		return(1);

}       /*** WCmpiSz ***/
/*-----------------------------------------------------------------------*/






SHORT FAR PASCAL WCmpiSnn(SZ lpstrOne, SZ lpstrTwo, BYTE far *qbLigatures, SHORT iLen1, SHORT iLen2)

/**************************************************
OWNER: Matthew W. Smith (MATTSMI)
DATE DOCUMENTED: March 5, 1992

@doc INTERNAL

@api int FAR PASCAL | WCmpiSnn | compares two LPSTRs
			   without case sensitivity, given lengths of strings

@parm LPSTR | lpstrOne | first string for comparison.

@parm LPSTR | lpstrTwo | other string for comparison.

@parm BYTE far * | qbLigatures | ligature table loaded from the
			      file system or from hardwiring (by default).

@parm SHORT | iLenOne |
	Length of first string

@parm SHORT | iLenTwo |
	Length of second string

@comm
		 This routine is analogous to strcmpi() except it
		 uses long pointers.  It is unlike lstrcmpi() in
		 that it is truly case insensitive.

	 This routine is unlike CompareLPSTRi in that it works
	 off of Microsoft's standard internal international
	 character set table.

		 The return value is:

		 0    if lpstrOne = lpstrTwo
		 1    if lpstrOne > lpstrTwo
		 -1   if lpstrOne < lpstrTwo

		NOTE: this version differs from CompareTableLPSTRi() in that
		ligature expansion (which is viewer-compiler specific is undertaken).
		This is done by drawing on a ligature table (LPSTR) kept globally
		during compilation -- see LoadLigatureTable().

		This routine draws on the standard Help character sort order
		table in utilib.c -- it is an extern global here.

		NOTE: this routine assumes that the ligature table available
		to it (rgchLigatureSortTableGlobal) uses the OEM and not ANSI character
		set.

 ***************************************************/

/*-----------------------------------------------------------------------*/
{       /*** WCmpiSz ***/

		 int  i=0, j=0;
		 unsigned char ch1, ch2, ch;
		 BYTE cLigs, c;
		 unsigned char ch1Next='\0';
		 unsigned char ch2Next='\0';
		 BOOL fDontExpandCh1=FALSE;
		 BOOL fDontExpandCh2=FALSE;


		 if (!qbLigatures)
			  cLigs=0;
		 else
			   cLigs=qbLigatures[0];

		 ch1=(iLen1)?lpstrOne[0]:0;
		 ch2=(iLen2)?lpstrTwo[0]:0;

		 while (ch1 && ch2)
		 {
			  /***************************
			  CHECK FOR LIGATURE EXPANSION
			  ****************************/
			  for (c=1; c<=cLigs; c++)
			  {
			      ch=qbLigatures[(c-1)*3+1];

			      if (!fDontExpandCh1 && (ch1 == ch))
			      {
			          ch1=qbLigatures[(c-1)*3+2];
			          ch1Next=qbLigatures[(c-1)*3+3];
			      }

			      if (!fDontExpandCh2 && (ch2 == ch))
			      {
			          ch2=qbLigatures[(c-1)*3+2];
			          ch2Next=qbLigatures[(c-1)*3+3];
			      }
			  }

			  ch1=mpchordNorm[ch1];
			  ch2=mpchordNorm[ch2];
			  fDontExpandCh1=FALSE;
			  fDontExpandCh2=FALSE;

			  /*************************************************
			  EITHER BREAK BECAUSE THE CHARACTERS WERE DIFFERENT
			  OR GET THE NEXT CHARACTER FOR COMPARISION
			  **************************************************/
			  if (ch1 != ch2)
			   break;
			else
			  {
			      if (ch1Next)
			      {
			          ch1=ch1Next;
			          ch1Next='\0';
			          fDontExpandCh1=TRUE;    // SETTING THIS FLAG PREVENTS ENDLESS RECURSION
			      }
			      else 
			      	  ch1=((++i)==iLen1)?0:lpstrOne[i];
			      	  //ch1=lpstrOne[++i];
				  
			      if (ch2Next)
			      {
			          ch2=ch2Next;
			          ch2Next='\0';
			          fDontExpandCh2=TRUE;    // SETTING THIS FLAG PREVENTS ENDLESS RECURSION
			      }
			      else 
			      	ch2=((++j)==iLen2)?0:lpstrTwo[j];
			      	//ch2=lpstrTwo[++j];
			  }
		 }

		 /**********************************
		 IF STRINGS BOTH TERMINATED AT THE
		 SAME TIME WITHOUT DIFF BEING FOUND
		 THEY ARE THE SAME
		 ***********************************/
		 if (!ch1 && !ch2)
		return(0);


		 /**************************************
		 IF ONE TERMINATED AND NO DIFF WAS
		 FOUND WHEN IT DID, THEN THE TERMINATING
		 STRING COMES FIRST . . .
		 ***************************************/
		 if (!ch1)
		return(-1);
		 else if (!ch2)
		return(1);


		 /*********************************
		 DIFF WAS FOUND; RETURN ACCORDINGLY
		 **********************************/
		 if (ch1 < ch2)
		return(-1);
		 else
		return(1);

}       /*** WCmpiSz ***/
/*-----------------------------------------------------------------------*/











/***************************************************************************
 *
- Function:     WCmpiScandSz(sz1, sz2)
-
 * Purpose:      Compare two SZs, case insensitive.  Scandinavian
 *               international characters are OK.
 *
 * ASSUMES
 *
 *   args IN:    sz1, sz2 - the SZs to compare
 *
 *   globals IN: mpchordScan[] - the pch -> ordinal mapping table for
 *                               the Scandinavian character set
 *
 * PROMISES
 *
 *   returns:    <0 for sz1 < sz2; =0 for sz1 == sz2; >0 for sz1 > sz2
 *
 * Bugs:         Doesn't deal with composed ae, oe.
 *
 ***************************************************************************/
SHORT FAR PASCAL WCmpiScandSz(sz1, sz2)
SZ sz1, sz2;
{
	while (0 == (int)( (unsigned char)*sz1 - (unsigned char)*sz2) )
		{
		if ('\0' == *sz1) return 0;
		sz1++; sz2++;
		}

	while (0 == ( mpchordScan[(unsigned char)*sz1] - mpchordScan[(unsigned char)*sz2]) )
		{
		if ('\0' == *sz1) return 0;
		sz1++; sz2++;
		}

	return mpchordScan[(unsigned char)*sz1] - mpchordScan[(unsigned char)*sz2];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\itutils.cpp ===
/*************************************************************************
*                                                                        *
*  ITUTILS.CPP                                                           *
*                                                                        *
*  Copyright (C) Microsoft Corporation 1997		                         *
*  All Rights reserved.                                                  *
*                                                                        *
**************************************************************************
*                                                                        *
*  Module Intent                                                         *
*    Provide a place to put miscellaneous utility routines.				 *
*                                                                        *
**************************************************************************
*                                                                        *
*  Current Owner: InfoTech Team                                          *
*                                                                        *
*************************************************************************/
#include <mvopsys.h>

#ifdef _DEBUG
static char s_aszModule[] = __FILE__;   /* For error report */
#endif

#include <mem.h>
#include <orkin.h>
#include <iterror.h>

#ifdef __cplusplus
extern "C" {
#endif

/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   HRESULT FAR PASCAL | ReallocBufferHmem |
 *              This function will reallocate or allocate anew a buffer of
 *				requested size.
 *
 *      @parm   HGLOBAL | *phmemBuf |
 *              Pointer to buffer handle; buffer handle can be NULL if
 *				a new buffer needs to be allocated.  New buffer handle
 *				is returned through this param.
 *
 *      @parm   DWORD | *pcbBufCur |
 *              Current size of existing buffer, if any.  Should be
 *				0 if *phmemBuf == 0.  New size is returned through
 *				this param.
 *
 *      @parm   DWORD | cbBufNew |
 *              Current size of existing buffer, if any.  Should be
 *				0 if *phmemBuf == 0.
 *
 *		@rvalue E_POINTER | phmemBuf or pcbBufCur was NULL
 *		@rvalue E_OUTOFMEMORY | Ran out of memory (re)allocating the buffer.
 *************************************************************************/
HRESULT FAR PASCAL ReallocBufferHmem(HGLOBAL *phmemBuf, DWORD *pcbBufCur,
															DWORD cbBufNew)
{
	HRESULT hr = S_OK;

	if (phmemBuf == NULL || pcbBufCur == NULL)
		return (E_POINTER);

	// Need to make sure we have a buffer big enough to hold what the caller
	// needs to store.
	if (cbBufNew > *pcbBufCur)
	{
		HGLOBAL	hmemNew;

		if (*phmemBuf == NULL)
			hmemNew = _GLOBALALLOC(GMEM_MOVEABLE, cbBufNew);
		else
			hmemNew = _GLOBALREALLOC(*phmemBuf, cbBufNew, GMEM_MOVEABLE);

		if (hmemNew != NULL)
		{
			// Do reassignment just in case the new hmem is different
			// than the old or if we just allocated a buffer for the
			// first time.
			*phmemBuf = hmemNew;
			*pcbBufCur = cbBufNew;
		}
		else
			// A pre-existing *phmemBuf is still valid;
			// we'll free it in Close().
			hr = E_OUTOFMEMORY;
	}

	return (hr);
}


/*************************************************************************
 *      @doc    INTERNAL
 *
 *      @func   void FAR PASCAL | SetGrfFlag |
 *              Sets or clears a bit flag in a group of flags.
 *
 *      @parm   DWORD | *pgrf |
 *              Pointer to the group of flags.
 *
 *      @parm   DWORD | fGrfFlag |
 *              Flag to set or clear.
 *
 *      @parm   BOOL | fSet |
 *              TRUE to set fGrfFlag; FALSE to clear fGrfFlag.
 *************************************************************************/
void FAR PASCAL SetGrfFlag(DWORD *pgrf, DWORD fGrfFlag, BOOL fSet)
{
	if (pgrf == NULL)
		return;
	
	*pgrf &= (~fGrfFlag);
	if (fSet)
		*pgrf |= fGrfFlag;
}


/*
Memory Maps a give file for Read-Only, sequential access
Return a pointer to the memory mapped address space and sets
pdwFileSize to the size of the file if it is not NULL.
*/
LPSTR MapSequentialReadFile(LPCSTR szFilename, LPDWORD pdwFileSize)
{
    LPSTR pMemory;
    HANDLE hInput, hMemMap;

    if (NULL == szFilename)
        return NULL;

    // Open input file
    hInput = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ,
        NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (INVALID_HANDLE_VALUE == hInput)
        return NULL;

    // Get the file size for the user
    if (pdwFileSize)
        *pdwFileSize = GetFileSize(hInput, NULL);

    // Create file mapping object
    hMemMap = CreateFileMapping(hInput, NULL, PAGE_READONLY, 0, 0, NULL);
    CloseHandle(hInput);  // Done with this handle
    if (NULL == hMemMap)
        return NULL;

    // Link the object to memory space
    pMemory =(LPSTR)MapViewOfFile(hMemMap, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hMemMap);  // Done with this handle

    return pMemory;
} /* MapSequentialReadFile */



// This routine was extracted from the C runtime, simplified, and renamed.
/***
*int _wcsicmp(dst, src) - compare wide-character strings, ignore case
*
*Purpose:
*       _wcsicmp perform a case-insensitive wchar_t string comparision.
*
*Entry:
*       wchar_t *dst, *src - strings to compare
*
*Return:
*       <0 if dst < src
*        0 if dst = src
*       >0 if dst > src
*       This range of return values may differ from other *cmp/*coll functions.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _it_wcsicmp (
        const wchar_t * dst,
        const wchar_t * src
        )
{
        wchar_t f,l;

        do  {
            f = ((*dst <= L'Z') && (*dst >= L'A'))
                ? *dst + L'a' - L'A'
                : *dst;
            l = ((*src <= L'Z') && (*src >= L'A'))
                ? *src + L'a' - L'A'
                : *src;
            dst++;
            src++;
        } while ( (f) && (f == l) );

        return (int)(f - l);
}


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btfill.c ===
/*****************************************************************************
 *                                                                            *
 *  BTFILL.C                                                                  *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1990 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for creating a btree by adding keys in order.  This is faster   *
 *  and the resulting btree is more compact and has adjacent leaf nodes.      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  Binhn                                                     *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Revision History:  Created 08/17/90 by JohnSc
 *
 *  11/12/90  JohnSc   RcFillHbt() wasn't setting rcBtreeError to S_OK
 *  11/29/90  RobertBu #ifdef'ed out routines that are not used under
 *                     windows.
 *
 *****************************************************************************/

static char s_aszModule[]= __FILE__;	/* For error report */


#include <mvopsys.h>
#include <orkin.h>
#include <iterror.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>

/*************************************************************************
 *
 *	                  INTERNAL PRIVATE FUNCTIONS
 *
 *	All of them should be declared near
 *
 *************************************************************************/

PRIVATE HRESULT NEAR PASCAL RcGrowCache(QBTHR);
PRIVATE KEY NEAR PASCAL KeyLeastInSubtree(QBTHR, BK, SHORT, LPVOID);

/***************************************************************************
 *
 * @doc	INTERNAL
 *
 * @func HRESULT NEAR PASCAL | RcGrowCache |
 *		Grow the cache by one level.
 *
 * @parm QBTHR | qbthr |
 *		Pointer to B-tree
 *
 * @rdesc rc
 *   args OUT:   qbthr->bth.cLevels - incremented
 *               qbthr->bth.ghCache - locked
 *               qbthr->bth.qCache  - points to locked ghCache
 *
 * Note:         Root is at level 0, leaves at level qbthr->bth.cLevels - 1.
 *
 ***************************************************************************/
PRIVATE HRESULT NEAR PASCAL RcGrowCache(QBTHR qbthr)
{
	HANDLE  gh;
	QB      qb;
	SHORT     cbcb = CbCacheBlock(qbthr);


	qbthr->bth.cLevels++;

	/* Allocate a new cache block
	 */

	if ((gh =  _GLOBALALLOC(GMEM_SHARE| GMEM_MOVEABLE | GMEM_ZEROINIT,
		(LONG)cbcb * qbthr->bth.cLevels)) == NULL) {
		return E_OUTOFMEMORY;
	}

	qb = (QB)_GLOBALLOCK(gh);

	/* Copy the old data */

	QVCOPY(qb + cbcb, qbthr->qCache,
		(LONG)cbcb * (qbthr->bth.cLevels - 1));

	/* Remove the old cache */

	_GLOBALUNLOCK(qbthr->ghCache);
	_GLOBALFREE(qbthr->ghCache);

	/* Update pointer to the new block */

	qbthr->ghCache = gh;
	qbthr->qCache = qb;

	return S_OK;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	KEY NEAR PASCAL | KeyLeastInSubtree |
 *		Return the least key in the subtree speced by bk and icbLevel.
 *
 *	@parm	QBTHR | qbthr |
 *		Pointer to B-tree
 *
 *	@parm	BK | bk |
 *		bk at root of subtree
 *
 *	@parm	SHORT | icbLevel |
 *		level of subtree root
 *
 * 	@rdesc	key - the smallest key in the subtree
 *			-1 if error
 *
 *	@comm	qbthr->ghCache, ->qCache - contents of cache may change
 *
 ***************************************************************************/

PRIVATE KEY NEAR PASCAL KeyLeastInSubtree(QBTHR qbthr, BK bk,
    SHORT icbLevel, PHRESULT phr)
{
	QCB qcb;
	SHORT icbMost = qbthr->bth.cLevels - 1;

	while (icbLevel < icbMost)
	{
		if ((qcb = QFromBk(bk, icbLevel, qbthr, phr)) == NULL)
			return (KEY)-1;
		bk  = *(BK UNALIGNED *UNALIGNED)qcb->db.rgbBlock;
		++icbLevel;
	}

	if ((qcb = QFromBk(bk, icbLevel, qbthr, phr)) == NULL)
		return ((KEY)-1);
	return (KEY)qcb->db.rgbBlock + 2 * sizeof(BK);
}

/***************************************************************************
 *
 *	@doc	PUBLIC API
 *
 *	@func	HBT PASCAL FAR | HbtInitFill |
 *		Start the btree fill process.  Note that the HBT returned
 *		is NOT a valid btree handle.
 *
 *	@parm	LPSTR | sz |
 *		btree name
 *
 *	@parm	BTREE_PARAMS FAR * | qbtp |
 *		btree creation parameters
 *
 *	@rdesc an HBT that isn't a valid btree handle until RcFiniFillHbt()
 *		is called on it (with intervening RcFillHbt()'s)
 *		The only valid operations on this HBT are
 *		RcFillHbt()     - add keys in order one at a time
 *		RcAbandonHbt()  - junk the hbt
 *		RcFiniFillHbt() - finish adding keys.  After this, the
 *		hbt is a normal btree handle.
 *
 *	@comm	Method:
 *		Create a btree.  Create a single-block cache.
 *
 ***************************************************************************/
PUBLIC HBT PASCAL FAR EXPORT_API HbtInitFill(LPSTR sz,
	BTREE_PARAMS FAR *qbtp, PHRESULT phr)
 {
	HBT   hbt;
	QBTHR qbthr;
	QCB   qcb;


	// Get a btree handle

	if ((hbt = HbtCreateBtreeSz(sz, qbtp, phr)) == 0)
		return 0;
	
	qbthr = (QBTHR)_GLOBALLOCK(hbt);


	// make a one-block cache

	if ((qbthr->ghCache =  _GLOBALALLOC(GMEM_ZEROINIT|GMEM_SHARE| GMEM_MOVEABLE,
		(LONG)CbCacheBlock(qbthr))) == NULL)
	{
		SetErrCode (phr, E_OUTOFMEMORY);
		_GLOBALUNLOCK(hbt);
		RcAbandonHbt(hbt);
		return 0;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);
	qcb = (QCB)qbthr->qCache;

	qbthr->bth.cLevels  = 1;
	qbthr->bth.bkFirst  = qbthr->bth.bkLast = qcb->bk = BkAlloc(qbthr, phr);
	qcb->bFlags         = fCacheDirty | fCacheValid;
	qcb->db.cbSlack     = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                    - 2 * sizeof(BK);
	qcb->db.cKeys       = 0;

	SetBkPrev(qcb, bkNil);

	_GLOBALUNLOCK(qbthr->ghCache);
	_GLOBALUNLOCK(hbt);
	return hbt;
}

/***************************************************************************
 *
 *	@doc	PUBLIC API
 *
 *	@func	HRESULT PASCAL FAR | RcFillHbt |
 *		Add a key and record (in order) to the "HBT" given.
 *               
 *	@parm	HBT | hbt |
 *		NOT a valid hbt:  it was produced with HbtInitFill().
 *
 *	@parm	KEY | key |
 *		key to add.  Must be greater than all keys previously added.
 *
 *               qvRec- record associated with key
 *
 * PROMISES
 *   returns:    error code
 *   args OUT:   hbt - key, record added
 * +++
 *
 * Method:       If key and record don't fit in current leaf, allocate a
 *               new one and make it the current one.
 *               Add key and record to current block.
 *
 ***************************************************************************/
HRESULT PASCAL FAR EXPORT_API RcFillHbt(HBT hbt, KEY key, QV qvRec)
{
	QBTHR qbthr;
	QCB   qcb;
	SHORT   cbRec, cbKey;
	QB    qb;
	HRESULT rc;


	/* Sanity check */
	if (hbt == 0 || key == 0 || qvRec == NULL)
		return E_INVALIDARG;

	qbthr = (QBTHR)_GLOBALLOCK(hbt);
	qcb = (QCB)_GLOBALLOCK(qbthr->ghCache);

	cbRec = CbSizeRec(qvRec, qbthr);
	cbKey = CbSizeKey(key, qbthr, FALSE);

	// Make sure key and record aren't too big for even an empty block.
	if (cbRec + cbKey > (qbthr->bth.cbBlock / 2))
	{
		_GLOBALUNLOCK(qbthr->ghCache);
		_GLOBALUNLOCK(hbt);
		return E_INVALIDARG;
	}

	if (cbRec + cbKey > qcb->db.cbSlack) {

		// key and rec don't fit in this block: write it out
		SetBkNext(qcb, BkAlloc(qbthr, NULL));
		if ((rc = RcWriteBlock(qcb, qbthr)) != S_OK)
		{
			_GLOBALUNLOCK(qbthr->ghCache);
			_GLOBALFREE(qbthr->ghCache);
			RcAbandonHf(qbthr->hf);
			_GLOBALUNLOCK(hbt);
			_GLOBALFREE(hbt);
			return rc;
		}

		// recycle the block

		SetBkPrev(qcb, qcb->bk);
		qcb->bk         = BkNext(qcb);
		qcb->bFlags     = fCacheDirty | fCacheValid;
		qcb->db.cbSlack = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                  - 2 * sizeof(BK);
		qcb->db.cKeys   = 0;
		
	}

	// add key and rec to the current block;

	qb = (QB)&(qcb->db) + qbthr->bth.cbBlock - qcb->db.cbSlack;
	QVCOPY(qb, (QV)key, (LONG)cbKey);
	QVCOPY(qb + cbKey, qvRec, (LONG)cbRec);
	qcb->db.cKeys++;
	qcb->db.cbSlack -= (cbKey + cbRec);
	qbthr->bth.lcEntries++;
	_GLOBALUNLOCK(qbthr->ghCache);
	_GLOBALUNLOCK(hbt);

	return S_OK;
}

/***************************************************************************
 *
 *	@doc	PUBLIC API 
 *
 *	@func	HRESULT PASCAL FAR | RcFiniFillHbt |
 *		Complete filling of the hbt.  After this call, the hbt is a valid
 *		btree handle.
 *
 *	@parm	HBT | hbt |
 *		NOT a valid hbt:  created with RcInitFillHbt()
 *		and filled with keys & records by RcFillHbt().
 *
 *	@rdesc	error code 
 *		hbt - a valid hbt (on S_OK)
 *
 *	@comm	Take the first key of each leaf block, creating a layer
 *		of internal nodes.
 *		Take the first key in each node in this layer to create
 *		another layer of internal nodes.  Repeat until we get
 *		we get a layer with only one node.  That's the root.
 *
 ***************************************************************************/
PUBLIC HRESULT PASCAL FAR EXPORT_API RcFiniFillHbt(HBT hbt)
{
	BK    bkThisMin, bkThisMost, bkThisCur,  // level being scanned
		  bkTopMin, bkTopMost;               // level being created
	QBTHR qbthr;
	QCB   qcbThis, qcbTop;
	SHORT   cbKey;
	KEY   key;
	QB    qbDst;
	HRESULT    rc = S_OK;


	if ((qbthr = (QBTHR)_GLOBALLOCK(hbt)) == NULL)
		return E_INVALIDARG;

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);  // we know cache is valid

	qcbThis = QCacheBlock(qbthr, 0);

	SetBkNext(qcbThis, bkNil);

	bkThisMin  = qbthr->bth.bkFirst;
	bkThisMost = qbthr->bth.bkLast  = qcbThis->bk;


	if (bkThisMin == bkThisMost)
	{    // only one leaf
		qbthr->bth.bkRoot = bkThisMin;
		goto normal_return;
	}

	if ((rc = RcGrowCache( qbthr)) != S_OK)
	{
		goto error_return;
	}

	qcbTop              = QCacheBlock(qbthr, 0);
	qcbTop->bk          = bkTopMin = bkTopMost = BkAlloc(qbthr, NULL);
	qcbTop->bFlags      = fCacheDirty | fCacheValid;
	qcbTop->db.cbSlack  = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                      - sizeof(BK);
	qcbTop->db.cKeys    = 0;
	
	// Get first key from each leaf node and build a layer of internal nodes.

	// add bk of first leaf to the node

	qbDst = qcbTop->db.rgbBlock;
	*(BK UNALIGNED *UNALIGNED)qbDst = bkThisMin;
	qbDst += sizeof(BK);

	for (bkThisCur = bkThisMin + 1; bkThisCur <= bkThisMost; ++bkThisCur)
	{
		qcbThis = QFromBk(bkThisCur, 1, qbthr, NULL);

		key = (KEY)(qcbThis->db.rgbBlock + 2 * sizeof( BK));
		cbKey = CbSizeKey(key, qbthr, FALSE);

		if ((SHORT)(cbKey + sizeof( BK)) > qcbTop->db.cbSlack)
		{
			// key and bk don't fit in this block: write it out
			rc = RcWriteBlock(qcbTop, qbthr);

			// recycle the block
			qcbTop->bk = bkTopMost = BkAlloc(qbthr, NULL);
			qcbTop->db.cbSlack  = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                        - sizeof(BK); // (bk added below)
			qcbTop->db.cKeys    = 0;
			qbDst = qcbTop->db.rgbBlock;
		}
		else {
			qcbTop->db.cbSlack -= cbKey + sizeof(BK);
			QVCOPY(qbDst, (QB)key, cbKey);
			qbDst += cbKey;
			qcbTop->db.cKeys++;
		}

		*(BK UNALIGNED *UNALIGNED)qbDst = bkThisCur;
		qbDst += sizeof(BK);
	}


	// Keep adding layers of internal nodes until we have a root.

	while (bkTopMost > bkTopMin)
	{
		bkThisMin  = bkTopMin;
		bkThisMost = bkTopMost;
		bkTopMin   = bkTopMost = BkAlloc(qbthr, NULL);

		_GLOBALUNLOCK(qbthr->ghCache);
		rc = RcGrowCache(qbthr);
		qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);
		if (rc != S_OK)
		{
			goto error_return;
		}

		qcbTop = QCacheBlock(qbthr, 0);
		qcbTop->bk          = bkTopMin;
		qcbTop->bFlags      = fCacheDirty | fCacheValid;
		qcbTop->db.cbSlack  = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                      - sizeof(BK);
		qcbTop->db.cKeys    = 0;

		
		// add bk of first node of this level to current node of top level;
		qbDst = qcbTop->db.rgbBlock;
		*(BK UNALIGNED *UNALIGNED)qbDst = bkThisMin;
		qbDst += sizeof(BK);


		// for (each internal node in this level after first)

		for (bkThisCur = bkThisMin + 1;
			bkThisCur <= bkThisMost; ++bkThisCur) {
			key = KeyLeastInSubtree(qbthr, bkThisCur, 1, NULL);

			cbKey = CbSizeKey(key, qbthr, FALSE);

			if ((SHORT)(cbKey + sizeof( BK)) > qcbTop->db.cbSlack) {

				// key and bk don't fit in this block: write it out

				rc = RcWriteBlock(qcbTop, qbthr);

				// recycle the block

				qcbTop->bk = bkTopMost = BkAlloc(qbthr, NULL);
				qcbTop->db.cbSlack = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
					- sizeof(BK); // (bk added below)
				qcbTop->db.cKeys    = 0;
				qbDst = qcbTop->db.rgbBlock;
			}
			else {
				qcbTop->db.cbSlack -= cbKey + sizeof(BK);
				QVCOPY(qbDst, (QB)key, cbKey);
				qbDst += cbKey;
				qcbTop->db.cKeys++;
			}

			*(BK UNALIGNED *UNALIGNED)qbDst = bkThisCur;
			qbDst += sizeof(BK);
		}
		}

	assert(bkTopMin == bkTopMost);

	qbthr->bth.bkRoot = bkTopMin;
	qbthr->bth.bkEOF  = bkTopMin + 1;

normal_return:
	_GLOBALUNLOCK(qbthr->ghCache);
	_GLOBALUNLOCK(hbt);
	return rc;

error_return:
	_GLOBALUNLOCK(qbthr->ghCache);
	_GLOBALUNLOCK(hbt);
	RcAbandonHbt(hbt);
	return (rc);
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btdelete.c ===
/*****************************************************************************
 *                                                                            *
 *  BTDELETE.C                                                                *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Btree deletion functions and helpers.                                     *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  Binhn                                                     *
 *                                                                            *
 *****************************************************************************/

static char s_aszModule[]= __FILE__;	/* For error report */

#include <mvopsys.h>
#include <misc.h>
#include <orkin.h>
#include <iterror.h>
#include <wrapstor.h>
#include <_mvutil.h>

/* Put all functions into the same segment to avoid memory fragmentation
 * and load time surplus for the MAC
 */
// #pragma code_seg ("MVFS")

/***************************************************************************
 *
 *                      Public Functions
 *
 ***************************************************************************/

/***************************************************************************\
 *
 *	@doc	PUBLIC API
 *
 *	@func	HRESULT PASCAL FAR | RcDeleteHbt |
 * 		delete a key from a btree.
 *		Just copy over the key and update cbSlack.
 *		Doesn't yet merge blocks less than half full or update key in
 *		parent key if we deleted the first key in a block.
 *
 *
 * 	@parm	HBT | hbt |
 *		handle of  the btree
 *
 *	@parm	KEY | key |
 *		the key to delete from the btree
 *
 *	@rdesc	S_OK if delete works; ERR_NOTEXIST
 *
 *	@rcomm	Unfinished:  doesn't do block merges or parent updates.
 *
 ***************************************************************************/
PUBLIC HRESULT PASCAL FAR EXPORT_API RcDeleteHbt(HBT hbt, KEY key)
{
	QBTHR     qbthr;
	HF        hf;
	HRESULT        rc;
	QCB  qcb;
	QB        qb;
	SHORT       cb;
	BTPOS     btpos;


	if ((qbthr = (QBTHR)_GLOBALLOCK(hbt)) == NULL)
        return(E_INVALIDARG);
	hf = qbthr->hf;

	if (qbthr->bth.bFlags & fFSOpenReadOnly)
	{
		rc = E_NOPERMISSION;
exit0:
		_GLOBALUNLOCK(hbt);
		return rc;
	}


	/* look up the key */

	if ((rc = RcLookupByKey(hbt, key, &btpos, NULL)) != S_OK)
		goto exit0;

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);


	// copy over this key and rec with subsequent keys and recs

	if ((qcb = QCacheBlock(qbthr, qbthr->bth.cLevels - 1)) == NULL)
	{
		rc = E_FAIL;
exit1:
		_GLOBALUNLOCK(qbthr->ghCache);
		goto exit0;
	}

	qb = qcb->db.rgbBlock + btpos.iKey;

	cb = CbSizeKey((KEY)qb, qbthr, TRUE);
	cb += CbSizeRec(qb + cb, qbthr);

	QVCOPY(qb, qb + cb, (LONG)(qbthr->bth.cbBlock +
			(QB)&(qcb->db) - qb - cb - qcb->db.cbSlack));

	qcb->db.cbSlack += cb;

	// if this was the first key in the leaf block, update key in parent

	// >>>>> code goes here 

	// if block is now less than half full, merge blocks
	
	// >>>>> code goes here 


	qcb->db.cKeys--;
	qcb->bFlags |= fCacheDirty;
	qbthr->bth.lcEntries--;
	qbthr->bth.bFlags |= fFSDirty;

	rc = S_OK;
	goto exit1;
}


/***************************************************************************\
 *
 *	@doc	PUBLIC API
 *
 *	@func	HRESULT PASCAL FAR | RcTraverseHbt |
 * 		Traverses entire btree, calling a user function at each entry.
 *		Optionally, the user can cause the current entry to be deleted.
 *
 * 	@parm	HBT | hbt |
 *		handle of  the btree
 *
 *	@parm	TRAVERSE_FUNC | fnCallback |
 *		Callback of the form DWORD Callback(KEY key, QB rec, DWORD dwUser)
 *		return TRAVERSE_DONE for normal exit, TRAVERSE_DELETE to delete this 
 *		entry, TRAVERSE_INTERRUPT to interrupt and stop traversing.
 *
 *	@parm	DWORD | dwUser |
 *		User data that gets passed into the callback.
 *
 *	@rdesc	S_OK if delete works
 *	@comm	Assumes that RcDeleteHbt does not do block merges.  Keys and 
 *		records are limited to 256 bytes in this function
 *
 ***************************************************************************/

typedef DWORD (FAR PASCAL *TRAVERSE_FUNC) (KEY key, QB rec, DWORD dwUser);

PUBLIC HRESULT PASCAL FAR EXPORT_API RcTraverseHbt(HBT hbt, TRAVERSE_FUNC fnCallback, DWORD dwUser)
{
	QBTHR	qbthr;
	HRESULT      rc;
	BK		bk;
	QCB		qcb;
	QB		qb;
	BTPOS   btpos;
	BYTE	* pKeyData;
	BYTE	* pRecData;
	HRESULT	errb;

	SHORT 	cbKey, cbRec;
	if ((hbt==NULL) || (!fnCallback))
		return E_INVALIDARG;
	
	if ((qbthr = (QBTHR)_GLOBALLOCK(hbt)) == NULL)
        return(E_INVALIDARG);

	if (qbthr->bth.lcEntries == (LONG)0)
	{
		rc = E_NOTEXIST;
exit0:
		_GLOBALUNLOCK(hbt);
		return rc;
	}

	if ((bk = qbthr->bth.bkFirst) == bkNil)
	{
		rc = E_ASSERT;
		goto exit0;
	}

	if (qbthr->ghCache == NULL)
	{
		if ((rc = RcMakeCache(qbthr)) != S_OK) 
			goto exit0;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	if ((qcb = QFromBk(bk, (SHORT)(qbthr->bth.cLevels - 1), qbthr,
	    &errb)) == NULL)
	{
		rc = errb;
exit1:
		_GLOBALUNLOCK(qbthr->ghCache);
		goto exit0;
	}
	
	qb = qcb->db.rgbBlock + 2 * sizeof(BK);
	pKeyData=qb;
	cbKey = CbSizeKey((KEY)qb, qbthr, TRUE);
	qb += cbKey;
	pRecData=qb;
	cbRec = CbSizeRec(qb, qbthr);
	
	btpos.bk = bk;
	btpos.iKey = 2 * sizeof(BK);
	btpos.cKey = 0;
	
	while (1)
	{
		DWORD dwRes=(*fnCallback)((KEY)pKeyData,(QB)pRecData,dwUser);
		BTPOS btposNew;
		HRESULT	  errMore;
		
		errMore=RcNextPos( hbt, &btpos, &btposNew ); //==ERR_NOTEXIST)
		
		if (dwRes==1) // delete case
		{
			if (qbthr->bth.bFlags & fFSOpenReadOnly)
			{
				rc = E_NOPERMISSION;
				goto exit1;
			}

			// delete entry, and keep btposNew up to date during delete
			qcb = QFromBk(btpos.bk, (SHORT)(qbthr->bth.cLevels - 1), qbthr,&errb);
			//qb = qcb->db.rgbBlock + btpos.iKey;

			qb = qcb->db.rgbBlock + btpos.iKey;

			QVCOPY(qb, qb + cbKey + cbRec, (LONG)(qbthr->bth.cbBlock +
					(QB)&(qcb->db) - qb - (cbKey + cbRec) - qcb->db.cbSlack));

			qcb->db.cbSlack += cbKey + cbRec;

			qcb->db.cKeys--;
			qcb->bFlags |= fCacheDirty;
			qbthr->bth.lcEntries--;
			qbthr->bth.bFlags |= fFSDirty;

			if (btposNew.bk == btpos.bk)
			{
			 	btposNew.iKey-=cbKey + cbRec;
				btposNew.cKey--;
			}
		}
		else if (dwRes == 2)
		{
		 	rc = E_INTERRUPT;
			goto exit1;
		}
		if (errMore==S_OK)
		{
		 	btpos=btposNew;
			qcb = QFromBk(btpos.bk, (SHORT)(qbthr->bth.cLevels - 1), qbthr,&errb);
			qb = qcb->db.rgbBlock + btpos.iKey;
			pKeyData=qb;
			cbKey = CbSizeKey((KEY)qb, qbthr, TRUE);
			qb += cbKey;
			pRecData=qb;
			cbRec = CbSizeRec(qb, qbthr);			
		}
		else
			break;
	}

	rc=S_OK;
	goto exit1;
}
	

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\wrapstor.cpp ===
/********************************************************************
 WRAPSTOR.CPP

 Owner: ErinFox

 Created: 28-Feb-1997
 
 Description: This file contains file system calls that are wrapped
              with the InfoTech IStorage implementation

*********************************************************************/


// For IStorage support
#define INITGUID

#include <windows.h>
#include <basetyps.h>
#include <comdef.h>
#include  <MSITStg.h>

// InfoTech includes
#include <mvopsys.h>
#include <_mvutil.h>
#include <wrapstor.h>
#include "iofts.h"

// DOSFILE support
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>



#define RESERVED 0

// I "borrowed" these from Tome code
#define PLI_To_PFO(PLI) ((FILEOFFSET *) PLI)
#define LI_To_FO(LI)    (*PLI_To_PFO(&LI))

#define PFO_To_PLI(PFO) ((LARGE_INTEGER *) PFO)
#define FO_To_LI(FO) (*PFO_To_PLI(&FO))


// was in iofts.c
#ifdef _DEBUG
static char s_aszModule[] = __FILE__;	// Used by error return functions.
#endif

// was in iofts.c
#define OPENED_HFS (BYTE)0x80

// was in iofts.c
PRIVATE HANDLE NEAR PASCAL IoftsWin32Create(LPCSTR lpstr, DWORD w);
PRIVATE HANDLE NEAR PASCAL IoftsWin32Open(LPCSTR lpstr, DWORD w);

// was in iofts.c
#define	CREAT(sz, w) IoftsWin32Create(sz, w)
#define	OPEN(sz, w)	IoftsWin32Open(sz, w)



//
// These functions came from subfile.c
//
PUBLIC HF PASCAL FAR EXPORT_API HfOpenHfs(HFS hfs, LPCWSTR wsz,
    BYTE bFlags, LPERRB lperrb)
{
	HF hf;
	DWORD grfMode;
	HRESULT hr;

	// TODO: find out how big this really should be
//	OLECHAR wsz[_MAX_PATH];
//	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, -1, wsz, _MAX_PATH);


	if (bFlags & HFOPEN_READWRITE)
		grfMode = STGM_READWRITE;
	else if (bFlags & HFOPEN_READ)
		grfMode = STGM_READ;


	if (!(bFlags & HFOPEN_CREATE))
	{
		hr = hfs->OpenStream(wsz, NULL, grfMode, RESERVED, &hf);
	}
	else
	{
	 	hr = hfs->CreateStream(wsz, grfMode, RESERVED, RESERVED, &hf);
	}

    // make sure we pass back a NULL if open/create failed
    if (!SUCCEEDED(hr))
        hf = NULL;

    // sometimes we get passed NULL for lperrb
    if (lperrb)
	    *lperrb = hr;    

	return hf;
}


PUBLIC HF PASCAL FAR EXPORT_API HfCreateFileHfs(HFS hfs, LPCSTR sz,
    BYTE bFlags, LPERRB lperrb)
{
	HF hf;
	DWORD grfMode;
	HRESULT hr;

	// TODO: find out how big this really should be
	OLECHAR wsz[_MAX_PATH];
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, -1, wsz, _MAX_PATH);

	
	if (bFlags & HFOPEN_READWRITE)
		grfMode = STGM_READWRITE;
	else if (bFlags & HFOPEN_READ)
		grfMode = STGM_READ;

	hr = hfs->CreateStream(wsz, grfMode, RESERVED, RESERVED, &hf);

    // make sure we pass back NULL if failure
    if (!SUCCEEDED(hr))
        hf = NULL;

    if (lperrb)
	    *lperrb = hr;   

	return hf;
}

// This is currently the same as HfOpenHfs, but once we have Ron's
// enhancements to Tome we will be able to set the size on the file
PUBLIC HF PASCAL FAR EXPORT_API HfOpenHfsReserve(HFS hfs, LPCSTR sz,
    BYTE bFlags, FILEOFFSET foReserve, LPERRB lperrb)
{
	HF hf;
	DWORD grfMode;
	HRESULT hr;

	// TODO: find out how big this really should be
	OLECHAR wsz[_MAX_PATH];
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, -1, wsz, _MAX_PATH);

	if (bFlags & HFOPEN_READWRITE)
		grfMode = STGM_READWRITE;
	else if (bFlags & HFOPEN_READ)
		grfMode = STGM_READ;

	if (!(bFlags & HFOPEN_CREATE))
	{
		hr = hfs->OpenStream(wsz, NULL, grfMode, RESERVED, &hf);
	}
	else
	{
	 	hr = hfs->CreateStream(wsz, grfMode, RESERVED, RESERVED, &hf);
	}

    if (!SUCCEEDED(hr))
        hf = NULL;

	if (lperrb)
        *lperrb = hr;
    
    return hf;
}

PUBLIC LONG PASCAL FAR EXPORT_API LcbReadHf(HF hf, LPVOID lpvBuffer,
	LONG lcb, LPERRB lperrb)
{
	ULONG cbRead;
	HRESULT hr;

	hr = hf->Read(lpvBuffer, lcb, &cbRead);

    if (lperrb)
	    *lperrb = hr;
	
	return cbRead;
}

PUBLIC LONG PASCAL FAR EXPORT_API LcbWriteHf(HF hf, LPVOID lpvBuffer,
	LONG lcb, LPERRB lperrb)
{
	ULONG cbWrote;
	HRESULT hr;

	hr = hf->Write(lpvBuffer, lcb, &cbWrote);

    if (lperrb)
	    *lperrb = hr;  

	return cbWrote;
}


PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FoSeekHf(HF hf, FILEOFFSET foOffset, 
	WORD wOrigin, LPERRB lperrb)
{

	HRESULT hr;
	ULARGE_INTEGER liNewPos;
	LARGE_INTEGER liOffset = FO_To_LI(foOffset);

	hr = hf->Seek(liOffset, (DWORD)wOrigin, &liNewPos);

    if (lperrb)
	    *lperrb = hr;

	return LI_To_FO(liNewPos);


}

PUBLIC RC PASCAL FAR EXPORT_API RcCloseHf(HF hf)
{
	if (hf)
		hf->Release();
	
	return S_OK;
}


PUBLIC BOOL PASCAL FAR EXPORT_API FAccessHfs( HFS hfs, LPCSTR szName, BYTE bFlags, LPERRB lperrb)
{
	HRESULT hr;
	HF hf = NULL;
	BOOL fRet = FALSE;

    if (lperrb)
	    *lperrb = S_OK;          // for now

	// TODO: find out how big this really should be
	OLECHAR wszName[_MAX_PATH];
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szName, -1, wszName, _MAX_PATH);

	hr = hfs->OpenStream(wszName, NULL, STGM_READWRITE, RESERVED, &hf);

	if (S_OK == hr)
	{
		if (bFlags & FACCESS_EXISTS)
			fRet = TRUE;

	}
	else if (STG_E_FILENOTFOUND == hr)
	{
		SetErrCode (lperrb, E_FILENOTFOUND);
	}
 // else
 // {
 //		Need to set error if anything but NOTFOUND
 // }
	
	if (hf)
		hf->Release();

	return fRet;
}


PUBLIC FILEOFFSET PASCAL FAR EXPORT_API FoSizeHf(HF hf, LPERRB lperrb)
{
	STATSTG stat;
	HRESULT hr;
    FILEOFFSET foSize;

	hr = hf->Stat(&stat, STATFLAG_NONAME);

    if (S_OK == hr)
        foSize = LI_To_FO(stat.cbSize);
    else
        foSize = foNil;

    if (lperrb)
        *lperrb = hr;

    
    return foSize;
}


///////////////////////////////////////////////////////////////////
//  These functions came from iofts.c
///////////////////////////////////////////////////////////////////

PUBLIC HFPB FAR PASCAL FileCreate (HFPB hfpbSysFile, LPCSTR lszFilename,
	int fFileType, LPERRB lperrb)
{
	LPFPB lpfpb;	/* Pointer to file parameter block */
	HANDLE hMem;
	HFPB hfpb;
	HRESULT hr;
	OLECHAR wszFileName[_MAX_PATH];
	FM fm;
	HFS hfs;

	/* Check for valid filename */
	if (lszFilename == NULL )
	{
		SetErrCode (lperrb, E_INVALIDARG);
		return 0;
	}

	/* Allocate a file's parameter block */
	if (!(hMem = _GLOBALALLOC(GMEM_ZEROINIT, sizeof(FPB))))
	{	
		SetErrCode(lperrb, E_OUTOFMEMORY);
		return NULL;
	}

	if (!(lpfpb = (LPFPB)_GLOBALLOCK(hMem)))
	{
	 	_GLOBALUNLOCK(hMem);
		SetErrCode(lperrb,E_OUTOFMEMORY);
		return NULL;
	}

	_INITIALIZECRITICALSECTION(&lpfpb->cs);
	lpfpb->hStruct = hMem;

	switch (fFileType)
	{
		case FS_SYSTEMFILE:

			IClassFactory* pCF;
			
			hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, 
                                  IID_IClassFactory, (VOID **)&pCF);

			// Error check!

			IITStorage* pITStorage;
			hr = pCF->CreateInstance(NULL, IID_ITStorage, 
                                      (VOID **)&pITStorage);
			if (pCF)
				pCF->Release();

			fm = FmNewSzDir((LPSTR)lszFilename, dirCurrent, NULL);
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, fm, -1, wszFileName, _MAX_PATH);

			hr = pITStorage->StgCreateDocfile(wszFileName, STGM_READWRITE, RESERVED, &hfs);

            // if call failed, make sure to set hfs NULL
            if (!SUCCEEDED(hr))
            {
                hfs = NULL;
                SetErrCode(lperrb, hr);
            }

			lpfpb->fs.hfs = hfs;


			if (pITStorage)
				pITStorage->Release();

			DisposeFm(fm);

			break;


		case FS_SUBFILE:
			hfs = GetHfs(hfpbSysFile,lszFilename,TRUE,lperrb);
			if (hfs)
			{
				lpfpb->fs.hf = HfCreateFileHfs(hfs,GetSubFilename(lszFilename,
					NULL),HFOPEN_READWRITE,lperrb);

				lpfpb->ioMode = OF_READWRITE;
				
				if (lpfpb->fs.hf == NULL)
				{
					if (!hfpbSysFile)
					 	RcCloseHfs(hfs);				
					goto ErrorExit;
				}
				else
				{
				 	if (!hfpbSysFile)
						lpfpb->ioMode |= OPENED_HFS;
				}
			}
			else
			{
			 	goto ErrorExit;
			}
			break;

		case REGULAR_FILE:
			// Create the file 
			if ((lpfpb->fs.hFile = (HFILE_GENERIC)CREAT (lszFilename, 0))
			    == HFILE_GENERIC_ERROR)
			{
				SetErrCode(lperrb,E_FILECREATE);
				goto ErrorExit;
			}
			lpfpb->ioMode = OF_READWRITE;
			break;
	}

	// Set the filetype 
	lpfpb->fFileType = (BYTE) fFileType;

	_GLOBALUNLOCK(hfpb = lpfpb->hStruct);
	return hfpb;

ErrorExit:
	_DELETECRITICALSECTION(&lpfpb->cs);
	_GLOBALFREE(hMem);
	return 0;
}




PUBLIC HFPB FAR PASCAL FileOpen (HFPB hfpbSysFile, LPCSTR lszFilename,
	int fFileType, int ioMode, LPERRB lperrb)
{
	LPFPB lpfpb;	/* Pointer to file parameter block */
	HANDLE hMem;
	HFPB hfpb;
	FM fm;
	OLECHAR wszFileName[_MAX_PATH];
	HFS hfs;

	HRESULT hr;

	/* Check for valid filename */
	if (lszFilename == NULL )
	{
		SetErrCode (lperrb, E_INVALIDARG);
		return 0;
	}

	/* Allocate a file's parameter block */
	if (!(hMem = _GLOBALALLOC(GMEM_ZEROINIT, sizeof(FPB))))
	{	
		SetErrCode(lperrb,E_OUTOFMEMORY);
		return NULL;
	}

	if (!(lpfpb = (LPFPB)_GLOBALLOCK(hMem)))
	{
	 	_GLOBALUNLOCK(hMem);
		SetErrCode(lperrb,E_OUTOFMEMORY);
		return NULL;
	}

	_INITIALIZECRITICALSECTION(&lpfpb->cs);
	lpfpb->hStruct = hMem;

	switch (fFileType)
	{
		case FS_SYSTEMFILE:

			IClassFactory* pCF;
			
			hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, 
                                  IID_IClassFactory, (VOID **)&pCF);

			// Error check!

			IITStorage* pITStorage;
			hr = pCF->CreateInstance(NULL, IID_ITStorage, 
                                      (VOID **)&pITStorage);
			if (pCF)
				pCF->Release();


			fm = FmNewSzDir((LPSTR)lszFilename, dirCurrent, NULL);
			MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, fm, -1, wszFileName, _MAX_PATH);

			hr = pITStorage->StgOpenStorage(wszFileName, NULL, (ioMode==READ) ? STGM_READ:STGM_READWRITE, 
			                                NULL, RESERVED, &hfs);

            if (!SUCCEEDED(hr))
            {
                hfs = NULL;
                SetErrCode(lperrb, hr);
            }

			lpfpb->fs.hfs = hfs;

			if (pITStorage)
				pITStorage->Release();

			DisposeFm(fm);

			break;

		case FS_SUBFILE:
			hfs = GetHfs(hfpbSysFile,lszFilename,FALSE,lperrb);
			if (hfs)
			{	
            	OLECHAR wsz[_MAX_PATH];
                LPCSTR sz = GetSubFilename(lszFilename, NULL);
            	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, -1, wsz, _MAX_PATH);
				lpfpb->fs.hf = HfOpenHfs(hfs, wsz,
                                (BYTE)((ioMode==READ)?HFOPEN_READ:HFOPEN_READWRITE),lperrb);

				lpfpb->ioMode = (BYTE) ioMode;
				
				if (lpfpb->fs.hf == 0)
				{
					if (!hfpbSysFile)
					 	RcCloseHfs(hfs);
					SetErrCode (lperrb, E_NOTEXIST);				
					goto ErrorExit;
				}
				else
				{
				 	if (!hfpbSysFile)
						lpfpb->ioMode|=OPENED_HFS;
				}
			}
			else
			{
				SetErrCode (lperrb, E_NOTEXIST);				
			 	goto ErrorExit;
			}
			break;

		case REGULAR_FILE:
			/* Set the IO mode and appropriate error messages */
			if (ioMode == READ)
			{
				/* Open the file */
				if ((lpfpb->fs.hFile = (HFILE_GENERIC)OPEN (lszFilename,
				    ioMode)) == HFILE_GENERIC_ERROR) 
				{
					SetErrCode(lperrb,E_NOTEXIST);
					goto ErrorExit;
				}

			}
			else
			{
				ioMode = OF_READWRITE;
				/* Open the file */
				if ((lpfpb->fs.hFile = (HFILE_GENERIC)OPEN(lszFilename, ioMode))
				    == HFILE_GENERIC_ERROR)
				{
					SetErrCode(lperrb,E_FILECREATE);
					goto ErrorExit;
				}
			}
			lpfpb->ioMode = (BYTE) ioMode;
			break;

	}

	// set filetype
	lpfpb->fFileType = (BYTE) fFileType;

	_GLOBALUNLOCK(hfpb = lpfpb->hStruct);
	return hfpb;

ErrorExit:
	_DELETECRITICALSECTION(&lpfpb->cs);
	_GLOBALFREE(hMem);
	return 0;

}

PUBLIC RC FAR PASCAL FileClose(HFPB hfpb)
{
	RC rc;
	LPFPB	lpfpb;


	if (hfpb == NULL)
		return E_HANDLE;

	lpfpb = (LPFPB)_GLOBALLOCK(hfpb);
	_ENTERCRITICALSECTION(&lpfpb->cs);

	rc = S_OK;
	switch (lpfpb->fFileType)
	{
		case FS_SYSTEMFILE:
            if (lpfpb->fs.hfs)
			    lpfpb->fs.hfs->Release();
			break;

		case FS_SUBFILE:
            if (lpfpb->fs.hf)
                lpfpb->fs.hf->Release();
			break;

		case REGULAR_FILE:
			if (lpfpb->fs.hFile)
				rc = (!CloseHandle(lpfpb->fs.hFile))?E_FILECLOSE:S_OK;
			break;
	}

	/* Free the file parameter block structure */
	_LEAVECRITICALSECTION(&lpfpb->cs);
	_DELETECRITICALSECTION(&lpfpb->cs);

    _GLOBALUNLOCK(hfpb);
	_GLOBALFREE(hfpb);

	return rc;
}


// These are verbatim from iofts.c. I put them here so we can compile
PRIVATE HANDLE NEAR PASCAL IoftsWin32Create(LPCSTR lpstr, DWORD w)
{
	SECURITY_ATTRIBUTES sa;
	HANDLE hfile;

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = 0;

	hfile= CreateFile(lpstr, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ,
		&sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	return hfile;
}

PRIVATE HANDLE NEAR PASCAL IoftsWin32Open(LPCSTR lpstr, DWORD w)
{
	SECURITY_ATTRIBUTES sa;

	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = 0;

	return CreateFile(lpstr, (w == READ) ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE, 
                      FILE_SHARE_READ, &sa,OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
}

#if 0
// This is new functionality
PUBLIC FM EXPORT_API FAR PASCAL FmFromHfs(HFS hfs)
{
	char szStoreName[_MAX_PATH];
	FM fm;
	ERRB errb;

	STATSTG StoreStat;
	HRESULT hr;

	// get storage name 
	// Turns out this isn't IMPLEMENTED yet!
	hr = hfs->Stat(&StoreStat, STATFLAG_DEFAULT);
	if (S_OK == hr)
	{
		// and convert it since FMs aren't Unicode
		WideCharToMultiByte(CP_ACP, 0, StoreStat.pwcsName, -1,
							szStoreName, _MAX_PATH, NULL, NULL);

		// free memory associated with pwcsName
		CoTaskMemFree(StoreStat.pwcsName);

		// create new FM
		fm = FmNew(szStoreName, &errb);
	}
	else
		fm = NULL;

	return fm;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btinsert.c ===
/*****************************************************************************
 *                                                                            *
 *  BTINSERT.C                                                                *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1989 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Btree insertion functions and helpers.                                    *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BinhN                                                     *
 *                                                                            *
 *****************************************************************************/

/*****************************************************************************
 *
 *  Revision History:  Created 04/20/89 by JohnSc
 *
 *  08/21/90     JohnSc  autodocified
 *  04-Feb-1991  JohnSc  set ghCache to NULL after freeing it
 *   3/05/97     erinfox Change errors to HRESULTS
 *****************************************************************************/

static char s_aszModule[]= __FILE__;	/* For error report */


#include <mvopsys.h>
#include <orkin.h>
#include <iterror.h>
#include <misc.h>
#include <wrapstor.h>
#include <_mvutil.h>


/*************************************************************************
 *
 *	                  INTERNAL GLOBAL FUNCTIONS
 *
 *	All of them should be declared far, unless they are known to be called
 *	in the same segment. They should be prototyped in some include file
 *
 *************************************************************************/

PUBLIC BK PASCAL FAR BkAlloc(QBTHR, LPVOID);
PUBLIC HRESULT PASCAL FAR RcInsertInternal(BK, KEY, SHORT, QBTHR);
PUBLIC HRESULT PASCAL FAR RcSplitLeaf(QCB, QCB, QBTHR);
PUBLIC void PASCAL FAR SplitInternal(QCB, QCB, QBTHR, QW);

/*************************************************************************
 *
 *	                     API FUNCTIONS
 *	Those functions should be exported in a .DEF file
 *************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcUpdateHbt(HBT, KEY, QV);
PUBLIC HRESULT PASCAL FAR EXPORT_API RcInsertHbt(HBT , KEY, QV);

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	BK PASCAL FAR | BkAlloc |
 *		Make up a new BK.
 *
 *	@parm	QBTHR | qbthr |
 *		Pointer to B-tree strucuture.
 *		qbthr->bkFree - head of free list, unless it's bkNil.
 *		qbthr->bkEOF  - use this if bkFree == bkNil (then ++)
 *
 *	@rdesc	a valid BK or bkNil if file is hosed
 *		args OUT:   qbthr->bkFree or qbthr->bkEOF will be different
 *
 *	@comm	Side Effects: btree file may grow
 *		Method: Use the head of the free list.  If the free list is empty,
 *		there are no holes in the file and we carve a new one.
 *
 ***************************************************************************/

PUBLIC BK PASCAL FAR BkAlloc(QBTHR qbthr, PHRESULT phr)
{
	BK    bk;

	if (qbthr->bth.bkFree == bkNil)
		bk = (qbthr->bth.bkEOF++);
	else
	{
		FILEOFFSET foSeek;
		bk = qbthr->bth.bkFree;
		foSeek=FoFromBk(bk,qbthr);

		if (!FoEquals(FoSeekHf(qbthr->hf, foSeek, wFSSeekSet, phr),foSeek ))
			return bkNil;
		
		if (LcbReadHf(qbthr->hf, &(qbthr->bth.bkFree), (LONG)sizeof(BK),
		    phr) != (LONG)sizeof(BK))
			return bkNil;
	}

	return bk;
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | RcSplitLeaf |
 *		Split a leaf node when a new key won't fit into it.
 *
 *	@parm	QCB | qcbOld |
 *		the leaf to be split
 *
 *	@parm	QCB | qcbNew |
 *		a leaf buffer to get half the contents of qcbOld;
 *		qcbNew->bk must be set
 *
 *	@parm	QBTHR | qbthr |
 *		Pointer to B-tree structure
 *
 * 	@rdesc S_OK, E_OUTOFMEMORY
 *		args OUT:   qcbOld - cbSlack, cKeys, bkPrev, bkNext updated
 *		qcbNew - about half of the old contents of qcbOld
 *		get put here.  cbSlack, cKeys set.
 *		qbthr  - qbthr->bkFirst and bkLast can be changed
 *		globals OUT: rcBtreeError
 *
 *	@comm 	ompressed keys not implemented
 *		For fixed length keys and records, could just split at
 *		middle key rather than scanning from the beginning.
 *
 *		The new block is always after the old block.  This is
 *		why we don't have to adjust pointers to the old block
 *		(i.e. qbthr->bth.bkFirst).
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR RcSplitLeaf(QCB qcbOld, QCB qcbNew, QBTHR qbthr)
{
	SHORT iOK, iNext, iHalf, cbKey, cbRec, cKeys;
	QB     q;
	HANDLE gh;
	QCB    qcb;
	HRESULT     rc;
	SHORT  cbCopyToNew;

	assert(qcbOld->bFlags & fCacheValid);

	iOK = iNext = 0;
	q = qcbOld->db.rgbBlock + 2 * sizeof(BK);
	iHalf = (qbthr->bth.cbBlock / 2) - sizeof(BK);

	for (cKeys = qcbOld->db.cKeys; ;)
	{
		assert(cKeys > 0);

		cbKey = CbSizeKey((KEY)q, qbthr, TRUE);
		cbRec = CbSizeRec(q + cbKey, qbthr);

		iNext = iOK + cbKey + cbRec;

		if (iNext > iHalf) break;

		q += cbKey + cbRec;
		iOK = iNext;
		cKeys--;
	}

	// >>>> if compressed, expand first key here

	// Note that the total block size includes the disk block struct.
	// The new slack in the old block should equal the number of bytes
	// copied to the new block.  The amount being copied was previously too large
	// by 4 bytes.
	cbCopyToNew = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1 - (iOK + 2 * sizeof(BK));

	QVCOPY(qcbNew->db.rgbBlock + 2 * sizeof(BK),
	    qcbOld->db.rgbBlock + 2 * sizeof(BK) + iOK, (LONG)cbCopyToNew);

	qcbNew->db.cKeys = cKeys;
	qcbOld->db.cKeys -= cKeys;

	qcbNew->db.cbSlack = qcbOld->db.cbSlack + iOK;
	qcbOld->db.cbSlack = cbCopyToNew;
		

	qcbOld->bFlags |= fCacheDirty | fCacheValid;
	qcbNew->bFlags =  fCacheDirty | fCacheValid;

	SetBkPrev(qcbNew, qcbOld->bk);
	SetBkNext(qcbNew, BkNext(qcbOld));
	SetBkNext(qcbOld, qcbNew->bk);

	if (BkNext(qcbNew) == bkNil)
		qbthr->bth.bkLast = qcbNew->bk;
	else
	{

		/* set new->next->prev = new; */

		if ((gh =  _GLOBALALLOC(GMEM_ZEROINIT| GMEM_SHARE| GMEM_MOVEABLE,
		    (LONG)CbCacheBlock(qbthr))) == NULL)
			return (E_OUTOFMEMORY);
		qcb = _GLOBALLOCK(gh);

		qcb->bk = BkNext(qcbNew);
		
		if ((rc = FReadBlock(qcb, qbthr)) != S_OK)
		{
			_GLOBALUNLOCK(gh);
			_GLOBALFREE(gh);
			return rc;
		}

		SetBkPrev(qcb, qcbNew->bk);
		if ((rc = RcWriteBlock(qcb, qbthr)) != S_OK)
		{
			_GLOBALUNLOCK(gh);
			_GLOBALFREE(gh);
			return rc;
		}

		_GLOBALUNLOCK(gh);
		_GLOBALFREE(gh);
	}

	return (S_OK);
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	void PASCAL FAR | SplitInternal |
 *
 *		Split an internal node node when a new key won't fit into it.
 *		Old node gets BKs and KEYs up to the first key that won't
 *		fit in half the block size.  (Leave that key there with iKey
 *		pointing at it).  The new block gets the BKs and KEYs after
 *		that key.
 *
 *	@parm	QCB | qcbOld |
 *		the block to split
 *
 *	@parm	QCB | qcbNew |
 *		pointer to a qcb
 *
 *	@parm	QBTHR | qbthr |
 *		Pointer to B-tree structure
 *
 *	@rdesc	qcbNew  - keys and records copied to this buffer.
 *		cbSlack, cKeys set.
 *		qcbOld  - cbSlack and cKeys updated.
 *		qi      - index into qcbOld->db.rgbBlock of discriminating key
 *
 *	@comm	compressed keys not implemented
 *		*qi is index of a key that is not valid for qcbOld.  This
 *		key gets copied into the parent node.
 *               
 ***************************************************************************/

PUBLIC void PASCAL FAR SplitInternal(QCB qcbOld, QCB qcbNew, QBTHR qbthr, QW qi)
{
	SHORT iOK, iNext, iHalf, cb, cKeys, cbTotal;
	QB  q;

	assert(qcbOld->bFlags & fCacheValid);

	iOK = iNext = sizeof(BK);
	q = qcbOld->db.rgbBlock + sizeof(BK);
	iHalf = qbthr->bth.cbBlock / 2;

	for (cKeys = qcbOld->db.cKeys; ; cKeys--)
	{
		assert(cKeys > 0);

		cb = CbSizeKey((KEY)q, qbthr, TRUE) + sizeof(BK);
		iNext = iOK + cb;
		
		if (iNext > iHalf) break;

		q += cb;
		iOK = iNext;
	}

	// have to expand first key if compressed

	cbTotal = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1;

	QVCOPY(qcbNew->db.rgbBlock,
		qcbOld->db.rgbBlock + iNext - sizeof(BK),
		(LONG)cbTotal - qcbOld->db.cbSlack - iNext + sizeof(BK));

	*qi = iOK;

	qcbNew->db.cKeys = cKeys - 1;
	qcbOld->db.cKeys -= cKeys;

	qcbNew->db.cbSlack = qcbOld->db.cbSlack + iNext - sizeof(BK);
	qcbOld->db.cbSlack = cbTotal - iOK;

	qcbOld->bFlags |= fCacheDirty | fCacheValid;
	qcbNew->bFlags =  fCacheDirty | fCacheValid;
	
}

/***************************************************************************
 *
 *	@doc	INTERNAL
 *
 *	@func	HRESULT PASCAL FAR | RcInsertInternal |
 *		Insert a bk and key into an internal block.
 *		state IN:   We've just done a lookup, so all ancestors are cached.
 *			Cache is locked.
 *
 *
 *	@parm	BK | bk | BK to insert
 *
 *	@parm	KEY | key | least key in bk
 *
 *	@parm	SHORT | wLevel |
 *		level of the block we're inserting
 *
 *	@parm	QNTHR | qbthr |
 *		btree header
 *
 *
 *	@rdesc	S_OK, E_OUTOFMEMORY
 *		args OUT:   qbthr->cLevels - incremented if root is split
 *		qbthr->ghCache, qbthr->qCache - may change if root is
 *		split and cache therefore grows
 *		state OUT:  Cache locked, all ancestors cached.
 *
 *	@comm
 *		Status:       compressed keys unimplemented
 *		Method:       Works recursively.  Splits root if need be.
 *		Side Effects: Cache could be different after this call than it
 *			was before.
 *			Pointers or handles to it from before this call could be
 *			invalid.  Use qbthr->ghCache or qbthr->qCache to be safe.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR RcInsertInternal(BK bk, KEY key, SHORT wLevel, QBTHR qbthr)
{
	QCB qcb, qcbNew, qcbRoot;
	WORD   iKey;
	SHORT    cLevels, cbKey, cbCBlock = CbCacheBlock(qbthr);
	QB     qb;
	HANDLE gh, ghOldCache;
	KEY    keyNew;
	BK     bkRoot;
	HRESULT     rc = S_OK;
	UINT_PTR    iKeySav = 0;
    ERRB   errb;


	cbKey = CbSizeKey(key, qbthr, TRUE);

	if (wLevel == 0)
	{

		/* inserting another block at root level */
		// allocate new root bk;

		bkRoot = BkAlloc(qbthr, &errb);
		if (bkRoot == bkNil)
		{
			return errb;
		}

		// grow cache by one cache block;
		qbthr->bth.cLevels++;

		gh =  _GLOBALALLOC(GMEM_ZEROINIT| GMEM_SHARE| GMEM_MOVEABLE,
		    (LONG)cbCBlock * qbthr->bth.cLevels);
		if (gh == NULL)
			return (E_OUTOFMEMORY);
		qb = _GLOBALLOCK(gh);

		QVCOPY(qb + cbCBlock, qbthr->qCache,
			(LONG)cbCBlock * (qbthr->bth.cLevels - 1));

		/* Since key points into the cache if this is a recursive */
		/* call, we can't free the old cache until a bit later. */

		ghOldCache = qbthr->ghCache;
		qbthr->ghCache = gh;
		qbthr->qCache = qb;

		// put old root bk, key, bk into new root block;

		qcbRoot = (QCB)qbthr->qCache;

		qcbRoot->bk         = bkRoot;
		qcbRoot->bFlags     = fCacheDirty | fCacheValid;
		qcbRoot->db.cbSlack = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                      - (2 * sizeof(BK) + cbKey);
		qcbRoot->db.cKeys   = 1;

		*(BK FAR *)(qcbRoot->db.rgbBlock) = qbthr->bth.bkRoot;

		QVCOPY(qcbRoot->db.rgbBlock + sizeof(BK), (QB)key, (LONG)cbKey);

		/* OK, now we're done with key, so we can safely free the */
		/* old cache. */
		_GLOBALUNLOCK(ghOldCache);
		_GLOBALFREE(ghOldCache);

		*(BK FAR *)(qcbRoot->db.rgbBlock + sizeof(BK) + cbKey) = bk;

		qbthr->bth.bkRoot = bkRoot;

		return S_OK;
	}

	qcb = QCacheBlock(qbthr, wLevel - 1);

	if ((SHORT)(cbKey + sizeof(BK)) >= qcb->db.cbSlack)  {

		// new key and BK won't fit in block
		// split the block;

		if ((gh =  _GLOBALALLOC(GMEM_ZEROINIT| GMEM_SHARE| GMEM_MOVEABLE,
		    (LONG)CbCacheBlock(qbthr))) == NULL)
			return (E_OUTOFMEMORY);

		qcbNew = _GLOBALLOCK(gh);
		if ((qcbNew->bk = BkAlloc(qbthr, &errb)) == bkNil) {
			_GLOBALUNLOCK(gh);
			_GLOBALFREE(gh);
			return errb;
		}

		SplitInternal(qcb, qcbNew, qbthr, &iKey);
		keyNew = (KEY)qcb->db.rgbBlock + iKey;

		cLevels = qbthr->bth.cLevels;

		if (wLevel < cLevels - 1)
		{
			/* This is a recursive call (the arg bk doesn't refer to a leaf.)
			** This means that the arg key points into the cache, so it will
			** be invalid if the root is split.
			** Verify with some asserts that key points into the cache.
			*/
			assert((QB)key > qbthr->qCache + CbCacheBlock(qbthr));
			assert((QB)key < qbthr->qCache + (wLevel + 1) * CbCacheBlock(qbthr));

			/* Save the offset of key into the cache block.  Recall that key
			** is the first invalid key in an internal node that has just
			** been split.  It points into the part that is still in the cache.
			*/
			iKeySav = (QB)key - (qbthr->qCache + wLevel * CbCacheBlock(qbthr));
		}

		if ((rc = RcInsertInternal(qcbNew->bk, (KEY)qcb->db.rgbBlock + iKey,
			(SHORT)(wLevel - 1), qbthr)) != S_OK)
		{
			_GLOBALUNLOCK(gh);
			_GLOBALFREE(gh);
			return rc;
		}

		/* RcInsertInternal() can change cache and qbthr->bth.cLevels */
		if (cLevels != qbthr->bth.cLevels)
		{
			assert(cLevels + 1 == qbthr->bth.cLevels);
			wLevel++;
			qcb = QCacheBlock(qbthr, wLevel - 1);
			keyNew = (KEY)qcb->db.rgbBlock + iKey;

			/* Also restore the arg "key" if it pointed into the cache.
			*/
			if (iKeySav)
			{
			  key = (KEY)(qbthr->qCache + wLevel * CbCacheBlock(qbthr)
			                + iKeySav);
			}
		}
		
		/* find out which block to put new key and bk in, and cache it */
		if (WCmpKey(key, keyNew, qbthr) < 0)
		{
			if ((rc = RcWriteBlock(qcbNew, qbthr)) != S_OK)
			{
				_GLOBALUNLOCK(gh);
				_GLOBALFREE(gh);
				return rc;
			 
			}
		}
		else
		{

			// write old block and cache the new one
			if ((rc = RcWriteBlock(qcb, qbthr)) != S_OK)
			{
				_GLOBALUNLOCK(gh);
				_GLOBALFREE(gh);
				return rc;
			}
			QVCOPY(qcb, qcbNew, (LONG)CbCacheBlock(qbthr));
		}

		_GLOBALUNLOCK(gh);
		_GLOBALFREE(gh);

	}

	// slide stuff over and insert the new key, bk

	/* get pos */
	if (qbthr->BkScanInternal(qcb->bk, key, (SHORT)(wLevel - 1), qbthr,
	    &iKey, &errb) == bkNil)
	 {
		return errb;
	}

	assert(iKey + cbKey + sizeof(BK) <
		qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1);

	qb = (QB)(qcb->db.rgbBlock) + iKey;

	QVCOPY(qb + cbKey + sizeof(BK), qb,
		(LONG)qbthr->bth.cbBlock - iKey - qcb->db.cbSlack
		- sizeof(DISK_BLOCK) + 1);

	QVCOPY(qb, (QB)key, (LONG)cbKey);
	*(BK FAR *)(qb + cbKey) = bk;
		
	qcb->db.cKeys++;
	qcb->db.cbSlack -= (cbKey + sizeof(BK));
	qcb->bFlags |= fCacheDirty;

	return (S_OK);
}


/***************************************************************************
 *
 *	@doc	PUBLIC API
 *
 *	@func	HRESULT PASCAL FAR | RcInsertHbt |
 *		Insert a key and record into a btree
 *
 *	@parm	HBT | hbt |
 *		btree handle
 *
 *	@parm	KEY | key |
 *		key to insert
 *
 *	@parm	QV | qvRec |
 *		record associated with key to insert
 *
 *	@rdesc	S_OK, E_DUPLICATE (duplicate key)
 *
 *	@comm
 *		state IN:   cache unlocked
 *		state OUT:  cache unlocked, all ancestor blocks cached
 *		Notes:        compressed keys unimplemented
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcInsertHbt(HBT hbt, KEY key, QV qvRec)
{
	QBTHR  qbthr;
	HF     hf;
	HRESULT     rc;
	SHORT    cbAdd, cbKey, cbRec;
	QCB    qcbLeaf, qcbNew, qcb;
	HANDLE gh;
	KEY    keyNew;
	QB     qb;
	BTPOS  btpos;
    ERRB   errb;


	if ((qbthr = _GLOBALLOCK(hbt)) == NULL)
        return(E_INVALIDARG);
        
	hf = qbthr->hf;

	if ((rc = RcLookupByKeyAux(hbt, key, &btpos, NULL, TRUE)) == S_OK)
	{
		rc = E_DUPLICATE;
exit0:
		_GLOBALUNLOCK (hbt);
		return rc;
	}

	/*
		After lookup, all nodes on path from root to correct leaf are
		guaranteed to be cached, with iKey valid.
	 */

	if (rc != E_NOTEXIST)
		goto exit0;

	rc = S_OK;

	if (qbthr->bth.cLevels == 0)
	{

		// need to build a valid root block

		if ((qbthr->ghCache = _GLOBALALLOC(GMEM_ZEROINIT| GMEM_SHARE| GMEM_MOVEABLE,
			(LONG)CbCacheBlock(qbthr))) == NULL)
	    {
			rc = E_OUTOFMEMORY;
			goto exit0;
		}

		qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);
		qcb = (QCB)qbthr->qCache;

		qbthr->bth.cLevels  = 1;
		qbthr->bth.bkFirst = qbthr->bth.bkLast = qbthr->bth.bkRoot =
			qcb->bk = BkAlloc(qbthr, &errb);

		if (qcb->bk == bkNil)
		{
exit01:
			_GLOBALUNLOCK(qbthr->ghCache);
			_GLOBALFREE(qbthr->ghCache);
			qbthr->ghCache = NULL;
			rc = errb;
			goto exit0;
		}
		qcb->bFlags         = fCacheDirty | fCacheValid;
		qcb->db.cbSlack     = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                      - 2 * sizeof(BK);
		qcb->db.cKeys       = 0;
		SetBkPrev(qcb, bkNil);
		SetBkNext(qcb, bkNil);
		btpos.iKey = 2 * sizeof(BK);

	}
	else
		qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	cbKey = CbSizeKey(key, qbthr, FALSE);
	cbRec = CbSizeRec(qvRec, qbthr);
	cbAdd = cbKey + cbRec;

	/* check to see if key and rec can fit harmoniously in a block */

	if (cbAdd > qbthr->bth.cbBlock / 2)
	{
		rc = E_FAIL;
		goto exit01;
	}

	qcbLeaf = QCacheBlock(qbthr, qbthr->bth.cLevels - 1);

	if (cbAdd > qcbLeaf->db.cbSlack)
	{
		/* new key and rec don't fit in leaf: split the block */

		/* create new leaf block */

		if ((gh =  _GLOBALALLOC(GMEM_ZEROINIT| GMEM_SHARE| GMEM_MOVEABLE,
		    (LONG)CbCacheBlock(qbthr))) == NULL)
	    {
			rc = E_OUTOFMEMORY;
			goto exit01;
		}
		qcbNew = _GLOBALLOCK(gh);

		if ((qcbNew->bk = BkAlloc(qbthr, &errb)) == bkNil)
		{
			rc = errb;
exit02:
			_GLOBALUNLOCK(gh);
			_GLOBALFREE(gh);
			goto exit01;
		}
		
		if ((rc = RcSplitLeaf(qcbLeaf, qcbNew, qbthr)) != S_OK)
			goto exit02;

		keyNew = (KEY)qcbNew->db.rgbBlock + 2 * sizeof(BK);

		/* insert new leaf into parent block */

		if ((rc = RcInsertInternal(qcbNew->bk,
			keyNew, (SHORT)(qbthr->bth.cLevels - 1), qbthr)) != S_OK)
		{
			goto exit02;
		}

		// InsertInternal can invalidate cache block pointers..

		qcbLeaf = QCacheBlock(qbthr, qbthr->bth.cLevels - 1);

		/* find out which leaf to put new key and rec in and cache it */

		if (WCmpKey(key, keyNew, qbthr) >= 0)
		{
			/* key goes in new block.  Write out old one and cache the new one */
			if ((rc = RcWriteBlock(qcbLeaf, qbthr)) != S_OK)
			    goto exit02;

			QVCOPY(qcbLeaf, qcbNew, (LONG)CbCacheBlock(qbthr));

			/* get pos */
			if ((rc = qbthr->RcScanLeaf(qcbLeaf->bk, key,
				(SHORT)(qbthr->bth.cLevels - 1),
				qbthr, NULL, &btpos)) != E_NOTEXIST)
			{
				if (rc == S_OK)
					rc = E_FAIL;
				goto exit02;
			}
		}
		else
		{

			/* key goes in old block.  Write out the new one */

			if ((rc = RcWriteBlock(qcbNew, qbthr)) != S_OK)
			{
				goto exit02;
			}
		}

		_GLOBALUNLOCK(gh);
		_GLOBALFREE(gh);
	}


	/* insert new key and rec into the leaf block */

	assert(btpos.iKey + cbAdd <= (SHORT)(qbthr->bth.cbBlock -
	     sizeof(DISK_BLOCK) + 1));

	qb = (QB)(qcbLeaf->db.rgbBlock) + btpos.iKey;

	QVCOPY(qb + cbAdd, qb, (LONG)qbthr->bth.cbBlock - btpos.iKey -
		qcbLeaf->db.cbSlack - sizeof(DISK_BLOCK) + 1);

	QVCOPY(qb, (QV)key, (LONG)cbKey);
	QVCOPY(qb + cbKey, qvRec, (LONG)cbRec);

	qcbLeaf->db.cKeys ++;
	qcbLeaf->db.cbSlack -= cbAdd;
	qcbLeaf->bFlags |= fCacheDirty;

	qbthr->bth.lcEntries++;
	qbthr->bth.bFlags |= fFSDirty;
	
	_GLOBALUNLOCK(qbthr->ghCache);
	_GLOBALUNLOCK(hbt);

	return S_OK;
}

PUBLIC HRESULT PASCAL FAR EXPORT_API RcInsertMacBrsHbt(HBT hbt, KEY key, QV qvRec)
{
	QBTHR  qbthr;
	HF     hf;
	HRESULT     rc;
	SHORT    cbAdd, cbKey, cbRec;
	QCB    qcbLeaf, qcbNew, qcb;
	HANDLE gh;
	KEY    keyNew;
	QB     qb;
	BTPOS  btpos;
    ERRB   errb;
	DWORD  tmp;


	if ((qbthr = _GLOBALLOCK(hbt)) == NULL)
        return(E_INVALIDARG);
        
	hf = qbthr->hf;

	if ((rc = RcLookupByKeyAux(hbt, key, &btpos, NULL, TRUE)) == S_OK)
	{
		rc = E_DUPLICATE;
exit0:
		_GLOBALUNLOCK (hbt);
		return rc;
	}

	/*
		After lookup, all nodes on path from root to correct leaf are
		guaranteed to be cached, with iKey valid.
	 */

	if (rc != E_NOTEXIST)
		goto exit0;

	rc = S_OK;

	if (qbthr->bth.cLevels == 0)
	{

		// need to build a valid root block

		if ((qbthr->ghCache = _GLOBALALLOC(GMEM_ZEROINIT| GMEM_SHARE| GMEM_MOVEABLE,
			(LONG)CbCacheBlock(qbthr))) == NULL)
	    {
			rc = E_OUTOFMEMORY;
			goto exit0;
		}

		qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);
		qcb = (QCB)qbthr->qCache;

		qbthr->bth.cLevels  = 1;
		qbthr->bth.bkFirst = qbthr->bth.bkLast = qbthr->bth.bkRoot =
			qcb->bk = BkAlloc(qbthr, &errb);

		if (qcb->bk == bkNil)
		{
exit01:
			_GLOBALUNLOCK(qbthr->ghCache);
			_GLOBALFREE(qbthr->ghCache);
			qbthr->ghCache = NULL;
			rc = errb;
			goto exit0;
		}
		qcb->bFlags         = fCacheDirty | fCacheValid;
		qcb->db.cbSlack     = qbthr->bth.cbBlock - sizeof(DISK_BLOCK) + 1
			                      - 2 * sizeof(BK);
		qcb->db.cKeys       = 0;
		SetBkPrev(qcb, bkNil);
		SetBkNext(qcb, bkNil);
		btpos.iKey = 2 * sizeof(BK);

	}
	else
		qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	cbKey = CbSizeKey(key, qbthr, FALSE);
	cbRec = CbSizeRec(qvRec, qbthr);
	cbAdd = cbKey + cbRec;

	/* check to see if key and rec can fit harmoniously in a block */

	if (cbAdd > qbthr->bth.cbBlock / 2)
	{
		rc = E_FAIL;
		goto exit01;
	}

	qcbLeaf = QCacheBlock(qbthr, qbthr->bth.cLevels - 1);

	if (cbAdd > qcbLeaf->db.cbSlack)
	{
		/* new key and rec don't fit in leaf: split the block */

		/* create new leaf block */

		if ((gh =  _GLOBALALLOC(GMEM_ZEROINIT| GMEM_SHARE| GMEM_MOVEABLE,
		    (LONG)CbCacheBlock(qbthr))) == NULL)
	    {
			rc = E_OUTOFMEMORY;
			goto exit01;
		}
		qcbNew = _GLOBALLOCK(gh);

		if ((qcbNew->bk = BkAlloc(qbthr, &errb)) == bkNil)
		{
			rc = errb;
exit02:
			_GLOBALUNLOCK(gh);
			_GLOBALFREE(gh);
			goto exit01;
		}
		
		if ((rc = RcSplitLeaf(qcbLeaf, qcbNew, qbthr)) != S_OK)
			goto exit02;

		keyNew = (KEY)qcbNew->db.rgbBlock + 2 * sizeof(BK);

		/* insert new leaf into parent block */

		if ((rc = RcInsertInternal(qcbNew->bk,
			keyNew, (SHORT)(qbthr->bth.cLevels - 1), qbthr)) != S_OK)
		{
			goto exit02;
		}

		// InsertInternal can invalidate cache block pointers..

		qcbLeaf = QCacheBlock(qbthr, qbthr->bth.cLevels - 1);

		/* find out which leaf to put new key and rec in and cache it */

		if (WCmpKey(key, keyNew, qbthr) >= 0)
		{
			/* key goes in new block.  Write out old one and cache the new one */
			if ((rc = RcWriteBlock(qcbLeaf, qbthr)) != S_OK)
			    goto exit02;

			QVCOPY(qcbLeaf, qcbNew, (LONG)CbCacheBlock(qbthr));

			/* get pos */
			if ((rc = qbthr->RcScanLeaf(qcbLeaf->bk, key,
				(SHORT)(qbthr->bth.cLevels - 1),
				qbthr, NULL, &btpos)) != E_NOTEXIST)
			{
				if (rc == S_OK)
					rc = E_FAIL;
				goto exit02;
			}
		}
		else
		{

			/* key goes in old block.  Write out the new one */

			if ((rc = RcWriteBlock(qcbNew, qbthr)) != S_OK)
			{
				goto exit02;
			}
		}

		_GLOBALUNLOCK(gh);
		_GLOBALFREE(gh);
	}


	/* insert new key and rec into the leaf block */

	assert(btpos.iKey + cbAdd <= (SHORT)(qbthr->bth.cbBlock -
	     sizeof(DISK_BLOCK) + 1));

	qb = (QB)(qcbLeaf->db.rgbBlock) + btpos.iKey;

	QVCOPY(qb + cbAdd, qb, (LONG)qbthr->bth.cbBlock - btpos.iKey -
		qcbLeaf->db.cbSlack - sizeof(DISK_BLOCK) + 1);

	tmp = GETLONG((QV)key);
	QVCOPY(qb, (QV)&tmp, (LONG)cbKey);
	QVCOPY(qb + cbKey, qvRec, (LONG)cbRec);

	qcbLeaf->db.cKeys ++;
	qcbLeaf->db.cbSlack -= cbAdd;
	qcbLeaf->bFlags |= fCacheDirty;

	qbthr->bth.lcEntries++;
	qbthr->bth.bFlags |= fFSDirty;
	
	_GLOBALUNLOCK(qbthr->ghCache);
	_GLOBALUNLOCK(hbt);

	return S_OK;
}

/***************************************************************************
 *
 *	@doc	PUBLIC API
 *
 *	@func	HRESULT PASCAL FAR | RcUpdateHbt |
 *		Update the record for an existing key.  If the key wasn't
 *		there already, it will not be inserted.
 *
 *	@parm	HBT | hbt |
 *		Handle to B-tree structure
 *
 *	@parm	KEY | key | 
 *		key that already exists in btree
 *
 *	@parm	QV | qvRec |
 *		new record
 *
 *	@rdesc	E_INVALIDARG, S_OK; ERR_NOTEXIST
 *		args OUT:   hbt     - if key was in btree, it now has a new record.
 *
 *	@comm
 *		Method: If the records are the same size, copy the new over
 *		the old. Otherwise, delete the old key/rec and insert the new.
 *
 ***************************************************************************/

PUBLIC HRESULT PASCAL FAR EXPORT_API RcUpdateHbt(HBT hbt, KEY key, QV qvRec)
{
	HRESULT    rc;
	QBTHR qbthr;
	QB    qb;
	QCB   qcb;
	BTPOS btpos;
	WORD wSizeNew,wSizeOld;
	SHORT iSizeKey;


	if ((qbthr = _GLOBALLOCK(hbt)) == NULL)
		return E_INVALIDARG;

	if ((rc = RcLookupByKey(hbt, key, &btpos, NULL)) != S_OK)
	{
		_GLOBALUNLOCK(hbt);
		return rc;
	}

	qbthr->qCache = _GLOBALLOCK(qbthr->ghCache);

	if (qbthr->bth.cLevels <= 0 || qbthr->qCache == NULL)
		return (E_ASSERT);

	qcb = QCacheBlock(qbthr, qbthr->bth.cLevels - 1);
	qb = qcb->db.rgbBlock + btpos.iKey;

	qb += (iSizeKey=CbSizeKey((KEY)qb, qbthr, FALSE));

	if ((wSizeNew=CbSizeRec(qvRec, qbthr)) != (wSizeOld=CbSizeRec(qb, qbthr)))
	{
		// Today's the day we do something clever:
		if ((wSizeNew<wSizeOld) || ((wSizeNew>wSizeOld) && (qcb->db.cbSlack>=wSizeNew-wSizeOld)))
		{
		 	WORD wBytesAfterBlock = (WORD) (qbthr->bth.cbBlock-sizeof(qcb->db)+1 -qcb->db.cbSlack -btpos.iKey -wSizeOld -iSizeKey);
			QB qb1, qb2;
			qb1=qb+max(wSizeNew,wSizeOld)+wBytesAfterBlock;
			qb2=(QB)(&qcb->db)+qbthr->bth.cbBlock;
			assert(qb1<=qb2);

		 	if (wBytesAfterBlock)
		 		QVCOPY(qb+wSizeNew,qb+wSizeOld,(LONG)wBytesAfterBlock);
			QVCOPY(qb, qvRec, (LONG)wSizeNew);			
			qcb->bFlags |= fCacheDirty;
			qbthr->bth.bFlags |= fFSDirty;
			qcb->db.cbSlack=qcb->db.cbSlack+wSizeOld-wSizeNew;		

			_GLOBALUNLOCK(qbthr->ghCache);
			_GLOBALUNLOCK(hbt);
		}
		else 
		{
			_GLOBALUNLOCK(qbthr->ghCache);
			_GLOBALUNLOCK(hbt);
		
			rc = RcDeleteHbt(hbt, key);

			if (rc == S_OK)
			{
				rc = RcInsertHbt(hbt, key, qvRec);
			}			
		}
	}
	else
	{
		QVCOPY(qb, qvRec, (LONG)wSizeNew);

		qcb->bFlags |= fCacheDirty;
		qbthr->bth.bFlags |= fFSDirty;

		_GLOBALUNLOCK(qbthr->ghCache);
		_GLOBALUNLOCK(hbt);
	}

	return rc;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\itircl\common\btree\btktcmap.c ===
/*****************************************************************************
 *                                                                            *
 *  BTKTCMAP.C                                                                *
 *                                                                            *
 *  Copyright (C) Microsoft Corporation 1990 - 1994.                          *
 *  All Rights reserved.                                                      *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Module Intent                                                             *
 *                                                                            *
 *  Functions for SZ (0-terminated string) keys.                              *
 *                                                                            *
 ******************************************************************************
 *                                                                            *
 *  Current Owner:  BinhN                                                     *
 *                                                                            *
 *****************************************************************************/

static char s_aszModule[] = __FILE__;  /* For error report */

#include <mvopsys.h>

#ifdef _MAC
#include <winnls.h>
#endif

#include <orkin.h>
#include <string.h>
#include <misc.h>
#include <iterror.h>
#include <wrapstor.h>
#include <mvdbcs.h>
#include <mvsearch.h>
#include <_mvutil.h>
#include "common.h"



// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// When ligature tables are implemented again, take this out !!!!!!!!!!
//#define NOCHARTABLES_FIXME

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


/**************************************
 * MASKS TO DEAL WITH KEYWORD SORTING *
 * (SHOULD MATCH WITH wmvc\keyword.c) *
 **************************************/
 
#define PRIMARY_SORT_MASK   0x0Fff
#define SECONDARY_SORT_MASK 0xF000

/*****************************************************************************
*                                                                            *
*           Tables for StringJCompare() - Japanese "50-on" sorting           *
*                                                                            *
*****************************************************************************/

static unsigned char pbPriHi[] = {
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,0x22,
0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0x23,0x24,0x25,0x26,0x27,0x28,
0x29,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,
0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x2A,0x2B,0x2C,0x2D,0x2E,
0x2F,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,
0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x30,0x31,0x32,0x33,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x13,0x38,0x3C,0x3D,0x37,0x43,0xB8,0x87,0x88,0x89,0x8A,0x8B,0xAA,0xAC,0xAE,0x98,
0x44,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,
0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,
0xA6,0xA7,0xA8,0xA9,0xAA,0xAC,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB9,0x3F,0x40,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x12,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
0x13,0x37,0x38,0x1F,0x21,0x43,0x23,0x24,0x28,0x14,0x3F,0x40,0x34,0x2F,0x34,0x2D,
0x33,0x2e,0x45,0x46,0x41,0x42,0x39,0x47,0x3A,0x3B,0x3B,0x44,0x35,0x34,0x22,0x47,
0x47,0x36,0x31,0x36,0x36,0x1A,0x1A,0x15,0x15,0x1B,0x1C,0x3E,0x3E,0x2A,0x2C,0x30,
0x32,0x3B,0x3B,0x3B,0x3B,0x3C,0x3D,0x3E,0x3E,0x3E,0x3E,0x1E,0x20,0x34,0x34,0xC1,
0x34,0x26,0x36,0x25,0x27,0x36,0x36,0x36,0x36,0x36,0x36,0x34,0x36,0x36,0x36,0x2B,
0x17,0x47,0x47,0x18,0x16,0x19,0x1D,0x29,0x34,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3E,0x36,0x36,0x36,0x36,0x3E,0xC1,0xC1,0xC1,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0x36,0x36,0x47,0x36,0x36,0x36,0x36,0xC1,
0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0x36,0x36,0x36,0x36,0x36,0x36,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x34,0xC1,0xC1,0xC1,0xC1,0x36,0xC1,0xC1,0xC1,
0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,
0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,
0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,
0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,
0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0x56,
0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,
0xC2,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,
0x6F,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0xC2,0xC2,0xC2,0xC2,0x87,
0x87,0x88,0x88,0x89,0x89,0x8A,0x8A,0x8B,0x8B,0x8C,0x8C,0x8D,0x8D,0x8E,0x8E,0x8F,
0x8F,0x90,0x90,0x91,0x91,0x92,0x92,0x93,0x93,0x94,0x94,0x95,0x95,0x96,0x96,0x97,
0x97,0x98,0x98,0x98,0x99,0x99,0x9A,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xA0,0xA0,0xA0,
0xA1,0xA1,0xA1,0xA2,0xA2,0xA2,0xA3,0xA3,0xA3,0xA4,0xA4,0xA4,0xA5,0xA6,0xA7,0xA8,
0xA9,0xAA,0xAA,0xAC,0xAC,0xAE,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB4,0xB5,0xB7,
0xB8,0xB9,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,0xC2,
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,
0x87,0x87,0x88,0x88,0x89,0x89,0x8A,0x8A,0x8B,0x8B,0x8C,0x8C,0x8D,0x8D,0x8E,0x8E,
0x8F,0x8F,0x90,0x90,0x91,0x91,0x92,0x92,0x93,0x93,0x94,0x94,0x95,0x95,0x96,0x96,
0x97,0x97,0x98,0x98,0x98,0x99,0x99,0x9A,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xA0,0xA0,
0xA0,0xA1,0xA1,0xA1,0xA2,0xA2,0xA2,0xA3,0xA3,0xA3,0xA4,0xA4,0xA4,0xA5,0xA6,0xC3,
0xA7,0xA8,0xA9,0xAA,0xAA,0xAC,0xAC,0xAE,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB4,
0xB5,0xB7,0xB8,0xB9,0x89,0x8C,0x8F,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x7C,
0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,
0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0x7C,
0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,
0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,
0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,0xC3,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,
0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,
0x7D,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0xC4,
0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,0x7D,
0x7D,0x7D,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0x36,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xC4,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,0xC4,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,0xC5,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,
0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,
0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,
0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,
0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xC7,0x47,
0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,
0x47,0x47,0x47,0x47,0x47,0x47,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0xC7,0x47,0xC7,
0x3E,0x3E,0x36,0x47,0x36,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,
0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xC7,0xC7,0xC7
};

static unsigned char pbPriLo[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x02,0x00,
0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x28,0xFF,0x03,0x04,0xFF,0xFF,0x09,0x00,0x29,
0x2A,0x2B,0x00,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x08,0x00,0x00,0x00,
0x00,0x05,0x06,0x07,0x08,0x00,0x00,0x01,0x02,0x03,0x04,0x00,0x00,0x04,0x07,0x7F,
0x08,0x00,0x3C,0x00,0x00,0x3F,0x40,0x27,0x36,0x8E,0x8D,0x03,0x06,0x07,0x09,0x00,
0x00,0x2B,0x2C,0x00,0x00,0x00,0x00,0x00,0x01,0x8C,0x8B,0x87,0x89,0x88,0x86,0x85,
0x80,0x7F,0x82,0x81,0x84,0x83,0x08,0x05,0x19,0x17,0x18,0x1A,0x06,0xAD,0xAE,0xAF,
0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0x21,0x22,0x45,0x46,0x43,0x44,0x30,0x2E,
0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0x2C,0x2D,0x2D,0x1B,0x1C,0x1D,0x1F,0xCF,
0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0x29,0x47,0x4A,0x1E,0x20,0x3D,
0x3A,0x41,0x42,0x24,0x39,0x26,0x37,0x32,0x34,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
0x0C,0x05,0x91,0x90,0x8F,0x01,0x02,0x06,0xF8,0xF9,0xFA,0xFB,0x8A,0xFD,0xFE,0xFF,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9B,0x9C,0x9D,0x9E,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,
0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,
0x00,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00,
0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,
0xFF,0x00,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
0x00,0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0xFF,0x7F,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x11,
0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,
0x22,0x23,0x24,0x25,0x26,0x27,0x28,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0x11,
0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,0x21,
0x22,0x23,0x24,0x25,0x26,0x27,0x28,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x20,
0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x30,
0x31,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x7F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x5F,
0x61,0x63,0x65,0x69,0x67,0x6B,0x73,0x6F,0x77,0x7B,0x60,0x62,0x64,0x66,0x6A,0x68,
0x6E,0x76,0x72,0x7A,0x7E,0x6D,0x74,0x71,0x78,0x7C,0x6C,0x75,0x70,0x79,0x7D,0xBF,
0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,
0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,
0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x5B,0x5C,0x5D,0x5E,0x5F,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x7E,0x7F,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,
0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,
0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF,
0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,
0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF,
0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,
0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF,
0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,
0x4B,0x4C,0x4D,0x4E,0x4F,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,
0x5B,0x5C,0x5D,0x5E,0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x5E,0x17,
0x0E,0x10,0x19,0x0F,0x13,0x0C,0x15,0x1A,0x1B,0x0D,0x12,0x11,0x14,0x18,0x16,0x22,
0x23,0x24,0x20,0x21,0x26,0x25,0x76,0x77,0x78,0x79,0x7A,0x7B,0x7C,0x7D,0x1C,0x7F,
0x09,0x0A,0x0A,0x27,0x0B,0x07,0x08,0x09,0x0A,0x0B,0x04,0x05,0x06,0x1F,0x1E,0x1D,
0x3B,0x3E,0x33,0x35,0x23,0x25,0x48,0x2A,0x28,0x49,0x38,0x2F,0x31,0x9D,0x9E,0x9F
};

static unsigned char pbSecWgt[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x14,0x04,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x40,0x00,0x40,
0x40,0x40,0x08,0x09,0x08,0x09,0x00,0x00,0x08,0x00,0x00,0x54,0x54,0x00,0x40,0x00,
0x00,0x00,0x40,0x00,0x00,0x40,0x44,0x40,0x44,0x40,0x40,0x00,0x00,0x40,0x40,0x40,
0x40,0x00,0x00,0x00,0x00,0x40,0x40,0x00,0x00,0x00,0x00,0x40,0x40,0x00,0x00,0x00,
0x00,0x40,0x00,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
0x40,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,
0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x60,
0x64,0x60,0x64,0x60,0x64,0x60,0x64,0x60,0x64,0x64,0x65,0x60,0x61,0x60,0x61,0x64,
0x65,0x60,0x61,0x60,0x61,0x60,0x61,0x60,0x61,0x60,0x61,0x60,0x61,0x60,0x61,0x60,
0x61,0x60,0x64,0x65,0x60,0x61,0x60,0x61,0x60,0x60,0x60,0x60,0x60,0x60,0x61,0x62,
0x60,0x61,0x62,0x60,0x61,0x62,0x60,0x61,0x62,0x60,0x61,0x62,0x60,0x60,0x60,0x60,
0x60,0x60,0x64,0x60,0x64,0x60,0x64,0x60,0x60,0x60,0x60,0x60,0x60,0x64,0x20,0x20,
0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x40,0x44,0x40,0x44,0x40,0x44,0x40,0x44,0x40,0x44,0x44,0x45,0x40,0x41,0x40,0x41,
0x44,0x45,0x40,0x41,0x40,0x41,0x40,0x41,0x40,0x41,0x40,0x41,0x40,0x41,0x40,0x41,
0x40,0x41,0x40,0x44,0x45,0x40,0x41,0x40,0x41,0x40,0x40,0x40,0x40,0x40,0x40,0x41,
0x42,0x40,0x41,0x42,0x40,0x41,0x42,0x40,0x41,0x42,0x40,0x41,0x42,0x40,0x40,0x00,
0x40,0x40,0x40,0x40,0x44,0x40,0x44,0x40,0x44,0x40,0x40,0x40,0x40,0x40,0x40,0x44,
0x00,0x00,0x40,0x40,0x45,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

static unsigned char pbSecFlg[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x22,0x20,0x20,0x20,0x20,0x22,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,
0x20,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x20,0x20,0x20,0x20,0x20,
0x20,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x20,0x20,0x20,0x20,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x20,0x20,0x20,0x20,0x35,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,
0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x35,0x35,0x37,0x35,0x35,0x35,0x35,0x35,0x35,
0x35,0x35,0x37,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
0x35,0x35,0x35,0x35,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x35,0x37,0x35,0x20,0x20,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00,0x20,
0x20,0x20,0x05,0x05,0x05,0x05,0x00,0x00,0x04,0x00,0x00,0x37,0x37,0x00,0x20,0x00,
0x00,0x00,0x20,0x00,0x00,0x22,0x22,0x22,0x22,0x20,0x20,0x00,0x00,0x20,0x20,0x20,
0x20,0x00,0x00,0x00,0x00,0x20,0x20,0x00,0x00,0x00,0x00,0x20,0x20,0x00,0x00,0x00,
0x00,0x20,0x00,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
0x20,0x00,0x00,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,
0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x00,0x00,0x00,0x00,0x37,
0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x37,
0x37,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
0x35,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
0x35,0x37,0x37,0x37,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x35,0x37,0x37,0x15,0x15,
0x35,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x35,0x35,0x35,0x35,
0x37,0x37,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
0x35,0x35,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,
0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x00,
0x35,0x35,0x35,0x37,0x37,0x37,0x37,0x37,0x37,0x35,0x35,0x35,0x35,0x35,0x37,0x37,
0x15,0x15,0x35,0x35,0x37,0x37,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x00,
0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,
0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

static unsigned char pbgMasks[] = {
      0x03, 0x01, 0x00, 0x02
    , 0x04, 0x02, 0x02, 0x01
    , 0x18, 0x04, 0x03, 0x02
    , 0x20, 0x18, 0x05, 0x01
    , 0x40, 0x20, 0x06, 0x01
    , 0x00, 0x00, 0x00, 0x00
};

static unsigned char pbIgnore[] = {
      0x1F, 0x07, 0x00, 0x02
    , 0x20, 0x08, 0x00, 0x01
    , 0x20, 0x10, 0x00, 0x40
    , 0x40, 0x20, 0x00, 0x08
    , 0x00, 0x00, 0x00, 0x00
};


#define	isDbcsJ( c, next) ((c >= 0x80 && c <= 0xA0) || (c >= 0xE0 && c <= 0xFF))

DWORD g_dwFlags; 

typedef struct tagCOMPSTRINGINFO{
    unsigned      priwt;
    unsigned char secwt;
    unsigned char secflg;
} COMPSTRINGINFO;

typedef struct tagSTRINFO_J
{
    LPBYTE pbPriHi;
    LPBYTE pbPriLo;
    LPBYTE pbSecWgt;
    LPBYTE pbSecFlg;
    LPBYTE pbMasks;
    LPBYTE pbMaps;
    LPBYTE pbIgnore;
    LPBYTE pbC1JPN;
    LPBYTE pbC2JPN;
    LPBYTE pbC3JPN;
}
STRINFO_J;

// Prototypes for Japanese sorting functions

PUBLIC int PASCAL FAR StringJCompare (DWORD dwFlags, LPBYTE lpstr1, int cch1,
    LPBYTE lpstr2, int cch2);

PRIVATE int PASCAL NEAR GetSortWeightJ(LPBYTE FAR*plpstr1,int cch1,
    COMPSTRINGINFO FAR *pcompstrinfo);
 
 
/***************************************************************************
 *
 * @doc  INTERNAL
 * 
 * @func BK FAR PASCAL | BkScanCMapInternal |
 *    Scan an internal node for a key and return child BK.
 *
 * @parm BK | bk |
 *    BK of internal node to scan
 *
 * @parm KEY | key |
 *    key to search for
 *
 * @parm SHORT | wLevel |
 *    level of btree bk lives on
 *
 * @parm QBTHR | qbthr |
 *    btree header containing cache, and btree specs
 *
 * @parm QW | qiKey |
 *    address of an int or NULL to not get it
 *
 * @rdesc   bk of subtree that might contain key; bkNil on error
 *    args OUT:   qbthr->qCache - bk's block will be cached
 *    qiKey       - index into rgbBlock of first key >= key
 *
 *    Side Effects:   bk's block will be cached
 *
 ***************************************************************************/

PUBLIC BK FAR PASCAL BkScanCMapInternal(BK bk, KEY key, SHORT wLevel,
   QBTHR qbthr, QW qiKey, PHRESULT phr)
{
    QCB qcb;                // Pointer to cache block
    QB  q;                  // Pointer to block buffer
    SHORT cKeys;            // Number of keys in the block
    SZ  szSaved = NULL;
    int fCompare;
    int KeyLength;
    int length;

    if ((qcb = QFromBk(bk, wLevel, qbthr, phr)) == NULL)
    {
        return bkNil;
    }

    q     = qcb->db.rgbBlock;  // Block buffer
    cKeys = qcb->db.cKeys;     // Number of keys in the block

    bk = (BK)GETLONG(q);           // Get leaf block number 
    q += sizeof(DWORD);
    KeyLength = (int) STRLEN((SZ)key);

    while (cKeys-- > 0)
    {
        length = (int) STRLEN((SZ)q);
        if (PRIMARYLANGID(LANGIDFROMLCID(qbthr->bth.lcid)) == LANG_JAPANESE)
            fCompare = StringJCompare(0L, (SZ)key, KeyLength, (SZ)q, length);
        else
            fCompare = StrFntMappedLigatureComp((SZ)key, (SZ)q,
                qbthr->lrglpCharTab);
        if (fCompare >= 0)
        {
            q += length + 1;
            bk = (BK)GETLONG(q);
            q += sizeof(DWORD);
        }
        else
            break;
    }

    if (qiKey != NULL)
    {
        *qiKey = (WORD)(q - (QB)qcb->db.rgbBlock);
    }

    return bk;
}

/***************************************************************************
 *
 * @doc  INTERNAL
 *
 * @func HRESULT FAR PASCAL | RcScanCMapLeaf |
 *    Scan a leaf node for a key and copy the associated data.
 *
 * @parm BK | bk |
 *    the leaf block
 *
 * @parm KEY | key |
 *    the key we're looking for
 *
 * @parm SHORT | wLevel |
 *    the level of leaves (unnecessary)
 *
 * @parm QBTHR | qbthr |
 *    the btree header
 *
 * @parm QV | qRec |
 *    if found, record gets copied into this buffer
 *
 * @parm QTPOS | qbtpos |
 *    pos of first key >= key goes here
 *
 * @rdesc   ERR_SUCESS if found; ERR_NOTEXIST if not found
 *    If we are scanning for a key greater than any key in this
 *    block, the pos returned will be invalid and will point just
 *    past the last valid key in this block.
 *
 ***************************************************************************/

PUBLIC HRESULT FAR PASCAL RcScanCMapLeaf(BK bk, KEY key, SHORT wLevel,
   QBTHR qbthr, QV qRec, QBTPOS qbtpos)
{
    QCB   qcb;
    SZ    sz;
    int   fRet;
    HRESULT    rc;
    SHORT i;
    SHORT cKeys;      // Number of keys in the block
    SZ    szSaved = NULL;
    int   KeyLength, length, lengthSaved = 0;
    HRESULT  errb;


    if ((qcb = QFromBk(bk, wLevel, qbthr, &errb)) == NULL)
    {
        return errb;
    }

    rc = E_NOTEXIST;

    sz = qcb->db.rgbBlock + 2 * sizeof(BK);
    cKeys = qcb->db.cKeys; 
    
    KeyLength = (int) STRLEN((SZ)key);

    for (i= 0; i < cKeys; i++)
    {
        length = (int) STRLEN((SZ)sz);


#ifdef NOCHARTABLES_FIXME

		fRet=STRCMP((SZ)key, (SZ)sz);

#else

        if (PRIMARYLANGID(LANGIDFROMLCID(qbthr->bth.lcid)) == LANG_JAPANESE)
            fRet = StringJCompare(0L, (SZ)key, KeyLength, (SZ)sz, length);
        else
            fRet = StrFntMappedLigatureComp((SZ)key, (SZ)sz,
                qbthr->lrglpCharTab);

#endif

         
      if (fRet > 0) /* still looking for key */
      {
         sz += length + 1;
         sz += CbSizeRec(sz, qbthr);
      }
      else if (fRet < 0) /* key not found */
      {
         if (szSaved)
         {
             sz = szSaved;
             /* Return 1st match match */
             if (qRec != NULL) {
                sz = (QB)sz + lengthSaved + 1;
                QVCOPY(qRec, sz, (LONG)CbSizeRec(sz, qbthr));
             }

             rc = S_OK;
         }
         
         break;
      }
      else /* matched the key */
      {
         /* We only save the location of the 1st element in the list */
         if (szSaved == NULL)
         {
            szSaved = sz;
            lengthSaved = length;
         }
         if (STRICMP((SZ)key, (SZ)sz) == 0) 
         {
             /* This is a real match */
             if (qRec != NULL) {
                sz = (QB)sz + length + 1;
                QVCOPY(qRec, sz, (LONG)CbSizeRec(sz, qbthr));
             }

             rc = S_OK;
             break;
         }
            
         sz += length + 1;
         sz += CbSizeRec(sz, qbthr);
      }
   }

   if (qbtpos != NULL)
   {
      qbtpos->bk   = bk;
      qbtpos->cKey = i;
      qbtpos->iKey = (int)((QB)sz - (QB)qcb->db.rgbBlock);
   }

   return rc;
}

/***********************************************************************
 * @func int PASCAL FAR | StrFntMappedLigatureComp |
 *    The function will compare two special zero-terminated strings.
 *    The strings contain information about their font maps given by
 *             1 <x + 1>
 *       - 1 : next byte will be the font map index
 *       - x + 1 :  font map index + 1
 *
 * @parm SZ | sz1|
 *    String 1
 *
 * @parm SZ | sz2 |
 *    String 2
 *
 * @parm LPCHARTAB FAR *| qrglpCharTab |
 *    Font mapping and ligature information
 *
 * @rdesc
 *    < 0 : if sz1 < sz2
 *    = 0 : if sz1 = sz2
 *    > 0 : if sz1 > sz2
 *
 * @comm    The function still may fail in the case of comparing
 *       a[essetz]s with as[essetz]
 ***********************************************************************/
PUBLIC int EXPORT_API PASCAL FAR StrFntMappedLigatureComp(SZ sz1, SZ sz2,
   LPCHARTAB FAR *qrglpCharTab )
{
    LPCMAP lpCMap1;         // Pointer to font map for string 1
    LPCMAP lpCMap2;         // Pointer to font map for string 2
    LPBYTE lpbLigature1;    // Pointer to ligature table for string 1
    LPBYTE lpbLigature2;    // Pointer to ligature table for string 2
    LPBYTE lpb;             // Scratch variable
    BYTE   ch1;
    BYTE   ch2;
    BYTE   chLig1;          // 2nd ligature bytes
    BYTE   chLig2;          // 2nd ligature bytes
    int    fRet;            // Returned value
	BYTE   cDelimiter1 = 0;
	BYTE   cDelimiter2 = 0;
	char   chDiff1 = 0;
	char   chDiff2 = 0;
	int    fRet2 = 0;       // Secondary returned value

    /* Get the default character map & ligature table */
    lpCMap1 = lpCMap2 = qrglpCharTab[0]->lpCMapTab;
    lpbLigature1 = lpbLigature2 = qrglpCharTab[0]->lpLigature;

    for (;; sz1++, sz2++)
    {
        
        ch1 = *sz1;
        ch2 = *sz2;
#if 0 // do not enable.  for Diff purposes only
		if (ch1 == DELIMITER)
		{
			cDelimiter1++;
			if (cDelimiter1 >= 2)
			{
				ch1 = 0;
			}
		}
		if (ch2 == DELIMITER)
		{
			cDelimiter2++;
			if (cDelimiter2 >= 2)
			{
				ch2 = 0;
			}
		}
#endif // 0

        if ((lpCMap1[ch1].Class  & SPECIAL_CHAR_MAP) == CLASS_TERMINATOR)
            ch1 = 0;
        if ((lpCMap1[ch2].Class  & SPECIAL_CHAR_MAP) == CLASS_TERMINATOR)
            ch2 = 0;

        while (ch1 == EMBEDFONT_BYTE_TAG)  // Change font map
        {
            sz1++;      // Skip the font info
            lpCMap1 = qrglpCharTab[ch1 = *sz1++ - 1]->lpCMapTab;    // Get the new font map
            lpbLigature1 = qrglpCharTab[ch1]->lpLigature;    // Get the new ligature
            ch1 = *sz1;
        }
        while (ch2 == EMBEDFONT_BYTE_TAG)  // Change font map
        {
            sz2++;      // Skip the font info
            lpCMap2 = qrglpCharTab[ch2 = *sz2++ - 1]->lpCMapTab;    // Get the new font map
            lpbLigature2 = qrglpCharTab[ch2]->lpLigature;    // Get the new ligature
            ch2 = *sz2;
        }

        if (ch1 == 0 || ch2 == 0)
            break;
        
        /* A sort order = 0 means that you want to ignore this letter */
        if (lpCMap1[ch1].SortOrder == 0)
        {
            // Skip this letter. 
			if (lpCMap1[ch2].SortOrder != 0)
			{
				if (chDiff1 == 0)
				{
					chDiff1 = -1;
					chDiff2 = 1;
				}
				sz2--;  // Compensate the increment
			}
			else if (ch1 != ch2)
			{
				// To fix the case of : (oui and !oui
				if (chDiff1 == 0)
					chDiff1 = ch1;
				if (chDiff2 == 0)
					chDiff2 = ch2;
			}
            continue;
        }
        
        if (lpCMap2[ch2].SortOrder == 0)
        {
            // Skip this letter. 
			if (lpCMap1[ch1].SortOrder != 0)
			{
				if (chDiff2 == 0)
				{
					chDiff2 = -1;
					chDiff1 = 1;
				}
				sz1--;  // Compensate the increment
			}
            continue;
        }

		/* Do this before ligature so that we can catch the case of
		 * ligature being greater than equivalent bytes
		 */
		if (fRet2 == 0)
			fRet2 = (lpCMap1[ch1].SortOrder & SECONDARY_SORT_MASK)
				- (lpCMap2[ch2].SortOrder & SECONDARY_SORT_MASK);
        
        /**************************************************
        * WE NOW HAVE TO CHECK FOR LIGATURES SORTING ORDER.
        ***************************************************/
        chLig1 = 0;
        chLig2 = 0;
        if (lpbLigature1 && lpCMap1[ch1].Class == CLASS_LIGATURE)
        {
            for (lpb = lpbLigature1; *lpb; lpb += 3)
            {
                if (*lpb == ch1) 
                {
                    ch1 = lpb[1];
                    chLig1 = lpb[2];
                    break;
                }
            }
        }
        if (lpbLigature2 && lpCMap2[ch2].Class == CLASS_LIGATURE) 
        {
            for (lpb = lpbLigature2; *lpb; lpb += 3)
            {
                if (*lpb == ch2)
                {
                    ch2 = lpb[1];
                    chLig2 = lpb[2];
                    break;
                }
            }
        }
        
        /* Now we have to check for ligature compared with non ligature */
        if (chLig1 != 0 && chLig2 == 0) 
        {
            chLig2 = *(++sz2);
        }

        if (chLig2 != 0 && chLig1 == 0)
        {
            chLig1 = *(++sz1);
        }


        if (fRet = (lpCMap1[ch1].SortOrder & PRIMARY_SORT_MASK)
            - (lpCMap2[ch2].SortOrder & PRIMARY_SORT_MASK))
            return(fRet);
          
        if (fRet = (lpCMap1[chLig1].SortOrder & PRIMARY_SORT_MASK) -
            (lpCMap2[chLig2].SortOrder & PRIMARY_SORT_MASK))
			return (fRet);

		// REVIEW: how to handle ligature secondary sort
        if (fRet = (lpCMap1[chLig1].SortOrder & SECONDARY_SORT_MASK) -
            (lpCMap2[chLig2].SortOrder & SECONDARY_SORT_MASK))
			return (fRet);

        if (fRet2 == 0) 
        {
            fRet2 = (lpCMap1[ch1].SortOrder & SECONDARY_SORT_MASK)
            - (lpCMap2[ch2].SortOrder & SECONDARY_SORT_MASK);
        }

    }
	if (ch1 != ch2)
	{
		if ((ch1 == 0 && lpCMap2[ch2].SortOrder == 0) ||
			(ch2 == 0 && lpCMap1[ch1].SortOrder == 0))
		{
			if (chDiff1 != chDiff2)
				return (chDiff1 - chDiff2);
		}
		return(ch1 - ch2);
	}

	// REVIEW:  Check case where chDiff1==chDiff2 and fRet2 != 0
	// REVIEW:  Merge this with btree compare
	return ((fRet = chDiff1 - chDiff2) == 0 ? fRet2 : fRet);
}


PUBLIC VOID EXPORT_API PASCAL FAR BtreeSetCMap (HANDLE hbt,
	LPCHARTAB FAR * lrglpCharTab)
{
	QBTHR qbthr;


    if (hbt == NULL || lrglpCharTab == NULL)
        return;
    qbthr = _GLOBALLOCK(hbt);

	qbthr->lrglpCharTab = lrglpCharTab;
    _GLOBALUNLOCK(hbt);
    return;
}

PUBLIC LPVOID EXPORT_API PASCAL FAR BtreeGetCMap (HANDLE hbt)
{
    QBTHR qbthr;
    LPVOID lpv;

    if (hbt == NULL)
        return NULL;
	qbthr = _GLOBALLOCK(hbt);

    lpv = (LPVOID)qbthr->lrglpCharTab;
    _GLOBALUNLOCK(hbt);
    return lpv;
}


/***********************************************************************
 * @func int | PASCAL FAR | StringJCompare |
 *    Compares two Japanese strings for sorting order.
 *
 *  @parm   DWORD | dwFlags |
 *          - zero or more of
 *          NORM_IGNORECASE
 *          NORM_IGNORENONSPACE
 *          NORM_IGNORESYMBOLS
 *
 *  @parm   LPBYTE | lpStr1 |
 *      Pointer to string to compare
 *
 *  @parm   int | cch1 |
 *      length of string
 *
 *  @parm   LPBYTE | lpStr2 |
 *      pointer to string to compare
 *
 *  @parm   int | cch2 |
 *      length of string
 *
 *  @rdesc 
 *		< 0 : if sz1 < sz2
 *		= 0 : if sz1 = sz2
 *		> 0 : if sz1 > sz2
 ***********************************************************************/

PUBLIC int EXPORT_API PASCAL FAR StringJCompare( DWORD dwFlags,
    LPBYTE lpstr1, int cch1, LPBYTE lpstr2, int cch2)
{
    LPBYTE pbMasks;
    unsigned char b1stDiff;
    int b1stDiffValue;
    unsigned char bFlgMask, bWgtMask;
    int bTemp;
    COMPSTRINGINFO compstrinfo1, compstrinfo2;

    b1stDiff=0;
    b1stDiffValue=0;

    /* initialise to indicate no previous character */
    g_dwFlags = dwFlags;
    compstrinfo1.priwt = compstrinfo1.secwt = 0;
    compstrinfo2.priwt = compstrinfo2.secwt = 0;

    /* must continue even if one string empty, to ignore trailing punc */
    while (cch1 || cch2