ntactLocationTypeField = value;
            }
        }
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string street {
            get {
                return this.streetField;
            }
            set {
                this.streetField = value;
            }
        }
        
        /// <remarks/>
        public string city {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
        /// <remarks/>
        public string state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public string country {
            get {
                return this.countryField;
            }
            set {
                this.countryField = value;
            }
        }
        
        /// <remarks/>
        public string postalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public string Office {
            get {
                return this.officeField;
            }
            set {
                this.officeField = value;
            }
        }
        
        /// <remarks/>
        public string Department {
            get {
                return this.departmentField;
            }
            set {
                this.departmentField = value;
            }
        }
        
        /// <remarks/>
        public double Latitude {
            get {
                return this.latitudeField;
            }
            set {
                this.latitudeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LatitudeSpecified {
            get {
                return this.latitudeFieldSpecified;
            }
            set {
                this.latitudeFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public double Longitude {
            get {
                return this.longitudeField;
            }
            set {
                this.longitudeField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool LongitudeSpecified {
            get {
                return this.longitudeFieldSpecified;
            }
            set {
                this.longitudeFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public ContactLocationProperty Changes {
            get {
                return this.changesField;
            }
            set {
                this.changesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ContactLocationType {
        
        /// <remarks/>
        ContactLocationPersonal,
        
        /// <remarks/>
        ContactLocationBusiness,
        
        /// <remarks/>
        Other,
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ContactLocationProperty {
        
        /// <remarks/>
        Name = 1,
        
        /// <remarks/>
        Street = 2,
        
        /// <remarks/>
        City = 4,
        
        /// <remarks/>
        State = 8,
        
        /// <remarks/>
        Country = 16,
        
        /// <remarks/>
        PostalCode = 32,
        
        /// <remarks/>
        Office = 64,
        
        /// <remarks/>
        Department = 128,
        
        /// <remarks/>
        Latitude = 256,
        
        /// <remarks/>
        Longitude = 512,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class ContactWebSite {
        
        private ContactWebSiteType contactWebSiteTypeField;
        
        private string webURLField;
        
        /// <remarks/>
        public ContactWebSiteType contactWebSiteType {
            get {
                return this.contactWebSiteTypeField;
            }
            set {
                this.contactWebSiteTypeField = value;
            }
        }
        
        /// <remarks/>
        public string webURL {
            get {
                return this.webURLField;
            }
            set {
                this.webURLField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ContactWebSiteType {
        
        /// <remarks/>
        ContactWebSitePersonal,
        
        /// <remarks/>
        ContactWebSiteBusiness,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ContactType {
        
        /// <remarks/>
        Regular,
        
        /// <remarks/>
        Me,
        
        /// <remarks/>
        Live,
        
        /// <remarks/>
        LiveDropped,
        
        /// <remarks/>
        LivePending,
        
        /// <remarks/>
        LiveRejected,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum SpotType {
        
        /// <remarks/>
        NoDevice,
        
        /// <remarks/>
        NoMessaging,
        
        /// <remarks/>
        MessagingEnabled,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum GenderType {
        
        /// <remarks/>
        Unspecified,
        
        /// <remarks/>
        Female,
        
        /// <remarks/>
        Male,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum TimeZoneRange {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        GmtMinus12h,
        
        /// <remarks/>
        GmtMinus11h,
        
        /// <remarks/>
        GmtMinus10h,
        
        /// <remarks/>
        GmtMinus9h,
        
        /// <remarks/>
        GmtMinus8h,
        
        /// <remarks/>
        GmtMinus7h,
        
        /// <remarks/>
        GmtMinus6h,
        
        /// <remarks/>
        GmtMinus5h,
        
        /// <remarks/>
        GmtMinus4h,
        
        /// <remarks/>
        GmtMinus3h30,
        
        /// <remarks/>
        GmtMinus3h,
        
        /// <remarks/>
        GmtMinus2h,
        
        /// <remarks/>
        GmtMinus1h,
        
        /// <remarks/>
        Gmt,
        
        /// <remarks/>
        GmtPlus1h,
        
        /// <remarks/>
        GmtPlus2h,
        
        /// <remarks/>
        GmtPlus3h,
        
        /// <remarks/>
        GmtPlus3h30,
        
        /// <remarks/>
        GmtPlus4h,
        
        /// <remarks/>
        GmtPlus4h30,
        
        /// <remarks/>
        GmtPlus5h,
        
        /// <remarks/>
        GmtPlus5h30,
        
        /// <remarks/>
        GmtPlus5h45,
        
        /// <remarks/>
        GmtPlus6h,
        
        /// <remarks/>
        GmtPlus6h30,
        
        /// <remarks/>
        GmtPlus7h,
        
        /// <remarks/>
        GmtPlus8h,
        
        /// <remarks/>
        GmtPlus9h,
        
        /// <remarks/>
        GmtPlus9h30,
        
        /// <remarks/>
        GmtPlus10h,
        
        /// <remarks/>
        GmtPlus11h,
        
        /// <remarks/>
        GmtPlus12h,
        
        /// <remarks/>
        GmtPlus13h,
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ContactPropertyType : long {
        
        /// <remarks/>
        ContactPrimaryEmailType = 1,
        
        /// <remarks/>
        ContactFirstName = 2,
        
        /// <remarks/>
        ContactLastName = 4,
        
        /// <remarks/>
        ContactQuickName = 8,
        
        /// <remarks/>
        ContactBirthDate = 16,
        
        /// <remarks/>
        ContactEmail = 32,
        
        /// <remarks/>
        ContactPhone = 64,
        
        /// <remarks/>
        ContactLocation = 128,
        
        /// <remarks/>
        ContactWebSite = 256,
        
        /// <remarks/>
        Annotation = 512,
        
        /// <remarks/>
        Passport = 1024,
        
        /// <remarks/>
        Comment = 2048,
        
        /// <remarks/>
        IsNotMobileVisible = 4096,
        
        /// <remarks/>
        IsMobileIMEnabled = 8192,
        
        /// <remarks/>
        IsMessengerUser = 16384,
        
        /// <remarks/>
        IsFavorite = 32768,
        
        /// <remarks/>
        IsSmtp = 65536,
        
        /// <remarks/>
        SpotWatchState = 131072,
        
        /// <remarks/>
        DisplayName = 262144,
        
        /// <remarks/>
        HasSpace = 524288,
        
        /// <remarks/>
        Categories = 1048576,
        
        /// <remarks/>
        FileAs = 2097152,
        
        /// <remarks/>
        IsPrivate = 4194304,
        
        /// <remarks/>
        Anniversary = 8388608,
        
        /// <remarks/>
        MiddleName = 16777216,
        
        /// <remarks/>
        NameTitle = 33554432,
        
        /// <remarks/>
        Suffix = 67108864,
        
        /// <remarks/>
        PrimaryLocation = 134217728,
        
        /// <remarks/>
        PrimaryPhone = 268435456,
        
        /// <remarks/>
        Gender = 536870912,
        
        /// <remarks/>
        TimeZone = 1073741824,
        
        /// <remarks/>
        ContactType = 2147483648,
        
        /// <remarks/>
        IsPassportNameHidden = 4294967296,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class AB {
        
        private System.Guid abIdField;
        
        private ABInfo abInfoField;
        
        private System.DateTime lastChangeField;
        
        private System.DateTime dynamicItemLastChangedField;
        
        private System.DateTime createDateField;
        
        private ABPropertyType propertiesChangedField;
        
        /// <remarks/>
        public System.Guid abId {
            get {
                return this.abIdField;
            }
            set {
                this.abIdField = value;
            }
        }
        
        /// <remarks/>
        public ABInfo abInfo {
            get {
                return this.abInfoField;
            }
            set {
                this.abInfoField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime lastChange {
            get {
                return this.lastChangeField;
            }
            set {
                this.lastChangeField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime DynamicItemLastChanged {
            get {
                return this.dynamicItemLastChangedField;
            }
            set {
                this.dynamicItemLastChangedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime createDate {
            get {
                return this.createDateField;
            }
            set {
                this.createDateField = value;
            }
        }
        
        /// <remarks/>
        public ABPropertyType propertiesChanged {
            get {
                return this.propertiesChangedField;
            }
            set {
                this.propertiesChangedField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class ABInfo {
        
        private string nameField;
        
        private long ownerPuidField;
        
        private long ownerCIDField;
        
        private string ownerEmailField;
        
        private bool fDefaultField;
        
        private bool joinedNamespaceField;
        
        private bool isBotField;
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public long ownerPuid {
            get {
                return this.ownerPuidField;
            }
            set {
                this.ownerPuidField = value;
            }
        }
        
        /// <remarks/>
        public long OwnerCID {
            get {
                return this.ownerCIDField;
            }
            set {
                this.ownerCIDField = value;
            }
        }
        
        /// <remarks/>
        public string ownerEmail {
            get {
                return this.ownerEmailField;
            }
            set {
                this.ownerEmailField = value;
            }
        }
        
        /// <remarks/>
        public bool fDefault {
            get {
                return this.fDefaultField;
            }
            set {
                this.fDefaultField = value;
            }
        }
        
        /// <remarks/>
        public bool joinedNamespace {
            get {
                return this.joinedNamespaceField;
            }
            set {
                this.joinedNamespaceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsBot {
            get {
                return this.isBotField;
            }
            set {
                this.isBotField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.FlagsAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ABPropertyType {
        
        /// <remarks/>
        Name = 1,
        
        /// <remarks/>
        IsBot = 2,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class GroupContactAddOptions {
        
        private bool fMergeField;
        
        private bool fGenerateMissingQuickNameField;
        
        private bool enableAllowListManagementField;
        
        private bool disableIMListManagementField;
        
        /// <remarks/>
        public bool fMerge {
            get {
                return this.fMergeField;
            }
            set {
                this.fMergeField = value;
            }
        }
        
        /// <remarks/>
        public bool fGenerateMissingQuickName {
            get {
                return this.fGenerateMissingQuickNameField;
            }
            set {
                this.fGenerateMissingQuickNameField = value;
            }
        }
        
        /// <remarks/>
        public bool EnableAllowListManagement {
            get {
                return this.enableAllowListManagementField;
            }
            set {
                this.enableAllowListManagementField = value;
            }
        }
        
        /// <remarks/>
        public bool DisableIMListManagement {
            get {
                return this.disableIMListManagementField;
            }
            set {
                this.disableIMListManagementField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class ContactDeleteOptions {
        
        private bool enableAllowListManagementField;
        
        private bool disableIMListManagementField;
        
        /// <remarks/>
        public bool EnableAllowListManagement {
            get {
                return this.enableAllowListManagementField;
            }
            set {
                this.enableAllowListManagementField = value;
            }
        }
        
        /// <remarks/>
        public bool DisableIMListManagement {
            get {
                return this.disableIMListManagementField;
            }
            set {
                this.disableIMListManagementField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class ContactAddOptions {
        
        private bool enableAllowListManagementField;
        
        private bool disableIMListManagementField;
        
        /// <remarks/>
        public bool EnableAllowListManagement {
            get {
                return this.enableAllowListManagementField;
            }
            set {
                this.enableAllowListManagementField = value;
            }
        }
        
        /// <remarks/>
        public bool DisableIMListManagement {
            get {
                return this.disableIMListManagementField;
            }
            set {
                this.disableIMListManagementField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class ContactFindResult {
        
        private Group[] groupsField;
        
        private Contact[] contactsField;
        
        private System.DateTime ablastChangeField;
        
        /// <remarks/>
        public Group[] groups {
            get {
                return this.groupsField;
            }
            set {
                this.groupsField = value;
            }
        }
        
        /// <remarks/>
        public Contact[] contacts {
            get {
                return this.contactsField;
            }
            set {
                this.contactsField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ablastChange {
            get {
                return this.ablastChangeField;
            }
            set {
                this.ablastChangeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class GroupFilter {
        
        private System.Guid[] groupIdsField;
        
        private System.Guid[] groupTypesField;
        
        /// <remarks/>
        public System.Guid[] groupIds {
            get {
                return this.groupIdsField;
            }
            set {
                this.groupIdsField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid[] groupTypes {
            get {
                return this.groupTypesField;
            }
            set {
                this.groupTypesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class ContactFilter {
        
        private System.Guid[] contactIdsField;
        
        private GroupFilter groupFilterField;
        
        private System.DateTime lastChangeField;
        
        private ContactInfoType contactInfoViewField;
        
        private bool fDeltasOnlyField;
        
        /// <remarks/>
        public System.Guid[] contactIds {
            get {
                return this.contactIdsField;
            }
            set {
                this.contactIdsField = value;
            }
        }
        
        /// <remarks/>
        public GroupFilter groupFilter {
            get {
                return this.groupFilterField;
            }
            set {
                this.groupFilterField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime lastChange {
            get {
                return this.lastChangeField;
            }
            set {
                this.lastChangeField = value;
            }
        }
        
        /// <remarks/>
        public ContactInfoType contactInfoView {
            get {
                return this.contactInfoViewField;
            }
            set {
                this.contactInfoViewField = value;
            }
        }
        
        /// <remarks/>
        public bool fDeltasOnly {
            get {
                return this.fDeltasOnlyField;
            }
            set {
                this.fDeltasOnlyField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ContactInfoType {
        
        /// <remarks/>
        ContactInfoHotmail,
        
        /// <remarks/>
        ContactInfoMessenger,
        
        /// <remarks/>
        ContactInfoAll,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public partial class ContactUpdateOptions {
        
        private bool enableAllowListManagementField;
        
        private bool disableIMListManagementField;
        
        /// <remarks/>
        public bool EnableAllowListManagement {
            get {
                return this.enableAllowListManagementField;
            }
            set {
                this.enableAllowListManagementField = value;
            }
        }
        
        /// <remarks/>
        public bool DisableIMListManagement {
            get {
                return this.disableIMListManagementField;
            }
            set {
                this.disableIMListManagementField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.msn.com/webservices/AddressBook", IsNullable=false)]
    public partial class ABTestHeader : System.Web.Services.Protocols.SoapHeader {
        
        private bool disableAuthField;
        
        private bool enableHiddenAPIField;
        
        private bool skipCIDLookupField;
        
        private System.Xml.XmlAttribute[] anyAttrField;
        
        /// <remarks/>
        public bool DisableAuth {
            get {
                return this.disableAuthField;
            }
            set {
                this.disableAuthField = value;
            }
        }
        
        /// <remarks/>
        public bool EnableHiddenAPI {
            get {
                return this.enableHiddenAPIField;
            }
            set {
                this.enableHiddenAPIField = value;
            }
        }
        
        /// <remarks/>
        public bool SkipCIDLookup {
            get {
                return this.skipCIDLookupField;
            }
            set {
                this.skipCIDLookupField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr {
            get {
                return this.anyAttrField;
            }
            set {
                this.anyAttrField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.msn.com/webservices/AddressBook", IsNullable=false)]
    public partial class ServiceHeader : System.Web.Services.Protocols.SoapHeader {
        
        private string versionField;
        
        private System.Xml.XmlAttribute[] anyAttrField;
        
        /// <remarks/>
        public string Version {
            get {
                return this.versionField;
            }
            set {
                this.versionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr {
            get {
                return this.anyAttrField;
            }
            set {
                this.anyAttrField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.msn.com/webservices/AddressBook", IsNullable=false)]
    public partial class ABApplicationHeader : System.Web.Services.Protocols.SoapHeader {
        
        private System.Guid applicationIdField;
        
        private bool isMigrationField;
        
        private string partnerScenarioField;
        
        private System.Xml.XmlAttribute[] anyAttrField;
        
        /// <remarks/>
        public System.Guid ApplicationId {
            get {
                return this.applicationIdField;
            }
            set {
                this.applicationIdField = value;
            }
        }
        
        /// <remarks/>
        public bool IsMigration {
            get {
                return this.isMigrationField;
            }
            set {
                this.isMigrationField = value;
            }
        }
        
        /// <remarks/>
        public string PartnerScenario {
            get {
                return this.partnerScenarioField;
            }
            set {
                this.partnerScenarioField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyAttributeAttribute()]
        public System.Xml.XmlAttribute[] AnyAttr {
            get {
                return this.anyAttrField;
            }
            set {
                this.anyAttrField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ABView {
        
        /// <remarks/>
        Full,
        
        /// <remarks/>
        Hotmail,
        
        /// <remarks/>
        MessengerServer,
        
        /// <remarks/>
        MessengerClient,
        
        /// <remarks/>
        Phone,
        
        /// <remarks/>
        MinimalPhone,
        
        /// <remarks/>
        MapPoint,
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        ContactControl,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.msn.com/webservices/AddressBook")]
    public enum ABDynamicItemView {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        Full,
        
        /// <remarks/>
        Gleam,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABAddCompletedEventHandler(object sender, ABAddCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Guid Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABUpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindCompletedEventHandler(object sender, ABFindCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABFindCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public AB[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AB[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactUpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactFindCompletedEventHandler(object sender, ABContactFindCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABContactFindCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABContactFindCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ContactFindResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ContactFindResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactAddCompletedEventHandler(object sender, ABContactAddCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABContactAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABContactAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Guid[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABContactDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupAddCompletedEventHandler(object sender, ABGroupAddCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABGroupAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABGroupAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Guid[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupUpdateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupFindCompletedEventHandler(object sender, ABGroupFindCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABGroupFindCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABGroupFindCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Group[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Group[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupContactAddCompletedEventHandler(object sender, ABGroupContactAddCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABGroupContactAddCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABGroupContactAddCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Guid[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABGroupContactDeleteCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABAllowListSetCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABAllowListGetCompletedEventHandler(object sender, ABAllowListGetCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABAllowListGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABAllowListGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindAllCompletedEventHandler(object sender, ABFindAllCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindAllCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABFindAllCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FindResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindByContactsCompletedEventHandler(object sender, ABFindByContactsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindByContactsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABFindByContactsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FindResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindMessengerUsersCompletedEventHandler(object sender, ABFindMessengerUsersCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindMessengerUsersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABFindMessengerUsersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FindResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindByGroupsCompletedEventHandler(object sender, ABFindByGroupsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindByGroupsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABFindByGroupsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FindResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABFindMeContactCompletedEventHandler(object sender, ABFindMeContactCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ABFindMeContactCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ABFindMeContactCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FindResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FindResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCategoryCompletedEventHandler(object sender, AddCategoryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCategoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCategoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public Category[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Category[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteCategoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateCategoryCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddDynamicItemCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateDynamicItemCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ABSetForceFullSyncDateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\cron\test\TestWatcher\TestWatcher.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Text;
using System.Threading;
using System.Web;

using xonline.common.config;
using Service = xonline.common.service;
using xonline.server.cron.plugins.cronlib;

namespace xonline.server.marketplace.test
{
    /// <summary>
    /// The Testwatcher class
    /// </summary>
    public class TestWatcher : CronJobExtender, ICronJobCommand
    {
        private uint watcherJobId = 0;

        #region ICronJob Members

        /// <summary>
        /// Overrides the base Execute method.  This method is repsonsible for handling
        /// all execution of the Test Watcher.  In its current form, it simply runs for
        /// a specified amount of time and then terminates.  There is no other logic
        /// contained within this method currently.
        /// </summary>
        /// <param name="jobId">The jobId for the Test Watcher</param>
        /// <param name="titleId">The titleId for the Test Watcher</param>
        /// <param name="args">The arguments used with the Test Watcher</param>
        public override void Execute(uint jobId, uint titleId, ref System.Collections.Hashtable args)
        {
            base.Start(jobId);
            watcherJobId = jobId;

            //The number of seconds the watcher will live for before it terminates.
            int secondsToLive = (int)args["runseconds"];

            //If a value of 0 or less is specified, the Watcher will run indefinitely.
            DateTime terminationTime = DateTime.MinValue;
            if (secondsToLive > 0)
            {
                terminationTime = DateTime.Now;
                terminationTime = terminationTime.AddSeconds(secondsToLive);
            }
            else
            {
                terminationTime = DateTime.MaxValue;
            }

            //Loop until the termination time is reached.
            Console.WriteLine("Test Watcher will run until: " + terminationTime.ToLongTimeString());
            while (DateTime.Now < terminationTime)
            {
                Thread.Sleep(1000);
            }

            base.Stop();
        }

        #endregion

        #region ICronJobCommand Members

        public Service.HResult Command(System.Collections.Hashtable args, System.Web.HttpResponse response)
        {
            if (null == args["op"] ||
                null == response)
            {
                return Service.HResult.E_INVALIDARG;
            }

            try
            {
                switch (args["op"].ToString().ToLower())
                {
                    case "getsettingvalue":
                        response.Write(
                            GetSettingValue((string)args["value"]));
                        break;

                    case "setenabled":                        
                        response.Write(
                            SetEnable((string)args["value"]));
                        break;

                    case "setintervalseconds":
                        response.Write(
                            SetCronTableValue(
                                "i_exec_interval_secs", 
                                Convert.ToInt32(args["value"])));
                        break;

                    case "settimeoutseconds":
                        response.Write(
                            SetCronTableValue(
                                "i_exec_timeout", 
                                Convert.ToInt32(args["value"])));
                        break;

                    case "setnextscheduled":
                        response.Write(
                            SetCronTableValue(
                                "dt_exec_next_scheduled",
                                (string)args["value"]));
                        break;

                    case "setnextactual":
                        response.Write(
                            SetCronTableValue(
                                "dt_exec_next_actual",
                                (string)args["value"]));
                        break;

                    case "setwatcherlifetime":
                        response.Write(
                            SetCronTableValue(
                                "txt_args",
                                (string)args["value"]));
                        break;

                    case "echo":
                        response.Write(
                            String.Format("Command Received: {0}.  Success was returned.", args["op"]));
                        break;

                    default:
                        response.Write(String.Format("Unknown command: [{0}], time:[{1}]", args["op"], DateTime.Now));
                        return Service.HResult.E_INVALIDARG;
                }
            }
            catch(Exception ex)
            {
                response.Write(ex.ToString());
                return Service.HResult.E_FAIL;
            }
                        
            return Service.HResult.S_OK;
        }

        // This is the xmgmt command handler
        public Service.HResult Command(System.Collections.Hashtable args, StringBuilder resultText, uint reqId)
        {
            return Service.HResult.XONLINE_E_UNSUPPORTED_METHOD;
        }

        /// <summary>
        /// Retrieve the value of a specified setting.
        /// </summary>
        /// <param name="settingName">The name of the setting to retrieve.</param>
        /// <returns>The value of the setting specified.</returns>
        private string GetSettingValue(string settingName)
        {
            SqlConnection connection = null;
            SqlCommand command = null;
            SqlDataReader sqlReader = null;
            string commandString = String.Format("select {0} from t_cron_jobs where i_job_id = '{1}'",
                settingName,
                watcherJobId);

            try
            {
                //Connect to the NPDB database to retrieve the needed value(s).
                IInterfaceInfo npdbInterface = Config.GetInterface(Config.GetServerListByInterface(Interface.npdb)[0], Interface.npdb);
                connection = new SqlConnection(npdbInterface.SqlConnectionString);
                connection.Open();

                command = new SqlCommand(
                    commandString,
                    connection);

                //return the first and only row retrieved from the query (there should
                //never be more than one row returned).  If more than one row is returned
                //we do not currently care about those rows other than the first.
                sqlReader = command.ExecuteReader();
                sqlReader.Read();                
                return sqlReader[0].ToString();
            }
            finally
            {
                //clean up connections and readers if necessary
                if (sqlReader != null) sqlReader.Close();
                if (command != null) command.Cancel();
                if (connection != null) connection.Close();
            }
        }

        /// <summary>
        /// Sets the value of the specified setting
        /// </summary>
        /// <param name="columnName">The name of the setting whose value will be changed.</param>
        /// <param name="value">The new value for the specified setting.</param>
        /// <returns>The SQL used to update the setting.</returns>
        private string SetCronTableValue(string columnName, string value)
        {
            SqlConnection connection = null;
            SqlCommand command = null;
            string commandString = String.Format("update t_cron_jobs set {0} = '{1}' where i_job_id = '{2}'",
                columnName,
                value,
                watcherJobId);

            try
            {
                //Connect to the NPDB database to retrieve the needed value(s).                
                IInterfaceInfo npdbInterface = Config.GetInterface(Config.GetServerListByInterface(Interface.npdb)[0], Interface.npdb);
                connection = new SqlConnection(npdbInterface.SqlConnectionString);
                connection.Open();

                command = new SqlCommand(
                    commandString,
                    connection);

                //set the new value of the setting
                command.ExecuteNonQuery();
            }
            finally
            {
                //clean up connections and readers if necessary
                if (command != null) command.Cancel();
                if (connection != null) connection.Close();
            }

            return commandString;
        }

        /// <summary>
        /// Sets the value of the specified setting
        /// </summary>
        /// <param name="columnName">The name of the setting whose value will be changed.</param>
        /// <param name="value">The new value for the specified setting.</param>
        /// <returns>The SQL used to update the setting.</returns>
        private string SetCronTableValue(string columnName, int value)
        {
            SqlConnection connection = null;
            SqlCommand command = null;
            string commandString = String.Format("update t_cron_jobs set {0} = {1} where i_job_id = '{2}'",
                        columnName,
                        value,
                        watcherJobId);

            try
            {
                //Connect to the NPDB database to retrieve the needed value(s).                
                IInterfaceInfo npdbInterface = Config.GetInterface(Config.GetServerListByInterface(Interface.npdb)[0], Interface.npdb);
                connection = new SqlConnection(npdbInterface.SqlConnectionString);
                connection.Open();

                command = new SqlCommand(
                    commandString,
                    connection);

                //set the new value of the setting
                command.ExecuteNonQuery();
            }
            finally
            {
                //clean up connections and readers if necessary
                if (command != null) command.Cancel();
                if (connection != null) connection.Close();
            }

            return commandString;
        }

        /// <summary>
        /// Sets the value of the b_enabled setting to the value specified.
        /// </summary>
        /// <param name="value">The new value for the specified setting.</param>        
        private new string SetEnable(string value)
        {
            SqlConnection connection = null;
            SqlCommand command = null;
            string commandString = "update t_cron_jobs set b_enabled = {0} where i_job_id = '{1}'";
                            
            try
            {
                //Connect to the NPDB database to retrieve the needed value(s).                
                IInterfaceInfo npdbInterface = Config.GetInterface(Config.GetServerListByInterface(Interface.npdb)[0], Interface.npdb);
                connection = new SqlConnection(npdbInterface.SqlConnectionString);
                connection.Open();

                int enableState;
                if (value.ToLower() == "false")
                {
                    enableState = 0;
                }
                else if (value.ToLower() == "true")
                {
                    enableState = 1;    
                }
                else
                {
                    return String.Empty;
                }

                commandString = String.Format(
                    commandString,
                    enableState,
                    watcherJobId);

                command = new SqlCommand(
                    commandString, 
                    connection);

                //set the new value of the setting
                command.ExecuteNonQuery();
            }
            finally
            {
                //clean up connections and readers if necessary
                if (command != null) command.Cancel();
                if (connection != null) connection.Close();
            }

            return commandString;
        }
                        
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\TestClient.cs ===
using System;
using System.Xml;

using Microsoft.XBox.Live.Server.Emulators.Framework;
using Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating;
using Microsoft.XBox.Live.Server.Emulators.MusicNet;
using Microsoft.XBox.Live.Server.Emulators.Dmp;
using System.Web.Services.Protocols;


public class TestClient 
{
    public static void Main(string[] args) 
    {
//         MSNRRSingleRatingTest();

//         MusicNetTest();
//         DMPTest();
//         SoapExceptionTest();
        
//         XmlConstraintTest();
        TestWait();
        
    }

    public static void MSNRRSingleRatingTest()
    {
        SingleRatingEmulator emu = new SingleRatingEmulator();
        ISingleRatingSoap mock = emu.StartRecording();

        Guid contentId = Guid.NewGuid();
        Guid itemId = Guid.NewGuid();
        long puid = 11;
        Guid msnGuid = Guid.NewGuid();
        int ratingValue = 5;
        int returnValue = 0;

        mock.SaveRating(contentId, itemId, puid, msnGuid, ratingValue);
        LastCall.On(mock).Returns(returnValue);

        emu.StopRecording(mock);

        SingleRating singleRating = new SingleRating();
        singleRating.Url = emu.GetUrl(mock);
        singleRating.SaveRating(contentId, itemId, puid, msnGuid, ratingValue);

        emu.Verify(mock);
    }

    public static void TestWait() 
    {
        DMPEmulator emu = new DMPEmulator();
        IDMPTransactionSoap mock = emu.StartRecording();
        
         string echoOut;
         DateTime dtOut;
        
         mock.TestConnection("EchoIn", out dtOut, out echoOut);
         LastCall.On(mock).OutArguments(null, DateTime.Now, "hello babies").Waits(TimeSpan.FromSeconds(30)).Returns("Hello");
         emu.StopRecording(mock);
         
         DMPTransaction client = new DMPTransaction();
         client.Url = emu.GetUrl(mock);
         Console.WriteLine("Start time {0}", DateTime.Now);
         string ret = client.TestConnection("EchoIn", out dtOut, out echoOut);
         Console.WriteLine("Stop time {0}", DateTime.Now);
         
         emu.Verify(mock);
         
    }
    
    public static void TestAnytime() 
    {
        DMPEmulator emu = new DMPEmulator();
        IDMPTransactionSoap mock = emu.StartRecording();
        
         string echoOut;
         DateTime dtOut;
        
         mock.TestConnection("EchoIn", out dtOut, out echoOut);
         LastCall.On(mock).ExpectedAnytime().OutArguments(null, DateTime.Now, "hello babies").Returns("Hello");
         emu.StopRecording(mock);
         
         DMPTransaction client = new DMPTransaction();
         client.Url = emu.GetUrl(mock);
         
         for (int i=0; i <5; i++) 
         {
             string ret = client.TestConnection("EchoIn", out dtOut, out echoOut);
             Console.WriteLine("echoOut is {0}, dtOut is {1}, retval is {2}", echoOut, dtOut, ret);
         }
         emu.Verify(mock);
    }
    
    public static void XmlConstraintTest() 
    {
        IConstraint c = Xml.HasNodes("ns", "urn:test", "/ns:bookstore/ns:book/ns:title");
        string errMsg;
        c.Verify(@" <bookstore xmlns=""urn:test""> <book> <title>Pride And Prejudice</title> </book> </bookstore>", out errMsg);
        Console.WriteLine(errMsg);
        
    }
    
    public static void DMPTest() 
    {
        DMPEmulator emu = new DMPEmulator();
        IDMPTransactionSoap mock = emu.StartRecording();
        
         string echoOut;
         DateTime dtOut;
        
         mock.TestConnection("EchoIn", out dtOut, out echoOut);
         LastCall.On(mock).OutArguments(null, DateTime.Now, "hello babies").Returns("Hello");
        
        Status status;
        mock.GetStatus(0,0,out status);
        LastCall.On(mock).OutArguments(null, null, Status.Active);
        emu.StopRecording(mock);
        
        DMPTransaction client = new DMPTransaction();
        client.Url = emu.GetUrl(mock);
        
         string ret = client.TestConnection("EchoIn", out dtOut, out echoOut);
        client.GetStatus(0,0, out status);
        
        emu.Verify(mock);
        Console.WriteLine("echoOut is {0}, dtOut is {1}, retval is {2}", echoOut, dtOut, ret);
    }

    public static void SoapExceptionTest() 
    {
        DMPEmulator emu = new DMPEmulator();
        IDMPTransactionSoap mock = emu.StartRecording();
         string echoOut;
         DateTime dtOut;
         
         //         Build the detail element of the SOAP fault.
         XmlDocument doc = new System.Xml.XmlDocument();
         doc.LoadXml("<detail><DMPErrorInfo xmlns=\"http://schemas.microsoft.com/DMP/2004/09/API\">" +
                     "<Property>DMP</Property>" +
                     "<Error>DMP_E_SYSTEM_INTERNAL_ERROR</Error>" +
                     "<DetailMessage>Some detail message</DetailMessage>" +
                     "<CanRetry>false</CanRetry>" +
                     "<ErrorBlob>Encrypted blah blah blah</ErrorBlob>" +
                     "</DMPErrorInfo></detail>");
         XmlNode node = doc.FirstChild;
         //         Console.WriteLine(node.OuterXml);
         
         SoapException e = new SoapException("bla", SoapException.ServerFaultCode, "uri:blabla", node);
         mock.TestConnection("EchoIn", out dtOut, out echoOut);
         
         LastCall.On(mock).Throws(e);
         emu.StopRecording(mock);
         
         DMPTransaction client = new DMPTransaction();
         client.Url = emu.GetUrl(mock);
         
         try 
         {
             string ret = client.TestConnection("EchoIn", out dtOut, out echoOut);
         }
         catch (SoapException ex) 
         {
             //  Console.WriteLine(ex);
             Console.WriteLine(ex.Detail.OuterXml);
             //  throw;
         }
         
    }
    
    public static void MusicNetTest () 
    {
        MusicNetEmulator emu = new MusicNetEmulator();
        IMusicNet mock = emu.StartRecording();
        mock.CreateAccount("bla", "bla", "bla", "bla", new CustomProperty[0]);
        LastCall.On(mock).IgnoresArgument(0); //.ClosesConnection();
        
        //        LastCall.On(mock).Throws(new SoapException("Blalblabla", SoapException.ServerFaultCode));
        
        CustomProperty[] props = new CustomProperty[1];
        props[0] = new CustomProperty();
        props[0].name = "Name";
        props[0].value = "Value";
        
        PurchaseItem[] items = new PurchaseItem[1];
        items[0] = new PurchaseItem();
        items[0].mnetId = "id";
        items[0].type = PurchaseItemType.Track;
        items[0].suggestedRetailPrice = new ItemPrice();
        items[0].suggestedRetailPrice.amount = "0.99";
        items[0].suggestedRetailPrice.currency = Currency.USD;
        items[0].soldForPrice = new ItemPrice();
        items[0].soldForPrice.amount = "0.99";
        items[0].soldForPrice.currency = Currency.USD;

        PurchaseItem[] items2 = new PurchaseItem[1];
        items2[0] = new PurchaseItem();
        items2[0].mnetId = "id2";
        items2[0].type = PurchaseItemType.Track;
        items2[0].suggestedRetailPrice = new ItemPrice();
        items2[0].suggestedRetailPrice.amount = "0.99";
        items2[0].suggestedRetailPrice.currency = Currency.USD;
        items2[0].soldForPrice = new ItemPrice();
        items2[0].soldForPrice.amount = "0.99";
        items2[0].soldForPrice.currency = Currency.USD;
        
//         CollectionEqualConstraint bla = new CollectionEqualConstraint(items);
//         Console.WriteLine(bla.Verify(items2));

        Purchase expectedPurchase = new Purchase();
        expectedPurchase.itemsWithErrors = new PurchaseItemResponse[0];
        mock.PurchaseAssets("blablablab", "blablb", "customer", "order", items, "en-US", true, props);
        LastCall.On(mock).Returns(expectedPurchase);
        
        emu.StopRecording(mock);
        EcommerceB2BService client = new EcommerceB2BService();
        client.Url = emu.GetUrl(mock);
        
        client.CreateAccount("Should be ignored", "bla", "bla", "bla", new CustomProperty[0]);
        Purchase returnPurchases = client.PurchaseAssets("blablablab", "blablb", "customer", "order", items, "en-US", true, props);
        
        emu.Verify(mock);
        
        //       Console.WriteLine(r);
    }
    
    private void InterceptionWorksTest() 
    {
        MusicNetServerStub stub = new MusicNetServerStub();
        try 
        {
            stub.CreateAccount("bla", "bla", "bla","bla", null);
        }
        catch(NotImplementedException) 
        {
            Console.WriteLine("It Works!");
        }
        catch(ApplicationException)
        {
            Console.WriteLine("It does NOT work !!!");
        }
    }

//     private Recording CreateRecording() 
//     {
//         IEcommerceB2BSoapBinding mock = Recorder.StartRecording<IEcommerceB2BSoapBinding>();
//         mock.CreateAccount("bla", "bla", "bla", "bla", null);
//         LastCall.On(mock).Throws(new SoapException("Blalblabla", SoapException.ServerFaultCode));
//         Recording r = Recorder.StopRecording(mock);
//         return r;
        
//     }
    
    
//     private void  RecordingTest()  
//     {
//         Recording r = CreateRecording();
//         Console.WriteLine(r.ToBase64String());
        
//         Controller c = new Controller();
//         Guid g = c.AddCallSequence(r.ToBase64String());
//         Console.WriteLine(g);
//     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\bdk\BdkSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.Bdk {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="bdkSoap", Namespace="http://tempuri.org/")]
    public interface IBdkSoap {
        
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ActivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrSubscriptionAction, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount);

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CalculateTax", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        void CalculateTax(string version, string callerInfoXml, string accountId, string taxCalculationInfoXml, string orderDetailXml, out string returnOrderDetailXml);
       
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelRenewal", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CancelRenewal(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, string subscriptionId);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CancelSubscriptionEx(int delegatePUIDHigh, int delegatePUIDLow, int requesterPUIDHigh, int requesterPUIDLow, string trackingGUID, bool computeOnly, string subscriptionId, string cancelDate, string commentInfoXML, bool closeBalance, out string amountChargedXML, out string subscriptionStatusInfoXML, out int removedServiceInstanceCount, out string removedServiceInstanceSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelTransaction", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CancelTransaction(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string transactionId);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ChargePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ChargePaymentInstrument(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string paymentInstrumentId, string chargeInfoXml, out string paymentInstrumentResultsXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckCDAvailability", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CheckCDAvailability(string accountIDBlob, string subscriptionRefIDBlob, out string partnerName);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConsumeToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ConsumeToken(int delegateIdHigh, int delegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string trackingGuid, string tokenID, out string consumedTokenDetailsXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ConvertSubscriptionEx2(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    string bstrRedirectInputInfoXML, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet, 
                    out string pbstrRedirectOutputInfoXML);
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("BdkSoapHeaderValue")]
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeactivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void DeactivateToken(int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId, string timeStamp, int committedStatus);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeliverToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void DeliverToken(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrFilterInfoXML, string bstrSessionKey, out string pbstrErrorXML, out string pbstrEncryptedTokenSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.FixExistingAddress", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void FixExistingAddress(long acctId, short subRefID, short addId, string mappingCombination, int maxReturnRange, double confidenceScoreThreshold, bool readOnlyMode, out bool result, out double confidenceScore, out int tryNumber);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPuid", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAccountIdFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, string roleSetXml, bool fullData, int max, out string errorXml, out int moreRows, out int accountInfoCount, out string accountInfoSetXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAccountIdFromToken(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, int lTokenType, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentMethodTypeProperties", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetPaymentMethodTypeProperties(out string paymentTypeInfoSetXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitHistoryForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetPermitHistoryForObjectId(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string objectId, out string errorXml, out int permitCount, out string permitSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProductClasses", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetProductClasses(out string productClassSetXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProvisioningInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetProvisioningInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, out string ProvisioningInfoXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralEvents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetReferralEvents(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, out string ReferralEventsInfoXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementTokenFromPuid", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetReplacementTokenFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, out int tokenInfoReturnedCount, out string replacementTokenSetXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClassRestrictionInfoForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetTokenClassRestrictionInfoForPUID(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, out string tokenClassRestrictionInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClasses", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetTokenClasses(string bstrProductClassGuidFilter, int lReturnCountMax, out int plAdditionalTokenClassCount, out int plTokenClassReturnedCount, out string pbstrTokenClassSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTransactions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetTransactions(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string accountId, string offeringGuid, string transactionId, string filteringCriteriaXml, out string transactionSetXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetUnconditionalReplacementToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void GetUnconditionalReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, bool tiePinRedemptionToPuid, int replacementReasonCode, string tokenClassGuid, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IssueTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void IssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MarkTokenDistributionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void MarkTokenDistributionStatus(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrTokenId, int lTokenType, string bstrStatusName, string bstrStatusValue, string bstrPartNumber);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MapAddress", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void MapAddress(int delegateIdHigh, int delegateIdLow, string addressInfoXML, int maxReturnRange, double confidenceScoreThreshold, out string MapAddressInfoSet);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MigrateOffer", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void MigrateOffer(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrOfferingGUID, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetSingleUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void OffsetSingleUsageEvent(int delegateIdHigh, int delegateIdLow, string trackingGuid, string lineItemId, int units, string CommentInfoXML, string reservedXML, int returnAsUsageActivity, out string newLineItemXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void OrderCDforAccount(string accountIDBlob, string subscriptionRefIDBlob, int surveyResultCode, out long orderId);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OrderCDforAnonymous", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void OrderCDforAnonymous(string anonymousInfoXml, string category, string requestorInfo, out long orderId);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProcessChargeback", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ProcessChargeback(int delegateIdHigh, int delegateIdLow, string lineItemId, int fileId, string fileNamespace, bool recordOnly, string mode, string chargebackInstanceXml, string commentInfoXml, out string chargebackResponseInfoXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void PurchaseItem(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, out string receiptXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void PurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void PurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void PurchaseOfferingEx2(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    string bstrRedirectInputInfoXML, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML, 
                    out string pbstrRedirectOutputInfoXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReconcileTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ReconcileTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string token, int tokenType, string externalReferenceId, string timeStamp, int action, out int reconStatus);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RegisterPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void RegisterPaymentInstrument(int delegateIdHigh, int delegateIdLow, int requestorIdHigh, int requestorIdLow, string trackingGuid, string paymentInstrumentInfoXml, string accountInfoXml, string responseOptionsXml, out string paymentInstrumentId, out string requiredPaperWorkUrl, out string paymentInstrumentsResultsXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePMNBasedServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void RemovePMNBasedServices(int lRequesterIdHigh, int lRequesterIdLow);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportSingleUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ReportSingleUsageEvent(string trackingGuid, bool computeOnly, string usageEventXml, out string lineItemId, out string usageInfoXml, out string amountChargedXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportTransactionEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ReportTransactionEvent(long sequenceNumber, string transactionId, string merchantId, string vendorInternalTransactionId, string amountXml, string transactionEventXml, string paymentDetailsXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccountsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SearchAccountsEx(int delegatePuidHigh, int delegatePuidLow, string accountSearchCriteriaXml, string bookmark, int returnedAccountCountMax, out string bookmarkNew, out int returnedAccountCount, out string accountInfoSetXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchBillingInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SearchBillingInfo(int delegateIdHigh, int delegateIdLow, string billingInfoSearchCriteriaXML, out string billingInfoSetXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML);
        

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SubmitOrder", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        void SubmitOrder(string version, Guid trackingGuid, string callerInfoXml, string objectId, string paymentInstrumentInfoXml, string orderDetailXml, out string orderReceiptXml);

        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetOrder", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        void OffsetOrder(string version, Guid trackingGuid, string callerInfoXml, string objectId, string correlationInfoXml, string orderDetailXml, string commentInfoXml, out string orderReceiptXml);

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void TestConnection(string bstrInputString, out string pbstrOutputString);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnIssueTokenTrusted", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void UnIssueTokenTrusted(string partnerName, int delegateIdHigh, int delegateIdLow, string trackingGuid, string token, int tokenType, string externalReferenceId);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        void ValidateToken(int delegateIdHigh, int delegateIdLow, string tokenClassGuid, string pin, string sequenceNumber, int signature, string partNumber);
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.SoapTypeAttribute(Namespace="http://tempuri.org/")]
    public partial class BdkSoapHeader : SoapHeader {
        
        /// <remarks/>
        public int PartitionId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\EcommerceB2BService.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet {

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml.Serialization;

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="EcommerceB2BSoapBinding", Namespace="http://ws.ecomm.musicnet.com")]
public partial class EcommerceB2BService : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    private System.Threading.SendOrPostCallback CreateAccountOperationCompleted;
    
    private System.Threading.SendOrPostCallback SuspendAccountOperationCompleted;
    
    private System.Threading.SendOrPostCallback ResumeAccountOperationCompleted;
    
    private System.Threading.SendOrPostCallback CloseAccountOperationCompleted;
    
    private System.Threading.SendOrPostCallback AddTrialSubscriptionOfferOperationCompleted;
    
    private System.Threading.SendOrPostCallback EndTrialSubscriptionOfferOperationCompleted;
    
    private System.Threading.SendOrPostCallback AddSubscriptionOfferOperationCompleted;
    
    private System.Threading.SendOrPostCallback CancelSubscriptionOfferOperationCompleted;
    
    private System.Threading.SendOrPostCallback UpgradeSubscriptionOfferOperationCompleted;
    
    private System.Threading.SendOrPostCallback DowngradeSubscriptionOfferOperationCompleted;
    
    private System.Threading.SendOrPostCallback PurchaseAssetsOperationCompleted;
    
    /// <remarks/>
    public EcommerceB2BService() {
        this.Url = "http://tkdevbl01:8080/jboss-net/services/EcommerceB2B";
    }
    
    /// <remarks/>
    public event CreateAccountCompletedEventHandler CreateAccountCompleted;
    
    /// <remarks/>
    public event SuspendAccountCompletedEventHandler SuspendAccountCompleted;
    
    /// <remarks/>
    public event ResumeAccountCompletedEventHandler ResumeAccountCompleted;
    
    /// <remarks/>
    public event CloseAccountCompletedEventHandler CloseAccountCompleted;
    
    /// <remarks/>
    public event AddTrialSubscriptionOfferCompletedEventHandler AddTrialSubscriptionOfferCompleted;
    
    /// <remarks/>
    public event EndTrialSubscriptionOfferCompletedEventHandler EndTrialSubscriptionOfferCompleted;
    
    /// <remarks/>
    public event AddSubscriptionOfferCompletedEventHandler AddSubscriptionOfferCompleted;
    
    /// <remarks/>
    public event CancelSubscriptionOfferCompletedEventHandler CancelSubscriptionOfferCompleted;
    
    /// <remarks/>
    public event UpgradeSubscriptionOfferCompletedEventHandler UpgradeSubscriptionOfferCompleted;
    
    /// <remarks/>
    public event DowngradeSubscriptionOfferCompletedEventHandler DowngradeSubscriptionOfferCompleted;
    
    /// <remarks/>
    public event PurchaseAssetsCompletedEventHandler PurchaseAssetsCompleted;
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void CreateAccount(string authToken, string retailerId, string customerId, string orderId, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("CreateAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCreateAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CreateAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCreateAccount(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void CreateAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters) {
        this.CreateAccountAsync(authToken, retailerId, customerId, orderId, extraParameters, null);
    }
    
    /// <remarks/>
    public void CreateAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, object userState) {
        if ((this.CreateAccountOperationCompleted == null)) {
            this.CreateAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateAccountOperationCompleted);
        }
        this.InvokeAsync("CreateAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, this.CreateAccountOperationCompleted, userState);
    }
    
    private void OnCreateAccountOperationCompleted(object arg) {
        if ((this.CreateAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.CreateAccountCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void SuspendAccount(string authToken, string retailerId, string customerId, string orderId, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("SuspendAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSuspendAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SuspendAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndSuspendAccount(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void SuspendAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters) {
        this.SuspendAccountAsync(authToken, retailerId, customerId, orderId, extraParameters, null);
    }
    
    /// <remarks/>
    public void SuspendAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, object userState) {
        if ((this.SuspendAccountOperationCompleted == null)) {
            this.SuspendAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSuspendAccountOperationCompleted);
        }
        this.InvokeAsync("SuspendAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, this.SuspendAccountOperationCompleted, userState);
    }
    
    private void OnSuspendAccountOperationCompleted(object arg) {
        if ((this.SuspendAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.SuspendAccountCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void ResumeAccount(string authToken, string retailerId, string customerId, string orderId, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("ResumeAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginResumeAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("ResumeAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndResumeAccount(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void ResumeAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters) {
        this.ResumeAccountAsync(authToken, retailerId, customerId, orderId, extraParameters, null);
    }
    
    /// <remarks/>
    public void ResumeAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, object userState) {
        if ((this.ResumeAccountOperationCompleted == null)) {
            this.ResumeAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnResumeAccountOperationCompleted);
        }
        this.InvokeAsync("ResumeAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, this.ResumeAccountOperationCompleted, userState);
    }
    
    private void OnResumeAccountOperationCompleted(object arg) {
        if ((this.ResumeAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.ResumeAccountCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void CloseAccount(string authToken, string retailerId, string customerId, string orderId, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("CloseAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCloseAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CloseAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCloseAccount(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void CloseAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters) {
        this.CloseAccountAsync(authToken, retailerId, customerId, orderId, extraParameters, null);
    }
    
    /// <remarks/>
    public void CloseAccountAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, object userState) {
        if ((this.CloseAccountOperationCompleted == null)) {
            this.CloseAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCloseAccountOperationCompleted);
        }
        this.InvokeAsync("CloseAccount", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, this.CloseAccountOperationCompleted, userState);
    }
    
    private void OnCloseAccountOperationCompleted(object arg) {
        if ((this.CloseAccountCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.CloseAccountCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void AddTrialSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, string offerSKUToRollover, int noOfTrialDays, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("AddTrialSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    offerSKUToRollover,
                    noOfTrialDays,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddTrialSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, string offerSKUToRollover, int noOfTrialDays, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddTrialSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    offerSKUToRollover,
                    noOfTrialDays,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddTrialSubscriptionOffer(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void AddTrialSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, string offerSKUToRollover, int noOfTrialDays, CustomProperty[] extraParameters) {
        this.AddTrialSubscriptionOfferAsync(authToken, retailerId, customerId, orderId, offerSKU, offerSKUToRollover, noOfTrialDays, extraParameters, null);
    }
    
    /// <remarks/>
    public void AddTrialSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, string offerSKUToRollover, int noOfTrialDays, CustomProperty[] extraParameters, object userState) {
        if ((this.AddTrialSubscriptionOfferOperationCompleted == null)) {
            this.AddTrialSubscriptionOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddTrialSubscriptionOfferOperationCompleted);
        }
        this.InvokeAsync("AddTrialSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    offerSKUToRollover,
                    noOfTrialDays,
                    extraParameters}, this.AddTrialSubscriptionOfferOperationCompleted, userState);
    }
    
    private void OnAddTrialSubscriptionOfferOperationCompleted(object arg) {
        if ((this.AddTrialSubscriptionOfferCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.AddTrialSubscriptionOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void EndTrialSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("EndTrialSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEndTrialSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EndTrialSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndEndTrialSubscriptionOffer(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void EndTrialSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters) {
        this.EndTrialSubscriptionOfferAsync(authToken, retailerId, customerId, orderId, extraParameters, null);
    }
    
    /// <remarks/>
    public void EndTrialSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters, object userState) {
        if ((this.EndTrialSubscriptionOfferOperationCompleted == null)) {
            this.EndTrialSubscriptionOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEndTrialSubscriptionOfferOperationCompleted);
        }
        this.InvokeAsync("EndTrialSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    extraParameters}, this.EndTrialSubscriptionOfferOperationCompleted, userState);
    }
    
    private void OnEndTrialSubscriptionOfferOperationCompleted(object arg) {
        if ((this.EndTrialSubscriptionOfferCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.EndTrialSubscriptionOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void AddSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("AddSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginAddSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("AddSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndAddSubscriptionOffer(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void AddSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, CustomProperty[] extraParameters) {
        this.AddSubscriptionOfferAsync(authToken, retailerId, customerId, orderId, offerSKU, extraParameters, null);
    }
    
    /// <remarks/>
    public void AddSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, CustomProperty[] extraParameters, object userState) {
        if ((this.AddSubscriptionOfferOperationCompleted == null)) {
            this.AddSubscriptionOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddSubscriptionOfferOperationCompleted);
        }
        this.InvokeAsync("AddSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    extraParameters}, this.AddSubscriptionOfferOperationCompleted, userState);
    }
    
    private void OnAddSubscriptionOfferOperationCompleted(object arg) {
        if ((this.AddSubscriptionOfferCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.AddSubscriptionOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void CancelSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, bool immediate, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("CancelSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    immediate,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginCancelSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, bool immediate, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("CancelSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    immediate,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndCancelSubscriptionOffer(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void CancelSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, bool immediate, CustomProperty[] extraParameters) {
        this.CancelSubscriptionOfferAsync(authToken, retailerId, customerId, orderId, immediate, extraParameters, null);
    }
    
    /// <remarks/>
    public void CancelSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, bool immediate, CustomProperty[] extraParameters, object userState) {
        if ((this.CancelSubscriptionOfferOperationCompleted == null)) {
            this.CancelSubscriptionOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelSubscriptionOfferOperationCompleted);
        }
        this.InvokeAsync("CancelSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    immediate,
                    extraParameters}, this.CancelSubscriptionOfferOperationCompleted, userState);
    }
    
    private void OnCancelSubscriptionOfferOperationCompleted(object arg) {
        if ((this.CancelSubscriptionOfferCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.CancelSubscriptionOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void UpgradeSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("UpgradeSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    immediate,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpgradeSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpgradeSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    immediate,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpgradeSubscriptionOffer(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void UpgradeSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters) {
        this.UpgradeSubscriptionOfferAsync(authToken, retailerId, customerId, orderId, offerSKU, immediate, extraParameters, null);
    }
    
    /// <remarks/>
    public void UpgradeSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters, object userState) {
        if ((this.UpgradeSubscriptionOfferOperationCompleted == null)) {
            this.UpgradeSubscriptionOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpgradeSubscriptionOfferOperationCompleted);
        }
        this.InvokeAsync("UpgradeSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    immediate,
                    extraParameters}, this.UpgradeSubscriptionOfferOperationCompleted, userState);
    }
    
    private void OnUpgradeSubscriptionOfferOperationCompleted(object arg) {
        if ((this.UpgradeSubscriptionOfferCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.UpgradeSubscriptionOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public void DowngradeSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        this.Invoke("DowngradeSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    immediate,
                    extraParameters});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDowngradeSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DowngradeSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    immediate,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDowngradeSubscriptionOffer(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    public void DowngradeSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters) {
        this.DowngradeSubscriptionOfferAsync(authToken, retailerId, customerId, orderId, offerSKU, immediate, extraParameters, null);
    }
    
    /// <remarks/>
    public void DowngradeSubscriptionOfferAsync(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters, object userState) {
        if ((this.DowngradeSubscriptionOfferOperationCompleted == null)) {
            this.DowngradeSubscriptionOfferOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDowngradeSubscriptionOfferOperationCompleted);
        }
        this.InvokeAsync("DowngradeSubscriptionOffer", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    offerSKU,
                    immediate,
                    extraParameters}, this.DowngradeSubscriptionOfferOperationCompleted, userState);
    }
    
    private void OnDowngradeSubscriptionOfferOperationCompleted(object arg) {
        if ((this.DowngradeSubscriptionOfferCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.DowngradeSubscriptionOfferCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.ecomm.musicnet.com", ResponseNamespace="http://ws.ecomm.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    [return: System.Xml.Serialization.XmlElementAttribute("PurchaseAssetsReturn")]
    public Purchase PurchaseAssets(string authToken, string retailerId, string customerId, string orderId, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] PurchaseItem[] items, string isoCountryCode, bool allowPartialPurchases, [System.Xml.Serialization.XmlArrayItemAttribute("item", IsNullable=false)] CustomProperty[] extraParameters) {
        object[] results = this.Invoke("PurchaseAssets", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    items,
                    isoCountryCode,
                    allowPartialPurchases,
                    extraParameters});
        return ((Purchase)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginPurchaseAssets(string authToken, string retailerId, string customerId, string orderId, PurchaseItem[] items, string isoCountryCode, bool allowPartialPurchases, CustomProperty[] extraParameters, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("PurchaseAssets", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    items,
                    isoCountryCode,
                    allowPartialPurchases,
                    extraParameters}, callback, asyncState);
    }
    
    /// <remarks/>
    public Purchase EndPurchaseAssets(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((Purchase)(results[0]));
    }
    
    /// <remarks/>
    public void PurchaseAssetsAsync(string authToken, string retailerId, string customerId, string orderId, PurchaseItem[] items, string isoCountryCode, bool allowPartialPurchases, CustomProperty[] extraParameters) {
        this.PurchaseAssetsAsync(authToken, retailerId, customerId, orderId, items, isoCountryCode, allowPartialPurchases, extraParameters, null);
    }
    
    /// <remarks/>
    public void PurchaseAssetsAsync(string authToken, string retailerId, string customerId, string orderId, PurchaseItem[] items, string isoCountryCode, bool allowPartialPurchases, CustomProperty[] extraParameters, object userState) {
        if ((this.PurchaseAssetsOperationCompleted == null)) {
            this.PurchaseAssetsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseAssetsOperationCompleted);
        }
        this.InvokeAsync("PurchaseAssets", new object[] {
                    authToken,
                    retailerId,
                    customerId,
                    orderId,
                    items,
                    isoCountryCode,
                    allowPartialPurchases,
                    extraParameters}, this.PurchaseAssetsOperationCompleted, userState);
    }
    
    private void OnPurchaseAssetsOperationCompleted(object arg) {
        if ((this.PurchaseAssetsCompleted != null)) {
            System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
            this.PurchaseAssetsCompleted(this, new PurchaseAssetsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
        }
    }
    
    /// <remarks/>
    public new void CancelAsync(object userState) {
        base.CancelAsync(userState);
    }
}


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void CreateAccountCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void SuspendAccountCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void ResumeAccountCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void CloseAccountCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void AddTrialSubscriptionOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void EndTrialSubscriptionOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void AddSubscriptionOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void CancelSubscriptionOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void UpgradeSubscriptionOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void DowngradeSubscriptionOfferCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
public delegate void PurchaseAssetsCompletedEventHandler(object sender, PurchaseAssetsCompletedEventArgs e);

/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
public partial class PurchaseAssetsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
    
    private object[] results;
    
    internal PurchaseAssetsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState) {
        this.results = results;
    }
    
    /// <remarks/>
    public Purchase Result {
        get {
            this.RaiseExceptionIfNecessary();
            return ((Purchase)(this.results[0]));
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\MSNRR.Aggregator.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.Aggregator {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AggregatorSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Aggregator : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaUnauthRatingAveragesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAveragesWithReviewCountOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetDeltaRatingAveragesWithReviewCountOperationCompleted;
        
        /// <remarks/>
        public Aggregator() {
            this.Url = "http://rr.msn-int.com/rrwebservice/Aggregator.asmx";
        }
        
        /// <remarks/>
        public event GetRatingAveragesCompletedEventHandler GetRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetDeltaRatingAveragesCompletedEventHandler GetDeltaRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingAveragesCompletedEventHandler GetUnauthRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetDeltaUnauthRatingAveragesCompletedEventHandler GetDeltaUnauthRatingAveragesCompleted;
        
        /// <remarks/>
        public event GetRatingAveragesWithReviewCountCompletedEventHandler GetRatingAveragesWithReviewCountCompleted;
        
        /// <remarks/>
        public event GetDeltaRatingAveragesWithReviewCountCompletedEventHandler GetDeltaRatingAveragesWithReviewCountCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetRatingAveragesAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetRatingAveragesOperationCompleted == null)) {
                this.GetRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetRatingAveragesOperationCompleted(object arg) {
            if ((this.GetRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAveragesCompleted(this, new GetRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetDeltaRatingAveragesAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetDeltaRatingAveragesOperationCompleted == null)) {
                this.GetDeltaRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetDeltaRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetDeltaRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetDeltaRatingAveragesOperationCompleted(object arg) {
            if ((this.GetDeltaRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaRatingAveragesCompleted(this, new GetDeltaRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken) {
            this.GetUnauthRatingAveragesAsync(contentTypeID, fromTime, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, object userState) {
            if ((this.GetUnauthRatingAveragesOperationCompleted == null)) {
                this.GetUnauthRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, this.GetUnauthRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingAveragesOperationCompleted(object arg) {
            if ((this.GetUnauthRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingAveragesCompleted(this, new GetUnauthRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaUnauthRatingAverages(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken) {
            this.GetDeltaUnauthRatingAveragesAsync(contentTypeID, fromTime, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaUnauthRatingAveragesAsync(System.Guid contentTypeID, System.DateTime fromTime, string transactionToken, object userState) {
            if ((this.GetDeltaUnauthRatingAveragesOperationCompleted == null)) {
                this.GetDeltaUnauthRatingAveragesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaUnauthRatingAveragesOperationCompleted);
            }
            this.InvokeAsync("GetDeltaUnauthRatingAverages", new object[] {
                        contentTypeID,
                        fromTime,
                        transactionToken}, this.GetDeltaUnauthRatingAveragesOperationCompleted, userState);
        }
        
        private void OnGetDeltaUnauthRatingAveragesOperationCompleted(object arg) {
            if ((this.GetDeltaUnauthRatingAveragesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaUnauthRatingAveragesCompleted(this, new GetDeltaUnauthRatingAveragesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAveragesWithReviewCo" +
            "unt", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAveragesWithReviewCount(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetRatingAveragesWithReviewCountAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetRatingAveragesWithReviewCountOperationCompleted == null)) {
                this.GetRatingAveragesWithReviewCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAveragesWithReviewCountOperationCompleted);
            }
            this.InvokeAsync("GetRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetRatingAveragesWithReviewCountOperationCompleted, userState);
        }
        
        private void OnGetRatingAveragesWithReviewCountOperationCompleted(object arg) {
            if ((this.GetRatingAveragesWithReviewCountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAveragesWithReviewCountCompleted(this, new GetRatingAveragesWithReviewCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAveragesWithRev" +
            "iewCount", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.Invoke("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken});
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetDeltaRatingAveragesWithReviewCount(System.IAsyncResult asyncResult, out string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results) {
            object[] results1 = this.EndInvoke(asyncResult);
            transactionToken = ((string)(results1[1]));
            transactionStartTime = ((System.DateTime)(results1[2]));
            results = ((System.Xml.XmlNode)(results1[3]));
            return ((int)(results1[0]));
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken) {
            this.GetDeltaRatingAveragesWithReviewCountAsync(contentTypeID, fromTime, returnRatingAttributes, transactionToken, null);
        }
        
        /// <remarks/>
        public void GetDeltaRatingAveragesWithReviewCountAsync(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, string transactionToken, object userState) {
            if ((this.GetDeltaRatingAveragesWithReviewCountOperationCompleted == null)) {
                this.GetDeltaRatingAveragesWithReviewCountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetDeltaRatingAveragesWithReviewCountOperationCompleted);
            }
            this.InvokeAsync("GetDeltaRatingAveragesWithReviewCount", new object[] {
                        contentTypeID,
                        fromTime,
                        returnRatingAttributes,
                        transactionToken}, this.GetDeltaRatingAveragesWithReviewCountOperationCompleted, userState);
        }
        
        private void OnGetDeltaRatingAveragesWithReviewCountOperationCompleted(object arg) {
            if ((this.GetDeltaRatingAveragesWithReviewCountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetDeltaRatingAveragesWithReviewCountCompleted(this, new GetDeltaRatingAveragesWithReviewCountCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAveragesCompletedEventHandler(object sender, GetRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaRatingAveragesCompletedEventHandler(object sender, GetDeltaRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingAveragesCompletedEventHandler(object sender, GetUnauthRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetUnauthRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaUnauthRatingAveragesCompletedEventHandler(object sender, GetDeltaUnauthRatingAveragesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaUnauthRatingAveragesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaUnauthRatingAveragesCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAveragesWithReviewCountCompletedEventHandler(object sender, GetRatingAveragesWithReviewCountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAveragesWithReviewCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetRatingAveragesWithReviewCountCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDeltaRatingAveragesWithReviewCountCompletedEventHandler(object sender, GetDeltaRatingAveragesWithReviewCountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDeltaRatingAveragesWithReviewCountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results1;
        
        internal GetDeltaRatingAveragesWithReviewCountCompletedEventArgs(object[] results1, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results1 = results1;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results1[0]));
            }
        }
        
        /// <remarks/>
        public string transactionToken {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results1[1]));
            }
        }
        
        /// <remarks/>
        public System.DateTime transactionStartTime {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results1[2]));
            }
        }
        
        /// <remarks/>
        public System.Xml.XmlNode results {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results1[3]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\controller\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\controller\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\MSNRR.MultiRating.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.MultiRating {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MultiRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public partial class MultiRating : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AdvanceStateOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameSuggestionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserWithAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMultipleRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReportViolationOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewHelpfulnessOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ValidateReviewOperationCompleted;
        
        /// <remarks/>
        public MultiRating() {
            this.Url = "http://rr.msn-int.com/rrwebservice/multirating.asmx";
        }
        
        /// <remarks/>
        public event AdvanceStateCompletedEventHandler AdvanceStateCompleted;
        
        /// <remarks/>
        public event GetNicknameCompletedEventHandler GetNicknameCompleted;
        
        /// <remarks/>
        public event GetNicknameSuggestionsCompletedEventHandler GetNicknameSuggestionsCompleted;
        
        /// <remarks/>
        public event GetRatingAverageCompletedEventHandler GetRatingAverageCompleted;
        
        /// <remarks/>
        public event GetRatingAverageRollupCompletedEventHandler GetRatingAverageRollupCompleted;
        
        /// <remarks/>
        public event GetRatingByUserCompletedEventHandler GetRatingByUserCompleted;
        
        /// <remarks/>
        public event GetRatingByUserWithAverageCompletedEventHandler GetRatingByUserWithAverageCompleted;
        
        /// <remarks/>
        public event GetMultipleRatingsByUserCompletedEventHandler GetMultipleRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetRatingsByUserCompletedEventHandler GetRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewByUserCompletedEventHandler GetReviewByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsCompletedEventHandler GetReviewsCompleted;
        
        /// <remarks/>
        public event GetReviewsByUserCompletedEventHandler GetReviewsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsRollupCompletedEventHandler GetReviewsRollupCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingsCompletedEventHandler GetUnauthRatingsCompleted;
        
        /// <remarks/>
        public event SaveNicknameCompletedEventHandler SaveNicknameCompleted;
        
        /// <remarks/>
        public event SaveRatingCompletedEventHandler SaveRatingCompleted;
        
        /// <remarks/>
        public event BulkSaveRatingCompletedEventHandler BulkSaveRatingCompleted;
        
        /// <remarks/>
        public event SaveReportViolationCompletedEventHandler SaveReportViolationCompleted;
        
        /// <remarks/>
        public event SaveReviewCompletedEventHandler SaveReviewCompleted;
        
        /// <remarks/>
        public event BulkSaveReviewCompletedEventHandler BulkSaveReviewCompleted;
        
        /// <remarks/>
        public event SaveReviewHelpfulnessCompletedEventHandler SaveReviewHelpfulnessCompleted;
        
        /// <remarks/>
        public event SaveUnauthRatingsCompletedEventHandler SaveUnauthRatingsCompleted;
        
        /// <remarks/>
        public event ValidateReviewCompletedEventHandler ValidateReviewCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            object[] results = this.Invoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndAdvanceState(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            this.AdvanceStateAsync(contentTypeID, itemID, puid, msnGuid, keys, values, null);
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, object userState) {
            if ((this.AdvanceStateOperationCompleted == null)) {
                this.AdvanceStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdvanceStateOperationCompleted);
            }
            this.InvokeAsync("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, this.AdvanceStateOperationCompleted, userState);
        }
        
        private void OnAdvanceStateOperationCompleted(object arg) {
            if ((this.AdvanceStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdvanceStateCompleted(this, new AdvanceStateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNickname(long puid, System.Guid msnGuid, out string nickname) {
            object[] results = this.Invoke("GetNickname", new object[] {
                        puid,
                        msnGuid});
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNickname(long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNickname", new object[] {
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNickname(System.IAsyncResult asyncResult, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid) {
            this.GetNicknameAsync(puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid, object userState) {
            if ((this.GetNicknameOperationCompleted == null)) {
                this.GetNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameOperationCompleted);
            }
            this.InvokeAsync("GetNickname", new object[] {
                        puid,
                        msnGuid}, this.GetNicknameOperationCompleted, userState);
        }
        
        private void OnGetNicknameOperationCompleted(object arg) {
            if ((this.GetNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameCompleted(this, new GetNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNicknameSuggestions(string seed, out string[] suggestionList) {
            object[] results = this.Invoke("GetNicknameSuggestions", new object[] {
                        seed});
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNicknameSuggestions(string seed, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNicknameSuggestions", new object[] {
                        seed}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNicknameSuggestions(System.IAsyncResult asyncResult, out string[] suggestionList) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed) {
            this.GetNicknameSuggestionsAsync(seed, null);
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed, object userState) {
            if ((this.GetNicknameSuggestionsOperationCompleted == null)) {
                this.GetNicknameSuggestionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameSuggestionsOperationCompleted);
            }
            this.InvokeAsync("GetNicknameSuggestions", new object[] {
                        seed}, this.GetNicknameSuggestionsOperationCompleted, userState);
        }
        
        private void OnGetNicknameSuggestionsOperationCompleted(object arg) {
            if ((this.GetNicknameSuggestionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameSuggestionsCompleted(this, new GetNicknameSuggestionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverage(System.Guid contentTypeID, object itemID, out Rating rating) {
            object[] results = this.Invoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverage(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverage(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageOperationCompleted == null)) {
                this.GetRatingAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageOperationCompleted(object arg) {
            if ((this.GetRatingAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageCompleted(this, new GetRatingAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out Rating rating) {
            object[] results = this.Invoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverageRollup(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverageRollup(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageRollupAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageRollupOperationCompleted == null)) {
                this.GetRatingAverageRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageRollupOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageRollupOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageRollupOperationCompleted(object arg) {
            if ((this.GetRatingAverageRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageRollupCompleted(this, new GetRatingAverageRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating) {
            object[] results = this.Invoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUser(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserOperationCompleted == null)) {
                this.GetRatingByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserOperationCompleted(object arg) {
            if ((this.GetRatingByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserCompleted(this, new GetRatingByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating) {
            object[] results = this.Invoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUserWithAverage(System.IAsyncResult asyncResult, out Rating rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((Rating)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserWithAverageAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserWithAverageOperationCompleted == null)) {
                this.GetRatingByUserWithAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserWithAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserWithAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserWithAverageOperationCompleted(object arg) {
            if ((this.GetRatingByUserWithAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserWithAverageCompleted(this, new GetRatingByUserWithAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out Rating[] ratings) {
            object[] results = this.Invoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid});
            ratings = ((Rating[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetMultipleRatingsByUser(System.IAsyncResult asyncResult, out Rating[] ratings) {
            object[] results = this.EndInvoke(asyncResult);
            ratings = ((Rating[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid) {
            this.GetMultipleRatingsByUserAsync(contentTypeID, itemIDs, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetMultipleRatingsByUserOperationCompleted == null)) {
                this.GetMultipleRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMultipleRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, this.GetMultipleRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetMultipleRatingsByUserOperationCompleted(object arg) {
            if ((this.GetMultipleRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMultipleRatingsByUserCompleted(this, new GetMultipleRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname) {
            object[] results = this.Invoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingsByUser(System.IAsyncResult asyncResult, out System.Guid userID, out Rating[] ratings, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetRatingsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetRatingsByUserOperationCompleted == null)) {
                this.GetRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingsByUserOperationCompleted(object arg) {
            if ((this.GetRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingsByUserCompleted(this, new GetRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review) {
            object[] results = this.Invoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewByUser(System.IAsyncResult asyncResult, out Review review) {
            object[] results = this.EndInvoke(asyncResult);
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetReviewByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetReviewByUserOperationCompleted == null)) {
                this.GetReviewByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetReviewByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewByUserOperationCompleted(object arg) {
            if ((this.GetReviewByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewByUserCompleted(this, new GetReviewByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviews(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviews(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsOperationCompleted == null)) {
                this.GetReviewsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsOperationCompleted);
            }
            this.InvokeAsync("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsOperationCompleted, userState);
        }
        
        private void OnGetReviewsOperationCompleted(object arg) {
            if ((this.GetReviewsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsCompleted(this, new GetReviewsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsByUser(System.IAsyncResult asyncResult, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetReviewsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetReviewsByUserOperationCompleted == null)) {
                this.GetReviewsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetReviewsByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewsByUserOperationCompleted(object arg) {
            if ((this.GetReviewsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsByUserCompleted(this, new GetReviewsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsRollup(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsRollup(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsRollupAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsRollupOperationCompleted == null)) {
                this.GetReviewsRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsRollupOperationCompleted);
            }
            this.InvokeAsync("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsRollupOperationCompleted, userState);
        }
        
        private void OnGetReviewsRollupOperationCompleted(object arg) {
            if ((this.GetReviewsRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsRollupCompleted(this, new GetReviewsRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.Invoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse});
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatings(System.IAsyncResult asyncResult, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.EndInvoke(asyncResult);
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse) {
            this.GetUnauthRatingsAsync(contentTypeID, itemID, ratingAttributeID, daysOfRatingsToUse, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, object userState) {
            if ((this.GetUnauthRatingsOperationCompleted == null)) {
                this.GetUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        daysOfRatingsToUse}, this.GetUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingsOperationCompleted(object arg) {
            if ((this.GetUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingsCompleted(this, new GetUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname});
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveNickname(long puid, System.Guid msnGuid, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveNickname(System.IAsyncResult asyncResult, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname) {
            this.SaveNicknameAsync(puid, msnGuid, nickname, null);
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname, object userState) {
            if ((this.SaveNicknameOperationCompleted == null)) {
                this.SaveNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveNicknameOperationCompleted);
            }
            this.InvokeAsync("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, this.SaveNicknameOperationCompleted, userState);
        }
        
        private void OnSaveNicknameOperationCompleted(object arg) {
            if ((this.SaveNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveNicknameCompleted(this, new SaveNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveRating(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues) {
            this.SaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingIDs, ratingValues, null);
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, object userState) {
            if ((this.SaveRatingOperationCompleted == null)) {
                this.SaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveRatingOperationCompleted);
            }
            this.InvokeAsync("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues}, this.SaveRatingOperationCompleted, userState);
        }
        
        private void OnSaveRatingOperationCompleted(object arg) {
            if ((this.SaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveRatingCompleted(this, new SaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, out ValidationError[] errors) {
            object[] results = this.Invoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveRating(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate) {
            this.BulkSaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingIDs, ratingValues, updateDate, null);
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, object userState) {
            if ((this.BulkSaveRatingOperationCompleted == null)) {
                this.BulkSaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveRatingOperationCompleted);
            }
            this.InvokeAsync("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingIDs,
                        ratingValues,
                        updateDate}, this.BulkSaveRatingOperationCompleted, userState);
        }
        
        private void OnBulkSaveRatingOperationCompleted(object arg) {
            if ((this.BulkSaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveRatingCompleted(this, new BulkSaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReportViolation(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments) {
            this.SaveReportViolationAsync(itemID, reviewID, name, emailAddress, comments, null);
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, object userState) {
            if ((this.SaveReportViolationOperationCompleted == null)) {
                this.SaveReportViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReportViolationOperationCompleted);
            }
            this.InvokeAsync("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, this.SaveReportViolationOperationCompleted, userState);
        }
        
        private void OnSaveReportViolationOperationCompleted(object arg) {
            if ((this.SaveReportViolationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReportViolationCompleted(this, new SaveReportViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty) {
            this.SaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, null);
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, object userState) {
            if ((this.SaveReviewOperationCompleted == null)) {
                this.SaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewOperationCompleted);
            }
            this.InvokeAsync("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, this.SaveReviewOperationCompleted, userState);
        }
        
        private void OnSaveReviewOperationCompleted(object arg) {
            if ((this.SaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewCompleted(this, new SaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname) {
            object[] results = this.Invoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveReview(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname) {
            this.BulkSaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, updateDate, nickname, null);
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname, object userState) {
            if ((this.BulkSaveReviewOperationCompleted == null)) {
                this.BulkSaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveReviewOperationCompleted);
            }
            this.InvokeAsync("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty,
                        updateDate,
                        nickname}, this.BulkSaveReviewOperationCompleted, userState);
        }
        
        private void OnBulkSaveReviewOperationCompleted(object arg) {
            if ((this.BulkSaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveReviewCompleted(this, new BulkSaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReviewHelpfulness(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score) {
            this.SaveReviewHelpfulnessAsync(itemID, puid, msnGuid, reviewID, score, null);
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, object userState) {
            if ((this.SaveReviewHelpfulnessOperationCompleted == null)) {
                this.SaveReviewHelpfulnessOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewHelpfulnessOperationCompleted);
            }
            this.InvokeAsync("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, this.SaveReviewHelpfulnessOperationCompleted, userState);
        }
        
        private void OnSaveReviewHelpfulnessOperationCompleted(object arg) {
            if ((this.SaveReviewHelpfulnessCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewHelpfulnessCompleted(this, new SaveReviewHelpfulnessCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas) {
            object[] results = this.Invoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveUnauthRatings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas) {
            this.SaveUnauthRatingsAsync(contentTypeID, itemID, ratingAttributeID, ratingScores, ratingCountDeltas, null);
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas, object userState) {
            if ((this.SaveUnauthRatingsOperationCompleted == null)) {
                this.SaveUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingAttributeID,
                        ratingScores,
                        ratingCountDeltas}, this.SaveUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnSaveUnauthRatingsOperationCompleted(object arg) {
            if ((this.SaveUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveUnauthRatingsCompleted(this, new SaveUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndValidateReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty) {
            this.ValidateReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingIDs, ratingValues, customProperty, null);
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, object userState) {
            if ((this.ValidateReviewOperationCompleted == null)) {
                this.ValidateReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateReviewOperationCompleted);
            }
            this.InvokeAsync("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingIDs,
                        ratingValues,
                        customProperty}, this.ValidateReviewOperationCompleted, userState);
        }
        
        private void OnValidateReviewOperationCompleted(object arg) {
            if ((this.ValidateReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateReviewCompleted(this, new ValidateReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdvanceStateCompletedEventHandler(object sender, AdvanceStateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdvanceStateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AdvanceStateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameCompletedEventHandler(object sender, GetNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameSuggestionsCompletedEventHandler(object sender, GetNicknameSuggestionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameSuggestionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameSuggestionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageCompletedEventHandler(object sender, GetRatingAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageRollupCompletedEventHandler(object sender, GetRatingAverageRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserCompletedEventHandler(object sender, GetRatingByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserWithAverageCompletedEventHandler(object sender, GetRatingByUserWithAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserWithAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserWithAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMultipleRatingsByUserCompletedEventHandler(object sender, GetMultipleRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMultipleRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMultipleRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingsByUserCompletedEventHandler(object sender, GetRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.Guid userID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewByUserCompletedEventHandler(object sender, GetReviewByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review review {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsCompletedEventHandler(object sender, GetReviewsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsByUserCompletedEventHandler(object sender, GetReviewsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsRollupCompletedEventHandler(object sender, GetReviewsRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingsCompletedEventHandler(object sender, GetUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratingScores {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public long[] ratingCounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveNicknameCompletedEventHandler(object sender, SaveNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveRatingCompletedEventHandler(object sender, SaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveRatingCompletedEventHandler(object sender, BulkSaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReportViolationCompletedEventHandler(object sender, SaveReportViolationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReportViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReportViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewCompletedEventHandler(object sender, SaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveReviewCompletedEventHandler(object sender, BulkSaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewHelpfulnessCompletedEventHandler(object sender, SaveReviewHelpfulnessCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewHelpfulnessCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewHelpfulnessCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveUnauthRatingsCompletedEventHandler(object sender, SaveUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateReviewCompletedEventHandler(object sender, ValidateReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ValidateReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ValidateReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\MSNRR.SingleRating.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="SingleRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public partial class SingleRating : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AdvanceStateOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetNicknameSuggestionsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingAverageRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingByUserWithAverageOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetMultipleRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetRatingsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsByUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetReviewsRollupOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveNicknameOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveRatingOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReportViolationOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback BulkSaveReviewOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveReviewHelpfulnessOperationCompleted;
        
        private System.Threading.SendOrPostCallback SaveUnauthRatingsOperationCompleted;
        
        private System.Threading.SendOrPostCallback ValidateReviewOperationCompleted;
        
        /// <remarks/>
        public SingleRating() {
            this.Url = "http://rr.msn-int.com/rrwebservice/singlerating.asmx";
        }
        
        /// <remarks/>
        public event AdvanceStateCompletedEventHandler AdvanceStateCompleted;
        
        /// <remarks/>
        public event GetNicknameCompletedEventHandler GetNicknameCompleted;
        
        /// <remarks/>
        public event GetNicknameSuggestionsCompletedEventHandler GetNicknameSuggestionsCompleted;
        
        /// <remarks/>
        public event GetRatingAverageCompletedEventHandler GetRatingAverageCompleted;
        
        /// <remarks/>
        public event GetRatingAverageRollupCompletedEventHandler GetRatingAverageRollupCompleted;
        
        /// <remarks/>
        public event GetRatingByUserCompletedEventHandler GetRatingByUserCompleted;
        
        /// <remarks/>
        public event GetRatingByUserWithAverageCompletedEventHandler GetRatingByUserWithAverageCompleted;
        
        /// <remarks/>
        public event GetMultipleRatingsByUserCompletedEventHandler GetMultipleRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetRatingsByUserCompletedEventHandler GetRatingsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewByUserCompletedEventHandler GetReviewByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsCompletedEventHandler GetReviewsCompleted;
        
        /// <remarks/>
        public event GetReviewsByUserCompletedEventHandler GetReviewsByUserCompleted;
        
        /// <remarks/>
        public event GetReviewsRollupCompletedEventHandler GetReviewsRollupCompleted;
        
        /// <remarks/>
        public event GetUnauthRatingsCompletedEventHandler GetUnauthRatingsCompleted;
        
        /// <remarks/>
        public event SaveNicknameCompletedEventHandler SaveNicknameCompleted;
        
        /// <remarks/>
        public event SaveRatingCompletedEventHandler SaveRatingCompleted;
        
        /// <remarks/>
        public event BulkSaveRatingCompletedEventHandler BulkSaveRatingCompleted;
        
        /// <remarks/>
        public event SaveReportViolationCompletedEventHandler SaveReportViolationCompleted;
        
        /// <remarks/>
        public event SaveReviewCompletedEventHandler SaveReviewCompleted;
        
        /// <remarks/>
        public event BulkSaveReviewCompletedEventHandler BulkSaveReviewCompleted;
        
        /// <remarks/>
        public event SaveReviewHelpfulnessCompletedEventHandler SaveReviewHelpfulnessCompleted;
        
        /// <remarks/>
        public event SaveUnauthRatingsCompletedEventHandler SaveUnauthRatingsCompleted;
        
        /// <remarks/>
        public event ValidateReviewCompletedEventHandler ValidateReviewCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            object[] results = this.Invoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values});
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Xml.XmlNode EndAdvanceState(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Xml.XmlNode)(results[0]));
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values) {
            this.AdvanceStateAsync(contentTypeID, itemID, puid, msnGuid, keys, values, null);
        }
        
        /// <remarks/>
        public void AdvanceStateAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values, object userState) {
            if ((this.AdvanceStateOperationCompleted == null)) {
                this.AdvanceStateOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAdvanceStateOperationCompleted);
            }
            this.InvokeAsync("AdvanceState", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        keys,
                        values}, this.AdvanceStateOperationCompleted, userState);
        }
        
        private void OnAdvanceStateOperationCompleted(object arg) {
            if ((this.AdvanceStateCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AdvanceStateCompleted(this, new AdvanceStateCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNickname(long puid, System.Guid msnGuid, out string nickname) {
            object[] results = this.Invoke("GetNickname", new object[] {
                        puid,
                        msnGuid});
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNickname(long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNickname", new object[] {
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNickname(System.IAsyncResult asyncResult, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            nickname = ((string)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid) {
            this.GetNicknameAsync(puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetNicknameAsync(long puid, System.Guid msnGuid, object userState) {
            if ((this.GetNicknameOperationCompleted == null)) {
                this.GetNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameOperationCompleted);
            }
            this.InvokeAsync("GetNickname", new object[] {
                        puid,
                        msnGuid}, this.GetNicknameOperationCompleted, userState);
        }
        
        private void OnGetNicknameOperationCompleted(object arg) {
            if ((this.GetNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameCompleted(this, new GetNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetNicknameSuggestions(string seed, out string[] suggestionList) {
            object[] results = this.Invoke("GetNicknameSuggestions", new object[] {
                        seed});
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetNicknameSuggestions(string seed, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetNicknameSuggestions", new object[] {
                        seed}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetNicknameSuggestions(System.IAsyncResult asyncResult, out string[] suggestionList) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed) {
            this.GetNicknameSuggestionsAsync(seed, null);
        }
        
        /// <remarks/>
        public void GetNicknameSuggestionsAsync(string seed, object userState) {
            if ((this.GetNicknameSuggestionsOperationCompleted == null)) {
                this.GetNicknameSuggestionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetNicknameSuggestionsOperationCompleted);
            }
            this.InvokeAsync("GetNicknameSuggestions", new object[] {
                        seed}, this.GetNicknameSuggestionsOperationCompleted, userState);
        }
        
        private void OnGetNicknameSuggestionsOperationCompleted(object arg) {
            if ((this.GetNicknameSuggestionsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetNicknameSuggestionsCompleted(this, new GetNicknameSuggestionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverage(System.Guid contentTypeID, object itemID, out float rating, out int count) {
            object[] results = this.Invoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverage(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverage(System.IAsyncResult asyncResult, out float rating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageOperationCompleted == null)) {
                this.GetRatingAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverage", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageOperationCompleted(object arg) {
            if ((this.GetRatingAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageCompleted(this, new GetRatingAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out float rating, out int count) {
            object[] results = this.Invoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID});
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingAverageRollup(System.Guid contentTypeID, object itemID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingAverageRollup(System.IAsyncResult asyncResult, out float rating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((float)(results[1]));
            count = ((int)(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID) {
            this.GetRatingAverageRollupAsync(contentTypeID, itemID, null);
        }
        
        /// <remarks/>
        public void GetRatingAverageRollupAsync(System.Guid contentTypeID, object itemID, object userState) {
            if ((this.GetRatingAverageRollupOperationCompleted == null)) {
                this.GetRatingAverageRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingAverageRollupOperationCompleted);
            }
            this.InvokeAsync("GetRatingAverageRollup", new object[] {
                        contentTypeID,
                        itemID}, this.GetRatingAverageRollupOperationCompleted, userState);
        }
        
        private void OnGetRatingAverageRollupOperationCompleted(object arg) {
            if ((this.GetRatingAverageRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingAverageRollupCompleted(this, new GetRatingAverageRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int rating) {
            object[] results = this.Invoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            rating = ((int)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUser(System.IAsyncResult asyncResult, out int rating) {
            object[] results = this.EndInvoke(asyncResult);
            rating = ((int)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserOperationCompleted == null)) {
                this.GetRatingByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserOperationCompleted(object arg) {
            if ((this.GetRatingByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserCompleted(this, new GetRatingByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int userRating, out float averageRating, out int count) {
            object[] results = this.Invoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            userRating = ((int)(results[1]));
            averageRating = ((float)(results[2]));
            count = ((int)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingByUserWithAverage(System.IAsyncResult asyncResult, out int userRating, out float averageRating, out int count) {
            object[] results = this.EndInvoke(asyncResult);
            userRating = ((int)(results[1]));
            averageRating = ((float)(results[2]));
            count = ((int)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetRatingByUserWithAverageAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingByUserWithAverageAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetRatingByUserWithAverageOperationCompleted == null)) {
                this.GetRatingByUserWithAverageOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingByUserWithAverageOperationCompleted);
            }
            this.InvokeAsync("GetRatingByUserWithAverage", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetRatingByUserWithAverageOperationCompleted, userState);
        }
        
        private void OnGetRatingByUserWithAverageOperationCompleted(object arg) {
            if ((this.GetRatingByUserWithAverageCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingByUserWithAverageCompleted(this, new GetRatingByUserWithAverageCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out int[] ratings) {
            object[] results = this.Invoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid});
            ratings = ((int[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetMultipleRatingsByUser(System.IAsyncResult asyncResult, out int[] ratings) {
            object[] results = this.EndInvoke(asyncResult);
            ratings = ((int[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid) {
            this.GetMultipleRatingsByUserAsync(contentTypeID, itemIDs, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetMultipleRatingsByUserAsync(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetMultipleRatingsByUserOperationCompleted == null)) {
                this.GetMultipleRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetMultipleRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetMultipleRatingsByUser", new object[] {
                        contentTypeID,
                        itemIDs,
                        puid,
                        msnGuid}, this.GetMultipleRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetMultipleRatingsByUserOperationCompleted(object arg) {
            if ((this.GetMultipleRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetMultipleRatingsByUserCompleted(this, new GetMultipleRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname) {
            object[] results = this.Invoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetRatingsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetRatingsByUser(System.IAsyncResult asyncResult, out System.Guid userID, out Rating[] ratings, out string nickname) {
            object[] results = this.EndInvoke(asyncResult);
            userID = ((System.Guid)(results[1]));
            ratings = ((Rating[])(results[2]));
            nickname = ((string)(results[3]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetRatingsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetRatingsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetRatingsByUserOperationCompleted == null)) {
                this.GetRatingsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetRatingsByUserOperationCompleted);
            }
            this.InvokeAsync("GetRatingsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetRatingsByUserOperationCompleted, userState);
        }
        
        private void OnGetRatingsByUserOperationCompleted(object arg) {
            if ((this.GetRatingsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetRatingsByUserCompleted(this, new GetRatingsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review) {
            object[] results = this.Invoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid});
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewByUser(System.IAsyncResult asyncResult, out Review review) {
            object[] results = this.EndInvoke(asyncResult);
            review = ((Review)(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid) {
            this.GetReviewByUserAsync(contentTypeID, itemID, puid, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewByUserAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, object userState) {
            if ((this.GetReviewByUserOperationCompleted == null)) {
                this.GetReviewByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewByUser", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid}, this.GetReviewByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewByUserOperationCompleted(object arg) {
            if ((this.GetReviewByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewByUserCompleted(this, new GetReviewByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviews(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviews(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsOperationCompleted == null)) {
                this.GetReviewsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsOperationCompleted);
            }
            this.InvokeAsync("GetReviews", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsOperationCompleted, userState);
        }
        
        private void OnGetReviewsOperationCompleted(object arg) {
            if ((this.GetReviewsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsCompleted(this, new GetReviewsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid});
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsByUser(System.IAsyncResult asyncResult, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            Reviews = ((Review[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid) {
            this.GetReviewsByUserAsync(contentTypeID, puid, userID, msnGuid, null);
        }
        
        /// <remarks/>
        public void GetReviewsByUserAsync(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, object userState) {
            if ((this.GetReviewsByUserOperationCompleted == null)) {
                this.GetReviewsByUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsByUserOperationCompleted);
            }
            this.InvokeAsync("GetReviewsByUser", new object[] {
                        contentTypeID,
                        puid,
                        userID,
                        msnGuid}, this.GetReviewsByUserOperationCompleted, userState);
        }
        
        private void OnGetReviewsByUserOperationCompleted(object arg) {
            if ((this.GetReviewsByUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsByUserCompleted(this, new GetReviewsByUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)] out Review[] Reviews) {
            object[] results = this.Invoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder});
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReviewsRollup(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetReviewsRollup(System.IAsyncResult asyncResult, out int pageSize, out int pageNum, out string sortBy, out string sortOrder, out int totalCount, out Review[] Reviews) {
            object[] results = this.EndInvoke(asyncResult);
            pageSize = ((int)(results[1]));
            pageNum = ((int)(results[2]));
            sortBy = ((string)(results[3]));
            sortOrder = ((string)(results[4]));
            totalCount = ((int)(results[5]));
            Reviews = ((Review[])(results[6]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder) {
            this.GetReviewsRollupAsync(contentTypeID, itemID, pageSize, pageNum, sortBy, sortOrder, null);
        }
        
        /// <remarks/>
        public void GetReviewsRollupAsync(System.Guid contentTypeID, object itemID, int pageSize, int pageNum, string sortBy, string sortOrder, object userState) {
            if ((this.GetReviewsRollupOperationCompleted == null)) {
                this.GetReviewsRollupOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReviewsRollupOperationCompleted);
            }
            this.InvokeAsync("GetReviewsRollup", new object[] {
                        contentTypeID,
                        itemID,
                        pageSize,
                        pageNum,
                        sortBy,
                        sortOrder}, this.GetReviewsRollupOperationCompleted, userState);
        }
        
        private void OnGetReviewsRollupOperationCompleted(object arg) {
            if ((this.GetReviewsRollupCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReviewsRollupCompleted(this, new GetReviewsRollupCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.Invoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse});
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetUnauthRatings(System.IAsyncResult asyncResult, out int[] ratingScores, out long[] ratingCounts) {
            object[] results = this.EndInvoke(asyncResult);
            ratingScores = ((int[])(results[1]));
            ratingCounts = ((long[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse) {
            this.GetUnauthRatingsAsync(contentTypeID, itemID, daysOfRatingsToUse, null);
        }
        
        /// <remarks/>
        public void GetUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, object userState) {
            if ((this.GetUnauthRatingsOperationCompleted == null)) {
                this.GetUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("GetUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        daysOfRatingsToUse}, this.GetUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnGetUnauthRatingsOperationCompleted(object arg) {
            if ((this.GetUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUnauthRatingsCompleted(this, new GetUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname});
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveNickname(long puid, System.Guid msnGuid, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveNickname(System.IAsyncResult asyncResult, out string[] suggestionList, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            suggestionList = ((string[])(results[1]));
            errors = ((ValidationError[])(results[2]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname) {
            this.SaveNicknameAsync(puid, msnGuid, nickname, null);
        }
        
        /// <remarks/>
        public void SaveNicknameAsync(long puid, System.Guid msnGuid, string nickname, object userState) {
            if ((this.SaveNicknameOperationCompleted == null)) {
                this.SaveNicknameOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveNicknameOperationCompleted);
            }
            this.InvokeAsync("SaveNickname", new object[] {
                        puid,
                        msnGuid,
                        nickname}, this.SaveNicknameOperationCompleted, userState);
        }
        
        private void OnSaveNicknameOperationCompleted(object arg) {
            if ((this.SaveNicknameCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveNicknameCompleted(this, new SaveNicknameCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue) {
            object[] results = this.Invoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveRating(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue) {
            this.SaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingValue, null);
        }
        
        /// <remarks/>
        public void SaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, object userState) {
            if ((this.SaveRatingOperationCompleted == null)) {
                this.SaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveRatingOperationCompleted);
            }
            this.InvokeAsync("SaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue}, this.SaveRatingOperationCompleted, userState);
        }
        
        private void OnSaveRatingOperationCompleted(object arg) {
            if ((this.SaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveRatingCompleted(this, new SaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate) {
            object[] results = this.Invoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveRating(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate) {
            this.BulkSaveRatingAsync(contentTypeID, itemID, puid, msnGuid, ratingValue, updateDate, null);
        }
        
        /// <remarks/>
        public void BulkSaveRatingAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate, object userState) {
            if ((this.BulkSaveRatingOperationCompleted == null)) {
                this.BulkSaveRatingOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveRatingOperationCompleted);
            }
            this.InvokeAsync("BulkSaveRating", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        ratingValue,
                        updateDate}, this.BulkSaveRatingOperationCompleted, userState);
        }
        
        private void OnBulkSaveRatingOperationCompleted(object arg) {
            if ((this.BulkSaveRatingCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveRatingCompleted(this, new BulkSaveRatingCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReportViolation(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments) {
            this.SaveReportViolationAsync(itemID, reviewID, name, emailAddress, comments, null);
        }
        
        /// <remarks/>
        public void SaveReportViolationAsync(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, object userState) {
            if ((this.SaveReportViolationOperationCompleted == null)) {
                this.SaveReportViolationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReportViolationOperationCompleted);
            }
            this.InvokeAsync("SaveReportViolation", new object[] {
                        itemID,
                        reviewID,
                        name,
                        emailAddress,
                        comments}, this.SaveReportViolationOperationCompleted, userState);
        }
        
        private void OnSaveReportViolationOperationCompleted(object arg) {
            if ((this.SaveReportViolationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReportViolationCompleted(this, new SaveReportViolationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty) {
            this.SaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingValue, customProperty, null);
        }
        
        /// <remarks/>
        public void SaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, object userState) {
            if ((this.SaveReviewOperationCompleted == null)) {
                this.SaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewOperationCompleted);
            }
            this.InvokeAsync("SaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, this.SaveReviewOperationCompleted, userState);
        }
        
        private void OnSaveReviewOperationCompleted(object arg) {
            if ((this.SaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewCompleted(this, new SaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname) {
            object[] results = this.Invoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndBulkSaveReview(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname) {
            this.BulkSaveReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIDs, reviewFieldValues, ratingValue, customProperty, updateDate, nickname, null);
        }
        
        /// <remarks/>
        public void BulkSaveReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname, object userState) {
            if ((this.BulkSaveReviewOperationCompleted == null)) {
                this.BulkSaveReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBulkSaveReviewOperationCompleted);
            }
            this.InvokeAsync("BulkSaveReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIDs,
                        reviewFieldValues,
                        ratingValue,
                        customProperty,
                        updateDate,
                        nickname}, this.BulkSaveReviewOperationCompleted, userState);
        }
        
        private void OnBulkSaveReviewOperationCompleted(object arg) {
            if ((this.BulkSaveReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BulkSaveReviewCompleted(this, new BulkSaveReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors) {
            object[] results = this.Invoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveReviewHelpfulness(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score) {
            this.SaveReviewHelpfulnessAsync(itemID, puid, msnGuid, reviewID, score, null);
        }
        
        /// <remarks/>
        public void SaveReviewHelpfulnessAsync(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, object userState) {
            if ((this.SaveReviewHelpfulnessOperationCompleted == null)) {
                this.SaveReviewHelpfulnessOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveReviewHelpfulnessOperationCompleted);
            }
            this.InvokeAsync("SaveReviewHelpfulness", new object[] {
                        itemID,
                        puid,
                        msnGuid,
                        reviewID,
                        score}, this.SaveReviewHelpfulnessOperationCompleted, userState);
        }
        
        private void OnSaveReviewHelpfulnessOperationCompleted(object arg) {
            if ((this.SaveReviewHelpfulnessCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveReviewHelpfulnessCompleted(this, new SaveReviewHelpfulnessCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int SaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas) {
            object[] results = this.Invoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndSaveUnauthRatings(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas) {
            this.SaveUnauthRatingsAsync(contentTypeID, itemID, ratingScores, ratingCountDeltas, null);
        }
        
        /// <remarks/>
        public void SaveUnauthRatingsAsync(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas, object userState) {
            if ((this.SaveUnauthRatingsOperationCompleted == null)) {
                this.SaveUnauthRatingsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSaveUnauthRatingsOperationCompleted);
            }
            this.InvokeAsync("SaveUnauthRatings", new object[] {
                        contentTypeID,
                        itemID,
                        ratingScores,
                        ratingCountDeltas}, this.SaveUnauthRatingsOperationCompleted, userState);
        }
        
        private void OnSaveUnauthRatingsOperationCompleted(object arg) {
            if ((this.SaveUnauthRatingsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SaveUnauthRatingsCompleted(this, new SaveUnauthRatingsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors) {
            object[] results = this.Invoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty});
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndValidateReview(System.IAsyncResult asyncResult, out ValidationError[] errors) {
            object[] results = this.EndInvoke(asyncResult);
            errors = ((ValidationError[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty) {
            this.ValidateReviewAsync(contentTypeID, itemID, puid, msnGuid, title, reviewFieldIds, reviewFieldValues, ratingValue, customProperty, null);
        }
        
        /// <remarks/>
        public void ValidateReviewAsync(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, object userState) {
            if ((this.ValidateReviewOperationCompleted == null)) {
                this.ValidateReviewOperationCompleted = new System.Threading.SendOrPostCallback(this.OnValidateReviewOperationCompleted);
            }
            this.InvokeAsync("ValidateReview", new object[] {
                        contentTypeID,
                        itemID,
                        puid,
                        msnGuid,
                        title,
                        reviewFieldIds,
                        reviewFieldValues,
                        ratingValue,
                        customProperty}, this.ValidateReviewOperationCompleted, userState);
        }
        
        private void OnValidateReviewOperationCompleted(object arg) {
            if ((this.ValidateReviewCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ValidateReviewCompleted(this, new ValidateReviewCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdvanceStateCompletedEventHandler(object sender, AdvanceStateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdvanceStateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AdvanceStateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Xml.XmlNode Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Xml.XmlNode)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameCompletedEventHandler(object sender, GetNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNicknameSuggestionsCompletedEventHandler(object sender, GetNicknameSuggestionsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNicknameSuggestionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNicknameSuggestionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageCompletedEventHandler(object sender, GetRatingAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public float rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingAverageRollupCompletedEventHandler(object sender, GetRatingAverageRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingAverageRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingAverageRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public float rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserCompletedEventHandler(object sender, GetRatingByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int rating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingByUserWithAverageCompletedEventHandler(object sender, GetRatingByUserWithAverageCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingByUserWithAverageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingByUserWithAverageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int userRating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public float averageRating {
            get {
                this.RaiseExceptionIfNecessary();
                return ((float)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public int count {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetMultipleRatingsByUserCompletedEventHandler(object sender, GetMultipleRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetMultipleRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetMultipleRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetRatingsByUserCompletedEventHandler(object sender, GetRatingsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetRatingsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetRatingsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.Guid userID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Rating[] ratings {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Rating[])(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string nickname {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewByUserCompletedEventHandler(object sender, GetReviewByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review review {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsCompletedEventHandler(object sender, GetReviewsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsByUserCompletedEventHandler(object sender, GetReviewsByUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsByUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsByUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReviewsRollupCompletedEventHandler(object sender, GetReviewsRollupCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReviewsRollupCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReviewsRollupCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int pageSize {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public int pageNum {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public string sortBy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string sortOrder {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
        
        /// <remarks/>
        public int totalCount {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[5]));
            }
        }
        
        /// <remarks/>
        public Review[] Reviews {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Review[])(this.results[6]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnauthRatingsCompletedEventHandler(object sender, GetUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int[] ratingScores {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public long[] ratingCounts {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveNicknameCompletedEventHandler(object sender, SaveNicknameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveNicknameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveNicknameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string[] suggestionList {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[1]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveRatingCompletedEventHandler(object sender, SaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveRatingCompletedEventHandler(object sender, BulkSaveRatingCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveRatingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveRatingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReportViolationCompletedEventHandler(object sender, SaveReportViolationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReportViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReportViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewCompletedEventHandler(object sender, SaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BulkSaveReviewCompletedEventHandler(object sender, BulkSaveReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BulkSaveReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BulkSaveReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveReviewHelpfulnessCompletedEventHandler(object sender, SaveReviewHelpfulnessCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveReviewHelpfulnessCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveReviewHelpfulnessCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SaveUnauthRatingsCompletedEventHandler(object sender, SaveUnauthRatingsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SaveUnauthRatingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SaveUnauthRatingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateReviewCompletedEventHandler(object sender, ValidateReviewCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ValidateReviewCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ValidateReviewCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public ValidationError[] errors {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ValidationError[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\MSNRR.NickNameListener.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.NickNameListener {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="RRListenerSoap", Namespace="http://www.msn.com/WebServices/SubscriberService/")]
    public partial class RRListener : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback OnNotificationReceiveOperationCompleted;
        
        /// <remarks/>
        public RRListener() {
            this.Url = "http://rr.msn-int.com/rrwebservice/rrnnlistener.asmx";
        }
        
        /// <remarks/>
        public event OnNotificationReceiveCompletedEventHandler OnNotificationReceiveCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/WebServices/SubscriberService/OnNotificationReceive", RequestNamespace="http://www.msn.com/WebServices/SubscriberService/", ResponseNamespace="http://www.msn.com/WebServices/SubscriberService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int OnNotificationReceive(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime) {
            object[] results = this.Invoke("OnNotificationReceive", new object[] {
                        publisherID,
                        eventTypeID,
                        resourceID,
                        extendedAttributes,
                        eventDateTime});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOnNotificationReceive(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OnNotificationReceive", new object[] {
                        publisherID,
                        eventTypeID,
                        resourceID,
                        extendedAttributes,
                        eventDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndOnNotificationReceive(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void OnNotificationReceiveAsync(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime) {
            this.OnNotificationReceiveAsync(publisherID, eventTypeID, resourceID, extendedAttributes, eventDateTime, null);
        }
        
        /// <remarks/>
        public void OnNotificationReceiveAsync(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime, object userState) {
            if ((this.OnNotificationReceiveOperationCompleted == null)) {
                this.OnNotificationReceiveOperationCompleted = new System.Threading.SendOrPostCallback(this.OnOnNotificationReceiveOperationCompleted);
            }
            this.InvokeAsync("OnNotificationReceive", new object[] {
                        publisherID,
                        eventTypeID,
                        resourceID,
                        extendedAttributes,
                        eventDateTime}, this.OnNotificationReceiveOperationCompleted, userState);
        }
        
        private void OnOnNotificationReceiveOperationCompleted(object arg) {
            if ((this.OnNotificationReceiveCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.OnNotificationReceiveCompleted(this, new OnNotificationReceiveCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OnNotificationReceiveCompletedEventHandler(object sender, OnNotificationReceiveCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OnNotificationReceiveCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal OnNotificationReceiveCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\CTPTransactionService\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\CTPTransactionService\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\client\DMPTransaction.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.Dmp {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="DMPTransactionSoap", Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class DMPTransaction : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AddProvisionedBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddPromotionalBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback RegisterUserOperationCompleted;
        
        private System.Threading.SendOrPostCallback UpdateRegistrationOperationCompleted;
        
        private System.Threading.SendOrPostCallback PurchaseItemOperationCompleted;
        
        private System.Threading.SendOrPostCallback CancelPurchaseItemOperationCompleted;

        private System.Threading.SendOrPostCallback TransferBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetBalanceDetailsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetStatementOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSingleTransactionHistoryOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetUserPropertiesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetBalancePolicyOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreditBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback DebitBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        /// <remarks/>
        public DMPTransaction() {
            this.Url = "https://titan4/DmpTransaction/Transaction.asmx";
        }
        
        /// <remarks/>
        public event AddProvisionedBalanceCompletedEventHandler AddProvisionedBalanceCompleted;
        
        /// <remarks/>
        public event AddPromotionalBalanceCompletedEventHandler AddPromotionalBalanceCompleted;
        
        /// <remarks/>
        public event RegisterUserCompletedEventHandler RegisterUserCompleted;
        
        /// <remarks/>
        public event UpdateRegistrationCompletedEventHandler UpdateRegistrationCompleted;
        
        /// <remarks/>
        public event PurchaseItemCompletedEventHandler PurchaseItemCompleted;
        
        /// <remarks/>
        public event CancelPurchaseItemCompletedEventHandler CancelPurchaseItemCompleted;
        
        /// <remarks/>
        public event TransferBalanceCompletedEventHandler TransferBalanceCompleted;

        /// <remarks/>
        public event GetBalanceCompletedEventHandler GetBalanceCompleted;
        
        /// <remarks/>
        public event GetBalanceDetailsCompletedEventHandler GetBalanceDetailsCompleted;
        
        /// <remarks/>
        public event GetStatementCompletedEventHandler GetStatementCompleted;
        
        /// <remarks/>
        public event GetSingleTransactionHistoryCompletedEventHandler GetSingleTransactionHistoryCompleted;
        
        /// <remarks/>
        public event GetStatusCompletedEventHandler GetStatusCompleted;
        
        /// <remarks/>
        public event SetStatusCompletedEventHandler SetStatusCompleted;
        
        /// <remarks/>
        public event GetUserPropertiesCompletedEventHandler GetUserPropertiesCompleted;
        
        /// <remarks/>
        public event SetUserPropertiesCompletedEventHandler SetUserPropertiesCompleted;
        
        /// <remarks/>
        public event GetBalancePolicyCompletedEventHandler GetBalancePolicyCompleted;
        
        /// <remarks/>
        public event CreditBalanceCompletedEventHandler CreditBalanceCompleted;
        
        /// <remarks/>
        public event DebitBalanceCompletedEventHandler DebitBalanceCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/AddProvisionedBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string AddProvisionedBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, out Receipt receipt) {
            object[] results = this.Invoke("AddProvisionedBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        SKU,
                        campaignId,
                        mode,
                        acquisitionTitle,
                        acquisitionType});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddProvisionedBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddProvisionedBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        SKU,
                        campaignId,
                        mode,
                        acquisitionTitle,
                        acquisitionType}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndAddProvisionedBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void AddProvisionedBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType) {
            this.AddProvisionedBalanceAsync(trackingGuid, targetUser, delegateUser, tenantId, balanceToAdd, externalReferenceId, SKU, campaignId, mode, acquisitionTitle, acquisitionType, null);
        }
        
        /// <remarks/>
        public void AddProvisionedBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, object userState) {
            if ((this.AddProvisionedBalanceOperationCompleted == null)) {
                this.AddProvisionedBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddProvisionedBalanceOperationCompleted);
            }
            this.InvokeAsync("AddProvisionedBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        SKU,
                        campaignId,
                        mode,
                        acquisitionTitle,
                        acquisitionType}, this.AddProvisionedBalanceOperationCompleted, userState);
        }
        
        private void OnAddProvisionedBalanceOperationCompleted(object arg) {
            if ((this.AddProvisionedBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddProvisionedBalanceCompleted(this, new AddProvisionedBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/AddPromotionalBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string AddPromotionalBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, out Receipt receipt) {
            object[] results = this.Invoke("AddPromotionalBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        promotionalSKU,
                        campaignId,
                        expirationLength,
                        acquisitionTitle,
                        acquisitionType});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddPromotionalBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddPromotionalBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        promotionalSKU,
                        campaignId,
                        expirationLength,
                        acquisitionTitle,
                        acquisitionType}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndAddPromotionalBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void AddPromotionalBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType) {
            this.AddPromotionalBalanceAsync(trackingGuid, targetUser, delegateUser, tenantId, balanceToAdd, externalReferenceId, promotionalSKU, campaignId, expirationLength, acquisitionTitle, acquisitionType, null);
        }
        
        /// <remarks/>
        public void AddPromotionalBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, object userState) {
            if ((this.AddPromotionalBalanceOperationCompleted == null)) {
                this.AddPromotionalBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddPromotionalBalanceOperationCompleted);
            }
            this.InvokeAsync("AddPromotionalBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        tenantId,
                        balanceToAdd,
                        externalReferenceId,
                        promotionalSKU,
                        campaignId,
                        expirationLength,
                        acquisitionTitle,
                        acquisitionType}, this.AddPromotionalBalanceOperationCompleted, userState);
        }
        
        private void OnAddPromotionalBalanceOperationCompleted(object arg) {
            if ((this.AddPromotionalBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddPromotionalBalanceCompleted(this, new AddPromotionalBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/RegisterUser", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string RegisterUser(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt) {
            object[] results = this.Invoke("RegisterUser", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRegisterUser(System.Guid trackingGuid, long targetUser, long delegateUser, string country, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RegisterUser", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndRegisterUser(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void RegisterUserAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country) {
            this.RegisterUserAsync(trackingGuid, targetUser, delegateUser, country, null);
        }
        
        /// <remarks/>
        public void RegisterUserAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country, object userState) {
            if ((this.RegisterUserOperationCompleted == null)) {
                this.RegisterUserOperationCompleted = new System.Threading.SendOrPostCallback(this.OnRegisterUserOperationCompleted);
            }
            this.InvokeAsync("RegisterUser", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, this.RegisterUserOperationCompleted, userState);
        }
        
        private void OnRegisterUserOperationCompleted(object arg) {
            if ((this.RegisterUserCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.RegisterUserCompleted(this, new RegisterUserCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/UpdateRegistration", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string UpdateRegistration(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt) {
            object[] results = this.Invoke("UpdateRegistration", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateRegistration(System.Guid trackingGuid, long targetUser, long delegateUser, string country, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateRegistration", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndUpdateRegistration(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void UpdateRegistrationAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country) {
            this.UpdateRegistrationAsync(trackingGuid, targetUser, delegateUser, country, null);
        }
        
        /// <remarks/>
        public void UpdateRegistrationAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string country, object userState) {
            if ((this.UpdateRegistrationOperationCompleted == null)) {
                this.UpdateRegistrationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUpdateRegistrationOperationCompleted);
            }
            this.InvokeAsync("UpdateRegistration", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        country}, this.UpdateRegistrationOperationCompleted, userState);
        }
        
        private void OnUpdateRegistrationOperationCompleted(object arg) {
            if ((this.UpdateRegistrationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UpdateRegistrationCompleted(this, new UpdateRegistrationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/PurchaseItem", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string PurchaseItem(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, out Receipt receipt) {
            object[] results = this.Invoke("PurchaseItem", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        itemSet,
                        context});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseItem(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("PurchaseItem", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        itemSet,
                        context}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndPurchaseItem(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void PurchaseItemAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context) {
            this.PurchaseItemAsync(trackingGuid, targetUser, delegateUser, itemSet, context, null);
        }
        
        /// <remarks/>
        public void PurchaseItemAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, object userState) {
            if ((this.PurchaseItemOperationCompleted == null)) {
                this.PurchaseItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnPurchaseItemOperationCompleted);
            }
            this.InvokeAsync("PurchaseItem", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        itemSet,
                        context}, this.PurchaseItemOperationCompleted, userState);
        }
        
        private void OnPurchaseItemOperationCompleted(object arg) {
            if ((this.PurchaseItemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.PurchaseItemCompleted(this, new PurchaseItemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/CancelPurchaseItem", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string CancelPurchaseItem(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, out Receipt receipt) {
            object[] results = this.Invoke("CancelPurchaseItem", new object[] {
                        targetUser,
                        delegateUser,
                        trackingGuidOriginal});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelPurchaseItem(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelPurchaseItem", new object[] {
                        targetUser,
                        delegateUser,
                        trackingGuidOriginal}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCancelPurchaseItem(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CancelPurchaseItemAsync(long targetUser, long delegateUser, System.Guid trackingGuidOriginal) {
            this.CancelPurchaseItemAsync(targetUser, delegateUser, trackingGuidOriginal, null);
        }
        
        /// <remarks/>
        public void CancelPurchaseItemAsync(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, object userState) {
            if ((this.CancelPurchaseItemOperationCompleted == null)) {
                this.CancelPurchaseItemOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelPurchaseItemOperationCompleted);
            }
            this.InvokeAsync("CancelPurchaseItem", new object[] {
                        targetUser,
                        delegateUser,
                        trackingGuidOriginal}, this.CancelPurchaseItemOperationCompleted, userState);
        }
        
        private void OnCancelPurchaseItemOperationCompleted(object arg) {
            if ((this.CancelPurchaseItemCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelPurchaseItemCompleted(this, new CancelPurchaseItemCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TransferBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TransferBalance(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt) {
            object[] results = this.Invoke("TransferBalance", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context});
            sourceReceipt = ((Receipt)(results[1]));
            transferReceipt = ((Receipt)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferBalance(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferBalance", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTransferBalance(System.IAsyncResult asyncResult, out Receipt sourceReceipt, out Receipt transferReceipt) {
            object[] results = this.EndInvoke(asyncResult);
            sourceReceipt = ((Receipt)(results[1]));
            transferReceipt = ((Receipt)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TransferBalanceAsync(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context) {
            this.TransferBalanceAsync(trackingGuid, sourceUser, transferUser, delegateUser, pointsToTransfer, context, null);
        }
        
        /// <remarks/>
        public void TransferBalanceAsync(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, object userState) {
            if ((this.TransferBalanceOperationCompleted == null)) {
                this.TransferBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTransferBalanceOperationCompleted);
            }
            this.InvokeAsync("TransferBalance", new object[] {
                        trackingGuid,
                        sourceUser,
                        transferUser,
                        delegateUser,
                        pointsToTransfer,
                        context}, this.TransferBalanceOperationCompleted, userState);
        }
        
        private void OnTransferBalanceOperationCompleted(object arg) {
            if ((this.TransferBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TransferBalanceCompleted(this, new TransferBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetBalance(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out string country) {
            object[] results = this.Invoke("GetBalance", new object[] {
                        targetUser,
                        delegateUser});
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            country = ((string)(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBalance(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBalance", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetBalance(System.IAsyncResult asyncResult, out int balance, out bool aboveLowBalance, out Status statusUser, out string country) {
            object[] results = this.EndInvoke(asyncResult);
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            country = ((string)(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetBalanceAsync(long targetUser, long delegateUser) {
            this.GetBalanceAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetBalanceAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetBalanceOperationCompleted == null)) {
                this.GetBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBalanceOperationCompleted);
            }
            this.InvokeAsync("GetBalance", new object[] {
                        targetUser,
                        delegateUser}, this.GetBalanceOperationCompleted, userState);
        }
        
        private void OnGetBalanceOperationCompleted(object arg) {
            if ((this.GetBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBalanceCompleted(this, new GetBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalanceDetails", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetBalanceDetails(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out PointLot[] lots) {
            object[] results = this.Invoke("GetBalanceDetails", new object[] {
                        targetUser,
                        delegateUser});
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            lots = ((PointLot[])(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBalanceDetails(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBalanceDetails", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetBalanceDetails(System.IAsyncResult asyncResult, out int balance, out bool aboveLowBalance, out Status statusUser, out PointLot[] lots) {
            object[] results = this.EndInvoke(asyncResult);
            balance = ((int)(results[1]));
            aboveLowBalance = ((bool)(results[2]));
            statusUser = ((Status)(results[3]));
            lots = ((PointLot[])(results[4]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetBalanceDetailsAsync(long targetUser, long delegateUser) {
            this.GetBalanceDetailsAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetBalanceDetailsAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetBalanceDetailsOperationCompleted == null)) {
                this.GetBalanceDetailsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBalanceDetailsOperationCompleted);
            }
            this.InvokeAsync("GetBalanceDetails", new object[] {
                        targetUser,
                        delegateUser}, this.GetBalanceDetailsOperationCompleted, userState);
        }
        
        private void OnGetBalanceDetailsOperationCompleted(object arg) {
            if ((this.GetBalanceDetailsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBalanceDetailsCompleted(this, new GetBalanceDetailsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetStatement", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetStatement(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, out string nextHandle, out Transaction[] transactions) {
            object[] results = this.Invoke("GetStatement", new object[] {
                        targetUser,
                        delegateUser,
                        tenantId,
                        filter,
                        startDate,
                        endDate,
                        numTransactionsRequested,
                        startHandle});
            nextHandle = ((string)(results[1]));
            transactions = ((Transaction[])(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatement(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatement", new object[] {
                        targetUser,
                        delegateUser,
                        tenantId,
                        filter,
                        startDate,
                        endDate,
                        numTransactionsRequested,
                        startHandle}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetStatement(System.IAsyncResult asyncResult, out string nextHandle, out Transaction[] transactions) {
            object[] results = this.EndInvoke(asyncResult);
            nextHandle = ((string)(results[1]));
            transactions = ((Transaction[])(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetStatementAsync(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle) {
            this.GetStatementAsync(targetUser, delegateUser, tenantId, filter, startDate, endDate, numTransactionsRequested, startHandle, null);
        }
        
        /// <remarks/>
        public void GetStatementAsync(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, object userState) {
            if ((this.GetStatementOperationCompleted == null)) {
                this.GetStatementOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetStatementOperationCompleted);
            }
            this.InvokeAsync("GetStatement", new object[] {
                        targetUser,
                        delegateUser,
                        tenantId,
                        filter,
                        startDate,
                        endDate,
                        numTransactionsRequested,
                        startHandle}, this.GetStatementOperationCompleted, userState);
        }
        
        private void OnGetStatementOperationCompleted(object arg) {
            if ((this.GetStatementCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetStatementCompleted(this, new GetStatementCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetSingleTransactionHistory", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetSingleTransactionHistory(long targetUser, long delegateUser, string cId, out Transaction[] transactions) {
            object[] results = this.Invoke("GetSingleTransactionHistory", new object[] {
                        targetUser,
                        delegateUser,
                        cId});
            transactions = ((Transaction[])(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSingleTransactionHistory(long targetUser, long delegateUser, string cId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSingleTransactionHistory", new object[] {
                        targetUser,
                        delegateUser,
                        cId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetSingleTransactionHistory(System.IAsyncResult asyncResult, out Transaction[] transactions) {
            object[] results = this.EndInvoke(asyncResult);
            transactions = ((Transaction[])(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetSingleTransactionHistoryAsync(long targetUser, long delegateUser, string cId) {
            this.GetSingleTransactionHistoryAsync(targetUser, delegateUser, cId, null);
        }
        
        /// <remarks/>
        public void GetSingleTransactionHistoryAsync(long targetUser, long delegateUser, string cId, object userState) {
            if ((this.GetSingleTransactionHistoryOperationCompleted == null)) {
                this.GetSingleTransactionHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSingleTransactionHistoryOperationCompleted);
            }
            this.InvokeAsync("GetSingleTransactionHistory", new object[] {
                        targetUser,
                        delegateUser,
                        cId}, this.GetSingleTransactionHistoryOperationCompleted, userState);
        }
        
        private void OnGetSingleTransactionHistoryOperationCompleted(object arg) {
            if ((this.GetSingleTransactionHistoryCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSingleTransactionHistoryCompleted(this, new GetSingleTransactionHistoryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetStatus", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetStatus(long targetUser, long delegateUser, out Status statusUser) {
            object[] results = this.Invoke("GetStatus", new object[] {
                        targetUser,
                        delegateUser});
            statusUser = ((Status)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatus(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatus", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetStatus(System.IAsyncResult asyncResult, out Status statusUser) {
            object[] results = this.EndInvoke(asyncResult);
            statusUser = ((Status)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetStatusAsync(long targetUser, long delegateUser) {
            this.GetStatusAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetStatusAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetStatusOperationCompleted == null)) {
                this.GetStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetStatusOperationCompleted);
            }
            this.InvokeAsync("GetStatus", new object[] {
                        targetUser,
                        delegateUser}, this.GetStatusOperationCompleted, userState);
        }
        
        private void OnGetStatusOperationCompleted(object arg) {
            if ((this.GetStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetStatusCompleted(this, new GetStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/SetStatus", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string SetStatus(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("SetStatus", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        statusUser,
                        externalReferenceId,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetStatus(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetStatus", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        statusUser,
                        externalReferenceId,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndSetStatus(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void SetStatusAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason) {
            this.SetStatusAsync(trackingGuid, targetUser, delegateUser, statusUser, externalReferenceId, reason, null);
        }
        
        /// <remarks/>
        public void SetStatusAsync(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, object userState) {
            if ((this.SetStatusOperationCompleted == null)) {
                this.SetStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetStatusOperationCompleted);
            }
            this.InvokeAsync("SetStatus", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        statusUser,
                        externalReferenceId,
                        reason}, this.SetStatusOperationCompleted, userState);
        }
        
        private void OnSetStatusOperationCompleted(object arg) {
            if ((this.SetStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetStatusCompleted(this, new SetStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetUserProperties", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetUserProperties(long targetUser, long delegateUser, out UserProperties userProp) {
            object[] results = this.Invoke("GetUserProperties", new object[] {
                        targetUser,
                        delegateUser});
            userProp = ((UserProperties)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserProperties(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserProperties", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetUserProperties(System.IAsyncResult asyncResult, out UserProperties userProp) {
            object[] results = this.EndInvoke(asyncResult);
            userProp = ((UserProperties)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserPropertiesAsync(long targetUser, long delegateUser) {
            this.GetUserPropertiesAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetUserPropertiesAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetUserPropertiesOperationCompleted == null)) {
                this.GetUserPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserPropertiesOperationCompleted);
            }
            this.InvokeAsync("GetUserProperties", new object[] {
                        targetUser,
                        delegateUser}, this.GetUserPropertiesOperationCompleted, userState);
        }
        
        private void OnGetUserPropertiesOperationCompleted(object arg) {
            if ((this.GetUserPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserPropertiesCompleted(this, new GetUserPropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/SetUserProperties", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string SetUserProperties(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("SetUserProperties", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        userProp,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetUserProperties(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetUserProperties", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        userProp,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndSetUserProperties(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void SetUserPropertiesAsync(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason) {
            this.SetUserPropertiesAsync(trackingGuid, targetUser, delegateUser, userProp, reason, null);
        }
        
        /// <remarks/>
        public void SetUserPropertiesAsync(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, object userState) {
            if ((this.SetUserPropertiesOperationCompleted == null)) {
                this.SetUserPropertiesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetUserPropertiesOperationCompleted);
            }
            this.InvokeAsync("SetUserProperties", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        userProp,
                        reason}, this.SetUserPropertiesOperationCompleted, userState);
        }
        
        private void OnSetUserPropertiesOperationCompleted(object arg) {
            if ((this.SetUserPropertiesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetUserPropertiesCompleted(this, new SetUserPropertiesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalancePolicy", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetBalancePolicy(long targetUser, long delegateUser, out BalancePolicy policy) {
            object[] results = this.Invoke("GetBalancePolicy", new object[] {
                        targetUser,
                        delegateUser});
            policy = ((BalancePolicy)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBalancePolicy(long targetUser, long delegateUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBalancePolicy", new object[] {
                        targetUser,
                        delegateUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetBalancePolicy(System.IAsyncResult asyncResult, out BalancePolicy policy) {
            object[] results = this.EndInvoke(asyncResult);
            policy = ((BalancePolicy)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetBalancePolicyAsync(long targetUser, long delegateUser) {
            this.GetBalancePolicyAsync(targetUser, delegateUser, null);
        }
        
        /// <remarks/>
        public void GetBalancePolicyAsync(long targetUser, long delegateUser, object userState) {
            if ((this.GetBalancePolicyOperationCompleted == null)) {
                this.GetBalancePolicyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetBalancePolicyOperationCompleted);
            }
            this.InvokeAsync("GetBalancePolicy", new object[] {
                        targetUser,
                        delegateUser}, this.GetBalancePolicyOperationCompleted, userState);
        }
        
        private void OnGetBalancePolicyOperationCompleted(object arg) {
            if ((this.GetBalancePolicyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetBalancePolicyCompleted(this, new GetBalancePolicyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/CreditBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string CreditBalance(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("CreditBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        cId,
                        itemsToCredit,
                        externalReferenceId,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditBalance(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        cId,
                        itemsToCredit,
                        externalReferenceId,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCreditBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void CreditBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason) {
            this.CreditBalanceAsync(trackingGuid, targetUser, delegateUser, cId, itemsToCredit, externalReferenceId, reason, null);
        }
        
        /// <remarks/>
        public void CreditBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, object userState) {
            if ((this.CreditBalanceOperationCompleted == null)) {
                this.CreditBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreditBalanceOperationCompleted);
            }
            this.InvokeAsync("CreditBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        cId,
                        itemsToCredit,
                        externalReferenceId,
                        reason}, this.CreditBalanceOperationCompleted, userState);
        }
        
        private void OnCreditBalanceOperationCompleted(object arg) {
            if ((this.CreditBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreditBalanceCompleted(this, new CreditBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/DebitBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string DebitBalance(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, out Receipt receipt) {
            object[] results = this.Invoke("DebitBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        balanceToAdjust,
                        cId,
                        externalReferenceId,
                        reason});
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDebitBalance(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DebitBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        balanceToAdjust,
                        cId,
                        externalReferenceId,
                        reason}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndDebitBalance(System.IAsyncResult asyncResult, out Receipt receipt) {
            object[] results = this.EndInvoke(asyncResult);
            receipt = ((Receipt)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void DebitBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason) {
            this.DebitBalanceAsync(trackingGuid, targetUser, delegateUser, balanceToAdjust, cId, externalReferenceId, reason, null);
        }
        
        /// <remarks/>
        public void DebitBalanceAsync(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, object userState) {
            if ((this.DebitBalanceOperationCompleted == null)) {
                this.DebitBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnDebitBalanceOperationCompleted);
            }
            this.InvokeAsync("DebitBalance", new object[] {
                        trackingGuid,
                        targetUser,
                        delegateUser,
                        balanceToAdjust,
                        cId,
                        externalReferenceId,
                        reason}, this.DebitBalanceOperationCompleted, userState);
        }
        
        private void OnDebitBalanceOperationCompleted(object arg) {
            if ((this.DebitBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.DebitBalanceCompleted(this, new DebitBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TestConnection", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string echoIn, out System.DateTime dt, out string echoOut) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        echoIn});
            dt = ((System.DateTime)(results[1]));
            echoOut = ((string)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string echoIn, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        echoIn}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult, out System.DateTime dt, out string echoOut) {
            object[] results = this.EndInvoke(asyncResult);
            dt = ((System.DateTime)(results[1]));
            echoOut = ((string)(results[2]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string echoIn) {
            this.TestConnectionAsync(echoIn, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string echoIn, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        echoIn}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddProvisionedBalanceCompletedEventHandler(object sender, AddProvisionedBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddProvisionedBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddProvisionedBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddPromotionalBalanceCompletedEventHandler(object sender, AddPromotionalBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddPromotionalBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddPromotionalBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RegisterUserCompletedEventHandler(object sender, RegisterUserCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RegisterUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RegisterUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateRegistrationCompletedEventHandler(object sender, UpdateRegistrationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateRegistrationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateRegistrationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseItemCompletedEventHandler(object sender, PurchaseItemCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseItemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal PurchaseItemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelPurchaseItemCompletedEventHandler(object sender, CancelPurchaseItemCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CancelPurchaseItemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CancelPurchaseItemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    

    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TransferBalanceCompletedEventHandler(object sender, TransferBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TransferBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TransferBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt sourceReceipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Receipt transferReceipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBalanceCompletedEventHandler(object sender, GetBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int balance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool aboveLowBalance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public Status statusUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Status)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public string country {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBalanceDetailsCompletedEventHandler(object sender, GetBalanceDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBalanceDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetBalanceDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public int balance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public bool aboveLowBalance {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[2]));
            }
        }
        
        /// <remarks/>
        public Status statusUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Status)(this.results[3]));
            }
        }
        
        /// <remarks/>
        public PointLot[] lots {
            get {
                this.RaiseExceptionIfNecessary();
                return ((PointLot[])(this.results[4]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetStatementCompletedEventHandler(object sender, GetStatementCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetStatementCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetStatementCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string nextHandle {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public Transaction[] transactions {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Transaction[])(this.results[2]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSingleTransactionHistoryCompletedEventHandler(object sender, GetSingleTransactionHistoryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSingleTransactionHistoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSingleTransactionHistoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Transaction[] transactions {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Transaction[])(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetStatusCompletedEventHandler(object sender, GetStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Status statusUser {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Status)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetStatusCompletedEventHandler(object sender, SetStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserPropertiesCompletedEventHandler(object sender, GetUserPropertiesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserPropertiesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserPropertiesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public UserProperties userProp {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserProperties)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetUserPropertiesCompletedEventHandler(object sender, SetUserPropertiesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetUserPropertiesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SetUserPropertiesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBalancePolicyCompletedEventHandler(object sender, GetBalancePolicyCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBalancePolicyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetBalancePolicyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public BalancePolicy policy {
            get {
                this.RaiseExceptionIfNecessary();
                return ((BalancePolicy)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreditBalanceCompletedEventHandler(object sender, CreditBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreditBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreditBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DebitBalanceCompletedEventHandler(object sender, DebitBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DebitBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal DebitBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public Receipt receipt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((Receipt)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public System.DateTime dt {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.DateTime)(this.results[1]));
            }
        }
        
        /// <remarks/>
        public string echoOut {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\CTPTransactionService\TransactionServerStub.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.TransactionService
{
    using System;
    using System.ServiceModel.Activation;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

        
    [Emulate]
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class TransactionServiceServerStub : ContextBoundObject, TransactionService
    {
        public PurchaseOutput Purchase(PurchaseInput request)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public PayoutOutput Payout(PayoutInput PayoutInput)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public JoinSubscriptionOutput JoinSubscription(JoinSubscriptionInput joinSubscriptionInput)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public MigrateAccountOutput MigrateAccount(MigrateAccountInput migrateAccountInput)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public GetPayoutOrderStatusOutput GetPayoutOrderStatus(GetPayoutOrderStatusInput GetPayoutOrderStatusInput)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public GetPayoutOrderEventUpdateOutput GetPayoutOrderEventUpdate(GetPayoutOrderEventUpdateInput GetPayoutOrderEventUpdateInput)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public string TestConnection(string inputString) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\controller\Controller.cs ===
namespace  Microsoft.XBox.Live.Server.Emulators.Controller 
{
    using System;
    using System.Web;
    using System.Web.Services;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;

    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    [WebService]
    public class Controller : WebService 
    {
        private readonly string masterPrefix = "master_";
        private readonly string recordingPrefix = "recording_";
        
        [WebMethod]
            public Guid AddCallSequence(string encodedRecording) 
        {
            MemoryStream ms = new MemoryStream(Convert.FromBase64String(encodedRecording));
            BinaryFormatter bf = new BinaryFormatter();
            Recording r = (Recording)bf.Deserialize(ms);
            
            Guid guid = Guid.NewGuid();
            HttpContext.Current.Application[masterPrefix + guid.ToString()] = r;
            HttpContext.Current.Application[recordingPrefix + guid.ToString()] = new Recording();

            return guid;
        }
        
        [WebMethod]
            public string GetCallRecord(Guid guid)
        {
            Recording r = (Recording)HttpContext.Current.Application[recordingPrefix+guid.ToString()];
            return r.ToBase64String();
            
        }
        
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\CTPTransactionService\TransactionServiceEmulator.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.TransactionService
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public class CTPTransactionEmulator : EmulatorFacadeBase<Microsoft.XBox.Live.Server.Emulators.TransactionService.TransactionService>
    {
        protected override string HandlerName 
        {
            get 
            {
                return "TransactionServiceEmulator.svc";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\dmp\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\dmp\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\dmp\DMPEmulator.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Dmp
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    public class DMPEmulator:EmulatorFacadeBase<IDMPTransactionSoap>
    {
        protected override string HandlerName 
        {
            get 
            {
                return "DMPEmulator.asmx";
            }
        }
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\dmp\DMPServerStub.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Dmp {
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
        
    [Emulate]
    public class DMPServerStub : ContextBoundObject, IDMPTransactionSoap 
    {
        public string AddProvisionedBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string AddPromotionalBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string RegisterUser(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string UpdateRegistration(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string PurchaseItem(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string CancelPurchaseItem(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string GetBalance(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out string country)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string GetBalanceDetails(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out PointLot[] lots)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string GetStatement(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, out string nextHandle, out Transaction[] transactions)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string GetSingleTransactionHistory(long targetUser, long delegateUser, string cId, out Transaction[] transactions)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string GetStatus(long targetUser, long delegateUser, out Status statusUser)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string SetStatus(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string GetUserProperties(long targetUser, long delegateUser, out UserProperties userProp)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string SetUserProperties(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string GetBalancePolicy(long targetUser, long delegateUser, out BalancePolicy policy)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string CreditBalance(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string DebitBalance(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, out Receipt receipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
        
        
        public string TestConnection(string echoIn, out System.DateTime dt, out string echoOut)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public string TransferBalance(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public string TransferPoints(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransferTransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\dmp\DMPTransactionTypes.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Dmp {
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    public partial class Receipt 
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            Receipt r = (Receipt)obj;
            return (TrackingGuid == r.TrackingGuid && ConfirmationId == r.ConfirmationId
                    && ConfirmationDate == r.ConfirmationDate && NewBalance == r.NewBalance);
        }
        
        public override int GetHashCode() 
        {
            return TrackingGuid.GetHashCode()^Helpers.GetHashCode(ConfirmationId)
                ^ConfirmationDate.GetHashCode()^NewBalance;
        }
    }
    
    public partial class BalancePolicy 
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            BalancePolicy bp = (BalancePolicy)obj;
            return (MinBalanceIndicator == bp.MinBalanceIndicator && MaxBalance == bp.MaxBalance
                    && MaxBalanceAcquisition == bp.MaxBalanceAcquisition
                    && ConsumptionLimitSpan == bp.ConsumptionLimitSpan
                    && ConsumptionLimitMax == bp.ConsumptionLimitMax
                    && PromotionalLimitMaxPerSku == bp.PromotionalLimitMaxPerSku);
        }
        
        public override int GetHashCode() 
        {
            return MinBalanceIndicator^MaxBalance^MaxBalanceAcquisition
                ^ConsumptionLimitSpan^ConsumptionLimitMax^PromotionalLimitMaxPerSku;
        }
    }
    
    public partial class UserProperties 
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            UserProperties up = (UserProperties)obj;
            return MinBalanceIndicator == up.MinBalanceIndicator;
        }
        
        public override int GetHashCode()
        {
            return MinBalanceIndicator;
        }
    }
    
    public partial class Transaction
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            Transaction t = (Transaction)obj;
            
            return (TargetUser == t.TargetUser && DelegateUser == t.DelegateUser 
                    && BalanceChange == t.BalanceChange && transactionType == t.transactionType
                    && AcquisitionTitle == t.AcquisitionTitle && AcquisitionType == t.AcquisitionType
                    && AcquisitionTypeSpecified == t.AcquisitionTypeSpecified 
                    && Arrays.Equal(ItemSet, t.ItemSet) && reasonCode == t.reasonCode
                    && reasonCodeSpecified == t.reasonCodeSpecified
                    && ConfirmationId == t.ConfirmationId && ConfirmationDate == t.ConfirmationDate
                    && OriginalConfirmationId == t.OriginalConfirmationId 
                    && TenantId == t.TenantId && ExternalReferenceId == t.ExternalReferenceId
                    && PostingDate == t.PostingDate 
                    && PostingDateSpecified == t.PostingDateSpecified 
                    && ClientAddress == t.ClientAddress);
        }
        
        public override int GetHashCode()
        {
            return TargetUser.GetHashCode()^DelegateUser.GetHashCode()^BalanceChange
                ^transactionType.GetHashCode()^Helpers.GetHashCode(AcquisitionTitle)
                ^AcquisitionType^AcquisitionTypeSpecified.GetHashCode()^Arrays.GetHashCode(ItemSet)
                ^reasonCode.GetHashCode()^Helpers.GetHashCode(ConfirmationId)
                ^ConfirmationDate.GetHashCode()^Helpers.GetHashCode(OriginalConfirmationId)
                ^TenantId.GetHashCode()^Helpers.GetHashCode(ExternalReferenceId)
                ^PostingDate.GetHashCode()^PostingDateSpecified.GetHashCode()^
                Helpers.GetHashCode(ClientAddress);
        }
    }
    
    public partial class Item 
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            Item i = (Item)obj;
            return (ExternalId == i.ExternalId && Title == i.Title && Price == i.Price
                    && SKU == i.SKU && ItemCategory == i.ItemCategory && ItemCredit == i.ItemCredit
                    && ItemCreditSpecified == i.ItemCreditSpecified);
        }
        
        public override int GetHashCode()
        {
            return Helpers.GetHashCode(ExternalId)^Helpers.GetHashCode(Title)
                ^Price^Helpers.GetHashCode(SKU)^Helpers.GetHashCode(ItemCategory)
                ^ItemCredit^ItemCreditSpecified.GetHashCode();
        }
    }
    
    public partial class PointLot 
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            PointLot pl = (PointLot)obj;
            
            return (sourceType == pl.sourceType && Quantity == pl.Quantity 
                    && ExpirationDays == pl.ExpirationDays 
                    && ExpirationDaysSpecified == pl.ExpirationDaysSpecified);
        }
        
        public override int GetHashCode()
        {
            return sourceType.GetHashCode()^Quantity^ExpirationDays
                ^ExpirationDaysSpecified.GetHashCode();
        }
    }
    
    public partial class TransactionContext 
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            TransactionContext tc = (TransactionContext)obj;
            return (SellingPartnerId == tc.SellingPartnerId 
                    && ExternalReferenceId == tc.ExternalReferenceId
                    && PostingDate == tc.PostingDate && ClientAddress == tc.ClientAddress
                    && CampaignId == tc.CampaignId);
        }
        
        public override int GetHashCode() 
        {
            return SellingPartnerId.GetHashCode()^Helpers.GetHashCode(ExternalReferenceId)
                ^PostingDate.GetHashCode()^Helpers.GetHashCode(ClientAddress)^CampaignId;
        }
    }
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\finbus\FinBusServerStub.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.FinBus {
    using System;
    using System.ServiceModel.Activation;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    [Emulate]
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class FinBusServerStub : ContextBoundObject, IInjectionService
    {
        public microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse PublishMessage(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public string IsServiceAlive(string message)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public System.IAsyncResult BeginPublishMessage(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message, System.AsyncCallback callback, object asyncState)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse EndPublishMessage(System.IAsyncResult result)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public System.IAsyncResult BeginIsServiceAlive(string message, System.AsyncCallback callback, object asyncState)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }

        public string EndIsServiceAlive(System.IAsyncResult result)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\finbus\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\finbus\FinBusEmulator.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.FinBus
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public class FinBusEmulator : EmulatorFacadeBase<IInjectionService>
    {
        protected override string HandlerName 
        {
            get 
            {
                return "FinBusEmulator.svc";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\finbus\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\CollectionEqualConstraint.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    using System.Collections;
    
    [System.Serializable]
    public class CollectionEqualConstraint: IConstraint
    {
        ICollection expected;
        public CollectionEqualConstraint(object expected) 
        {
            this.expected = (ICollection)expected;
            
        }
        
        public bool Verify(object got, out string errorMessage) 
        {
            errorMessage = String.Empty;
            
            if (got == null && expected == null)
                return true;
            
            ICollection gotCollection = got as ICollection;
            if (gotCollection == null) 
            {
                errorMessage = "Expected a collection but got NULL";
                return false;
            }
            
            if (gotCollection.Count != expected.Count) 
            {
                errorMessage = String.Format("Expected a collection with {0} items but got one with {1}", expected.Count, gotCollection.Count);
                return false;
            }
            
            
            IEnumerator enumGot = gotCollection.GetEnumerator();
            IEnumerator enumExpected = expected.GetEnumerator();
            int elem =0;
            while (enumGot.MoveNext() && enumExpected.MoveNext()) 
            {
                if(!enumExpected.Current.Equals(enumGot.Current)) 
                {
                    errorMessage = String.Format("Unexpected element at position {0}.Expected {1} but got {2}", elem, enumExpected.Current, enumGot.Current);
                    return false;
                }
                elem++;
            }
            
            return true;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\CallHolder.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework 
{
    using System;
    
    public class CallHolder: IMethodCallOptions 
    {
        private MethodCall call;
        private bool expectedAnytime = false;
        
        public CallHolder(MethodCall call) 
        {
            this.call = call;
        }
        
        public void AddToRecording(Recording r) 
        {
            if (expectedAnytime) 
            {
                r.stubs[call.Name] = call;
            }
            else 
            {
                r.orderedCalls.Add(this.call);
            }
            
        }
        
        IMethodCallOptions IMethodCallOptions.Returns (object returnValue) 
        {
            ((IMethodCallOptions)call).Returns(returnValue);
            return this;
        }
        
        IMethodCallOptions IMethodCallOptions.Throws (Exception exception)
        {
            ((IMethodCallOptions)call).Throws(exception);
            return this;
        }

        IMethodCallOptions IMethodCallOptions.Argument (int argIndex, IConstraint constraint)
        {
            ((IMethodCallOptions)call).Argument(argIndex, constraint);
            return this;
        }

        IMethodCallOptions IMethodCallOptions.Arguments (params IConstraint[] constraints)
        {
            ((IMethodCallOptions)call).Arguments(constraints);
            return this;
        }
        
        IMethodCallOptions IMethodCallOptions.IgnoresArgument(int argIndex) 
        {
            ((IMethodCallOptions)call).IgnoresArgument(argIndex);
            return this;
        }
        
        IMethodCallOptions IMethodCallOptions.ClosesConnection()
        {
            ((IMethodCallOptions)call).ClosesConnection();
            return this;
        }

        IMethodCallOptions IMethodCallOptions.OutArguments(params object[] outArgs)
        {
            ((IMethodCallOptions)call).OutArguments(outArgs);
            return this;
        }
        
        IMethodCallOptions IMethodCallOptions.ExpectedAnytime() 
        {
            expectedAnytime = true;
            return this;
        }

        IMethodCallOptions IMethodCallOptions.Waits(TimeSpan waitInterval) 
        {
            call.WaitInterval = waitInterval;
            return this;
        }
        
        

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\EmulateAttribute.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework 
{
    using System;
    using System.Runtime.Remoting.Proxies;
    using System.Security.Permissions;

    [AttributeUsage(AttributeTargets.Class)]
    public class EmulateAttribute: ProxyAttribute 
    {
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public override MarshalByRefObject CreateInstance(Type targetType) 
        {
            MarshalByRefObject target = base.CreateInstance(targetType);
            RealProxy proxy = new EmulationProxy(target, targetType);
            return (MarshalByRefObject)(proxy.GetTransparentProxy());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\dmp\DMPTransactionSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.Dmp {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="DMPTransactionSoap", Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public interface IDMPTransactionSoap {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/AddProvisionedBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string AddProvisionedBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string SKU, int campaignId, ProvisionMode mode, string acquisitionTitle, int acquisitionType, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/AddPromotionalBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string AddPromotionalBalance(System.Guid trackingGuid, long targetUser, long delegateUser, System.Guid tenantId, int balanceToAdd, string externalReferenceId, string promotionalSKU, int campaignId, short expirationLength, string acquisitionTitle, int acquisitionType, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/RegisterUser", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string RegisterUser(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/UpdateRegistration", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string UpdateRegistration(System.Guid trackingGuid, long targetUser, long delegateUser, string country, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/PurchaseItem", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string PurchaseItem(System.Guid trackingGuid, long targetUser, long delegateUser, Item[] itemSet, TransactionContext context, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/CancelPurchaseItem", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string CancelPurchaseItem(long targetUser, long delegateUser, System.Guid trackingGuidOriginal, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string GetBalance(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out string country);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalanceDetails", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string GetBalanceDetails(long targetUser, long delegateUser, out int balance, out bool aboveLowBalance, out Status statusUser, out PointLot[] lots);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetStatement", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string GetStatement(long targetUser, long delegateUser, System.Guid tenantId, TransactionType filter, System.DateTime startDate, System.DateTime endDate, short numTransactionsRequested, string startHandle, out string nextHandle, out Transaction[] transactions);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetSingleTransactionHistory", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string GetSingleTransactionHistory(long targetUser, long delegateUser, string cId, out Transaction[] transactions);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetStatus", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string GetStatus(long targetUser, long delegateUser, out Status statusUser);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/SetStatus", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string SetStatus(System.Guid trackingGuid, long targetUser, long delegateUser, Status statusUser, string externalReferenceId, ReasonCode reason, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetUserProperties", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string GetUserProperties(long targetUser, long delegateUser, out UserProperties userProp);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/SetUserProperties", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string SetUserProperties(System.Guid trackingGuid, long targetUser, long delegateUser, UserProperties userProp, ReasonCode reason, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/GetBalancePolicy", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string GetBalancePolicy(long targetUser, long delegateUser, out BalancePolicy policy);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/CreditBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string CreditBalance(System.Guid trackingGuid, long targetUser, long delegateUser, string cId, Item[] itemsToCredit, string externalReferenceId, ReasonCode reason, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/DebitBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string DebitBalance(System.Guid trackingGuid, long targetUser, long delegateUser, int balanceToAdjust, string cId, string externalReferenceId, ReasonCode reason, out Receipt receipt);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TestConnection", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string TestConnection(string echoIn, out System.DateTime dt, out string echoOut);

        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TransferBalance", RequestNamespace="http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace="http://schemas.microsoft.com/DMP/2004/09/API", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string TransferBalance(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt);

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.microsoft.com/DMP/2004/09/API/TransferPoints", RequestNamespace = "http://schemas.microsoft.com/DMP/2004/09/API", ResponseNamespace = "http://schemas.microsoft.com/DMP/2004/09/API", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        string TransferPoints(System.Guid trackingGuid, long sourceUser, long transferUser, long delegateUser, int pointsToTransfer, TransferTransactionContext context, out Receipt sourceReceipt, out Receipt transferReceipt);     
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum ProvisionMode {
        
        /// <remarks/>
        Normal,
        
        /// <remarks/>
        ComputeOnly,
        
        /// <remarks/>
        MaxBalanceOverride,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Receipt {
        
        /// <remarks/>
        public System.Guid TrackingGuid;
        
        /// <remarks/>
        public string ConfirmationId;
        
        /// <remarks/>
        public System.DateTime ConfirmationDate;
        
        /// <remarks/>
        public int NewBalance;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class BalancePolicy {
        
        /// <remarks/>
        public int MinBalanceIndicator;
        
        /// <remarks/>
        public int MaxBalance;
        
        /// <remarks/>
        public int MaxBalanceAcquisition;
        
        /// <remarks/>
        public int ConsumptionLimitSpan;
        
        /// <remarks/>
        public int ConsumptionLimitMax;
        
        /// <remarks/>
        public int PromotionalLimitMaxPerSku;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class UserProperties {
        
        /// <remarks/>
        public int MinBalanceIndicator;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Transaction {
        
        /// <remarks/>
        public long TargetUser;
        
        /// <remarks/>
        public long DelegateUser;
        
        /// <remarks/>
        public int BalanceChange;
        
        /// <remarks/>
        public TransactionType transactionType;
        
        /// <remarks/>
        public string AcquisitionTitle;
        
        /// <remarks/>
        public int AcquisitionType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AcquisitionTypeSpecified;
        
        /// <remarks/>
        public Item[] ItemSet;
        
        /// <remarks/>
        public ReasonCode reasonCode;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool reasonCodeSpecified;
        
        /// <remarks/>
        public string ConfirmationId;
        
        /// <remarks/>
        public System.DateTime ConfirmationDate;
        
        /// <remarks/>
        public string OriginalConfirmationId;
        
        /// <remarks/>
        public System.Guid TenantId;
        
        /// <remarks/>
        public string ExternalReferenceId;
        
        /// <remarks/>
        public System.DateTime PostingDate;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool PostingDateSpecified;
        
        /// <remarks/>
        public string ClientAddress;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum TransactionType {
        
        /// <remarks/>
        All,
        
        /// <remarks/>
        StatusCreated,
        
        /// <remarks/>
        StatusDisabled,
        
        /// <remarks/>
        StatusReactivated,
        
        /// <remarks/>
        StatusClosed,
        
        /// <remarks/>
        PurchasePoints,
        
        /// <remarks/>
        PromotionPoints,
        
        /// <remarks/>
        PurchaseItem,
        
        /// <remarks/>
        ChangeUserProperties,
        
        /// <remarks/>
        CancelPurchase,
        
        /// <remarks/>
        CreditBalance,
        
        /// <remarks/>
        ChargebackDebit,
        
        /// <remarks/>
        RefundDebit,
        
        /// <remarks/>
        ExpirePurchasedPoints,
        
        /// <remarks/>
        ExpirePromoPoints,
        
        /// <remarks/>
        OffsetCredit,
        
        /// <remarks/>
        UpdateRegistration,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Item {
        
        /// <remarks/>
        public string ExternalId;
        
        /// <remarks/>
        public string Title;
        
        /// <remarks/>
        public int Price;
        
        /// <remarks/>
        public string SKU;
        
        /// <remarks/>
        public string ItemCategory;
        
        /// <remarks/>
        public byte ItemCredit;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ItemCreditSpecified;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum ReasonCode {
        
        /// <remarks/>
        OK,
        
        /// <remarks/>
        ConsumptionError,
        
        /// <remarks/>
        CustomerRetention,
        
        /// <remarks/>
        PurchaseCredit,
        
        /// <remarks/>
        ProductFailure,
        
        /// <remarks/>
        FraudClaim,
        
        /// <remarks/>
        PromotionalExpiration,
        
        /// <remarks/>
        CountryDisable,
        
        /// <remarks/>
        CountryActivate,
        
        /// <remarks/>
        CustomerRequestedClose,
        
        /// <remarks/>
        CustomerRequestedReopen,
        
        /// <remarks/>
        FraudSuspected,
        
        /// <remarks/>
        FraudNotSuspected,
        
        /// <remarks/>
        CustomerRequestedCloseAndRefund,
        
        /// <remarks/>
        Offset,
        
        /// <remarks/>
        Chargeback,
        
        /// <remarks/>
        Refund,
        
        /// <remarks/>
        RegularExpiration,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class PointLot {
        
        /// <remarks/>
        public SourceType sourceType;
        
        /// <remarks/>
        public int Quantity;
        
        /// <remarks/>
        public short ExpirationDays;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ExpirationDaysSpecified;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum SourceType {
        
        /// <remarks/>
        SourcePurchased,
        
        /// <remarks/>
        SourcePromo,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class TransactionContext {
        
        /// <remarks/>
        public System.Guid SellingPartnerId;
        
        /// <remarks/>
        public string ExternalReferenceId;
        
        /// <remarks/>
        public System.DateTime PostingDate;
        
        /// <remarks/>
        public string ClientAddress;
        
        /// <remarks/>
        public int CampaignId;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class Property
    {

        private string namespaceField;

        private string nameField;

        private string valueField;

        /// <remarks/>
        public string Namespace
        {
            get
            {
                return this.namespaceField;
            }
            set
            {
                this.namespaceField = value;
            }
        }

        /// <remarks/>
        public string Name
        {
            get
            {
                return this.nameField;
            }
            set
            {
                this.nameField = value;
            }
        }

        /// <remarks/>
        public string Value
        {
            get
            {
                return this.valueField;
            }
            set
            {
                this.valueField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.1432")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/DMP/2004/09/API")]
    public partial class TransferTransactionContext
    {

        private System.Guid tenantIdField;

        private string externalReferenceIdField;

        private System.DateTime postingDateField;

        private int campaignIdField;

        private bool riskCheckFlagField;

        private string reasonCodeField;

        private bool emailFlagField;

        private Property[] propertyBagField;

        /// <remarks/>
        public System.Guid TenantId
        {
            get
            {
                return this.tenantIdField;
            }
            set
            {
                this.tenantIdField = value;
            }
        }

        /// <remarks/>
        public string ExternalReferenceId
        {
            get
            {
                return this.externalReferenceIdField;
            }
            set
            {
                this.externalReferenceIdField = value;
            }
        }

        /// <remarks/>
        public System.DateTime PostingDate
        {
            get
            {
                return this.postingDateField;
            }
            set
            {
                this.postingDateField = value;
            }
        }

        /// <remarks/>
        public int CampaignId
        {
            get
            {
                return this.campaignIdField;
            }
            set
            {
                this.campaignIdField = value;
            }
        }

        /// <remarks/>
        public bool RiskCheckFlag
        {
            get
            {
                return this.riskCheckFlagField;
            }
            set
            {
                this.riskCheckFlagField = value;
            }
        }

        /// <remarks/>
        public string ReasonCode
        {
            get
            {
                return this.reasonCodeField;
            }
            set
            {
                this.reasonCodeField = value;
            }
        }

        /// <remarks/>
        public bool EmailFlag
        {
            get
            {
                return this.emailFlagField;
            }
            set
            {
                this.emailFlagField = value;
            }
        }

        /// <remarks/>
        public Property[] PropertyBag
        {
            get
            {
                return this.propertyBagField;
            }
            set
            {
                this.propertyBagField = value;
            }
        }
    }


    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/DMP/2004/09/API")]
    public enum Status {
        
        /// <remarks/>
        Active,
        
        /// <remarks/>
        Disabled,
        
        /// <remarks/>
        Closed,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\finbus\FinBusSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4952
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/MessageInfo/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemption/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemption")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrder/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrder")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.Contract.V1.Data/Priority/", ClrNamespace="microsoft.edis.ieb.messaging.contract.v1.data.Priority")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.Contract.V1.Data/MessageType/", ClrNamespace="microsoft.edis.ieb.messaging.contract.v1.data.MessageType")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemptionHeader/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionHeader")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemptionLineItem/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItem")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemptionLineItemSubLin" +
    "eItem/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItemSubLineItem")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderHeader/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeader")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderLineItem/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItem")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderHeaderOBO/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderOBO")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderHeaderProperty/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderProperty")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderLineItemSubLineI" +
    "tem/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemSubLineItem")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderLineItemToken/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemToken")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/MessageInfoResponse/", ClrNamespace="microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse")]

namespace microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MessageInfo", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/MessageInfo/")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemption.TokenRedemption))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrder.PurchaseOrder))]
    public partial class MessageInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime MessageDateField;
        
        private System.Guid MessageIdField;
        
        private microsoft.edis.ieb.messaging.contract.v1.data.Priority.Priority MessagePriorityField;
        
        private microsoft.edis.ieb.messaging.contract.v1.data.MessageType.MessageType MessageTypeField;
        
        private string PartnerIdField;

        // check PartnerId, MessageType and MessagePriority only
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
                return false;

            MessageInfo objMessageInfo = (MessageInfo)obj;

            if (MessagePriority != objMessageInfo.MessagePriority)
                return false;

            if (MessageType != objMessageInfo.MessageType)
                return false;

            if (PartnerId != objMessageInfo.PartnerId)
                return false;

            return true;
        }

        public override int GetHashCode()
        {
            return MessageDate.GetHashCode() ^ MessageId.GetHashCode();
        }

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime MessageDate
        {
            get
            {
                return this.MessageDateField;
            }
            set
            {
                this.MessageDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid MessageId
        {
            get
            {
                return this.MessageIdField;
            }
            set
            {
                this.MessageIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.contract.v1.data.Priority.Priority MessagePriority
        {
            get
            {
                return this.MessagePriorityField;
            }
            set
            {
                this.MessagePriorityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.contract.v1.data.MessageType.MessageType MessageType
        {
            get
            {
                return this.MessageTypeField;
            }
            set
            {
                this.MessageTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PartnerId
        {
            get
            {
                return this.PartnerIdField;
            }
            set
            {
                this.PartnerIdField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemption
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenRedemption", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemption/")]
    public partial class TokenRedemption : microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo
    {
        
        private microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionHeader.TokenRedemptionHeader HeaderField;
        
        private microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItem.TokenRedemptionLineItem[] LineItemsField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionHeader.TokenRedemptionHeader Header
        {
            get
            {
                return this.HeaderField;
            }
            set
            {
                this.HeaderField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItem.TokenRedemptionLineItem[] LineItems
        {
            get
            {
                return this.LineItemsField;
            }
            set
            {
                this.LineItemsField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrder
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOrder", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrder/")]
    public partial class PurchaseOrder : microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo
    {
        
        private microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeader.PurchaseOrderHeader HeaderField;
        
        private microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItem.PurchaseOrderLineItem[] LineItemsField;

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return Header.GetHashCode();
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeader.PurchaseOrderHeader Header
        {
            get
            {
                return this.HeaderField;
            }
            set
            {
                this.HeaderField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItem.PurchaseOrderLineItem[] LineItems
        {
            get
            {
                return this.LineItemsField;
            }
            set
            {
                this.LineItemsField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.contract.v1.data.Priority
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="Priority", Namespace="http://Microsoft.EDIS.IEB.Messaging.Contract.V1.Data/Priority/")]
    public enum Priority : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        High = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Medium = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Low = 3,
    }
}
namespace microsoft.edis.ieb.messaging.contract.v1.data.MessageType
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MessageType", Namespace="http://Microsoft.EDIS.IEB.Messaging.Contract.V1.Data/MessageType/")]
    public enum MessageType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        MasterData = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        TransactionData = 2,
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionHeader
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenRedemptionHeader", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemptionHeader/")]
    public partial class TokenRedemptionHeader : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int ChannelTypeIdField;
        
        private string IPAddressField;
        
        private string MachineIdField;
        
        private string MemberCountryCodeField;
        
        private string MemberIdField;
        
        private int MemberSubscriptionTierIdField;
        
        private bool MemberSubscriptionTierIdSpecifiedField;
        
        private string RedemptionTransactionIdField;
        
        private string StoreFrontIdField;
        
        private System.DateTime TransactionDateTimeField;
        
        private int TransactionSourceIdField;
        
        private string TransmissionIdField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ChannelTypeId
        {
            get
            {
                return this.ChannelTypeIdField;
            }
            set
            {
                this.ChannelTypeIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string IPAddress
        {
            get
            {
                return this.IPAddressField;
            }
            set
            {
                this.IPAddressField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MachineId
        {
            get
            {
                return this.MachineIdField;
            }
            set
            {
                this.MachineIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MemberCountryCode
        {
            get
            {
                return this.MemberCountryCodeField;
            }
            set
            {
                this.MemberCountryCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MemberId
        {
            get
            {
                return this.MemberIdField;
            }
            set
            {
                this.MemberIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int MemberSubscriptionTierId
        {
            get
            {
                return this.MemberSubscriptionTierIdField;
            }
            set
            {
                this.MemberSubscriptionTierIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool MemberSubscriptionTierIdSpecified
        {
            get
            {
                return this.MemberSubscriptionTierIdSpecifiedField;
            }
            set
            {
                this.MemberSubscriptionTierIdSpecifiedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RedemptionTransactionId
        {
            get
            {
                return this.RedemptionTransactionIdField;
            }
            set
            {
                this.RedemptionTransactionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StoreFrontId
        {
            get
            {
                return this.StoreFrontIdField;
            }
            set
            {
                this.StoreFrontIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TransactionDateTime
        {
            get
            {
                return this.TransactionDateTimeField;
            }
            set
            {
                this.TransactionDateTimeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int TransactionSourceId
        {
            get
            {
                return this.TransactionSourceIdField;
            }
            set
            {
                this.TransactionSourceIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TransmissionId
        {
            get
            {
                return this.TransmissionIdField;
            }
            set
            {
                this.TransmissionIdField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItem
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenRedemptionLineItem", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemptionLineItem/")]
    public partial class TokenRedemptionLineItem : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ChannelSKUField;
        
        private int LineItemIdField;
        
        private string OfferInstanceIdField;
        
        private string ProductIdField;
        
        private long PurchasingTitleIdField;
        
        private int QuantityField;
        
        private microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItemSubLineItem.TokenRedemptionLineItemSubLineItem[] SubLineItemsField;
        
        private string TokenHashField;
        
        private int TokenTypeIdField;
        
        private string UnitOfMeasureField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ChannelSKU
        {
            get
            {
                return this.ChannelSKUField;
            }
            set
            {
                this.ChannelSKUField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int LineItemId
        {
            get
            {
                return this.LineItemIdField;
            }
            set
            {
                this.LineItemIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string OfferInstanceId
        {
            get
            {
                return this.OfferInstanceIdField;
            }
            set
            {
                this.OfferInstanceIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductId
        {
            get
            {
                return this.ProductIdField;
            }
            set
            {
                this.ProductIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public long PurchasingTitleId
        {
            get
            {
                return this.PurchasingTitleIdField;
            }
            set
            {
                this.PurchasingTitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int Quantity
        {
            get
            {
                return this.QuantityField;
            }
            set
            {
                this.QuantityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItemSubLineItem.TokenRedemptionLineItemSubLineItem[] SubLineItems
        {
            get
            {
                return this.SubLineItemsField;
            }
            set
            {
                this.SubLineItemsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenHash
        {
            get
            {
                return this.TokenHashField;
            }
            set
            {
                this.TokenHashField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int TokenTypeId
        {
            get
            {
                return this.TokenTypeIdField;
            }
            set
            {
                this.TokenTypeIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string UnitOfMeasure
        {
            get
            {
                return this.UnitOfMeasureField;
            }
            set
            {
                this.UnitOfMeasureField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.TokenRedemptionLineItemSubLineItem
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenRedemptionLineItemSubLineItem", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/TokenRedemptionLineItemSubLin" +
        "eItem/")]
    public partial class TokenRedemptionLineItemSubLineItem : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ProductIdField;
        
        private decimal RevenueAllocationPercentageField;
        
        private string RevenueSKUField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductId
        {
            get
            {
                return this.ProductIdField;
            }
            set
            {
                this.ProductIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal RevenueAllocationPercentage
        {
            get
            {
                return this.RevenueAllocationPercentageField;
            }
            set
            {
                this.RevenueAllocationPercentageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RevenueSKU
        {
            get
            {
                return this.RevenueSKUField;
            }
            set
            {
                this.RevenueSKUField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeader
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOrderHeader", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderHeader/")]
    public partial class PurchaseOrderHeader : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int ChannelTypeIdField;
        
        private string CustomerReferenceNumberField;
        
        private string IPAddressField;
        
        private bool IsBulkTokenUploadField;
        
        private string MachineIdField;
        
        private string MemberCountryCodeField;
        
        private string MemberIdField;
        
        private int MemberSubscriptionTierIdField;
        
        private bool MemberSubscriptionTierIdSpecifiedField;
        
        private microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderOBO.PurchaseOrderHeaderOBO OBOField;
        
        private microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderProperty.PurchaseOrderHeaderProperty[] PropertyBagField;
        
        private string PurchaseTransactionIdField;
        
        private string SoldToCountryField;
        
        private string SoldToCustomerNumberField;
        
        private string StoreFrontIdField;
        
        private System.DateTime TransactionDateTimeField;
        
        private int TransactionSourceIdField;
        
        private string TransmissionIdField;
        
        private string XNACreatorIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ChannelTypeId
        {
            get
            {
                return this.ChannelTypeIdField;
            }
            set
            {
                this.ChannelTypeIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string CustomerReferenceNumber
        {
            get
            {
                return this.CustomerReferenceNumberField;
            }
            set
            {
                this.CustomerReferenceNumberField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string IPAddress
        {
            get
            {
                return this.IPAddressField;
            }
            set
            {
                this.IPAddressField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsBulkTokenUpload
        {
            get
            {
                return this.IsBulkTokenUploadField;
            }
            set
            {
                this.IsBulkTokenUploadField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MachineId
        {
            get
            {
                return this.MachineIdField;
            }
            set
            {
                this.MachineIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MemberCountryCode
        {
            get
            {
                return this.MemberCountryCodeField;
            }
            set
            {
                this.MemberCountryCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MemberId
        {
            get
            {
                return this.MemberIdField;
            }
            set
            {
                this.MemberIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int MemberSubscriptionTierId
        {
            get
            {
                return this.MemberSubscriptionTierIdField;
            }
            set
            {
                this.MemberSubscriptionTierIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool MemberSubscriptionTierIdSpecified
        {
            get
            {
                return this.MemberSubscriptionTierIdSpecifiedField;
            }
            set
            {
                this.MemberSubscriptionTierIdSpecifiedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderOBO.PurchaseOrderHeaderOBO OBO
        {
            get
            {
                return this.OBOField;
            }
            set
            {
                this.OBOField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderProperty.PurchaseOrderHeaderProperty[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PurchaseTransactionId
        {
            get
            {
                return this.PurchaseTransactionIdField;
            }
            set
            {
                this.PurchaseTransactionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SoldToCountry
        {
            get
            {
                return this.SoldToCountryField;
            }
            set
            {
                this.SoldToCountryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SoldToCustomerNumber
        {
            get
            {
                return this.SoldToCustomerNumberField;
            }
            set
            {
                this.SoldToCustomerNumberField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StoreFrontId
        {
            get
            {
                return this.StoreFrontIdField;
            }
            set
            {
                this.StoreFrontIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TransactionDateTime
        {
            get
            {
                return this.TransactionDateTimeField;
            }
            set
            {
                this.TransactionDateTimeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int TransactionSourceId
        {
            get
            {
                return this.TransactionSourceIdField;
            }
            set
            {
                this.TransactionSourceIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TransmissionId
        {
            get
            {
                return this.TransmissionIdField;
            }
            set
            {
                this.TransmissionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string XNACreatorId
        {
            get
            {
                return this.XNACreatorIdField;
            }
            set
            {
                this.XNACreatorIdField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItem
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOrderLineItem", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderLineItem/")]
    public partial class PurchaseOrderLineItem : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private decimal BilledUnitPriceExcludingTaxField;
        
        private string ChannelSKUField;
        
        private string CurrencyCodeField;
        
        private int CustomerReferenceLineItemField;
        
        private decimal FeeAmountField;
        
        private bool FeeAmountSpecifiedField;
        
        private int LineItemIdField;
        
        private string OfferInstanceIdField;
        
        private int PaymentMethodIdField;
        
        private decimal PointsDiscountAmountField;
        
        private int PointsUsedQuantityField;
        
        private decimal PriceDiscountAmountField;
        
        private int PriceTypeField;
        
        private bool PriceTypeSpecifiedField;
        
        private string ProductIdField;
        
        private string ProductNameField;
        
        private string PromotionField;
        
        private long PurchasingTitleIdField;
        
        private int QuantityField;
        
        private microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemSubLineItem.PurchaseOrderLineItemSubLineItem[] SubLineItemsField;
        
        private decimal SuggestedRetailPriceCurrencyField;
        
        private int SuggestedRetailPricePointsQuantityField;
        
        private decimal TaxAmountField;
        
        private microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemToken.PurchaseOrderLineItemToken[] TokensField;
        
        private string UnitOfMeasureField;
        
        private decimal WholesalePriceCurrencyField;
        
        private int WholesalePricePointsQuantityField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal BilledUnitPriceExcludingTax
        {
            get
            {
                return this.BilledUnitPriceExcludingTaxField;
            }
            set
            {
                this.BilledUnitPriceExcludingTaxField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ChannelSKU
        {
            get
            {
                return this.ChannelSKUField;
            }
            set
            {
                this.ChannelSKUField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string CurrencyCode
        {
            get
            {
                return this.CurrencyCodeField;
            }
            set
            {
                this.CurrencyCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int CustomerReferenceLineItem
        {
            get
            {
                return this.CustomerReferenceLineItemField;
            }
            set
            {
                this.CustomerReferenceLineItemField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal FeeAmount
        {
            get
            {
                return this.FeeAmountField;
            }
            set
            {
                this.FeeAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool FeeAmountSpecified
        {
            get
            {
                return this.FeeAmountSpecifiedField;
            }
            set
            {
                this.FeeAmountSpecifiedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int LineItemId
        {
            get
            {
                return this.LineItemIdField;
            }
            set
            {
                this.LineItemIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string OfferInstanceId
        {
            get
            {
                return this.OfferInstanceIdField;
            }
            set
            {
                this.OfferInstanceIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int PaymentMethodId
        {
            get
            {
                return this.PaymentMethodIdField;
            }
            set
            {
                this.PaymentMethodIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal PointsDiscountAmount
        {
            get
            {
                return this.PointsDiscountAmountField;
            }
            set
            {
                this.PointsDiscountAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int PointsUsedQuantity
        {
            get
            {
                return this.PointsUsedQuantityField;
            }
            set
            {
                this.PointsUsedQuantityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal PriceDiscountAmount
        {
            get
            {
                return this.PriceDiscountAmountField;
            }
            set
            {
                this.PriceDiscountAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int PriceType
        {
            get
            {
                return this.PriceTypeField;
            }
            set
            {
                this.PriceTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool PriceTypeSpecified
        {
            get
            {
                return this.PriceTypeSpecifiedField;
            }
            set
            {
                this.PriceTypeSpecifiedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductId
        {
            get
            {
                return this.ProductIdField;
            }
            set
            {
                this.ProductIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductName
        {
            get
            {
                return this.ProductNameField;
            }
            set
            {
                this.ProductNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Promotion
        {
            get
            {
                return this.PromotionField;
            }
            set
            {
                this.PromotionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public long PurchasingTitleId
        {
            get
            {
                return this.PurchasingTitleIdField;
            }
            set
            {
                this.PurchasingTitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int Quantity
        {
            get
            {
                return this.QuantityField;
            }
            set
            {
                this.QuantityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemSubLineItem.PurchaseOrderLineItemSubLineItem[] SubLineItems
        {
            get
            {
                return this.SubLineItemsField;
            }
            set
            {
                this.SubLineItemsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal SuggestedRetailPriceCurrency
        {
            get
            {
                return this.SuggestedRetailPriceCurrencyField;
            }
            set
            {
                this.SuggestedRetailPriceCurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int SuggestedRetailPricePointsQuantity
        {
            get
            {
                return this.SuggestedRetailPricePointsQuantityField;
            }
            set
            {
                this.SuggestedRetailPricePointsQuantityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TaxAmount
        {
            get
            {
                return this.TaxAmountField;
            }
            set
            {
                this.TaxAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemToken.PurchaseOrderLineItemToken[] Tokens
        {
            get
            {
                return this.TokensField;
            }
            set
            {
                this.TokensField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string UnitOfMeasure
        {
            get
            {
                return this.UnitOfMeasureField;
            }
            set
            {
                this.UnitOfMeasureField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal WholesalePriceCurrency
        {
            get
            {
                return this.WholesalePriceCurrencyField;
            }
            set
            {
                this.WholesalePriceCurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int WholesalePricePointsQuantity
        {
            get
            {
                return this.WholesalePricePointsQuantityField;
            }
            set
            {
                this.WholesalePricePointsQuantityField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderOBO
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOrderHeaderOBO", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderHeaderOBO/")]
    public partial class PurchaseOrderHeaderOBO : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string OBOAliasField;
        
        private string OBOCompanyField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string OBOAlias
        {
            get
            {
                return this.OBOAliasField;
            }
            set
            {
                this.OBOAliasField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string OBOCompany
        {
            get
            {
                return this.OBOCompanyField;
            }
            set
            {
                this.OBOCompanyField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderHeaderProperty
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOrderHeaderProperty", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderHeaderProperty/")]
    public partial class PurchaseOrderHeaderProperty : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string NameField;
        
        private string ValueField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                this.ValueField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemSubLineItem
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOrderLineItemSubLineItem", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderLineItemSubLineI" +
        "tem/")]
    public partial class PurchaseOrderLineItemSubLineItem : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ProductIdField;
        
        private decimal RevenueAllocationPercentageField;
        
        private string RevenueSKUField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductId
        {
            get
            {
                return this.ProductIdField;
            }
            set
            {
                this.ProductIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal RevenueAllocationPercentage
        {
            get
            {
                return this.RevenueAllocationPercentageField;
            }
            set
            {
                this.RevenueAllocationPercentageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RevenueSKU
        {
            get
            {
                return this.RevenueSKUField;
            }
            set
            {
                this.RevenueSKUField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.PurchaseOrderLineItemToken
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOrderLineItemToken", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/PurchaseOrderLineItemToken/")]
    public partial class PurchaseOrderLineItemToken : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string TokenHashField;
        
        private int TokenTypeIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenHash
        {
            get
            {
                return this.TokenHashField;
            }
            set
            {
                this.TokenHashField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int TokenTypeId
        {
            get
            {
                return this.TokenTypeIdField;
            }
            set
            {
                this.TokenTypeIdField = value;
            }
        }
    }
}
namespace microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MessageInfoResponse", Namespace="http://Microsoft.EDIS.IEB.Messaging.DataContract.V1/MessageInfoResponse/")]
    public partial class MessageInfoResponse : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime MessageDateField;
        
        private System.Guid MessageIdField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime MessageDate
        {
            get
            {
                return this.MessageDateField;
            }
            set
            {
                this.MessageDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid MessageId
        {
            get
            {
                return this.MessageIdField;
            }
            set
            {
                this.MessageIdField = value;
            }
        }
    }
}
namespace Microsoft.EDIS.IEB.Messaging.Contract.V1.Data
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="FaultDetails", Namespace="http://schemas.datacontract.org/2004/07/Microsoft.EDIS.IEB.Messaging.Contract.V1." +
        "Data")]
    public partial class FaultDetails : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        [System.NonSerialized()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string DetailMessageField;
        
        private int ErrorCodeField;
        
        private string FriendlyMessageField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string DetailMessage
        {
            get
            {
                return this.DetailMessageField;
            }
            set
            {
                this.DetailMessageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ErrorCode
        {
            get
            {
                return this.ErrorCodeField;
            }
            set
            {
                this.ErrorCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string FriendlyMessage
        {
            get
            {
                return this.FriendlyMessageField;
            }
            set
            {
                this.FriendlyMessageField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(ConfigurationName="IInjectionService")]
public interface IInjectionService
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IInjectionService/PublishMessage", ReplyAction="http://tempuri.org/IInjectionService/PublishMessageResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.EDIS.IEB.Messaging.Contract.V1.Data.FaultDetails), Action="http://tempuri.org/IInjectionService/PublishMessageFaultDetailsFault", Name="FaultDetails", Namespace="http://schemas.datacontract.org/2004/07/Microsoft.EDIS.IEB.Messaging.Contract.V1." +
        "Data")]
    microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse PublishMessage(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message);
    
    [System.ServiceModel.OperationContractAttribute(AsyncPattern=true, Action="http://tempuri.org/IInjectionService/PublishMessage", ReplyAction="http://tempuri.org/IInjectionService/PublishMessageResponse")]
    System.IAsyncResult BeginPublishMessage(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message, System.AsyncCallback callback, object asyncState);
    
    microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse EndPublishMessage(System.IAsyncResult result);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IInjectionService/IsServiceAlive", ReplyAction="http://tempuri.org/IInjectionService/IsServiceAliveResponse")]
    string IsServiceAlive(string message);
    
    [System.ServiceModel.OperationContractAttribute(AsyncPattern=true, Action="http://tempuri.org/IInjectionService/IsServiceAlive", ReplyAction="http://tempuri.org/IInjectionService/IsServiceAliveResponse")]
    System.IAsyncResult BeginIsServiceAlive(string message, System.AsyncCallback callback, object asyncState);
    
    string EndIsServiceAlive(System.IAsyncResult result);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface IInjectionServiceChannel : IInjectionService, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class PublishMessageCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
{
    
    private object[] results;
    
    public PublishMessageCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState)
    {
        this.results = results;
    }
    
    public microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse Result
    {
        get
        {
            base.RaiseExceptionIfNecessary();
            return ((microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse)(this.results[0]));
        }
    }
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class IsServiceAliveCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
{
    
    private object[] results;
    
    public IsServiceAliveCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
            base(exception, cancelled, userState)
    {
        this.results = results;
    }
    
    public string Result
    {
        get
        {
            base.RaiseExceptionIfNecessary();
            return ((string)(this.results[0]));
        }
    }
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class InjectionServiceClient : System.ServiceModel.ClientBase<IInjectionService>, IInjectionService
{
    
    private BeginOperationDelegate onBeginPublishMessageDelegate;
    
    private EndOperationDelegate onEndPublishMessageDelegate;
    
    private System.Threading.SendOrPostCallback onPublishMessageCompletedDelegate;
    
    private BeginOperationDelegate onBeginIsServiceAliveDelegate;
    
    private EndOperationDelegate onEndIsServiceAliveDelegate;
    
    private System.Threading.SendOrPostCallback onIsServiceAliveCompletedDelegate;
    
    public InjectionServiceClient()
    {
    }
    
    public InjectionServiceClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public InjectionServiceClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public InjectionServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public InjectionServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public event System.EventHandler<PublishMessageCompletedEventArgs> PublishMessageCompleted;
    
    public event System.EventHandler<IsServiceAliveCompletedEventArgs> IsServiceAliveCompleted;
    
    public microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse PublishMessage(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message)
    {
        return base.Channel.PublishMessage(message);
    }
    
    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
    public System.IAsyncResult BeginPublishMessage(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message, System.AsyncCallback callback, object asyncState)
    {
        return base.Channel.BeginPublishMessage(message, callback, asyncState);
    }
    
    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
    public microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse EndPublishMessage(System.IAsyncResult result)
    {
        return base.Channel.EndPublishMessage(result);
    }
    
    private System.IAsyncResult OnBeginPublishMessage(object[] inValues, System.AsyncCallback callback, object asyncState)
    {
        microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message = ((microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo)(inValues[0]));
        return this.BeginPublishMessage(message, callback, asyncState);
    }
    
    private object[] OnEndPublishMessage(System.IAsyncResult result)
    {
        microsoft.edis.ieb.messaging.datacontract.v1.MessageInfoResponse.MessageInfoResponse retVal = this.EndPublishMessage(result);
        return new object[] {
                retVal};
    }
    
    private void OnPublishMessageCompleted(object state)
    {
        if ((this.PublishMessageCompleted != null))
        {
            InvokeAsyncCompletedEventArgs e = ((InvokeAsyncCompletedEventArgs)(state));
            this.PublishMessageCompleted(this, new PublishMessageCompletedEventArgs(e.Results, e.Error, e.Cancelled, e.UserState));
        }
    }
    
    public void PublishMessageAsync(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message)
    {
        this.PublishMessageAsync(message, null);
    }
    
    public void PublishMessageAsync(microsoft.edis.ieb.messaging.datacontract.v1.MessageInfo.MessageInfo message, object userState)
    {
        if ((this.onBeginPublishMessageDelegate == null))
        {
            this.onBeginPublishMessageDelegate = new BeginOperationDelegate(this.OnBeginPublishMessage);
        }
        if ((this.onEndPublishMessageDelegate == null))
        {
            this.onEndPublishMessageDelegate = new EndOperationDelegate(this.OnEndPublishMessage);
        }
        if ((this.onPublishMessageCompletedDelegate == null))
        {
            this.onPublishMessageCompletedDelegate = new System.Threading.SendOrPostCallback(this.OnPublishMessageCompleted);
        }
        base.InvokeAsync(this.onBeginPublishMessageDelegate, new object[] {
                    message}, this.onEndPublishMessageDelegate, this.onPublishMessageCompletedDelegate, userState);
    }
    
    public string IsServiceAlive(string message)
    {
        return base.Channel.IsServiceAlive(message);
    }
    
    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
    public System.IAsyncResult BeginIsServiceAlive(string message, System.AsyncCallback callback, object asyncState)
    {
        return base.Channel.BeginIsServiceAlive(message, callback, asyncState);
    }
    
    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
    public string EndIsServiceAlive(System.IAsyncResult result)
    {
        return base.Channel.EndIsServiceAlive(result);
    }
    
    private System.IAsyncResult OnBeginIsServiceAlive(object[] inValues, System.AsyncCallback callback, object asyncState)
    {
        string message = ((string)(inValues[0]));
        return this.BeginIsServiceAlive(message, callback, asyncState);
    }
    
    private object[] OnEndIsServiceAlive(System.IAsyncResult result)
    {
        string retVal = this.EndIsServiceAlive(result);
        return new object[] {
                retVal};
    }
    
    private void OnIsServiceAliveCompleted(object state)
    {
        if ((this.IsServiceAliveCompleted != null))
        {
            InvokeAsyncCompletedEventArgs e = ((InvokeAsyncCompletedEventArgs)(state));
            this.IsServiceAliveCompleted(this, new IsServiceAliveCompletedEventArgs(e.Results, e.Error, e.Cancelled, e.UserState));
        }
    }
    
    public void IsServiceAliveAsync(string message)
    {
        this.IsServiceAliveAsync(message, null);
    }
    
    public void IsServiceAliveAsync(string message, object userState)
    {
        if ((this.onBeginIsServiceAliveDelegate == null))
        {
            this.onBeginIsServiceAliveDelegate = new BeginOperationDelegate(this.OnBeginIsServiceAlive);
        }
        if ((this.onEndIsServiceAliveDelegate == null))
        {
            this.onEndIsServiceAliveDelegate = new EndOperationDelegate(this.OnEndIsServiceAlive);
        }
        if ((this.onIsServiceAliveCompletedDelegate == null))
        {
            this.onIsServiceAliveCompletedDelegate = new System.Threading.SendOrPostCallback(this.OnIsServiceAliveCompleted);
        }
        base.InvokeAsync(this.onBeginIsServiceAliveDelegate, new object[] {
                    message}, this.onEndIsServiceAliveDelegate, this.onIsServiceAliveCompletedDelegate, userState);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\EmulationProxy.cs ===
namespace  Microsoft.XBox.Live.Server.Emulators.Framework 
{
    using System;
    using System.Web;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting.Services;
    using System.Security.Permissions;

    public class EmulationProxy: RealProxy 
    {
        private MarshalByRefObject target;
        private readonly string masterPrefix;
        private readonly string recordingPrefix;

        public EmulationProxy(MarshalByRefObject target, Type targetType)
            : base(targetType) 
        {
            this.target = target;
            masterPrefix = "master_";
            recordingPrefix  = "recording_";
        }

        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
        public override IMessage Invoke(IMessage msg) 
        {
            IConstructionCallMessage ctor = msg as IConstructionCallMessage;
            if (ctor != null) 
            {
                RealProxy defaultProxy = RemotingServices.GetRealProxy(target);
                defaultProxy.InitializeServerObject(ctor);
                MarshalByRefObject tp = (MarshalByRefObject)this.GetTransparentProxy();
                return EnterpriseServicesHelper.CreateConstructionReturnMessage(ctor, tp);
            }
            else 
            {
                IMethodCallMessage call = (IMethodCallMessage)msg;
                string guid = HttpContext.Current.Request.QueryString["guid"];

                if (String.IsNullOrEmpty(guid)) 
                {
                    return RemotingServices.ExecuteMessage(target, call);
                } 
                else 
                {
                    Recording master = ObtainMaster(guid);
                    Recording recording = ObtainRecording(guid);
                    return master.VerifyAndRecord(call, recording);
                    
                }
                
            }
            
        }

        private Recording ObtainMaster(string guid) 
        {
            Recording result = (Recording)HttpContext.Current.Application[masterPrefix + guid.ToString()];
            if (result == null) 
            {
                throw new ArgumentOutOfRangeException("guid", guid, "Master recording for this guid is not found in the application state.");
            }
            return result;
        }
        
        private Recording ObtainRecording(string guid) 
        {
            Recording result = (Recording)HttpContext.Current.Application[recordingPrefix + guid.ToString()];
            return result;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\ExpectationException.cs ===
namespace  Microsoft.XBox.Live.Server.Emulators.Framework 
{
    using System;
    
    public class ExpectationException: Exception 
    {
        public ExpectationException(string message):base(message) 
        {
        }
        
        public ExpectationException(string message, Exception innerException):base(message, innerException)
        {
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\IConstraint.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    public interface IConstraint 
    {
        bool Verify(object got, out string errorMessage);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\EmulatorFacadeBase.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Collections.Generic;
    using Microsoft.XBox.Live.Server.Emulators.Client;
    
    public abstract class EmulatorFacadeBase<T> where T:class
    {
        private Controller controller = new Controller();
        
        public T StartRecording () 
        {
            return Recorder.StartRecording<T>();
        }
        
        public void StopRecording(object mock) 
        {
            Recording r = Recorder.StopRecording(mock);
            Guid guid = controller.AddCallSequence(r.ToBase64String());
            Recorder.SetRecordingGuid(mock, guid);
        }
        
        protected abstract string HandlerName 
        {
            get;
        }
        

        public string GetUrl(object mock) 
        {
            Guid guid = Recorder.GetRecordingGuid(mock);
            return "http://"+ System.Net.Dns.GetHostName() +"/MusicNetEmulator/"+this.HandlerName+"?guid="+guid.ToString();
        }
        
        public void Verify(object mock) 
        {
            Guid guid = Recorder.GetRecordingGuid(mock);
            
            string encodedRecording = controller.GetCallRecord(guid);
            MemoryStream ms = new MemoryStream(Convert.FromBase64String(encodedRecording));
            BinaryFormatter bf = new BinaryFormatter();
            Recording record = (Recording)bf.Deserialize(ms);

            Recording master = Recorder.GetRecording(mock);
            master.Compare(record);
            
        }
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\IgnoreConstraint.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    
    [Serializable]
    public class IgnoreConstraint: IConstraint 
    {
        public bool Verify(object got, out string errorMessage) 
        {
            errorMessage = String.Empty;
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\IMethodCallOptions.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    
    public interface IMethodCallOptions
    {
        IMethodCallOptions Returns(object returnValue);
        IMethodCallOptions Throws(Exception exception);
        IMethodCallOptions Argument(int argIndex, IConstraint constraint);
        IMethodCallOptions Arguments(params IConstraint[] constraints);
        IMethodCallOptions IgnoresArgument(int argIndex);
        IMethodCallOptions OutArguments(params object[] outArgs);
        IMethodCallOptions ClosesConnection();
        IMethodCallOptions Waits(TimeSpan timeout);
        IMethodCallOptions ExpectedAnytime();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\EqualConstraint.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    
    [Serializable]
    public class EqualConstraint: IConstraint
    {
        private object expected;
        public EqualConstraint(object expected) 
        {
            this.expected = expected;
        }
        
        public bool Verify(object got, out string errorMessage) 
        {
            errorMessage = String.Empty;
            if(object.Equals(expected, got)) 
            {
                return true;
            }
            else 
            {
                errorMessage = String.Format("Expected {0} but got {1} instead", expected, got);
                return false;
            }
            
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\CTPTransactionService\TransactionServiceSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>   [System.SerializableAttribute()]
//------------------------------------------------------------------------------

using System.ServiceModel;
using System.Runtime.Serialization;
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01", ClrNamespace = "Microsoft.XBox.Live.Server.Emulators.TransactionService")]

namespace Microsoft.XBox.Live.Server.Emulators.TransactionService
{
    using System.Runtime.Serialization;

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "AbstractRequest", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderStatusInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderEventUpdateInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseInput))]
    public partial class AbstractRequest : object
    {

        


    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractRequest
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingInfo BillingInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutContext PayoutContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderInput PayoutOrderInputField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Partner PayoutPartnerField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingInfo BillingInfo
        {
            get
            {
                return this.BillingInfoField;
            }
            set
            {
                this.BillingInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutContext PayoutContext
        {
            get
            {
                return this.PayoutContextField;
            }
            set
            {
                this.PayoutContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderInput PayoutOrderInput
        {
            get
            {
                return this.PayoutOrderInputField;
            }
            set
            {
                this.PayoutOrderInputField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Partner PayoutPartner
        {
            get
            {
                return this.PayoutPartnerField;
            }
            set
            {
                this.PayoutPartnerField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "JoinSubscriptionInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractRequest
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubsContext JoinSubsContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionInfoInput JoinSubscriptionInfoInputField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubsContext JoinSubsContext
        {
            get
            {
                return this.JoinSubsContextField;
            }
            set
            {
                this.JoinSubsContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionInfoInput JoinSubscriptionInfoInput
        {
            get
            {
                return this.JoinSubscriptionInfoInputField;
            }
            set
            {
                this.JoinSubscriptionInfoInputField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateAccountInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractRequest
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountContext MigrateAccountContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountInfoInput MigrateAccountInfoInputField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountContext MigrateAccountContext
        {
            get
            {
                return this.MigrateAccountContextField;
            }
            set
            {
                this.MigrateAccountContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountInfoInput MigrateAccountInfoInput
        {
            get
            {
                return this.MigrateAccountInfoInputField;
            }
            set
            {
                this.MigrateAccountInfoInputField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "GetPayoutOrderStatusInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderStatusInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractRequest
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Filter FilterField;

        private int NumRecordsRequestedField;

        private string StartHandlerField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Filter Filter
        {
            get
            {
                return this.FilterField;
            }
            set
            {
                this.FilterField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int NumRecordsRequested
        {
            get
            {
                return this.NumRecordsRequestedField;
            }
            set
            {
                this.NumRecordsRequestedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StartHandler
        {
            get
            {
                return this.StartHandlerField;
            }
            set
            {
                this.StartHandlerField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "GetPayoutOrderEventUpdateInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderEventUpdateInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractRequest
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Filter FilterField;

        private int NumRecordsRequestedField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Partner PayoutPartnerField;

        private string StartHandlerField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Filter Filter
        {
            get
            {
                return this.FilterField;
            }
            set
            {
                this.FilterField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int NumRecordsRequested
        {
            get
            {
                return this.NumRecordsRequestedField;
            }
            set
            {
                this.NumRecordsRequestedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Partner PayoutPartner
        {
            get
            {
                return this.PayoutPartnerField;
            }
            set
            {
                this.PayoutPartnerField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StartHandler
        {
            get
            {
                return this.StartHandlerField;
            }
            set
            {
                this.StartHandlerField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractRequest
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingInfo BillingInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Marketplace MarketplaceField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseContext PurchaseContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseInfoInput PurchaseInfoInputField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingInfo BillingInfo
        {
            get
            {
                return this.BillingInfoField;
            }
            set
            {
                this.BillingInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Marketplace Marketplace
        {
            get
            {
                return this.MarketplaceField;
            }
            set
            {
                this.MarketplaceField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseContext PurchaseContext
        {
            get
            {
                return this.PurchaseContextField;
            }
            set
            {
                this.PurchaseContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseInfoInput PurchaseInfoInput
        {
            get
            {
                return this.PurchaseInfoInputField;
            }
            set
            {
                this.PurchaseInfoInputField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "APIContext", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class APIContext : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private System.Guid TrackingGuidField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TrackingGuid
        {
            get
            {
                return this.TrackingGuidField;
            }
            set
            {
                this.TrackingGuidField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "BillingInfo", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class BillingInfo : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingMode BillingModeField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PaymentMethod[] PaymentMethodField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingMode BillingMode
        {
            get
            {
                return this.BillingModeField;
            }
            set
            {
                this.BillingModeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PaymentMethod[] PaymentMethod
        {
            get
            {
                return this.PaymentMethodField;
            }
            set
            {
                this.PaymentMethodField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "CallerInfo", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class CallerInfo : object
    {

        

        private string AccountIdField;

        private string AddressIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Identity DelegatorField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Identity RequesterField;

        private string TaxProfileIdField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public string AccountId
        {
            get
            {
                return this.AccountIdField;
            }
            set
            {
                this.AccountIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string AddressId
        {
            get
            {
                return this.AddressIdField;
            }
            set
            {
                this.AddressIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Identity Delegator
        {
            get
            {
                return this.DelegatorField;
            }
            set
            {
                this.DelegatorField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Identity Requester
        {
            get
            {
                return this.RequesterField;
            }
            set
            {
                this.RequesterField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TaxProfileId
        {
            get
            {
                return this.TaxProfileIdField;
            }
            set
            {
                this.TaxProfileIdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Marketplace", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Marketplace : object
    {

        

        private System.Guid MarkerplaceGuidField;

        private string MarketplaceNameField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid MarkerplaceGuid
        {
            get
            {
                return this.MarkerplaceGuidField;
            }
            set
            {
                this.MarkerplaceGuidField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MarketplaceName
        {
            get
            {
                return this.MarketplaceNameField;
            }
            set
            {
                this.MarketplaceNameField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseContext", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseContext : object
    {

        

        private bool ComputeOnlyField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Policy PolicyField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private System.DateTime TimeStampField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Policy Policy
        {
            get
            {
                return this.PolicyField;
            }
            set
            {
                this.PolicyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseInfoInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseInfoInput : object
    {

        

        private System.Nullable<int> CampaignIdField;

        private string ClientAddressField;

        private string DescriptionField;

        private string ExternalPurchaseIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseBundleInput[] PurchaseBundleInputSetField;

        private string TitleField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> CampaignId
        {
            get
            {
                return this.CampaignIdField;
            }
            set
            {
                this.CampaignIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ClientAddress
        {
            get
            {
                return this.ClientAddressField;
            }
            set
            {
                this.ClientAddressField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPurchaseId
        {
            get
            {
                return this.ExternalPurchaseIdField;
            }
            set
            {
                this.ExternalPurchaseIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseBundleInput[] PurchaseBundleInputSet
        {
            get
            {
                return this.PurchaseBundleInputSetField;
            }
            set
            {
                this.PurchaseBundleInputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutContext", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutContext : object
    {

        

        private bool ComputeOnlyField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private System.DateTime TimeStampField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutOrderInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOrderInput : object
    {

        

        private string DescriptionField;

        private string ExternalPayoutIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutLineEntryInput[] PayoutLineEntryInputSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private string SourceCurrencyField;

        private string TargetCurrencyField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPayoutId
        {
            get
            {
                return this.ExternalPayoutIdField;
            }
            set
            {
                this.ExternalPayoutIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutLineEntryInput[] PayoutLineEntryInputSet
        {
            get
            {
                return this.PayoutLineEntryInputSetField;
            }
            set
            {
                this.PayoutLineEntryInputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceCurrency
        {
            get
            {
                return this.SourceCurrencyField;
            }
            set
            {
                this.SourceCurrencyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TargetCurrency
        {
            get
            {
                return this.TargetCurrencyField;
            }
            set
            {
                this.TargetCurrencyField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Partner", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Partner : object
    {

        

        private System.Guid PartnerGuidField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PartnerGuid
        {
            get
            {
                return this.PartnerGuidField;
            }
            set
            {
                this.PartnerGuidField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Property", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Property : object
    {

        

        private string NameField;

        private string NamespaceField;

        private string ValueField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Namespace
        {
            get
            {
                return this.NamespaceField;
            }
            set
            {
                this.NamespaceField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                this.ValueField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "BillingMode", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum BillingMode : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        ImmediateSettle = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        ScheduledSettle = 1,
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PaymentMethod", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.TokenPaymentMethod))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.RegisteredPaymentMethod))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PointPaymentMethod))]
    public partial class PaymentMethod : object
    {

        

 
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "TokenPaymentMethod", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class TokenPaymentMethod : Microsoft.XBox.Live.Server.Emulators.TransactionService.PaymentMethod
    {

        private string PKPNField;

        private string TokenInstanceIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.TokenInstanceType TokenInstanceTypeField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PKPN
        {
            get
            {
                return this.PKPNField;
            }
            set
            {
                this.PKPNField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenInstanceId
        {
            get
            {
                return this.TokenInstanceIdField;
            }
            set
            {
                this.TokenInstanceIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.TokenInstanceType TokenInstanceType
        {
            get
            {
                return this.TokenInstanceTypeField;
            }
            set
            {
                this.TokenInstanceTypeField = value;
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "RegisteredPaymentMethod", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RegisteredPaymentMethod : Microsoft.XBox.Live.Server.Emulators.TransactionService.PaymentMethod
    {

        private string PaymentMethodIDField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PaymentMethodID
        {
            get
            {
                return this.PaymentMethodIDField;
            }
            set
            {
                this.PaymentMethodIDField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PointPaymentMethod", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PointPaymentMethod : Microsoft.XBox.Live.Server.Emulators.TransactionService.PaymentMethod
    {
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "TokenInstanceType", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum TokenInstanceType : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        RSMToken = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        PartnerToken = 1,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Identity", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Identity : object
    {

        

        private string IdentityTypeField;

        private string IdentityValueField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public string IdentityType
        {
            get
            {
                return this.IdentityTypeField;
            }
            set
            {
                this.IdentityTypeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string IdentityValue
        {
            get
            {
                return this.IdentityValueField;
            }
            set
            {
                this.IdentityValueField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutLineEntryInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutLineEntryInput : object
    {

        

        private string CategoryField;

        private string DescriptionField;

        private string ExternalItemIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.IncomeType IncomeTypeField;

        private string NameField;

        private string SourceOfIncomeField;

        private System.Nullable<decimal> SourceTotalAmountField;

        private decimal TargetTotalAmountField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Category
        {
            get
            {
                return this.CategoryField;
            }
            set
            {
                this.CategoryField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalItemId
        {
            get
            {
                return this.ExternalItemIdField;
            }
            set
            {
                this.ExternalItemIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.IncomeType IncomeType
        {
            get
            {
                return this.IncomeTypeField;
            }
            set
            {
                this.IncomeTypeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceOfIncome
        {
            get
            {
                return this.SourceOfIncomeField;
            }
            set
            {
                this.SourceOfIncomeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> SourceTotalAmount
        {
            get
            {
                return this.SourceTotalAmountField;
            }
            set
            {
                this.SourceTotalAmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TargetTotalAmount
        {
            get
            {
                return this.TargetTotalAmountField;
            }
            set
            {
                this.TargetTotalAmountField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "IncomeType", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum IncomeType : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Royalty = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Service = 2,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Rebate = 3,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Reward = 4,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "JoinSubsContext", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubsContext : object
    {

        

        private bool ComputeOnlyField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private System.DateTime TimeStampField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "JoinSubscriptionInfoInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionInfoInput : object
    {

        

        private string DestinationSubscriptionIdField;

        private string SourceSubscriptionIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfoField;

 

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string DestinationSubscriptionId
        {
            get
            {
                return this.DestinationSubscriptionIdField;
            }
            set
            {
                this.DestinationSubscriptionIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceSubscriptionId
        {
            get
            {
                return this.SourceSubscriptionIdField;
            }
            set
            {
                this.SourceSubscriptionIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfo
        {
            get
            {
                return this.SubsTimeExtensionInfoField;
            }
            set
            {
                this.SubsTimeExtensionInfoField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SubsTimeExtensionInfo", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class SubsTimeExtensionInfo : object
    {

        

        private System.Nullable<Microsoft.Transaction.Interfaces.ExtendReasonCode> ExtendReasonCodeField;

        private int ExtendedLengthField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.TimeExtensionUnit ExtendedUnitField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<Microsoft.Transaction.Interfaces.ExtendReasonCode> ExtendReasonCode
        {
            get
            {
                return this.ExtendReasonCodeField;
            }
            set
            {
                this.ExtendReasonCodeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ExtendedLength
        {
            get
            {
                return this.ExtendedLengthField;
            }
            set
            {
                this.ExtendedLengthField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.TimeExtensionUnit ExtendedUnit
        {
            get
            {
                return this.ExtendedUnitField;
            }
            set
            {
                this.ExtendedUnitField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "TimeExtensionUnit", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum TimeExtensionUnit : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Day = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Month = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Year = 2,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateAccountContext", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountContext : object
    {

        

        private bool ComputeOnlyField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContextField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Policy PolicyField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private System.DateTime TimeStampField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Policy Policy
        {
            get
            {
                return this.PolicyField;
            }
            set
            {
                this.PolicyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateAccountInfoInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountInfoInput : object
    {

        

        private string DestinationAccountIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateSubscriptionInfoInput[] MigrateSubscriptionInfoInputsField;

        private string SourceAccountIdField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public string DestinationAccountId
        {
            get
            {
                return this.DestinationAccountIdField;
            }
            set
            {
                this.DestinationAccountIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateSubscriptionInfoInput[] MigrateSubscriptionInfoInputs
        {
            get
            {
                return this.MigrateSubscriptionInfoInputsField;
            }
            set
            {
                this.MigrateSubscriptionInfoInputsField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceAccountId
        {
            get
            {
                return this.SourceAccountIdField;
            }
            set
            {
                this.SourceAccountIdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Policy", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Policy : object
    {

        

        private System.Guid PolicyGUIDField;

        private int PolicyVersionField;

        private System.DateTime SignatureDateTimeField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PolicyGUID
        {
            get
            {
                return this.PolicyGUIDField;
            }
            set
            {
                this.PolicyGUIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int PolicyVersion
        {
            get
            {
                return this.PolicyVersionField;
            }
            set
            {
                this.PolicyVersionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime SignatureDateTime
        {
            get
            {
                return this.SignatureDateTimeField;
            }
            set
            {
                this.SignatureDateTimeField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateSubscriptionInfoInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateSubscriptionInfoInput : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseNewSubscriptionProductItemInput DestinationSubscriptionInfoField;

        private bool ProvisionServiceField;

        private string SourceSubscriptionIdField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseNewSubscriptionProductItemInput DestinationSubscriptionInfo
        {
            get
            {
                return this.DestinationSubscriptionInfoField;
            }
            set
            {
                this.DestinationSubscriptionInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ProvisionService
        {
            get
            {
                return this.ProvisionServiceField;
            }
            set
            {
                this.ProvisionServiceField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceSubscriptionId
        {
            get
            {
                return this.SourceSubscriptionIdField;
            }
            set
            {
                this.SourceSubscriptionIdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseNewSubscriptionProductItemInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseNewSubscriptionProductItemInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemInput
    {

        private string ProductItemCatalogIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEventsField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ReferralInfo[] ReferralInfoSetField;

        private string SubscriptionFriendlyNameField;

        private string SupportDescriptionField;

        private string SupportTitleField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemCatalogId
        {
            get
            {
                return this.ProductItemCatalogIdField;
            }
            set
            {
                this.ProductItemCatalogIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ReferralInfo[] ReferralInfoSet
        {
            get
            {
                return this.ReferralInfoSetField;
            }
            set
            {
                this.ReferralInfoSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionFriendlyName
        {
            get
            {
                return this.SubscriptionFriendlyNameField;
            }
            set
            {
                this.SubscriptionFriendlyNameField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportDescription
        {
            get
            {
                return this.SupportDescriptionField;
            }
            set
            {
                this.SupportDescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportTitle
        {
            get
            {
                return this.SupportTitleField;
            }
            set
            {
                this.SupportTitleField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseProductItemInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchasePointsProductItemInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseContentProductItemInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseConvertSubscriptionProductItemInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseNewSubscriptionProductItemInput))]
    public partial class PurchaseProductItemInput : object
    {

        

        private string DescriptionField;

        private string ExternalProductItemIdField;

        private string ProductTypeField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RevenueInfo RevenueInfoField;

        private string TitleField;

 

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalProductItemId
        {
            get
            {
                return this.ExternalProductItemIdField;
            }
            set
            {
                this.ExternalProductItemIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductType
        {
            get
            {
                return this.ProductTypeField;
            }
            set
            {
                this.ProductTypeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RevenueInfo RevenueInfo
        {
            get
            {
                return this.RevenueInfoField;
            }
            set
            {
                this.RevenueInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "RevenueInfo", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RevenueInfo : object
    {

        

        private decimal RevenueAllocationPercentageField;

        private string RevenueSKUField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal RevenueAllocationPercentage
        {
            get
            {
                return this.RevenueAllocationPercentageField;
            }
            set
            {
                this.RevenueAllocationPercentageField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RevenueSKU
        {
            get
            {
                return this.RevenueSKUField;
            }
            set
            {
                this.RevenueSKUField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchasePointsProductItemInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchasePointsProductItemInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemInput
    {

        private string ItemCategoryField;

        private string ProductItemCatalogIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ReferralInfo[] ReferralInfoSetField;

        private string SupportDescriptionField;

        private string SupportTitleField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemCategory
        {
            get
            {
                return this.ItemCategoryField;
            }
            set
            {
                this.ItemCategoryField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemCatalogId
        {
            get
            {
                return this.ProductItemCatalogIdField;
            }
            set
            {
                this.ProductItemCatalogIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ReferralInfo[] ReferralInfoSet
        {
            get
            {
                return this.ReferralInfoSetField;
            }
            set
            {
                this.ReferralInfoSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportDescription
        {
            get
            {
                return this.SupportDescriptionField;
            }
            set
            {
                this.SupportDescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportTitle
        {
            get
            {
                return this.SupportTitleField;
            }
            set
            {
                this.SupportTitleField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseContentProductItemInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseContentProductItemInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemInput
    {

        private string ExternalProductItemCatalogIdField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalProductItemCatalogId
        {
            get
            {
                return this.ExternalProductItemCatalogIdField;
            }
            set
            {
                this.ExternalProductItemCatalogIdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseConvertSubscriptionProductItemInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseConvertSubscriptionProductItemInput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemInput
    {

        private string ConvertFromSubscriptionIDField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ConvertMode ConvertModeField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.CreditMode CreditModeField;

        private string ProductItemCatalogIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEventsField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ReferralInfo[] ReferralInfoSetField;

        private System.Nullable<int> RoundBoundaryField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfoField;

        private string SubscriptionFriendlyNameField;

        private string SupportDescriptionField;

        private string SupportTitleField;

        private System.Nullable<decimal> TimeConversionRatioField;

        private int MonthExtendedField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ConvertFromSubscriptionID
        {
            get
            {
                return this.ConvertFromSubscriptionIDField;
            }
            set
            {
                this.ConvertFromSubscriptionIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ConvertMode ConvertMode
        {
            get
            {
                return this.ConvertModeField;
            }
            set
            {
                this.ConvertModeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.CreditMode CreditMode
        {
            get
            {
                return this.CreditModeField;
            }
            set
            {
                this.CreditModeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemCatalogId
        {
            get
            {
                return this.ProductItemCatalogIdField;
            }
            set
            {
                this.ProductItemCatalogIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ReferralInfo[] ReferralInfoSet
        {
            get
            {
                return this.ReferralInfoSetField;
            }
            set
            {
                this.ReferralInfoSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> RoundBoundary
        {
            get
            {
                return this.RoundBoundaryField;
            }
            set
            {
                this.RoundBoundaryField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfo
        {
            get
            {
                return this.SubsTimeExtensionInfoField;
            }
            set
            {
                this.SubsTimeExtensionInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionFriendlyName
        {
            get
            {
                return this.SubscriptionFriendlyNameField;
            }
            set
            {
                this.SubscriptionFriendlyNameField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportDescription
        {
            get
            {
                return this.SupportDescriptionField;
            }
            set
            {
                this.SupportDescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportTitle
        {
            get
            {
                return this.SupportTitleField;
            }
            set
            {
                this.SupportTitleField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> TimeConversionRatio
        {
            get
            {
                return this.TimeConversionRatioField;
            }
            set
            {
                this.TimeConversionRatioField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute(Order = 12)]
        public int MonthExtended
        {
            get
            {
                return this.MonthExtendedField;
            }
            set
            {
                this.MonthExtendedField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "RatingEvent", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RatingEvent : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingRule[] RuleInfoField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEventType TypeField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingRule[] RuleInfo
        {
            get
            {
                return this.RuleInfoField;
            }
            set
            {
                this.RuleInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEventType Type
        {
            get
            {
                return this.TypeField;
            }
            set
            {
                this.TypeField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ReferralInfo", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ReferralInfo : object
    {

        

        private System.DateTime CreatedDateTimeField;

        private string DataField;

        private System.Guid PartnerIdField;

        private string PartnerNameField;

        private string TypeField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime CreatedDateTime
        {
            get
            {
                return this.CreatedDateTimeField;
            }
            set
            {
                this.CreatedDateTimeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Data
        {
            get
            {
                return this.DataField;
            }
            set
            {
                this.DataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PartnerId
        {
            get
            {
                return this.PartnerIdField;
            }
            set
            {
                this.PartnerIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PartnerName
        {
            get
            {
                return this.PartnerNameField;
            }
            set
            {
                this.PartnerNameField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Type
        {
            get
            {
                return this.TypeField;
            }
            set
            {
                this.TypeField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ConvertMode", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum ConvertMode : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Convert = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Renew = 1,
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "CreditMode", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum CreditMode : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        CreditByRefund = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        CreditByTimeExtension = 1,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "RatingRule", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RatingRule : object
    {

        

        private decimal AmountField;

        private int CycleEndField;

        private int CycleStartField;

        private int CycleUnitField;

        private System.Guid GuidReferenceField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingRuleType TypeField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int CycleEnd
        {
            get
            {
                return this.CycleEndField;
            }
            set
            {
                this.CycleEndField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int CycleStart
        {
            get
            {
                return this.CycleStartField;
            }
            set
            {
                this.CycleStartField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int CycleUnit
        {
            get
            {
                return this.CycleUnitField;
            }
            set
            {
                this.CycleUnitField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid GuidReference
        {
            get
            {
                return this.GuidReferenceField;
            }
            set
            {
                this.GuidReferenceField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingRuleType Type
        {
            get
            {
                return this.TypeField;
            }
            set
            {
                this.TypeField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "RatingEventType", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum RatingEventType : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        ConvertFrom = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        CancelSubscription = 1,
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "RatingRuleType", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum RatingRuleType : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Charge = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Proration = 1,
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Filter", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Filter : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.DateRange OrderCreateDateRangeField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.DateRange OrderEventDateRangeField;

        private string[] OrderEventTypeSetField;

        private string PayoutOrderIDField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.DateRange OrderCreateDateRange
        {
            get
            {
                return this.OrderCreateDateRangeField;
            }
            set
            {
                this.OrderCreateDateRangeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.DateRange OrderEventDateRange
        {
            get
            {
                return this.OrderEventDateRangeField;
            }
            set
            {
                this.OrderEventDateRangeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string[] OrderEventTypeSet
        {
            get
            {
                return this.OrderEventTypeSetField;
            }
            set
            {
                this.OrderEventTypeSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderID
        {
            get
            {
                return this.PayoutOrderIDField;
            }
            set
            {
                this.PayoutOrderIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "DateRange", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class DateRange : object
    {

        

        private System.Nullable<System.DateTime> EndDateField;

        private System.Nullable<System.DateTime> StartDateField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> EndDate
        {
            get
            {
                return this.EndDateField;
            }
            set
            {
                this.EndDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> StartDate
        {
            get
            {
                return this.StartDateField;
            }
            set
            {
                this.StartDateField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseBundleInput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseBundleInput : object
    {

        

        private System.Nullable<decimal> AmountField;

        private string CurrencyField;

        private string DescriptionField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.DiscountInfo[] DiscountInfoSetField;

        private string ExternalBundleCatalogIdField;

        private string ExternalBundleIdField;

        private System.Nullable<bool> IsTaxExemptionAllowedField;

        private System.Nullable<bool> IsTaxIncludedField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemInput[] PurchaseProductItemInputSetField;

        private string TitleField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.DiscountInfo[] DiscountInfoSet
        {
            get
            {
                return this.DiscountInfoSetField;
            }
            set
            {
                this.DiscountInfoSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleCatalogId
        {
            get
            {
                return this.ExternalBundleCatalogIdField;
            }
            set
            {
                this.ExternalBundleCatalogIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleId
        {
            get
            {
                return this.ExternalBundleIdField;
            }
            set
            {
                this.ExternalBundleIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxExemptionAllowed
        {
            get
            {
                return this.IsTaxExemptionAllowedField;
            }
            set
            {
                this.IsTaxExemptionAllowedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxIncluded
        {
            get
            {
                return this.IsTaxIncludedField;
            }
            set
            {
                this.IsTaxIncludedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemInput[] PurchaseProductItemInputSet
        {
            get
            {
                return this.PurchaseProductItemInputSetField;
            }
            set
            {
                this.PurchaseProductItemInputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "DiscountInfo", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class DiscountInfo : object
    {

        

        private string DiscountDescriptionField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string DiscountDescription
        {
            get
            {
                return this.DiscountDescriptionField;
            }
            set
            {
                this.DiscountDescriptionField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "AbstractResponse", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderStatusOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderEventUpdateOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseOutput))]
    public partial class AbstractResponse : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.AckCodeType AckField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ErrorType ErrorField;

        private bool IsSameTrackingGuidRetryField;

        private System.Guid ResponseGuidField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.AckCodeType Ack
        {
            get
            {
                return this.AckField;
            }
            set
            {
                this.AckField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ErrorType Error
        {
            get
            {
                return this.ErrorField;
            }
            set
            {
                this.ErrorField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsSameTrackingGuidRetry
        {
            get
            {
                return this.IsSameTrackingGuidRetryField;
            }
            set
            {
                this.IsSameTrackingGuidRetryField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid ResponseGuid
        {
            get
            {
                return this.ResponseGuidField;
            }
            set
            {
                this.ResponseGuidField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ErrorType", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ErrorType : object
    {

        

        private int ErrorCodeField;

        private string ErrorDescriptionField;

        private string ErrorLongMessageField;

        private string ErrorShortMessageField;

        private bool RetryableField;

  

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ErrorCode
        {
            get
            {
                return this.ErrorCodeField;
            }
            set
            {
                this.ErrorCodeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ErrorDescription
        {
            get
            {
                return this.ErrorDescriptionField;
            }
            set
            {
                this.ErrorDescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ErrorLongMessage
        {
            get
            {
                return this.ErrorLongMessageField;
            }
            set
            {
                this.ErrorLongMessageField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ErrorShortMessage
        {
            get
            {
                return this.ErrorShortMessageField;
            }
            set
            {
                this.ErrorShortMessageField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool Retryable
        {
            get
            {
                return this.RetryableField;
            }
            set
            {
                this.RetryableField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractResponse
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderOutput PayoutOrderOutputField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderOutput PayoutOrderOutput
        {
            get
            {
                return this.PayoutOrderOutputField;
            }
            set
            {
                this.PayoutOrderOutputField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "JoinSubscriptionOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractResponse
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionInfoOutput JoinSubscriptionInfoOutputField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionInfoOutput JoinSubscriptionInfoOutput
        {
            get
            {
                return this.JoinSubscriptionInfoOutputField;
            }
            set
            {
                this.JoinSubscriptionInfoOutputField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateAccountOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractResponse
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountInfoOutput MigrateAccountInfoOutputField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountInfoOutput MigrateAccountInfoOutput
        {
            get
            {
                return this.MigrateAccountInfoOutputField;
            }
            set
            {
                this.MigrateAccountInfoOutputField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "GetPayoutOrderStatusOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderStatusOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractResponse
    {

        private string NextHandlerField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderOutput[] PayoutOrderOutputField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property PropertyBagField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string NextHandler
        {
            get
            {
                return this.NextHandlerField;
            }
            set
            {
                this.NextHandlerField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderOutput[] PayoutOrderOutput
        {
            get
            {
                return this.PayoutOrderOutputField;
            }
            set
            {
                this.PayoutOrderOutputField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "GetPayoutOrderEventUpdateOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderEventUpdateOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractResponse
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderEventOutput[] GetPayoutOrderEventOutputField;

        private string NextHandlerField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property PropertyBagField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderEventOutput[] GetPayoutOrderEventOutput
        {
            get
            {
                return this.GetPayoutOrderEventOutputField;
            }
            set
            {
                this.GetPayoutOrderEventOutputField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string NextHandler
        {
            get
            {
                return this.NextHandlerField;
            }
            set
            {
                this.NextHandlerField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.AbstractResponse
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseInfoOutput PurchaseInfoOutputField;

        private decimal TotalPriceWithoutTaxField;

        private decimal TotalTaxField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseInfoOutput PurchaseInfoOutput
        {
            get
            {
                return this.PurchaseInfoOutputField;
            }
            set
            {
                this.PurchaseInfoOutputField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalPriceWithoutTax
        {
            get
            {
                return this.TotalPriceWithoutTaxField;
            }
            set
            {
                this.TotalPriceWithoutTaxField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalTax
        {
            get
            {
                return this.TotalTaxField;
            }
            set
            {
                this.TotalTaxField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "AckCodeType", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum AckCodeType : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Success = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        RetryableFailure = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        NonRetryableFailure = 2,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        InternalError = 3,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseInfoOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseInfoOutput : object
    {

        

        private string ExternalPurchaseIdField;

        private System.Nullable<int> NewPointsBalanceField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.OrderOutput[] OrderSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseBundleOutput[] PurchaseBundleOutputSetField;

        private string PurchaseIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseStatus StateField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPurchaseId
        {
            get
            {
                return this.ExternalPurchaseIdField;
            }
            set
            {
                this.ExternalPurchaseIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> NewPointsBalance
        {
            get
            {
                return this.NewPointsBalanceField;
            }
            set
            {
                this.NewPointsBalanceField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.OrderOutput[] OrderSet
        {
            get
            {
                return this.OrderSetField;
            }
            set
            {
                this.OrderSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseBundleOutput[] PurchaseBundleOutputSet
        {
            get
            {
                return this.PurchaseBundleOutputSetField;
            }
            set
            {
                this.PurchaseBundleOutputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PurchaseId
        {
            get
            {
                return this.PurchaseIdField;
            }
            set
            {
                this.PurchaseIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseStatus State
        {
            get
            {
                return this.StateField;
            }
            set
            {
                this.StateField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutOrderOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOrderOutput : object
    {

        

        private string ExternalPayoutIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PaymentMethod PaymentMethodField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderEventOutput[] PayoutOrderEventOutputSetField;

        private string PayoutOrderIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Partner PayoutPartnerField;

        private string PayoutTaxProfileIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private string TargetCurrencyField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPayoutId
        {
            get
            {
                return this.ExternalPayoutIdField;
            }
            set
            {
                this.ExternalPayoutIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PaymentMethod PaymentMethod
        {
            get
            {
                return this.PaymentMethodField;
            }
            set
            {
                this.PaymentMethodField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSet
        {
            get
            {
                return this.PayoutLineEntryOutputSetField;
            }
            set
            {
                this.PayoutLineEntryOutputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOrderEventOutput[] PayoutOrderEventOutputSet
        {
            get
            {
                return this.PayoutOrderEventOutputSetField;
            }
            set
            {
                this.PayoutOrderEventOutputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderId
        {
            get
            {
                return this.PayoutOrderIdField;
            }
            set
            {
                this.PayoutOrderIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Partner PayoutPartner
        {
            get
            {
                return this.PayoutPartnerField;
            }
            set
            {
                this.PayoutPartnerField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutTaxProfileId
        {
            get
            {
                return this.PayoutTaxProfileIdField;
            }
            set
            {
                this.PayoutTaxProfileIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TargetCurrency
        {
            get
            {
                return this.TargetCurrencyField;
            }
            set
            {
                this.TargetCurrencyField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutLineEntryOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutLineEntryOutput : object
    {

        

        private string ExternalItemIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutTaxEntry[] PayoutTaxEntriesField;

        private string TargetCurrencyField;

        private decimal TargetNetAmountField;

        private decimal TargetTotalAmountField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.WHTStateType WHTStateField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalItemId
        {
            get
            {
                return this.ExternalItemIdField;
            }
            set
            {
                this.ExternalItemIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutTaxEntry[] PayoutTaxEntries
        {
            get
            {
                return this.PayoutTaxEntriesField;
            }
            set
            {
                this.PayoutTaxEntriesField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TargetCurrency
        {
            get
            {
                return this.TargetCurrencyField;
            }
            set
            {
                this.TargetCurrencyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TargetNetAmount
        {
            get
            {
                return this.TargetNetAmountField;
            }
            set
            {
                this.TargetNetAmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TargetTotalAmount
        {
            get
            {
                return this.TargetTotalAmountField;
            }
            set
            {
                this.TargetTotalAmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.WHTStateType WHTState
        {
            get
            {
                return this.WHTStateField;
            }
            set
            {
                this.WHTStateField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutOrderEventOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOrderEventOutput : object
    {

        

        private System.DateTime EventDateField;

        private string ExternalPayoutIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSetField;

        private string PayoutOrderEventTypeField;

        private string PayoutOrderIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

  

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime EventDate
        {
            get
            {
                return this.EventDateField;
            }
            set
            {
                this.EventDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPayoutId
        {
            get
            {
                return this.ExternalPayoutIdField;
            }
            set
            {
                this.ExternalPayoutIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSet
        {
            get
            {
                return this.PayoutLineEntryOutputSetField;
            }
            set
            {
                this.PayoutLineEntryOutputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderEventType
        {
            get
            {
                return this.PayoutOrderEventTypeField;
            }
            set
            {
                this.PayoutOrderEventTypeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderId
        {
            get
            {
                return this.PayoutOrderIdField;
            }
            set
            {
                this.PayoutOrderIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PayoutTaxEntry", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutTaxEntry : Microsoft.XBox.Live.Server.Emulators.TransactionService.TaxEntry
    {
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "WHTStateType", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum WHTStateType : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Applied = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        NotApplicable = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        PendingCalculation = 2,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "TaxEntry", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutTaxEntry))]
    public partial class TaxEntry : object
    {

        

        private decimal AmountField;

        private string JurisdictionField;

        private decimal RateField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Jurisdiction
        {
            get
            {
                return this.JurisdictionField;
            }
            set
            {
                this.JurisdictionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Rate
        {
            get
            {
                return this.RateField;
            }
            set
            {
                this.RateField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "JoinSubscriptionInfoOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionInfoOutput : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] DestSubsRatingRuleSetField;

        private System.DateTime DestSubscriptionNextCycleChargeDateField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo DestinationSubscriptionStatusField;

        private string ExternalJoinSubsIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo SourceSubscriptionStatusField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubsStatus StateField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] DestSubsRatingRuleSet
        {
            get
            {
                return this.DestSubsRatingRuleSetField;
            }
            set
            {
                this.DestSubsRatingRuleSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime DestSubscriptionNextCycleChargeDate
        {
            get
            {
                return this.DestSubscriptionNextCycleChargeDateField;
            }
            set
            {
                this.DestSubscriptionNextCycleChargeDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo DestinationSubscriptionStatus
        {
            get
            {
                return this.DestinationSubscriptionStatusField;
            }
            set
            {
                this.DestinationSubscriptionStatusField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalJoinSubsId
        {
            get
            {
                return this.ExternalJoinSubsIdField;
            }
            set
            {
                this.ExternalJoinSubsIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSet
        {
            get
            {
                return this.SourceSubsRemovedServiceInstanceSetField;
            }
            set
            {
                this.SourceSubsRemovedServiceInstanceSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo SourceSubscriptionStatus
        {
            get
            {
                return this.SourceSubscriptionStatusField;
            }
            set
            {
                this.SourceSubscriptionStatusField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubsStatus State
        {
            get
            {
                return this.StateField;
            }
            set
            {
                this.StateField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SubscriptionStatusInfo", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class SubscriptionStatusInfo : object
    {

        

        private System.DateTime NewEndDateField;

        private string SubscriptionIdField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatus SubscriptionStatusField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ViolationId[] ViolationSetField;

 

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime NewEndDate
        {
            get
            {
                return this.NewEndDateField;
            }
            set
            {
                this.NewEndDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionId
        {
            get
            {
                return this.SubscriptionIdField;
            }
            set
            {
                this.SubscriptionIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatus SubscriptionStatus
        {
            get
            {
                return this.SubscriptionStatusField;
            }
            set
            {
                this.SubscriptionStatusField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ViolationId[] ViolationSet
        {
            get
            {
                return this.ViolationSetField;
            }
            set
            {
                this.ViolationSetField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ServiceInstance", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ServiceInstance : object
    {

        

        private string ServiceComponentIdField;

        private string ServiceInstanceIdField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ServiceComponentId
        {
            get
            {
                return this.ServiceComponentIdField;
            }
            set
            {
                this.ServiceComponentIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ServiceInstanceId
        {
            get
            {
                return this.ServiceInstanceIdField;
            }
            set
            {
                this.ServiceInstanceIdField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "JoinSubsStatus", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum JoinSubsStatus : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Complete = 2,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Abandon = 3,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Aborted = 4,
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SubscriptionStatus", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum SubscriptionStatus : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        INVALID = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        PENDING = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        ENABLED = 2,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        SUSPENED = 3,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        CANCELED = 4,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        EXPIRED = 5,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        ABANDONED = 6,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        PENDINGCOMMITCREATESUBS = 7,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        PENDINGCOMMITCONVERTSUBS = 8,
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ViolationId", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ViolationId : object
    {

        

        private int IdField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public int Id
        {
            get
            {
                return this.IdField;
            }
            set
            {
                this.IdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateAccountInfoOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountInfoOutput : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountStatus MigrateAccountStatusField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateSubscriptionInfoOutput[] MigrateSubscriptionInfoOutputsField;


        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountStatus MigrateAccountStatus
        {
            get
            {
                return this.MigrateAccountStatusField;
            }
            set
            {
                this.MigrateAccountStatusField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateSubscriptionInfoOutput[] MigrateSubscriptionInfoOutputs
        {
            get
            {
                return this.MigrateSubscriptionInfoOutputsField;
            }
            set
            {
                this.MigrateSubscriptionInfoOutputsField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateAccountStatus", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum MigrateAccountStatus : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Complete = 2,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Abandon = 3,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Aborted = 4,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "MigrateSubscriptionInfoOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateSubscriptionInfoOutput : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] DestinationSubsAddedServiceInstanceSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo DestinationSubscriptionStatusField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo SourceSubscriptionStatusField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] DestinationSubsAddedServiceInstanceSet
        {
            get
            {
                return this.DestinationSubsAddedServiceInstanceSetField;
            }
            set
            {
                this.DestinationSubsAddedServiceInstanceSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo DestinationSubscriptionStatus
        {
            get
            {
                return this.DestinationSubscriptionStatusField;
            }
            set
            {
                this.DestinationSubscriptionStatusField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSet
        {
            get
            {
                return this.SourceSubsRemovedServiceInstanceSetField;
            }
            set
            {
                this.SourceSubsRemovedServiceInstanceSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubscriptionStatusInfo SourceSubscriptionStatus
        {
            get
            {
                return this.SourceSubscriptionStatusField;
            }
            set
            {
                this.SourceSubscriptionStatusField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "OrderOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class OrderOutput : object
    {

        

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingMode BillingModeField;

        private string CurrencyField;

        private System.DateTime EstimatedChargeTimeField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ItemEntryOutput[] ItemEntriesField;

        private long OrderIdField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.BillingMode BillingMode
        {
            get
            {
                return this.BillingModeField;
            }
            set
            {
                this.BillingModeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime EstimatedChargeTime
        {
            get
            {
                return this.EstimatedChargeTimeField;
            }
            set
            {
                this.EstimatedChargeTimeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ItemEntryOutput[] ItemEntries
        {
            get
            {
                return this.ItemEntriesField;
            }
            set
            {
                this.ItemEntriesField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public long OrderId
        {
            get
            {
                return this.OrderIdField;
            }
            set
            {
                this.OrderIdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseBundleOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseBundleOutput : object
    {

        

        private System.Nullable<decimal> AmountField;

        private string BundleIdField;

        private string CurrencyField;

        private string DescriptionField;

        private string ExternalBundleCatalogIdField;

        private string ExternalBundleIdField;

        private System.Nullable<bool> IsTaxExemptionAppliedField;

        private System.Nullable<bool> IsTaxIncludedField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBagField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemOutput[] PurchaseProductItemOutputSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.TaxEntry[] TaxEntriesField;

        private string TitleField;

        private decimal TotalTaxAmountField;

        private decimal TotalTaxRateField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string BundleId
        {
            get
            {
                return this.BundleIdField;
            }
            set
            {
                this.BundleIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleCatalogId
        {
            get
            {
                return this.ExternalBundleCatalogIdField;
            }
            set
            {
                this.ExternalBundleCatalogIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleId
        {
            get
            {
                return this.ExternalBundleIdField;
            }
            set
            {
                this.ExternalBundleIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxExemptionApplied
        {
            get
            {
                return this.IsTaxExemptionAppliedField;
            }
            set
            {
                this.IsTaxExemptionAppliedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxIncluded
        {
            get
            {
                return this.IsTaxIncludedField;
            }
            set
            {
                this.IsTaxIncludedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemOutput[] PurchaseProductItemOutputSet
        {
            get
            {
                return this.PurchaseProductItemOutputSetField;
            }
            set
            {
                this.PurchaseProductItemOutputSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.TaxEntry[] TaxEntries
        {
            get
            {
                return this.TaxEntriesField;
            }
            set
            {
                this.TaxEntriesField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalTaxAmount
        {
            get
            {
                return this.TotalTaxAmountField;
            }
            set
            {
                this.TotalTaxAmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalTaxRate
        {
            get
            {
                return this.TotalTaxRateField;
            }
            set
            {
                this.TotalTaxRateField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseStatus", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum PurchaseStatus : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 1,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Complete = 2,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Abandon = 3,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Aborted = 4,
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ItemEntryOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ItemEntryOutput : object
    {

        

        private long BundleIdField;

        private System.Nullable<bool> IsTaxExemptionAppliedField;

        private System.Nullable<bool> IsTaxIncludedField;

        private string ItemDescriptionField;

        private string ItemNameField;

        private string ItemTypeField;

        private long ProductItemIdField;

        private long PurchaseIdField;

        private System.Nullable<int> QuantityField;

        private string RevenueSKUField;

        private string TaxCodeField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.TaxEntry[] TaxEntriesField;

        private System.Nullable<decimal> UnitAmountField;



        [System.Runtime.Serialization.DataMemberAttribute()]
        public long BundleId
        {
            get
            {
                return this.BundleIdField;
            }
            set
            {
                this.BundleIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxExemptionApplied
        {
            get
            {
                return this.IsTaxExemptionAppliedField;
            }
            set
            {
                this.IsTaxExemptionAppliedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxIncluded
        {
            get
            {
                return this.IsTaxIncludedField;
            }
            set
            {
                this.IsTaxIncludedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemDescription
        {
            get
            {
                return this.ItemDescriptionField;
            }
            set
            {
                this.ItemDescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemName
        {
            get
            {
                return this.ItemNameField;
            }
            set
            {
                this.ItemNameField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemType
        {
            get
            {
                return this.ItemTypeField;
            }
            set
            {
                this.ItemTypeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public long ProductItemId
        {
            get
            {
                return this.ProductItemIdField;
            }
            set
            {
                this.ProductItemIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public long PurchaseId
        {
            get
            {
                return this.PurchaseIdField;
            }
            set
            {
                this.PurchaseIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> Quantity
        {
            get
            {
                return this.QuantityField;
            }
            set
            {
                this.QuantityField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RevenueSKU
        {
            get
            {
                return this.RevenueSKUField;
            }
            set
            {
                this.RevenueSKUField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TaxCode
        {
            get
            {
                return this.TaxCodeField;
            }
            set
            {
                this.TaxCodeField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.TaxEntry[] TaxEntries
        {
            get
            {
                return this.TaxEntriesField;
            }
            set
            {
                this.TaxEntriesField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> UnitAmount
        {
            get
            {
                return this.UnitAmountField;
            }
            set
            {
                this.UnitAmountField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseProductItemOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseContentProductItemOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseNewSubscriptionProductItemOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseConvertSubscriptionProductItemOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchasePointsProductItemOutput))]
    public partial class PurchaseProductItemOutput : object
    {

        

        private string ExternalProductItemIdField;

        private string ProductItemIdField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalProductItemId
        {
            get
            {
                return this.ExternalProductItemIdField;
            }
            set
            {
                this.ExternalProductItemIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemId
        {
            get
            {
                return this.ProductItemIdField;
            }
            set
            {
                this.ProductItemIdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseContentProductItemOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseContentProductItemOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemOutput
    {
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseNewSubscriptionProductItemOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseNewSubscriptionProductItemOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemOutput
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] AddedServiceInstanceSetField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEventsField;

        private System.DateTime SubscriptionEndDateField;

        private System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDateField;

        private string SubscriptionIdField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] AddedServiceInstanceSet
        {
            get
            {
                return this.AddedServiceInstanceSetField;
            }
            set
            {
                this.AddedServiceInstanceSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime SubscriptionEndDate
        {
            get
            {
                return this.SubscriptionEndDateField;
            }
            set
            {
                this.SubscriptionEndDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDate
        {
            get
            {
                return this.SubscriptionFirstCycleChargeDateField;
            }
            set
            {
                this.SubscriptionFirstCycleChargeDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionId
        {
            get
            {
                return this.SubscriptionIdField;
            }
            set
            {
                this.SubscriptionIdField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchaseConvertSubscriptionProductItemOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseConvertSubscriptionProductItemOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemOutput
    {

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] AddedServiceInstanceSetField;

        private int MonthExtendedField;

        private System.Nullable<decimal> PotentialRefundAmountField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEventsField;

        private int RemainingDaysinOldSubsField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] RemovededServiceInstanceSetField;

        private System.Nullable<int> RoundBoundaryField;

        private Microsoft.XBox.Live.Server.Emulators.TransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfoField;

        private System.DateTime SubscriptionEndDateField;

        private System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDateField;

        private string SubscriptionIdField;

        private System.Nullable<decimal> TimeConversionRatioField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] AddedServiceInstanceSet
        {
            get
            {
                return this.AddedServiceInstanceSetField;
            }
            set
            {
                this.AddedServiceInstanceSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int MonthExtended
        {
            get
            {
                return this.MonthExtendedField;
            }
            set
            {
                this.MonthExtendedField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> PotentialRefundAmount
        {
            get
            {
                return this.PotentialRefundAmountField;
            }
            set
            {
                this.PotentialRefundAmountField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public int RemainingDaysinOldSubs
        {
            get
            {
                return this.RemainingDaysinOldSubsField;
            }
            set
            {
                this.RemainingDaysinOldSubsField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.ServiceInstance[] RemovededServiceInstanceSet
        {
            get
            {
                return this.RemovededServiceInstanceSetField;
            }
            set
            {
                this.RemovededServiceInstanceSetField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> RoundBoundary
        {
            get
            {
                return this.RoundBoundaryField;
            }
            set
            {
                this.RoundBoundaryField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public Microsoft.XBox.Live.Server.Emulators.TransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfo
        {
            get
            {
                return this.SubsTimeExtensionInfoField;
            }
            set
            {
                this.SubsTimeExtensionInfoField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime SubscriptionEndDate
        {
            get
            {
                return this.SubscriptionEndDateField;
            }
            set
            {
                this.SubscriptionEndDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDate
        {
            get
            {
                return this.SubscriptionFirstCycleChargeDateField;
            }
            set
            {
                this.SubscriptionFirstCycleChargeDateField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionId
        {
            get
            {
                return this.SubscriptionIdField;
            }
            set
            {
                this.SubscriptionIdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> TimeConversionRatio
        {
            get
            {
                return this.TimeConversionRatioField;
            }
            set
            {
                this.TimeConversionRatioField = value;
            }
        }
    }

    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "PurchasePointsProductItemOutput", Namespace = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchasePointsProductItemOutput : Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseProductItemOutput
    {

        private string PointsPurchaseInstanceIdField;

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PointsPurchaseInstanceId
        {
            get
            {
                return this.PointsPurchaseInstanceIdField;
            }
            set
            {
                this.PointsPurchaseInstanceIdField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01", ConfigurationName="Microsoft.XBox.Live.Server.Emulators.TransactionService.TransactionService")]
    public interface TransactionService
    {

        [System.ServiceModel.OperationContractAttribute(Action = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Te" +
            "stConnection", ReplyAction = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/TestConnectionResponse")]
        string TestConnection(string inputString);

        [System.ServiceModel.OperationContractAttribute(Action = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Pu" +
            "rchase", ReplyAction = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/PurchaseResponse")]
        Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseOutput Purchase(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseInput purchaseInput);

        [System.ServiceModel.OperationContractAttribute(Action = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Pa" +
            "yout", ReplyAction = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/PayoutResponse")]
        Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOutput Payout(Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutInput PayoutInput);

        [System.ServiceModel.OperationContractAttribute(Action = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Jo" +
            "inSubscription", ReplyAction = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/JoinSubscriptionResponse")]
        Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionOutput JoinSubscription(Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionInput joinSubscriptionInput);

        [System.ServiceModel.OperationContractAttribute(Action = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Mi" +
            "grateAccount", ReplyAction = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/MigrateAccountResponse")]
        Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountOutput MigrateAccount(Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountInput migrateAccountInput);

        [System.ServiceModel.OperationContractAttribute(Action = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Ge" +
            "tPayoutOrderStatus", ReplyAction = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/GetPayoutOrderStatusResponse")]
        Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderStatusOutput GetPayoutOrderStatus(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderStatusInput GetPayoutOrderStatusInput);

        [System.ServiceModel.OperationContractAttribute(Action = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Ge" +
            "tPayoutOrderEventUpdate", ReplyAction = "urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/GetPayoutOrderEventUpdateResponse")]
        Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderEventUpdateOutput GetPayoutOrderEventUpdate(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderEventUpdateInput GetPayoutOrderEventUpdateInput);
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface TransactionServiceChannel : Microsoft.XBox.Live.Server.Emulators.TransactionService.TransactionService, System.ServiceModel.IClientChannel
    {
    }


    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class TransactionServiceClient : System.ServiceModel.ClientBase<Microsoft.XBox.Live.Server.Emulators.TransactionService.TransactionService>, Microsoft.XBox.Live.Server.Emulators.TransactionService.TransactionService
    {

        public TransactionServiceClient()
        {
        }

        public TransactionServiceClient(string endpointConfigurationName) :
            base(endpointConfigurationName)
        {
        }

        public TransactionServiceClient(string endpointConfigurationName, string remoteAddress) :
            base(endpointConfigurationName, remoteAddress)
        {
        }

        public TransactionServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
            base(endpointConfigurationName, remoteAddress)
        {
        }

        public TransactionServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
            base(binding, remoteAddress)
        {
        }

        public string TestConnection(string inputString)
        {
            return base.Channel.TestConnection(inputString);
        }

        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseOutput Purchase(Microsoft.XBox.Live.Server.Emulators.TransactionService.PurchaseInput purchaseInput)
        {
            return base.Channel.Purchase(purchaseInput);
        }

        public Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutOutput Payout(Microsoft.XBox.Live.Server.Emulators.TransactionService.PayoutInput PayoutInput)
        {
            return base.Channel.Payout(PayoutInput);
        }

        public Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionOutput JoinSubscription(Microsoft.XBox.Live.Server.Emulators.TransactionService.JoinSubscriptionInput joinSubscriptionInput)
        {
            return base.Channel.JoinSubscription(joinSubscriptionInput);
        }

        public Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountOutput MigrateAccount(Microsoft.XBox.Live.Server.Emulators.TransactionService.MigrateAccountInput migrateAccountInput)
        {
            return base.Channel.MigrateAccount(migrateAccountInput);
        }

        public Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderStatusOutput GetPayoutOrderStatus(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderStatusInput GetPayoutOrderStatusInput)
        {
            return base.Channel.GetPayoutOrderStatus(GetPayoutOrderStatusInput);
        }

        public Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderEventUpdateOutput GetPayoutOrderEventUpdate(Microsoft.XBox.Live.Server.Emulators.TransactionService.GetPayoutOrderEventUpdateInput GetPayoutOrderEventUpdateInput)
        {
            return base.Channel.GetPayoutOrderEventUpdate(GetPayoutOrderEventUpdateInput);
        }
    }
}
namespace Microsoft.Transaction.Interfaces
{
    using System.Runtime.Serialization;


    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "ExtendReasonCode", Namespace = "http://schemas.datacontract.org/2004/07/Microsoft.Transaction.Interfaces")]
    public enum ExtendReasonCode : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        NormalExtend = 10,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        FlexibleExtend = 11,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\Helpers.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    
    public static class Arrays
    {
        public static bool Equal<T>(T[] one, T[] other) 
        {
            if (one == null && other == null)
                return true;
            else if (one == null || other == null)
                return false;
            
            if (one.Length != other.Length)
                return false;
            
            for (int i =0; i < one.Length; i++) 
                if (!Object.Equals(one[i],other[i]))
                    return false;
            
            return true;
        }

        public static int GetHashCode<T>(T[] one) 
        {
            if (one == null || one.Length == 0)
                return 0;
            int result = 0;
            for (int i =0; i <one.Length; i++)
                result ^= one[i].GetHashCode();
            
            return result;
        }
        
    }

    public static class Helpers 
    {
        public static int GetHashCode<T> (T obj) where T : class
        {
            return (obj == null)?0:obj.GetHashCode();
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\LastCall.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework 
{
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;

    public static class LastCall 
    {
        public static IMethodCallOptions On(object transparentProxy) 
        {
            RecordingProxy rp = (RecordingProxy)RemotingServices.GetRealProxy(transparentProxy);
            Recording recording = rp.Recording;
            return recording.LastCall;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\Is.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    public static class Is 
    {
        public static IConstraint Any()
        {
            return new IgnoreConstraint();
            
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\MethodCall.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    using System.Collections;
    using System.Runtime.Remoting.Messaging;
    using System.Web.Services.Protocols;
    using System.Text;
    using System.Threading;
    using System.Xml;


    [Serializable]
    public class MethodCall : IMethodCallOptions
    {
        [Serializable]
        internal class XmlNodeOutArgument
        {
            internal string Xml;

            internal XmlNodeOutArgument(XmlNode xmlNode)
            {
                this.Xml = xmlNode.OuterXml;
            }

            internal XmlNode ToXmlNode()
            {
                var doc = new XmlDocument();
                doc.LoadXml(Xml);
                return doc.FirstChild;
            }
        }

        public string Name;
        public object[] InputParameters;
        public object[] OutputParameters;
        public object ReturnValue;
        public Exception Exception;
        public string SoapExceptionDetail;
        public TimeSpan WaitInterval = TimeSpan.Zero;
        private IConstraint[] argConstraints;

        private bool closesConnection = false;

        IMethodCallOptions IMethodCallOptions.Returns(object returnValue)
        {
            if (returnValue is XmlNode)
                ReturnValue = new XmlNodeOutArgument(returnValue as XmlNode);
            else 
                ReturnValue = returnValue;
            return this;
        }

        IMethodCallOptions IMethodCallOptions.Throws(Exception exception)
        {
            Exception = exception;
            SoapException se = exception as SoapException;
            if (se != null && se.Detail != null)
            {
                SoapExceptionDetail = se.Detail.OuterXml;
            }

            return this;
        }

        IMethodCallOptions IMethodCallOptions.Argument(int argIndex, IConstraint constraint)
        {
            if (argIndex < 0 || argIndex >= argConstraints.Length)
                throw new ArgumentException("argIndex is out of range");
            this.argConstraints[argIndex] = constraint;
            return this;
        }

        IMethodCallOptions IMethodCallOptions.Arguments(params IConstraint[] constraints)
        {
            if (constraints.Length != argConstraints.Length)
                throw new ArgumentException(String.Format("Number of constraints {0} is not equal to number of input parameters {1}", constraints.Length, argConstraints.Length));
            for (int argIndex = 0; argIndex < argConstraints.Length; argIndex++)
                this.argConstraints[argIndex] = constraints[argIndex];
            return this;
        }

        IMethodCallOptions IMethodCallOptions.IgnoresArgument(int argIndex)
        {
            return ((IMethodCallOptions)this).Argument(argIndex, new IgnoreConstraint());
        }

        IMethodCallOptions IMethodCallOptions.ClosesConnection()
        {
            closesConnection = true;
            return this;
        }

        IMethodCallOptions IMethodCallOptions.OutArguments(params object[] outArgs)
        {
            this.OutputParameters = new object[outArgs.Length];
            for (int i = 0; i < outArgs.Length; i++)
                if (outArgs[i] is XmlNode)
                    this.OutputParameters[i] = new XmlNodeOutArgument((XmlNode)outArgs[i]);
                else
                    this.OutputParameters[i] = outArgs[i];

            return this;
        }

        IMethodCallOptions IMethodCallOptions.ExpectedAnytime()
        {
            throw new NotImplementedException("Temporary until MethodCall IMethodCallOptions have not been moved to CallHolder");
        }

        IMethodCallOptions IMethodCallOptions.Waits(TimeSpan interval)
        {
            throw new NotImplementedException("Temporary until MethodCall IMethodCallOptions have not been moved to CallHolder");
        }


        public MethodCall(IMethodCallMessage msg)
        {
            this.InputParameters = new object[msg.InArgCount];
            this.argConstraints = new IConstraint[msg.InArgCount];
            this.OutputParameters = new object[0];

            this.Name = msg.MethodName;
            for (int i = 0; i < msg.InArgCount; i++)
            {
                object arg = msg.GetInArg(i);
                this.InputParameters[i] = arg;
                if (arg is ICollection)
                    this.argConstraints[i] = new CollectionEqualConstraint(InputParameters[i]);
                else
                    this.argConstraints[i] = new EqualConstraint(InputParameters[i]);
            }

        }

        public void Verify(string methodName, IEnumerable args)
        {
            if (this.Name != methodName)
            {
                throw new ExpectationException(String.Format("Unexpected method call: Expected {0} but received {1}", this.Name, methodName));
            }

            int i = 0;
            StringBuilder allErrors = new StringBuilder();
            foreach (object arg in args)
            {
                string errorMessage;

                if (!this.argConstraints[i].Verify(arg, out errorMessage))
                {
                    allErrors.AppendFormat("Argument {0}: {1}", i, errorMessage);
                    allErrors.AppendLine();
                }
                i++;
            }
            if (allErrors.Length > 0)
                throw new ExpectationException(String.Format("Argument verification failed for method {0}.\n{1}", this.Name, allErrors.ToString()));

        }

        public void Verify(MethodCall call)
        {
            Verify(call.Name, call.InputParameters);
        }

        public void Verify(IMethodCallMessage msg)
        {
            Verify(msg.MethodName, EnumerateInArgs(msg));
        }

        private IEnumerable EnumerateInArgs(IMethodCallMessage msg)
        {
            for (int i = 0; i < msg.InArgCount; i++)
            {
                yield return msg.GetInArg(i);
            }

        }


        public IMessage CreateReturnMessage(IMethodCallMessage call)
        {
            if (WaitInterval != TimeSpan.Zero)
            {
                Thread.Sleep(WaitInterval);
            }

            if (closesConnection)
            {
                System.Web.HttpContext.Current.Response.Close();
            }

            if (Exception != null)
            {
                SoapException se = Exception as SoapException;
                if (se != null && !String.IsNullOrEmpty(SoapExceptionDetail))
                {
                    XmlDocument doc = new XmlDocument();
                    doc.LoadXml(SoapExceptionDetail);
                    Exception = new SoapException(se.Message, se.Code, se.Actor, se.Role, se.Lang, doc.DocumentElement, se.SubCode, se.InnerException);
                }

                return new ReturnMessage(Exception, call);
            }
            else
            {
                for (int i = 0; i < OutputParameters.Length; i++)
                {
                    var xmlArg = OutputParameters[i] as XmlNodeOutArgument;
                    if (xmlArg != null)
                        OutputParameters[i] = xmlArg.ToXmlNode();
                }
                var xmlRet = ReturnValue as XmlNodeOutArgument;
                if (xmlRet != null)
                    ReturnValue = xmlRet.ToXmlNode();
                return new ReturnMessage(ReturnValue, OutputParameters, OutputParameters.Length, null, call);
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\Recorder.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework 
{
    using System;
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Proxies;
    using System.Runtime.Remoting.Messaging;
    
    public static class Recorder 
    {
        public static T StartRecording<T>() where T : class
        {
            RealProxy rp = new RecordingProxy(typeof(T));
            T tp = (T)rp.GetTransparentProxy();
            return tp;
        }

        public static Recording StopRecording(object transparentProxy) 
        {
            RecordingProxy rp = (RecordingProxy)RemotingServices.GetRealProxy(transparentProxy);
            return rp.Recording;
        }

        public static Recording GetRecording(object transparentProxy) 
        {
            RecordingProxy rp = (RecordingProxy)RemotingServices.GetRealProxy(transparentProxy);
            return rp.Recording;
        }

        public static void SetRecordingGuid(object transparentProxy, Guid guid) 
        {
            RecordingProxy rp = (RecordingProxy)RemotingServices.GetRealProxy(transparentProxy);
            rp.RecordingGuid = guid;
        }

        public static Guid GetRecordingGuid(object transparentProxy) 
        {
            RecordingProxy rp = (RecordingProxy)RemotingServices.GetRealProxy(transparentProxy);
            return rp.RecordingGuid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\Xml.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System.Xml;

    public static class Xml 
    {
        public static IConstraint HasNodes(string nsPrefix, string xmlNamespace, string xpathQuery)
        {
            return new XmlHasNodesConstraint(nsPrefix, xmlNamespace, xpathQuery, false, null);
        }

        public static IConstraint HasNodes(string nsPrefix, string xmlNamespace, string xpathQuery, string nodeInnerText)
        {
            return new XmlHasNodesConstraint(nsPrefix, xmlNamespace, xpathQuery, false, nodeInnerText);
        }

        public static IConstraint NotHasNodes(string nsPrefix, string xmlNamespace, string xpathQuery)
        {
            return new XmlHasNodesConstraint(nsPrefix, xmlNamespace, xpathQuery, true, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\XmlHasNodesConstraint.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    using System.Xml;
    using System.Xml.XPath;
        
    [Serializable]
    public class XmlHasNodesConstraint: IConstraint
    {
        string xmlNamespace;
        string nsPrefix;
        string xpathQuery;
        bool checkNotHasNodes = false;
        string nodeInnerText = null;

        public XmlHasNodesConstraint(string nsPrefix, string xmlNamespace, string xpathQuery, bool checkNotHasNodes, string nodeInnerText) 
        {
            this.nsPrefix = nsPrefix;
            this.xmlNamespace = xmlNamespace;
            this.xpathQuery = xpathQuery;
            this.checkNotHasNodes = checkNotHasNodes;
            this.nodeInnerText = nodeInnerText;
            // when checking the xml not having some specific nodes, we ignore the nodeInnerText passed in
            if (this.checkNotHasNodes)
                this.nodeInnerText = null;
        }
        
        public bool Verify(object got, out string errorMessage) 
        {
            errorMessage = String.Empty;
            
            if (got.GetType() != typeof(string)) 
            {
                errorMessage = String.Format("Expected argument of type String, got {0}", got.GetType().FullName);
                return false;
            }
            
            XmlDocument doc = new XmlDocument();
            try 
            {
                doc.LoadXml(got as string);
            }
            catch (XmlException) 
            {
                errorMessage = "Expected argument to be well-formed xml document";
                return false;
            }
            
            XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);
            nsmgr.AddNamespace(nsPrefix, xmlNamespace);
            XmlNodeList results = doc.SelectNodes(xpathQuery, nsmgr);
            if (results.Count == 0 && !checkNotHasNodes) 
            {
                errorMessage = String.Format("XPath query {0} did not find matching nodes in xml listed below\n{1}", xpathQuery, got as string);
                return false;
            }
            else if (results.Count > 0 && checkNotHasNodes)
            {
                errorMessage = String.Format("XPath query {0} did find matching nodes in xml listed below\n{1}", xpathQuery, got as string);
                return false;
            }

            if (nodeInnerText != null)
            {
                // only check the first node
                if (results[0].InnerText.ToLower() != nodeInnerText)
                {
                    errorMessage = String.Format("XPath query {0} didn't find the expected node in xml listed below\nExpecting node: {1}, got: {2}\n{3}",
                        xpathQuery, nodeInnerText, results[0].InnerText, got as string);
                    return false;
                }
            }

            return true;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\RecordingProxy.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework 
{
    using System;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Proxies;

    class RecordingProxy: RealProxy 
    {
        private Recording recording = new Recording();
        public Guid RecordingGuid;
        
        public Recording Recording 
        {
            get 
            {
                return recording;
            }
        }


        public RecordingProxy(Type targetType)
            : base(targetType) 
        {
        }
        
        public override IMessage Invoke (IMessage msg) 
        {
            
            MethodCall call = new MethodCall((IMethodCallMessage)msg);
            Recording.Add(call);

            return new ReturnMessage(null, null, 0, null, (IMethodCallMessage)msg);
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\Aggregator\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\Recording.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.Framework
{
    using System;
    using System.Text;
    using System.Collections.Generic;
    using System.IO;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Remoting.Messaging;

    
    [Serializable]
    public class Recording 
    {
        private int position = 0;
        internal List<MethodCall> orderedCalls = new List<MethodCall>();
        internal Dictionary<string, MethodCall> stubs = new Dictionary<string, MethodCall>();
        

        [NonSerialized] 
        private CallHolder lastCall;
        public IMethodCallOptions LastCall 
        {
            get 
            {
                return lastCall;
            }
        }
        
        public string ToBase64String() 
        {
            if(lastCall != null ) 
            {
                lastCall.AddToRecording(this);
            }

            MemoryStream m = new MemoryStream();
            BinaryFormatter f = new BinaryFormatter();
            f.Serialize(m, this);
            m.Close();
            return Convert.ToBase64String(m.ToArray());
        }

        public override string ToString() 
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendFormat("Recording has {0} method calls",  orderedCalls.Count);
            sb.AppendLine();
            foreach (MethodCall call in orderedCalls) 
            {
                sb.AppendFormat("\tMethod {0}", call.Name);
                sb.AppendLine();
                sb.Append("\tInput Parameters: ");
                foreach(object ip in call.InputParameters) 
                {
                    sb.Append(ip);
                    sb.Append(" ");
                }
                sb.AppendLine();
                
                sb.AppendFormat("\tExpected ReturnValue: {0}", (call.ReturnValue == null)?"null":call.ReturnValue);
                sb.AppendLine();
                
                sb.AppendFormat("\tExpected exception {0}", (call.Exception == null)?"null":call.Exception.ToString());
                sb.AppendLine();
                
            }
            return sb.ToString();
        }

        public void Compare(Recording r) 
        {
            if (this.orderedCalls.Count > r.orderedCalls.Count)
                throw new ExpectationException(String.Format("Expected {0} methods to be called, only {1} were called", this.orderedCalls.Count, r.orderedCalls.Count));
            if (this.orderedCalls.Count < r.orderedCalls.Count)
                throw new Exception("This should not happen, inform sergs@microsoft.com");
            
            for (int i = 0; i < this.orderedCalls.Count; i++)
            {
                this.orderedCalls[i].Verify(r.orderedCalls[i]);
            }
        }

        public IMessage VerifyAndRecord(IMethodCallMessage call, Recording log) 
        {
            if (stubs.ContainsKey(call.MethodName)) 
            {
                return stubs[call.MethodName].CreateReturnMessage(call);
            }
            
            MethodCall current = GetCurrent();
            if (current == null) 
            {
                throw new ExpectationException("No method calls are expected at this moment");
            }
            
            log.Add(new MethodCall(call));
            current.Verify(call);
            return current.CreateReturnMessage(call);
        }
        
        
        private MethodCall GetCurrent() 
        {
            if (position == this.orderedCalls.Count)
                return null;
            return this.orderedCalls[position++];
        }

        public void Add(MethodCall call) 
        {
            if(lastCall != null ) 
            {
                lastCall.AddToRecording(this);
            }
            lastCall = new CallHolder(call);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\Aggregator\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\Aggregator\AggregatorEmulator.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.Aggregator
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public class AggregatorEmulator : EmulatorFacadeBase<IAggregatorSoap>
    {
        protected override string HandlerName
        {
            get
            {
                return "AggregatorEmulator.asmx";
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\Aggregator\AggregatorStub.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.Aggregator
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    [Emulate]
    public class AggregatorStub : ContextBoundObject, IAggregatorSoap
    {
        public int? GetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\MultiRating\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\framework\wsdl\Controller.wsdl.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.5448
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.Client {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ControllerSoap", Namespace="http://tempuri.org/")]
    public partial class Controller : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AddCallSequenceOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetCallRecordOperationCompleted;
        
        /// <remarks/>
        public Controller() {
            this.Url = "http://localhost/MusicNetEmulator/Controller.asmx";
        }
        
        /// <remarks/>
        public event AddCallSequenceCompletedEventHandler AddCallSequenceCompleted;
        
        /// <remarks/>
        public event GetCallRecordCompletedEventHandler GetCallRecordCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/AddCallSequence", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.Guid AddCallSequence(string encodedRecording) {
            object[] results = this.Invoke("AddCallSequence", new object[] {
                        encodedRecording});
            return ((System.Guid)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddCallSequence(string encodedRecording, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddCallSequence", new object[] {
                        encodedRecording}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Guid EndAddCallSequence(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Guid)(results[0]));
        }
        
        /// <remarks/>
        public void AddCallSequenceAsync(string encodedRecording) {
            this.AddCallSequenceAsync(encodedRecording, null);
        }
        
        /// <remarks/>
        public void AddCallSequenceAsync(string encodedRecording, object userState) {
            if ((this.AddCallSequenceOperationCompleted == null)) {
                this.AddCallSequenceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCallSequenceOperationCompleted);
            }
            this.InvokeAsync("AddCallSequence", new object[] {
                        encodedRecording}, this.AddCallSequenceOperationCompleted, userState);
        }
        
        private void OnAddCallSequenceOperationCompleted(object arg) {
            if ((this.AddCallSequenceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCallSequenceCompleted(this, new AddCallSequenceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetCallRecord", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetCallRecord(System.Guid guid) {
            object[] results = this.Invoke("GetCallRecord", new object[] {
                        guid});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetCallRecord(System.Guid guid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetCallRecord", new object[] {
                        guid}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetCallRecord(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetCallRecordAsync(System.Guid guid) {
            this.GetCallRecordAsync(guid, null);
        }
        
        /// <remarks/>
        public void GetCallRecordAsync(System.Guid guid, object userState) {
            if ((this.GetCallRecordOperationCompleted == null)) {
                this.GetCallRecordOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetCallRecordOperationCompleted);
            }
            this.InvokeAsync("GetCallRecord", new object[] {
                        guid}, this.GetCallRecordOperationCompleted, userState);
        }
        
        private void OnGetCallRecordOperationCompleted(object arg) {
            if ((this.GetCallRecordCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetCallRecordCompleted(this, new GetCallRecordCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCallSequenceCompletedEventHandler(object sender, AddCallSequenceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCallSequenceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCallSequenceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public System.Guid Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((System.Guid)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCallRecordCompletedEventHandler(object sender, GetCallRecordCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCallRecordCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCallRecordCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\MultiRating\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\MultiRating\MultiRatingEmulator.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.MultiRating
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public class MultiRatingEmulator : EmulatorFacadeBase<IMultiRatingSoap>
    {
        protected override string HandlerName
        {
            get
            {
                return "MultiRatingEmulator.asmx";
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\Aggregator\AggregatorSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.Aggregator {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AggregatorSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public interface IAggregatorSoap {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetDeltaRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaUnauthRatingAverages", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetDeltaUnauthRatingAverages(System.Guid contentTypeID, System.DateTime fromTime, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAveragesWithReviewCount", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetDeltaRatingAveragesWithReviewCount", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetDeltaRatingAveragesWithReviewCount(System.Guid contentTypeID, System.DateTime fromTime, bool returnRatingAttributes, ref string transactionToken, out System.DateTime transactionStartTime, out System.Xml.XmlNode results);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\NickNameListener\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\MultiRating\MultiRatingStub.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.MultiRating
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    [Emulate]
    public class MultiRatingStub : ContextBoundObject, IMultiRatingSoap
    {
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetNickname(long puid, System.Guid msnGuid, out string nickname)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetNicknameSuggestions(string seed, out string[] suggestionList)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingAverage(System.Guid contentTypeID, object itemID, out Rating rating)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out Rating rating)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out Rating[] ratings)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, out Review[] Reviews)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, out Review[] Reviews)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, out Review[] Reviews)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\NickNameListener\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\MultiRating\MultiRatingTypes.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.MultiRating
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public partial class ValidationError
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            ValidationError ve = (ValidationError)obj;
            return (
                DataField == ve.DataField &&
                Code == ve.Code &&
                ID == ve.ID &&
                MaxLength == ve.MaxLength);
        }

        public override int GetHashCode()
        {
            return (
                DataField.GetHashCode() ^
                Code.GetHashCode() ^
                ID.GetHashCode() ^
                MaxLength);
        }
    }

    public partial class Helpfulness
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            Helpfulness h = (Helpfulness)obj;
            return (
                Count == h.Count &&
                Sum == h.Sum &&
                Error == h.Error &&
                ErrorSpecified == h.ErrorSpecified &&
                CurrentUser == h.CurrentUser &&
                CurrentUserSpecified == h.CurrentUserSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Count ^
                Sum ^
                Error ^
                ErrorSpecified.GetHashCode() ^
                CurrentUser.GetHashCode() ^
                CurrentUserSpecified.GetHashCode());
        }
    }

    public partial class ReviewField
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            ReviewField rf = (ReviewField)obj;
            return (
                Error == rf.Error &&
                ErrorSpecified == rf.ErrorSpecified &&
                ID == rf.ID &&
                IDSpecified == rf.IDSpecified &&
                Label == rf.Label &&
                MaxLength == rf.MaxLength &&
                MaxLengthSpecified == rf.MaxLengthSpecified &&
                Cols == rf.Cols &&
                ColsSpecified == rf.ColsSpecified &&
                Rows == rf.Rows &&
                RowsSpecified == rf.RowsSpecified &&
                Rank == rf.Rank &&
                RankSpecified == rf.RankSpecified &&
                Required == rf.Required &&
                RequiredSpecified == rf.RequiredSpecified &&
                Description == rf.Description &&
                Value == rf.Value);
        }

        public override int GetHashCode()
        {
            return (
                Error ^
                ErrorSpecified.GetHashCode() ^
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Helpers.GetHashCode(Label) ^
                MaxLength ^
                MaxLengthSpecified.GetHashCode() ^
                Cols ^
                ColsSpecified.GetHashCode() ^
                Rows ^
                RowsSpecified.GetHashCode() ^
                Rank ^
                RankSpecified.GetHashCode() ^
                Required.GetHashCode() ^
                RequiredSpecified.GetHashCode() ^
                Helpers.GetHashCode(Description) ^
                Helpers.GetHashCode(Value));
        }
    }

    public partial class User
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            User u = (User)obj;
            return (
                Nickname == u.Nickname &&
                ID == u.ID &&
                IDSpecified == u.IDSpecified &&
                Error == u.Error &&
                ErrorSpecified == u.ErrorSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Helpers.GetHashCode(Nickname) ^
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Error ^
                ErrorSpecified.GetHashCode());
        }
    }

    public partial class Review
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            Review r = (Review)obj;
            return (
                Item == r.Item &&
                Date == r.Date &&
                DateSpecified == r.DateSpecified &&
                User == r.User &&
                CustomProperty == r.CustomProperty &&
                Rating == r.Rating &&
                Title == r.Title &&
                Arrays.Equal(Field, r.Field) &&
                Helpfulness == r.Helpfulness &&
                ID == r.ID &&
                IDSpecified == r.IDSpecified &&
                Error == r.Error &&
                ErrorSpecified == r.ErrorSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Item.GetHashCode() ^
                Date.GetHashCode() ^
                DateSpecified.GetHashCode() ^
                User.GetHashCode() ^
                CustomProperty.GetHashCode() ^
                Rating.GetHashCode() ^
                Title.GetHashCode() ^
                Arrays.GetHashCode(Field) ^
                Helpfulness.GetHashCode() ^
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Error ^
                ErrorSpecified.GetHashCode());
        }
    }

    public partial class ItemID
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            ItemID id = (ItemID)obj;
            return (
                StringID == id.StringID &&
                Arrays.Equal(LongID, id.LongID) &&
                GuidID == id.GuidID &&
                GuidIDSpecified == id.GuidIDSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Helpers.GetHashCode(StringID) ^
                Arrays.GetHashCode(LongID) ^
                GuidID.GetHashCode() ^
                GuidIDSpecified.GetHashCode());
        }
    }

    public partial class Rating
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            Rating r = (Rating)obj;
            return (
                Item == r.Item &&
                Arrays.Equal(RatingItem, r.RatingItem) &&
                OverallRating == r.OverallRating &&
                Date == r.Date &&
                DateSpecified == r.DateSpecified &&
                Error == r.Error &&
                ErrorSpecified == r.ErrorSpecified &&
                TotalCount == r.TotalCount &&
                TotalCountSpecified == r.TotalCountSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Item.GetHashCode() ^
                Arrays.GetHashCode(RatingItem) ^
                OverallRating.GetHashCode() ^
                Date.GetHashCode() ^
                DateSpecified.GetHashCode() ^
                Error ^
                ErrorSpecified.GetHashCode() ^
                TotalCount ^
                TotalCountSpecified.GetHashCode());
        }
    }

    public partial class RatingAttribute
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            RatingAttribute ra = (RatingAttribute)obj;
            return (
                AverageValue == ra.AverageValue &&
                AverageValueSpecified == ra.AverageValueSpecified &&
                UserValue == ra.UserValue &&
                UserValueSpecified == ra.UserValueSpecified &&
                Count == ra.Count &&
                CountSpecified == ra.CountSpecified &&
                base.Equals((RatingItem)obj));
        }

        public override int GetHashCode()
        {
            return (
                AverageValue.GetHashCode() ^
                AverageValueSpecified.GetHashCode() ^
                UserValue ^
                UserValueSpecified.GetHashCode() ^
                Count ^
                CountSpecified.GetHashCode() ^
                base.GetHashCode());
        }
    }

    public partial class RatingItem
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            RatingItem ri = (RatingItem)obj;
            return (
                ID == ri.ID &&
                IDSpecified == ri.IDSpecified &&
                Label == ri.Label &&
                Error == ri.Error &&
                ErrorSpecified == ri.ErrorSpecified &&
                Description == ri.Description &&
                Rank == ri.Rank &&
                RankSpecified == ri.RankSpecified &&
                Required == ri.Required &&
                RequiredSpecified == ri.RequiredSpecified);
        }

        public override int GetHashCode()
        {
            return (
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Helpers.GetHashCode(Label) ^
                Error ^
                ErrorSpecified.GetHashCode() ^
                Helpers.GetHashCode(Description) ^
                Rank ^
                RankSpecified.GetHashCode() ^
                Required.GetHashCode() ^
                RequiredSpecified.GetHashCode());
        }
    }

    public partial class OverallRating
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            OverallRating or = (OverallRating)obj;
            return (
                AverageValue == or.AverageValue &&
                AverageValueSpecified == or.AverageValueSpecified &&
                UserValue == or.UserValue &&
                UserValueSpecified == or.UserValueSpecified &&
                base.Equals((RatingItem)obj));
        }

        public override int GetHashCode()
        {
            return (
                AverageValue.GetHashCode() ^
                AverageValueSpecified.GetHashCode() ^
                UserValue.GetHashCode() ^
                UserValueSpecified.GetHashCode() ^
                base.GetHashCode());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\NickNameListener\NickNameListenerStub.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.NickNameListener
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    [Emulate]
    public class NickNameListenerStub : ContextBoundObject, IRRListenerSoap
    {
        public int? OnNotificationReceive(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\NickNameListener\NickNameListenerEmulator.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.NickNameListener
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public class NickNameListenerEmulator : EmulatorFacadeBase<IRRListenerSoap>
    {
        protected override string HandlerName
        {
            get
            {
                return "NickNameListenerEmulator.asmx";
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\SingleRating\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\MultiRating\MultiRatingSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.MultiRating {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="MultiRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public interface IMultiRatingSoap {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetNickname(long puid, System.Guid msnGuid, out string nickname);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetNicknameSuggestions(string seed, out string[] suggestionList);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingAverage(System.Guid contentTypeID, object itemID, out Rating rating);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out Rating rating);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Rating rating);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out Rating[] ratings);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] out Review[] Reviews);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] out Review[] Reviews);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] out Review[] Reviews);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, System.Guid[] ratingIDs, int[] ratingValues, System.DateTime updateDate, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, System.DateTime updateDate, string nickname);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveUnauthRatings(System.Guid contentTypeID, object itemID, System.Guid ratingAttributeID, int[] ratingScores, int[] ratingCountDeltas);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, System.Guid[] ratingIDs, int[] ratingValues, string customProperty, out ValidationError[] errors);
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ValidationError {
        
        private Field dataFieldField;
        
        private Type codeField;
        
        private System.Guid idField;
        
        private int maxLengthField;
        
        /// <remarks/>
        public Field DataField {
            get {
                return this.dataFieldField;
            }
            set {
                this.dataFieldField = value;
            }
        }
        
        /// <remarks/>
        public Type Code {
            get {
                return this.codeField;
            }
            set {
                this.codeField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Field {
        
        /// <remarks/>
        empty,
        
        /// <remarks/>
        nickname,
        
        /// <remarks/>
        ratingItemID,
        
        /// <remarks/>
        reviewFieldID,
        
        /// <remarks/>
        title,
        
        /// <remarks/>
        customProperty,
        
        /// <remarks/>
        name,
        
        /// <remarks/>
        email,
        
        /// <remarks/>
        comments,
        
        /// <remarks/>
        score,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Type {
        
        /// <remarks/>
        RequiredFieldMissing,
        
        /// <remarks/>
        TextTooLong,
        
        /// <remarks/>
        TextInvalidChars,
        
        /// <remarks/>
        TextProfanity,
        
        /// <remarks/>
        InvalidFormat,
        
        /// <remarks/>
        TooManyChanges,
        
        /// <remarks/>
        AlreadyTaken,
        
        /// <remarks/>
        ReviewsRequireRatings,
        
        /// <remarks/>
        ReviewsRequireOneField,
        
        /// <remarks/>
        UserCannotRateOwnReview,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Helpfulness {
        
        private int countField;
        
        private int sumField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private bool currentUserField;
        
        private bool currentUserFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Sum {
            get {
                return this.sumField;
            }
            set {
                this.sumField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool CurrentUser {
            get {
                return this.currentUserField;
            }
            set {
                this.currentUserField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CurrentUserSpecified {
            get {
                return this.currentUserFieldSpecified;
            }
            set {
                this.currentUserFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ReviewField {
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int maxLengthField;
        
        private bool maxLengthFieldSpecified;
        
        private int colsField;
        
        private bool colsFieldSpecified;
        
        private int rowsField;
        
        private bool rowsFieldSpecified;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        private string descriptionField;
        
        private string valueField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool MaxLengthSpecified {
            get {
                return this.maxLengthFieldSpecified;
            }
            set {
                this.maxLengthFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Cols {
            get {
                return this.colsField;
            }
            set {
                this.colsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ColsSpecified {
            get {
                return this.colsFieldSpecified;
            }
            set {
                this.colsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rows {
            get {
                return this.rowsField;
            }
            set {
                this.rowsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RowsSpecified {
            get {
                return this.rowsFieldSpecified;
            }
            set {
                this.rowsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class User {
        
        private string nicknameField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Nickname {
            get {
                return this.nicknameField;
            }
            set {
                this.nicknameField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Review {
        
        private ItemID itemField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private User userField;
        
        private ReviewField customPropertyField;
        
        private Rating ratingField;
        
        private ReviewField titleField;
        
        private ReviewField[] fieldField;
        
        private Helpfulness helpfulnessField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public User User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField CustomProperty {
            get {
                return this.customPropertyField;
            }
            set {
                this.customPropertyField = value;
            }
        }
        
        /// <remarks/>
        public Rating Rating {
            get {
                return this.ratingField;
            }
            set {
                this.ratingField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Field")]
        public ReviewField[] Field {
            get {
                return this.fieldField;
            }
            set {
                this.fieldField = value;
            }
        }
        
        /// <remarks/>
        public Helpfulness Helpfulness {
            get {
                return this.helpfulnessField;
            }
            set {
                this.helpfulnessField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ItemID {
        
        private string stringIDField;
        
        private long[] longIDField;
        
        private System.Guid guidIDField;
        
        private bool guidIDFieldSpecified;
        
        /// <remarks/>
        public string StringID {
            get {
                return this.stringIDField;
            }
            set {
                this.stringIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LongID")]
        public long[] LongID {
            get {
                return this.longIDField;
            }
            set {
                this.longIDField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid GuidID {
            get {
                return this.guidIDField;
            }
            set {
                this.guidIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool GuidIDSpecified {
            get {
                return this.guidIDFieldSpecified;
            }
            set {
                this.guidIDFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Rating {
        
        private ItemID itemField;
        
        private RatingAttribute[] ratingItemField;
        
        private OverallRating overallRatingField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private int totalCountField;
        
        private bool totalCountFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("RatingItem")]
        public RatingAttribute[] RatingItem {
            get {
                return this.ratingItemField;
            }
            set {
                this.ratingItemField = value;
            }
        }
        
        /// <remarks/>
        public OverallRating OverallRating {
            get {
                return this.overallRatingField;
            }
            set {
                this.overallRatingField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int TotalCount {
            get {
                return this.totalCountField;
            }
            set {
                this.totalCountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool TotalCountSpecified {
            get {
                return this.totalCountFieldSpecified;
            }
            set {
                this.totalCountFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingAttribute : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private int userValueField;
        
        private bool userValueFieldSpecified;
        
        private int countField;
        
        private bool countFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CountSpecified {
            get {
                return this.countFieldSpecified;
            }
            set {
                this.countFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(OverallRating))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingAttribute))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingItem {
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private string descriptionField;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class OverallRating : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private float userValueField;
        
        private bool userValueFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\SingleRating\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\SingleRating\SingleRatingEmulator.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public class SingleRatingEmulator : EmulatorFacadeBase<ISingleRatingSoap>
    {
        protected override string HandlerName
        {
            get
            {
                return "SingleRatingEmulator.asmx";
            }
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\SingleRating\SingleRatingStub.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    [Emulate]
    public class SingleRatingStub : ContextBoundObject, ISingleRatingSoap
    {
        public System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetNickname(long puid, System.Guid msnGuid, out string nickname)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetNicknameSuggestions(string seed, out string[] suggestionList)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingAverage(System.Guid contentTypeID, object itemID, out float rating, out int count)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out float rating, out int count)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int rating)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int userRating, out float averageRating, out int count)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out int[] ratings)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, out Review[] Reviews)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, out Review[] Reviews)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, out Review[] Reviews)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? GetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? SaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

        public int? ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors)
        {
            throw new NotImplementedException("This is a stub. It should never be called directly");
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\NickNameListener\NickNameListenerSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.NickNameListener {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="RRListenerSoap", Namespace="http://www.msn.com/WebServices/SubscriberService/")]
    public interface IRRListenerSoap {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://www.msn.com/WebServices/SubscriberService/OnNotificationReceive", RequestNamespace="http://www.msn.com/WebServices/SubscriberService/", ResponseNamespace="http://www.msn.com/WebServices/SubscriberService/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? OnNotificationReceive(System.Guid publisherID, int eventTypeID, string resourceID, string extendedAttributes, System.DateTime eventDateTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\SingleRating\SingleRatingTypes.cs ===
﻿namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;

    public partial class ValidationError
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            ValidationError ve = (ValidationError)obj;
            return (
                DataField == ve.DataField &&
                Code == ve.Code &&
                ID == ve.ID &&
                MaxLength == ve.MaxLength);
        }

        public override int GetHashCode()
        {
            return (
                DataField.GetHashCode() ^
                Code.GetHashCode() ^
                ID.GetHashCode() ^
                MaxLength);
        }
    }

    public partial class Helpfulness
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            Helpfulness h = (Helpfulness)obj;
            return (
                Count == h.Count &&
                Sum == h.Sum &&
                Error == h.Error &&
                ErrorSpecified == h.ErrorSpecified &&
                CurrentUser == h.CurrentUser &&
                CurrentUserSpecified == h.CurrentUserSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Count ^
                Sum ^
                Error ^
                ErrorSpecified.GetHashCode() ^
                CurrentUser.GetHashCode() ^
                CurrentUserSpecified.GetHashCode());
        }
    }

    public partial class ReviewField
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            ReviewField rf = (ReviewField)obj;
            return (
                Error == rf.Error &&
                ErrorSpecified == rf.ErrorSpecified &&
                ID == rf.ID &&
                IDSpecified == rf.IDSpecified &&
                Label == rf.Label &&
                MaxLength == rf.MaxLength &&
                MaxLengthSpecified == rf.MaxLengthSpecified &&
                Cols == rf.Cols &&
                ColsSpecified == rf.ColsSpecified &&
                Rows == rf.Rows &&
                RowsSpecified == rf.RowsSpecified &&
                Rank == rf.Rank &&
                RankSpecified == rf.RankSpecified &&
                Required == rf.Required &&
                RequiredSpecified == rf.RequiredSpecified &&
                Description == rf.Description &&
                Value == rf.Value);
        }

        public override int GetHashCode()
        {
            return (
                Error ^
                ErrorSpecified.GetHashCode() ^
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Helpers.GetHashCode(Label) ^
                MaxLength ^
                MaxLengthSpecified.GetHashCode() ^
                Cols ^
                ColsSpecified.GetHashCode() ^
                Rows ^
                RowsSpecified.GetHashCode() ^
                Rank ^
                RankSpecified.GetHashCode() ^
                Required.GetHashCode() ^
                RequiredSpecified.GetHashCode() ^
                Helpers.GetHashCode(Description) ^
                Helpers.GetHashCode(Value));
        }
    }

    public partial class User
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            User u = (User)obj;
            return (
                Nickname == u.Nickname &&
                ID == u.ID &&
                IDSpecified == u.IDSpecified &&
                Error == u.Error &&
                ErrorSpecified == u.ErrorSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Helpers.GetHashCode(Nickname) ^
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Error ^
                ErrorSpecified.GetHashCode());
        }
    }

    public partial class Review
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            Review r = (Review)obj;
            return (
                Item == r.Item &&
                Date == r.Date &&
                DateSpecified == r.DateSpecified &&
                User == r.User &&
                CustomProperty == r.CustomProperty &&
                Rating == r.Rating &&
                Title == r.Title &&
                Arrays.Equal(Field, r.Field) &&
                Helpfulness == r.Helpfulness &&
                ID == r.ID &&
                IDSpecified == r.IDSpecified &&
                Error == r.Error &&
                ErrorSpecified == r.ErrorSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Item.GetHashCode() ^
                Date.GetHashCode() ^
                DateSpecified.GetHashCode() ^
                User.GetHashCode() ^
                CustomProperty.GetHashCode() ^
                Rating.GetHashCode() ^
                Title.GetHashCode() ^
                Arrays.GetHashCode(Field) ^
                Helpfulness.GetHashCode() ^
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Error ^
                ErrorSpecified.GetHashCode());
        }
    }

    public partial class ItemID
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            ItemID id = (ItemID)obj;
            return (
                StringID == id.StringID &&
                Arrays.Equal(LongID, id.LongID) &&
                GuidID == id.GuidID &&
                GuidIDSpecified == id.GuidIDSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Helpers.GetHashCode(StringID) ^
                Arrays.GetHashCode(LongID) ^
                GuidID.GetHashCode() ^
                GuidIDSpecified.GetHashCode());
        }
    }

    public partial class Rating
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            Rating r = (Rating)obj;
            return (
                Item == r.Item &&
                Arrays.Equal(RatingItem, r.RatingItem) &&
                OverallRating == r.OverallRating &&
                Date == r.Date &&
                DateSpecified == r.DateSpecified &&
                Error == r.Error &&
                ErrorSpecified == r.ErrorSpecified &&
                TotalCount == r.TotalCount &&
                TotalCountSpecified == r.TotalCountSpecified);
        }

        public override int GetHashCode()
        {
            return (
                Item.GetHashCode() ^
                Arrays.GetHashCode(RatingItem) ^
                OverallRating.GetHashCode() ^
                Date.GetHashCode() ^
                DateSpecified.GetHashCode() ^
                Error ^
                ErrorSpecified.GetHashCode() ^
                TotalCount ^
                TotalCountSpecified.GetHashCode());
        }
    }

    public partial class RatingAttribute
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            RatingAttribute ra = (RatingAttribute)obj;
            return (
                AverageValue == ra.AverageValue &&
                AverageValueSpecified == ra.AverageValueSpecified &&
                UserValue == ra.UserValue &&
                UserValueSpecified == ra.UserValueSpecified &&
                Count == ra.Count &&
                CountSpecified == ra.CountSpecified &&
                base.Equals((RatingItem)obj));
        }

        public override int GetHashCode()
        {
            return (
                AverageValue.GetHashCode() ^
                AverageValueSpecified.GetHashCode() ^
                UserValue ^
                UserValueSpecified.GetHashCode() ^
                Count ^
                CountSpecified.GetHashCode() ^
                base.GetHashCode());
        }
    }

    public partial class RatingItem
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            RatingItem ri = (RatingItem)obj;
            return (
                ID == ri.ID &&
                IDSpecified == ri.IDSpecified &&
                Label == ri.Label &&
                Error == ri.Error &&
                ErrorSpecified == ri.ErrorSpecified &&
                Description == ri.Description &&
                Rank == ri.Rank &&
                RankSpecified == ri.RankSpecified &&
                Required == ri.Required &&
                RequiredSpecified == ri.RequiredSpecified);
        }

        public override int GetHashCode()
        {
            return (
                ID.GetHashCode() ^
                IDSpecified.GetHashCode() ^
                Helpers.GetHashCode(Label) ^
                Error ^
                ErrorSpecified.GetHashCode() ^
                Helpers.GetHashCode(Description) ^
                Rank ^
                RankSpecified.GetHashCode() ^
                Required.GetHashCode() ^
                RequiredSpecified.GetHashCode());
        }
    }

    public partial class OverallRating
    {
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            OverallRating or = (OverallRating)obj;
            return (
                AverageValue == or.AverageValue &&
                AverageValueSpecified == or.AverageValueSpecified &&
                UserValue == or.UserValue &&
                UserValueSpecified == or.UserValueSpecified &&
                base.Equals((RatingItem)obj));
        }

        public override int GetHashCode()
        {
            return (
                AverageValue.GetHashCode() ^
                AverageValueSpecified.GetHashCode() ^
                UserValue.GetHashCode() ^
                UserValueSpecified.GetHashCode() ^
                base.GetHashCode());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\IMusicNet.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet {

    public interface IMusicNet: IConfigurationServiceHttpBinding, IEcommerceB2BServiceHttpBinding
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\msnrr\SingleRating\SingleRatingSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3074
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MSNRR.SingleRating {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="SingleRatingSoap", Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingItem))]
    public interface ISingleRatingSoap {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/AdvanceState", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        System.Xml.XmlNode AdvanceState(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string[] keys, string[] values);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetNickname(long puid, System.Guid msnGuid, out string nickname);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetNicknameSuggestions", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetNicknameSuggestions(string seed, out string[] suggestionList);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingAverage(System.Guid contentTypeID, object itemID, out float rating, out int count);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingAverageRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingAverageRollup(System.Guid contentTypeID, object itemID, out float rating, out int count);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int rating);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingByUserWithAverage", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingByUserWithAverage(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out int userRating, out float averageRating, out int count);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetMultipleRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetMultipleRatingsByUser(System.Guid contentTypeID, object[] itemIDs, long puid, System.Guid msnGuid, out int[] ratings);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetRatingsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetRatingsByUser(System.Guid contentTypeID, long puid, ref System.Guid userID, System.Guid msnGuid, out Rating[] ratings, out string nickname);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviewByUser(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, out Review review);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviews", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviews(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] out Review[] Reviews);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsByUser", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviewsByUser(System.Guid contentTypeID, long puid, System.Guid userID, System.Guid msnGuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] out Review[] Reviews);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetReviewsRollup", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetReviewsRollup(System.Guid contentTypeID, object itemID, ref int pageSize, ref int pageNum, ref string sortBy, ref string sortOrder, out int totalCount, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] out Review[] Reviews);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/GetUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? GetUnauthRatings(System.Guid contentTypeID, object itemID, int daysOfRatingsToUse, out int[] ratingScores, out long[] ratingCounts);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveNickname", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveNickname(long puid, System.Guid msnGuid, string nickname, out string[] suggestionList, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveRating", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? BulkSaveRating(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, int ratingValue, System.DateTime updateDate);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReportViolation", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveReportViolation(object itemID, System.Guid reviewID, string name, string emailAddress, string comments, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/BulkSaveReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? BulkSaveReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIDs, string[] reviewFieldValues, int ratingValue, string customProperty, System.DateTime updateDate, string nickname);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveReviewHelpfulness", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveReviewHelpfulness(object itemID, long puid, System.Guid msnGuid, System.Guid reviewID, int score, out ValidationError[] errors);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/SaveUnauthRatings", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? SaveUnauthRatings(System.Guid contentTypeID, object itemID, int[] ratingScores, int[] ratingCountDeltas);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://schemas.msn.com/webservices/msnrr/2005/02/11/ValidateReview", RequestNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", ResponseNamespace="http://schemas.msn.com/webservices/msnrr/2005/02/11", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int? ValidateReview(System.Guid contentTypeID, object itemID, long puid, System.Guid msnGuid, string title, System.Guid[] reviewFieldIds, string[] reviewFieldValues, int ratingValue, string customProperty, out ValidationError[] errors);
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ValidationError {
        
        private Field dataFieldField;
        
        private Type codeField;
        
        private System.Guid idField;
        
        private int maxLengthField;
        
        /// <remarks/>
        public Field DataField {
            get {
                return this.dataFieldField;
            }
            set {
                this.dataFieldField = value;
            }
        }
        
        /// <remarks/>
        public Type Code {
            get {
                return this.codeField;
            }
            set {
                this.codeField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Field {
        
        /// <remarks/>
        empty,
        
        /// <remarks/>
        nickname,
        
        /// <remarks/>
        ratingItemID,
        
        /// <remarks/>
        reviewFieldID,
        
        /// <remarks/>
        title,
        
        /// <remarks/>
        customProperty,
        
        /// <remarks/>
        name,
        
        /// <remarks/>
        email,
        
        /// <remarks/>
        comments,
        
        /// <remarks/>
        score,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public enum Type {
        
        /// <remarks/>
        RequiredFieldMissing,
        
        /// <remarks/>
        TextTooLong,
        
        /// <remarks/>
        TextInvalidChars,
        
        /// <remarks/>
        TextProfanity,
        
        /// <remarks/>
        InvalidFormat,
        
        /// <remarks/>
        TooManyChanges,
        
        /// <remarks/>
        AlreadyTaken,
        
        /// <remarks/>
        ReviewsRequireRatings,
        
        /// <remarks/>
        ReviewsRequireOneField,
        
        /// <remarks/>
        UserCannotRateOwnReview,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Helpfulness {
        
        private int countField;
        
        private int sumField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private bool currentUserField;
        
        private bool currentUserFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Sum {
            get {
                return this.sumField;
            }
            set {
                this.sumField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool CurrentUser {
            get {
                return this.currentUserField;
            }
            set {
                this.currentUserField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CurrentUserSpecified {
            get {
                return this.currentUserFieldSpecified;
            }
            set {
                this.currentUserFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ReviewField {
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int maxLengthField;
        
        private bool maxLengthFieldSpecified;
        
        private int colsField;
        
        private bool colsFieldSpecified;
        
        private int rowsField;
        
        private bool rowsFieldSpecified;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        private string descriptionField;
        
        private string valueField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int MaxLength {
            get {
                return this.maxLengthField;
            }
            set {
                this.maxLengthField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool MaxLengthSpecified {
            get {
                return this.maxLengthFieldSpecified;
            }
            set {
                this.maxLengthFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Cols {
            get {
                return this.colsField;
            }
            set {
                this.colsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ColsSpecified {
            get {
                return this.colsFieldSpecified;
            }
            set {
                this.colsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rows {
            get {
                return this.rowsField;
            }
            set {
                this.rowsField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RowsSpecified {
            get {
                return this.rowsFieldSpecified;
            }
            set {
                this.rowsFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class User {
        
        private string nicknameField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Nickname {
            get {
                return this.nicknameField;
            }
            set {
                this.nicknameField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Review {
        
        private ItemID itemField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private User userField;
        
        private ReviewField customPropertyField;
        
        private Rating ratingField;
        
        private ReviewField titleField;
        
        private ReviewField[] fieldField;
        
        private Helpfulness helpfulnessField;
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        public User User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField CustomProperty {
            get {
                return this.customPropertyField;
            }
            set {
                this.customPropertyField = value;
            }
        }
        
        /// <remarks/>
        public Rating Rating {
            get {
                return this.ratingField;
            }
            set {
                this.ratingField = value;
            }
        }
        
        /// <remarks/>
        public ReviewField Title {
            get {
                return this.titleField;
            }
            set {
                this.titleField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Field")]
        public ReviewField[] Field {
            get {
                return this.fieldField;
            }
            set {
                this.fieldField = value;
            }
        }
        
        /// <remarks/>
        public Helpfulness Helpfulness {
            get {
                return this.helpfulnessField;
            }
            set {
                this.helpfulnessField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class ItemID {
        
        private string stringIDField;
        
        private long[] longIDField;
        
        private System.Guid guidIDField;
        
        private bool guidIDFieldSpecified;
        
        /// <remarks/>
        public string StringID {
            get {
                return this.stringIDField;
            }
            set {
                this.stringIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LongID")]
        public long[] LongID {
            get {
                return this.longIDField;
            }
            set {
                this.longIDField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid GuidID {
            get {
                return this.guidIDField;
            }
            set {
                this.guidIDField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool GuidIDSpecified {
            get {
                return this.guidIDFieldSpecified;
            }
            set {
                this.guidIDFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class Rating {
        
        private ItemID itemField;
        
        private RatingAttribute[] ratingItemField;
        
        private OverallRating overallRatingField;
        
        private System.DateTime dateField;
        
        private bool dateFieldSpecified;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private int totalCountField;
        
        private bool totalCountFieldSpecified;
        
        /// <remarks/>
        public ItemID Item {
            get {
                return this.itemField;
            }
            set {
                this.itemField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("RatingItem")]
        public RatingAttribute[] RatingItem {
            get {
                return this.ratingItemField;
            }
            set {
                this.ratingItemField = value;
            }
        }
        
        /// <remarks/>
        public OverallRating OverallRating {
            get {
                return this.overallRatingField;
            }
            set {
                this.overallRatingField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.DateTime Date {
            get {
                return this.dateField;
            }
            set {
                this.dateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DateSpecified {
            get {
                return this.dateFieldSpecified;
            }
            set {
                this.dateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int TotalCount {
            get {
                return this.totalCountField;
            }
            set {
                this.totalCountField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool TotalCountSpecified {
            get {
                return this.totalCountFieldSpecified;
            }
            set {
                this.totalCountFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingAttribute : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private int userValueField;
        
        private bool userValueFieldSpecified;
        
        private int countField;
        
        private bool countFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Count {
            get {
                return this.countField;
            }
            set {
                this.countField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool CountSpecified {
            get {
                return this.countFieldSpecified;
            }
            set {
                this.countFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(OverallRating))]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(RatingAttribute))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class RatingItem {
        
        private System.Guid idField;
        
        private bool idFieldSpecified;
        
        private string labelField;
        
        private int errorField;
        
        private bool errorFieldSpecified;
        
        private string descriptionField;
        
        private int rankField;
        
        private bool rankFieldSpecified;
        
        private bool requiredField;
        
        private bool requiredFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid ID {
            get {
                return this.idField;
            }
            set {
                this.idField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool IDSpecified {
            get {
                return this.idFieldSpecified;
            }
            set {
                this.idFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Label {
            get {
                return this.labelField;
            }
            set {
                this.labelField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Error {
            get {
                return this.errorField;
            }
            set {
                this.errorField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ErrorSpecified {
            get {
                return this.errorFieldSpecified;
            }
            set {
                this.errorFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Description {
            get {
                return this.descriptionField;
            }
            set {
                this.descriptionField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int Rank {
            get {
                return this.rankField;
            }
            set {
                this.rankField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RankSpecified {
            get {
                return this.rankFieldSpecified;
            }
            set {
                this.rankFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool Required {
            get {
                return this.requiredField;
            }
            set {
                this.requiredField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool RequiredSpecified {
            get {
                return this.requiredFieldSpecified;
            }
            set {
                this.requiredFieldSpecified = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.msn.com/webservices/msnrr/2005/02/11")]
    public partial class OverallRating : RatingItem {
        
        private float averageValueField;
        
        private bool averageValueFieldSpecified;
        
        private float userValueField;
        
        private bool userValueFieldSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float AverageValue {
            get {
                return this.averageValueField;
            }
            set {
                this.averageValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool AverageValueSpecified {
            get {
                return this.averageValueFieldSpecified;
            }
            set {
                this.averageValueFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public float UserValue {
            get {
                return this.userValueField;
            }
            set {
                this.userValueField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool UserValueSpecified {
            get {
                return this.userValueFieldSpecified;
            }
            set {
                this.userValueFieldSpecified = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\MusicNetServerStub.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet 
{
    using System;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Web.Services.Description;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    [Emulate]
    [SoapDocumentService(SoapBindingUse.Literal,
		                 SoapParameterStyle.Wrapped,
		                 RoutingStyle=SoapServiceRoutingStyle.RequestElement)]

    public class MusicNetServerStub : ContextBoundObject, IMusicNet
    {
        public bool IsAlive() 
        {
            throw new ApplicationException("Stub method should not be called");
        }
            
        public ServiceConfiguration GetServiceConfiguration(string retailerId, Service? service) 
        {
            throw new ApplicationException("Stub method should not be called");
        }

        public void CreateAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        public void SuspendAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        public void ResumeAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        public void CloseAccount(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        public void AddTrialSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, string offerSKUToRollover, int noOfTrialDays, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        public void EndTrialSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        
        public void AddSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        
        public void CancelSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, bool immediate, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        
        public void UpgradeSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        
        public void DowngradeSubscriptionOffer(string authToken, string retailerId, string customerId, string orderId, string offerSKU, bool immediate, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
        
        
        public Purchase PurchaseAssets(string authToken, string retailerId, string customerId, string orderId,  PurchaseItem[] items, string isoCountryCode, bool allowPartialPurchases, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }

        public int TransferEntitlements(string sourceXuid, string targetXuid, CustomProperty[] extraParameters)
        {
            throw new ApplicationException("Stub method should not be called");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\MusicNetConfigTypes.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet {

    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    public partial class ServiceConfiguration 
    {
        public override bool Equals (object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            ServiceConfiguration cfg = (ServiceConfiguration)obj;
            
            return (location == cfg.location && Arrays.Equal(getServiceConfigurationReturn, cfg.getServiceConfigurationReturn));
        }
        
        public override int GetHashCode() 
        {
            return Helpers.GetHashCode(location)^Arrays.GetHashCode(getServiceConfigurationReturn);
        }
        
    }
    
    public partial class MethodConfiguration
    {
        public override bool Equals (object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            MethodConfiguration cfg = (MethodConfiguration)obj;
            return (methodName == cfg.methodName && clientRequestSignatureRequired == cfg.clientRequestSignatureRequired 
                    && serverResponseSignatureRequired == cfg.serverResponseSignatureRequired);
        }
        
        public override int GetHashCode() 
        {
            return Helpers.GetHashCode(methodName)^serverResponseSignatureRequired.GetHashCode()^clientRequestSignatureRequired.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\MusicNetEmulator.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    public class MusicNetEmulator:EmulatorFacadeBase<IMusicNet>
    {
        protected override string HandlerName 
        {
            get 
            {
                return "MusicNetEmulator.asmx";
            }
        }
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\MusicNetTypes.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet {

    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
                                                    
    public partial class CustomProperty {
        
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            
            CustomProperty c = (CustomProperty)obj;
            return (name == c.name && value == c.value);
        }

        public override int GetHashCode() 
        {
            return Helpers.GetHashCode(name)^Helpers.GetHashCode(value);
        }

    }
    
    public partial class Error 
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            Error e = (Error)obj;
            return (code == e.code && description == e.description);
        }
        
        public override int GetHashCode() 
        {
            return code^Helpers.GetHashCode(description);
        }

        
    }
    
    public partial class PurchaseItemResponse
    {
        public override bool Equals (object obj) 
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            PurchaseItemResponse pir = (PurchaseItemResponse)obj;
            return (mnetId == pir.mnetId && Object.Equals(error, pir.error));
        }
        
        public override int GetHashCode()
        {
            return Helpers.GetHashCode(mnetId)^Helpers.GetHashCode(error);
        }
    }
    
    
    public partial class Purchase 
    {
        public override bool Equals (object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            Purchase p = (Purchase)obj;
            
            return Arrays.Equal(itemsWithErrors, p.itemsWithErrors);
        }
        
        public override int GetHashCode()
        {
            return Arrays.GetHashCode(itemsWithErrors);
        
        }
    }
    
    public partial class ItemPrice 
    {
        public override bool Equals (object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            ItemPrice price = (ItemPrice)obj;
            return (amount == price.amount && currency == price.currency);
        }
        
        public override int GetHashCode() 
        {
            return (Helpers.GetHashCode(amount) ^ (int)currency);
        }
    }
    
    public partial class PurchaseItem
    {
        public override bool Equals (object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;
            PurchaseItem pi = (PurchaseItem)obj;
            return (mnetId == pi.mnetId && type == pi.type && Object.Equals(suggestedRetailPrice, pi.suggestedRetailPrice) && Object.Equals(soldForPrice ,pi.soldForPrice));
        }
        
        public override int GetHashCode()
        {
            return Helpers.GetHashCode(mnetId)^Helpers.GetHashCode(suggestedRetailPrice)^Helpers.GetHashCode(soldForPrice)^(int)type;
        }
    }
    
            
            
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaCredential\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\MusicNetConfigSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ConfigurationServiceHttpBinding", Namespace="http://ws.musicnet.com")]
    public interface IConfigurationServiceHttpBinding {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("out")]
        bool IsAlive();
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("out", IsNullable=true)]
        ServiceConfiguration GetServiceConfiguration([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<Service> service);
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public enum Service {
        
        /// <remarks/>
        Fulfillment,
        
        /// <remarks/>
        Discovery,
        
        /// <remarks/>
        Utilities,
        
        /// <remarks/>
        EcommerceB2B,
        
        /// <remarks/>
        CamB2B,
        
        /// <remarks/>
        Community,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class ServiceConfiguration {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item")]
        public MethodConfiguration[] getServiceConfigurationReturn;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string location;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class MethodConfiguration {
        
        /// <remarks/>
        public bool clientRequestSignatureRequired;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool clientRequestSignatureRequiredSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string methodName;
        
        /// <remarks/>
        public bool serverResponseSignatureRequired;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool serverResponseSignatureRequiredSpecified;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\musicnet\MusicNetSI.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.MusicNet {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="EcommerceB2BServiceHttpBinding", Namespace="http://ws.musicnet.com")]
    public interface IEcommerceB2BServiceHttpBinding {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void UpgradeSubscriptionOffer([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string offerSKU, bool immediate, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void CancelSubscriptionOffer([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, bool immediate, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void AddSubscriptionOffer([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string offerSKU, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void EndTrialSubscriptionOffer([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DowngradeSubscriptionOffer([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string offerSKU, bool immediate, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void ResumeAccount([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void CreateAccount([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void AddTrialSubscriptionOffer([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string offerSKU, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string offerSKUToRollover, int noOfTrialDays, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("out", IsNullable=true)]
        Purchase PurchaseAssets([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] PurchaseItem[] items, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string isoCountryCode, bool allowPartialPurchases, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void CloseAccount([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void SuspendAccount([System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string authToken, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string retailerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string customerId, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] string orderId, [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("", RequestNamespace="http://ws.musicnet.com", ResponseNamespace="http://ws.musicnet.com", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        int TransferEntitlements([System.Xml.Serialization.XmlElementAttribute(IsNullable = false)] string sourceXuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable = false)] string targetXuid, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute("item")] CustomProperty[] extraParameters);
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class CustomProperty {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string value;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class Error {
        
        /// <remarks/>
        public int code;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool codeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string description;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class PurchaseItemResponse {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public Error error;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string mnetId;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class Purchase {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute(IsNullable=true)]
        [System.Xml.Serialization.XmlArrayItemAttribute("item")]
        public PurchaseItemResponse[] itemsWithErrors;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class ItemPrice {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string amount;
        
        /// <remarks/>
        public Currency currency;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public enum Currency {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        USD,
        
        /// <remarks/>
        CAD,
        
        /// <remarks/>
        GBP,
        
        /// <remarks/>
        EUR,
        
        /// <remarks/>
        JPY,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public partial class PurchaseItem {

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string assetCode;        

        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string mnetId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public ItemPrice soldForPrice;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public ItemPrice suggestedRetailPrice;
        
        /// <remarks/>
        public PurchaseItemType type;
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://ws.musicnet.com")]
    public enum PurchaseItemType {
        
        /// <remarks/>
        Track,
        
        /// <remarks/>
        Album,
        
        /// <remarks/>
        Video,

	/// <remarks/>
       Undefined,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaCredential\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaCredential\ppsaCredentialServerStub.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.ppsaCredential {
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
        
    [Emulate]
    public class ppsaCredentialServerStub : ContextBoundObject, IppsaCredentialSoap
    {
        public tagPASSID GetPassportID(tagPASSID PassIDIn) { throw new NotImplementedException("This is a stub code. It should not be called directly"); }

        public string AddProof(tagPASSID idUserPUID, string bstrProofData) { throw new NotImplementedException("This is a stub code. It should not be called directly"); }

        public string GetUserProofState(tagPASSID idUserPUID, eProofFilter epfFilter) { throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
   
        public string GetCredentialInfo(tagPASSID PassIDIn, string bstrAttribList){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void AddCredential(string bstrNamespace, string bstrCredXML, ref string pbstrNetID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void UpdateCredential(string bstrCredXML){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void DeleteCredential(tagPASSID PassID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void RenameCredential(tagPASSID PassIDIn, string bstrnewCredName){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
        public void UnblockCredential(tagPASSID PassID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void BlockCredential(tagPASSID PassID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string EnumCredentialsByName(string bstrCredName, string bstrAttribList){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string EnumCredentialsByNetID(string bstrNetID, string bstrAttribList){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string EnumCredentialsByNamespace(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetCertificateAssociations(string bstrNetID, string bstrSigninName){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void DeleteCertificateAssociation(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void DeleteAllCertificateAssociations(string bstrNetID, string bstrSigninName){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
        public string GetSigninNamesForNetIDs(string bstrNetIDs){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void ForceCredentialRename(tagPASSID PassID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetNetIDsForSigninNames(string bstrSigninNames){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string QueryCredentialChanges(string OptionsXml){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
        public string QueryCredentialHistory(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string QueryCredentialHistoryByNetID(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string QueryNetIDHistoryBySigninName(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string SuggestAlternateMemberNames(string Namespace, string FirstName, string LastName, string RequestedName){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetSigninNamesAndCIDsForNetIDs(string bstrNetIDs){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetNetIDsAndCIDsForSigninNames(string bstrSigninNames){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string CheckAvailableSigninNames(string bstrSigninNames){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string CheckRenameRules(tagPASSID PassIDIn){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void RenameCredentialEx(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void ReserveName(tagPASSID PassIDIn, string bstrNewSigninName){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetSLT(tagPASSID PassIDIn, int LoginSeconds){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void AddLinkAccounts(string bstrLinkProofData, ref string pbstrLinkID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void DeLinkAccounts(string bstrSigninNames, string SLT){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
        public string GetLinkAccountMembers(string bstrLinkID){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
        public void AssociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateToken){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void DisassociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateList){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void DeleteCredentialEx(tagPASSID PassIDIn, string bstrOptionalParams){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string CreateAlias(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName, out string pbstrSuggestedNames){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
        public void UpdateAlias(tagPASSID PassIDIn, string bstrAliasXML){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public void DeleteAlias(tagPASSID PassIDIn, string bstrAliasXML){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string RenameAlias(tagPASSID PassIDIn, string bstrOldName, string bstrNewName){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetAliasesForAccount(tagPASSID PassIDIn, string bstrOptionalParams){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetAccountForAlias(tagPASSID AliasIDIn, string bstrOptionalParams){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string AddToReputationScore(string bstrDataFeedXML){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string OverrideReputationScore(string bstrDataFeedXML){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
    
    
        public string GetReputationScoreDetails(tagPASSID PassIDIn){ throw new NotImplementedException("This is a stub code. It should not be called directly"); }
        
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaProfile\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaCredential\ppsaCredentialEmulator.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.ppsaCredential
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    public class ppsaCredentialEmulator : EmulatorFacadeBase<IppsaCredentialSoap>
    {
        protected override string HandlerName 
        {
            get 
            {
                return "ppsaCredentialEmulator.asmx";
            }
        }
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaProfile\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ups\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaProfile\ppsaProfileServerStub.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.ppsaProfile {
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
        
    [Emulate]
    public class ppsaProfileServerStub : ContextBoundObject, IppsaProfileSoap
    {
#if false        
        public ppsaProfileSoapHeader ppsaProfileSoapHeaderValue;
#endif
        public void CreateProfile( string[] bstrProfileXMLArray) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public string[] CreatePassports(string[] pbstrAccountXMLArray, eTRANSACTION etFlags, out string pbstrErrorBlob) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        
        public string[] ReservePassports( string[] pbstrAccountXMLArray, eTRANSACTION etFlags, out string pbstrErrorBlob) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public string[] UpdatePassports(string[] pbstrNetIDArray,   string[] pbstrAccountXMLArray,   string[] pbstrAdditionalXML, string bstrOptions, out string pbstrErrorBlob) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public string[] GetProfileByAttributes( string[] pbstrNetIDArray, string bstrAttribList, uint ulFlags, out string pbstrErrorBlob) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        
        public string[] GetProfileByXPath( string[] pbstrNetIDArray,  string[] pbstrXPathArray, out string pbstrErrorBlob) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public void UpdateProfile(string[] pbstrProfileXMLArray) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public void UpdateProfileEx(string[] pbstrNetIDArray, string bstrProfileXML) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public void DeleteProfileW(string[] ppbstrNetIDArray, string bstrPropertyCollectionList) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        
        public void DeletePassports(string[] pbstrNetIDArray) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public string GetIdentityInfo(tagPASSID PassIDIn, string bstrCredAttribList, string bstrProfileAttribList, string bstrOptionalParams) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        
        public string UpdateUserAppConsent(tagPASSID passID, string bstrAppPermissionXML) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public string EnumerateAppPermissions(tagPASSID passID, string bstrFilterXML) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public string GetDelegationToken(tagPASSID passID, string bstrFilterXML) 
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaCredential\PPSACredentialWSDL.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4961
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace Microsoft.XBox.Live.Server.Emulators.ppsaCredential {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="CredentialServiceAPISoapServerSoap", Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
     public interface IppsaCredentialSoap {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetPassportID", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pPassIDOut")]
        tagPASSID GetPassportID(tagPASSID PassIDIn);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddProof", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAddedProof")]
        string AddProof(tagPASSID idUserPUID, string bstrProofData);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetUserProofState", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrProofs")]
        string GetUserProofState(tagPASSID idUserPUID, eProofFilter epfFilter);
        
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetCredentialInfo", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrcredXML")]
        string GetCredentialInfo(tagPASSID PassIDIn, string bstrAttribList);
        
       
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void AddCredential(string bstrNamespace, string bstrCredXML, ref string pbstrNetID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void UpdateCredential(string bstrCredXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DeleteCredential(tagPASSID PassID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void RenameCredential(tagPASSID PassIDIn, string bstrnewCredName);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UnblockCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void UnblockCredential(tagPASSID PassID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#BlockCredential", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void BlockCredential(tagPASSID PassID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByName", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        string EnumCredentialsByName(string bstrCredName, string bstrAttribList);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByNetID", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredentialXML")]
        string EnumCredentialsByNetID(string bstrNetID, string bstrAttribList);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByNamespace", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredListXML")]
        string EnumCredentialsByNamespace(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetCertificateAssociations", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCertXML")]
        string GetCertificateAssociations(string bstrNetID, string bstrSigninName);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCertificateAssociation", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DeleteCertificateAssociation(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteAllCertificateAssociations", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DeleteAllCertificateAssociations(string bstrNetID, string bstrSigninName);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSigninNamesForNetIDs", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        string GetSigninNamesForNetIDs(string bstrNetIDs);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ForceCredentialRename", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void ForceCredentialRename(tagPASSID PassID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetNetIDsForSigninNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        string GetNetIDsForSigninNames(string bstrSigninNames);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialChanges", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangesXml")]
        string QueryCredentialChanges(string OptionsXml);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialHistory", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangeHistory")]
        string QueryCredentialHistory(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID);

        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialHistoryByNetID", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangeHistory")]
        string QueryCredentialHistoryByNetID(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryNetIDHistoryBySigninName", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("NetIDHistory")]
        string QueryNetIDHistoryBySigninName(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#SuggestAlternateMemberNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Names")]
        string SuggestAlternateMemberNames(string Namespace, string FirstName, string LastName, string RequestedName);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSigninNamesAndCIDsForNetIDs", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        string GetSigninNamesAndCIDsForNetIDs(string bstrNetIDs);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetNetIDsAndCIDsForSigninNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        string GetNetIDsAndCIDsForSigninNames(string bstrSigninNames);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CheckAvailableSigninNames", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        string CheckAvailableSigninNames(string bstrSigninNames);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CheckRenameRules", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAvailableAttributes")]
        string CheckRenameRules(tagPASSID PassIDIn);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameCredentialEx", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void RenameCredentialEx(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ReserveName", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void ReserveName(tagPASSID PassIDIn, string bstrNewSigninName);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSLT", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("SLT")]
        string GetSLT(tagPASSID PassIDIn, int LoginSeconds);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddLinkAccounts", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void AddLinkAccounts(string bstrLinkProofData, ref string pbstrLinkID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeLinkAccounts", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DeLinkAccounts(string bstrSigninNames, string SLT);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetLinkAccountMembers", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrLinkCredXML")]
        string GetLinkAccountMembers(string bstrLinkID);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AssociateCertificate", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void AssociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateToken);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DisassociateCertificate", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DisassociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateList);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCredentialEx", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DeleteCredentialEx(tagPASSID PassIDIn, string bstrOptionalParams);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CreateAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAUID")]
        string CreateAlias(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName, out string pbstrSuggestedNames);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void UpdateAlias(tagPASSID PassIDIn, string bstrAliasXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        void DeleteAlias(tagPASSID PassIDIn, string bstrAliasXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        string RenameAlias(tagPASSID PassIDIn, string bstrOldName, string bstrNewName);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetAliasesForAccount", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        string GetAliasesForAccount(tagPASSID PassIDIn, string bstrOptionalParams);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetAccountForAlias", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        string GetAccountForAlias(tagPASSID AliasIDIn, string bstrOptionalParams);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddToReputationScore", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDataFeedXML")]
        string AddToReputationScore(string bstrDataFeedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#OverrideReputationScore", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDataFeedXML")]
        string OverrideReputationScore(string bstrDataFeedXML);
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetReputationScoreDetails", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrReputationScoreXML")]
        string GetReputationScoreDetails(tagPASSID PassIDIn);
    }
        
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("WSSecurityHeader", Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", IsNullable=false)]
    public partial class tagWSSECURITYHEADER : System.Web.Services.Protocols.SoapHeader {
        
        private EnumSHVersion versionField;
        
        private string wssecurityField;
        
        private string authorizationField;
        
        private string sitetokenField;
        
        private string ppSoapHeader25Field;
        
        private string auditInfoField;
        
        private string delegateField;
        
        private string originatorField;
        
        private string clientIPField;
        
        /// <remarks/>
        public EnumSHVersion version {
            get {
                return this.versionField;
            }
            set {
                this.versionField = value;
            }
        }
        
        /// <remarks/>
        public string wssecurity {
            get {
                return this.wssecurityField;
            }
            set {
                this.wssecurityField = value;
            }
        }
        
        /// <remarks/>
        public string authorization {
            get {
                return this.authorizationField;
            }
            set {
                this.authorizationField = value;
            }
        }
        
        /// <remarks/>
        public string sitetoken {
            get {
                return this.sitetokenField;
            }
            set {
                this.sitetokenField = value;
            }
        }
        
        /// <remarks/>
        public string ppSoapHeader25 {
            get {
                return this.ppSoapHeader25Field;
            }
            set {
                this.ppSoapHeader25Field = value;
            }
        }
        
        /// <remarks/>
        public string auditInfo {
            get {
                return this.auditInfoField;
            }
            set {
                this.auditInfoField = value;
            }
        }
        
        /// <remarks/>
        public string @delegate {
            get {
                return this.delegateField;
            }
            set {
                this.delegateField = value;
            }
        }
        
        /// <remarks/>
        public string originator {
            get {
                return this.originatorField;
            }
            set {
                this.originatorField = value;
            }
        }
        
        /// <remarks/>
        public string clientIP {
            get {
                return this.clientIPField;
            }
            set {
                this.clientIPField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum EnumSHVersion {
        
        /// <remarks/>
        eshHeader30,
        
        /// <remarks/>
        eshHeader25,
        
        /// <remarks/>
        eshNone,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public partial class tagPASSID {
        
        private PASSIDTYPE pitField;
        
        private string bstrIDField;
        
        /// <remarks/>
        public PASSIDTYPE pit {
            get {
                return this.pitField;
            }
            set {
                this.pitField = value;
            }
        }
        
        /// <remarks/>
        public string bstrID {
            get {
                return this.bstrIDField;
            }
            set {
                this.bstrIDField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum PASSIDTYPE {
        
        /// <remarks/>
        PASSID_PUID_SIGNINNAME,
        
        /// <remarks/>
        PASSID_ROLEID,
        
        /// <remarks/>
        PASSID_PPSACREDENTIALID,
        
        /// <remarks/>
        PASSID_NULL,
        
        /// <remarks/>
        PASSID_PUID,
        
        /// <remarks/>
        PASSID_SIGNINNAME,
        
        /// <remarks/>
        PASSID_ALIASNAME,
        
        /// <remarks/>
        PASSID_AUID,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("PPSoapHeader", Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", IsNullable=false)]
    public partial class PPSoapHeader_wrapper : System.Web.Services.Protocols.SoapHeader {
        
        private string[] textField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string[] Text {
            get {
                return this.textField;
            }
            set {
                this.textField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum eProofFilter {
        
        /// <remarks/>
        eProofFilter_Max,
        
        /// <remarks/>
        eProofFilter_NeedConfirm,
        
        /// <remarks/>
        eProofFilter_All,
        
        /// <remarks/>
        eProofFilter_Invalid,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPassportIDCompletedEventHandler(object sender, GetPassportIDCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPassportIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPassportIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public tagPASSID Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((tagPASSID)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddProofCompletedEventHandler(object sender, AddProofCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddProofCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddProofCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserProofStateCompletedEventHandler(object sender, GetUserProofStateCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserProofStateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserProofStateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCredentialInfoCompletedEventHandler(object sender, GetCredentialInfoCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCredentialInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCredentialInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCredentialCompletedEventHandler(object sender, AddCredentialCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCredentialCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCredentialCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string pbstrNetID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RenameCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnblockCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BlockCredentialCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumCredentialsByNameCompletedEventHandler(object sender, EnumCredentialsByNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumCredentialsByNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumCredentialsByNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumCredentialsByNetIDCompletedEventHandler(object sender, EnumCredentialsByNetIDCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumCredentialsByNetIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumCredentialsByNetIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumCredentialsByNamespaceCompletedEventHandler(object sender, EnumCredentialsByNamespaceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumCredentialsByNamespaceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumCredentialsByNamespaceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCertificateAssociationsCompletedEventHandler(object sender, GetCertificateAssociationsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCertificateAssociationsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetCertificateAssociationsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteCertificateAssociationCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteAllCertificateAssociationsCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSigninNamesForNetIDsCompletedEventHandler(object sender, GetSigninNamesForNetIDsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSigninNamesForNetIDsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSigninNamesForNetIDsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ForceCredentialRenameCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNetIDsForSigninNamesCompletedEventHandler(object sender, GetNetIDsForSigninNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNetIDsForSigninNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNetIDsForSigninNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void QueryCredentialChangesCompletedEventHandler(object sender, QueryCredentialChangesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryCredentialChangesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryCredentialChangesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void QueryCredentialHistoryCompletedEventHandler(object sender, QueryCredentialHistoryCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryCredentialHistoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryCredentialHistoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void QueryCredentialHistoryByNetIDCompletedEventHandler(object sender, QueryCredentialHistoryByNetIDCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryCredentialHistoryByNetIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryCredentialHistoryByNetIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void QueryNetIDHistoryBySigninNameCompletedEventHandler(object sender, QueryNetIDHistoryBySigninNameCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class QueryNetIDHistoryBySigninNameCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal QueryNetIDHistoryBySigninNameCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SuggestAlternateMemberNamesCompletedEventHandler(object sender, SuggestAlternateMemberNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SuggestAlternateMemberNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SuggestAlternateMemberNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSigninNamesAndCIDsForNetIDsCompletedEventHandler(object sender, GetSigninNamesAndCIDsForNetIDsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSigninNamesAndCIDsForNetIDsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSigninNamesAndCIDsForNetIDsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetNetIDsAndCIDsForSigninNamesCompletedEventHandler(object sender, GetNetIDsAndCIDsForSigninNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetNetIDsAndCIDsForSigninNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetNetIDsAndCIDsForSigninNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CheckAvailableSigninNamesCompletedEventHandler(object sender, CheckAvailableSigninNamesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CheckAvailableSigninNamesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CheckAvailableSigninNamesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CheckRenameRulesCompletedEventHandler(object sender, CheckRenameRulesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CheckRenameRulesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CheckRenameRulesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RenameCredentialExCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReserveNameCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSLTCompletedEventHandler(object sender, GetSLTCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSLTCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSLTCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddLinkAccountsCompletedEventHandler(object sender, AddLinkAccountsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddLinkAccountsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddLinkAccountsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string pbstrLinkID {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeLinkAccountsCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLinkAccountMembersCompletedEventHandler(object sender, GetLinkAccountMembersCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLinkAccountMembersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetLinkAccountMembersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AssociateCertificateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DisassociateCertificateCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteCredentialExCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateAliasCompletedEventHandler(object sender, CreateAliasCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateAliasCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateAliasCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string pbstrSuggestedNames {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateAliasCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteAliasCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RenameAliasCompletedEventHandler(object sender, RenameAliasCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RenameAliasCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal RenameAliasCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAliasesForAccountCompletedEventHandler(object sender, GetAliasesForAccountCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAliasesForAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAliasesForAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountForAliasCompletedEventHandler(object sender, GetAccountForAliasCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountForAliasCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetAccountForAliasCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddToReputationScoreCompletedEventHandler(object sender, AddToReputationScoreCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddToReputationScoreCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddToReputationScoreCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OverrideReputationScoreCompletedEventHandler(object sender, OverrideReputationScoreCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OverrideReputationScoreCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal OverrideReputationScoreCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReputationScoreDetailsCompletedEventHandler(object sender, GetReputationScoreDetailsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReputationScoreDetailsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetReputationScoreDetailsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaProfile\ppsaProfileEmulator.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.ppsaProfile
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    public class ppsaProfileEmulator : EmulatorFacadeBase<IppsaProfileSoap>
    {
        protected override string HandlerName 
        {
            get 
            {
                return "ppsaProfileEmulator.asmx";
            }
        }
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ups\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ups\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ups\upsServerStub.cs ===
using System;
using Microsoft.XBox.Live.Server.Emulators.Framework;

namespace Microsoft.XBox.Live.Server.Emulators.ups {
    [Emulate]
    public class upsServerStub : ContextBoundObject, IUpsSoap
    {
        public string[] GetProfileByAttributes(string[] pbstrNetIDArray, string bstrAttribList, System.UInt32 ulFlags, out string pbstrErrorBlob)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public void UpdateProfile(string[] pbstrProfileXMLArray)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
        
        public void DeleteProfile(string[] pbstrNetIDArray, string bstrPropertyCollectionList)
        {
            throw new NotImplementedException("This is a stub code. It should not be called directly");
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ppsaProfile\PPSAProfileWSDL.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 

namespace Microsoft.XBox.Live.Server.Emulators.ppsaProfile {
    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Web.Services;
    using System.Web.Services.Protocols;
    using System.Xml.Serialization;


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ProfileServiceAPISoapServerSoap", Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
     public interface IppsaProfileSoap {
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CreateProfile", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
         void CreateProfile(  string[] bstrProfileXMLArray); 
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CreatePassports", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrCreatedAccountsArray", IsNullable = true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
         string[] CreatePassports(  string[] pbstrAccountXMLArray, eTRANSACTION etFlags, out string pbstrErrorBlob); 
        
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ReservePassports", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrReservedAccountsArray", IsNullable=true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        string[] ReservePassports(  string[] pbstrAccountXMLArray, eTRANSACTION etFlags, out string pbstrErrorBlob); 
        
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdatePassports", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrUpdatedAccountsArray", IsNullable=true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
         string[] UpdatePassports(  string[] pbstrNetIDArray,   string[] pbstrAccountXMLArray,   string[] pbstrAdditionalXML, string bstrOptions, out string pbstrErrorBlob) ;
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetProfileByAttributes", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrProfileXMLArray", IsNullable=true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
         string[] GetProfileByAttributes(  string[] pbstrNetIDArray, string bstrAttribList, uint ulFlags, out string pbstrErrorBlob) ;
        
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetProfileByXPath", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrProfileXMLArray", IsNullable=true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
         string[] GetProfileByXPath(  string[] pbstrNetIDArray,   string[] pbstrXPathArray, out string pbstrErrorBlob); 
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateProfile", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
         void UpdateProfile(  string[] pbstrProfileXMLArray); 
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateProfileEx", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
         void UpdateProfileEx(  string[] pbstrNetIDArray, string bstrProfileXML) ;
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteProfileW", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
         void DeleteProfileW(  string[] ppbstrNetIDArray, string bstrPropertyCollectionList); 
        
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeletePassports", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
         void DeletePassports(  string[] pbstrNetIDArray); 
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetIdentityInfo", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrXML")]
         string GetIdentityInfo(tagPASSID PassIDIn, string bstrCredAttribList, string bstrProfileAttribList, string bstrOptionalParams); 
        
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateUserAppConsent", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrResultXML")]
         string UpdateUserAppConsent(tagPASSID passID, string bstrAppPermissionXML) ;
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumerateAppPermissions", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAppPermissionXML")]
         string EnumerateAppPermissions(tagPASSID passID, string bstrFilterXML); 
        
        /// <remarks/>
        [System.Web.Services.WebMethodAttribute()]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetDelegationToken", RequestNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAppPermissionXML")]
         string GetDelegationToken(tagPASSID passID, string bstrFilterXML) ;
        
    }

#if false
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.SoapTypeAttribute(Namespace="http://tempuri.org/")]
    public partial class ppsaProfileSoapHeader : SoapHeader {
        
        /// <remarks/>
        public int PartitionId;
    }
#endif

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public enum eTRANSACTION {
        
        /// <remarks/>
        TX_MAX,
        
        /// <remarks/>
        TX_ROLLBACK_NONE,
        
        /// <remarks/>
        TX_ROLLBACK_ACCOUNT,
        
        /// <remarks/>
        TX_ROLLBACK_ALL,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public partial class tagPASSID {
        
        private PASSIDTYPE pitField;
        
        private string bstrIDField;
        
        /// <remarks/>
        public PASSIDTYPE pit {
            get {
                return this.pitField;
            }
            set {
                this.pitField = value;
            }
        }
        
        /// <remarks/>
        public string bstrID {
            get {
                return this.bstrIDField;
            }
            set {
                this.bstrIDField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public enum PASSIDTYPE {
        
        /// <remarks/>
        PASSID_PUID_SIGNINNAME,
        
        /// <remarks/>
        PASSID_ROLEID,
        
        /// <remarks/>
        PASSID_PPSACREDENTIALID,
        
        /// <remarks/>
        PASSID_NULL,
        
        /// <remarks/>
        PASSID_PUID,
        
        /// <remarks/>
        PASSID_SIGNINNAME,
    }
    
#if true
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("WSSecurityHeader", Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", IsNullable=false)]
    public partial class tagWSSECURITYHEADER : System.Web.Services.Protocols.SoapHeader {
        
        private EnumSHVersion versionField;
        
        private string wssecurityField;
        
        private string authorizationField;
        
        private string sitetokenField;
        
        private string ppSoapHeader25Field;
        
        private string auditInfoField;
        
        private string delegateField;
        
        private string originatorField;
        
        private string clientIPField;
        
        /// <remarks/>
        public EnumSHVersion version {
            get {
                return this.versionField;
            }
            set {
                this.versionField = value;
            }
        }
        
        /// <remarks/>
        public string wssecurity {
            get {
                return this.wssecurityField;
            }
            set {
                this.wssecurityField = value;
            }
        }
        
        /// <remarks/>
        public string authorization {
            get {
                return this.authorizationField;
            }
            set {
                this.authorizationField = value;
            }
        }
        
        /// <remarks/>
        public string sitetoken {
            get {
                return this.sitetokenField;
            }
            set {
                this.sitetokenField = value;
            }
        }
        
        /// <remarks/>
        public string ppSoapHeader25 {
            get {
                return this.ppSoapHeader25Field;
            }
            set {
                this.ppSoapHeader25Field = value;
            }
        }
        
        /// <remarks/>
        public string auditInfo {
            get {
                return this.auditInfoField;
            }
            set {
                this.auditInfoField = value;
            }
        }
        
        /// <remarks/>
        public string @delegate {
            get {
                return this.delegateField;
            }
            set {
                this.delegateField = value;
            }
        }
        
        /// <remarks/>
        public string originator {
            get {
                return this.originatorField;
            }
            set {
                this.originatorField = value;
            }
        }
        
        /// <remarks/>
        public string clientIP {
            get {
                return this.clientIPField;
            }
            set {
                this.clientIPField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public enum EnumSHVersion {
        
        /// <remarks/>
        eshHeader30,
        
        /// <remarks/>
        eshHeader25,
        
        /// <remarks/>
        eshNone,
    }



    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("PPSoapHeader", Namespace="http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", IsNullable=false)]
    public partial class PPSoapHeader_wrapper : System.Web.Services.Protocols.SoapHeader {
        
        private string[] textField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string[] Text {
            get {
                return this.textField;
            }
            set {
                this.textField = value;
            }
        }
    }


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateProfileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreatePassportsCompletedEventHandler(object sender, CreatePassportsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreatePassportsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreatePassportsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string pbstrErrorBlob {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReservePassportsCompletedEventHandler(object sender, ReservePassportsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReservePassportsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ReservePassportsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string pbstrErrorBlob {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdatePassportsCompletedEventHandler(object sender, UpdatePassportsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdatePassportsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdatePassportsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string pbstrErrorBlob {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetProfileByAttributesCompletedEventHandler(object sender, GetProfileByAttributesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetProfileByAttributesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetProfileByAttributesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string pbstrErrorBlob {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetProfileByXPathCompletedEventHandler(object sender, GetProfileByXPathCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetProfileByXPathCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetProfileByXPathCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string[])(this.results[0]));
            }
        }
        
        /// <remarks/>
        public string pbstrErrorBlob {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateProfileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateProfileExCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeleteProfileWCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeletePassportsCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetIdentityInfoCompletedEventHandler(object sender, GetIdentityInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetIdentityInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetIdentityInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateUserAppConsentCompletedEventHandler(object sender, UpdateUserAppConsentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateUserAppConsentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UpdateUserAppConsentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumerateAppPermissionsCompletedEventHandler(object sender, EnumerateAppPermissionsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumerateAppPermissionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumerateAppPermissionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetDelegationTokenCompletedEventHandler(object sender, GetDelegationTokenCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetDelegationTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetDelegationTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
#endif    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ups\upsEmulator.cs ===
namespace Microsoft.XBox.Live.Server.Emulators.ups
{
    using System;
    using Microsoft.XBox.Live.Server.Emulators.Framework;
    
    public class upsEmulator : EmulatorFacadeBase<IUpsSoap>
    {
        protected override string HandlerName 
        {
            get 
            {
                return "upsEmulator.asmx";
            }
        }
        
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\emulators\ups\upsWSDL.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.2032.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;

namespace Microsoft.XBox.Live.Server.Emulators.ups
{


/// <remarks/>
[System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "1.1.4322.2032")]
[System.Web.Services.WebServiceBindingAttribute(Name="UpsWebServiceSoap", Namespace="urn:UpsWebService")]
public interface IUpsSoap {
    
    /// <remarks/>
    [System.Web.Services.WebMethodAttribute()]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("#GetProfileByAttributes", RequestNamespace="urn:UpsWebService", ResponseNamespace="urn:UpsWebService")]
    [return: System.Xml.Serialization.SoapElementAttribute("ppbstrProfileXMLArray")]
    string[] GetProfileByAttributes(string[] pbstrNetIDArray, string bstrAttribList, System.UInt32 ulFlags, out string pbstrErrorBlob);
    
    /// <remarks/>
    [System.Web.Services.WebMethodAttribute()]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("#UpdateProfile", RequestNamespace="urn:UpsWebService", ResponseNamespace="urn:UpsWebService")]
    void UpdateProfile(string[] pbstrProfileXMLArray);
    
    /// <remarks/>
    [System.Web.Services.WebMethodAttribute()]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("#DeleteProfile", RequestNamespace="urn:UpsWebService", ResponseNamespace="urn:UpsWebService")]
    void DeleteProfile(string[] pbstrNetIDArray, string bstrPropertyCollectionList);
}

/// <remarks/>
[System.Xml.Serialization.SoapTypeAttribute("WSSecurityHeader", "urn:UpsWebService")]
public class WSSecurityHeader : SoapHeader {
    
    /// <remarks/>
    public EnumSHVersion version;
    
    /// <remarks/>
    public string wssecurity;
    
    /// <remarks/>
    public string authorization;
    
    /// <remarks/>
    public string sitetoken;
    
    /// <remarks/>
    public string ppSoapHeader25;
}

/// <remarks/>
[System.Xml.Serialization.SoapTypeAttribute("EnumSHVersion", "urn:UpsWebService")]
public enum EnumSHVersion {
    
    /// <remarks/>
    eshHeader30,
    
    /// <remarks/>
    eshHeader25,
    
    /// <remarks/>
    eshNone,
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\svr\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\svr\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\test\dvt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\svr\EventParser.cs ===
// 
// EventHandler.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Event Collection Tool
// Xbox Online Service
// 
// Author: Pankajn

using System;
using System.Collections;
using xonline.common.service;

namespace xonline.server.eventsink.svr
{
	/// <summary>
	/// this class is used to parse titleid, userpuids and team puids from SGINFO, SGAuth and BundaledAuth
	/// </summary>
	class EventParser
	{
        public static string Description;
		
		public static int TitleId=0;
		public static int AltTitleid=0;
        public static ulong[] Users = new ulong[4];
        
        

		/// <summary>
		/// function that parses Event message to extract Auth information
		/// </summary>
		/// <param name="mess"></param>
		public static void Parse(string mess)
		{
            Description = mess;
            for (int i = 0; i < Users.Length; i++)
            {
                Users[i] = 0;
            }
                
            
			try
			{
                string[] lines = mess.Split(new char[] { '\r', '\n' });
                
                foreach (string line in lines)
                {
                    string[] parts = line.Split(new char[] { ':' });
                    
                    if (parts.Length != 2)
                        continue;
                        
                    switch (parts[0])
                    {
                    case "TitleId":
                        TitleId = SafeConvert.ToInt32(parts[1].Trim());
                        break;
                        
                    case "U0":
                        Users[0] = ParseXuid(parts[1]);
                        break;
                        
                    case "U1":
                        Users[1] = ParseXuid(parts[1]);
                        break;
                        
                    case "U2":
                        Users[2] = ParseXuid(parts[1]);
                        break;
                        
                    case "U3":
                        Users[3] = ParseXuid(parts[1]);
                        break;
                    }        
                        
                    // todo: parse more
				}
			}
			catch(Exception e)
			{
				Description += "\r\nEVENTSINK:  Another exception happened while trying to parse the description!\r\n" + e.ToString();
			}


        }    
        
        
        // str looks something like " 0x9FFFF5299E9C8 (6700,0)"
        public static ulong ParseXuid(string str)
        {
            int start = str.IndexOf("0x");
            if (start == -1)
                return 0;

            start += 2;
                            
            int end = str.IndexOf(' ', start);
            if (end == -1)
                return 0;
                
            return Convert.ToUInt64(str.Substring(start, end-start), 16);
        }    

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\test\dvt\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\test\dvt\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_eventsinkdevtest_none_12.4.56.0_none_23be3543a35f2e0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventsinkdevtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.manifest
XP_MANIFEST_PATH=manifests\msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.cat
XP_CATALOG_PATH=manifests\msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.cat
XP_PAYLOAD_PATH=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventsinkdevtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\svr\EventsDB.cs ===
// 
// EventHandler.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Event Collection Tool
// Xbox Online Service
// 

using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Collections;
using System.IO;

using xonline.common.sql.sqlclient;
using xonline.common.config;

namespace xonline.server.eventsink.svr
{
	/// <summary>
	/// This class handles all database related operation.
	/// Events that need to be written to the db should be added to the queue using QueueEvent function
	/// </summary>
	public class EventsDB
	{
		

		/// <summary>
		/// Writes events to the db
		/// </summary>
		/// <param name="entry">Event to write to db </param>
		/// <returns>True indicating the event was successfully written else false</returns>
		public static void LogEvents(EventLogEntry[] entries)
		{
            DateTime lastTime = entries[0].TimeWritten;
            using (SqlClient cxn = new SqlClient(Interface.eventsdb))
            {
                cxn.StoredProc = "p_eventsink_log_event";
                
                cxn.BeginTransaction();
                
                foreach(EventLogEntry entry in entries)
                {
        			if (entry.TimeWritten != lastTime)
                    {
                        // Since events are collected on a one-second granularity, if multiple events happen in one
                        // second, and an event in the middle causes a failure, the remaining events in the 
                        // same second will not be logged.   So we commit only when the entire 1-sec block has been
                        // written. 
                        //
                        cxn.CommitTransaction();  
						
						// we need to stop
						if(EventSinkService.Shutdown())
							return ;

                        cxn.BeginTransaction();
                        
                        EventSinkService.LastEntryTime = lastTime;
                        lastTime = entry.TimeWritten;
                                              
                    }
                    
        			EventParser.Parse(entry.Message);
                    
    				// Set the parameters
    				cxn.AddParameter("@dt_time", entry.TimeGenerated);
    				cxn.AddParameter("@vc_app", entry.Source);
                    cxn.AddParameter("@c_type", entry.EntryType.ToString());
                    cxn.AddParameter("@i_event_id", (int)entry.InstanceId);
    				cxn.AddParameter("@vc_server", entry.MachineName);
    				cxn.AddParameter("@i_title_id", EventParser.TitleId);
                    // TODO: allow for really large descriptions
                    if (EventParser.Description.Length > 7050)
                    {
    				    cxn.AddParameter("@vc_description", EventParser.Description.Substring(0, 7050));
                    }
                    else 
                    {
    				    cxn.AddParameter("@vc_description", EventParser.Description);
                    }                    
                    
                    // this is to make sure the SqlCommand doesn't try to convert it to ntext..
                    cxn.Command.Parameters["@vc_description"].SqlDbType = SqlDbType.VarChar;                    
    				
    				for( int i=0; i < EventParser.Users.Length; i++)
    				{
    					if (EventParser.Users[i] != 0)
                        {
        					cxn.AddParameter("@bi_puid"+i, (long)EventParser.Users[i]);
                        }    
    				}
    				
    				// Execute the command
    				cxn.ExecuteNonQuery();
                    cxn.ClearParameters();
                    
                }				
                
                cxn.CommitTransaction();
                EventSinkService.LastEntryTime = lastTime;
            }
			
		}


		 
		/// <summary>
		/// Used to find datetime of the last event inthe db.
		/// </summary>
		/// <returns>returns the datetime of the last event entry in the db</returns>
		public static DateTime GetLastEntryTime()
		{
			using (SqlClient cmd = new SqlClient(Interface.eventsdb))
            {
                cmd.StoredProc = "p_eventsink_get_last_entry_time";
                cmd.AddParameter("@vc_server", Environment.MachineName);
                
                object o = cmd.ExecuteScalar();
                return (o == null ? DateTime.MinValue : (DateTime)o);
            }
		}

	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\test\dvt\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\test\dvt\eventsinkdevtest.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;

using ServerTestFramework;
using LiveService = ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;


using xonline.common.diagnostics;
using xonline.common.service;
using xonline.common.protocol;

using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.sql.sqlclient;
using xonline.common.stfutil;
using xonline.server.eventsink.svr;


[TestGroup, DVT]
public class EventSinkDevTest : TestNode
{
    EventSinkService _service;
        
    [TestGroupSetup]
    public void Setup()
    {
        
        // set up a few config overrides
        InterfaceInfo eventsDbIface = (InterfaceInfo)Config.GetSingleInterface(Interface.eventsdb);
        eventsDbIface.DBName = "eventsDb_test";
        
        Config.SetSingleInterface(Interface.eventsdb, eventsDbIface);
        
        Console.WriteLine("Setting up eventsDb_test databse..");
        using(SqlConnection cxn = DbUtil.CreateDb(Interface.eventsdb))
        {
            DbUtil.ExecuteSqlFile(cxn, Environment.GetEnvironmentVariable("_NT386TREE") + 
                                    "\\private\\sql\\npdb\\eventsdb\\eventsdb.sql");
        }                            
        // log the latest event time to now so we don't pick up everything else on this machine
        //

        Console.WriteLine("Writing most recent NT event to the events db...");            
        EventLog log = new EventLog();
        log.Log = "Application";   
        if (log.Entries.Count > 0)
        {
            EventsDB.LogEvents(new EventLogEntry[] { log.Entries[log.Entries.Count - 1] });
        }
        
        Console.WriteLine("Creating event source..");
        if (!EventLog.SourceExists("EventSinkDevTest"))
        {
            EventLog.CreateEventSource("EventSinkDevTest", "Application");
        }

        Console.WriteLine("Starting event sink..");
        _service = new EventSinkService();
        _service.Start();
            

                                
    }
    
    [TestGroupTearDown]
    public void Shutdown()
    {
        _service.Stop();
    }
        
        
    
    [TestCase]
    public void Baseline()
    {
        int eventId = new Random().Next() & 0xffff;
        
        string eventText = 
            "Dynamic Event(common\feapp\feapp.cs,182): Console attempted to write to a setting that it shouldn't! id: 10040001\r\n" +
            "\r\n" +
            "----- SG Info -----\r\n" +
            "ClientIP:  65.52.241.211\r\n" +
            "SG IP:    65.52.241.211\r\n" +
            "TitleId:   0x4D2\r\n" +
            "TitleVer:  0x1\r\n" +
            "TitleRgn:   0x0\r\n" +
            "ConsoleRgn: 0x0\r\n" +
            "MediaID: 0x0\r\n" +
            "LanguageID: 0\r\n" +
            "AuthDataFlags: 0x0\r\n" +
            "XboxLibVer: 0.0.0.0\r\n" +
            "MachineId: 0x9500000000000\r\n" +
            "U0: 0x9FFFF5299E9C8 (6700,0)\r\n" +
            "\r\n" +
            "SVC1: 0x1\r\n" +
            "SVC5: 0x5\r\n" +
            "SVC7: 0x7\r\n" +
            "SVC9: 0x9\r\n" +
            "SVC12: 0xC\r\n" +
            "SVC15: 0xF\r\n" +
            "SVC242: 0xF2\r\n" +
            "SVC243: 0xF3\r\n" +
            "SVC244: 0xF4\r\n" +
            "SVC245: 0xF5\r\n" +
            "SVC246: 0xF6\r\n" +
            "SVC247: 0xF7\r\n" +
            "SVC248: 0xF8\r\n" +
            "SVC249: 0xF9\r\n" +
            "SVC251: 0xFB\r\n" +
            "SVC252: 0xFC\r\n" +
            "SVC254: 0xFE\r\n" +
            "SVC255: 0xFF\r\n" +
            "no AltTitleID present\r\n" +
            "\r\n" +
            "----- Http Request -----\r\n" +
            "\r\n" +
            "URL:    /xstats/syncsettings.ashx\r\n" +
            "Headers:\r\n" +
            "  Content-Length: 43\r\n" +
            "  Content-Type: xon/7\r\n" +
            "  User-Agent: 7/1.0.4325\r\n" +
            "\r\n" +
            "X-Err: 0x80159200\r\n" +
            "\r\n" +
            "Event data contains POST buffer.\r\n" +
            "\r\n" +
            "\r\n" +
            "----- Request Data -----\r\n" +
            "\r\n" +
            "TitleId=1234\r\n" +
            "UserId=2814746857957832\r\n" +
            "Version=126817920000000000\r\n" +
            "StartinIndex=0\r\n" +
            "SettingsLen=1\r\n" +
            "Settings is an array of length 1\r\n" +
            "  Settings[0]=\r\n" +
            "    Source=2\r\n" +
            "    UserId=2814746857957832\r\n" +
            "    SettingId=268697601\r\n" +
            "    ValueLen=1\r\n" +
            "    Value=01\r\n" +
            "\r\n" +
            "\r\n" +
            "----- Exception 0 -----\r\n" +
            "xonline.common.service.XRLException: Console attempted to write to a setting that it shouldn't! id: 10040001\r\n" +
            "   at xonline.server.stats.fd.Profile.SyncSettings(UInt64 userId, UInt32 titleId, DateTime clientVersion, UInt16 startingIndex, UserSetting[] clientSettings, DateTime& serverVersion, UserSetting[]& serverSettings, UInt16& totalSettings) in e:\\src\\xonline\\main\\private\\server\\stats\\fd\\profile.cs:line 78\r\n" +
            "   at xonline.server.stats.fd.XRLSyncSettings.ProcessRequest(HttpContext ctx) in e:\\src\\xonline\\main\\private\\server\\stats\\fd\\xrlsyncsettings.cs:line 65\r\n" +
            "   at System.Web.CallHandlerExecutionStep.System.Web.HttpApplication+IExecutionStep.Execute()\r\n" +
            "   at System.Web.HttpApplication.ExecuteStep(IExecutionStep step, Boolean& completedSynchronously)\r\n" +
            "\r\n" +
            "\r\n" +
            "For more information, see Help and Support Center at http://go.microsoft.com/fwlink/events.asp.        \r\n" +
            "        \r\n";
            
        EventLog.WriteEntry("EventSinkDevTest", eventText, EventLogEntryType.Error, eventId);
        DateTime timeLogged = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, DateTime.Now.Hour, DateTime.Now.Minute, DateTime.Now.Second);
        
        using (SqlClient cmd = new SqlClient(Interface.eventsdb))
        {
            Console.WriteLine("Waiting a few seconds for the event to show up in the db...");
            
            cmd.Command.CommandText = "select * from t_events where i_event_id = " + eventId;
            SqlDataReader reader = null;
            
            for (int i = 0; i < 5; i++)
            {
                reader = cmd.Execute();
                if (reader.Read())
                {
                    break;
                }
                
                reader.Close();
                
                Thread.Sleep(1000);
            }
            
            Assert.IsTrue(!reader.IsClosed, "The event wasn't logged in a timely fashion!");
            
            Assert.AreEqual((DateTime)reader["dt_time"], timeLogged);
            Assert.AreEqual((string)reader["vc_app"], "EventSinkDevTest");
            Assert.AreEqual((string)reader["c_type"], "E");
            Assert.AreEqual((int)reader["i_event_id"], eventId);
            Assert.AreEqual((string)reader["vc_server"], Environment.MachineName);
            Assert.AreEqual((string)reader["vc_description"], eventText);
            Assert.AreEqual((int)reader["i_title_id"], 0x4d2);
            
            int index = (int)reader["i_index"];
            
            reader.Close();
                        
            cmd.Command.CommandText = "select * from t_event_puids where i_index = " + index;
            reader = cmd.Execute();
            
            Assert.IsTrue(reader.Read());
            Assert.AreEqual((ulong)(long)reader["bi_puid"], 0x9FFFF5299E9C8);
            
                    
        }    
    }
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\svr\ProjectInstaller.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Configuration.Install;
using xonline.common.config;

namespace eventsink
{
	/// <summary>
	/// Summary description for ProjectInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class ProjectInstaller : System.Configuration.Install.Installer
	{
		private System.ServiceProcess.ServiceProcessInstaller serviceProcessInstaller1;
		private System.ServiceProcess.ServiceInstaller eventsink;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public ProjectInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();

			// TODO: Add any initialization after the InitializeComponent call
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.serviceProcessInstaller1 = new System.ServiceProcess.ServiceProcessInstaller();
			this.eventsink = new System.ServiceProcess.ServiceInstaller();
			// 
			// serviceProcessInstaller1
			// 
            
            
            IComponentInfo compInfo = Config.GetComponent(xonline.common.config.Component.eventsink);
            
			this.serviceProcessInstaller1.Account = System.ServiceProcess.ServiceAccount.User;
			this.serviceProcessInstaller1.Username = compInfo.Username;

            CSetupSecureResolver decoder = new CSetupSecureResolver();
			this.serviceProcessInstaller1.Password = decoder.UserSecret(compInfo.Password);
            

			// 
			// eventsink
			// 
			this.eventsink.ServiceName = "eventsink";
            this.eventsink.DisplayName = "Xbox Live EventSink Service";
            this.eventsink.StartType = System.ServiceProcess.ServiceStartMode.Automatic;
			this.eventsink.AfterInstall += new System.Configuration.Install.InstallEventHandler(this.XEvents_AfterInstall);
			// 
			// ProjectInstaller
			// 
			this.Installers.AddRange(new System.Configuration.Install.Installer[] {
																					  this.serviceProcessInstaller1,
																					  this.eventsink});

		}
		#endregion

		private void XEvents_AfterInstall(object sender, System.Configuration.Install.InstallEventArgs e)
		{
		    System.ServiceProcess.ServiceController svc = new System.ServiceProcess.ServiceController("eventsink");
            svc.Start();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\svr\eventsink.cs ===
using System;                                  
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using System.Threading;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.trace)]

namespace xonline.server.eventsink.svr
{
	public class EventSinkService : System.ServiceProcess.ServiceBase
	{
		
        static XboxLiveThread _listenerThread = new XboxLiveThread(new ThreadStart(EventSinkService.ListenerProc));
        
        public static ManualResetEvent ShutdownEvent = new ManualResetEvent(false);
        public static DateTime LastEntryTime = DateTime.Now;        
        
        public EventSinkService()
        {
            this.ServiceName = "EventSink";
        }
                    
					
		
        static void Main()
		{
        
            try
            {
    			System.ServiceProcess.ServiceBase[] ServicesToRun;
    	
    			// More than one user Service may run within the same process. To add
    			// another service to this process, change the following line to
    			// create a second service object. For example,
    			//
    			//   ServicesToRun = new System.ServiceProcess.ServiceBase[] {new Service1(), new MySecondUserService()};
    			//
    			ServicesToRun = new System.ServiceProcess.ServiceBase[] { new EventSinkService() };
                Xom.Trace(XomAreaName.trace, LogLevel.L_LOW, "Staring eventsink service..");
    
    			System.ServiceProcess.ServiceBase.Run(ServicesToRun);
            }
            catch (Exception e)
            {
                EventBuilder.LogEvent(XEvent.Id.EVENTSINK_CODE_0, 
                    "Failure in starting the EventSink Service! ", e);
            }
		}


		/// <summary>
		/// Set things in motion so your service can do its work.
		/// </summary>
		protected override void OnStart(string[] args)
		{
        
            try
            {
                Xom.Trace(XomAreaName.trace, LogLevel.L_LOW, "Initalizing logging.");
                XomLoggingControl.Init();
    
                LastEntryTime = EventsDB.GetLastEntryTime();
                
                Xom.Trace(XomAreaName.trace, LogLevel.L_LOW, "Staring eventsink thread.");
                ShutdownEvent.Reset();
    			_listenerThread.Start();
            
            }
            catch (Exception e)
            {
                EventBuilder.LogEvent(XEvent.Id.EVENTSINK_CODE_1, 
                    "Failure in starting the EventSink Service! ", e);
            }
		}
 
		/// <summary>
		/// Stop this service.
		/// </summary>
		protected override void OnStop()
		{
            try
            {
                Xom.Trace(XomAreaName.trace, LogLevel.L_LOW, "Stopping eventsink thread.");
                ShutdownEvent.Set();
                
                // wait for the thread to stop
                _listenerThread.Join();
            }
            catch (Exception e)
            {
                EventBuilder.LogEvent(XEvent.Id.EVENTSINK_CODE_2, 
                    "Failure in stopping the EventSink Service! ", e);
            }
                
		}

		/// <summary>
		/// Start the service (for testing purposes)
		/// </summary>
        public void Start()
        {
            OnStart(null);
        }    

        /// <summary>
		/// Thread function will we used to check if its time to shutdown
		/// </summary>
		public static bool Shutdown()
		{
			return ShutdownEvent.WaitOne(0, false);
		}
        

		/// <summary>
		/// Thread function which repeatedly checks for new events 
		/// if the event if configured to write to db then the event is written to db else ingored.
		/// </summary>
		protected static void ListenerProc() 
		{
            EventLog log;
            bool logErrors = true;
            
            ArrayList eventList = new ArrayList();
            
			do
			{
				try
                {
                    
                    Xom.Trace(XomAreaName.trace, LogLevel.L_LOW, "ListenerProc: reloading eventlog.");
                    
                    log = new EventLog();
                    // todo: replace this with configured list
                    log.Log = "Application";   
                    
                    // TODO: replace this with the setting lists as soon as paul checks it in
                    string allAppsToExclude = Config.GetSetting(Setting.eventsink_excludeApps);
                    string[] appsToExclude = allAppsToExclude.Split(new char[] { ';' });
                    
                    
                    // we use now -1 seconds since the ntevent log has second accuracy
    				DateTime maxTime = DateTime.Now.AddSeconds(-1);

                    eventList.Clear();
    
                    Xom.Trace(XomAreaName.trace, LogLevel.L_LOW, "ListenerProc: found " + log.Entries.Count + " entires in the evenlog.");
    				
                    // find new events since the last time we checked
    				for(int i = log.Entries.Count - 1; i >= 0; i--)
    				{  
                        if(Shutdown())
							return;
    					EventLogEntry logEntry = log.Entries[i];
    					DateTime timeWritten = logEntry.TimeWritten;
                        
    					if (logEntry.TimeWritten <= LastEntryTime)
                        {
                            break;
                        }
                        
                        if( logEntry.TimeWritten <= maxTime && !((IList)appsToExclude).Contains(logEntry.Source.ToLower().Trim()))
    					{
                            // always insert at the top of the list, so the resulting array is in ascending time
                            eventList.Insert(0, logEntry);
                        }
    				}
                    
                    
                    Xom.Trace(XomAreaName.trace, LogLevel.L_LOW, "ListenerProc: writing " + eventList.Count + " new entires to the db.");
    				
                    // write the events to db
                    if (eventList.Count > 0)
                        EventsDB.LogEvents((EventLogEntry[])eventList.ToArray(typeof(EventLogEntry)));
                        
                    
                    // success!  log any future errors 
                    logErrors = true;
                    LastEntryTime = maxTime;
					
                }
                catch(Exception e)
                {
                    if (logErrors == true)
                    {
                        EventBuilder.LogEvent(XEvent.Id.EVENTSINK_COMM_0, 
                            "Failure in Polling events!   See exception below.\r\n" + 
                            "NOTE: while the eventsink will keep trying, no additional error events " +
                            "will be logged until it's successful again.\r\n", e);
                            
                        logErrors = false;    
                    }
                }    
                
                // wait aother second, or until it's time to shut down.
			}
            while(!ShutdownEvent.WaitOne(1000, false));
			
			
			

		}
		



	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\eventsink\test\dvt\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_eventsinkdevtest_none_12.4.56.0_none_23be3543a35f2e0d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=eventsinkdevtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.manifest
XP_MANIFEST_PATH=manifests\msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.cat
XP_CATALOG_PATH=manifests\msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd.cat
XP_PAYLOAD_PATH=msil_eventsinkdevtest_no-public-key_12.4.56.0_x-ww_0bdfe3dd
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=eventsinkdevtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\ESearch\SyntaxTemplate.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

public partial class SyntaxTemplate : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\ESearch\Default.aspx.cs ===
/// ================================================================================================================
/// Program Name: ESearch
/// Description:  
/// Version:      1.2
///
/// ---------- ----------- ------------- ---------------------------------------------------------------------------
///    Date      Version     Developer           Description
/// ---------- ----------- ------------- ---------------------------------------------------------------------------
/// 05/01/2008 1.00.00.000 ESearch Dev? - Original  
/// 06/26/2008 1.00.00.001 Richard Loba - Implementing BadWords validation code I created 05/01/2008.
///                                     - Added commented out code which handles no rows returned.
///                                       Can be caused by empty DB or ESearch <=> SQL DB connection issues.
///                                       This code an be un-commented out when we are ready for some real tesing.
/// 08/14/2008 1.01.00.000 Richard Loba - Created WebServiceProxy helper class to interface to the newly created
///                                       PerfDATA Web Service's single point configuration methods.
///                                     - Implementing all original Web.Config configuration strings to get them
///                                       from the newly added PerfDATA configuration WebService methods.
/// 08/26/2008 1.01.000 Richard Loba    - Added in Production enviornment code, for Prod Release.
/// ================================================================================================================

using System;
using System.Configuration;
using System.Collections;
using System.ComponentModel;
using System.Xml;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;
using System.Globalization;


namespace Events
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
    public partial class WebForm1 : System.Web.UI.Page
    {
        //static public PerfDataWS.PerfDataWebService oPerfDataWS = new PerfDataWS.PerfDataWebService();

        public WebServiceProxy oProxy = new WebServiceProxy();





        protected void Page_Load(object sender, System.EventArgs e)
        {
            LoadBadWords(); // [RichLoba] - ESearch string uses these words to validate against 
            LoadLinks();
           
            SetTimeVars();

            if (!this.IsPostBack)
            {
                //happens only when the page is first loaded
               
                //sets the default environment to testnet (the dropdown box hasn't loaded yet)
                BuildEnvDropDown();
                EnvDropDown.SelectedIndex = 0;
                EventDB.SetEnvironment(EnvDropDown.SelectedValue, "");
                //EventDB.SetEnvironment("testnet", path);
                // NPDB.SetEnvironment("testnet");
                //serverlist is actually serviceslist

                ServerList.Items.Clear();
                ServerList.Items.Add(new ListItem("<All Services>", "All Services"));
                EventDB.GetServicesList(ServerList.Items);
                ServerList.SelectedIndex = 0;

                //string env = "TESTNET";
                //testNetTime.Text = env + " Time in " + TimeZoneText + ":  " + DateTime.Now.AddHours(TimeOffset);
                Form1.DefaultButton = Search.UniqueID;
            }
            else if (Request.Form.GetValues(0)[0].Equals("CopyButton"))
            {
                Form1.DefaultButton = Search.UniqueID;
                if (RSearch.Visible == false)
                {
                    Form1.DefaultButton = backtoResults.UniqueID;
                }
            }
            //DEAL WITH ENVIRONMENT SELECTION
            
            string env = EnvDropDown.SelectedValue;
            //EventDB.SetEnvironment(EnvDropDown.SelectedValue, path);
            //NPDB.SetEnvironment(EnvDropDown.SelectedValue);
            testNetTime.Text = env + " Time in " + TimeZoneText + ": " + DateTime.Now.AddHours(TimeOffset);
            NoResultsLabel.Text = "No Results Found";
        }

        private void BuildEnvDropDown()
        {
            EnvDropDown.Items.Clear();

            //load from the xml file
            /*string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1);
            path += "ConfigXML\\ESearch.xml";
            try
            {
                XmlDocument ESearchXML = new XmlDocument();
                ESearchXML.Load(path);

                XmlNode ESearch = ESearchXML.SelectSingleNode("descendant::ESearch");

                XmlNode Environments = ESearch.SelectSingleNode("descendant::SupportedEnvironments");
                foreach (XmlNode envs in Environments.ChildNodes)
                {
                    EnvDropDown.Items.Add(new ListItem(envs.Attributes["Name"].Value, envs.Attributes["Name"].Value));
                }

                if (EnvDropDown.Items.Count == 0)
                    throw new XmlException("No Environments loaded for ESearch. Please edit the xml file in " + path + " to include supported evnironments");

            }*/
             try
            {
                WebServiceProxy oProxy = new WebServiceProxy();

                string envList = oProxy.GetConfigurationString( WebServiceProxy.VARIABLE_ENVIRONMENTS);

                if (envList == "")
                    throw new Exception("No Environments loaded for ESearch. Please edit web.config to include supported environments in the appSettings portion. Use this code: <add key=\"Environments\" value=\"env1,env3,env3\"/>");
                string[] envs = envList.Split(',');
                foreach (string env in envs)
                {
                    EnvDropDown.Items.Add(new ListItem(env, env));
                }
                if (EnvDropDown.Items.Count == 0)
                    throw new Exception("No Environments loaded for ESearch. Please edit web.config to include supported environments in the appSettings portion. Use this code: <add key=\"Environments\" value=\"env1,env3,env3\"/>");
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading environments from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();

                //reverting to defaults:
                EnvDropDown.Items.Add(new ListItem("Error", "Error"));
            }
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.DataGrid1.PageIndexChanged += new System.Web.UI.WebControls.DataGridPageChangedEventHandler(this.DataGrid1_PageIndexChanged);
            this.DataGrid1.SortCommand += new System.Web.UI.WebControls.DataGridSortCommandEventHandler(this.DataGrid1_SortCommand);
            //this.ImageButton1.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton1_Click);
            //this.ImageButton2.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton2_Click);


        }
        #endregion

        //BUTTON CLICKED FUNCTIONS

        //the button next to the environment dropdown was clicked: means that the environment has changed
        protected void DropDownButton_Click(object sender, ImageClickEventArgs e)
        {
            string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1);
            path += "ConfigXML\\";
            EventDB.SetEnvironment(EnvDropDown.SelectedValue, path);
            //NPDB.SetEnvironment(EnvDropDown.SelectedValue);

            //rebuild the dropdown services list on the RSearch panel (different environments have different services)
            ServerList.Items.Clear();
            ServerList.Items.Add(new ListItem("<All Services>", "All Services"));
            EventDB.GetServicesList(ServerList.Items);
            ServerList.SelectedIndex = 0;

            if (AdvSearchPanel.Visible == true)
            {
                //if the Advanced Search panel is viewable, rebuild environment specific objects
                //otherwise, they will rebuild when the panel becomes visible (the advsearch button is clicked)
                CheckBoxList1.Items.Clear();
                EventDB.GetServicesList(CheckBoxList1.Items);
                BuildMachineTree();
            }
            //if the results panel is visible, the results panel is no longer valid. return to original screen
            if (Results.Visible == true)
            {
                BackToMainPage();
            }
            SetDefaultButtons();
        }

        //the simple search button was clicked
        protected void Search_Click(object sender, System.EventArgs e)
        {


            /* [RichLoba] - If you have bad characters then continue because
             * If you have old results, and bad characters, then the bad results will be removed so you will get
             * Invalid characters/words and no records returned.
             * Verify there are not issues with any SQL injection, etc.
             * The new validation code was not there to resolve SQL injection, just to provide an indicator of the reason for
             * no rows returned. This quick fix was added to the legal stuff required to drop to the new TEST III box system.
            */
            /*
                if (Page.IsValid == false)
                {
                    return;
                }
                           
                
                if (!SearchStringValid())
                {
                    return;
                }
            
            */










            //CopyButton.Visible = false;
            CopyButton2.Visible = false;
            DetailPanel.Visible = false;
            Results.Visible = true;
            DataGrid1.Visible = false;
            NoResultsLabel.Visible = false;
            Form1.DefaultButton = Search.UniqueID;
            //Regular search
            ArrayList tmp = EventDB.GetTableList();
            bool IsTop1000 = true;

            if (!CheckBox2.Checked)
                IsTop1000 = false;

            string query = QueryBuilder.GetReqularQuery(tb_contains.Text, ServerList.SelectedItem.Value, TypeList.SelectedItem.Value, IsTop1000, ((EventTB)tmp[0]).Name);
            DataView view = LoadData(query, null, ((EventTB)tmp[0]).Name);

            if (view.Count < 1000)
            {
                string query2 = QueryBuilder.GetReqularQuery(tb_contains.Text, ServerList.SelectedItem.Text, TypeList.SelectedItem.Text, IsTop1000, ((EventTB)tmp[1]).Name);
                view = LoadData(query2, view, ((EventTB)tmp[1]).Name);
            }

            if (view.Count == 0)
            {
                //no results returned in the query. Show the label that says so
                NoResultsLabel.Visible = true;
                return;
            }
            DataGrid1.DataSource = view;
            DataGrid1.CurrentPageIndex = 0;
            DataGrid1.CurrentPageIndex = 0;
            DataGrid1.DataBind();
            DataGrid1.Visible = true;
        }

        // ===================================================================================================
        // <<<<<<<<<<<<<<<<<<<<<<<<<<<   ESearch BAD CHARACTER/Word STRING >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        // ===================================================================================================
        // [ RichLoba ] - [ START ]
        //              1. BadChars Validation String
        //                 BadChars contains the bad chars searched for in the Search String validation.
        //                 Add / delete any characters you want here and compile.
        //              2. BadWords Validation ArrayList
        //                 ESearch will search for any words loaded in the BadWord ArrayList.
        //                 To add additional words to the BadWords ArrayList, just follow the action in the
        //                 LoadBadWord() method.
        //                 For example, if you want to add the word "Like", as a bad word then you will add
        //                 the following line to the LoadBadWords() method.
        //
        //                 BadWords.Add("LIKE");
        //
        //              3. The string BadWordsOrCharsErrorMessage is dynamically loaded depending on the actual
        //                 validation error. Since you can have bad characters, bad words, or both the message
        //                 is built to clearly show only the true error. Ex: if there are only bad characters
        //                 it will only show bad characters, not bad words, etc.
        // ===================================================================================================
        
            private string BadChars = "<>-'"; // <- Add characters between the quotes.

            private ArrayList BadWords = new ArrayList();

            public string BadWordsOrCharsErrorMessage ; 

            private void LoadBadWords()
            {
                BadWords.Add("UNION");
            }

        // ===================================================================================================
        // [ RichLoba ] - [ END ] - BadChars, BadWords Validation String >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
        // ===================================================================================================

        public int TimeOffset       = 0;        //to convert from GMT to PST
        public string TimeZoneText  = "GMT";

        //stupid function because XETESTSQL001 does not use DST.
        protected void SetTimeVars()
        {
            Boolean IsDST = false;
            int year = DateTime.Now.Year;
            if (year == 2007)
            {
                if (DateTime.Now.DayOfYear >= 70 && DateTime.Now.DayOfYear < 308)
                    IsDST = true;
            }
            //leap year
            if (year == 2008)
            {
                if (DateTime.Now.DayOfYear >= 69 && DateTime.Now.DayOfYear < 307)
                    IsDST = true;
            }
            if (year == 2009)
            {
                if (DateTime.Now.DayOfYear >= 67 && DateTime.Now.DayOfYear < 305)
                    IsDST = true;
            }
            if (year == 2010)
            {
                if (DateTime.Now.DayOfYear >= 73 && DateTime.Now.DayOfYear < 311)
                    IsDST = true;
            }
            if (PSTRadioButton.Checked == true)
            {
                TimeZone time = TimeZone.CurrentTimeZone;
                DaylightTime temp = time.GetDaylightChanges(DateTime.Now.Year);
                if (IsDST) TimeOffset = -7;
                else TimeOffset = -8;
                TimeZoneText = "PST";
            }
            else
            {
                TimeOffset = 0;
                TimeZoneText = "GMT";
            }
        }

        // ============================================================================================================
        // Method Name: SetEnvironment
        // Description: 
        // Version:      1.2
        //
        // ========== =========== ============ ========================================================================
        // Date       Version Developer           Description
        // ========== =========== ============ ========================================================================
        // ??/??/???? 1.00.00.000 ESearch Dev? - Original - got configuration information from local Web.Config.
        // 08/13/2008 1.01.01.000 Richard Loba - Converted to use the common PerfData web service.
        // ============================================================================================================

        private void LoadLinks()
        {
            WebServiceProxy oProxy = new WebServiceProxy();

            try
            {
                ESearchLink.NavigateUrl      = oProxy.GetConfigurationString( WebServiceProxy.WEB_SITE_LINK_ESEARCH    ) ;
                PerfDADLink.NavigateUrl      = oProxy.GetConfigurationString( WebServiceProxy.WEB_SITE_LINK_PERFDAD    ) ;
                GrapherLink.NavigateUrl      = oProxy.GetConfigurationString( WebServiceProxy.WEB_SITE_LINK_GRAPHER    ) ;
                RegressionLink.NavigateUrl   = oProxy.GetConfigurationString( WebServiceProxy.WEB_SITE_LINK_REGRESSION ) ;
                ReportingLink.NavigateUrl    = oProxy.GetConfigurationString( WebServiceProxy.WEB_SITE_LINK_REPORTING  ) ; 

                if(Convert.ToInt32( oProxy.GetConfigurationString( WebServiceProxy.VARIABLE_SHOW_ENVIRONMENT_REGRESSION)) == 0) 
                {
                     RegressionLink.Visible = false;
                    LeftNavGoImage4.Visible = false;
                }
            }
            catch(Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading links from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();

                ESearchLink.Visible = false;
                GrapherLink.Visible = false;
                PerfDADLink.Visible = false;
                RegressionLink.Visible = false;
                ReportingLink.Visible = false;
            }
        }

        public bool ShowThisLink(int iWhichLink)
        {


            //VARIABLE_SHOW_ENVIRONMENT_REGRESSION



            return true;

        }




        //the show advanced options button was clicked
        protected void AdvSearch_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = true;
            AdvSearchPanelshort.Visible = true;
            DetailPanel.Visible = false;
            Results.Visible = false;
            RSearch.Visible = false;
            refine.Visible = false;
            ReQuery.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            CopyButton2.Visible = false;
            DateTime today = DateTime.Today;
            DateTime lowerd = today.AddDays(-3);
            calendarPopup1.UpperBoundDate = today;
            //calendarPopup1.LowerBoundDate= lowerd;
            Calendarpopup2.UpperBoundDate = today;
            //Calendarpopup2.LowerBoundDate= lowerd;
            initAdvtab();

        }
        //the advanced search button was clicked
        protected void AdvSearchBt_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = false;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = true;
            ReQuery.Visible = true;
            Results.Visible = true;
            Form1.DefaultButton = refine.UniqueID;
            NoResultsLabel.Visible = false;
            DataGrid1.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;


            ///Advance Search
            ArrayList tmp = EventDB.GetTableList();
            //make sure we use the correct tables.
            DataView view = null;
            try
            {
                if (CheckBox1.Checked == true)
                {
                    DateTime start = Calendarpopup2.SelectedDate.Date;
                    start = start.AddHours(Convert.ToInt32(Tbstarthh.Text));
                    start = start.AddMinutes(Convert.ToInt32(tbstartmm.Text));
                    //convert BACK to GMT if needed
                    start = start.AddHours(-TimeOffset);

                    DateTime end = calendarPopup1.SelectedDate.Date;
                    end = end.AddHours(Convert.ToInt32(Tbendhh.Text));
                    end = end.AddMinutes(Convert.ToInt32(tbendmm.Text));
                    //convert BACK to GMT if needed
                    end = end.AddHours(-TimeOffset);

                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i == 0)
                            etb.EndTime = DateTime.Now;
                        if (DateTime.Compare(etb.stTime, end) <= 0 && DateTime.Compare(etb.EndTime, end) > 0)
                        {
                            for (; i < tmp.Count; i++)
                            {
                                etb = (EventTB)tmp[i];
                                if (DateTime.Compare(etb.EndTime, start) <= 0)
                                    break;
                                view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);
                            }
                        }
                    }


                }
                else
                {
                    int Durationinmin = Convert.ToInt32(TextBox1.Text);
                    DateTime current = DateTime.Now;
                    DateTime stRange = current.AddMinutes(-1 * Durationinmin);
                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i > 0 && DateTime.Compare(etb.EndTime, stRange) <= 0)
                            break;
                        view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);

                    }
                }

                if (view.Count == 0)
                {
                    //no results returned in the query. Show the label that says so
                    NoResultsLabel.Visible = true;
                    return;
                }
                DataGrid1.PageSize = Convert.ToInt32(ddl_PageSize.SelectedItem.Value, 10);
                DataGrid1.DataSource = view;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.DataBind();
                DataGrid1.Visible = true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading input from advanced search criteria page.\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                NoResultsLabel.Visible = true;
                NoResultsLabel.Text = "Error in advanced search inputs";
            }
        }

        //the return to search button on the results panel was clicked
        protected void refine_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = true;
            Form1.DefaultButton = AdvSearchBt.UniqueID;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = false;
            ReQuery.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            CopyButton2.Visible = false;
        }
        //the requery button on the results panel was clicked-- resends the query w/updated time
        protected void ReQuery_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = false;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = true;
            ReQuery.Visible = true;
            Form1.DefaultButton = refine.UniqueID;
            Results.Visible = true;
            DataGrid1.Visible = false;
            NoResultsLabel.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;

            ArrayList tmp = EventDB.GetTableList();
            ((EventTB)tmp[0]).EndTime = DateTime.Now;
            DataView view = null;
            try
            {
                if (CheckBox1.Checked == true)
                {
                    DateTime start = Calendarpopup2.SelectedDate.Date;
                    start = start.AddHours(Convert.ToInt32(Tbstarthh.Text));
                    start = start.AddMinutes(Convert.ToInt32(tbstartmm.Text));


                    DateTime end = calendarPopup1.SelectedDate.Date;
                    end = end.AddHours(Convert.ToInt32(Tbendhh.Text));
                    end = end.AddMinutes(Convert.ToInt32(tbendmm.Text));

                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i == 0)
                            etb.EndTime = DateTime.Now;
                        if (DateTime.Compare(etb.stTime, end) <= 0 && DateTime.Compare(etb.EndTime, end) > 0)
                        {
                            for (; i < tmp.Count; i++)
                            {
                                etb = (EventTB)tmp[i];
                                if (DateTime.Compare(etb.EndTime, start) <= 0)
                                    break;
                                view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);
                            }
                        }
                    }


                }
                else
                {
                    int Durationinmin = Convert.ToInt32(TextBox1.Text);
                    DateTime current = DateTime.Now;
                    DateTime stRange = current.AddMinutes(-1 * Durationinmin);
                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i > 0 && DateTime.Compare(etb.EndTime, stRange) <= 0)
                            break;
                        view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);

                    }
                }
                ///Advance Search

                if (view.Count == 0)
                {
                    //no results returned in the query. Show the label that says so
                    NoResultsLabel.Visible = true;
                    return;
                }
                DataGrid1.PageSize = Convert.ToInt32(ddl_PageSize.SelectedItem.Value, 10);
                DataGrid1.DataSource = view;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.DataBind();
                DataGrid1.Visible = true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading input from advanced search criteria page.\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                NoResultsLabel.Visible = true;
                NoResultsLabel.Text = "Error in advanced search inputs";
            }

        }
        //backtoresults button on the details page was clicked
        protected void backtoResults_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = false;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = true;
            ReQuery.Visible = true;
            Results.Visible = true;
            Form1.DefaultButton = refine.UniqueID;
            NoResultsLabel.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            //CopyButton2.Visible = false;
        }

        //check/uncheck all buttons above the machine tree
        protected void CheckAllButton_Click(object sender, EventArgs e)
        {
            while (MachineTree.CheckedNodes.Count != 0)
            {
                MachineTree.CheckedNodes[0].Checked = false;
            }
            foreach (TreeNode type in MachineTree.Nodes)
            {
                type.Checked = true;
                type.Expanded = false;
            }
        }
        protected void UncheckAllButton_Click(object sender, EventArgs e)
        {
            //hint: as soon as you uncheck a node, it is removed from CheckedNodes
            while (MachineTree.CheckedNodes.Count != 0)
            {
                MachineTree.CheckedNodes[0].Checked = false;
            }

        }


        protected void DataGrid1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            DetailPanel.Visible = true;
            backtoResults.Visible = true;
            Form1.DefaultButton = Search.UniqueID;
            if (RSearch.Visible == false)
            {
                Form1.DefaultButton = backtoResults.UniqueID;
            }
            Results.Visible = false;
            //DataGrid1.Visible = false;
            //NoResultsLabel.Visible = false;
            //determine which copy button to turn on
            if (RSearch.Visible == true)
            {
                CopyButton2.Visible = true;
            }
            else
            {
                CopyButton.Visible = true;
            }
            populateDetail();

        }

        private void DataGrid1_PageIndexChanged(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
        {
            try
            {
                DataView dv = (DataView)Session["Dataview"];
                // Set CurrentPageIndex to the page the user clicked.
                DataGrid1.CurrentPageIndex = e.NewPageIndex;

                // Re-bind the data to refresh the DataGrid control. 
                DataGrid1.DataSource = dv;
                DataGrid1.DataBind();
                Form1.DefaultButton = Search.UniqueID;
                if (RSearch.Visible == false)
                {
                    Form1.DefaultButton = refine.UniqueID;
                }
            }
            catch (Exception)
            {
                //session expired, do something
                BackToMainPage();
            }
        }

        private void DataGrid1_SortCommand(object source, System.Web.UI.WebControls.DataGridSortCommandEventArgs e)
        {
            try
            {
                DataView dv = (DataView)Session["Dataview"];


                string sortorder = (string)Session["sortorder"];
                if (sortorder == "DESC")
                {
                    dv.Sort = "DateTime ASC";
                    Session.Add("sortorder", "ASC");
                }
                else
                {
                    dv.Sort = "DateTime DESC";
                    Session.Add("sortorder", "DESC");
                }
                // Re-bind the data to refresh the DataGrid control. 
                DataGrid1.DataSource = dv;
                DataGrid1.DataBind();
            }
            catch (Exception)
            {
                //the session expired, restart everthing.
                BackToMainPage();
            }
        }



        //private helper functions
        protected DataView LoadData(string mySelectQuery, DataView dvold, string tbname)
        {
            DataView dv = EventDB.GetResult(mySelectQuery, (dvold == null ? null : dvold.Table), tbname, TimeOffset);
            if (dv.Table.Rows.Count == 0)
            {
                //No results were returned in the query
            }
            dv.Sort = "DateTime DESC";
            Session.Add("Dataview", dv);
            Session.Add("sortorder", "DESC");
            Session.Add("currentPage", (int)0);

            return dv;

        }

        private string BuildAdvQuery(string tbname)
        {

            QueryData Qdata = new QueryData();
            try
            {

                //free text searching
                Qdata.AllWordstxt = AllWords.Text;
                Qdata.Atlestwords = Atlestwords.Text;
                Qdata.NoWords = NoWords.Text;

                //services
                for (int p = 0; p < CheckBoxList1.Items.Count; p++)
                {
                    if (CheckBoxList1.Items[p].Selected)
                        Qdata.vc_apps.Add(CheckBoxList1.Items[p].Text);
                }

                //event type
                for (int p = 0; p < CheckBoxList2.Items.Count; p++)
                {
                    if (CheckBoxList2.Items[p].Selected)
                        Qdata.Etypes.Add(CheckBoxList2.Items[p].Text);

                }

                //event time 
                if (CheckBox1.Checked == true)
                {
                    //use time range
                    Qdata.useDateRange = true;

                    DateTime start = Calendarpopup2.SelectedDate.Date;
                    start = start.AddHours(Convert.ToInt32(Tbstarthh.Text));
                    start = start.AddMinutes(Convert.ToInt32(tbstartmm.Text));
                    //convert back to GMT time
                    start = start.AddHours(-TimeOffset);
                    Qdata.start = start;

                    DateTime end = calendarPopup1.SelectedDate.Date;
                    end = end.AddHours(Convert.ToInt32(Tbendhh.Text));
                    end = end.AddMinutes(Convert.ToInt32(tbendmm.Text));
                    //convert back to GMT time
                    end = end.AddHours(-TimeOffset);
                    Qdata.end = end;


                }
                //otherwise use last 30 minutes
                else
                {
                    Qdata.useDateRange = false;
                    Qdata.Durationinmin = Convert.ToInt32(TextBox1.Text);
                }

                //trace through tree to find individually selected machine names 
                Qdata.AllChecked = true;
                foreach (TreeNode root in MachineTree.Nodes)
                {
                    //determine if an "allxxx" root node is selected
                    if (!root.Checked)
                    {
                        Qdata.AllChecked = false;
                        foreach (TreeNode leaf in root.ChildNodes)
                        {
                            if (leaf.Checked)
                            {
                                if (!Qdata.CompNames.Contains(leaf.Text.Trim()))
                                {
                                    Qdata.CompNames.Add(leaf.Text.Trim());
                                }
                            }
                        }
                    }
                    else
                    {
                        foreach (TreeNode leaf in root.ChildNodes)
                        {
                            if (!Qdata.CompNames.Contains(leaf.Text.Trim()))
                            {
                                Qdata.CompNames.Add(leaf.Text.Trim());
                            }
                        }
                    }
                }

                /*foreach (ListItem item in Computernames.Items)
                {
                    if(item.Selected)
                        Qdata.CompNames.Add(item.Text.Trim());
                }*/
                //eventID
                Qdata.Events = tb_eventids.Text.Trim();
                //event title
                Qdata.titles = tb_Title.Text.Trim();
                //whether or not to exclude or include the ID or title
                Qdata.ExcludeEvents = excludeevents.Checked;
                Qdata.Excludetitles = excludetitle.Checked;
                //Qdata.gamertags=txgamertag.Text.Trim();
            }
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error building advanced query.\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
            }


            //done gathering the info, ready to build the query!
            return QueryBuilder.GetAdvQuery(Qdata, tbname);

        }

        private void initAdvtab()
        {
            DateTime end = DateTime.Now.AddHours(TimeOffset);
            DateTime start = end.AddHours(-12);
            Calendarpopup2.SelectedDate = start;
            calendarPopup1.SelectedDate = end;

            Tbstarthh.Text = start.Hour < 10 ? "0" + start.Hour.ToString() : start.Hour.ToString();
            tbstartmm.Text = start.Minute < 10 ? "0" + start.Minute.ToString() : start.Minute.ToString();
            Tbendhh.Text = end.Hour < 10 ? "0" + end.Hour.ToString() : end.Hour.ToString();
            tbendmm.Text = end.Minute < 10 ? "0" + end.Minute.ToString() : end.Minute.ToString();

            DateTimeLabel.Text = "Enter Date and Time in " + TimeZoneText;
            Form1.DefaultButton = AdvSearchBt.UniqueID;
            //init environment specific objects
            CheckBoxList1.Items.Clear();
            EventDB.GetServicesList(CheckBoxList1.Items);
            BuildMachineTree();

        }

        private void populateDetail()
        {
            try
            {
                int reindex = (DataGrid1.CurrentPageIndex * DataGrid1.PageSize) + DataGrid1.SelectedIndex;

                DataView dv = (DataView)Session["Dataview"];

                if (reindex > dv.Count)
                {
                    return;
                }
                lbdate.Text = dv[reindex][3].ToString(); //date
                lbtime.Text = dv[reindex][4].ToString(); //time
                lbtype.Text = dv[reindex][2].ToString(); //type
                lbtitle.Text = dv[reindex][8].ToString();//title

                lbsource.Text = dv[reindex][5].ToString(); //source
                lbeventid.Text = dv[reindex][6].ToString(); //eventid
                lbcomputer.Text = dv[reindex][7].ToString(); //computer name
                //Label18.Text= "Occurrence Count Per Minute:-"+dv[reindex][10].ToString();
                string temp = (dv[reindex][10]).ToString();
                tb_Detail.Text = EventDB.GetEventDetail(dv[reindex][0].ToString(), temp);

                if (DataGrid1.CurrentPageIndex <= 0 && DataGrid1.SelectedIndex <= 0)
                    ImageButton1.Visible = false;
                else
                    ImageButton1.Visible = true;

                if (DataGrid1.CurrentPageIndex >= DataGrid1.PageCount && DataGrid1.SelectedIndex >= DataGrid1.PageSize)
                    ImageButton2.Visible = false;
                else
                    ImageButton2.Visible = true;
            }
            catch 
            {
                //session expired. Restart
                BackToMainPage();
            }
            //tb_Detail.Text = EventDB.GetEventDetail((int)dv[reindex][0],(string)(dv[reindex][11]).ToString());
        }

        private void BuildMachineTree()
        {
            //TreeNodeCollection roots = new TreeNodeCollection();
            ListItemCollection serverNames;
            serverNames = new ListItemCollection();

            //getserverlist will handle errors
            EventDB.GetServerList(serverNames, EnvDropDown.SelectedValue);
            
            MachineTree.Nodes.Clear();

            //assume items in serverNames are sorted by server TYPE
            //items in serverNames are composed (TEXT=<server name>,VALUE=<server type>)
            string previousname = "";
            TreeNode serverTypeNode = null;
            foreach (ListItem item in serverNames)
            {
                if (!item.Value.Equals(previousname))
                {
                    //we have encountered a new server TYPE name, create a new "root" server type node
                    previousname = item.Value;
                    serverTypeNode = new TreeNode(item.Value, item.Value);
                    serverTypeNode.Checked = true;
                    serverTypeNode.ShowCheckBox = true;
                    serverTypeNode.SelectAction = TreeNodeSelectAction.Expand;
                    //add as root node
                    MachineTree.Nodes.Add(serverTypeNode);
                }

                //add this server name as a child to the root node
                TreeNode temp = new TreeNode(item.Text.Trim(), item.Text.Trim());
                temp.Checked = false;
                temp.ShowCheckBox = true;
                temp.SelectAction = TreeNodeSelectAction.None;
                if (serverTypeNode.ChildNodes.Count == 0)
                    serverTypeNode.ChildNodes.Add(temp);
                else
                {
                    //insert the node in it's sorted place, childnodes is already sorted
                    int index = 0;
                    Boolean placed = false;
                    foreach (TreeNode sorteditem in serverTypeNode.ChildNodes)
                    {
                        int sort = temp.Text.CompareTo(sorteditem.Text);
                        if (sort <= 0)
                        {
                            //insert before sorted item
                            serverTypeNode.ChildNodes.AddAt(index, temp);
                            placed = true;
                            break;
                        }
                        index++;
                    }
                    if (!placed)
                        serverTypeNode.ChildNodes.AddAt(index, temp);
                }
            }
        }

        private void SetDefaultButtons()
        {
            Form1.DefaultButton = Search.UniqueID;

            //if we're on the results screen and the regular search button isn't visible, make the back to advanced options the default button
            if (RSearch.Visible == false)
            {
                Form1.DefaultButton = refine.UniqueID;
            }
            //otherwise, if we're looking at the details of an event, make the default button the back to results button
            if (DetailPanel.Visible == true)
            {
                Form1.DefaultButton = backtoResults.UniqueID;
            }
            //if we're on the advanced panel screen, make the default button the advanced search button
            //if advanced search options is visible, change the label and time searching variables
            if (AdvSearchPanel.Visible == true)
            {
                DateTimeLabel.Text = "Enter Date and Time in " + TimeZoneText;
                Form1.DefaultButton = AdvSearchBt.UniqueID;
            }
        }

        private void BackToMainPage()
        {
            RSearch.Visible = true;
            AdvSearchPanel.Visible = false;
            AdvSearchPanelshort.Visible = false;
            refine.Visible = false;
            ReQuery.Visible = false;
            Results.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            CopyButton2.Visible = false;
        }

        protected void ImageButton1_Click1(object sender, ImageClickEventArgs e)
        {
            //up, go to previous event on list

            if (DataGrid1.SelectedIndex - 1 < 0)
            {
                if (DataGrid1.CurrentPageIndex - 1 > 0)
                {
                    DataGrid1.CurrentPageIndex = DataGrid1.CurrentPageIndex - 1;
                    DataGrid1.SelectedIndex = DataGrid1.PageSize - 1;
                }
                else
                    return;
            }
            else
            {
                DataGrid1.SelectedIndex = DataGrid1.SelectedIndex - 1;
            }

            populateDetail();
        }
      
        protected void ImageButton2_Click1(object sender, ImageClickEventArgs e)
        {
            // Down, go to next event on list 

            if (DataGrid1.SelectedIndex + 1 >= DataGrid1.Items.Count)
            {

                if (DataGrid1.CurrentPageIndex + 1 < DataGrid1.PageCount)
                {
                    DataGrid1.CurrentPageIndex = DataGrid1.CurrentPageIndex + 1;
                    DataGrid1.SelectedIndex = 0;
                }
                else
                    return;
            }

            else
            {
                DataGrid1.SelectedIndex = DataGrid1.SelectedIndex + 1;
            }

            populateDetail();
        }
        
        // [RichLoba ] - [START] - Bad character code


        private bool SearchStringValid()
        {
            int start       = 0;
            int StrLength   = tb_contains.Text.Length;
            int BadCharHit;
            
            char[] BadCharList = BadChars.ToCharArray();
            
            if(tb_contains.Text == "")           return true;   // blank is ok

            BadCharHit = tb_contains.Text.IndexOfAny(BadCharList, start, StrLength);

            if (BadCharHit > -1)
                return false;
            else
                return true;
        }



        private bool BadCharsFound()
        {
            int start       = 0;
            int StrLength   = tb_contains.Text.Length;
            int BadCharHit;
            
            char[] BadCharList = BadChars.ToCharArray();
            
            if(tb_contains.Text == "")           return false;   // blank is ok

            BadCharHit = tb_contains.Text.IndexOfAny(BadCharList, start, StrLength);

            if (BadCharHit > -1)

                return true;   // bad chars found
            else
                return false;  // string ok
        }

        private bool BadWordsFound()
        {
            for(int i = 0; i < BadWords.Count ; i++)
            {
                if(tb_contains.Text.Contains(BadWords[i].ToString()))

                    return true;
            }

            return false;
        }


        protected void ValidateESearchString(ServerValidateEventArgs args)
        {
            bool BadCharsFoundResults = BadCharsFound();
            bool BadWordsFoundResults = BadWordsFound();

            if (BadCharsFoundResults && !BadWordsFoundResults)

                BadWordsOrCharsErrorMessage = "Your Search String contains invalid characters.<br> ";

            else if (!BadCharsFoundResults && BadWordsFoundResults)

                BadWordsOrCharsErrorMessage = "Your Search String contains invalid words.<br> ";

            else if (BadCharsFoundResults || BadWordsFoundResults)

                BadWordsOrCharsErrorMessage = "Your Search String contains invalid words or characters.<br> ";

            if (BadCharsFoundResults)

                BadWordsOrCharsErrorMessage += "Bad characters are: " + BadChars + "<BR>";

            if (BadWordsFoundResults)
            {
                BadWordsOrCharsErrorMessage += "Bad words are: ";

                for (int i = 0; i < BadWords.Count; i++)
                {
                    BadWordsOrCharsErrorMessage += BadWords[i].ToString();

                    if (i + 1 != BadWords.Count)

                        BadWordsOrCharsErrorMessage += ", ";
                }

            }

            if (BadCharsFoundResults || BadWordsFoundResults)

                args.IsValid = false;
        }

        protected void CustomValidator3_ServerValidate(object source, ServerValidateEventArgs args)
        {
            ValidateESearchString(args);
        }


        protected void AllWords_TextChanged(object sender, EventArgs e)
        {

        }
        protected void tb_contains_TextChanged(object sender, EventArgs e)
        {

        }

        // [RichLoba ] - [END] - Bad character code

        public void ShowLeftNavLinks()
        {
            WebServiceProxy oProxy = new WebServiceProxy();

            if( 0 == Convert.ToInt32( oProxy.GetConfigurationString( WebServiceProxy.VARIABLE_SHOW_ENVIRONMENT_REGRESSION)))

                ShowRegressionLinks();
        }

        public void ShowRegressionLinks()
        {
            string RegressionLinkString = string.Empty;

            RegressionLinkString += "<tr>";
            RegressionLinkString += "<td  class='TableCellNoBorder' style='width: 9px' align=center><img src='images/go.gif' border='0' alt='App''/></td>";
            RegressionLinkString += "<td  class='TableCellNoBorder' style='width: 94px; text-align: left;'>";
            RegressionLinkString += "<asp:HyperLink ID='RegressionLink' runat='server' NavigateUrl='http://localhost/Regression'>Regression</asp:HyperLink>'";           RegressionLinkString += "</td>";
            RegressionLinkString += "</tr>";

            Response.Write(RegressionLinkString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\ESearch\Default.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Events {
    
    
    /// <summary>
    /// WebForm1 class.
    /// </summary>
    /// <remarks>
    /// Auto-generated class.
    /// </remarks>
    public partial class WebForm1 {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
        
        /// <summary>
        /// EnvDropDown control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList EnvDropDown;
        
        /// <summary>
        /// DropDownButton control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ImageButton DropDownButton;
        
        /// <summary>
        /// XENPDBSQL001_NPDB control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.SqlDataSource XENPDBSQL001_NPDB;
        
        /// <summary>
        /// PSTRadioButton control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RadioButton PSTRadioButton;
        
        /// <summary>
        /// GMTRadioButton2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RadioButton GMTRadioButton2;
        
        /// <summary>
        /// LeftNavGoImage1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Image LeftNavGoImage1;
        
        /// <summary>
        /// ESearchLink control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.HyperLink ESearchLink;
        
        /// <summary>
        /// LeftNavGoImage2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Image LeftNavGoImage2;
        
        /// <summary>
        /// PerfDADLink control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.HyperLink PerfDADLink;
        
        /// <summary>
        /// LeftNavGoImage3 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Image LeftNavGoImage3;
        
        /// <summary>
        /// GrapherLink control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.HyperLink GrapherLink;
        
        /// <summary>
        /// LeftNavGoImage4 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Image LeftNavGoImage4;
        
        /// <summary>
        /// RegressionLink control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.HyperLink RegressionLink;
        
        /// <summary>
        /// LeftNavGoImage5 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Image LeftNavGoImage5;
        
        /// <summary>
        /// ReportingLink control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.HyperLink ReportingLink;
        
        /// <summary>
        /// NPDBErrorLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label NPDBErrorLabel;
        
        /// <summary>
        /// Panel2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel2;
        
        /// <summary>
        /// Panel1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel1;
        
        /// <summary>
        /// Panel15 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel15;
        
        /// <summary>
        /// testNetTime control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label testNetTime;
        
        /// <summary>
        /// Label44 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label44;
        
        /// <summary>
        /// CheckBox2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox CheckBox2;
        
        /// <summary>
        /// RSearch control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel RSearch;
        
        /// <summary>
        /// ServerList control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ServerList;
        
        /// <summary>
        /// TypeList control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList TypeList;
        
        /// <summary>
        /// tb_contains control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tb_contains;
        
        /// <summary>
        /// Search control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button Search;
        
        /// <summary>
        /// AdvSearch control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button AdvSearch;
        
        /// <summary>
        /// CopyButton2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button CopyButton2;
        
        /// <summary>
        /// AdvSearchPanelshort control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel AdvSearchPanelshort;
        
        /// <summary>
        /// Label9 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label9;
        
        /// <summary>
        /// Label10 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label10;
        
        /// <summary>
        /// refine control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button refine;
        
        /// <summary>
        /// ReQuery control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button ReQuery;
        
        /// <summary>
        /// backtoResults control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button backtoResults;
        
        /// <summary>
        /// CopyButton control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button CopyButton;
        
        /// <summary>
        /// Panel17 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel17;
        
        /// <summary>
        /// CustomValidator4 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CustomValidator CustomValidator4;
        
        /// <summary>
        /// AdvSearchPanel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel AdvSearchPanel;
        
        /// <summary>
        /// Panel3 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel3;
        
        /// <summary>
        /// Label1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label1;
        
        /// <summary>
        /// Panel5 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel5;
        
        /// <summary>
        /// Label2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label2;
        
        /// <summary>
        /// AllWords control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox AllWords;
        
        /// <summary>
        /// l5 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label l5;
        
        /// <summary>
        /// ddl_PageSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddl_PageSize;
        
        /// <summary>
        /// Panel7 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel7;
        
        /// <summary>
        /// Label4 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label4;
        
        /// <summary>
        /// Atlestwords control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox Atlestwords;
        
        /// <summary>
        /// i1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label i1;
        
        /// <summary>
        /// AdvSearchBt control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button AdvSearchBt;
        
        /// <summary>
        /// Panel9 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel9;
        
        /// <summary>
        /// Label3 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label3;
        
        /// <summary>
        /// NoWords control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox NoWords;
        
        /// <summary>
        /// Service control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Service;
        
        /// <summary>
        /// Panel6 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel6;
        
        /// <summary>
        /// CheckBoxList1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBoxList CheckBoxList1;
        
        /// <summary>
        /// Panel10 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel10;
        
        /// <summary>
        /// Label11 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label11;
        
        /// <summary>
        /// Panel4 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel4;
        
        /// <summary>
        /// CheckAllButton control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button CheckAllButton;
        
        /// <summary>
        /// UncheckAllButton control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button UncheckAllButton;
        
        /// <summary>
        /// MachineTree control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TreeView MachineTree;
        
        /// <summary>
        /// Panel12 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel12;
        
        /// <summary>
        /// Panel14 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel14;
        
        /// <summary>
        /// title control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label title;
        
        /// <summary>
        /// tb_Title control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tb_Title;
        
        /// <summary>
        /// excludetitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox excludetitle;
        
        /// <summary>
        /// Panel16 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel16;
        
        /// <summary>
        /// Label13 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label13;
        
        /// <summary>
        /// tb_eventids control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tb_eventids;
        
        /// <summary>
        /// excludeevents control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox excludeevents;
        
        /// <summary>
        /// Panel13 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel13;
        
        /// <summary>
        /// Panel18 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel18;
        
        /// <summary>
        /// t2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label t2;
        
        /// <summary>
        /// Calendarpopup2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::eWorld.UI.CalendarPopup Calendarpopup2;
        
        /// <summary>
        /// Label15 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label15;
        
        /// <summary>
        /// Tbstarthh control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox Tbstarthh;
        
        /// <summary>
        /// Label17 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label17;
        
        /// <summary>
        /// tbstartmm control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbstartmm;
        
        /// <summary>
        /// Label19 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label19;
        
        /// <summary>
        /// DateTimeLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label DateTimeLabel;
        
        /// <summary>
        /// CheckBox1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox CheckBox1;
        
        /// <summary>
        /// Label7 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label7;
        
        /// <summary>
        /// TextBox1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox TextBox1;
        
        /// <summary>
        /// Label22 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label22;
        
        /// <summary>
        /// CheckBoxList2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBoxList CheckBoxList2;
        
        /// <summary>
        /// Panel11 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel11;
        
        /// <summary>
        /// Label8 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label8;
        
        /// <summary>
        /// calendarPopup1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::eWorld.UI.CalendarPopup calendarPopup1;
        
        /// <summary>
        /// Label16 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label16;
        
        /// <summary>
        /// Tbendhh control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox Tbendhh;
        
        /// <summary>
        /// Label5 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label5;
        
        /// <summary>
        /// tbendmm control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbendmm;
        
        /// <summary>
        /// Label20 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label20;
        
        /// <summary>
        /// CustomValidator1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CustomValidator CustomValidator1;
        
        /// <summary>
        /// CustomValidator2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CustomValidator CustomValidator2;
        
        /// <summary>
        /// Label6 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label6;
        
        /// <summary>
        /// Results control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Results;
        
        /// <summary>
        /// ResultHead control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel ResultHead;
        
        /// <summary>
        /// DataGrid1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid DataGrid1;
        
        /// <summary>
        /// NoResultsLabel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label NoResultsLabel;
        
        /// <summary>
        /// DetailPanel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel DetailPanel;
        
        /// <summary>
        /// Panel20 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel20;
        
        /// <summary>
        /// Label12 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label12;
        
        /// <summary>
        /// Panel22 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel22;
        
        /// <summary>
        /// Panel8 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Panel Panel8;
        
        /// <summary>
        /// Label14 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label14;
        
        /// <summary>
        /// lbdate control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lbdate;
        
        /// <summary>
        /// Label24 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label24;
        
        /// <summary>
        /// lbsource control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lbsource;
        
        /// <summary>
        /// ImageButton1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ImageButton ImageButton1;
        
        /// <summary>
        /// Label18 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label18;
        
        /// <summary>
        /// lbtime control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lbtime;
        
        /// <summary>
        /// Label25 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label25;
        
        /// <summary>
        /// lbeventid control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lbeventid;
        
        /// <summary>
        /// Label21 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label21;
        
        /// <summary>
        /// lbtype control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lbtype;
        
        /// <summary>
        /// Label26 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label26;
        
        /// <summary>
        /// lbcomputer control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lbcomputer;
        
        /// <summary>
        /// ImageButton2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ImageButton ImageButton2;
        
        /// <summary>
        /// Label23 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label23;
        
        /// <summary>
        /// lbtitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lbtitle;
        
        /// <summary>
        /// tb_Detail control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tb_Detail;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\ESearch\App_Code\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace Events 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\ESearch\App_Code\QueryBuilder.cs ===
using System;
using System.Collections;


namespace Events
{
	/// <summary>
	/// Summary description for QueryBuilder.
	/// </summary>
	
	public class QueryData
	{	
		public string AllWordstxt="";
		public string Atlestwords="";
		public string NoWords="";
		public ArrayList vc_apps= new ArrayList();
		public ArrayList Etypes= new ArrayList();
		public bool  useDateRange = false;
		public DateTime start;
		public DateTime end;
		public int Durationinmin;
		//outdated non-dynamic treeview system
        /*public bool AllIIS = false;
		public bool AllINH = false;
		public bool AllWBCA = false;
		public bool AllKDC	=false;
		public bool AllSG	=false;*/
        public bool AllChecked = false;
		public ArrayList CompNames = new ArrayList();
		public string Events="";
		public string titles="";
		public bool ExcludeEvents=false;
		public bool Excludetitles=false;
		public string gamertags;
	}
	public class QueryBuilder
	{

		static string  hexstr="0123456789abcdef";
		public QueryBuilder()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		static public int getInt(string data)
		{
			int tmp=-1;
			data=data.ToLower();

			if(data.StartsWith("0x"))
			{
				// the value is in Hex 
				tmp=Convert.ToInt32(data,16);
			}
			else
			{
				// value is in desimal
				tmp=Convert.ToInt32(data,10);
			}
			


			return tmp;
		}

		static public ArrayList Parseids(string data)
		{

			// event id's
			ArrayList idList= new ArrayList();
			string txtdata= data.Trim();
			if(txtdata !=null && txtdata.Length>0)
			{
				string[] ids=txtdata.Split(new char[]{' ',',',';'});

				for(int l=0;l<ids.Length;l++)
				{
					string tmp = ids[l].Trim();
					if(tmp.Length>0)
					{
						try
						{
							idList.Add(getInt(tmp));
						}
						catch(System.Exception)
						{
							// ignore the exception...
						}
					}

				}
			}

			return idList;

		}

		static public bool isnumber(string data)
		{

			
			if(data.StartsWith("0x"))
			{
				for(int i=2;i<data.Length;i++)
				{
					if(hexstr.IndexOf(data[i])==-1)
						return false;
									
				}
			}
			else
			{
				for(int i=0;i<data.Length;i++)
				{
					if(!Char.IsNumber(data[i]))
						return false;
				}
			}

			return true;
		}
	
	/*	static public long getPUID(string data)
		{
			long tmp=-1;
			data=data.ToLower();


			if(isnumber(data))
			{
				if(data.StartsWith("0x"))
				{
					// the value is in Hex 
					tmp=Convert.ToInt64(data,16);
				}
				else
				{
					// value is in desimal
					tmp=Convert.ToInt64(data,10);
				}
			}
			else
			{
				// its a gamertag . use xcache to convert to puid.
				XCache tmpcache = new XCache();
				tmp = (long)tmpcache.LookupPUID(data);
			}
			


			return tmp;
		}*/

	/*	static public ArrayList ParseGamertagsorpuids(string data)
		{

			// event id's
			ArrayList idList= new ArrayList();
			string txtdata= data.Trim();
			if(txtdata !=null && txtdata.Length>0)
			{
				string[] ids=txtdata.Split(new char[]{' ',',',';'});

				for(int l=0;l<ids.Length;l++)
				{
					string tmp = ids[l].Trim();
					if(tmp.Length>0)
					{
						try
						{
							long puid  =getPUID(tmp);
							if(puid>0)
								idList.Add(puid);
						}
						catch(System.Exception e)
						{
							string tmpe = e.ToString();
							
							// ignore the exception...
						}
					}

				}
			}

			return idList;

		}*/


		static public string GetReqularQuery(string SearchTxt,string server, string Type ,bool IsTop1000, string tbname)
		{
			string mySelectQuery ="";
			
			if(IsTop1000)
				mySelectQuery = "select top 1000 uid_mom_guid, si_type, dt_time,vc_app,i_event_id,vc_server,i_title_id from  ";
			else 
				mySelectQuery = "select uid_mom_guid, si_type, dt_time,vc_app,i_event_id,vc_server,i_title_id from  ";

			mySelectQuery = mySelectQuery+ tbname +" WITH (NOLOCK) ";
			string whereclause = GetReqularClause(SearchTxt,server,Type );
			return mySelectQuery+whereclause;
		}

		static public string GetReqularClause(string SearchTxt,string server, string Type )
		{
			
			string Freetext= null;

			if(SearchTxt.Length>0)
			{
				string tcontains = SearchTxt.Trim();
				string [] array = tcontains.Split(new char[]{' '});
				ArrayList temp = new ArrayList();

				for(int i=0;i<array.Length;i++)
				{
					if(array[i].Trim()!="")
						temp.Add(array[i]);
				}

				bool IsLastWordSeparator =false;
				for(int i=0;i<temp.Count;i++)
				{
					string word = (string) temp[i];
					if(word.ToLower() !="or" && word.ToLower() !="and" )
					{
						if(i+1 <temp.Count)
						{
							string iplus1= (string)temp[i+1];
							if(iplus1.ToLower().Trim() !="and" && !IsLastWordSeparator )
								Freetext+= temp[i]+" or ";
							else
								Freetext+= temp[i]+" ";
						}
						else
							Freetext+= temp[i]+" ";

						IsLastWordSeparator= false;
					}
					else 
					{
						if(i>0)
						{
							if (word.ToLower() =="and")
							{
								if(i+1 <temp.Count)
								{
									string iplus1=  (string)temp[i+1];
									if(iplus1.ToLower().Trim() !="and" && iplus1.ToLower().Trim() !="or" )
										Freetext+= temp[i]+" ";
									
								}
							}

							IsLastWordSeparator= true;
						}
						
					}
					
				}

			}
			// build Query here 
			string mySelectQuery ="";
			if(server !="All Services")
			{
				mySelectQuery+="where vc_app='"+server+"' ";
				if(Freetext!=null && Freetext.Length>0)
					mySelectQuery+=" and contains(vc_description,'"+Freetext+"') ";
				if(Type !="Type")
				{
					if(Type.Trim() =="Error")
					{
						mySelectQuery+=" and si_type=1 ";
					}
					else if(Type.Trim() =="Warning")
					{
						mySelectQuery+=" and si_type=2 ";
					}
					else
					{
						mySelectQuery+=" and si_type=4 ";
					}
					
				}
				mySelectQuery+=" and dt_time > DATEADD(Hour,-12,getdate())";
			}
			else if(Type !="Type")
			{
				if(Type.Trim() =="Error")
				{
					mySelectQuery+=" where si_type=1 ";
				}
				else if(Type.Trim() =="Warning")
				{
					mySelectQuery+=" where si_type=2 ";
				}
				else
				{
					mySelectQuery+=" where si_type=4 ";
				}

				if(Freetext!=null  && Freetext.Length>0)
					mySelectQuery+=" and contains(vc_description,'"+Freetext+"') ";
				
				mySelectQuery+=" and dt_time > DATEADD(Hour,-12,getdate())";
				
			}
			else if(Freetext!=null && Freetext.Length>0)
			{
				mySelectQuery+=" where contains(vc_description,'"+Freetext+"') ";
				//mySelectQuery+=" and dt_time > DATEADD(Hour,-6,getdate())";
			}
			/*else
			{
				mySelectQuery+=" where dt_time > DATEADD(Hour,-6,getdate())";
			}
			*/

			

			mySelectQuery+=" order by dt_time DESC";

			return mySelectQuery;

		}



		static public string GetAdvQuery(QueryData qdata,string tbname)
		{
			string Query ="select uid_mom_guid, si_type, dt_time,vc_app,i_event_id,vc_server,i_title_id from "+tbname+" WITH (NOLOCK)";
			string contains=null;
			int containscount=0;
            
            //free-text search
			string[] _allwords =(qdata.AllWordstxt.Trim()).Split(new char[]{' '});
			string[] _anywords =(qdata.Atlestwords.Trim()).Split(new char[]{' '}); 
			string[] _nowords = (qdata.NoWords.Trim()).Split(new char[]{' '});

			for(int i=0; i<_allwords.Length;i++)
			{
				string temp=_allwords[i].ToLower();
				if(temp!="" && temp!="and" && temp!="or" && temp!="not")
				{
					if(containscount<=0)
						contains =temp;
					else
						contains+=" and "+temp;
					containscount++;
					

				}
			}

			for(int i=0; i<_anywords.Length;i++)
			{
				string temp=_anywords[i].ToLower();
				if(temp!="" && temp!="and" && temp!="or" && temp!="not")
				{
					if(containscount<=0)
						contains =temp;
					else
						contains+=" or "+temp;
					containscount++;
					

				}
			}

			for(int i=0; i<_nowords.Length;i++)
			{
				string temp=_nowords[i].ToLower();
				if(temp!="" && temp!="and" && temp!="or" && temp!="not")
				{
					if(containscount>0)
					{
						contains+=" and not "+temp;
						containscount++;
					}

				}
			}
			
            //services search
            string servires= null;
			int serviresidx=0;

			for (int p=0;p< qdata.vc_apps.Count;p++)
			{
				if(serviresidx<=0)
					servires = " vc_app='"+qdata.vc_apps[p]+"'";
				else
					servires +=" or vc_app='"+qdata.vc_apps[p]+"'";
					
				serviresidx++;
				
			}

            //event types search
			string types= null;
			int typesidx=0;

			for (int p=0; p<qdata.Etypes.Count;p++)
			{
				string dat = (string)qdata.Etypes[p];
				string val;
				if(dat =="Error")
				{
					val="1";
				}
				else if(dat =="Warning")
				{
					val="2";
				}
				else
				{
					val="4";
				}
				
				if(typesidx<=0)
					types = " si_type="+val;
				else
					types +=" or  si_type="+ val;
					
				typesidx++;
				
			}

			string timeserch=null;
			if(qdata.useDateRange)
			{

				// time search...
				
				DateTime start=qdata.start;
				DateTime end=qdata.end;
				
				if(DateTime.Compare(start ,end)>0)
					return "";
				else
				{
					timeserch="dt_time > '"+start.ToString("G")+"' and dt_time < '"+end.ToString("G")+"'";
				}
			}
			else
			{
				timeserch = "dt_time > DATEADD(Minute,-"+qdata.Durationinmin+",getdate())";

			}
            
            //Add Machine Server names
            string Compname = null;

            if (qdata.AllChecked == false)
            {
                bool IsfirstSelecteditem = true;
                
                //outdated non-dynamic server names system
                /*
                if (qdata.AllIIS)
                {
                    Compname = " vc_server like '%POOLIIS%' ";
                    IsfirstSelecteditem = false;
                }
                if (qdata.AllINH)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%POOLINH%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%POOLINH%' ";

                }
                if (qdata.AllWBCA)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%WBCA%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%WBCA%' ";
                }
                if (qdata.AllKDC)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%XEXMACINH%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%XEXMACINH%' ";
                }
                if (qdata.AllSG)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%XESECUINH%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%XESECUINH%' ";
                }
                */
                //this create a possible long query, but i currently can't think of any other way to
                //search by server type, since the names of the servers don't neccessarily have to have
                //and resemblance to the type, and they change frequently.
                foreach (string item in qdata.CompNames)
                {
                    if (IsfirstSelecteditem)
                    {
                        Compname = " vc_server='" + item.Trim() + "' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server='" + item.Trim() + "' ";

                }
            }

			// event id's

			ArrayList ids = Parseids(qdata.Events.Trim());
			string eventids=null;
			
			
			for(int l=0;l<ids.Count;l++)
			{
				if(l==0)
				{
					if(qdata.ExcludeEvents)
						eventids+="i_event_id <>'"+ids[l]+"'";
					else
						eventids+="i_event_id ='"+ids[l]+"'";
					
				}
				else
				{
					if(qdata.ExcludeEvents)
						eventids+=" and i_event_id <>'"+ids[l]+"'";
					else
						eventids+=" or i_event_id ='"+ids[l]+"'";
				}
			}

			// titleIDs
			ArrayList tids = Parseids(qdata.titles.Trim());
			string titleids=null;
			
			
			for(int l=0;l<tids.Count;l++)
			{
				if(l==0)
				{
					if(qdata.Excludetitles)
						titleids+="i_title_id <>'"+tids[l]+"'";
					else
						titleids+="i_title_id ='"+tids[l]+"'";
				}
				else
				{
					if(qdata.Excludetitles)
						titleids+=" and i_title_id <>'"+tids[l]+"'";
					else
						titleids+=" or i_title_id ='"+tids[l]+"'";
				}
			}

			// gamertags -NO LONGER SUPPORTED

			//	ArrayList puids = ParseGamertagsorpuids(qdata.gamertags.Trim());

			

			if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null || Compname!=null || eventids!=null)
			{
				Query +=" where ";
				if(containscount >0)
				{
					Query+= " contains(vc_description,'"+ contains+"')";
				}
				
				if(serviresidx>0)
				{
					if(containscount >0)
						Query+="and ("+servires+") ";
					else
						Query+=" ("+servires+") ";
				}
				
				if (typesidx>0)
				{
					if(containscount >0 || serviresidx>0 )
						Query+="and ("+types+") ";
					else
						Query+=" ("+types+") ";
				}
				
				if(timeserch !=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0)
						Query+="and "+timeserch;
					else
						Query+=" "+timeserch;

				}

				if(Compname!=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null)
						Query+="and ("+Compname+") ";
					else
						Query+=" ("+Compname+") ";
				}

				if(eventids !=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null||Compname!=null)
						Query+=" and ("+eventids+" )";
					else
						Query+=" "+eventids;
				}

				if(titleids!=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null||Compname!=null || eventids !=null)
						Query+=" and ("+titleids+")";
					else
						Query+=" "+titleids;
				}

			}
			
			

			return Query;

		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\MomPlugin\EventSysMomPlugindll.cs ===
using System;
using System.Reflection;

namespace xonline.common.config
{
} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\MomPlugin\EventSysMomPlugin.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.EnterpriseManagement.Mom.Runtime;
using System.Reflection;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.server.eventsys.momplugin
{
    public class EventSysMomPlugin
    {
        static public void OnEvent(Microsoft.EnterpriseManagement.Mom.Runtime.Context context)
        {
            try
            {                
                System.Guid momGuid       = context.Event.ID;
                DateTime    dtEventTime   = context.Event.TimeGenerated;
                string      szApp         = context.Event.Source;
                ushort      usType        = (ushort)(context.Event.EventType);
                int         nEventId      = context.Event.EventNumber;
                string      szServer      = context.Event.SourceComputer;
                string      szDescription = context.Event.Message;
                int         nTitleId      = GetTitleID(szDescription);
                
                using (WSClient ws = new WSClient(ConfigUtil.EventSysDbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "p_event_sys_log_event";
                    ws.Partition = ws.CalcPartition(momGuid.ToString());

                    ws.AddParameter("@uid_mom_guid", momGuid);
                    ws.AddParameter("@dt_time", dtEventTime);
                    ws.AddParameter("@vc_app", szApp);
                    ws.AddParameter("@si_type", usType);

                    ws.AddParameter("@i_event_id", nEventId);
                    ws.AddParameter("@vc_server", szServer);
                    ws.AddParameter("@vc_description", szDescription);
                    ws.AddParameter("@i_title_id", nTitleId);
                    
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                    ws.ExecuteNonQuery();
                }
            }
            catch (Exception e)
            {
                throw e;
            }
            finally
            {
            }
        }

        static int GetTitleID(string szDescription)
        {
            return EventParser.GetTitleID(szDescription);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\websvc\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.eventsys.websvc
{

    [XomPerformanceCounterCategoryAttr( "EventService", "Xbox Live: EventService Web Service Performance Counters" )]

    public class EventServiceCounterCategory : XomPerformanceCounterCategory
    {
        [XomPerformanceCounterAttr(
             "FindEvents requests per second", 
             "Number of FindEvents requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FindEventsPerSecond;

        [XomPerformanceCounterAttr(
             "FindEvents requests total", 
             "Total FindEvents requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FindEventsTotal;

        [XomPerformanceCounterAttr(
             "LookupEvent requests per second", 
             "Number of LookupEvent requests executed per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter LookupEventPerSecond;

        [XomPerformanceCounterAttr(
             "LookupEvent requests total", 
             "Total LookupEvent requests recorded in the the current AppDomain.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter LookupEventTotal;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\MomPlugin\EventParser.cs ===
using System;
using System.Collections;
using xonline.common.service;

namespace xonline.server.eventsys.momplugin
{
	class EventParser
	{
        public const int UNKNOWN_TITLE = unchecked((int)0xFFFFFFFF);
        static public int GetTitleID(string szMessage)
        {   
            int nTitleID = (int)UNKNOWN_TITLE;
			try
			{
                string [] szLines = szMessage.Split(new char[] { '\r', '\n' });
                foreach (string szLine in szLines)
                {
                    string[] arrszParts = szLine.Split(new char[] { ':' });
                    
                    if (arrszParts.Length != 2)
                       continue;
                        
                    switch (arrszParts[0])
                    {
                        case "TitleId":
                            nTitleID = SafeConvert.ToInt32(arrszParts[1].Trim());
                            break;
                            
                        default:
                            break;
                    }

                    if (nTitleID != UNKNOWN_TITLE)
                    {
                        //found it so let's break from the loop
                        break;
                    }
				}
			}
			catch
			{
                //we do nothing at this point - it could be the event message has no AUTH data to get the title id
			}

            return nTitleID;
        }    
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\ESearch\App_Code\EventDB.cs ===
using System;
using System.Data;
using System.Xml;
using System.Collections;
using System.Configuration;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Web.UI.WebControls;
//using WebServiceProxyHelpers;

namespace Events
{
    /// ================================================================================================================
    /// Class Name:  WebServiceProxy
    /// Method Name: GetConfigurationString
    /// Description: This method will handle getting Web.Config configuration strings from the PerfDATA Web Service.
    ///              Just pass the configuration constant in and you will get your result.
    ///              The existing configuration constants are contained in the WebServiceConfigurationConstants class
    /// Version:     1.0
    ///
    /// Notes:       Make sure the const values match the values in PefData else your WebService will not work correctly
    /// 
    ///              Once we create a new way to replace the existing .MSI creation, and we can have additional files,
    ///              then add this and other classes into a clean proxy class, rather than just throwing into some
    ///              class like i did here.
    ///
    /// ---------- ----------- ------------- ---------------------------------------------------------------------------
    ///    Date     Version     Developer                           Description
    /// ---------- ----------- ------------- ---------------------------------------------------------------------------
    /// 08/14/2008 1.01.00.000 Richard Loba  - Original
    /// ================================================================================================================


    public class WebServiceProxy
    {
        //static public PerfDataWS.PerfDataWebService oPerfDataWS = new PerfDataWS.PerfDataWebService();

        public string GetConfigurationString(int iWhichConfigEntry)
        {
            //return oPerfDataWS.GetCacheEnvironmentString(iWhichConfigEntry);

            return GetConfigurationStringCtrler(iWhichConfigEntry);
        }

        public const int DB_SERVER_NAME_NPDB                    =  1 ;  // Key = "npdbConnectionString"     - PerfDAD, ESearch

        public const int ENV_DB_EVENTSYSDB_STRESSNET            =  2 ;  // Key = "stressnetEventSysDB"      - ESearch
        public const int ENV_DB_EVENTSYSDB_TESTNET              =  3 ;  // Key = "testnetEventSysDB"        - ESearch
        public const int ENV_DB_EVENTSYSDB_PRODUCTION           =  4 ;  // Key = "ProdNetEventSysDB"        - ESearch


        public const int ENV_DB_EVENTSYSDB_CERTNET = 12;  // Key = "certnetEventSysDB"      - ESearch
        public const int ENV_DB_EVENTSYSDB_PARTNERNET = 13;  // Key = "partnernetEventSysDB"        - ESearch
        public const int ENV_DB_EVENTSYSDB_ARGONET = 14;  // Key = "argonetEventSysDB"        - ESearch

        public const int WEB_SITE_LINK_ESEARCH                  =  5 ;  // Key = "ESearchLink"              - ESearch, PerfDAD
        public const int WEB_SITE_LINK_PERFDAD                  =  6 ;  // Key = "PerfDADLink"              - ESearch, PerfDAD
        public const int WEB_SITE_LINK_GRAPHER                  =  7 ;  // Key = "GrapherLink"              - ESearch, PerfDAD
        public const int WEB_SITE_LINK_REGRESSION               =  8 ;  // Key = "RegressionLink"           - ESearch, PerfDAD
        public const int WEB_SITE_LINK_REPORTING                =  9 ;  // Key = "ReportingLink"            - ESearch, PerfDAD

        public const int VARIABLE_ENVIRONMENTS                  = 10 ;  // Key = "Environments"             - ESearch, PerfDAD
        public const int VARIABLE_SHOW_ENVIRONMENT_REGRESSION   = 11 ;  // Key = "RegressionEnvironment"    - ESearch, PerfDAD

            // Environment variables

            public const string ENV_NAME_STRESSNET  = "STRESSNET";  // Note, used in switch statement, using Env.ToUpper()
            public const string ENV_NAME_TESTNET    = "TESTNET";    //  Etc....
            public const string ENV_NAME_PRODUCTION = "PRODNET";    //  Etc....
            public const string ENV_NAME_CERTNET = "CERTNET";  // Note, used in switch statement, using Env.ToUpper()
            public const string ENV_NAME_PARTNERNET = "PARTNERNET";    //  Etc....
            public const string ENV_NAME_ARGONET = "ARGONET";    //  Etc....

    //=================================================================================================

        public const string PERFDATA_CONFIGURATION_KEY_ERROR = "Configuration Warning/Error.\nAre you missing a Web.Config Entry?\n" ;

        public string APP_SETTING_ESearchLink               = ConfigurationManager.AppSettings["ESearchLink"];                              // ESearch, PerfDAD
        public string APP_SETTING_PerfDADLink               = ConfigurationManager.AppSettings["PerfDADLink"];                              // ESearch, PerfDAD
        public string APP_SETTING_GrapherLink               = ConfigurationManager.AppSettings["GrapherLink"];                              // ESearch, PerfDAD
        public string APP_SETTING_RegressionLink            = ConfigurationManager.AppSettings["RegressionLink"];                           // ESearch, PerfDAD
        public string APP_SETTING_ReportingLink             = ConfigurationManager.AppSettings["ReportingLink"];                            // ESearch, PerfDAD

        public string APP_SETTING_Environments              = ConfigurationManager.AppSettings["Environments"];                             // ESearch, PerfDAD
        public string APP_SETTING_RegressionEnvironment     = ConfigurationManager.AppSettings["RegressionEnvironment"];                    // ESearch, PerfDAD

        public string KEYNAME_DB_SERVER_NAME_NPDB           = ConfigurationManager.ConnectionStrings["npdbConnectionString"].ToString();    // PerfDAD, ESearch  

        public string KEYNAME_ENV_DB_EVENTSYSDB_STRESSNET   = ConfigurationManager.ConnectionStrings["stressnetEventSysDB"].ToString();     // ESearch 
        public string KEYNAME_ENV_DB_EVENTSYSDB_TESTNET     = ConfigurationManager.ConnectionStrings["testnetEventSysDB"].ToString();       // ESearch    
        public string KEYNAME_ENV_DB_EVENTSYSDB_PRODUCTION  = ConfigurationManager.ConnectionStrings["ProdNetEventSysDB"].ToString();       // ESearch      
        public string KEYNAME_ENV_DB_EVENTSYSDB_CERTNET = ConfigurationManager.ConnectionStrings["certnetEventSysDB"].ToString();     // ESearch 
        public string KEYNAME_ENV_DB_EVENTSYSDB_PARTNERNET = ConfigurationManager.ConnectionStrings["partnernetEventSysDB"].ToString();       // ESearch    
        public string KEYNAME_ENV_DB_EVENTSYSDB_ARGONET = ConfigurationManager.ConnectionStrings["argonetEventSysDB"].ToString();       // ESearch     

    //=====================================================================================================

        public string GetConfigurationStringCtrler(int iWhichKey)
        {
            switch(iWhichKey)
            {
                case DB_SERVER_NAME_NPDB:                   return  KEYNAME_DB_SERVER_NAME_NPDB         ;  // PerfDAD, ESearch  // Key = "npdbConnectionString"  

                case ENV_DB_EVENTSYSDB_STRESSNET:           return  KEYNAME_ENV_DB_EVENTSYSDB_STRESSNET ;  // ESearch           // Key = "stressnetEventSysDB" 
                case ENV_DB_EVENTSYSDB_TESTNET:             return  KEYNAME_ENV_DB_EVENTSYSDB_TESTNET   ;  // ESearch           // Key = "testnetEventSysDB" 
                case ENV_DB_EVENTSYSDB_PRODUCTION:          return  KEYNAME_ENV_DB_EVENTSYSDB_PRODUCTION   ;  // ESearch           // Key = "ProdNetEventSysDB" 

                case ENV_DB_EVENTSYSDB_CERTNET: return KEYNAME_ENV_DB_EVENTSYSDB_CERTNET;  // ESearch           // Key = "stressnetEventSysDB" 
                case ENV_DB_EVENTSYSDB_PARTNERNET: return KEYNAME_ENV_DB_EVENTSYSDB_PARTNERNET;  // ESearch           // Key = "testnetEventSysDB" 
                case ENV_DB_EVENTSYSDB_ARGONET: return KEYNAME_ENV_DB_EVENTSYSDB_ARGONET;  // ESearch           // Key = "ProdNetEventSysDB" 

                case WEB_SITE_LINK_ESEARCH:                 return  APP_SETTING_ESearchLink             ;  // ESearch, PerfDAD  // Key = "ESearchLink" 
                case WEB_SITE_LINK_PERFDAD:                 return  APP_SETTING_PerfDADLink             ;  // ESearch, PerfDAD  // Key = "PerfDADLink"  
                case WEB_SITE_LINK_GRAPHER:                 return  APP_SETTING_GrapherLink             ;  // ESearch, PerfDAD  // Key = "GrapherLink" 
                case WEB_SITE_LINK_REGRESSION:              return  APP_SETTING_RegressionLink          ;  // ESearch, PerfDAD  // Key = "RegressionLink" 
                case WEB_SITE_LINK_REPORTING:               return  APP_SETTING_ReportingLink           ;  // ESearch, PerfDAD  // Key = "ReportingLink" 

                case VARIABLE_ENVIRONMENTS:                 return  APP_SETTING_Environments            ;  // ESearch, PerfDAD  // Key = "Environments" 
                case VARIABLE_SHOW_ENVIRONMENT_REGRESSION:  return  APP_SETTING_RegressionEnvironment   ;  // ESearch, PerfDAD  // Key = "RegressionEnvironment" 
            }

            return PERFDATA_CONFIGURATION_KEY_ERROR;
        }
    }

	/// <summary>
	/// Summary description for EventDB.
	/// </summary>
	/// 
	public class EventTB
	{
		public string Name;
		public DateTime stTime;
		public DateTime EndTime;
				
	}

	public class EventDB
	{
        static string myConnString = "";
        static string serverListConnString = "";
		
        public EventDB()
		{

		}

        // ============================================================================================================
        // Method Name: SetEnvironment
        // Description: 
        // Version:      1.2
        //
        // ========== =========== ============ ========================================================================
        // Date       Version Developer           Description
        // ========== =========== ============ ========================================================================
        // 05/01/2008 1.00.00.000 ESearch Dev? - Original - got configuration information from XML files.
        //                                       Most of this code was commented out, not exactly sure why. There are
        //                                       a number of ways this environment has been working, each site is a
        //                                       different way.
        // 08/07/2008 1.00.00.001 Richard Loba - No spec on any of this enviornment drop-down, NPDB, or how this is
        //                                       supposed to work, so trying what makes sense.
        //                                       Converting it to work with Web.Config.
        //                                       Updating environment database connection strings for the environment,
        //                                       tring to use any configuration stuff that might be in NPDB.
        // 08/13/2008 1.01.00.000 Richard Loba - Converted to use the common PerfData web service.
        // ============================================================================================================

        public static void SetEnvironment(string env, string pathToXMLfolder)
        {
            WebServiceProxy oProxy = new WebServiceProxy();

            try
            {
                switch(env.Trim().ToUpper())
                {
                    case WebServiceProxy.ENV_NAME_STRESSNET          : myConnString = oProxy.GetConfigurationString( WebServiceProxy.ENV_DB_EVENTSYSDB_STRESSNET)  ; break;
                    case WebServiceProxy.ENV_NAME_TESTNET            : myConnString = oProxy.GetConfigurationString( WebServiceProxy.ENV_DB_EVENTSYSDB_TESTNET)    ; break;
                    case WebServiceProxy.ENV_NAME_PRODUCTION         : myConnString = oProxy.GetConfigurationString( WebServiceProxy.ENV_DB_EVENTSYSDB_PRODUCTION) ; break;
                    case WebServiceProxy.ENV_NAME_CERTNET: myConnString = oProxy.GetConfigurationString(WebServiceProxy.ENV_DB_EVENTSYSDB_CERTNET); break;
                    case WebServiceProxy.ENV_NAME_PARTNERNET: myConnString = oProxy.GetConfigurationString(WebServiceProxy.ENV_DB_EVENTSYSDB_PARTNERNET); break;
                    case WebServiceProxy.ENV_NAME_ARGONET: myConnString = oProxy.GetConfigurationString(WebServiceProxy.ENV_DB_EVENTSYSDB_ARGONET); break;
                }

                if (myConnString == null)
                    throw new Exception("No connection string found for environment " + env + ". Please add a connection string to PerfDATA's web.config to name="+env+"EventSysDB");

                serverListConnString = myConnString; 
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading settings from web.config\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
            }
        }
       
        static public void GetServerList(ListItemCollection servernames, string environment)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the connection string
                _EventCnt = new SqlConnection(serverListConnString);
                _EventCnt.Open();

                //Query for the server names 
                //string mySelectQuery = "select distinct vc_server, vc_server_type from dbo.t_servers where vc_environment = '" + environment + "' and vc_server_state = 'online' order by vc_server_type";

                // Modified to use server interfaces instead
                string mySelectQuery = "select distinct s.vc_server, i.vc_interface " +
                                       "from t_servers s inner join t_server_interfaces i " +
                                       "on s.vc_server = i.vc_server and s.vc_environment = i.vc_environment " +
                                       "where s.vc_server_state = 'online' " +
                                       "and s.vc_environment = @Environment " +
                                       "order by i.vc_interface";
                
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.Parameters.Add(new SqlParameter("@Environment", environment.Trim()));
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    //read and store server names
                    string name = myReader.GetString(0).Trim();
                    string type = myReader.GetString(1).Trim();
                    servernames.Add(new ListItem(name, type));
                }
                myReader.Close();

            }
            catch (Exception e)
            {
                
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading supported servers from database using connection string \""+serverListConnString+"\".\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //somehow we cannot reach NPDB, return servernames unchanged.
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
            
        }
		static public int GetServicesList(ListItemCollection items)
		{
            int retval = 0;
			SqlConnection _EventCnt =null;
            try
            {

                string mySelectQuery = "select vc_app from dbo.t_Application group by vc_app";
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();


                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    string tmp = myReader.GetString(0);
                    items.Add(new ListItem(tmp.Trim(), tmp.Trim()));
                }
                myReader.Close();

            }
            catch (Exception ex)
            {
                //we could not connect to our database, return 1
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading services from t_Application in EventSysDB using connection string \""+myConnString+"\".\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                retval = 1;
            }
         	finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
            return retval;
		}

		static public string GetEventDetail(string guid ,string tablename ) 
		{
			string detail = "";
			SqlConnection _EventCnt =null;
			try
			{
				
				string mySelectQuery = "select vc_description from "+tablename+" where uid_mom_guid=\'"+guid+"\'";
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				detail = (string) myCommand.ExecuteScalar();
			}
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading event detail (guid="+guid+")from "+tablename+" in EventSysDB using connection string \""+myConnString+"\".\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //we couldn't reach the database. return empty string.
            }
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
            
			return detail;

		}

		static public DataView GetResult(string Query,DataTable dt,string tbname, int TimeOffset)
		{
			DataRow dr;
			if(dt==null)
			{
				dt = new DataTable();
				dt.Columns.Add(new DataColumn("Index", typeof(string)));
				dt.Columns.Add(new DataColumn("ImageType", typeof(string)));
				dt.Columns.Add(new DataColumn("Type", typeof(string)));
				dt.Columns.Add(new DataColumn("Date", typeof(string)));
				dt.Columns.Add(new DataColumn("Time", typeof(string)));
				dt.Columns.Add(new DataColumn("Source", typeof(string)));
				dt.Columns.Add(new DataColumn("Event", typeof(string)));
				dt.Columns.Add(new DataColumn("Computer", typeof(string)));
				dt.Columns.Add(new DataColumn("Title", typeof(string)));
				dt.Columns.Add(new DataColumn("DateTime", typeof(DateTime)));
				//dt.Columns.Add(new DataColumn("Occurrence", typeof(Int32)));
				dt.Columns.Add(new DataColumn("TableName", typeof(string)));
			}

		

			SqlConnection _EventCnt =null;
			try
			{
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(Query, _EventCnt);
				myCommand.CommandType = CommandType.Text;
                myCommand.CommandTimeout = 60*2; //two minutes
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					dr = dt.NewRow();
					dr[0] = myReader.GetSqlGuid(0).ToString();
                                   short tmp = myReader.GetInt16(1);
					dr[1] = FormatURL(tmp);
					dr[2] = FormatText(tmp);
					dr[3] = myReader.GetDateTime(2).AddHours(TimeOffset).ToShortDateString();
					dr[4] = myReader.GetDateTime(2).AddHours(TimeOffset).ToShortTimeString();
					dr[5] = myReader.GetString(3);
					dr[6] = myReader.GetInt32(4);
					dr[7] = myReader.GetString(5);
					dr[8] = "0x"+myReader.GetInt32(6).ToString("x"); // title
					dr[9] =myReader.GetDateTime(2);
					//if(!myReader.GetSqlInt32(7).IsNull)
					//	dr[10] =myReader.GetInt32(7);
					//else
					//	dr[10] =0;

					//dr[11] =tbname;
                    dr[10] = tbname;
 
					dt.Rows.Add(dr);
				}
				myReader.Close();
                if (dt.Rows.Count == 0)
                {
                    //there were no rows created, meaning no results returned
                  
                }


			}
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading results from "+tbname+" from EventSysDB using connection string "+myConnString+".\nQuery: "+Query+ "\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //we couldn't reach the database. return empty.
            }
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
 
			return( new DataView(dt));

		}

		static public ArrayList GetTableList()
		{
			ArrayList tmp = new ArrayList();
			string Query = "SELECT [c_table_name], [dt_start_time], [dt_end_time] FROM [t_event_tables] order by dt_start_time desc";
			SqlConnection _EventCnt =null;
			try
			{
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(Query, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				SqlDataReader myReader = myCommand.ExecuteReader();

                // [RichLoba] - [START] - Handle if you do not return any rows.
                //                        This could be an empty table, or ESearch <-> SQL server access errors, no rows returned.
                //
                //    if(myReader.HasRows == false)
                //    {
                //        return ReturnZeroRows();
                //    }
                // [RichLoba] - [END] - Handle if you have an empty table.

				while(myReader.Read()) 
				{
					EventTB oeventtb = new EventTB();
					oeventtb.Name = myReader.GetString(0);
					if(!myReader.IsDBNull(1))
						oeventtb.stTime = myReader.GetDateTime(1);
					if(!myReader.IsDBNull(2))
						oeventtb.EndTime =myReader.GetDateTime(2);

					
					tmp.Add(oeventtb);
					
				}
				myReader.Close();


			}
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading table list from EventSysDB using connection string " + myConnString + ".\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //we couldn't reach the database. return emptiness.
            }
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
 
			return tmp;

		}

        // [RichLoba] - [START] - If you create a new DB with zero rows then the existing code will crash if zero records for ESearch.
        //                just create a couple of dummy rows so it doesn't crash
        //
        // [Needs to be throughly tested before implementing...]
        //
        //   static public ArrayList ReturnZeroRows()
        //    {
        //        ArrayList tmp = new ArrayList();
        //
        //        EventTB oeventtb = new EventTB();
        //
        //        oeventtb.Name = "No Records";
        //        oeventtb.stTime = DateTime.Now;
        //        oeventtb.EndTime = DateTime.Now;
        //        tmp.Add(oeventtb);
        //
        //        oeventtb.Name = "No Records";
        //        oeventtb.stTime = DateTime.Now;
        //        oeventtb.EndTime = DateTime.Now;
        //        tmp.Add(oeventtb);
        //
        //        return tmp;
        //    }
        //
        // [RichLoba] - [END]

        static public string FormatText(short type)
        {
            //<%#  DataBinder.Eval(Container.DataItem, "ImageType") %>
            //string lower = type.ToLower().Trim();
            string retval = null;
            if (type == 1)
                retval = "Error";
            else if (type == 2)
                retval = "Warning";
            else if (type == 16)
                retval = "Failure Audit";
            else 
                retval = "Info"; //info is 4

            return retval;
        }

        static public string FormatURL(short type)
        {
            //<%#  DataBinder.Eval(Container.DataItem, "ImageType") %>
            string retval = null;
            if(type == 1)
                retval= "error.gif";
            else if (type == 2)
                retval = "warning.gif";
            else if (type == 16)
                retval = "failureaudit.jpg";
            else
                retval ="info.gif"; //info is 4

            return retval;
        }

	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\enumrecdreviews.cs ===
//-------------------------------------------------
//
//  EnumRecdReviews.cs : front door for feedback
//
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Xml;
using System.Text;
using System.Diagnostics;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.server.feedback 
{
    public class EnumerateRecdReviews : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            HResult hr = HResult.S_OK;
            
            Xom.NtEvent(XEvent.Id.FEEDBACK_INFO_0, "xonline.server.feedback.EnumerateRecdReviews.ProcessRequest() was called.");

            XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, hr);
            
        } // end ProcessRequest

        public bool IsReusable
        {
            get { return true; }
        }


    } // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\EventSys\websvc\service.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Services;
using System.Web.Caching;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.service;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.utilities;
using xonline.common.sql.webstore;
using xonline.server.mgmt.soap;
using xonline.server.webcache.common;


[assembly: XomIisInstallerAttribute( Interface.eventservice )]
[assembly: ConfigAttribute(xonline.common.config.Component.eventservice)]

[assembly: XomAreaDefinition(XomAreaName.EventService)]

namespace xonline.server.eventsys.websvc
{
    [WebService(Namespace="http://websvc.xboxlive.com/EventService/")]
    public class EventService : System.Web.Services.WebService
    {
        private static Utilities                    _utils;
        private static EventServiceCounterCategory  _counters;
        private const  int SUMMARY_TRUNCATE_LENGTH = 32;
    
        static EventService()
        {
            try
            {
                // Initialize statics
                _utils = Utilities.Instance;
                _counters = new EventServiceCounterCategory();
                
                // Pre-load any settings
                // FriendsCacheExpirationSeconds = Config.GetUIntSetting(Setting.presenceWidget_friendsCacheExpirationSeconds);
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_38, e);
            }
        }

        public EventService()
        {
            try
            {
                //CODEGEN: This call is required by the ASP.NET Web Services Designer
                InitializeComponent();
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_39, e);
            }
        }

        #region Component Designer generated code
        
        //Required by the Web Services Designer 
        private IContainer components = null;
                
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if(disposing && components != null)
            {
                components.Dispose();
            }
            base.Dispose(disposing);        
        }
        
        #endregion

        //------------------------------------------------------------------------------
        // Internal helpers
        //------------------------------------------------------------------------------

        // Get a partner specific category instance 
        private EventServiceCounterCategory PartnerCategory(string partnerName)
        {
            return (EventServiceCounterCategory) _counters.GetInstance(partnerName);
        }

        private void ValidatePartnerTitleAccess(string partnerName, uint titleId)
        {
        }

        private void ValidateMaxResults(uint maxResults)
        {
        }

        private void ValidateQueryText(string queryText)
        {
        }

        private void ValidateApplicationFilter(string applicationFilter)
        {
        }
        
        private void ValidateStartEndTime(DateTime startTime, DateTime endTime)
        {
        }

        //------------------------------------------------------------------------------
        // Web service exposed types
        //------------------------------------------------------------------------------

        public struct QueryResult
        {
            public uint                 Count;
            public LiveEventSummary []  Items;
        }

        public struct LiveEventSummary
        {
            public string               Guid;
            public DateTime             Time;
            public uint                 TitleId;
            public string               Application;
            public string               Server;
            public byte                 Type;
            public string               ShortDescription;
            public int                  DescriptionLength;
        }

        public struct LiveEventDetails
        {
            public LiveEventSummary     Summary;
            public string               FullText;
        }

        //------------------------------------------------------------------------------
        // Web service method definitions
        //------------------------------------------------------------------------------

        [WebMethod]
        public LiveEventSummary[] FindEvents(
                uint titleId, 
                uint maxResults,
                string queryText, 
                string applicationFilter, 
                DateTime startTime, 
                DateTime endTime)
        {
            try
            {
                _utils.CheckAPI("EventService.FindEvents");

                _counters.FindEventsPerSecond.Increment();
                _counters.FindEventsTotal.Increment();

                //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetGamertagsFromXUIDSFailedRequestsPerSecond);
                //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetGamertagsFromXUIDSFailedRequestsTotal);
                    
                string partnerName = Utilities.GetSubjectName();
                //if (partnerName != null)
                //{
                    //WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSRequestsPerSecond.Increment();
                    //WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSRequestsTotal.Increment();

                    //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSFailedRequestsPerSecond);
                    //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetGamertagsFromXUIDSFailedRequestsTotal);
                //}

                ValidatePartnerTitleAccess(partnerName, titleId);

                ValidateMaxResults(maxResults);

                ValidateQueryText(queryText);

                ValidateApplicationFilter(applicationFilter);

                ValidateStartEndTime(startTime, endTime);

                List<LiveEventSummary> summaries = new List<LiveEventSummary>((int)maxResults);

                using(WSClient ws = new WSClient(ConfigUtil.EventSysDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "p_event_sys_find_events";
                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@i_rowcount", maxResults + 1); // Add one to max results so we can inform client of need to page
                    ws.AddParameter("@dt_start_time", startTime);
                    ws.AddParameter("@dt_end_time", endTime);

                    // TODO: implement query filters
                    //ws.AddParameter("@vc_app", "%");
                    //ws.AddParameter("@si_type", "%");
                    //ws.AddParameter("@vc_server", "%");
                    
                    if(null != queryText && queryText.Length > 0)
                    {
                        ws.AddParameter("@vc_description", "%" + queryText + "%");
                    }

                    
                    // Execute query and read the results into memory
                    WstDataReader reader = ws.Execute();
                    while(reader.Read())
                    {
                        LiveEventSummary summary = new LiveEventSummary();
                        summary.Guid = ((System.Guid)reader["uid_mom_guid"]).ToString();
                        summary.Time = (DateTime)reader["dt_time"];
                        summary.TitleId = (uint)(int)reader["i_title_id"];
                        summary.Application = (string)reader["vc_app"];
                        summary.Server = (string)reader["vc_server"];
                        summary.Type = Byte.Parse((string)reader["si_type"]);

                        string desc = (string)reader["vc_description"];
                        summary.ShortDescription = Truncate(desc);
                        summary.DescriptionLength = desc.Length;

                        
                        summaries.Add(summary);
                    }

                    reader.Close();
                }
            
                
                Xom.Log(XomAreaName.EventService, 
                        String.Format(
                            "FindEvents|{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}|{8}",
                            Utilities.GetSubjectName(),
                            Utilities.GetRequestID(),
                            Utilities.GetClientIPPort(),
                            titleId,
                            queryText,
                            applicationFilter,
                            startTime,
                            endTime,
                            summaries.Count));

                return summaries.ToArray();
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_40, e);
            }
        }

        private string Truncate(string text)
        {
            int truncate = 0;
            int times = 3;
            while(times-- > 0 && truncate < SUMMARY_TRUNCATE_LENGTH)
            {
                truncate = text.IndexOfAny(new char[]{' ', '\t', '\n', '\r'}, truncate);
            }

            truncate = (int)Math.Max(truncate, SUMMARY_TRUNCATE_LENGTH);

            if(truncate <= text.Length)
            {
                return text.Substring(0, truncate);
            }
            else
            {
                return text;
            }
        }

        [WebMethod]
        public LiveEventDetails LookupEvent(uint titleId, string eventGuid)
        {
            try
            {
                _utils.CheckAPI("EventService.LookupEvent");

                _counters.LookupEventPerSecond.Increment();
                _counters.LookupEventTotal.Increment();

                //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetXUIDSFromGamertagsFailedRequestsPerSecond);
                //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters.GetXUIDSFromGamertagsFailedRequestsTotal);
                    
                //string partnerName = Utilities.GetSubjectName();
                //if (partnerName != null)
                //{
                    //WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsRequestsPerSecond.Increment();
                    //WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsRequestsTotal.Increment();

                    //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsFailedRequestsPerSecond);
                    //SoapFrontEndApp.AddErrorPerfCounter(WebCachePresenceCounter.Counters[partnerName].GetXUIDSFromGamertagsFailedRequestsTotal);
                //}

                
                LiveEventDetails details = new LiveEventDetails();
                details.Summary = new LiveEventSummary();
                
                using(WSClient ws = new WSClient(ConfigUtil.EventSysDbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.StoredProc = "p_event_sys_lookup_event";
                    ws.AddParameter("@i_title_id", (int)titleId);
                    ws.AddParameter("@uid_mom_guid", eventGuid);

                    // Execute query and read the results into memory
                    WstDataReader reader = ws.Execute();
                    if(reader.Read())
                    {
                        details.Summary.Guid = ((System.Guid)reader["uid_mom_guid"]).ToString();
                        details.Summary.Time = (DateTime)reader["dt_time"];
                        details.Summary.TitleId = (uint)(int)reader["i_title_id"];
                        details.Summary.Application = (string)reader["vc_app"];
                        details.Summary.Server = (string)reader["vc_server"];
                        details.Summary.Type = Byte.Parse((string)reader["si_type"]);
                        details.Summary.ShortDescription = "";

                        string desc = (string)reader["vc_description"];
                        details.Summary.ShortDescription = "";
                        details.Summary.DescriptionLength = desc.Length;
                        details.FullText = desc;
                    }

                    reader.Close();

                }

                Xom.Log(XomAreaName.EventService, String.Format("LookupEvent|{0}|{1}|{2}|{3}|{4}|{5}",
                                Utilities.GetSubjectName(),
                                Utilities.GetRequestID(),
                                Utilities.GetClientIPPort(),
                                titleId,
                                eventGuid,
                                (details.Summary.Guid == eventGuid ? 1 : 0)));

                return details;
            }
            catch (XboxWebException)
            {
                throw;
            }
            catch (Exception e)
            {
                throw new XboxWebInternalException(XEvent.Id.WEBCACHE_UNKNOWN_ERROR_40, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\enumsentreviews.cs ===
//-------------------------------------------------
//
//  EnumSentReviews.cs : front door for feedback
//
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Xml;
using System.Text;
using System.Diagnostics;

using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.server.feedback 
{
    public class EnumerateSentReviews : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            HResult hr = HResult.S_OK;
            
            Xom.NtEvent(XEvent.Id.FEEDBACK_INFO_1, "xonline.server.feedback.EnumerateSentReviews.ProcessRequest() was called.");
            
            XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, hr);
            
        } // end ProcessRequest

        public bool IsReusable
        {
            get { return true; }
        }


    } // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\getaggreview.cs ===
//-------------------------------------------------
//
//  GetAggReview.cs : front door for feedback
//
//-------------------------------------------------

using System;
using System.Collections;
using System.IO;
using System.Web;
using System.Xml;
using System.Text;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;


namespace xonline.server.feedback 
{
    public class GetAggregateReviews : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            HResult                     hr = HResult.S_OK;
            GetAggregateReviewsRequest  reviewRequest = null;
            GetAggregateReviewsReply    reviewReply = null;

            try
            {
                if (!XRLUtil.IsValidXOnlineRequest(ctx.Request, XOService.Feedback))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.FEEDBACK_HACK_3, "GetAggregateReview.ProcessRequest: Request is invalid" );                                        
                }

                // Keep track of total incoming requests
                FeedbackCounters.Current.GetAggregateReviewTotal.Increment();            
                FeedbackCounters.Current.GetAggregateReviewRate.Increment();            

                reviewRequest = new GetAggregateReviewsRequest();
                reviewRequest.ReadFromRequest(ctx.Request);

                CallSource.Check(VirtualInterface.fbserver, VirtualInterface.fbserver_int);
                
                //--------------------------
                // Do some param checking...
                if (reviewRequest.targetPUID == 0)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_NULL_TARGET, XEvent.Id.FEEDBACK_HACK_4, "GetAggregateReview.ProcessRequest: null targetPUID." );                
                }

                // Talk to the database to record this player review
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
                ws.StoredProc = "dbo.p_feedback_get_agg_reviews";
                int iBucket = ws.SetHashVal(reviewRequest.targetPUID);
                
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", reviewRequest.targetPUID);
                
                WstDataReader r = ws.Execute();
                hr = (uint)ws.GetIntParameter("@RETVAL");
                
                if(HResult.Failed(hr))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_DATABASE_ERROR, XEvent.Id.FEEDBACK_CODE_1, "GetAggregateReview.ProcessRequest: Database error: hr =" + hr + " TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );                    
                }

                ArrayList aggregates = new ArrayList();
                AggregateReview aggReview;

                int ixPuid = r.GetOrdinal("bi_user_puid");
                int ixType = r.GetOrdinal("i_type");
                int ixCount = r.GetOrdinal("i_count");

                while (r.Read())
                {
                    aggReview = new AggregateReview();
                    
                    aggReview.targetPUID    = (ulong)r.GetInt64(ixPuid);
                    aggReview.count         = (uint)r.GetInt32(ixCount);
                    aggReview.type          = (uint)r.GetInt32(ixType);

                    aggregates.Add(aggReview);
                }
                
                r.Close();

                reviewReply = new GetAggregateReviewsReply();

                reviewReply.hr = HResult.S_OK;
                reviewReply.cReviews = (uint)aggregates.Count;
                reviewReply.aggReviews = (AggregateReview[])aggregates.ToArray(typeof(AggregateReview));                
                
                // Log line gets written in the finally block                    
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "GetAggregateReview.ProcessRequest: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message );
                hr = e.HResult;
                
                throw;
            }            
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.GetAggregateReview: Unexpected failure, msg=" + e.Message );
                hr = HResult.XONLINE_E_FEEDBACK_GET_AGGREGATE_REVIEW_ERROR;

                throw;
            }
            finally
            {
                if (null != reviewRequest)
                {
                    // LineType|LineDesc|SendPUID|TargetPUID|TitleID|ReviewType|Nonce
                    Xom.Log(XomAreaName.feedbacklog, "803|GetAggregateReview|"
                        + "|" + ((long) reviewRequest.targetPUID).ToString("d")
                        );
                }
            }                    

            if (HResult.Succeeded(hr))
            {
                // We've successfully recorded this GetAggregateReview request
                FeedbackCounters.Current.GetAggregateReviewSuccessTotal.Increment();            
                FeedbackCounters.Current.GetAggregateReviewSuccessRate.Increment();            
            }
            else
            {
                // We've failed to process this GetAggregateReview request
                FeedbackCounters.Current.GetAggregateReviewFailedTotal.Increment();            
                FeedbackCounters.Current.GetAggregateReviewFailedRate.Increment();            
            }
            
            if( null != reviewReply )
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, reviewReply.hr, reviewReply);
            }
            else
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, hr);
            }

        } // end ProcessRequest

        public bool IsReusable
        {
            get { return true; }
        }

    } // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\fbserver.cs ===
//-------------------------------------------------
//
//  FeedbackServer.cs : front door for feedback
//
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Xml;
using System.Text;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;


namespace xonline.server.feedback 
{
    public class FeedbackServer : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            HResult             hr = HResult.S_OK;
            FeedbackRequest     feedbackRequest = null;
            string              feedbackData = "";

            try
            {
                if (!XRLUtil.IsValidXOnlineRequest(ctx.Request, XOService.Feedback))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.FEEDBACK_HACK_0, "FBServer.Feedback: Request is invalid" );                                        
                }

                // Keep track of total incoming requests
                FeedbackCounters.Current.FeedbackTotal.Increment();            
                FeedbackCounters.Current.FeedbackRate.Increment();            
            
                feedbackRequest = new FeedbackRequest();
                feedbackRequest.ReadFromRequest(ctx.Request);

                CallSource.Check(VirtualInterface.fbserver, VirtualInterface.fbserver_int);
                
                //--------------------------
                // Do some param checking...
                if (feedbackRequest.ulTargetPUID == 0)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_NULL_TARGET, XEvent.Id.FEEDBACK_HACK_1, "FBServer.ProcessRequest: null targetPUID (TitleID=0x" + ((int)feedbackRequest.uiTitleID).ToString("x") + ",SenderPUID=0x" + feedbackRequest.ulSendPUID.ToString("x") + ",Type=0x" + feedbackRequest.bFeedbackType.ToString("x") + ",TargetPUID=0x" + feedbackRequest.ulTargetPUID.ToString("x") + ")" );                
                }
                if ((feedbackRequest.bFeedbackType >= FeedbackApp.MaxFeedbackType) && (feedbackRequest.bFeedbackType < FeedbackApp.MinServiceType))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_BAD_TYPE, XEvent.Id.FEEDBACK_HACK_2, "FBServer.ProcessRequest: Bad Feedback Type (TitleID=0x" + ((int)feedbackRequest.uiTitleID).ToString("x") + ",SenderPUID=0x" + feedbackRequest.ulSendPUID.ToString("x") + ",Type=0x" + feedbackRequest.bFeedbackType.ToString("x") + ",TargetPUID=0x" + feedbackRequest.ulTargetPUID.ToString("x") + ")" );
                }

                if (feedbackRequest.bTextSize > 0)
                {  
                    // Create a UTF-8 encoding.
                    UTF8Encoding utf8 = new UTF8Encoding( false /* no byte order mark */, true /* throw on bad chars */ );

                    // Encode the string to ensure it is valid. This will throw on error. 
                    utf8.GetBytes( feedbackRequest.szText );

                    // String is guaranteed valid at this point. Copy it to the member we will log
                    feedbackData = feedbackRequest.szText;
                }

                // Talk to the database to record this feedback
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
                ws.StoredProc = "dbo.p_feedback_submit_v1_feedback";
                int iBucket = ws.SetHashVal(feedbackRequest.ulTargetPUID);
                
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", feedbackRequest.ulSendPUID);
                ws.AddParameter(ParamType.INPUT, "@bi_target_puid", feedbackRequest.ulTargetPUID);
                ws.AddParameter(ParamType.INPUT, "@i_title_id", feedbackRequest.uiTitleID);
                ws.AddParameter(ParamType.INPUT, "@i_type", feedbackRequest.bFeedbackType);
                ws.AddParameter(ParamType.INPUT, "@vc_text", feedbackData, feedbackData.Length);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", iBucket);
                
                ws.ExecuteNonQuery();
                
                hr = (uint)ws.GetIntParameter("@RETVAL");
                
                if(HResult.Failed(hr))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_DATABASE_ERROR, XEvent.Id.FEEDBACK_CODE_0, "FBServer.ProcessRequest: Database error: hr = " + hr + ", TitleID=0x" + ((int)feedbackRequest.uiTitleID).ToString("x") + ",SenderPUID=0x" + feedbackRequest.ulSendPUID.ToString("x") + ",Type=0x" + feedbackRequest.bFeedbackType.ToString("x") + ",TargetPUID=0x" + feedbackRequest.ulTargetPUID.ToString("x") + ")" );
                }
                
                // Log line gets written in the finally block                    
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.Feedback: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message );
                hr = e.HResult;
                
                throw;
            }            
            catch( ArgumentException e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.Feedback: Invalid string encoding: TitleID=0x" + ((int)feedbackRequest.uiTitleID).ToString("x") + ",SenderPUID=0x" + feedbackRequest.ulSendPUID.ToString("x") + ",Type=0x" + feedbackRequest.bFeedbackType.ToString("x") + ",TargetPUID=0x" + feedbackRequest.ulTargetPUID.ToString("x") + ", msg="  + e.Message);
                feedbackData = "<Bad String>";
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.Feedback: Unexpected failure, msg=" + e.Message );
                hr = HResult.XONLINE_E_FEEDBACK_ERROR;

                throw;
            }
            finally
            {
                if (null != feedbackRequest)
                {
                    // LineType|LineDesc|SendPUID|TargetPUID|TitleID|FeedbackType|Nickname(optional)
                    Xom.Log(XomAreaName.feedbacklog, "801|FEEDBACK|"
                        + "|" + ((long) feedbackRequest.ulSendPUID).ToString("d")
                        + "|" + ((long) feedbackRequest.ulTargetPUID).ToString("d")
                        + "|" + ((int) feedbackRequest.uiTitleID).ToString("d") 
                        + "|" + feedbackRequest.bFeedbackType.ToString("d") 
                        + "|" + feedbackData
                        );
                }
            }                    

            if (HResult.Succeeded(hr))
            {
                // We've successfully recorded this feedback request
                FeedbackCounters.Current.FeedbackSuccessTotal.Increment();            
                FeedbackCounters.Current.FeedbackSuccessRate.Increment();            
            }
            else
            {
                // We've failed to process this feedback request
                FeedbackCounters.Current.FeedbackFailedTotal.Increment();            
                FeedbackCounters.Current.FeedbackFailedRate.Increment();            
            }
            
            if( null != feedbackRequest )
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, feedbackRequest.uiTitleID, hr);
            }
            else
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, hr);
            }

        } // end ProcessRequest

        public bool IsReusable
        {
            get { return true; }
        }


    } // end class 


    [XomPerformanceCounterCategoryAttr( "Feedback FD", "XBox Live Feedback Service" )]
    public class FeedbackCounters : XomPerformanceCounterCategory
    {
        
        static public FeedbackCounters Current = new FeedbackCounters();
        
        //
        // Feedback counters
        //
        [XomPerformanceCounterAttr(
            "Feedback Requests", 
            "Total number of feedback requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FeedbackTotal;

        [XomPerformanceCounterAttr(
            "Feedback Requests Rate", 
            "Total number of feedback requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FeedbackRate;

        [XomPerformanceCounterAttr(
            "Successful Feedback Requests", 
            "Total number of successful feedback requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FeedbackSuccessTotal;

        [XomPerformanceCounterAttr(
            "Successful Feedback Requests Rate", 
            "Total number of successful feedback requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FeedbackSuccessRate;

        [XomPerformanceCounterAttr(
            "Failed Feedback Requests", 
            "Total number of failed feedback requests processed by the server.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter FeedbackFailedTotal;

        [XomPerformanceCounterAttr(
            "Failed Feedback Requests Rate", 
            "Total number of failed feedback requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FeedbackFailedRate;


        //
        // Review counters
        //
        [XomPerformanceCounterAttr(
            "Submitted Review Requests", 
            "Total number of Review requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SubmitReviewTotal;

        [XomPerformanceCounterAttr(
            "Submitted Review Requests Rate", 
            "Total number of Review requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SubmitReviewRate;

        [XomPerformanceCounterAttr(
            "Successful Submitted Review Requests", 
            "Total number of successful Review requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SubmitReviewSuccessTotal;

        [XomPerformanceCounterAttr(
            "Successful Submitted Review Requests Rate", 
            "Total number of successful Review requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SubmitReviewSuccessRate;

        [XomPerformanceCounterAttr(
            "Failed Submitted Review Requests", 
            "Total number of failed Review requests processed by the server.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SubmitReviewFailedTotal;

        [XomPerformanceCounterAttr(
            "Failed Submitted Review Requests Rate", 
            "Total number of failed Review requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SubmitReviewFailedRate;


        //
        // Complaint counters
        //
        [XomPerformanceCounterAttr(
            "Submit Complaint Requests", 
            "Total number of Complaint requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SubmitComplaintTotal;

        [XomPerformanceCounterAttr(
            "Submit Complaint Requests Rate", 
            "Total number of Complaint requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SubmitComplaintRate;

        [XomPerformanceCounterAttr(
            "Successful Submit Complaint Requests", 
            "Total number of successful Complaint requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SubmitComplaintSuccessTotal;

        [XomPerformanceCounterAttr(
            "Successful Submit Complaint Requests Rate", 
            "Total number of successful Complaint requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SubmitComplaintSuccessRate;

        [XomPerformanceCounterAttr(
            "Failed Submit Complaint Requests", 
            "Total number of failed Complaint requests processed by the server.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SubmitComplaintFailedTotal;

        [XomPerformanceCounterAttr(
            "Failed Submit Complaint Requests Rate", 
            "Total number of failed Complaint requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SubmitComplaintFailedRate;


        //
        // AggregateReview counters
        //
        [XomPerformanceCounterAttr(
            "AggregateReview Requests", 
            "Total number of AggregateReview requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetAggregateReviewTotal;
        
        [XomPerformanceCounterAttr(
            "AggregateReview Requests Rate", 
            "Total number of AggregateReview requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetAggregateReviewRate;
        
        [XomPerformanceCounterAttr(
            "Successful AggregateReview Requests", 
            "Total number of successful AggregateReview requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetAggregateReviewSuccessTotal;
        
        [XomPerformanceCounterAttr(
            "Successful AggregateReview Requests Rate", 
            "Total number of successful AggregateReview requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetAggregateReviewSuccessRate;
        
        [XomPerformanceCounterAttr(
            "Failed AggregateReview Requests", 
            "Total number of failed AggregateReview requests processed by the server.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetAggregateReviewFailedTotal;
        
        [XomPerformanceCounterAttr(
            "Failed AggregateReview Requests Rate", 
            "Total number of failed AggregateReview requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter GetAggregateReviewFailedRate;

    } // end perf counter class

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\fbapp.cs ===
// fbapp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Feedback Service Front Door
// Xbox Online Service

using System;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Security.Principal;
using System.Threading;
using System.Web;
using System.Web.Caching;

using xonline.common.config;
using xonline.common.health;
using xonline.common.installer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomIisInstallerAttribute( Interface.fbserver )]
[assembly: XomIisInstallerAttribute( Interface.fbserver_int )]
[assembly: ConfigAttribute(Component.fbserver)]


[assembly: XomAreaDefinition(XomAreaName.feedbackTrace)]
[assembly: XomAreaDefinition(XomAreaName.feedbacklog)]


namespace xonline.server.feedback 
{
    public class FeedbackInfoHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType 
        { 
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager  blockManager, 
            NameValueCollection blockParams,
            HealthReport        report
        )
        {
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    public class FeedbackApp : FrontEndApp
    {
        public override void Application_BeginRequest( object sender, EventArgs e )
        {
            base.Application_BeginRequest( sender, e );
            
            // we have to do initalization here instead of Application_Start, because
            // the former isn't yet impersonating the iis application's credentials. 
            // 
            if (m_fInitialized == false)
            {
                lock(this)
                {
                    if (m_fInitialized == false)                    
                    {
                        Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_NORMAL, "Feedback: Initializing..." );

                        Config.SettingChange += new SettingChangeEventHandler(OnSettingChange);

                        LoadConfigSettings();
                        
                        Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_NORMAL, "Feedback: Initializing...Done" );
                        m_fInitialized = true;
                    }
                }
            }            
        }
        
        public override void Application_End( object sender, EventArgs e )
        {
            // Do application termination here
            Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_NORMAL, "Feedback: Shutting down..." );
            
            base.Application_End( sender, e );
        }

        public static void LoadConfigSettings()
        {
            
            //
            // Xbox1 Settings:
            //
            
            // NOTE: This must be increased when new types are added by changing the INI file
            _maxFeedbackType = Config.GetUIntSetting(Setting.feedback_maxFeedbackTypes);
            if( 0 == _maxFeedbackType )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "Feedback: No MaxFeedbackTypes setting found in configuration data" );
                Xom.NtEvent( XEvent.Id.FEEDBACK_CONFIG_0, "Feedback: No MaxFeedbackTypes setting found in configuration data" );
            }
            
            // NOTE: This must be decreased when new private types are added by changing the INI file
            _minFeedbackServiceType = Config.GetUIntSetting(Setting.feedback_minFeedbackServiceType);
            if( 0 == _minFeedbackServiceType )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "Feedback: No MinFeedbackServiceType setting found in configuration data" );
                Xom.NtEvent( XEvent.Id.FEEDBACK_CONFIG_1, "Feedback: No MinFeedbackServiceType setting found in configuration data" );
                _minFeedbackServiceType = 256; // Default to 256 if none specified (no service defined types)
            }
            
            //
            // Xenon Settings:
            //
            
            // Player review types. Must be a max set > 0
            _maxReviewType = Config.GetUIntSetting(Setting.feedback_maxReviewType);
            if( 0 == _maxReviewType )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "Feedback: No MaxReviewTypes setting found in configuration data" );
                Xom.NtEvent( XEvent.Id.FEEDBACK_CONFIG_2, "Feedback: No MaxReviewTypes setting found in configuration data" );
            }
            
            // Complaint types. Must be a max set > 0
            _maxComplaintType = Config.GetUIntSetting(Setting.feedback_maxComplaintType);
            if( 0 == _maxComplaintType )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "Feedback: No MaxComplaintType setting found in configuration data" );
                Xom.NtEvent( XEvent.Id.FEEDBACK_CONFIG_3, "FBServer: No MaxComplaintType setting found in configuration data" );
            }             

            // Rating accumulation coefficients. Validate that these are between 0.0 and 1.0
            _reviewIgnoreThreshold = Config.GetDoubleSetting(Setting.feedback_reviewIgnoreThreshold);
            if(( 1.0 < _reviewIgnoreThreshold ) || ( 0.0 > _reviewIgnoreThreshold ))
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "Feedback: ReviewIgnoreThreshold setting found in configuration data is out of bounds" );
                Xom.NtEvent( XEvent.Id.FEEDBACK_CONFIG_4, "FBServer: ReviewIgnoreThreshold setting found in configuration data is out of bounds" );
            }             

            _ratingDecayFactor = Config.GetDoubleSetting(Setting.feedback_ratingDecayFactor);
            if(( 1.0 < _ratingDecayFactor ) || ( 0.0 > _ratingDecayFactor ))
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "Feedback: RatingDecayFactor setting found in configuration data is out of bounds" );
                Xom.NtEvent( XEvent.Id.FEEDBACK_CONFIG_5, "FBServer: RatingDecayFactor setting found in configuration data is out of bounds" );
            }             

            _ratingDecayFloor = Config.GetDoubleSetting(Setting.feedback_ratingDecayFloor);
            if(( 1.0 < _ratingDecayFloor ) || ( 0.0 > _ratingDecayFloor ))
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "Feedback: RatingDecayFloor setting found in configuration data is out of bounds" );
                Xom.NtEvent( XEvent.Id.FEEDBACK_CONFIG_6, "FBServer: RatingDecayFloor setting found in configuration data is out of bounds" );
            }             

            // Rating calculation coefficients
            _coeffNegativeReview = Config.GetDoubleSetting(Setting.feedback_coeffNegativeReview);
            _coeffPositiveReview = Config.GetDoubleSetting(Setting.feedback_coeffPositiveReview);
            _coeffFudgeFactor = Config.GetDoubleSetting(Setting.feedback_coeffFudgeFactor);

            // Normalization coefficients
            _coeffBias = Config.GetDoubleSetting(Setting.feedback_coeffBias);
            _coeffSlope = Config.GetDoubleSetting(Setting.feedback_coeffSlope);
            _coeffRange = Config.GetDoubleSetting(Setting.feedback_coeffRange);

            // Default rating
            _ratingDefault = Config.GetDoubleSetting(Setting.xuacs_defaultGamercardReputation);
            
        }
        
        public static void OnSettingChange(object sender, SettingChangeEventArgs e)
        {
            switch (e.Setting)
            {
            case Setting.feedback_maxFeedbackTypes:
                if ((UInt32.Parse(e.ValueNew) == 0) || (UInt32.Parse(e.ValueNew) > 128))
                {
                    throw new Exception("Feedback: MaxFeedbackTypes setting change is invalid. Rejected.");
                }
                _maxFeedbackType = UInt32.Parse(e.ValueNew);
                break;

            case Setting.feedback_minFeedbackServiceType:
                if ((UInt32.Parse(e.ValueNew) <= 128) || (UInt32.Parse(e.ValueNew) > 256))
                {
                    throw new Exception("Feedback: MaxFeedbackTypes setting change is invalid. Rejected.");
                }
                _minFeedbackServiceType = UInt32.Parse(e.ValueNew);
                break;

            case Setting.feedback_maxReviewType:
                if (UInt32.Parse(e.ValueNew) == 0)
                {
                    throw new Exception("Feedback: MaxReviewType setting change is invalid. Rejected.");
                }
                _maxReviewType = UInt32.Parse(e.ValueNew);
                break;

            case Setting.feedback_maxComplaintType:
                if (UInt32.Parse(e.ValueNew) == 0)
                {
                    throw new Exception("Feedback: MaxComplaintType setting change is invalid. Rejected.");
                }
                _maxComplaintType = UInt32.Parse(e.ValueNew);
                break;

                
            case Setting.feedback_reviewIgnoreThreshold:
                if (Double.Parse(e.ValueNew) == 0)
                {
                    throw new Exception("Feedback: ReviewIgnoreThreshold setting change is invalid. Rejected.");
                }
                _reviewIgnoreThreshold = Double.Parse(e.ValueNew);
                break;

            case Setting.feedback_ratingDecayFactor:
                if (Double.Parse(e.ValueNew) == 0)
                {
                    throw new Exception("Feedback: RatingDecayFactor setting change is invalid. Rejected.");
                }
                _ratingDecayFactor = Double.Parse(e.ValueNew);
                break;
                
            case Setting.feedback_ratingDecayFloor:
                if (Double.Parse(e.ValueNew) == 0)
                {
                    throw new Exception("Feedback: RatingDecayFloor setting change is invalid. Rejected.");
                }
                _ratingDecayFloor = Double.Parse(e.ValueNew);
                break;

            case Setting.feedback_coeffNegativeReview:
                _coeffNegativeReview = Double.Parse(e.ValueNew);
                break;

            case Setting.feedback_coeffPositiveReview:
                _coeffPositiveReview = Double.Parse(e.ValueNew);
                break;

            case Setting.feedback_coeffFudgeFactor:
                _coeffFudgeFactor = Double.Parse(e.ValueNew);
                break;

            case Setting.feedback_coeffBias:
                _coeffBias = Double.Parse(e.ValueNew);
                break;

            case Setting.feedback_coeffSlope:
                _coeffSlope = Double.Parse(e.ValueNew);
                break;

            case Setting.feedback_coeffRange:
                _coeffRange = Double.Parse(e.ValueNew);
                break;
                
            case Setting.xuacs_defaultGamercardReputation:
                _ratingDefault = Double.Parse(e.ValueNew);
                break;
            }
        }    


        public static uint MaxFeedbackType          { get { return _maxFeedbackType;} }
        public static uint MinServiceType           { get { return _minFeedbackServiceType;} }
        public static uint MaxReviewType            { get { return _maxReviewType;} }
        public static uint MaxComplaintType         { get { return _maxComplaintType;} }

        public static double ReviewIgnoreThreshold  { get { return _reviewIgnoreThreshold;} }
        public static double RatingDecayFactor      { get { return _ratingDecayFactor;} }
        public static double RatingDecayFloor       { get { return _ratingDecayFloor;} }
        public static double CoeffNegativeReview    { get { return _coeffNegativeReview;} }
        public static double CoeffPositiveReview    { get { return _coeffPositiveReview;} }
        public static double CoeffFudgeFactor       { get { return _coeffFudgeFactor;} }
        public static double CoeffBias              { get { return _coeffBias;} }
        public static double CoeffSlope             { get { return _coeffSlope;} }
        public static double CoeffRange             { get { return _coeffRange;} }
        public static double RatingDefault          { get { return _ratingDefault;} }

        // Settings
        private static uint _maxFeedbackType;          // Public types start at 0 and increase sequentially as documented in xonline.x
        private static uint _minFeedbackServiceType;   // Private service types start at 255 and decrease sequentially as documented in xonline.x
        
        private static uint _maxReviewType;            // Player Review types start at 0 and increase sequentially as documented in xonline.x
        private static uint _maxComplaintType;         // Complaint types start at 0 and increase sequentially as documented in xonline.x

        private static double _reviewIgnoreThreshold;  // If the user exceeds this threshold (calculated as reviews sent/strangers played) the review is ignored
        private static double _ratingDecayFactor;      // The factor at which values decay on a per game basis. 
        private static double _ratingDecayFloor;       // The minimum allowed decay factor between recalculations of the rating
        private static double _coeffNegativeReview;    // The relative weight of negative reviews to strangers played
        private static double _coeffPositiveReview;    // The relative weight of positive reviews to strangers played
        private static double _coeffFudgeFactor;       // The relative weight of the fudge factor
        private static double _coeffBias;              // Bias coefficient for normalizing the rating 
        private static double _coeffSlope;             // Slope coefficient for normalizing the rating 
        private static double _coeffRange;             // Range coefficient for normalizing the rating 
        private static double _ratingDefault;          // Default rating a user starts with
        
        private static bool m_fInitialized = false;       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\submitreview.cs ===
//-------------------------------------------------
//
//  SubmitReview.cs : front door for SubmitReview
//
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Xml;
using System.Text;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;


namespace xonline.server.feedback 
{
    public class SubmitReview : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            HResult                 hr = HResult.S_OK;
            SubmitReviewRequest     reviewRequest = null;

            try
            {
                WSClient    ws;
                int         iBucket;
                int         iGamesPlayed = 0;
                int         iUsersPlayed = 0;
                int         iReviewsSent = 0;
                int         iFudgeFactor = 0;
                
                if (!XRLUtil.IsValidXOnlineRequest(ctx.Request, XOService.Feedback))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.FEEDBACK_HACK_10, "SubmitReview.ProcessRequest: Request is invalid" );                                        
                }

                CallSource.Check(VirtualInterface.fbserver, VirtualInterface.fbserver_int);
                
                // Keep track of total incoming requests
                FeedbackCounters.Current.SubmitReviewTotal.Increment();            
                FeedbackCounters.Current.SubmitReviewRate.Increment();            
            
                reviewRequest = new SubmitReviewRequest();
                reviewRequest.ReadFromRequest(ctx.Request);

                //--------------------------
                // Do some param checking...
                if (reviewRequest.targetPUID == 0)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_NULL_TARGET, XEvent.Id.FEEDBACK_HACK_11, "SubmitReview.ProcessRequest: null targetPUID. TitleID=0x" + ((int)reviewRequest.titleID).ToString("x") + ",SenderPUID=0x" + reviewRequest.senderPUID.ToString("x") + ",Type=0x" + reviewRequest.type.ToString("x") + ",TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );                
                }
                if (reviewRequest.targetPUID == reviewRequest.senderPUID)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_NULL_TARGET, XEvent.Id.FEEDBACK_HACK_12, "SubmitReview.ProcessRequest: senderPUID == targetPUID. TitleID=0x" + ((int)reviewRequest.titleID).ToString("x") + ",SenderPUID=0x" + reviewRequest.senderPUID.ToString("x") + ",Type=0x" + reviewRequest.type.ToString("x") + ",TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );                
                }
                if (!SGInfo.Current.IsUserPresent( reviewRequest.senderPUID ))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_USER_NOT_PRESENT, XEvent.Id.FEEDBACK_HACK_13, "SubmitReview.ProcessRequest: senderPUID is not present in the SGINFO. TitleID=0x" + ((int)reviewRequest.titleID).ToString("x") + ",SenderPUID=0x" + reviewRequest.senderPUID.ToString("x") + ",Type=0x" + reviewRequest.type.ToString("x") + ",TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );                
                }                
                if (reviewRequest.type >= FeedbackApp.MaxReviewType)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_BAD_TYPE, XEvent.Id.FEEDBACK_HACK_14, "SubmitReview.ProcessRequest: Bad Review Type. TitleID=0x" + ((int)reviewRequest.titleID).ToString("x") + ",SenderPUID=0x" + reviewRequest.senderPUID.ToString("x") + ",Type=0x" + reviewRequest.type.ToString("x") + ",TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );
                }

                // Talk to the database to record this player review
                ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
                iBucket = ws.SetHashVal(reviewRequest.senderPUID);
                
                if (reviewRequest.type != (uint)FeedbackDefs.PlayerReview.Prefer) 
                {
                    iReviewsSent = 1;
                }

                ws.StoredProc = "dbo.p_feedback_add_rating_data";
                ws.AddParameter(ParamType.RETVAL,  "@RETVAL",           hr);
                ws.AddParameter(ParamType.INPUT,   "@bi_user_puid",     reviewRequest.senderPUID);
                ws.AddParameter(ParamType.INOUT,   "@i_games_played",   iGamesPlayed);
                ws.AddParameter(ParamType.INOUT,   "@i_users_played",   iUsersPlayed);
                ws.AddParameter(ParamType.INOUT,   "@i_reviews_sent",   iReviewsSent);
                ws.AddParameter(ParamType.INOUT,   "@i_fudge_factor",   iFudgeFactor);
                ws.AddParameter(ParamType.INPUT,   "@si_hash_bucket",   iBucket);
                
                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
                
                if(HResult.Failed(hr))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_DATABASE_ERROR, XEvent.Id.FEEDBACK_CODE_3, "SubmitReview.ProcessRequest: Database error on p_feedback_add_rating_data: hr = " + hr + ", TitleID=0x" + ((int)reviewRequest.titleID).ToString("x") + ",SenderPUID=0x" + reviewRequest.senderPUID.ToString("x") + ",Type=0x" + reviewRequest.type.ToString("x") + ",TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );                    
                }                

                iGamesPlayed    = ws.GetIntParameter("@i_games_played");
                iUsersPlayed    = ws.GetIntParameter("@i_users_played");
                iReviewsSent    = ws.GetIntParameter("@i_reviews_sent");
                iFudgeFactor    = ws.GetIntParameter("@i_fudge_factor");
                
                                
                // Enforce sanity. If this user has more than 10 submitted reviews, verify that they aren't
                //  above the spam threshold. If they are, we ignore their feedback if it is bad
                if ((iReviewsSent > 10) && (reviewRequest.type != (uint)FeedbackDefs.PlayerReview.Prefer) && ((double)iReviewsSent/(double)iUsersPlayed) > FeedbackApp.ReviewIgnoreThreshold)
                {
                    hr = HResult.XONLINE_E_FEEDBACK_REVIEW_LIMIT_EXCEEDED;
                    goto Exit;
                }


                // Cleared to write the news to the database
                ws.ClearParameters();
                iBucket = ws.SetHashVal(reviewRequest.targetPUID);
                
                ws.StoredProc = "dbo.p_feedback_submit_review";
                
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", reviewRequest.senderPUID);
                ws.AddParameter(ParamType.INPUT, "@bi_target_puid", reviewRequest.targetPUID);
                ws.AddParameter(ParamType.INPUT, "@i_title_id", reviewRequest.titleID);
                ws.AddParameter(ParamType.INPUT, "@i_type", reviewRequest.type);
                ws.AddParameter(ParamType.INPUT, "@bi_context", reviewRequest.context);
                ws.AddParameter(ParamType.INPUT, "@dt_submitted", DateTime.UtcNow);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", iBucket);
                
                ws.ExecuteNonQuery();
                
                hr = (uint)ws.GetIntParameter("@RETVAL");
                
                if(HResult.Failed(hr))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_DATABASE_ERROR, XEvent.Id.FEEDBACK_CODE_4, "SubmitReview.ProcessRequest: Database error on p_feedback_submit_review: hr = " + hr + ", TitleID=0x" + ((int)reviewRequest.titleID).ToString("x") + ",SenderPUID=0x" + reviewRequest.senderPUID.ToString("x") + ",Type=0x" + reviewRequest.type.ToString("x") + ",TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );
                }

                // Integration with Affiliates is best effort. If we fail, we will not abort the request.
                //  UpdateAffiliation logs errors internally
                UpdateAffiliation(ctx, reviewRequest.senderPUID, reviewRequest.targetPUID, reviewRequest.type, reviewRequest.titleID);
                
                if(hr == HResult.S_FALSE)
                {
                    // Inserted a new review - calculate a new rating for the target
                    ws.ClearParameters();
                    iBucket = ws.SetHashVal(reviewRequest.targetPUID);
                    
                    ws.StoredProc = "dbo.p_feedback_calc_rating_data";

                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                    ws.AddParameter(ParamType.INPUT, "@bi_user_puid", reviewRequest.targetPUID);
                    ws.AddParameter(ParamType.INPUT, "@dbl_decay_factor", FeedbackApp.RatingDecayFactor);
                    ws.AddParameter(ParamType.INPUT, "@dbl_decay_floor", FeedbackApp.RatingDecayFloor);
                    ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", iBucket);

                    WstDataReader r = ws.Execute();
                    hr = (uint)ws.GetIntParameter("@RETVAL");
                    
                    if(HResult.Failed(hr))
                    {
                        throw new XRLException(HResult.XONLINE_E_FEEDBACK_DATABASE_ERROR, XEvent.Id.FEEDBACK_CODE_5, "SubmitReview.ProcessRequest: Database error on p_feedback_calc_rating_data: hr = " + hr + "TargetPUID=0x" + reviewRequest.targetPUID.ToString("x") );                    
                    }

                    if (r.Read())
                    {
                        double usersPlayed      = r.GetDouble(r.GetOrdinal("dbl_decayed_users_played"));
                        double fudgeFactor      = r.GetDouble(r.GetOrdinal("dbl_decayed_fudge_factor"));
                        double positiveReviews  = r.GetDouble(r.GetOrdinal("dbl_decayed_positive_review"));
                        double negativeReviews  = r.GetDouble(r.GetOrdinal("dbl_decayed_negative_review"));                    

                        // Do the math. First calculate the raw rating score
                        double rawRating = (usersPlayed 
                                    + (positiveReviews * FeedbackApp.CoeffPositiveReview) 
                                    - (negativeReviews * FeedbackApp.CoeffNegativeReview) 
                                    + (FeedbackApp.RatingDefault * fudgeFactor * FeedbackApp.CoeffFudgeFactor) )
                                    / (usersPlayed
                                    + (fudgeFactor * FeedbackApp.CoeffFudgeFactor) );                                    

                        rawRating = Math.Min(rawRating, 1.0);
                        rawRating = Math.Max(rawRating, 0.0);

                        // Now normalize to our 1-100 scale
                        // f(x) = exp((x-bias)*slope))/(1+exp((x-bias)*slope))*Range
                        double refinedRating = Math.Exp((rawRating-FeedbackApp.CoeffBias)*FeedbackApp.CoeffSlope)
                                    /(1+Math.Exp((rawRating-FeedbackApp.CoeffBias)*FeedbackApp.CoeffSlope))*FeedbackApp.CoeffRange;

                        refinedRating = Math.Min(refinedRating, 100.0);
                        refinedRating = Math.Max(refinedRating, 0.01);

                        // Write the rating to the profile
                        UpdateProfile(reviewRequest.senderPUID, reviewRequest.targetPUID, (float)refinedRating, reviewRequest.titleID);
                    }
                    
                    r.Close();                    
                }                
Exit:                
                ; // Log line gets written in the finally block
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "SubmitReview.ProcessRequest: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message );
                hr = e.HResult;
                
                throw;
            }            
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.SubmitReview: Unexpected failure, msg=" + e.Message );
                hr = HResult.XONLINE_E_FEEDBACK_SUBMIT_REVIEW_ERROR;

                throw;
            }
            finally
            {
                if (null != reviewRequest)
                {
                    // LineType|LineDesc|SendPUID|TargetPUID|TitleID|ReviewType|Nonce
                    Xom.Log(XomAreaName.feedbacklog, "802|SubmitReview|"
                        + "|" + ((long) reviewRequest.senderPUID).ToString("d")
                        + "|" + ((long) reviewRequest.targetPUID).ToString("d")
                        + "|" + ((int) reviewRequest.titleID).ToString("d") 
                        + "|" + reviewRequest.type.ToString("d") 
                        + "|" + ((long) reviewRequest.context).ToString("d")
                        );
                }
            }                    

            if (HResult.Succeeded(hr))
            {
                // We've successfully recorded this SubmitReview request
                FeedbackCounters.Current.SubmitReviewSuccessTotal.Increment();            
                FeedbackCounters.Current.SubmitReviewSuccessRate.Increment();            
            }
            else
            {
                // We've failed to process this SubmitReview request
                FeedbackCounters.Current.SubmitReviewFailedTotal.Increment();            
                FeedbackCounters.Current.SubmitReviewFailedRate.Increment();            
            }
            
            if( null != reviewRequest )
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, reviewRequest.titleID, hr);
            }
            else
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, hr);
            }
            
        } // end ProcessRequest

        private string GetHttpAuthData(ulong userId, uint titleId)
        {
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, userId, titleId, 0, 0);

            return authData.GetBase64EncodedString();
        }

        private HResult UpdateAffiliation(HttpContext ctx, ulong senderPuid, ulong targetPuid, uint type, uint titleId)
        {
            PresenceAddAffiliatesMsg  request = new PresenceAddAffiliatesMsg();
            XRLObject2                xrlo = null;
            HResult                   hr;

            request.qwSenderID = senderPuid;
            if (type == (uint)FeedbackDefs.PlayerReview.Prefer)
            {
                request.dwListFlag = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_POSITIVE_FEEDBACK_INDEX);
            }
            else
            {
                request.dwListFlag = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX);
            }

            request.dwTitleID = titleId;
            request.cwAffiliates = 1;
            request.pqwAffiliates = new ulong[1];
            request.pqwAffiliates[0] = targetPuid;           
            
            string url = ctx.Request.Headers[FeedbackDefs.AlternatePresenceDestinationHeaderName];
            if (url == null)
            {
                hr = XRLUtil.PostXrlRequest( VirtualInterface.xpnfd_presence_int, request.GetXRL(), SGInfo.ToBase64String(), request, ref xrlo );
            }
            else
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_LOW, "FBServer.SubmitReview: found " + FeedbackDefs.AlternatePresenceDestinationHeaderName + " http header, value: " + url);
                hr = XRLUtil.PostXrlRequestToAlternate(XOService.PresNotification, url, SGInfo.ToBase64String(), request, null, null);
            }

            if (HResult.Failed(hr))
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.SubmitReview: Unexpected failure calling UpdateAffiliation. hr = " + hr);
                Xom.NtEvent( XEvent.Id.FEEDBACK_CODE_6, "FBServer.SubmitReview: Unexpected failure calling UpdateAffiliation. hr = " + hr);
            }

            return hr;
        }
    
        private HResult UpdateProfile(ulong senderPuid, ulong targetPuid, float rating, uint titleId)
        {
            SyncSettingsRequest     request = new SyncSettingsRequest();
            XRLObject2              xrlo = null;            
            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);

            request.TitleId = XOn.XENON_DASH_TITLE_ID;
            request.UserId = targetPuid;
            request.Version = DateTime.UtcNow;
            
            request.Settings = new UserSetting[1];
            
            request.Settings[0] = new UserSetting();
            request.Settings[0].Source = XOn.XSOURCE_DEFAULT;
            request.Settings[0].UserId = targetPuid;
            request.Settings[0].SettingId = ProfileDefs.XPROFILE_GAMERCARD_REP;

            writer.Write(rating);
            request.Settings[0].Value = stream.ToArray();

            // Consider: We may need to call Array.Reverse(request.Settings[0].Value) to fix byte ordering issues here

            HResult hr = XRLUtil.PostXrlRequest( VirtualInterface.profilefd_int, request.GetXRL(), GetHttpAuthData(targetPuid, XOn.XENON_DASH_TITLE_ID), request, ref xrlo );

            if (HResult.Failed(hr))
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.SubmitReview: Unexpected failure calling UpdateProfile. hr = " + hr);
                Xom.NtEvent( XEvent.Id.FEEDBACK_CODE_7, "FBServer.SubmitReview: Unexpected failure calling UpdateProfile. hr = " + hr);
            }
            
            return hr;
        }
        

        public bool IsReusable
        {
            get { return true; }
        }


    } // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\AsAuthData.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "askdc.h"

CAsADHandler::CAsADHandler(CASProvider *pASProvider) :
    m_pASProvider(pASProvider)
{
    
}

void log54364(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

KERBERR __stdcall
CAsADHandler::AddToTicket(
    IN  IKerbRequest                *piReq,
    OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
    OUT PKERB_EXT_ERROR              pExtendedError)
{
    XOMASSERT( piReq );
    XOMASSERT( ppAuthData );
    XOMASSERT( pExtendedError );

    // validate all parameters    
    if ( NULL == piReq || NULL == ppAuthData || NULL == pExtendedError )
    {
		log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - (%s:%d) AddToTicket: invalid parameter.", __FILE__, __LINE__); 
        XomNtEvent(XEVENT_ASKDC_BAD_PARAMETER, "(%s:%d) AddToTicket: invalid parameter.", __FILE__, __LINE__);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) AddToTicket: invalid parameter.", __FILE__, __LINE__);
        return KDC_ERR_SVC_UNAVAILABLE;
    }

    // only proceed for requests in the PASSPORT.NET realm
    const KERB_KDC_REQUEST *pKdcReq = piReq->GetKdcRequest();
    if ( _stricmp( pKdcReq->request_body.realm, PASSPORT_KERBEROS_REALM ) )
    {
		log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - KDC_ERR_NONE");
        return KDC_ERR_NONE;
    }
    
    IKDCTimeStamp *piTimeStamp = NULL;
    CASPrincipal *piPrinc = NULL;
    LPCWSTR pwszName = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    LARGE_INTEGER liClientTime;

    g_pASProvider->ConfigReadLock();
    
    // find the PA handler for the encrypted timestamp
    status = piReq->GetPAHandler(IID_IKDCTimeStamp, (PVOID*)&piTimeStamp);
    if ( !NT_SUCCESS(status) || NULL == piTimeStamp )
    {
		log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - (%s:%d) AddToTicket: failed to acquire valid IKDCTimeStamp interface.", __FILE__, __LINE__);
        XomNtEvent(XEVENT_ASKDC_BAD_PARAMETER_1, "(%s:%d) AddToTicket: failed to acquire valid IKDCTimeStamp interface.", __FILE__, __LINE__);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) AddToTicket: failed to acquire valid IKDCTimeStamp interface.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    liClientTime = piTimeStamp->GetTimeStamp();

    piPrinc = (CASPrincipal*) piReq->GetIPrincClient();
    
    XOMASSERT( piPrinc );
    if ( NULL == piPrinc )
    {
		log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - (%s:%d) AddToTicket: client principal missing from IKerbRequest.", __FILE__, __LINE__);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) AddToTicket: client principal missing from IKerbRequest.", __FILE__, __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    
    pwszName = piPrinc->GetGamerTag();

    // Add the principal to the DoS cache
    if ( g_pASProvider->CheckForDos() && !piPrinc->IsPassport() )
    {
        ASkdcAsDosCachePrincipal(pwszName, piPrinc, liClientTime);
    }

    // If this principal was retrieved from the DoS cache and its
    // cached auth time matches the timestamp sent in the encrypted
    // timestamp preauth, then this is a replay.
    if ( liClientTime.QuadPart == piPrinc->GetCachedAuthTime().QuadPart )
    {
        PSOCKADDR_IN pClientAddr = (PSOCKADDR_IN) piReq->GetClientAddress();
        in_addr *pInAddr = &(pClientAddr->sin_addr);
                      
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_REPLAYS, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_REPLAYS_RATE, 1);
        
		log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - (%s:%d) AddToTicket: replay detected.  Client: %s, Name: '%S', timestamp: 0x%016I64X.",
            __FILE__,
            __LINE__,
            inet_ntoa(pClientAddr->sin_addr),
            pwszName,
            liClientTime);
			
        XomNtEvent(XEVENT_ASKDC_DOS_REPLAY,
            "(%s:%d) AddToTicket: replay detected.  Client: %s, Name: '%S', timestamp: 0x%016I64X.",
            __FILE__,
            __LINE__,
            inet_ntoa(pClientAddr->sin_addr),
            pwszName,
            liClientTime);
			
        log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - (%s:%d) AddToTicket: replay detected.  Client: %s, Name: '%S', timestamp: 0x%016I64X.",
            __FILE__,
            __LINE__,
            inet_ntoa(pClientAddr->sin_addr),
            pwszName,
            liClientTime); 
			
        XomTrace(ASkdc, L_ERROR,
            "(%s:%d) AddToTicket: replay detected.  Client: %s, Name: '%S', timestamp: 0x%016I64X.",
            __FILE__,
            __LINE__,
            inet_ntoa(pClientAddr->sin_addr),
            pwszName,
            liClientTime);

		log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - KRB_AP_ERR_REPEAT");
                      
        KerbErr = m_pASProvider->SilentKerbErr(KRB_AP_ERR_REPEAT);
    }
    
Cleanup:    
    g_pASProvider->ConfigReadUnlock();
    
	log54364("c:\\askdc-AsAuthData-cpp.log","AddToTicket - 0x%X", KerbErr);
    return KerbErr;
}


CAsADHandlerFactory::CAsADHandlerFactory(IN CASProvider *pASProvider) :
    m_AsADHandler(pASProvider)
{
}


NTSTATUS
CAsADHandlerFactory::CreateInstance(
    IN  IKerbRequest    *piReq,
    OUT IADHandler      **ppIADHandler)
{
    XOMASSERT( ppIADHandler );
    if ( NULL == ppIADHandler )
    {
		log54364("c:\\askdc-AsAuthData-cpp.log","CreateInstance - STATUS_INVALID_PARAMETER_2");
        return STATUS_INVALID_PARAMETER_2;
    }

    *ppIADHandler = static_cast<IADHandler*>(&m_AsADHandler);
	log54364("c:\\askdc-AsAuthData-cpp.log","CreateInstance - STATUS_SUCCESS");
    return STATUS_SUCCESS;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\XeSchemaUnitTest.cs ===
//-------------------------------------------------
//
//  SubmitComplaint.cs : front door for feedback
//
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Xml;
using System.Text;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.server.feedback 
{
    public class XeSchemaUnitTest : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            HResult                     hr = HResult.S_OK;
            XeSchemaUnitTestRequest     request = null;
            XeSchemaUnitTestResponse    response = null;

            try
            {
                if (!XRLUtil.IsValidXOnlineRequest(ctx.Request, XOService.Feedback))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.FEEDBACK_HACK_5, "XeSchemaUnitTest.ProcessRequest: Request is invalid" );                                        
                }
            
                request = new XeSchemaUnitTestRequest();
                request.SchemaVersion = WireData.GetSchemaVersion(ctx.Request);

                request.ReadFromRequest(ctx.Request);

                CallSource.Check(VirtualInterface.fbserver, VirtualInterface.fbserver_int);

                // Build response
                response = new XeSchemaUnitTestResponse();
                response.SchemaVersion = request.SchemaVersion;

                // Copy the request info into the response.
                response.v1_uint_field = request.v1_uint_field;
                response.v1_ulong_field = request.v1_ulong_field;
                response.v2_string_field_length = request.v2_string_field_length;
                response.v2_string_field = request.v2_string_field;
                if (request.v3_4_complex_field != null)
                {
                    response.v3_4_complex_field = new XeSchemaUnitTestComplexType();
                    response.v3_4_complex_field.v3_ushort_field = request.v3_4_complex_field.v3_ushort_field;
                    response.v3_4_complex_field.v4_int_field = request.v3_4_complex_field.v4_int_field;
                }
                    
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, HResult.S_OK);
                BinaryWriter writer = new BinaryWriter(ctx.Response.OutputStream);
                response.WriteToResponse(writer, (UTF8Encoding) ctx.Response.ContentEncoding);

                // Log line gets written in the finally block                    
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "XeSchemaUnitTest.ProcessRequest: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message );
                hr = e.HResult;
                
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, hr);
            }            
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.XeSchemaUnitTest: Unexpected failure, msg=" + e.Message );
                hr = HResult.XONLINE_E_FEEDBACK_ERROR;

                throw;
            }
            finally
            {
                if (null != request)
                {
                    // LineType|LineDesc|SendPUID|TargetPUID|TitleID|SubmitComplaintType|Nickname(optional)
                    Xom.Log(XomAreaName.feedbacklog, "XeSchemaUnitTest|"
                        + "|" + request.v1_uint_field.ToString("d")
                        + "|" + request.v1_ulong_field.ToString("d")
                        + "|" + request.v2_string_field 
                        );
                }
            }                    
        } // end ProcessRequest

        public bool IsReusable
        {
            get { return true; }
        }


    } // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feeds\fd\DataAccess\AccelerationMemCache.cs ===
using System;
using System.Text;
using xonline.common.service;
using xonline.common.config;

namespace xonline.server.reflector.fd
{
    public class AccelerationMemCache : IMemCache
    {
        private Acceleration m_accel;
        private DataChangeNotification m_notificationCallback;
        private DataChangeFailureNotification m_failureCallback;
        
        public AccelerationMemCache()
        {
            m_accel = new Acceleration(Interface.acceleration);
            m_accel.RegisterNotificationHandler(AccelerationNotificationHandler);
            m_accel.RegisterNotificationFailureHandler(AccelerationNotificationFailureHandler);
        }

        public string GetImplementationName()
        {
            return "Acceleration";
        }
        
        public byte[] RequestData(string sKey, Object keyState)
        {
            byte[] rgbValue;
            byte[] rgbKey = keyState as byte[];
            if (rgbKey == null)
            {
                rgbKey = Encoding.ASCII.GetBytes(sKey);
            }
            m_accel.Query(rgbKey, out rgbValue);
            return rgbValue;
        }
        
        public byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates)
        {
            byte[][] rgValues;
            byte[][] rgbKeys = new byte[rgKeys.Length][];
            uint[] rgValidSeconds;
            for (int iKey = 0; iKey < rgbKeys.Length; iKey++)
            {
                rgbKeys[iKey] = rgKeyStates[iKey] as byte[];
                if (rgbKeys[iKey] == null)
                {
                    rgbKeys[iKey] = Encoding.ASCII.GetBytes(rgKeys[iKey]);
                }
            }
            m_accel.Query(rgbKeys, out rgValues, out rgValidSeconds);
            return rgValues;
        }
        
        public void PublishData(string sKey, byte[] rgbValue, Object keyState)
        {
            byte[] rgbKey = keyState as byte[];
            if (rgbKey == null)
            {
                rgbKey = Encoding.ASCII.GetBytes(sKey);
            }
            m_accel.SetData(rgbKey, rgbValue, 0, 0);
        }
        
        public void RegisterNotificationHandler(DataChangeNotification notificationCallback)
        {
            m_notificationCallback += notificationCallback;
        }
        
        public void RegisterNotificationFailureHandler(DataChangeFailureNotification failureCallback)
        {
            m_failureCallback += failureCallback;
        }
        
        public void UnregisterHandlers()
        {
            m_notificationCallback = null;
            m_failureCallback = null;
        }

        public void AccelerationNotificationHandler(byte[][] keys)
        {
            if (m_notificationCallback == null)
            {
                return;
            }
            
            string[] rgsKeys = new string[keys.Length];
            for (int iKey = 0; iKey < rgsKeys.Length; iKey++)
            {
                rgsKeys[iKey] = Encoding.ASCII.GetString(keys[iKey]);
            }
            m_notificationCallback(rgsKeys, keys);
        }

        public void AccelerationNotificationFailureHandler()
        {
            if (m_failureCallback == null)
            {
                return;
            }
            
            m_failureCallback();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\test\dvt\fbclassic.cs ===
using System;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Threading;
using System.Net;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Utilities;

using xonline.common.diagnostics;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.stfutil;



namespace xonline.server.feedback.test.dvt 
{
    [TestGroup, DVT]
    public class FeedbackClassic : TestNode
    {
        public static string GetSGInfoString(uint titleID, ulong userId)
        {
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, userId, titleID, 0, 0);
            return authData.ConstructBase64String();
        }    
        
        public uint SendFeedback( ulong senderPUID, ulong targetPUID, uint titleID, byte feedbackType, string text )
        {
            FeedbackRequest  request = new FeedbackRequest();
            MemoryStream     stream = new MemoryStream();
            BinaryWriter     writer = new BinaryWriter(stream);
            byte[]           respBuf;

            request.ulSendPUID = senderPUID;
            request.ulTargetPUID = targetPUID;
            request.uiTitleID = titleID;
            request.bFeedbackType = feedbackType;
            request.szText = text;

            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleID;
            slot.userPuid0 = senderPUID;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Feedback, false, request.GetXRL(), stream.ToArray(), out respBuf);

            return hr;
        }
        
        public uint SendReview( ulong senderPUID, ulong targetPUID, uint titleID, uint reviewType, ulong context)
        {
            SubmitReviewRequest  request = new SubmitReviewRequest();
            MemoryStream         stream = new MemoryStream();
            BinaryWriter         writer = new BinaryWriter(stream);
            byte[]               respBuf;

            request.senderPUID = senderPUID;
            request.targetPUID = targetPUID;
            request.titleID = titleID;
            request.type = reviewType;
            request.context = context;

            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleID;
            slot.userPuid0 = senderPUID;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Feedback, false, request.GetXRL(), stream.ToArray(), out respBuf);

            return hr;
        
        }
        
        public uint SendComplaint( ulong senderPUID, ulong targetPUID, uint titleID, uint complaintType, ulong context)
        {
            SubmitComplaintRequest  request = new SubmitComplaintRequest();
            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);
            byte[]                  respBuf;

            request.senderPUID = senderPUID;
            request.targetPUID = targetPUID;
            request.titleID = titleID;
            request.type = complaintType;
            request.context = context;

            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleID;
            slot.userPuid0 = senderPUID;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Feedback, false, request.GetXRL(), stream.ToArray(), out respBuf);

            return hr;        
        }
        
        public uint GetAggReviews( ulong senderPUID, ulong targetPUID, uint titleID, out GetAggregateReviewsReply reply)
        {
            GetAggregateReviewsRequest  request = new GetAggregateReviewsRequest();
            MemoryStream                stream = new MemoryStream();
            BinaryWriter                writer = new BinaryWriter(stream);
            BinaryReader                reader;
            byte[]                      respBuf;

            request.targetPUID = targetPUID;

            reply = null;
            
            request.WriteToResponse(writer, (UTF8Encoding)Encoding.UTF8);

            CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
            slot.titleId = titleID;
            slot.userPuid0 = senderPUID;
            
            uint hr = StfXrlUtil.PostXrlRequest(ref slot, XOService.Feedback, false, request.GetXRL(), stream.ToArray(), out respBuf);

            if (HResult.Succeeded(hr))
            {
                reply = new GetAggregateReviewsReply();
                reader = new BinaryReader(new MemoryStream(respBuf));
                reply.ReadFromRequest(reader, (UTF8Encoding)Encoding.UTF8, respBuf.Length, null);
            }
            
            return hr;        
        }
        

        [TestCase]
        public void TestBasics()
        {         
            uint    hr;
            
            // Test v1 Feedback
            hr = SendFeedback(0x0009FFFFFFFFFFFF, 0x0009FFFFFFFFFFFE, XOn.XENON_DASH_TITLE_ID, (byte)FeedbackDefs.FeedbackType.NegHarassment, "Feedback String");

            if (HResult.Failed(hr))
            {
                throw new Exception("SendFeedback failed with hr = " + hr.ToString("x8"));
            }

            // Test Review
            hr = SendReview(0x0009FFFFFFFFFFFF, 0x0009FFFFFFFFFFFE, XOn.XENON_DASH_TITLE_ID, (uint)FeedbackDefs.PlayerReview.AvoidDisruptive, 5);
            
            if (HResult.Failed(hr))
            {
                throw new Exception("SendReview failed with hr = " + hr.ToString("x8"));
            }

            // Test Complaint
            hr = SendComplaint(0x0009FFFFFFFFFFFF, 0x0009FFFFFFFFFFFE, XOn.XENON_DASH_TITLE_ID, (uint)FeedbackDefs.ComplaintType.OffensiveTextMessage, 5);
            
            if (HResult.Failed(hr))
            {
                throw new Exception("SendReview failed with hr = " + hr.ToString("x8"));
            }
            
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\fd\submitcomplaint.cs ===
//-------------------------------------------------
//
//  SubmitComplaint.cs : front door for feedback
//
//-------------------------------------------------

using System;
using System.IO;
using System.Web;
using System.Xml;
using System.Text;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;


namespace xonline.server.feedback 
{
    public class SubmitComplaint : IHttpHandler
    {
        //-----------------------------------------------------
        // ProcessRequest (IHttpHandler)
        //      
        //      the main entry point for http requests.
        //
        public void ProcessRequest(HttpContext ctx)
        {
            HResult                 hr = HResult.S_OK;
            SubmitComplaintRequest  complaintRequest = null;

            try
            {
                if (!XRLUtil.IsValidXOnlineRequest(ctx.Request, XOService.Feedback))
                {
                    throw new XRLException(HResult.XONLINE_E_INVALID_REQUEST, XEvent.Id.FEEDBACK_HACK_5, "SubmitComplaint.ProcessRequest: Request is invalid" );                                        
                }

                // Keep track of total incoming requests
                FeedbackCounters.Current.SubmitComplaintTotal.Increment();            
                FeedbackCounters.Current.SubmitComplaintRate.Increment();            
            
                complaintRequest = new SubmitComplaintRequest();
                complaintRequest.ReadFromRequest(ctx.Request);

                CallSource.Check(VirtualInterface.fbserver, VirtualInterface.fbserver_int);

                //--------------------------
                // Do some param checking...
                if (complaintRequest.targetPUID == 0)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_NULL_TARGET, XEvent.Id.FEEDBACK_HACK_6, "SubmitComplaint.ProcessRequest: null targetPUID. TitleID=0x" + ((int)complaintRequest.titleID).ToString("x") + ",SenderPUID=0x" + complaintRequest.senderPUID.ToString("x") + ",Type=0x" + complaintRequest.type.ToString("x") + ",TargetPUID=0x" + complaintRequest.targetPUID.ToString("x") );                
                }
                if (complaintRequest.targetPUID == complaintRequest.senderPUID)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_NULL_TARGET, XEvent.Id.FEEDBACK_HACK_7, "SubmitComplaint.ProcessRequest: senderPUID == targetPUID. TitleID=0x" + ((int)complaintRequest.titleID).ToString("x") + ",SenderPUID=0x" + complaintRequest.senderPUID.ToString("x") + ",Type=0x" + complaintRequest.type.ToString("x") + ",TargetPUID=0x" + complaintRequest.targetPUID.ToString("x") );                
                }
                if (!SGInfo.Current.IsUserPresent( complaintRequest.senderPUID ))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_USER_NOT_PRESENT, XEvent.Id.FEEDBACK_HACK_8, "SubmitComplaint.ProcessRequest: senderPUID is not present in SGINFO. TitleID=0x" + ((int)complaintRequest.titleID).ToString("x") + ",SenderPUID=0x" + complaintRequest.senderPUID.ToString("x") + ",Type=0x" + complaintRequest.type.ToString("x") + ",TargetPUID=0x" + complaintRequest.targetPUID.ToString("x") );                
                }                
                if (complaintRequest.type >= FeedbackApp.MaxComplaintType)
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_BAD_TYPE, XEvent.Id.FEEDBACK_HACK_9, "SubmitComplaint.ProcessRequest: Bad Review Type. TitleID=0x" + ((int)complaintRequest.titleID).ToString("x") + ",SenderPUID=0x" + complaintRequest.senderPUID.ToString("x") + ",Type=0x" + complaintRequest.type.ToString("x") + ",TargetPUID=0x" + complaintRequest.targetPUID.ToString("x") );
                }

                // Talk to the database to record this player review
                WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
                ws.StoredProc = "dbo.p_feedback_submit_complaint";
                int iBucket = ws.SetHashVal(complaintRequest.targetPUID);
                
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", complaintRequest.senderPUID);
                ws.AddParameter(ParamType.INPUT, "@bi_target_puid", complaintRequest.targetPUID);
                ws.AddParameter(ParamType.INPUT, "@i_title_id", complaintRequest.titleID);
                ws.AddParameter(ParamType.INPUT, "@i_type", complaintRequest.type);
                ws.AddParameter(ParamType.INPUT, "@bi_context", complaintRequest.context);
                ws.AddParameter(ParamType.INPUT, "@dt_submitted", DateTime.UtcNow);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", iBucket);
                
                ws.ExecuteNonQuery();
                
                hr = (uint)ws.GetIntParameter("@RETVAL");
                
                if(HResult.Failed(hr))
                {
                    throw new XRLException(HResult.XONLINE_E_FEEDBACK_DATABASE_ERROR, XEvent.Id.FEEDBACK_CODE_2, "SubmitComplaint.ProcessRequest: Database error: hr = " + hr + ", TitleID=0x" + ((int)complaintRequest.titleID).ToString("x") + ",SenderPUID=0x" + complaintRequest.senderPUID.ToString("x") + ",Type=0x" + complaintRequest.type.ToString("x") + ",TargetPUID=0x" + complaintRequest.targetPUID.ToString("x") );                    
                }
                
                // Log line gets written in the finally block                    
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "SubmitComplaint.ProcessRequest: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message );
                hr = e.HResult;
                
                throw;
            }            
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.feedbackTrace, LogLevel.L_ERROR, "FBServer.SubmitComplaint: Unexpected failure, msg=" + e.Message );
                hr = HResult.XONLINE_E_FEEDBACK_SUBMIT_COMPLAINT_ERROR;

                throw;
            }
            finally
            {
                if (null != complaintRequest)
                {
                    // LineType|LineDesc|SendPUID|TargetPUID|TitleID|SubmitComplaintType|Nickname(optional)
                    Xom.Log(XomAreaName.feedbacklog, "804|SubmitComplaint|"
                        + "|" + ((long) complaintRequest.senderPUID).ToString("d")
                        + "|" + ((long) complaintRequest.targetPUID).ToString("d")
                        + "|" + ((int) complaintRequest.titleID).ToString("d") 
                        + "|" + complaintRequest.type.ToString("d") 
                        + "|" + ((long) complaintRequest.context).ToString("d")
                        );
                }
            }                    

            if (HResult.Succeeded(hr))
            {
                // We've successfully recorded this SubmitComplaint request
                FeedbackCounters.Current.SubmitComplaintSuccessTotal.Increment();            
                FeedbackCounters.Current.SubmitComplaintSuccessRate.Increment();            
            }
            else
            {
                // We've failed to process this SubmitComplaint request
                FeedbackCounters.Current.SubmitComplaintFailedTotal.Increment();            
                FeedbackCounters.Current.SubmitComplaintFailedRate.Increment();            
            }
            
            if( null != complaintRequest )
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, complaintRequest.titleID, hr);
            }
            else
            {
                XRLUtil.SetXRLResponse(ctx.Response, XOService.Feedback, hr);
            }
        } // end ProcessRequest

        public bool IsReusable
        {
            get { return true; }
        }


    } // end class 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\AsDos.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "askdc.h"
#include "hashfn.h"

using namespace HashFn;

void logtof54(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

// Use the same heap as the KDC for allocating memory
static PVOID (WINAPI *KdcAllocMemory)(IN size_t cSize) = 0;
static void (WINAPI *KdcFreeMemory)(IN PVOID pAddress) = 0;


// This code is a slight variation on dinartem's hash code for
// the security gateways in sgstate.cpp.  Anyone wishing to reuse
// this code should first look at sgstate.cpp.

// ----------------------------------------------------------------------------
// CHashTable
// ----------------------------------------------------------------------------

#ifndef INLINE
#define INLINE __forceinline
#endif

typedef DWORD (*PFNHCOMPUTE)(LIST_ENTRY * ple);
typedef BOOL  (*PFNHCOMPARE)(LIST_ENTRY * ple1, void * ple2);

class CHashTable
{

public:
    
    INLINE          CHashTable() { _ple = NULL; }
    INLINE         ~CHashTable() { Term(); }
    BOOL            Init(UINT cBucket, PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare);
    void            Term();
    LIST_ENTRY *    Lookup(LIST_ENTRY * pleLok);
    void            Insert(LIST_ENTRY * pleIns);
    void            Delete(LIST_ENTRY * pleDel);
    INLINE UINT     GetCount() const                { return(_cEnt); }
    INLINE UINT     GetBucketCount() const          { return(_cBucket); }

protected:

    LIST_ENTRY *    _ple;               // Vector of hash buckets
    UINT            _cBucket;           // Number of buckets in the table
    UINT            _cEnt;              // Number of entries in the table
    PFNHCOMPUTE     _pfnCompute;        // Function to compute a 32-bit hash from an entry
    PFNHCOMPARE     _pfnCompare;        // Function to compare two entries for equality

};

#define DECLARE_NEW_DELETE(class) \
   INLINE void * operator new(size_t cb) { return(KdcAllocMemory(cb)); } \
   INLINE void operator delete(void * pv) { KdcFreeMemory(pv); }

#define DECLARE_HASH_TABLE(_type) \
    DWORD Kdc##_type##HashCompute(C##_type *); \
    BOOL  Kdc##_type##HashCompare(C##_type *, C##_type *); \
    class C##_type##Hash : public CHashTable { public: DECLARE_NEW_DELETE(C##_type); \
    INLINE BOOL Init(UINT cEnt) { return(CHashTable::Init(cEnt, (PFNHCOMPUTE)Kdc##_type##HashCompute, (PFNHCOMPARE)Kdc##_type##HashCompare)); } \
    INLINE C##_type * Lookup(C##_type * pvEnt) { return((C##_type *)CHashTable::Lookup((LIST_ENTRY *)pvEnt)); } \
    INLINE void  Insert(C##_type * pvEnt) { CHashTable::Insert((LIST_ENTRY *)pvEnt); } \
    INLINE void  Delete(C##_type * pvEnt) { CHashTable::Delete((LIST_ENTRY *)pvEnt); } \
    }; \


UINT g_iHashTableOverheadPct = 100;   // percent overhead to add to hash tables

BOOL CHashTable::Init(UINT cEnt, PFNHCOMPUTE pfnCompute, PFNHCOMPARE pfnCompare)
{
    // Base the number of buckets we allocate on the maximum number of entries, scaled
    // up by a constant factor and then rounded up to the next highest prime number.
    // The idea is to keep hash collisions to a minimum at the cost of additional memory.

    XOMASSERT(g_iHashTableOverheadPct > 0);
    UINT cBucket = cEnt * (100 + g_iHashTableOverheadPct) / 100;

    static DWORD s_adwPrimes[] = { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

    DWORD * pdwPrime = s_adwPrimes;
    for (; cBucket > *pdwPrime; pdwPrime++) ;
    cBucket = *pdwPrime;

    _ple = (LIST_ENTRY *)KdcAllocMemory(cBucket * sizeof(LIST_ENTRY));

    if (_ple == NULL)
    {
        return(FALSE);
    }
    
    ZeroMemory(_ple, cBucket * sizeof(LIST_ENTRY));

    _cBucket    = cBucket;
    _cEnt       = 0;
    _pfnCompute = pfnCompute;
    _pfnCompare = pfnCompare;

    for (LIST_ENTRY * ple = _ple; cBucket > 0; --cBucket, ++ple)
    {
        InitializeListHead(ple);
    }

    return(TRUE);
}

void CHashTable::Term()
{
    KdcFreeMemory(_ple);
    _ple = NULL;
}

LIST_ENTRY * CHashTable::Lookup(LIST_ENTRY * pleLok)
{
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleLok) % _cBucket];
    
    for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        if (_pfnCompare(pleLok, ple))
        {
            return(ple);
        }
    }

    return(NULL);
}

void CHashTable::Insert(LIST_ENTRY * pleIns)
{
    XOMASSERT( NULL == pleIns->Flink );
    LIST_ENTRY * pleHead = &_ple[_pfnCompute(pleIns) % _cBucket];
    InsertTailList(pleHead, pleIns);
    _cEnt += 1;
}

void CHashTable::Delete(LIST_ENTRY * pleDel)
{
    XOMASSERT( pleDel->Flink );
    XOMASSERT( pleDel == Lookup(pleDel) );
    XOMASSERT( Lookup(pleDel) );
    RemoveEntryList(pleDel);
    pleDel->Flink = NULL;

    XOMASSERT(_cEnt > 0);
    _cEnt -= 1;
}

// ----------------------------------------------------------------------------
// CAsDos
// ----------------------------------------------------------------------------
struct CAsDos
{
    LIST_ENTRY      Hash;
    WCHAR           Name[XONLINE_GAMERTAG_SIZE];
    CASPrincipal    *piPrinc;
    LARGE_INTEGER   LastLookup;
    LARGE_INTEGER   LastAuthTime;
    LIST_ENTRY      Lru;
};

    
void AsDosClearPrincipal(CAsDos *pAsDos)
{
    XOMASSERT( pAsDos );
    if ( NULL != pAsDos && NULL != pAsDos->piPrinc )
    {
        pAsDos->piPrinc->Release();
        pAsDos->piPrinc = NULL;
    }
}

void AsDosSetPrincipal(CAsDos *pAsDos, CASPrincipal *piPrinc)
{
    XOMASSERT( NULL != pAsDos && NULL == pAsDos->piPrinc );
    if ( NULL != pAsDos )
    {
        AsDosClearPrincipal(pAsDos);
        if ( NULL != piPrinc )
        {
            XOMASSERT( piPrinc->m_dwRefCount >= 1 );
            piPrinc->AddRef();
        }
        pAsDos->piPrinc = piPrinc;
    }
}

DECLARE_HASH_TABLE(AsDos);

CAsDosHash   *g_pAsDosHash = NULL; // Hash table mapping PUID to CAsDos
CAsDos       *g_pAsDos = NULL;     // Vector of all CAsDos structures
UINT          g_cAsDos = 0;        // Number of CAsDos structures allocated
UINT          g_cAsDosInUse = 0;   // Number of CAsDos structures in use
LIST_ENTRY    g_leAsDosLru = {0};  // Queue of CAsDos structures in use in LRU order
CRITICAL_SECTION g_cs;             // Synchronizes access to AsDos data
LONGLONG      g_qwCacheTime = (LONGLONG) 10000 * 5000;  // Time a client principal is cached before going back to UODB
LONGLONG      g_qwCacheHitInterval = (LONGLONG) 10000 * 1000; // Minimum time that must elapse between cache hits

DWORD KdcAsDosHashCompute(CAsDos *pAsDos)
{
    XOMASSERT( pAsDos );
    XOMASSERT( lstrlenW(pAsDos->Name) <= XONLINE_MAX_GAMERTAG_LENGTH );
    return HashStringNoCase( pAsDos->Name );
}

BOOL KdcAsDosHashCompare(CAsDos *pAsDos1, CAsDos *pAsDos2)
{
    XOMASSERT( pAsDos1 );
    XOMASSERT( pAsDos2 );
    return ( 0 == _wcsnicmp(pAsDos1->Name, pAsDos2->Name, XONLINE_MAX_GAMERTAG_LENGTH) );
}

BOOL ASkdcAsDosInit()
{
    XOMASSERT( NULL == KdcAllocMemory );
    XOMASSERT( NULL == KdcFreeMemory );
    XOMASSERT( g_pASProvider );
    XOMASSERT( g_pASProvider->KdcAllocMemory );
    XOMASSERT( g_pASProvider->KdcFreeMemory );
    XOMASSERT( NULL == g_pAsDos );
    XOMASSERT( 0 == g_cAsDos );
    XOMASSERT( 0 == g_cAsDosInUse );
    XOMASSERT( NULL == g_pAsDosHash );
    XOMASSERT( NULL == g_leAsDosLru.Flink );
    XOMASSERT( NULL == g_leAsDosLru.Blink );
    KdcAllocMemory = g_pASProvider->KdcAllocMemory;
    KdcFreeMemory = g_pASProvider->KdcFreeMemory;
    InitializeCriticalSection(&g_cs);
    InitializeListHead(&g_leAsDosLru);
    return TRUE;
}

CAsDos * ASkdcAsDosFromLruLink(LIST_ENTRY *ple)
{
    return (CAsDos*)(((BYTE*)ple) - offsetof(CAsDos, Lru));
}


void ASkdcAsDosTerm()
{
    XOMASSERT( KdcAllocMemory );
    XOMASSERT( KdcFreeMemory );

    EnterCriticalSection(&g_cs);
    
    // release any lingering principal structs
    while ( !IsListEmpty(&g_leAsDosLru) )
    {
        LIST_ENTRY *ple = RemoveHeadList(&g_leAsDosLru);
        CAsDos *pAsDos = ASkdcAsDosFromLruLink(ple);
        if ( pAsDos->piPrinc )
        {
            pAsDos->piPrinc->Release();
            pAsDos->piPrinc = NULL;
        }
    }
        
    if ( g_pAsDos )
    {
        KdcFreeMemory(g_pAsDos);
        g_pAsDos = NULL;
    }

    delete g_pAsDosHash;
    g_pAsDosHash = NULL;
    
    g_cAsDos = 0;
    g_cAsDosInUse = 0;
    ZeroMemory(&g_leAsDosLru, sizeof(g_leAsDosLru));

    LeaveCriticalSection(&g_cs);
    
    DeleteCriticalSection(&g_cs);
    KdcAllocMemory = NULL;
    KdcFreeMemory = NULL;
}

BOOL ASkdcAsDosConfig(UINT cAsDos, UINT cCacheMillisecs, UINT cCacheHitIntervalMillisecs)
{
    // set the client cache time
    g_qwCacheTime = (LONGLONG) 10000 * cCacheMillisecs;

    // set the required interval between cache hits
    g_qwCacheHitInterval = (LONGLONG) 10000 * cCacheHitIntervalMillisecs;
    
    // allocate and zero-fill AsDos nodes
    g_pAsDos = (CAsDos *) KdcAllocMemory(cAsDos * sizeof(CAsDos));
    if ( NULL == g_pAsDos )
    {
		logtof54("c:\\askdc-AsDos-cpp.log", "ASkdcAsDosConfig: failed to allocate %d bytes for CAsDos entries.", cAsDos*sizeof(CAsDos));
        XomNtEvent(XEVENT_ASKDC_NO_MEMORY, "ASkdcAsDosConfig: failed to allocate %d bytes for CAsDos entries.", cAsDos*sizeof(CAsDos));
        return FALSE;
    }
    ZeroMemory(g_pAsDos, cAsDos * sizeof(CAsDos));
    
    g_pAsDosHash = new CAsDosHash;
    if ( NULL == g_pAsDosHash || !g_pAsDosHash->Init(cAsDos) )
    {
		logtof54("c:\\askdc-AsDos-cpp.log", "ASkdcAsDosConfig: failed to allocate hash table."); 
        XomNtEvent(XEVENT_ASKDC_NO_MEMORY_1, "ASkdcAsDosConfig: failed to allocate hash table.");
        return FALSE;
    }

    g_cAsDos = cAsDos;
    g_cAsDosInUse = 0;

	logtof54("c:\\askdc-AsDos-cpp.log","ASkdcAsDosConfig: configured AS DOS table with %d entries in %d hash buckets.", g_cAsDos, g_pAsDosHash->GetBucketCount());
    XomTrace(ASkdc, L_NORMAL, "ASkdcAsDosConfig: configured AS DOS table with %d entries in %d hash buckets.", g_cAsDos, g_pAsDosHash->GetBucketCount());
    
    return TRUE;
}

CAsDos * ASkdcAsDosLookup(LPCWSTR wszName)
{
    XOMASSERT( wszName );
    XOMASSERT( lstrlenW(wszName) <= XONLINE_MAX_GAMERTAG_LENGTH );
    
    CAsDos AsDos;
    lstrcpynW(AsDos.Name, wszName, XONLINE_GAMERTAG_SIZE);
    return g_pAsDosHash->Lookup(&AsDos);
}

CAsDos *ASkdcAsDosAlloc(LPCWSTR wszName)
{
    CAsDos *pAsDos = NULL;

    if ( g_cAsDosInUse < g_cAsDos )
    {
        pAsDos = &g_pAsDos[g_cAsDosInUse++];
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_ENTRIES_IN_USE, 1);
        XOMASSERT( NULL == pAsDos->piPrinc );
    }
    else if ( IsListEmpty(&g_leAsDosLru) )
    {
        // this should never happen 
        XOMASSERT(0);
		logtof54("c:\\askdc-AsDos-cpp.log","ASkdcAsDosAlloc: all DoS ache entries currently allocated.  Increase DoS.NumDosEntries in ASKDC.INI higher than %d.", g_cAsDos);

        XomNtEvent(XEVENT_ASKDC_DOS_CACHE_TOO_SMALL, "ASkdcAsDosAlloc: all DoS ache entries currently allocated.  Increase DoS.NumDosEntries in ASKDC.INI higher than %d.", g_cAsDos);
        return NULL;
    }
    else
    {
        LIST_ENTRY *pleLru = RemoveHeadList(&g_leAsDosLru);
        pAsDos = ASkdcAsDosFromLruLink(pleLru);
        g_pAsDosHash->Delete(pAsDos);
        AsDosClearPrincipal(pAsDos);

        // enabling this will spam the event log under stress conditions
        LARGE_INTEGER liNow;
        GetSystemTimeAsFileTime((LPFILETIME)&liNow);
        if ( pAsDos->LastLookup.QuadPart + g_qwCacheTime > liNow.QuadPart )
        {
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_ALLOC_UNEXPIRED, 1);
			logtof54("c:\\askdc-AsDos-cpp.log","ASkdcAsDosAlloc: allocating unexpired DoS cache entry.  Increase DoS.NumDosEntries in ASKDC.INI higher than %d.", g_cAsDos);

            XomNtEvent(XEVENT_ASKDC_DOS_CACHE_TOO_SMALL_1, "ASkdcAsDosAlloc: allocating unexpired DoS cache entry.  Increase DoS.NumDosEntries in ASKDC.INI higher than %d.", g_cAsDos);
        }
    }

    pAsDos->Hash.Flink = NULL;
    pAsDos->Lru.Flink = NULL;

    lstrcpynW(pAsDos->Name, wszName, XONLINE_GAMERTAG_SIZE);
    XOMASSERT( NULL == pAsDos->piPrinc );
    pAsDos->LastLookup.QuadPart = 0;
    pAsDos->LastAuthTime.QuadPart = 0;
    g_pAsDosHash->Insert(pAsDos);
    return pAsDos;
}

BOOL ASkdcAsDosGetPrincipal(
    IN  IKerbRequest *piReq, 
    IN  LPCWSTR wszName,
    OUT BOOL *pbCacheHitTooSoon,
    OUT CASPrincipal **piClientPrinc)
{
    XOMASSERT( piReq );
    XOMASSERT( wszName );
    XOMASSERT( pbCacheHitTooSoon );
    XOMASSERT( piClientPrinc );
    
    BOOL bFound = FALSE;
    BOOL bCacheHitTooSoon = FALSE;
    CASPrincipal *piPrinc = NULL;
    
    EnterCriticalSection(&g_cs);
    
    CAsDos *pAsDos = ASkdcAsDosLookup(wszName);
    if ( pAsDos )
    {
        LARGE_INTEGER liNow;

        // remove from the LRU list
        RemoveEntryList(&pAsDos->Lru);
        pAsDos->Lru.Flink = NULL;
        
        GetSystemTimeAsFileTime((LPFILETIME)&liNow);

        // If fewer than n seconds (default 30) have elapsed since the
        // last lookup for this principal, return the one from the cache.
        // Otherwise, the cache entry for this principal can be aged out
        // and the principal will be refetched from the UODB.
        if ( pAsDos->LastLookup.QuadPart + g_qwCacheTime > liNow.QuadPart )
        {
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT, 1);
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_RATE, 1);
        
            bFound = TRUE;

            // DoS check:
            // Real Xbox clients will never send more than 1 AS request per
            // second.  If less than 1 second has elapsed since the last 
            // lookup for this principal, flag a boolean to indicate not 
            // enough time has elapsed.  Later, the LastLookup time will be
            // reset to the current time so at least 1 more second must
            // elapse before we will do any additional work.
            if ( pAsDos->LastLookup.QuadPart + g_qwCacheHitInterval > liNow.QuadPart )
            {
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_TOO_SOON, 1);
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_TOO_SOON_RATE, 1);
                bCacheHitTooSoon = TRUE;
            }
        
            piPrinc = pAsDos->piPrinc;

            if ( piPrinc )
            {
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_EXISTS, 1);
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_EXISTS_RATE, 1);
                
                // add a ref since it is being returned
                piPrinc->AddRef();
                XOMASSERT( 2 <= piPrinc->m_dwRefCount );
                
				logtof54("c:\\askdc-AsDos-cpp.log","ASkdcAsDosGetPrincipal: found '%S', returning cached principal.", wszName);

                // Principal exists in UODB and will be returned to the core.
                XomTrace(ASkdc, L_LOW, "ASkdcAsDosGetPrincipal: found '%S', returning cached principal.", wszName);
            }
            else
            {
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_NONEXISTENT, 1);
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_NONEXISTENT_RATE, 1);
            }
            
            // update the last lookup time and reinsert in the LRU list
            pAsDos->LastLookup = liNow;
            InsertTailList(&g_leAsDosLru, &pAsDos->Lru);
        }
        else
        {
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_EXPIRED, 1);
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_DOS_CACHE_HIT_EXPIRED_RATE, 1);
            
            // if there was a principal in UODB for this name, release it
            AsDosClearPrincipal(pAsDos);
            pAsDos->LastLookup.QuadPart = 0;
            pAsDos->LastAuthTime.QuadPart = 0;
            
            // the node is now unused so reinsert it at the head
            InsertHeadList(&g_leAsDosLru, &pAsDos->Lru);
        }
    }
    
    LeaveCriticalSection(&g_cs);

    *pbCacheHitTooSoon = bCacheHitTooSoon;
    *piClientPrinc = piPrinc;
    return bFound;
}


void ASkdcAsDosCachePrincipal(
    IN  LPCWSTR wszName, 
    IN  CASPrincipal *piPrinc, 
    IN  LARGE_INTEGER liAuthTime)
{
    CAsDos *pAsDos = NULL;
    
    EnterCriticalSection(&g_cs);

    pAsDos = ASkdcAsDosLookup(wszName);
    if ( pAsDos )
    {
        AsDosClearPrincipal(pAsDos);
        RemoveEntryList(&pAsDos->Lru);
        pAsDos->Lru.Flink = NULL;
    }
    else
    {
        pAsDos = ASkdcAsDosAlloc(wszName);
        XOMASSERT( pAsDos );
        if ( NULL == pAsDos )
        {
			logtof54("c:\\askdc-AsDos-cpp.log","ASkdcAsDosCachePrincipal: unable to allocate DoS cache entry. '%S' not added to DoS cache.", wszName);
            XomTrace(ASkdc, L_HIGH, "ASkdcAsDosCachePrincipal: unable to allocate DoS cache entry. '%S' not added to DoS cache.", wszName);
            goto Cleanup;
        }
        XOMASSERT( NULL == pAsDos->Lru.Flink );
    }
    

    AsDosSetPrincipal(pAsDos, piPrinc);
    XOMASSERT( 0 == _wcsnicmp(pAsDos->Name, wszName, XONLINE_MAX_GAMERTAG_LENGTH) );

    pAsDos->LastAuthTime = liAuthTime;
    GetSystemTimeAsFileTime((LPFILETIME)&pAsDos->LastLookup);

    InsertTailList(&g_leAsDosLru, &pAsDos->Lru);

Cleanup:    
    LeaveCriticalSection(&g_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\feedback\test\dvt\fbtest.cs ===
using System;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Threading;
using System.Net;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Feedback;
using ServerTestFramework.Utilities;
using xonline.common.config;

using xonline.common.diagnostics;
using xonline.common.service;


namespace xonline.server.feedback.test.dvt 
{
    [TestGroup, DVT]
    public class Feedback : TestNode
    {
        public static string GetSGInfoString(uint titleId, ulong userId)
        {
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, userId, titleId, 0, 0);
            return authData.ConstructBase64String();
        }    
        
        public uint SendFeedback( ulong senderPUID, ulong targetPUID, uint titleID, byte feedbackType, string text )
        {
            XrlFeedback     request = new XrlFeedback();
            uint            hr = HResult.S_OK;

            request.FeedbackType = feedbackType;
            request.SenderPuid = senderPUID;
            request.TargetPuid= targetPUID;
            request.TitleID = titleID;

            if ( text != null )
            {
                request.Nickname = text;
                request.NicknameLen = (byte) text.Length;
            }
            else
            {
                request.Nickname = "";
                request.NicknameLen = 0;
            }

            if (!request.Execute())
            {
                // log failure seperately?
                hr = HResult.E_FAIL;
            }

            return hr;
        }
        
        public uint SendReview( ulong senderPUID, ulong targetPUID, uint titleID, uint reviewType, ulong context)
        {
            SubmitReview        request = new SubmitReview();
            uint                hr = HResult.S_OK;

            request.type        = reviewType;
            request.senderPUID  = senderPUID;
            request.targetPUID  = targetPUID;
            request.titleID     = titleID;
            request.context     = context;

            if (null == request.Execute())
            {
                // log failure seperately?
                hr = HResult.E_FAIL;
            }

            return hr;
        
        }
        
        public uint SendComplaint( ulong senderPUID, ulong targetPUID, uint titleID, uint complaintType, ulong context)
        {
            SubmitComplaintRequest request = new SubmitComplaintRequest();
            uint                hr = HResult.S_OK;

            request.type        = complaintType;
            request.senderPUID  = senderPUID;
            request.targetPUID  = targetPUID;
            request.titleID     = titleID;
            request.context     = context;

            if (null == request.Execute())
            {
                // log failure seperately?
                hr = HResult.E_FAIL;
            }

            return hr;        
        }
        
        public uint GetAggReviews( ulong senderPUID, ulong targetPUID, uint titleID, out GetAggregateReviewsReply reply)
        {
            GetAggregateReviewsRequest  request = new GetAggregateReviewsRequest();
            uint                hr = HResult.S_OK;
            
            request.targetPUID = targetPUID;
            
            reply = request.Execute();

            if (null == reply)
            {
                // log failure seperately?
                hr = HResult.E_FAIL;
            }
            
            return hr;        
        }
        

        [TestCase]
        public void TestBasics()
        {
            FriendsCommon fc = new FriendsCommon();

            PNUser          user1    = fc.CreateUser( false );
            PNUser          user2    = fc.CreateUser( false );
            uint            hr;

            // Create a xenon xbox client
            PNXbox xbox1 = new PNXbox(XOn.XENON_DASH_TITLE_ID, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK, true);
            fc.LogonUser(user1, xbox1);

            // Create a xenon xbox client
            PNXbox xbox2 = new PNXbox(XOn.XENON_DASH_TITLE_ID, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK, true);
            fc.LogonUser(user2, xbox2);

            
            // Test v1 Feedback
            hr = SendFeedback(user1.UserId, user2.UserId, XOn.XENON_DASH_TITLE_ID, 3 /*FeedbackDefs.FeedbackType.NegHarassment */, "Feedback String");

            if (HResult.Failed(hr))
            {
                throw new Exception("SendFeedback failed with hr = " + hr.ToString("x8"));
            }

            // Test Review
            hr = SendReview(user1.UserId, user2.UserId, XOn.XENON_DASH_TITLE_ID, 3 /* FeedbackDefs.PlayerReview.AvoidDisruptive */, 5);
            
            if (HResult.Failed(hr))
            {
                throw new Exception("SendReview failed with hr = " + hr.ToString("x8"));
            }

            // Test Complaint
            hr = SendComplaint(user1.UserId, user2.UserId, XOn.XENON_DASH_TITLE_ID, 2 /* FeedbackDefs.ComplaintType.OffensiveTextMessage */, 5);
            
            if (HResult.Failed(hr))
            {
                throw new Exception("SendReview failed with hr = " + hr.ToString("x8"));
            }
            
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\askdc-log.h ===
#include <stdarg.h>

void log(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\ASPrincipal.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "askdc.h"

CASPrincipal::CASPrincipal() :
    m_ulPuid(0),
    m_pProv(NULL),
    m_pIdInfo(NULL),
    m_dwRefCount(0),
    m_credType(CT_RandomKey)
{
    m_wszGamerTag[0] = L'\0';
    m_wszConsoleCertHash[0] = L'\0';
    m_liCachedAuthTime.QuadPart = 0;
}

CASPrincipal::~CASPrincipal()
{
    XOMASSERT( 0 == m_dwRefCount );
    if ( KdcFreeMemory && m_pIdInfo )
    {
        KdcFreeMemory(m_pIdInfo);
        m_pIdInfo = NULL;
    }
}

void logt2425454(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}



void
__stdcall
CASPrincipal::Release(void)
{
    XOMASSERT( m_dwRefCount > 0 );
    const KERB_INTERNAL_NAME *pName = this->GetName();
    if ( 0 == InterlockedDecrement((LONG*)&m_dwRefCount) )
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log","CASPrincipal::Release: destroying principal '%S'.", 
                  pName ? pName->Names[0].Buffer : L""); 
        XomTrace(ASkdc, L_LOW, "CASPrincipal::Release: destroying principal '%S'.", 
                  pName ? pName->Names[0].Buffer : L"");
        delete this;
    }
    else
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "CASPrincipal::Release: not destroying cached principal '%S/%S'. (outstanding refs: %d)", 
                  pName ? pName->Names[0].Buffer : L"", 
                  pName ? pName->Names[1].Buffer : L"", 
                  m_dwRefCount);

        XomTrace(ASkdc, L_LOW, "CASPrincipal::Release: not destroying cached principal '%S/%S'. (outstanding refs: %d)", 
                  pName ? pName->Names[0].Buffer : L"", 
                  pName ? pName->Names[1].Buffer : L"", 
                  m_dwRefCount);
    }
}

NTSTATUS
__stdcall
CASPrincipal::Initialize(
    IN  CXBaseProvider      *pProv,
    IN  ULONGLONG           ulPuid,
    IN  BYTE                *pbConsoleCertHash,
    IN  PUNICODE_STRING     pustrRealm,
    IN  PXKDC_PRINCIPAL     pKdbPrinc,
    IN  LPCWSTR             pwszGamerTag,
    IN  XkdcCredential      *pCred,
    IN  LARGE_INTEGER       liMaxLifeTime,
    IN  LARGE_INTEGER       liMaxRenewTime,
    IN  PRINC_DATA_FLAGS    PrincDataFlags,
    IN  CREDTYPE            credType,
    IN  DWORD               dwIdentityAttributes
    )
{
    UNREFERENCED_PARAMETER( PrincDataFlags );

    XOMASSERT( pProv );
    if ( NULL == pProv )
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::Initialize: invalid provider handle.");
        XomTrace(ASkdc, L_ERROR, "CASPrincipal::Initialize: invalid provider handle.");
		logt2425454("c:\\askdc-ASPrincipal-cpp.log","STATUS_INVALID_PARAMETER");
        return STATUS_INVALID_PARAMETER;
    }
    m_pProv = pProv;

    XOMASSERT( pustrRealm );
    if ( NULL == pustrRealm )
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::Initialize: missing realm parameter.");
        XomTrace(ASkdc, L_ERROR, "CASPrincipal::Initialize: missing realm parameter.");
        return STATUS_INVALID_PARAMETER;
    }

    XOMASSERT( pKdbPrinc );
    if ( NULL == pKdbPrinc )
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::Initialize: missing key parameter.");
        XomTrace(ASkdc, L_ERROR, "CASPrincipal::Initialize: missing key parameter.");
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: STATUS_INVALID_PARAMETER");
        return STATUS_INVALID_PARAMETER;
    }

    NTSTATUS status = STATUS_SUCCESS;

    // perform all base class initialization
    status = CXBasePrincipal::Initialize(
                static_cast<IKdbProvider*>(pProv),
                pProv->GetKdcCore(),
                pustrRealm,
                pKdbPrinc,
                pCred,
                liMaxLifeTime,
                liMaxRenewTime,
                KERB_KDB_TIME_NEVER,
                KERB_KDB_TIME_NEVER,
                KERB_KDB_DATA_ALL);

    if ( !NT_SUCCESS(status) )
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::Initialize: base class initialization failed with status %d.", status);
        XomTrace(ASkdc, L_ERROR, "CASPrincipal::Initialize: base class initialization failed with status %d.", status);
        goto Cleanup;
    }

    // initialize the identity puid
    m_ulPuid = ulPuid;

    // initialize the secondary puid
    if (pbConsoleCertHash != NULL) 
    {
        UINT i = 0; 

        for (i = 0; i < A_SHA_DIGEST_LEN; i++) 
        {
            _snwprintf(
                &m_wszConsoleCertHash[2*i],
                (A_SHA_DIGEST_LEN + 1 - i),
                L"%02X",
                pbConsoleCertHash[i]
                );
        }
        m_wszConsoleCertHash[2*i] = L'\0';
    }

    // initialize the gamer tag (client name minus realm and domain)
    lstrcpynW(m_wszGamerTag, pwszGamerTag, ARRAYSIZE(m_wszGamerTag));

    // new principal so no cached auth time
    m_liCachedAuthTime.QuadPart = 0;
    m_credType = credType;
    m_dwIdentityAttributes = dwIdentityAttributes;

    // now add a reference
    XOMASSERT( 0 == m_dwRefCount );
    AddRef();
    XOMASSERT( 1 == m_dwRefCount );

	logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::Initialize: successfully initialized principal '%S' with puid of 0x%016I64X.", m_wszGamerTag, m_ulPuid);
    XomTrace(ASkdc, L_NORMAL, "CASPrincipal::Initialize: successfully initialized principal '%S' with puid of 0x%016I64X.", m_wszGamerTag, m_ulPuid);

Cleanup:
    return status;
}

NTSTATUS
__stdcall
CASPrincipal::Initialize(PKERB_INTERNAL_NAME pName)
{
    if (pName != NULL && pName->NameCount > 1)
    {
        // Set the full principal name in the logging data. A client should 
        // never send us 2+ names.

		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: %S/%S",
            pName->Names[0].Buffer,
            pName->Names[1].Buffer);
        m_logData.m_strPrincipalName.Format(
            "%S/%S",
            pName->Names[0].Buffer,
            pName->Names[1].Buffer);
    }
    else if (pName != NULL && pName->NameCount > 0)
    {
        // Set the "gamertagified" principal name in the logging data.  
        // Translate underscores in the gamertag to spaces, remove trailing 
        // @xbox.com, @xboxtest.com, etc.
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: %S", pName->Names[0].Buffer);
        m_logData.m_strPrincipalName.Format("%S", pName->Names[0].Buffer);
        for (UINT i=0; i < m_logData.m_strPrincipalName.GetLength(); i++)
        {
            if ( '_' == m_logData.m_strPrincipalName[i] )
            {
                m_logData.m_strPrincipalName[i] = ' ';
            }
            else if ( '@' == m_logData.m_strPrincipalName[i] )
            {
                m_logData.m_strPrincipalName.TruncateLength(i);
                break;
            }
        }
    }
    
    // now add a reference
    XOMASSERT( 0 == m_dwRefCount );
    AddRef();
    XOMASSERT( 1 == m_dwRefCount );

    return STATUS_SUCCESS;
}


NTSTATUS
__stdcall
CASPrincipal::GetIdentityInfo(const IDENTITY **ppId)
{
    XOMASSERT( ppId );
    if ( NULL == ppId )
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::GetIdentityInfo: missing ppId parameter.");
        XomTrace(ASkdc, L_ERROR, "CASPrincipal::GetIdentityInfo: missing ppId parameter.");
        return STATUS_INVALID_PARAMETER;
    }

    *ppId = NULL;

    XOMASSERT( 0 != m_ulPuid );
    if ( 0 == m_ulPuid )
    {
		logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::GetIdentityInfo: invalid puid of 0.");
        XomTrace(ASkdc, L_ERROR, "CASPrincipal::GetIdentityInfo: invalid puid of 0.");
        return STATUS_INVALID_SERVER_STATE;
    }

    if ( NULL == m_pIdInfo )
    {
        DWORD dwSize = sizeof(IDENTITY) + sizeof(LARGE_INTEGER);
        m_pIdInfo = (IDENTITY*) KdcAllocMemory(dwSize);
        if ( NULL == m_pIdInfo )
        {
			logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::GetIdentityInfo: failed to allocate %d bytes for IDENTITY struct.", dwSize);
            XomNtEvent(XEVENT_ASKDC_NO_MEMORY_2, "CASPrincipal::GetIdentityInfo: failed to allocate %d bytes for IDENTITY struct.", dwSize);
			logt2425454("c:\\askdc-ASPrincipal-cpp.log", "ERROR: CASPrincipal::GetIdentityInfo: failed to allocate %d bytes for IDENTITY struct.", dwSize);
            XomTrace(ASkdc, L_ERROR, "CASPrincipal::GetIdentityInfo: failed to allocate %d bytes for IDENTITY struct.", dwSize);
            return STATUS_NO_MEMORY;
        }

        m_pIdInfo->LengthOfIdentity = FIELD_OFFSET(IDENTITY, Identity) + sizeof(LARGE_INTEGER);
        m_pIdInfo->IdentityAttributes = m_dwIdentityAttributes;
        m_pIdInfo->IdentityType = ID_PUID;
        m_pIdInfo->CredentialIdType = m_credType;
        *(ULONGLONG*)m_pIdInfo->Identity = m_ulPuid;
    }

    *ppId = m_pIdInfo;
    return STATUS_SUCCESS;
}

NTSTATUS
__stdcall
CASPrincipal::SetCredentialType(CREDTYPE credType)
{
    // GetIdentityInfo might have already been called by this point
    if ( NULL != m_pIdInfo) 
    {
        m_pIdInfo->CredentialIdType = credType;
    }

    // Update the credential types
    m_credType = credType;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\ASProvider.cpp ===
//------------------------------------------------------------------
//  AsProvider.cpp:  Askdc provider object implementation.
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
//------------------------------------------------------------------

//------------------------------------------------------------------
//  Includes
//------------------------------------------------------------------

#include "askdc.h"
#include "PassportAuth.h"
#include "EncPassportAuth.h"
#include "ManagedProxyMemory.h"

#include <atlconv.h>
#include <oleauto.h>

void logtfile546(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

//------------------------------------------------------------------
//  Definitions
//------------------------------------------------------------------

// The CHECK_* macros all set an HR return value. They require the following variables to
// be defined in your function:
//     DWORD       eventId = <appropriate event id>;
//     HRESULT     hr = S_OK;
//     NTSTATUS    status = STATUS_SUCCESS;
//

#define CHECK_BOOL(x, hr_if_failed) \
    if(!(x)) { \
        XomNtEvent( \
            eventId, \
            "The following operation failed within the function %s:\n\n" \
            "%s\n\nhr=0x%08x", __FUNCTION__, #x, hr_if_failed); \
			logtfile546("c:\\askdc-ASProvider-cpp.log","The following operation failed within the function %s:\n\n" \
            "%s\n\nhr=0x%08x", __FUNCTION__, #x, hr_if_failed); \
        hr = hr_if_failed; \
        goto Exit; \
    }

#define CHECK_BOOL_EX(x, hr_if_failed, fmt, ...) \
    if(!(x)) { \
        XomNtEvent( \
            eventId, \
            "The following operation failed within the function %s:\n\n" \
            "%s\n\nhr=0x%08x\nExtended-error: " fmt, __FUNCTION__, #x, hr_if_failed, __VA_ARGS__); \
			logtfile546("c:\\askdc-ASProvider-cpp.log","The following operation failed within the function %s:\n\n" \
            "%s\n\nhr=0x%08x\nExtended-error: " fmt, __FUNCTION__, #x, hr_if_failed, __VA_ARGS__); \
        hr = hr_if_failed; \
        goto Exit; \
    }

#define CHECK_STATUS(x) \
    if(!NT_SUCCESS(status = (x))) { \
        XomNtEvent( \
            eventId, \
            "The following operation failed within the function %s:\n\n" \
            "%s\n\nntstatus=0x%08x", __FUNCTION__, #x, status); \
			logtfile546("c:\\askdc-ASProvider-cpp.log","The following operation failed within the function %s:\n\n" \
            "%s\n\nntstatus=0x%08x", __FUNCTION__, #x, status); \
        hr = HRESULT_FROM_NT(status); \
        goto Exit; \
    }

#define CHECK_STATUS_EX(x, fmt, ...) \
    if(!NT_SUCCESS(status = (x))) { \
        XomNtEvent( \
            eventId, \
            "The following operation failed within the function %s:\n\n" \
            "%s\n\nntstatus=0x%08x\nExtended-error: " fmt, __FUNCTION__, #x, status, __VA_ARGS__); \
			logtfile546("c:\\askdc-ASProvider-cpp.log", "The following operation failed within the function %s:\n\n" \
            "%s\n\nntstatus=0x%08x\nExtended-error: " fmt, __FUNCTION__, #x, status, __VA_ARGS__); \
        hr = HRESULT_FROM_NT(status); \
        goto Exit; \
    }

#define CHECK_HR(x) \
    if(FAILED(hr = (x))) { \
        XomNtEvent( \
            eventId, \
            "The following operation failed within the function %s:\n\n" \
            "%s\n\nhr=0x%08x", __FUNCTION__, #x, hr); \
			logtfile546("c:\\askdc-ASProvider-cpp.log", "The following operation failed within the function %s:\n\n" \
            "%s\n\nhr=0x%08x", __FUNCTION__, #x, hr); \
        goto Exit; \
    }

#define CHECK_HR_EX(x, fmt, ...) \
    if(FAILED(hr = (x))) { \
        XomNtEvent( \
            eventId, \
            "The following operation failed within the function %s:\n\n" \
            "%s\n\nhr=0x%08x\nExtended-error: " fmt, __FUNCTION__, #x, hr, __VA_ARGS__); \
        goto Exit; \
    }

// management output areas
XomDefineArea(log);
XomDefineArea(KdcBase);
XomDefineArea(ASkdc);

// definitions for ASKdc logging DWORD
#define REQSTAT_AS_INVALIDSTATE              (1 << 31)
#define REQSTAT_AS_CONNECTIONFAILURE         (1 << 30)
#define REQSTAT_AS_NO_SERVICE_PRINCIPALS     (1 << 29)
#define REQSTAT_AS_NO_KEK_LOADED             (1 << 28)
#define REQSTAT_AS_SC_PRINC_MISMATCH         (1 << 27)
#define REQSTAT_AS_XBOX1_DECOMMISSION        (1 << 26)
#define REQSTAT_AS_TEMPORARILY_BANNED        (1 << 25)
#define REQSTAT_AS_FOUND_ECHO_PREAUTH        (1 << 24)
#define REQSTAT_AS_VERIFIED_PRE_AUTH_LIST    (1 << 23)
#define REQSTAT_AS_GET_GAMERTAG_BY_USER_ID   (1 << 22)
#define REQSTAT_AS_GET_USER_BY_PASSPORT      (1 << 21)
#define REQSTAT_AS_PASSPORT_AUTH_DETECTED    (1 << 20)
#define REQSTAT_AS_SUCCESSFUL_VALIDATION     (1 << 19)
#define REQSTAT_AS_MORE_THAN_1_PRINC         (1 << 18)
#define REQSTAT_AS_PRINC_FOUND_IN_DB         (1 << 17)
#define REQSTAT_AS_MODIFY_GAMERTAG           (1 << 16)
#define REQSTAT_AS_SC_NO_PRINC_EXISTS        (1 << 15)
#define REQSTAT_AS_SC_PRINC_COPY             (1 << 14)
#define REQSTAT_AS_SC_TOO_SOON               (1 << 13)
#define REQSTAT_AS_GET_USER_BY_ENC_PASSPORT  (1 << 12)
#define REQSTAT_AS_PPA_BAD_TIME_RESPOND      (1 << 11)
#define REQSTAT_AS_PPA_BAD_TIME_DONT_RESPOND (1 << 10)
#define REQSTAT_AS_PPA_SPPA2MISMATCH         (1 << 9)
#define REQSTAT_AS_PPA_ENTRY_NOT_FOUND       (1 << 8)
#define REQSTAT_AS_LOADINGPPA                (1 << 7)
#define REQSTAT_AS_STILL_LOADING_PPA         (1 << 6)
#define REQSTAT_AS_RECEIVEDPPA               (1 << 5)
#define REQSTAT_AS_ISKRBTGT                  (1 << 4)
#define REQSTAT_AS_INVALID_TGS_REQ           (1 << 3)
#define REQSTAT_AS_INVALID_NAME              (1 << 2)
#define REQSTAT_AS_INVALID_REALM             (1 << 1)


//------------------------------------------------------------------
//  Globals
//------------------------------------------------------------------

// global reference to AS provider object
CASProvider *g_pASProvider = NULL;

// global reference to extension handler object
CAsADHandlerFactory *g_pADFactory = NULL;

// Passport-Auth preauth factory
CPaPassportAuthentication::Factory g_PassportAuthPAHandlerFactory;

// Encrypted Passport-Auth preauth factory
CPaEncryptedPassportAuthentication::Factory g_EncryptedPassportAuthPAHandlerFactory;

// ASKDC performance counters
PERFCOUNTER g_ASkdcPerfCtrs[] =
{
    DWORD_COUNTER( ASKDCPERF_SERVER_AS_REQ_COUNTER, -3 ),
    DWORD_RATE( ASKDCPERF_SERVER_AS_REQ_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_TGS_REQ_COUNTER, -3 ),
    DWORD_RATE( ASKDCPERF_SERVER_TGS_REQ_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_AS_SUCCESS_COUNTER, -3 ),
    DWORD_RATE( ASKDCPERF_SERVER_AS_SUCCESS_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_AS_FAILURE_COUNTER, -3 ),
    DWORD_RATE( ASKDCPERF_SERVER_AS_FAILURE_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_TGS_SUCCESS_COUNTER, -3 ),
    DWORD_RATE( ASKDCPERF_SERVER_TGS_SUCCESS_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_TGS_FAILURE_COUNTER, -1 ),
    DWORD_RATE( ASKDCPERF_SERVER_TGS_FAILURE_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_TIMESKEW_COUNTER, -2 ),
    DWORD_RATE( ASKDCPERF_SERVER_TIMESKEW_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_SILENT_FAILURE_COUNTER, -1 ),
    DWORD_RATE( ASKDCPERF_SERVER_SILENT_FAILURE_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_HTTP_REQ_COUNTER, -3 ),
    DWORD_RATE( ASKDCPERF_SERVER_HTTP_REQ_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_HTTP_REQ_CURRENT, 0 ),
    QWORD_AVERAGE( ASKDCPERF_SERVER_HTTP_REQ_TIME_AVERAGE, -1 ),
    DWORD_BASE( ASKDCPERF_SERVER_HTTP_REQ_TIME_BASE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_HTTP_REQ_500_COUNTER, -1 ),
    DWORD_RATE( ASKDCPERF_SERVER_HTTP_REQ_500_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_HTTP_REQ_TIMEOUT_COUNTER, -1 ),
    DWORD_RATE( ASKDCPERF_SERVER_HTTP_REQ_TIMEOUT_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_HTTP_REQ_RETRY_COUNTER, -1 ),
    DWORD_RATE( ASKDCPERF_SERVER_HTTP_REQ_RETRY_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_GETPRINCIPAL_COUNTER, -3 ),
    DWORD_RATE( ASKDCPERF_SERVER_GETPRINCIPAL_RATE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_GETPRINCIPAL_CURRENT, 1 ),
    QWORD_AVERAGE( ASKDCPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE, -1 ),
    DWORD_BASE( ASKDCPERF_SERVER_GETPRINCIPAL_TIME_BASE, 0 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_ENTRIES_IN_USE, -1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_CACHE_HIT, 1 ),
    DWORD_RATE( ASKDCPERF_SERVER_DOS_CACHE_HIT_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_CACHE_HIT_TOO_SOON, 1 ),
    DWORD_RATE( ASKDCPERF_SERVER_DOS_CACHE_HIT_TOO_SOON_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_CACHE_HIT_EXISTS, 1 ),
    DWORD_RATE( ASKDCPERF_SERVER_DOS_CACHE_HIT_EXISTS_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_CACHE_HIT_NONEXISTENT, 1 ),
    DWORD_RATE( ASKDCPERF_SERVER_DOS_CACHE_HIT_NONEXISTENT_RATE, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_CACHE_HIT_EXPIRED, 1),
    DWORD_RATE( ASKDCPERF_SERVER_DOS_CACHE_HIT_EXPIRED_RATE, 1),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_ALLOC_UNEXPIRED, 1 ),
    DWORD_COUNTER( ASKDCPERF_SERVER_DOS_REPLAYS, 1 ),
    DWORD_RATE( ASKDCPERF_SERVER_DOS_REPLAYS_RATE, 1 ),
    DWORD_RATE( ASKDCPERF_SERVER_RPS_USER_AUTH_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_RPS_USER_AUTH_FAILURE_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_XBOX360_MACHINE_AUTH_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_XBOX360_MACHINE_AUTH_FAILURE_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_PC_MACHINE_AUTH_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_PC_MACHINE_AUTH_FAILURE_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_XBOX_USER_AUTH_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_XBOX_USER_AUTH_FAILURE_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_PASSPORT_USER_AUTH_RATE, 0),
    DWORD_RATE( ASKDCPERF_SERVER_PASSPORT_USER_AUTH_FAILURE_RATE, 0),
    DWORD_RATE   ( ASKDCPERF_SERVER_ECHO_FAIL_CHECKSUM_RATE, 0),
    DWORD_COUNTER( ASKDCPERF_SERVER_ECHO_FAIL_CHECKSUM_TOTAL, -3),
    DWORD_RATE   ( ASKDCPERF_SERVER_ECHO_FAIL_IP_RATE, 0),
    DWORD_COUNTER( ASKDCPERF_SERVER_ECHO_FAIL_IP_TOTAL, -3),
    DWORD_RATE   ( ASKDCPERF_SERVER_ECHO_FAIL_TIMESTAMP_RATE, 0),
    DWORD_COUNTER( ASKDCPERF_SERVER_ECHO_FAIL_TIMESTAMP_TOTAL, -3),
    DWORD_RATE   ( ASKDCPERF_SERVER_ECHO_FAIL_NOTPRESENT_RATE, 0),
    DWORD_RATE   ( ASKDCPERF_SERVER_ECHO_FAIL_TOTAL_RATE, 0),
    QWORD_AVERAGE( ASKDCPERF_SERVER_ECHO_FAIL_PERCENT, 0),
    DWORD_BASE   ( ASKDCPERF_SERVER_ECHO_FAIL_PERCENT_BASE, 0),
    DWORD_RATE   ( ASKDCPERF_SERVER_ECHO_SUCCESS_RATE, 0),

};

DWORD g_cASkdcPerfCtrs = sizeof(g_ASkdcPerfCtrs) / sizeof(g_ASkdcPerfCtrs[0]);

// Version for the master key
DWORD g_dwKeyVersion;

//------------------------------------------------------------------
//  Constants
//------------------------------------------------------------------

const BYTE  c_byteEmptyArray[]                  = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

// const for the max number keys to be read for one user.
const DWORD c_dwMaxNumberOfKeys                 = 4;

const char  c_szPerfDllName[]                   = "askdcperf.dll";
const char  c_szServiceName[]                   = "ASKDC";

// PC user principal name
const WCHAR c_PcUserPrincipalName[] = L"PC.USER@XBOX.COM";

//------------------------------------------------------------------
//  Local Function declarations
//------------------------------------------------------------------

//used to make invalid names appear as valid ones.
void MakePresentableLogName( char *szName, DWORD dwNameSize, WCHAR *pwszSrc );

static HRESULT FillKeysFromAskdcPrincipals(
    IN unsigned int const idx,
    IN DWORD const dwItem,
    IN XKDC_PRINCIPAL const * const psPrinc,
    IN OUT XkdcCredential * const pCred,
    IN DWORD const cCred,
    IN AskdcServicePrincipal const * const pPrincipals,
    IN unsigned int const cPrincipals,
    OUT DWORD * const pdwTicketLifetimeSecs
    );

struct FreeAskdcServicePrincipal
{
    static void Free(AskdcServicePrincipal * const pPrincipal)
    {
        SysFreeString(pPrincipal->ServiceName);
        SysFreeString(pPrincipal->DomainName);
        SafeArrayDestroy(pPrincipal->Key);
    }
};
typedef CKdcAutoPtr<AskdcServicePrincipal, FreeAskdcServicePrincipal> CAskdcServicePrincipalsAutoPtr;


struct FreeAskdcKeyEncryptionKey
{
    static void Free(AskdcKeyEncryptionKey * const pKeyEncryptionKey)
    {
        SafeArrayDestroy(pKeyEncryptionKey->Key);
    }
};
typedef CKdcAutoPtr<AskdcKeyEncryptionKey, FreeAskdcKeyEncryptionKey> CAskdcKeyEncryptionKeysAutoPtr;


struct FreeAskdcPrincipal
{
    static void Free(AskdcPrincipal * const pPrincipal)
    {
        SafeArrayDestroy(pPrincipal->IV);
        SafeArrayDestroy(pPrincipal->Key);
    }
};
typedef CKdcAutoPtr<AskdcPrincipal, FreeAskdcPrincipal> CAskdcPrincipalAutoPtr;


static NTSTATUS NtFromHResult(HRESULT hr)
{
    return (NTSTATUS) hr;
}


//------------------------------------------------------------------
//  Main ASKDC code
//------------------------------------------------------------------


//
//  Exported entry point for dll registration.
//
static HMODULE g_hDll = 0;


BOOL APIENTRY DllMain( HANDLE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                   )
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
        break;
    }

    g_hDll = (HMODULE)hModule;

    return TRUE;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = S_OK;

    // set the kdc registry value.
    hr = SetKDCRegistry( TRUE , g_hDll );
    if ( FAILED(hr) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "SetKDCRegistry FAILED(hr)");
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ASKDC:(ERROR) Failed to register askdc.dll provider information.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_ASKDC_REGISTER_FAILURE, "ASKDC:(ERROR) Failed to register askdc.dll provider information.  RESULT=0x%X", hr);
        goto Exit;
    }

    UninstallCounters( (char*)c_szServiceName );

    // install this providers performance counters.
    hr = InstallCounters( (char*)c_szPerfDllName );
    if ( hr != ERROR_SUCCESS )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "InstallCounters ERROR_SUCCESS");
		logtfile546("c:\\askdc-ASProvider-cpp.log","ASKDC:(ERROR) Failed to register askdcperf.dll.  Performance counter information was not properly setup.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_ASKDC_REGISTER_FAILURE_1, "ASKDC:(ERROR) Failed to register askdcperf.dll.  Performance counter information was not properly setup.  RESULT=0x%X", hr);
        goto Exit;
    }

	logtfile546("c:\\askdc-ASProvider-cpp.log", "ASKDC:  Successfully registered AS provider.");
    XomNtEvent( XEVENT_ASKDC_REGISTER_SUCCESS, "ASKDC:  Successfully registered AS provider.");

Exit:
    return hr;

}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;

    // set the kdc registry value.
    hr = SetKDCRegistry( FALSE, g_hDll );
    if ( FAILED(hr) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ASKDC:(ERROR) Failed to unregister askdc.dll provider information.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_ASKDC_REGISTER_FAILURE_2, "ASKDC:(ERROR) Failed to unregister askdc.dll provider information.  RESULT=0x%X", hr);
        goto Exit;
    }

    // install this providers performance counters.
    hr = UninstallCounters( (char*)c_szServiceName );
    if ( hr != ERROR_SUCCESS )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ASKDC:(ERROR) Failed to unregister askdcperf.dll.  Performance counter information was not cleaned up.  RESULT=0x%X", hr);
        XomNtEvent( XEVENT_ASKDC_REGISTER_FAILURE_3, "ASKDC:(ERROR) Failed to unregister askdcperf.dll.  Performance counter information was not cleaned up.  RESULT=0x%X", hr);
        goto Exit;
    }

	logtfile546("c:\\askdc-ASProvider-cpp.log","ASKDC:  Successfully unregistered AS provider.");
    XomNtEvent( XEVENT_ASKDC_REGISTER_SUCCESS_1, "ASKDC:  Successfully unregistered AS provider.");

Exit:
    return hr;

}


//
//    Exported entry point into provider dll.  When the dll is loaded or unloaded by the service,
//    this function is called.
//
//    Purpose:
//        instantiates the provider
//
extern "C" NTSTATUS
KdcExtMain (
    IN DWORD dwReason,
    IN IKdcCore *piKdcCoreInterface
    )
{
    // Don't use XomTrace here because the management framework will
    // not have been initialized yet on startup.
    OutputDebugStringW(L"ASProvider: entering KdcExtMain...");
	logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: entering KdcExtMain...");

    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    CASProvider *pASProvider = NULL;

    if ( dwReason == DLL_PROCESS_ATTACH )
    {
        // initialize COM before g_xomcentral has a chance.
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if ( FAILED(hr) ) {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ASkdcProvider: Failed CoInitializeEx.  Stopping ASKDC.  Hresult = 0xX", hr );
            // error time!!!! --- something bad happened... make note and do what you can.
            XomNtEvent( XEVENT_KDC_CONFIG_6, "ASkdcProvider: Failed CoInitializeEx.  Stopping ASKDC.  Hresult = 0xX", hr );

            return STATUS_INTERNAL_ERROR;
        }

        g_xomcentral.Init("ASkdc", NULL, "kdcsvc");

		logtfile546("c:\\askdc-ASProvider-cpp.log","ASkdcProvider: KdcExtMain attaching...");
        XomTrace(ASkdc, L_NORMAL, "ASkdcProvider: KdcExtMain attaching...");

        //  the core must provide an interface
        if (!piKdcCoreInterface)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","STATUS_INVALID_PARAMETER_2");
            return  STATUS_INVALID_PARAMETER_2;
        }

        //
        //    Initialize global objects that the provider is serving up
        //
        pASProvider = new CASProvider(piKdcCoreInterface);
        if (NULL == pASProvider)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: failed to instantiate CASProvider object.");
            XomNtEvent(XEVENT_ASKDC_INIT_FAILURE, "ASProvider: failed to instantiate CASProvider object.");
            status = STATUS_NO_MEMORY;
            goto Error;
        }

        // set the global AS provider object
        g_pASProvider = pASProvider;

        // initialize the performance counters
        hr = g_Counters.Init(ASKDCPERF_SERVER_OBJECT, g_ASkdcPerfCtrs, g_cASkdcPerfCtrs);
        if ( FAILED(hr) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","g_Counters.Init FAILED(hr)");
            // ungghhhhh...  trying to be "user-friendly" and "helpful" here.
            DWORD dwFirstCounter = 0;
            DWORD dwLastCounter = 0;
            DWORD dwFirstHelp = 0;
            DWORD dwLastHelp = 0;
            HRESULT hrWhy = GetCounterBasis(dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp);

			logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: perfcounter initialization failed with hr=0x%08X. Detailed info from GetCounterBasis:\n"
                "hr=0x%08X \n"
                "FirstCounter=%d, LastCounter=%d, NumCounters=%d \n"
                "FirstHelp=%d, LastHelp=%d, NumHelp=%d",
                hr, hrWhy, dwFirstCounter, dwLastCounter, (dwLastCounter - dwFirstCounter) / 2,
                dwFirstHelp, dwLastHelp, (dwLastHelp - dwFirstHelp) / 2);

            XomNtEvent(XEVENT_ASKDC_INIT_FAILURE_1,
                "ASProvider: perfcounter initialization failed with hr=0x%08X. Detailed info from GetCounterBasis:\n"
                "hr=0x%08X \n"
                "FirstCounter=%d, LastCounter=%d, NumCounters=%d \n"
                "FirstHelp=%d, LastHelp=%d, NumHelp=%d",
                hr, hrWhy, dwFirstCounter, dwLastCounter, (dwLastCounter - dwFirstCounter) / 2,
                dwFirstHelp, dwLastHelp, (dwLastHelp - dwFirstHelp) / 2);
            status = STATUS_INTERNAL_ERROR;
            goto Error;
        }
        else
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: perfcounters successfully initialized.");
            XomTrace(ASkdc, L_NORMAL, "ASProvider: perfcounters successfully initialized.");
        }

        //
        //    Bringing up the provider
        //
        status = pASProvider->Initialize();
        if (!NT_SUCCESS(status))
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: CASProvider initialization failed with status = 0x%08X.", status);
            XomNtEvent(XEVENT_ASKDC_INIT_FAILURE_2, "ASProvider: CASProvider initialization failed with status = 0x%08X.", status);
            goto Error;
        }

        //
        //    Let the core know about this provider
        //
        status = piKdcCoreInterface->pfnKdcRegisterProvider(pASProvider);
        if (!NT_SUCCESS(status))
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: failed to register CASProvider with core, status = 0x%08X.", status);
            XomNtEvent(XEVENT_ASKDC_INIT_FAILURE_3, "ASProvider: failed to register CASProvider with core, status = 0x%08X.", status);
            goto Error;
        }

        //
        //    ownership belongs to g_pASProvider
        //
        pASProvider = NULL;

		logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: successfully loaded and initialized.");
        XomNtEvent(XEVENT_ASKDC_INIT_SUCCESS, "ASProvider: successfully loaded and initialized.");
        XomTrace(ASkdc, L_NORMAL, "ASProvider: KdcExtMain successfully loaded and initialized.");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: KdcExtMain detaching...");
        XomTrace(ASkdc, L_NORMAL, "ASProvider: KdcExtMain detaching...");

        if (g_pASProvider)
        {
            g_pASProvider->Unload();

            delete g_pASProvider;

            g_pASProvider = NULL;
        }

		logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: KdcExtMain successfully unloaded.");
        XomNtEvent(XEVENT_ASKDC_TERM_SUCCESS, "ASProvider: KdcExtMain successfully unloaded.");
        XomTrace(ASkdc, L_NORMAL, "ASProvider: KdcExtMain successfully unloaded.");

        g_xomcentral.Term();
        CoUninitialize();

    }

Done:
    return status;

Error:
	logtfile546("c:\\askdc-ASProvider-cpp.log","ASProvider: KdcExtMain encountered an error.");
    XomNtEvent(XEVENT_ASKDC_INIT_FAILURE_4, "ASProvider: KdcExtMain encountered an error.");

    delete pASProvider;
    g_pASProvider = NULL;
    goto Done;
}

//------------------------------------------------------------------------------------
//                        IKdbProvider
//------------------------------------------------------------------------------------
CASProvider::CASProvider(IKdcCore *pIKdcCore) :
    CXBaseProvider(pIKdcCore, L"Xbox AS KDC", PASSPORT_KERBEROS_REALM_L),
    m_cPrinc(0),
    m_ppPrinc(NULL),
    m_pKeyEncKey(NULL),
    m_cKeyEncKey(-1),
    m_bCheckEchoPreauth(FALSE),
    m_pEchoDataKey(NULL),
    m_bCheckForDos(TRUE),
    m_cDosCacheEntries(1000),
    m_cCacheTimeMilliseconds(1000),
    m_cCacheHitIntervalMilliseconds(1000)
{
    m_liEchoLifetime.QuadPart = 0;
}


CASProvider::~CASProvider()
{
}


void __stdcall
CASProvider::Unload()
{
    Uninitialize();

    CXBaseProvider::Unload();

    delete g_pADFactory;
    g_pADFactory = NULL;

	logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::Unload: completed.");
    XomTrace(ASkdc, L_NORMAL, "CASProvider::Unload: completed.");
}


//
//    Non-IKdbProvider methods for CASProvider
//
NTSTATUS
CASProvider::Initialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    DWORD dwThreadID = 0;
    BOOL success;
    CLargeStr errorstr;
    CComBSTR setting;

    INT cKeyEncKey = 0;
    ASKdcKeyEncKey *pKeyEncKey = NULL;

    INT cOldKeyEncKey = 0;
    ASKdcKeyEncKey *pOldKeyEncKey = NULL;

    INT cPrinc = 0;
    CASKrbTgtPrincipal **ppPrinc = NULL;

    INT cOldPrinc = 0;
    CASKrbTgtPrincipal **ppOldPrinc = NULL;

    XOCryptoKeyEncryptionHelper *pEchoDataKey = NULL;
    XOCryptoKeyEncryptionHelper *pOldEchoDataKey = NULL;

    ConfigWriteLock();

    status = CXBaseProvider::Initialize();
    if ( !NT_SUCCESS(status) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "CASProvider::Initialize: base class initialization failed with status %d.", status);
        XomTrace(ASkdc, L_ERROR, "CASProvider::Initialize: base class initialization failed with status %d.", status);
        goto Cleanup;
    }

    if ( m_bCheckForDos )
    {
        if ( !ASkdcAsDosInit() )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::Initialize: ASkdcAsDosInit failed.");
            XomNtEvent(XEVENT_ASKDC_NO_MEMORY_3, "CASProvider::Initialize: ASkdcAsDosInit failed.");
            XomTrace(ASkdc, L_ERROR, "CASProvider::Initialize: ASkdcAsDosInit failed.");
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !ASkdcAsDosConfig(m_cDosCacheEntries, m_cCacheTimeMilliseconds, m_cCacheHitIntervalMilliseconds) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::Initialize: ASkdcAsDosConfig failed.  DoS Cache Entries=%d", m_cDosCacheEntries);
            XomNtEvent(XEVENT_ASKDC_NO_MEMORY_4, "CASProvider::Initialize: ASkdcAsDosConfig failed.  DoS Cache Entries=%d", m_cDosCacheEntries);
            XomTrace(ASkdc, L_ERROR, "CASProvider::Initialize: ASkdcAsDosConfig failed.");
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }

    status = LoadServicePrincipals(&cPrinc, &ppPrinc);
    if ( !NT_SUCCESS(status) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::Initialize: LoadServicePrincipals failed with status 0x%08X.", status);
        // log an error message but continue
        XomNtEvent(XEVENT_ASKDC_INIT_WARNING, "CASProvider::Initialize: LoadServicePrincipals failed with status 0x%08X.", status);
        status = STATUS_SUCCESS;
    }
    else if ( ppPrinc && cPrinc > 0 )
    {
        status = ReplaceServicePrincipals(cPrinc, ppPrinc, &cOldPrinc, &ppOldPrinc);
        if ( !NT_SUCCESS(status) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log", "CASProvider::Initialize: ReplaceServicePrincipals failed with status 0x%08X.", status);
            // log an error message but continue (not that an error will ever happen)
            XomNtEvent(XEVENT_ASKDC_INIT_WARNING_1, "CASProvider::Initialize: ReplaceServicePrincipals failed with status 0x%08X.", status);
            status = STATUS_SUCCESS;
        }
    }

    status = LoadKeyEncryptionKeys(&cKeyEncKey, &pKeyEncKey);
    if ( !NT_SUCCESS(status) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::Initialize: LoadKeyEncryptionKeys failed with status 0x%08X.", status);
        // log an error message but continue
        XomNtEvent(XEVENT_ASKDC_INIT_WARNING_2, "CASProvider::Initialize: LoadKeyEncryptionKeys failed with status 0x%08X.", status);
        status = STATUS_SUCCESS;
    }
    else if ( pKeyEncKey && cKeyEncKey > 0 )
    {
        status = ReplaceKeyEncryptionKeys(cKeyEncKey, pKeyEncKey, &cOldKeyEncKey, &pOldKeyEncKey);
        if ( !NT_SUCCESS(status) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log", "CASProvider::Initialize: ReplaceKeyEncryptionKeys failed with status 0x%08X.", status);
            // log an error message but continue (not that an error will ever happen)
            XomNtEvent(XEVENT_ASKDC_INIT_WARNING_3, "CASProvider::Initialize: ReplaceKeyEncryptionKeys failed with status 0x%08X.", status);
            status = STATUS_SUCCESS;
        }
    }

    // Load the key needed to implement the Echo preauth
    hr = LoadEchoDataKey(&pEchoDataKey);
    if (FAILED(hr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","%s: LoadEchoDataKey failed with hr 0x%08X. Please use xkeymgr to create this key in t_service_keys. Suggested command line is:\n"
                   "\"xkeymgr addfreq 9 1 MasterKeyV1.pub\"",
                   __FUNCTION__, hr);
        // This is fatal (?)
        XomNtEvent(XEVENT_ASKDC_INIT_FAILURE_6,
                   "%s: LoadEchoDataKey failed with hr 0x%08X. Please use xkeymgr to create this key in t_service_keys. Suggested command line is:\n"
                   "\"xkeymgr addfreq 9 1 MasterKeyV1.pub\"",
                   __FUNCTION__, hr);
        status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }
    else if (pEchoDataKey)
    {
        ReplaceEchoDataKey(pEchoDataKey, &pOldEchoDataKey);
    }


    // Set realm referral flag so requests for krbtgt/XBOX.COM are handled by
    // this provider which registers for the PASSPORT.NET domain.
    m_ulRealmFlags = KERB_KDB_REALM_REFERRAL;

    // Configure Dos2

    BOOL   enabled      = GetDWORDSetting(Setting_kdcsvc_askdc_DoS2_enabled, 0);
    UINT32 maxRecords   = GetDWORDSetting(Setting_kdcsvc_askdc_DoS2_cacheSize, 0);
    double sizeRatio    = 0.5;
    UINT32 maxRequests  = GetDWORDSetting(Setting_kdcsvc_askdc_DoS2_maxRequests, 0);
    UINT32 interval     = GetDWORDSetting(Setting_kdcsvc_askdc_DoS2_interval, 0);
    UINT32 blockingTime = GetDWORDSetting(Setting_kdcsvc_askdc_DoS2_blockingTime, 0);

    success = m_Dos2.Init(
        enabled,
        maxRecords,
        sizeRatio,
        maxRequests,
        interval,
        blockingTime);

    if(!success)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","Failed to initialize DoS detection. Verify that the following settings "
            "contain valid parameters: \n"
            " kdcsvc_askdc_DoS2_enabled: %u \n"
            " kdcsvc_askdc_DoS2_cacheSize: %u \n"
            " kdcsvc_askdc_DoS2_maxRequests: %u \n"
            " kdcsvc_askdc_DoS2_interval: %u \n"
            " kdcsvc_askdc_DoS2_blockingTime: %u \n",
            enabled,
            maxRecords,
            maxRequests,
            interval,
            blockingTime);

        XomNtEvent(
            XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
            "Failed to initialize DoS detection. Verify that the following settings "
            "contain valid parameters: \n"
            " kdcsvc_askdc_DoS2_enabled: %u \n"
            " kdcsvc_askdc_DoS2_cacheSize: %u \n"
            " kdcsvc_askdc_DoS2_maxRequests: %u \n"
            " kdcsvc_askdc_DoS2_interval: %u \n"
            " kdcsvc_askdc_DoS2_blockingTime: %u \n",
            enabled,
            maxRecords,
            maxRequests,
            interval,
            blockingTime);

        status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

Cleanup:
    ConfigWriteUnlock();

    if ( cOldPrinc > 0 && ppOldPrinc )
    {
        FreeServicePrincipals(cOldPrinc, ppOldPrinc);
        cOldPrinc = 0;
        ppOldPrinc = NULL;
    }

    if ( cOldKeyEncKey > 0 && pOldKeyEncKey )
    {
        FreeKeyEncryptionKeys(cOldKeyEncKey, pOldKeyEncKey);
        cOldKeyEncKey = 0;
        pOldKeyEncKey = NULL;
    }

    if ( pOldEchoDataKey )
    {
        FreeEchoDataKey(pOldEchoDataKey);
        pOldEchoDataKey = NULL;
    }

    return status;
}


NTSTATUS
CASProvider::Uninitialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    DWORD dwI = 0;

    ConfigWriteLock();

    if ( m_bCheckForDos )
    {
        ASkdcAsDosTerm();
    }

    // free the cached service principals
    FreeServicePrincipals(m_cPrinc, m_ppPrinc);
    m_cPrinc = 0;
    m_ppPrinc = NULL;

    // free key encryption keys
    FreeKeyEncryptionKeys(m_cKeyEncKey, m_pKeyEncKey);
    m_cKeyEncKey = 0;
    m_pKeyEncKey = NULL;

    // free echo data key
    FreeEchoDataKey(m_pEchoDataKey);
    m_pEchoDataKey = NULL;

    // base provider needs to free up WinHttp handles
    status = CXBaseProvider::Uninitialize();

    ConfigWriteUnlock();

    return status;
}


NTSTATUS
CASProvider::Reinitialize()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    INT cPrinc = 0;
    CASKrbTgtPrincipal **ppPrinc = NULL;

    INT cOldPrinc = 0;
    CASKrbTgtPrincipal **ppOldPrinc = NULL;

    INT cKeyEncKey = 0;
    ASKdcKeyEncKey *pKeyEncKey = NULL;

    INT cOldKeyEncKey = 0;
    ASKdcKeyEncKey *pOldKeyEncKey = NULL;

    XOCryptoKeyEncryptionHelper *pEchoDataKey = NULL;
    XOCryptoKeyEncryptionHelper *pOldEchoDataKey = NULL;

	logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) Reinitialize: starting reinitialization.", __FILE__, __LINE__);
    XomTrace(ASkdc, L_NORMAL, "(%s:%d) Reinitialize: starting reinitialization.", __FILE__, __LINE__);

    status = LoadServicePrincipals(&cPrinc, &ppPrinc);
    if ( !NT_SUCCESS(status) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) Reinitialize: LoadServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) Reinitialize: LoadServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
        goto Cleanup;
    }

    status = LoadKeyEncryptionKeys(&cKeyEncKey, &pKeyEncKey);
    if ( !NT_SUCCESS(status) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) Reinitialize: LoadKeyEncryptionKeys returned status 0x%08X.", __FILE__, __LINE__, status);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) Reinitialize: LoadKeyEncryptionKeys returned status 0x%08X.", __FILE__, __LINE__, status);
        goto Cleanup;
    }

    // Load the key needed to implement the Echo preauth
    hr = LoadEchoDataKey(&pEchoDataKey);
    if (FAILED(hr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","%s: LoadEchoDataKey failed with hr 0x%08X.",
                   __FUNCTION__, hr);
        // This is fatal (?)
        XomNtEvent(XEVENT_ASKDC_INIT_FAILURE_6, "%s: LoadEchoDataKey failed with hr 0x%08X.",
                   __FUNCTION__, hr);
		logtfile546("c:\\askdc-ASProvider-cpp.log","STATUS_INTERNAL_ERROR");
        status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }


    ConfigWriteLock();

    if ( ppPrinc && cPrinc > 0 )
    {
        status = ReplaceServicePrincipals(cPrinc, ppPrinc, &cOldPrinc, &ppOldPrinc);
        if ( !NT_SUCCESS(status) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) Reinitialize: ReplaceServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) Reinitialize: ReplaceServicePrincipals returned status 0x%08X.", __FILE__, __LINE__, status);
        }
        else
        {
            ppPrinc = NULL;
            cPrinc = 0;
        }
    }

    if ( pKeyEncKey && cKeyEncKey > 0 )
    {
        status = ReplaceKeyEncryptionKeys(cKeyEncKey, pKeyEncKey, &cOldKeyEncKey, &pOldKeyEncKey);
        if ( !NT_SUCCESS(status) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log", "(%s:%d) Reinitialize: ReplaceKeyEncryptionKeys returned status 0x%08X.", __FILE__, __LINE__, status);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) Reinitialize: ReplaceKeyEncryptionKeys returned status 0x%08X.", __FILE__, __LINE__, status);
        }
        else
        {
            pKeyEncKey = NULL;
            cKeyEncKey = 0;
        }
    }

    if ( pEchoDataKey )
    {
        ReplaceEchoDataKey(pEchoDataKey, &pOldEchoDataKey);
        pEchoDataKey = NULL;
    }

    ConfigWriteUnlock();

    // free the previous service principals (if any)
    if ( cOldPrinc > 0 && ppOldPrinc )
    {
        FreeServicePrincipals(cOldPrinc, ppOldPrinc);
        ppOldPrinc = NULL;
        cOldPrinc = 0;
    }

    // free the previous key encryption keys (if any)
    if ( cOldKeyEncKey > 0 && pOldKeyEncKey )
    {
        FreeKeyEncryptionKeys(cOldKeyEncKey, pOldKeyEncKey);
        pOldKeyEncKey = NULL;
        cOldKeyEncKey = 0;
    }

    // free the previous echo data key (if any)
    if ( pOldEchoDataKey )
    {
        FreeEchoDataKey(pOldEchoDataKey);
        pOldEchoDataKey = NULL;
    }


	logtfile546("c:\\askdc-ASProvider-cpp.log","Reinitialize: completed reinitialization.");
    XomNtEvent(XEVENT_ASKDC_RELOAD_SUCCESS, "Reinitialize: completed reinitialization.");

	logtfile546("c:\\askdc-ASProvider-cpp.log", "(%s:%d) Reinitialize: completed reinitialization.", __FILE__, __LINE__);
    XomTrace(ASkdc, L_NORMAL, "(%s:%d) Reinitialize: completed reinitialization.", __FILE__, __LINE__);

 Cleanup:

    // Clean up any memory left behind from fatal errors

    if ( cPrinc > 0 && ppPrinc )
    {
        FreeServicePrincipals(cPrinc, ppPrinc);
        ppPrinc = NULL;
        cPrinc = 0;
    }

    if ( cKeyEncKey > 0 && pKeyEncKey )
    {
        FreeKeyEncryptionKeys(cKeyEncKey, pKeyEncKey);
        pKeyEncKey = NULL;
        cKeyEncKey = 0;
    }

    if ( pEchoDataKey )
    {
        FreeEchoDataKey(pEchoDataKey);
        pEchoDataKey = NULL;
    }

    return status;
}


NTSTATUS
CASProvider::InitializePrincipalStore()
{
    NTSTATUS status = STATUS_SUCCESS;

    status = CXBaseProvider::InitializePrincipalStore();
    if ( !NT_SUCCESS(status) )
    {
        goto Cleanup;
    }

Cleanup:
    return status;
}


NTSTATUS
CASProvider::LoadKeyEncryptionKeys(
    OUT INT *pcNumKeyEncKey,
    OUT ASKdcKeyEncKey  **ppKeyEncKey)
{
    NTSTATUS status = STATUS_SUCCESS;
    ASKdcKeyEncKey *pKeyEncKey = NULL;
    DWORD dwSize = 0;
    HRESULT hr = S_OK;
    AskdcKeyEncryptionKey * pKeyEncryptionKeys = NULL;
    unsigned long cKeyEncryptionKeys = 0;
    CAskdcKeyEncryptionKeysAutoPtr askdcKeyEncryptionKeysAutoPtr(&pKeyEncryptionKeys, &cKeyEncryptionKeys);

    XOMASSERT( pcNumKeyEncKey );
    XOMASSERT( ppKeyEncKey );

    if ( NULL == pcNumKeyEncKey || NULL == ppKeyEncKey )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadKeyEncryptionKeys: invalid NULL parameter.",
            __FILE__,
            __LINE__);

        XomNtEvent(XEVENT_KDC_CODE_10,
            "(%s:%d) LoadKeyEncryptionKeys: invalid NULL parameter.",
            __FILE__,
            __LINE__);
        return STATUS_INVALID_PARAMETER;
    }

    *pcNumKeyEncKey = -1;
    *ppKeyEncKey = NULL;

    hr = m_pManagedProxy->AskdcLoadKeyEncryptionKeys(&pKeyEncryptionKeys, &cKeyEncryptionKeys);
    if (FAILED(hr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","AskdcLoadKeyEncryptionKeys FAILED(hr)");
        status = NtFromHResult(hr);
        goto Cleanup;
    }

    // allocate space for the key encryption keys
    dwSize = cKeyEncryptionKeys * sizeof(ASKdcKeyEncKey);
    pKeyEncKey = (ASKdcKeyEncKey*) KdcAllocMemory( dwSize );
    if ( NULL == pKeyEncKey )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadKeyEncryptionKeys: failed to allocate %d bytes.", __FILE__, __LINE__, dwSize);
        XomNtEvent(XEVENT_ASKDC_NO_MEMORY_8, "(%s:%d) LoadKeyEncryptionKeys: failed to allocate %d bytes.", __FILE__, __LINE__, dwSize);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) LoadKeyEncryptionKeys: failed to allocate %d bytes.", __FILE__, __LINE__, dwSize);
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    ZeroMemory( pKeyEncKey, dwSize );

    for (unsigned long i=0; i < cKeyEncryptionKeys; i++)
    {
        DWORD dwMasterKeyVersion = 0;
        DWORD dwKeyLen = 0;
        XOCryptoMasterKeyEncryptedStruct EncryptedKey = {0};
        XOCryptoKeyEncryptionKey KeyEncKey = {0};
        HRESULT hr = S_OK;

        // -------------------------------------------------------------------
        // copy the master key version
        dwMasterKeyVersion = pKeyEncryptionKeys[i].MasterKeyVersion;

        // -------------------------------------------------------------------
        // copy the key encryption key version
        pKeyEncKey[i].dwKeyEncKeyVersion = pKeyEncryptionKeys[i].KeyVersion;

        // -------------------------------------------------------------------
        // copy the size of the encrypted key encryption key
        EncryptedKey.dwKeyLen = pKeyEncryptionKeys[i].KeyLen;

        // -------------------------------------------------------------------
        // copy the encrypted key encryption key
        XOMASSERT( pKeyEncryptionKeys[i].Key->rgsabound[0].cElements == EncryptedKey.dwKeyLen );
        memcpy(EncryptedKey.abKey, pKeyEncryptionKeys[i].Key->pvData, EncryptedKey.dwKeyLen);

        // decrypt the key encryption key using the specified master key
        hr = DecryptWithMasterKey(dwMasterKeyVersion, &EncryptedKey);
        if ( FAILED(hr) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","DecryptWithMasterKey FAILED(hr)");
			logtfile546("c:\\askdc-ASProvider-cpp.log", "(%s:%d) LoadKeyEncryptionKeys: DecryptWithMasterKey failed for master key version %d, hr = 0x%08X.", __FILE__, __LINE__, dwMasterKeyVersion, hr);

            XomNtEvent(XEVENT_ASKDC_DECRYPTION_FAILED, "(%s:%d) LoadKeyEncryptionKeys: DecryptWithMasterKey failed for master key version %d, hr = 0x%08X.", __FILE__, __LINE__, dwMasterKeyVersion, hr);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) LoadKeyEncryptionKeys: DecryptWithMasterKey failed for master key version %d, hr = 0x%08X.", __FILE__, __LINE__, dwMasterKeyVersion, hr);
            status = STATUS_SERVER_DISABLED;
            goto Cleanup;
        }

        // this should be the size of a key encryption key (32 bytes)
        XOMASSERT( EncryptedKey.dwKeyLen <= KEY_ENCRYPTION_KEY_SIZE );

        // save the raw key encryption key
        memcpy(&KeyEncKey, EncryptedKey.abKey, KEY_ENCRYPTION_KEY_SIZE);

        // instantiate a new CryptoHelper for this key encryption key
        pKeyEncKey[i].pCryptoHelper = new XOCryptoKeyEncryptionHelper(&KeyEncKey);
        if ( NULL == pKeyEncKey[i].pCryptoHelper )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadKeyEncryptionKeys: failed to instantiate XOCryptoKeyEncryptionHelper.", __FILE__, __LINE__);
            XomNtEvent(XEVENT_ASKDC_NO_MEMORY_9, "(%s:%d) LoadKeyEncryptionKeys: failed to instantiate XOCryptoKeyEncryptionHelper.", __FILE__, __LINE__);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) LoadKeyEncryptionKeys: failed to instantiate XOCryptoKeyEncryptionHelper.", __FILE__, __LINE__);
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadKeyEncryptionKeys: successful for master key version %d, key version %d.", __FILE__, __LINE__, dwMasterKeyVersion, pKeyEncKey[i].dwKeyEncKeyVersion);
        XomTrace(ASkdc, L_NORMAL, "(%s:%d) LoadKeyEncryptionKeys: successful for master key version %d, key version %d.", __FILE__, __LINE__, dwMasterKeyVersion, pKeyEncKey[i].dwKeyEncKeyVersion);

    }

    // everything succeeded - return the key encryption keys pulled from UODB
    *pcNumKeyEncKey = cKeyEncryptionKeys;
    *ppKeyEncKey = pKeyEncKey;

 Cleanup:
    return status;
}


NTSTATUS
CASProvider::ReplaceKeyEncryptionKeys(
    IN  INT cKeyEncKey,
    IN  ASKdcKeyEncKey *pKeyEncKey,
    OUT INT *pcOldKeyEncKey,
    OUT ASKdcKeyEncKey **ppOldKeyEncKey)
{
    NTSTATUS status = STATUS_SUCCESS;

    XOMASSERT( cKeyEncKey > 0 );
    XOMASSERT( pKeyEncKey );
    XOMASSERT( pcOldKeyEncKey );
    XOMASSERT( ppOldKeyEncKey );

    // save the old key encryption keys if any
    *pcOldKeyEncKey = m_cKeyEncKey;
    *ppOldKeyEncKey = m_pKeyEncKey;

    // install the new key encryption keys
    m_cKeyEncKey = cKeyEncKey;
    m_pKeyEncKey = pKeyEncKey;

    return status;
}


void
CASProvider::FreeKeyEncryptionKeys(
    IN INT cKeyEncKey,
    IN ASKdcKeyEncKey *pKeyEncKey)
{
    if ( pKeyEncKey && cKeyEncKey > 0 )
    {
        for (int i=0; i < cKeyEncKey; i++)
        {
            delete pKeyEncKey[i].pCryptoHelper;
            pKeyEncKey[i].pCryptoHelper = NULL;
        }
        KdcFreeMemory( pKeyEncKey );
    }
}


NTSTATUS
CASProvider::LoadServicePrincipals(
    OUT INT *pcPrinc,
    OUT CASKrbTgtPrincipal ***pppPrinc)
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    VARIANT_BOOL bReadMore = VARIANT_FALSE;
    LONG lPartition = 0;
    INT cActualPrinc = 0;
    CASKrbTgtPrincipal **ppPrinc = NULL;
    AskdcServicePrincipal * pAskdcPrincipals = NULL;
    unsigned long cPrincipals = 0;
    CAskdcServicePrincipalsAutoPtr askdcPrincipalsAutoPtr(&pAskdcPrincipals, &cPrincipals);
    long cDistinctPrincipals = 0;

    XOMASSERT( pcPrinc );
    XOMASSERT( pppPrinc );

    if ( NULL == pcPrinc || NULL == pppPrinc )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadServicePrincipals: invalid NULL parameter.",
            __FILE__,
            __LINE__);

        XomNtEvent(XEVENT_KDC_CODE_22,
            "(%s:%d) LoadServicePrincipals: invalid NULL parameter.",
            __FILE__,
            __LINE__);
        status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    *pcPrinc = 0;
    *pppPrinc = NULL;

    hr = m_pManagedProxy->AskdcGetServicePrincipals(&cDistinctPrincipals, &pAskdcPrincipals, &cPrincipals);
    if (FAILED(hr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","AskdcGetServicePrincipals FAILED(hr)");
        status = NtFromHResult(hr);
        goto Cleanup;
    }

    ppPrinc = (CASKrbTgtPrincipal**) KdcAllocMemory(cDistinctPrincipals * sizeof(CASKrbTgtPrincipal*));
    if ( NULL == ppPrinc )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "LoadServicePrincipals: failed to allocate %d bytes.",
            cDistinctPrincipals * sizeof(CASPrincipal*));

        XomNtEvent(XEVENT_ASKDC_NO_MEMORY_11,
            "LoadServicePrincipals: failed to allocate %d bytes.",
            cDistinctPrincipals * sizeof(CASPrincipal*));

        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    ZeroMemory( ppPrinc, cDistinctPrincipals * sizeof(CASPrincipal*) );


    if (cPrincipals == 0)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "LoadServicePrincipals: Result set does not contain all principal data.  ASKDC will continue to start; however, please investigate this problem.");
        XomNtEvent(XEVENT_KDC_CODE_28, "LoadServicePrincipals: Result set does not contain all principal data.  ASKDC will continue to start; however, please investigate this problem.");
        cDistinctPrincipals = 0;
    }

    for (int i=0; i < cDistinctPrincipals; i++)
    {
        CASKrbTgtPrincipal *pPrinc = NULL;
        XkdcCredential *pCred = NULL;
        XKDC_PRINCIPAL sPrinc = {0};
        LARGE_INTEGER liTicketLifetime = {0};
        LARGE_INTEGER liMaxRenewalTime = {0};
        DWORD dwTicketLifetimeSecs = 0;
        DWORD dwCredSize = 0;
        DWORD dwNumKeys = 0;
        DWORD dwActualNumKeys = 0;

        cActualPrinc++;

        // -------------------------------------------------------------------
        // get the key count
        dwNumKeys = pAskdcPrincipals[i].KeyCount;

        // -------------------------------------------------------------------
        // get the string for the service name
        lstrcpynW(sPrinc.wszServiceName, pAskdcPrincipals[i].ServiceName, ARRAYSIZE(sPrinc.wszServiceName));


        // -------------------------------------------------------------------
        // get teh string for the domain name.
        lstrcpynW(sPrinc.wszDomainName, pAskdcPrincipals[i].DomainName, ARRAYSIZE(sPrinc.wszDomainName));

        // allocate space for credentials
        dwCredSize = sizeof(XkdcCredential) + dwNumKeys * (sizeof(XkdcKey) + XKDC_KEYSIZE);
        pCred = (XkdcCredential*) KdcAllocMemory(dwCredSize);
        if ( NULL == pCred )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log", "LoadServicePrincipals: failed to allocate %d bytes for keys.", dwCredSize);
            XomNtEvent(XEVENT_ASKDC_NO_MEMORY_12, "LoadServicePrincipals: failed to allocate %d bytes for keys.", dwCredSize);
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        ZeroMemory(pCred, dwCredSize);

        pCred->dwKeyCount = dwNumKeys;
        XOMASSERT( dwNumKeys > 0 );

        // go through all keys of this principle type.
        for (DWORD k=0; k<dwNumKeys; k++)
        {
            dwActualNumKeys++;
            hr = FillKeysFromAskdcPrincipals(i, k, &sPrinc, pCred, dwCredSize, pAskdcPrincipals, cPrincipals, &dwTicketLifetimeSecs);
            if ( hr == S_FALSE )
            {
                if ( ( cDistinctPrincipals != cActualPrinc ) || ( dwNumKeys != dwActualNumKeys ) )
                {
					logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadServicePrincipals: Result set does not contain all principal data.  ASKDC will continue to start; however, please investigate this problem.", __FILE__, __LINE__);
                    XomNtEvent(XEVENT_KDC_CONFIG_18, "(%s:%d) LoadServicePrincipals: Result set does not contain all principal data.  ASKDC will continue to start; however, please investigate this problem.", __FILE__, __LINE__);
                    XomTrace(ASkdc, L_ERROR, "(%s:%d) LoadServicePrincipals: Result set does not contain all principal data.  ASKDC will continue to start; however, please investigate this problem.", __FILE__, __LINE__);
                }
                cDistinctPrincipals = cActualPrinc;
                pCred->dwKeyCount = dwActualNumKeys;
                break;
            }
            else if ( FAILED(hr) )
            {
                status = STATUS_SERVER_DISABLED;
                goto Cleanup;
            }
        }

        // allocate the new principal
        pPrinc = new CASKrbTgtPrincipal();
        if ( NULL == pPrinc )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadServicePrincipals failed to instantiate new principal.", __FILE__, __LINE__);
            XomNtEvent(XEVENT_ASKDC_NO_MEMORY_13, "(%s:%d) LoadServicePrincipals failed to instantiate new principal.", __FILE__, __LINE__);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) LoadServicePrincipals failed to instantiate new principal.", __FILE__, __LINE__);
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        // ticket lifetime is specified in periods of 100ns
        liTicketLifetime.QuadPart = (LONGLONG) 10000000 * dwTicketLifetimeSecs;

        // This lifetime will be used as the ticket lifetime for the user and
        // machine principals since we don't want to specify a lifetime for
        // each and every one of them in the UODB.
        m_liMaxLifetime = liTicketLifetime;

        // initialize the new principal
        status = pPrinc->Initialize(
                this,
                (ULONGLONG)0,
                NULL,
                &m_ustrRealmName,
                &sPrinc,
                sPrinc.wszServiceName,
                pCred,
                liTicketLifetime,
                liMaxRenewalTime,
                KERB_KDB_DATA_ALL,
                CT_RandomKey,
                IA_USER
                );

        if ( !NT_SUCCESS(status) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log", "(%s:%d) LoadServicePrincipals failed to initialize new principal, status = 0x%08X.", __FILE__, __LINE__, status);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) LoadServicePrincipals failed to initialize new principal, status = 0x%08X.", __FILE__, __LINE__, status);
            goto Cleanup;
        }

		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadServicePrincipals created cached principal '%S/%S'.", __FILE__, __LINE__, sPrinc.wszServiceName, sPrinc.wszDomainName);

        XomTrace(ASkdc, L_NORMAL, "(%s:%d) LoadServicePrincipals created cached principal '%S/%S'.", __FILE__, __LINE__, sPrinc.wszServiceName, sPrinc.wszDomainName);

        // if this is krbtgt/PASSPORT.NET, the key version must be specified
        if ( 0 == _wcsnicmp(
                    PASSPORT_KERBEROS_REALM_L,
                    pPrinc->GetName()->Names[1].Buffer,
                    pPrinc->GetName()->Names[1].Length ) )
        {
            status = pPrinc->SetEncryptionKeyVersion(g_dwKeyVersion);

            if ( !NT_SUCCESS(status) )
            {
                if ( STATUS_NOT_FOUND == status )
                {
					logtfile546("c:\\askdc-ASProvider-cpp.log","LoadServicePrincipals: invalid Passport key version %d specified.  Check kdcsvc_askdc_keyVersion setting in ConfigDB.",
                        g_dwKeyVersion);

                    XomNtEvent(XEVENT_ASKDC_INVALID_PASSPORT_KEY_VERSION,
                        "LoadServicePrincipals: invalid Passport key version %d specified.  Check kdcsvc_askdc_keyVersion setting in ConfigDB.",
                        g_dwKeyVersion);

					logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) LoadServicePrincipals: invalid Passport key version %d specified.  Check kdcsvc_askdc_keyVersion setting in ConfigDB.",
                        __FILE__,
                        __LINE__,
                        g_dwKeyVersion);

                    XomTrace(ASkdc, L_NORMAL,
                        "(%s:%d) LoadServicePrincipals: invalid Passport key version %d specified.  Check kdcsvc_askdc_keyVersion setting in ConfigDB.",
                        __FILE__,
                        __LINE__,
                        g_dwKeyVersion);

					logtfile546("c:\\askdc-ASProvider-cpp.log","STATUS_INVALID_PARAMETER");
                    status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }

        // add the new principal to the cache
        ppPrinc[i] = pPrinc;
    }

    // everything was successful so return the new principals
    *pcPrinc = cDistinctPrincipals;
    *pppPrinc = ppPrinc;

    // don't set cDistinctPrincipals to 0 -- although the auto-ptr doesn't reference it
    // (it uses a ptr), you never know how things may shake down in the future and we
    // don't want another memory leak.
    ppPrinc = NULL;

 Cleanup:
    if ( cDistinctPrincipals > 0 && ppPrinc )
    {
        FreeServicePrincipals(cDistinctPrincipals, ppPrinc);
        ppPrinc = NULL;
    }

    return status;
}


NTSTATUS
CASProvider::ReplaceServicePrincipals(
    IN  INT cPrinc,
    IN  CASKrbTgtPrincipal **ppPrinc,
    OUT INT *pcOldPrinc,
    OUT CASKrbTgtPrincipal ***pppOldPrinc)
{
    NTSTATUS status = STATUS_SUCCESS;

    XOMASSERT( cPrinc > 0 );
    XOMASSERT( ppPrinc );
    XOMASSERT( pcOldPrinc );
    XOMASSERT( pppOldPrinc );

    // save the old service principals (if any)
    *pcOldPrinc = m_cPrinc;
    *pppOldPrinc = m_ppPrinc;

    // install the new service principals
    m_cPrinc = cPrinc;
    m_ppPrinc = ppPrinc;

    cPrinc = 0;
    ppPrinc = NULL;

    return status;
}


void
CASProvider::FreeServicePrincipals(
    IN INT cPrinc,
    IN CASKrbTgtPrincipal **ppPrinc)
{
    if ( ppPrinc )
    {
        if ( cPrinc > 0 )
        {
            for (int i=0; i < cPrinc; i++)
            {
                if ( ppPrinc[i] )
                {
                    ppPrinc[i]->Release();
                    ppPrinc[i] = NULL;
                }
            }
        }

        KdcFreeMemory(ppPrinc);
    }
}

HRESULT
CASProvider::LoadEchoDataKey(
    OUT XOCryptoKeyEncryptionHelper **ppKey)
{
    XOMASSERT(ppKey);

    DWORD       eventId = XEVENT_ASKDC_FAILED_TO_LOAD_ECHO_DATA_KEY;
    NTSTATUS    status = STATUS_SUCCESS;
    HRESULT     hr = S_OK;
    SAFEARRAY * psaKey = NULL;
    XOCryptoKeyEncryptionKey         plaintextKey = {0};

    CHECK_HR(m_pManagedProxy->KdcGetLatestDecryptedServiceKey(KEY_TYPE_KDC_ECHO_DATA, &psaKey));
    CHECK_BOOL_EX(psaKey->rgsabound[0].cElements == sizeof(plaintextKey.abKey), E_FAIL,
               "EncKeyLen=%d, PlainKeyLen=%d", psaKey->rgsabound[0].cElements, sizeof(plaintextKey.abKey));

	logtfile546("c:\\askdc-ASProvider-cpp.log","EncKeyLen=%d, PlainKeyLen=%d", psaKey->rgsabound[0].cElements, sizeof(plaintextKey.abKey));

    memcpy(plaintextKey.abKey, psaKey->pvData, sizeof(plaintextKey.abKey));
    SecureZeroMemory(psaKey->pvData, psaKey->rgsabound[0].cElements);

    // "plaintextKey" isn't really a key-encryption-key, but that's ok - the crypto helper
    // will let us use it for encrypting arbitrary data. it just means our key has to be
    // 256 bits, which is fine.
    CHECK_BOOL(*ppKey = new XOCryptoKeyEncryptionHelper(&plaintextKey), E_OUTOFMEMORY);


Exit:
    if (psaKey != NULL)
    {
        SafeArrayDestroy(psaKey);
    }

    return hr;
}


VOID
CASProvider::ReplaceEchoDataKey(
    IN XOCryptoKeyEncryptionHelper *pKey,
    OUT XOCryptoKeyEncryptionHelper **ppOldKey)
{
    XOMASSERT(ppOldKey);
    *ppOldKey = m_pEchoDataKey;
    m_pEchoDataKey = pKey;
}

void
CASProvider::FreeEchoDataKey(
    IN XOCryptoKeyEncryptionHelper *pKey)
{
    if (pKey)
    {
        delete pKey;
    }
}

//
//    IKdbProvider methods for CASProvider
//
KERBERR __stdcall
CASProvider::GetPrincipal(
    IN  GET_PRINC_FLAGS      flags,
    IN  PKERB_INTERNAL_NAME  pName,
    IN  LPCWSTR              pcwszRealm,
    IN  IKerbRequest        *piReq,
    OUT PIKerbPrincipal     *ppIPrincipal,
    OUT PKERB_EXT_ERROR      pExtendedError,
    OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm
    )
{
    in_addr *pInAddr = NULL;
    QWORD qwStartTime = 0;
    QWORD qwEndTime = 0;
    QWORD qwElapsedMs = 0;
    DWORD dwReqStatus = 0;

    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;

    g_Counters.IncrementValue32(ASKDCPERF_SERVER_GETPRINCIPAL_CURRENT, 1);

    GetSystemTimeAsFileTime((FILETIME*)&qwStartTime);

    pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

    ConfigReadLock();

    XOMASSERT( ppIPrincipal );
    *ppIPrincipal = NULL;

    // PASSPORT.NET realm should never receive TGS requests from valid Xbox clients
    if ( KerbTgs == piReq->GetServId() )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: invalid TGS request to %s realm from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        XomNtEvent(XEVENT_KDC_HACK_1,
                "(%s:%d) GetPrincipal: invalid TGS request to %s realm from client %s.  Possible hack attempt.",
                __FILE__,
                __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: invalid TGS request to %s realm from client %s.  Possible hack attempt.",
                 __FILE__,
                 __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        XomTrace(ASkdc, L_ERROR,
                "(%s:%d) GetPrincipal: invalid TGS request to %s realm from client %s.  Possible hack attempt.",
                 __FILE__,
                 __LINE__,
                XBOX_KERBEROS_REALM,
                inet_ntoa(*pInAddr));

        KerbErr = SilentKerbErr(KDC_ERR_POLICY);
        dwReqStatus |= REQSTAT_AS_INVALID_TGS_REQ;
        status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    // ensure the correct realm.  AS should only handle PASSPORT realm issues.
    if ( _wcsicmp( pcwszRealm , PASSPORT_KERBEROS_REALM_L ) != 0 )
    {
        KerbErr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
		logtfile546("c:\\askdc-ASProvider-cpp.log","STATUS_NOT_SUPPORTED");
        status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }


    // make sure we have the krbtgt principals loaded up
    if ( m_cPrinc <= 0 )
    {
        INT cPrinc = 0;
        CASKrbTgtPrincipal **ppPrinc = NULL;

        INT cOldPrinc = 0;
        CASKrbTgtPrincipal **ppOldPrinc = NULL;

        status = LoadServicePrincipals(&cPrinc, &ppPrinc);
        if ( !NT_SUCCESS(status) || cPrinc <= 0 )
        {
            KerbErr = KDC_ERR_SERVICE_NOTYET;
            dwReqStatus |= REQSTAT_AS_NO_SERVICE_PRINCIPALS;
            status = STATUS_SERVER_DISABLED;
			logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: principal cache unavailable.", __FILE__, __LINE__);
            XomTrace(ASkdc, L_NORMAL, "(%s:%d) GetPrincipal: principal cache unavailable.", __FILE__, __LINE__);
            goto Cleanup;
        }

        // TODO: should really expose the reader/writer lock methods
        // ConvertExclusiveToShared and ConvertSharedToExclusive rather than
        // doing this.
        ConfigReadUnlock();
        ConfigWriteLock();

        status = ReplaceServicePrincipals(cPrinc, ppPrinc, &cOldPrinc, &ppOldPrinc);

        ConfigWriteUnlock();
        ConfigReadLock();

        if ( cOldPrinc > 0 && ppOldPrinc )
        {
            FreeServicePrincipals(cOldPrinc, ppOldPrinc);
            cOldPrinc = 0;
            ppOldPrinc = NULL;
        }

        if ( !NT_SUCCESS(status) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ReplaceServicePrincipals !NT_SUCCESS(status)");
            goto Cleanup;
        }

    }

    // make sure we have the key encryption keys loaded up
    if ( m_cKeyEncKey < 0 )
    {
        INT cKeyEncKey = 0;
        ASKdcKeyEncKey *pKeyEncKey = NULL;

        INT cOldKeyEncKey = 0;
        ASKdcKeyEncKey *pOldKeyEncKey = NULL;

        status = LoadKeyEncryptionKeys(&cKeyEncKey, &pKeyEncKey);
        if ( !NT_SUCCESS(status) || cKeyEncKey <= 0 )
        {
            KerbErr = KDC_ERR_SERVICE_NOTYET;
            dwReqStatus |= REQSTAT_AS_NO_KEK_LOADED;
            status = STATUS_SERVER_DISABLED;
			logtfile546("c:\\askdc-ASProvider-cpp.log", "(%s:%d) GetPrincipal: key encryption keys unavailable.", __FILE__, __LINE__);
            XomTrace(ASkdc, L_NORMAL, "(%s:%d) GetPrincipal: key encryption keys unavailable.", __FILE__, __LINE__);
            goto Cleanup;
        }

        // TODO: should really expose the reader/writer lock methods
        // ConvertExclusiveToShared and ConvertSharedToExclusive rather than
        // doing this.
        ConfigReadUnlock();
        ConfigWriteLock();

        status = ReplaceKeyEncryptionKeys(cKeyEncKey, pKeyEncKey, &cOldKeyEncKey, &pOldKeyEncKey);

        ConfigWriteUnlock();
        ConfigReadLock();

        if ( cOldKeyEncKey > 0 && pOldKeyEncKey )
        {
            FreeKeyEncryptionKeys(cOldKeyEncKey, pOldKeyEncKey);
            cOldKeyEncKey = 0;
            pOldKeyEncKey = NULL;
        }

        if ( !NT_SUCCESS(status) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ReplaceKeyEncryptionKeys !NT_SUCCESS(status)");
            pExtendedError->status = status;
            goto Cleanup;
        }
    }

    if (flags & KDC_KDB_GET_PRINC_CLIENT)
    {
        if (pName->NameCount != 1)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) Too many names (%d) for client principal", __FILE__, __LINE__, pName->NameCount);
            XomTrace(ASkdc, L_HIGH, "(%s:%d) Too many names (%d) for client principal", __FILE__, __LINE__, pName->NameCount);
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
			logtfile546("c:\\askdc-ASProvider-cpp.log","KDC_ERR_C_PRINCIPAL_UNKNOWN");
            goto Cleanup;
        }

        if (GetPaData(piReq, KRB5_PADATA_PASSPORT_AUTHENTICATION))
        {
            // Detected passport authentication pre-auth. Principal must be
            // authenticated/built in a special way. For Panorama (PC) clients.

            KerbErr = GetPrincipalByPassport(
                flags,
                pName,
                pcwszRealm,
                piReq,
                ppIPrincipal,
                pExtendedError,
                ppustrReferredRealm,
                dwReqStatus);

			logtfile546("c:\\askdc-ASProvider-cpp.log","#1 GetPrincipalByPassport");
        }
        else
        {
            // Build the principal in the usual way. For Xbox, Xbox 360 and kerberos
            // principles.

            KerbErr = GetPrincipalByName(
                flags,
                pName,
                pcwszRealm,
                piReq,
                ppIPrincipal,
                pExtendedError,
                ppustrReferredRealm,
                dwReqStatus);

			logtfile546("c:\\askdc-ASProvider-cpp.log","#2 GetPrincipalByPassport");
        }

    }
    else
    {
        XOMASSERT(flags & KDC_KDB_GET_PRINC_SERVER);

        if (pName->NameCount != 2)
        {
            XomTrace(ASkdc, L_HIGH, "(%s:%d) Too few names (%d) for server principal", __FILE__, __LINE__, pName->NameCount);
			logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) Too few names (%d) for server principal", __FILE__, __LINE__, pName->NameCount);
            KerbErr = KDC_ERR_S_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }

        WCHAR wszName[100] = {0};
        _snwprintf(wszName, ARRAYSIZE(wszName)-1, L"%s/%s",
                   pName->Names[0].Buffer,
                   pName->Names[1].Buffer
                   );

	logtfile546("c:\\askdc-ASProvider-cpp.log","%s/%s",
                   pName->Names[0].Buffer,
                   pName->Names[1].Buffer
                   );

        if ( IsKrbTgt(pName) )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: krbtgt name is '%S', flags=%d.", __FILE__, __LINE__, wszName, flags);
            XomTrace(ASkdc, L_LOW, "(%s:%d) GetPrincipal: krbtgt name is '%S', flags=%d.", __FILE__, __LINE__, wszName, flags);

            dwReqStatus |= REQSTAT_AS_ISKRBTGT;

            for (INT i=0; i < m_cPrinc; i++)
            {
                if ( m_ppPrinc[i] && GetKdcCore()->pfnKerbEqualKdcNames(pName, m_ppPrinc[i]->GetName()) )
                {
                    m_ppPrinc[i]->AddRef();
                    *ppIPrincipal = static_cast<IKerbPrincipal*>(m_ppPrinc[i]);
					logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: returning cached principal '%S/%S'.", __FILE__, __LINE__, pName->Names[0].Buffer, pName->Names[1].Buffer);

                    XomTrace(ASkdc, L_LOW, "(%s:%d) GetPrincipal: returning cached principal '%S/%S'.", __FILE__, __LINE__, pName->Names[0].Buffer, pName->Names[1].Buffer);
                    goto Cleanup;
                }
            }
        }

		logtfile546("c:\\askdc-ASProvider-cpp.log","GetPrincipal (server): No krbtgt match for '%S/%S'",
                   pName->Names[0].Buffer, pName->Names[1].Buffer);

        // No match? How odd.
        XomNtEvent(XEVENT_ASKDC_UNKNOWN_SERVER_PRINCIPAL,
                   "GetPrincipal (server): No krbtgt match for '%S/%S'",
                   pName->Names[0].Buffer, pName->Names[1].Buffer);
        KerbErr = SilentKerbErr(KDC_ERR_S_PRINCIPAL_UNKNOWN);
        goto Cleanup;
    }


Cleanup:

    ConfigReadUnlock();

    // Set some logging fields in the principal, but only for a client principal.
    if (flags & KDC_KDB_GET_PRINC_CLIENT)
    {
        // If the helper functions didn't create a principal, we're going to create a
        // dummy one to use for logging purposes.  Since we're returning a kerb error,
        // this principal should get essentially ignored (?).
        // @@@ todo: verify this is true
        if (*ppIPrincipal == NULL)
        {
            XOMASSERT(KerbErr != KDC_ERR_NONE);
            CASPrincipal *p = new CASPrincipal();
            if (p == NULL)
            {
				logtfile546("c:\\askdc-ASProvider-cpp.log","Failed to instantiate new CASPrincipal.");

                XomNtEvent(XEVENT_ASKDC_NO_MEMORY_17, "Failed to instantiate new CASPrincipal.");
                status = STATUS_NO_MEMORY;
                KerbErr = KDC_ERR_SVC_UNAVAILABLE;
                goto CleanupOutOfMem;
            }
            p->Initialize(pName);  // set name, add ref
            *ppIPrincipal = static_cast<IKerbPrincipal*>(p);
        }

        // Cast back to our useful class and stuff in some helpful logging info
        CASPrincipal *pPrinc = static_cast<CASPrincipal*>(*ppIPrincipal);

        // Failure in child trumps failure in this function
        if (!NT_SUCCESS(pExtendedError->status))
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","!NT_SUCCESS(pExtendedError->status)");
            pPrinc->m_logData.m_ntstatus = pExtendedError->status;
        }
        else
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","pPrinc->m_logData.m_ntstatus = status;");
            pPrinc->m_logData.m_ntstatus = status;
        }

        pPrinc->m_logData.m_princFlags = flags;
        pPrinc->m_logData.m_dwReqStatus = dwReqStatus;
    }

CleanupOutOfMem:

    g_Counters.IncrementValue32(ASKDCPERF_SERVER_GETPRINCIPAL_CURRENT, -1);

    if (flags & KDC_KDB_GET_PRINC_CLIENT &&
        KERB_SUCCESS(KerbErr))
    {
        // These perf counters only apply to successful requests (not even the echo
        // reply gets included).
        GetSystemTimeAsFileTime((FILETIME*)&qwEndTime);
        qwElapsedMs = ( qwEndTime - qwStartTime ) / 10000;
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_GETPRINCIPAL_COUNTER, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_GETPRINCIPAL_RATE, 1);
        g_Counters.IncrementValue64(ASKDCPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE, qwElapsedMs);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_GETPRINCIPAL_TIME_BASE, 1);
    }

    return KerbErr;
}

KERBERR
CASProvider::GetPrincipalByName(
    IN  GET_PRINC_FLAGS      flags,
    IN  PKERB_INTERNAL_NAME  pName,
    IN  LPCWSTR              pcwszRealm,
    IN  IKerbRequest        *piReq,
    OUT PIKerbPrincipal     *ppIPrincipal,
    OUT PKERB_EXT_ERROR      pExtendedError,
    OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm,
    IN OUT DWORD             &dwReqStatus
    )
{
    BOOL bIsMachineIdentity = FALSE;
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;
    WCHAR wszName[100] = {0};
    XkdcCredential *pCred = NULL;
    DWORD dwCredSize = 0;
    CASPrincipal *pPrinc = NULL;
    XKDC_PRINCIPAL sPrinc = {0};
    ULONGLONG ulPuid = 0;
    LARGE_INTEGER liMaxRenewalTime = {0};
    in_addr *pInAddr = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);
    BYTE * pbConsoleCertHash = NULL;
    PXKERB_PA_XENON_PPA pXenonPPA = NULL;
    ASN1octetstring_t* padata = NULL;

    XOMASSERT(pName->NameCount == 1);
    XOMASSERT(flags & KDC_KDB_GET_PRINC_CLIENT);

	logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: original name is '%S', flags=%d.", __FILE__, __LINE__, pName->Names[0].Buffer, flags);
    XomTrace(ASkdc, L_LOW, "(%s:%d) GetPrincipal: original name is '%S', flags=%d.", __FILE__, __LINE__, pName->Names[0].Buffer, flags);

    // translate underscores in the gamertag to spaces
    // remove trailing @xbox.com, @xboxtest.com, etc. and separate the tag
    lstrcpynW(wszName, pName->Names[0].Buffer, ARRAYSIZE(wszName));
    for (INT i=0; i<ARRAYSIZE(wszName); i++)
    {
        if ( L'_' == wszName[i] )
        {
            wszName[i] = L' ';
        }
        else if ( L'@' == wszName[i] )
        {
            wszName[i] = L'\0';
            break;
        }
    }

    // A non-Xbox client could be sending us bogus names so make sure
    // the gamertag length isn't exceeded.
    wszName[XONLINE_MAX_GAMERTAG_LENGTH] = L'\0';

	logtfile546("c:\\askdc-ASProvider-cpp.log", "(%s:%d) GetPrincipal: truncated name is '%S', flags=%d.", __FILE__, __LINE__, wszName, flags);
    XomTrace(ASkdc, L_LOW, "(%s:%d) GetPrincipal: truncated name is '%S', flags=%d.", __FILE__, __LINE__, wszName, flags);

    // We are configured to fail all xbox 1 requests, then fail out early here.
    if (_wcsnicmp(wszName, L"SN.", 3) == 0)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","SN. KDC_ERR_POLICY ");
        KerbErr = KDC_ERR_POLICY;
        dwReqStatus |= REQSTAT_AS_XBOX1_DECOMMISSION;
        goto Cleanup;
    }

    // ==================================================================================
    // If DoS checks are enabled, first check the DoS cache for the given
    // principal name before hitting the UODB.
    // ==================================================================================

    if (m_bCheckForDos)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","m_bCheckForDos = yes");
        BOOL bTooSoon = FALSE;
        if ( ASkdcAsDosGetPrincipal(piReq, wszName, &bTooSoon, &pPrinc) )
        {
            // If the principal was found in the secondary cache but less
            // than 1 second has elapsed since the last cache hit, this is
            // not a valid Xbox client so don't bother returning anything
            if ( bTooSoon )
            {
                XOMASSERT( NULL == *ppIPrincipal );
                dwReqStatus |= REQSTAT_AS_SC_TOO_SOON;
                KerbErr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);

                // we have a reqstat bit to key off of in the app logs, and we have
                // tracing. no event spam!

//                 XomNtEvent(XEVENT_KDC_HACK_2,
//                     "(%s:%d) GetPrincipal: multiple DoS cache hits for principal less 
//                     than 1 second apart.  Client: %s, Name: '%S'.",
//                     __FILE__,
//                     __LINE__,
//                     inet_ntoa(*pInAddr),
//                     wszName);
				logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: multiple DoS cache hits for principal less than 1 second apart.  Client: %s, Name: '%S'.",
                    __FILE__,
                    __LINE__,
                    inet_ntoa(*pInAddr),
                    wszName);

                XomTrace(ASkdc, L_HIGH,
                    "(%s:%d) GetPrincipal: multiple DoS cache hits for principal less than 1 second apart.  Client: %s, Name: '%S'.",
                    __FILE__,
                    __LINE__,
                    inet_ntoa(*pInAddr),
                    wszName);

            }
            else if ( pPrinc )
            {
                // cache hit and the principal exists in UODB
                dwReqStatus |= REQSTAT_AS_SC_PRINC_COPY;

                *ppIPrincipal = static_cast<IKerbPrincipal*>(pPrinc);
                pPrinc = NULL;

				logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: DoS cache hit for existing principal.  Client: %s, Name: '%S'.",
                    __FILE__,
                    __LINE__,
                    inet_ntoa(*pInAddr),
                    wszName);

                XomTrace(ASkdc, L_HIGH,
                    "(%s:%d) GetPrincipal: DoS cache hit for existing principal.  Client: %s, Name: '%S'.",
                    __FILE__,
                    __LINE__,
                    inet_ntoa(*pInAddr),
                    wszName);

                // Check for valid pre-auths in request. This function will take care of
                // logging events. Do this after DoS checks. This is mainline code path 1
                // of 2 for when we hit the DoS cache.
                KerbErr = VerifyPreAuthWhitelist(piReq, wszName, dwReqStatus);
                if (!KERB_SUCCESS(KerbErr))
                {
					logtfile546("c:\\askdc-ASProvider-cpp.log","VerifyPreAuthWhitelist !KERB_SUCCESS(KerbErr)");
                    goto Cleanup;
                }
            }
            else
            {
                // cache hit and the principal does not exist in UODB
                dwReqStatus |= REQSTAT_AS_SC_NO_PRINC_EXISTS;
                KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;

				logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: DoS cache hit for nonexistent principal.  Client: %s, Name: '%S'.",
                    __FILE__,
                    __LINE__,
                    inet_ntoa(*pInAddr),
                    wszName);

                XomTrace(ASkdc, L_HIGH,
                    "(%s:%d) GetPrincipal: DoS cache hit for nonexistent principal.  Client: %s, Name: '%S'.",
                    __FILE__,
                    __LINE__,
                    inet_ntoa(*pInAddr),
                    wszName);

            }

            // If you are in the cache for any reason, we avoid a DB lookup. We also avoid
            // any future checks (preauth, echo, etc).
            goto Cleanup;
        }
    }

    // ==================================================================================
    // Check for valid pre-auths in request. This function will take care of logging
    // events. Do this after DoS checks. This is mainline code path 2 of 2 for when we
    // miss the DoS cache.
    // ==================================================================================
    KerbErr = VerifyPreAuthWhitelist(piReq, wszName, dwReqStatus);
    if (!KERB_SUCCESS(KerbErr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","VerifyPreAuthWhitelist !KERB_SUCCESS(KerbErr)");
        goto Cleanup;
    }


    // ==================================================================================
    // check for existence of the KRB5_PADATA_XBOX_ECHO data. If it isn't present, we
    // return an error to the client (with the ECHO data in it), and the client will retry
    // the request but include the ECHO data.
    // ==================================================================================
    KerbErr = CheckEchoPreauth(piReq, wszName, pExtendedError, &dwReqStatus);
    if ( !KERB_SUCCESS(KerbErr) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","CheckEchoPreauth !KERB_SUCCESS(KerbErr)");
        goto Cleanup;
    }


    // ==================================================================================
    // IP-based DoS detection (request throttling). Do this after the echo preauth check
    // so some malicious user doesn't spoof an IP address and deny service to an
    // unsuspecting user.
    // ==================================================================================
    CKdcDos* pKdcDos = GetKdcDos();
    UINT64 dosKey = (UINT64)pInAddr->S_un.S_addr;
    KDCDOS_STATUS dosStatus = pKdcDos->Check(dosKey);

    if(dosStatus == KDCDOS_LIMIT_EXCEEDED)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","An Xbox client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client IP: "DBGINAFMT"\n"
            "Hash key: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            dosKey);

        XomNtEvent(
            XEVENT_ASKDC_HACK_DOS_ATTACK,
            "An Xbox client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client IP: "DBGINAFMT"\n"
            "Hash key: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            dosKey);

        dwReqStatus |= REQSTAT_AS_TEMPORARILY_BANNED;
        KerbErr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Cleanup;
    }
    else if(dosStatus == KDCDOS_TEMP_BANNED)
    {
        // Client was previously banned and an event was already logged at that time. To
        // prevent the client from flooding the Nt event log, we're not going to log an
        // event.
        dwReqStatus |= REQSTAT_AS_TEMPORARILY_BANNED;
        KerbErr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Cleanup;
    }
    XOMASSERT(dosStatus == KDCDOS_OK);

    // If the name starts with 'XE.' or 'PC.' then it is a machine identity.
    // In theory, we could look for a '.' in the 3rd character position but ...
    if (_wcsnicmp(wszName, L"XE.", 3) == 0 ||
        _wcsnicmp(wszName, L"PC.", 3) == 0) 
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "XE. or PC.");
        bIsMachineIdentity = TRUE;
    }

    // ==================================================================================
    // Check to see if the PA-DATA contains a secondary identifier
    // 
    // BUG:188506 - The Bucharest (Spring 2011) client will send up XENON_PPA
    // pre-auths with requests for users as well as request for machines. To
    // fix it, for the life of the 360, we must check if the name starts with "XE."
    // before using a XENON_PPA.
    // ==================================================================================
    padata = GetPaData( piReq, KRB5_PADATA_XENON_PPA);
    if (padata != NULL && 
        padata->value != NULL && 
        padata->length == sizeof(XKERB_PA_XENON_PPA) &&
        bIsMachineIdentity == TRUE) 
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","pXenonPPA = (PXKERB_PA_XENON_PPA) padata->value;");
        pXenonPPA = (PXKERB_PA_XENON_PPA) padata->value;
        pbConsoleCertHash = pXenonPPA->abConsoleCertHash;
    }

    // ==================================================================================
    // look up the principal in the UODB.
    // ==================================================================================
    KerbErr = PrincipalLookup( wszName, pbConsoleCertHash, flags, pInAddr, &ulPuid, &dwReqStatus, &pCred, &dwCredSize, &status);
    if ( KerbErr != KDC_ERR_NONE )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","PrincipalLookup KerbErr != KDC_ERR_NONE");
        goto Cleanup;
    }

    if ( IsKrbTgt(pName) )
    {
        XOMASSERT( pName->NameCount > 1 );
        XOMASSERT( pName->Names[1].Buffer );
        lstrcpynW(sPrinc.wszServiceName, KDC_PRINCIPAL_NAME, ARRAYSIZE(sPrinc.wszServiceName));
        lstrcpynW(sPrinc.wszDomainName, pName->Names[1].Buffer, ARRAYSIZE(sPrinc.wszDomainName));
        sPrinc.iType = KRB_NT_SRV_INST;
    }
    else
    {
        lstrcpynW(sPrinc.wszServiceName, wszName, ARRAYSIZE(sPrinc.wszServiceName));
        lstrcpynW(sPrinc.wszDomainName, m_ustrRealmName.Buffer, ARRAYSIZE(sPrinc.wszDomainName));
        sPrinc.iType = KRB_NT_PRINCIPAL;
    }

    // TODO: do any flags need to be specified?
    sPrinc.iFlags = 0;

    pPrinc = new CASPrincipal();
    if ( NULL == pPrinc )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) GetPrincipal: failed to instantiate new principal.", __FILE__, __LINE__);
        XomNtEvent(XEVENT_ASKDC_NO_MEMORY_17, "(%s:%d) GetPrincipal: failed to instantiate new principal.", __FILE__, __LINE__);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) GetPrincipal: failed to instantiate new principal.", __FILE__, __LINE__);
        status = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // initialize the new principal
    status = pPrinc->Initialize(
        this,
        ulPuid,
        pbConsoleCertHash,
        &m_ustrRealmName,
        &sPrinc,
        wszName,
        pCred,
        m_liMaxLifetime,
        liMaxRenewalTime,
        KERB_KDB_DATA_ALL,
        CT_RandomKey,
        (bIsMachineIdentity ? IA_MACHINE : IA_USER)
        );

    if ( !NT_SUCCESS(status) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Initialize !NT_SUCCESS(status)");
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: (%s:%d) GetPrincipal: failed to initialize new principal, status = %d.", __FILE__, __LINE__, status);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) GetPrincipal: failed to initialize new principal, status = %d.", __FILE__, __LINE__, status);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    *ppIPrincipal = static_cast<IKerbPrincipal*>(pPrinc);
    pPrinc = NULL;

	logtfile546("c:\\askdc-ASProvider-cpp.log","successfully: (%s:%d) GetPrincipal: successfully instantiated principal for '%S'.", __FILE__, __LINE__, wszName);
    XomTrace(ASkdc, L_LOW, "(%s:%d) GetPrincipal: successfully instantiated principal for '%S'.", __FILE__, __LINE__, wszName);

    dwReqStatus |= REQSTAT_AS_SUCCESSFUL_VALIDATION;

Cleanup:

    if ( pPrinc )
    {
        pPrinc->Release();
        pPrinc = NULL;
    }

    pExtendedError->status = status;

    return KerbErr;
}

KERBERR
CASProvider::GetPrincipalByPassport(
    IN  GET_PRINC_FLAGS      flags,
    IN  PKERB_INTERNAL_NAME  pName,
    IN  LPCWSTR              pcwszRealm,
    IN  IKerbRequest        *piReq,
    OUT PIKerbPrincipal     *ppIPrincipal,
    OUT PKERB_EXT_ERROR      pExtendedError,
    OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm,
    IN OUT DWORD             &dwReqStatus
    )
{
    BOOL bIsMachineIdentity = FALSE;
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS status = STATUS_SUCCESS;
    WCHAR wszName[100] = {0};
    XkdcCredential *pCred = NULL;
    DWORD dwCredSize = 0;
    HRESULT hr;
    UINT64 xboxUserId = 0;
    XKDC_PRINCIPAL sPrinc = {0};
    CASPrincipal *pPrinc = NULL;
    LARGE_INTEGER liMaxRenewalTime = {0};
    CPaPassportAuthentication* pPassportAuth = NULL;

    XOMASSERT(flags & KDC_KDB_GET_PRINC_CLIENT);

    dwReqStatus |= REQSTAT_AS_PASSPORT_AUTH_DETECTED;

    // The PC doesn't even know the gamertag of the user at the time of the
    // request.  All it has is a passport ticket. Therefore it doesn't have much
    // to pass in as the client name. So it will pass a fixed string.

    if(pName->NameCount != 1 ||
       wcsicmp(pName->Names[0].Buffer, c_PcUserPrincipalName) != 0)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Invalid client name for Passport authenticated request.\n"
            "NameCount = %u, Name[0] = %S",
            pName->NameCount,
            pName->NameCount > 0 ? pName->Names[0].Buffer : L"(null)");
        XomNtEvent(
            XEVENT_ASKDC_HACK_INVALID_REQUEST,
            "Invalid client name for Passport authenticated request.\n"
            "NameCount = %u, Name[0] = %S",
            pName->NameCount,
            pName->NameCount > 0 ? pName->Names[0].Buffer : L"(null)");
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_NO_RESPONSE");
        KerbErr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Cleanup;
    }

    // Process the passport preauth now. If it checks OK, it will give us an user
    // passport-id that we can use to try to map to an Xbox account.

    status = piReq->GetPAHandler(
        CPaPassportAuthentication::GetGuid(),
        (void**)&pPassportAuth);

    if(!NT_SUCCESS(status))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: GetPAHandler !NT_SUCCESS(status)");
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Failed to get passport authentication pa-handler");
        XOMASSERT(!"Failed to get passport authentication pa-handler");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    KerbErr = pPassportAuth->Process(piReq);

    if(!KERB_SUCCESS(KerbErr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Process !KERB_SUCCESS(KerbErr)");
        goto Cleanup;
    }

    // @@@ DoS detection

    // Using passport auth. The client name is NOT the xbox gamertag. To retrieve the
    // gamertag we're going to make 2 extra trips to the database. One to retrieve
    // the xbox-user-id based on the passport-user-id in the preauth's ticket and
    // another to retrieve the gamertag based on the xbox-user-id.

    hr = GetXboxUserByPassport(pPassportAuth->GetPassportPuid(), &xboxUserId);

    if(FAILED(hr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: GetXboxUserByPassport FAILED(hr)");
        if(hr == XONLINE_E_ACCOUNTS_INVALID_USER)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: XONLINE_E_ACCOUNTS_INVALID_USER");
            // Couldn't find an xbox account linked to the passport id in the ticket
            KerbErr = KDC_ERR_C_PRINCIPAL_UNKNOWN;
            goto Cleanup;
        }
        else if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_SERVICE_NOTYET");
            KerbErr = KDC_ERR_SERVICE_NOTYET;
            goto Cleanup;
        }
        else
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_SVC_UNAVAILABLE");
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
            goto Cleanup;
        }
    }

    dwReqStatus |= REQSTAT_AS_GET_USER_BY_PASSPORT;

    // Now the trip to retrieve the gamertag based on the xboxUserId

    hr = GetGamertagByUserId(xboxUserId, wszName);

    if(FAILED(hr))
    {
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_SERVICE_NOTYET");
            KerbErr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_SVC_UNAVAILABLE");
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        }
        goto Cleanup;
    }

    dwReqStatus |= REQSTAT_AS_GET_GAMERTAG_BY_USER_ID;

    lstrcpynW(sPrinc.wszServiceName, wszName, ARRAYSIZE(sPrinc.wszServiceName));
    lstrcpynW(sPrinc.wszDomainName, m_ustrRealmName.Buffer, ARRAYSIZE(sPrinc.wszDomainName));
    sPrinc.iType = KRB_NT_PRINCIPAL;
    sPrinc.iFlags = 0;

    // Use the key obtained from the passport authdata as the client key

    dwCredSize = sizeof(XkdcCredential) +
        c_dwMaxNumberOfKeys * (sizeof(XkdcKey) + XKDC_KEYSIZE);

    pCred = (XkdcCredential*) KdcAllocMemory(dwCredSize);

    if(!pCred)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: if(!pCred)");
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_SVC_UNAVAILABLE");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    ZeroMemory(pCred, dwCredSize);

    pCred->dwKeyCount                 = 1;
    pCred->Key[0].dwKeyVersion        = 1;
    pCred->Key[0].Key.keytype         = KERB_ETYPE_RC4_HMAC_NT;
    pCred->Key[0].Key.keyvalue.length = XKDC_KEYSIZE;
    pCred->Key[0].Key.keyvalue.value  = ((BYTE*)pCred) + dwCredSize - XKDC_KEYSIZE;

    pPassportAuth->GetClientKey(pCred->Key[0].Key.keyvalue.value);

    // Use Passport preauth handler with xbox-user-id and gamertag so that it can
    // return it to the client with the response.

    pPassportAuth->SetAccountInfo(xboxUserId, CTinyStr().Format("%S", wszName).cstr());
	
    pPrinc = new CASPrincipal();
    if ( NULL == pPrinc )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Failed to instantiate new principal.");
        XomNtEvent(XEVENT_ASKDC_NO_MEMORY_17, "Failed to instantiate new principal.");
        status = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // initialize the new principal

    status = pPrinc->Initialize(
        this,
        xboxUserId,
        NULL,
        &m_ustrRealmName,
        &sPrinc,
        wszName,
        pCred,
        m_liMaxLifetime,
        liMaxRenewalTime,
        KERB_KDB_DATA_ALL,
        CT_RawPassport,
        (bIsMachineIdentity ? IA_MACHINE : IA_USER)
        );

    if ( !NT_SUCCESS(status) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: pPrinc->Initialize !NT_SUCCESS(status)");
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_SVC_UNAVAILABLE");
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    // pCred belongs now to pPrinc
    pCred = NULL;

    // Return Principal to caller

    *ppIPrincipal = static_cast<IKerbPrincipal*>(pPrinc);
    pPrinc = NULL;

	logtfile546("c:\\askdc-ASProvider-cpp.log","successfully: GetPrincipalByPassport: successfully instantiated principal for '%S'.",
        wszName);
    XomTrace(
        ASkdc, L_LOW,
        "GetPrincipalByPassport: successfully instantiated principal for '%S'.",
        wszName);

    dwReqStatus |= REQSTAT_AS_SUCCESSFUL_VALIDATION;

Cleanup:

    if(pPrinc)
    {
        pPrinc->Release();
        pPrinc = NULL;
    }

    if(pCred)
    {
        KdcFreeMemory(pCred);
        pCred = NULL;
    }

    pExtendedError->status = status;


	logtfile546("c:\\askdc-ASProvider-cpp.log","GetPrincipalByPassport: KerbErr: 0x%X", KerbErr);
    return KerbErr;
}

#define DBGIPPRM(x) \
    ((x)      ) & 0xFF, \
    ((x) >>  8) & 0xFF, \
    ((x) >> 16) & 0xFF, \
    ((x) >> 24) & 0xFF

VOID
CASProvider::BuildEchoPreauth(
    DWORD               clientIp,
    OUT PKERB_EXT_ERROR pExtendedError)
{
    XKERB_PA_XBOX_ECHO echoData = {0};
    XOCryptoIVStruct   ivStruct = {0};
    LARGE_INTEGER      liNow = {0};

    GetSystemTimeAsFileTime((PFILETIME)&liNow);

    // Set echo data fields
    echoData.dwIpAddr = clientIp;
    echoData.liTimestamp = liNow;
    if (!XOCryptGenRandom(echoData.abRandomBits, sizeof(echoData.abRandomBits)))
    {
        // Log an error but continue request. No random bits, not a huge deal

        DWORD dwError = GetLastError();
        XomNtEvent(XEVENT_ASKDC_CRYPTO_FAILURE,
                   "XOCryptGenRandom failed, GetLastError=0x%08X. IP="DBGINAFMT,
                   dwError, DBGIPPRM(clientIp));
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: XOCryptGenRandom failed, GetLastError=0x%08X. IP="DBGINAFMT,
                   dwError, DBGIPPRM(clientIp));

    }
    echoData.checksum = echoData.ComputeChecksum();

    // Encrypt it using no IV. Since we're only encrypting 1 block, and it contains some
    // random bits, this is ok.
    C_ASSERT(sizeof(echoData.abEncryptedData) == AES_BLOCKLEN);
    m_pEchoDataKey->EncryptWithIv(
        echoData.abEncryptedData,
        sizeof(echoData.abEncryptedData),
        &ivStruct,
        echoData.abEncryptedData);  // encrypt in place

    // Set the necessary kerberos extended error fields so that this gets sent to the
    // client correctly. See the code in tickets.cxx.
    C_ASSERT(sizeof(pExtendedError->echo_data) >= sizeof(XKERB_PA_XBOX_ECHO));
    pExtendedError->echo_length = sizeof(XKERB_PA_XBOX_ECHO);
    memcpy(pExtendedError->echo_data, &echoData, pExtendedError->echo_length);

    SYSTEMTIME st;
    FileTimeToSystemTime((PFILETIME)&liNow, &st );
	logtfile546("c:\\askdc-ASProvider-cpp.log","%s["DBGINAFMT"]: Echo data ("DBGINAFMT","DBGSYSTEMTIMEFMT")",
              __FUNCTION__, DBGIPPRM(clientIp), DBGIPPRM(clientIp), DBGSYSTEMTIMEPRM(&st));

    XomTrace(ASkdc, L_NORMAL, "%s["DBGINAFMT"]: Echo data ("DBGINAFMT","DBGSYSTEMTIMEFMT")",
              __FUNCTION__, DBGIPPRM(clientIp), DBGIPPRM(clientIp), DBGSYSTEMTIMEPRM(&st));
}


// ---------------------------------------------------------------------------------------
// CheckEchoPreauth - verifies existence of the KRB5_PADATA_XBOX_ECHO preauth if required,
// and makes sure it is valid. May abort a request with KDC_ERR_PREAUTH_REQUIRED error and
// return proper "echo data" to the client.
// ---------------------------------------------------------------------------------------
KERBERR
CASProvider::CheckEchoPreauth(
    IN  IKerbRequest *      piReq,
    IN  LPCWSTR             pwszName,
    OUT PKERB_EXT_ERROR     pExtendedError,
    OUT DWORD *             pdwReqStat)
{
    // System disabled?
    if (!m_bCheckEchoPreauth)
    {
        return KDC_ERR_NONE;
    }

    // Validate parameters
    XOMASSERT(piReq);
    XOMASSERT(pwszName);
    XOMASSERT(pExtendedError);
    XOMASSERT(pdwReqStat);

    if (NULL == piReq ||
        NULL == pwszName ||
        NULL == pExtendedError ||
        NULL == pdwReqStat)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: CheckEchoPreauth: invalid parameters");
        XomNtEvent(XEVENT_ASKDC_BAD_PARAMETER_4, "CheckEchoPreauth: invalid parameters");
        return KDC_ERR_SVC_UNAVAILABLE;
    }

    KERBERR             KerbErr         = KDC_ERR_NONE;
    ASN1octetstring_t*  padata          = NULL;
    PXKERB_PA_XBOX_ECHO pEchoData       = NULL;
    XOCryptoIVStruct    ivStruct        = {0};
    //WORD clientPort      = htons(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_port);
    DWORD               clientIp        = (((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr.S_un.S_addr);

    // Look for pre-auth structure. Return echo data if not found.
    padata = GetPaData(piReq, KRB5_PADATA_XBOX_ECHO);
    if(!padata)
    {
        //g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_NOTPRESENT_RATE, 1);
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: %s["DBGINAFMT",%S]: KRB5_PADATA_XBOX_ECHO preauth not found",
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName);
        XomTrace(ASkdc, L_NORMAL, "%s["DBGINAFMT",%S]: KRB5_PADATA_XBOX_ECHO preauth not found",
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName);
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_PREAUTH_REQUIRED");
        KerbErr = KDC_ERR_PREAUTH_REQUIRED;
        goto Exit;
    }

    if (padata->value == NULL ||
        padata->length != sizeof(XKERB_PA_XBOX_ECHO))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: CheckEchoPreauth: bad XKERB_PA_XBOX_ECHO structure.\n"
                   "padata->value: %s, padata->length: %d (expected %d), "
                   "IP: "DBGINAFMT", Principal: %S",
                   padata->value == NULL ? "NULL" : "not NULL",
                   padata->length, sizeof(XKERB_PA_XBOX_ECHO),
                   DBGIPPRM(clientIp), pwszName);
        KerbErr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        XomNtEvent(XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH_1,
                   "CheckEchoPreauth: bad XKERB_PA_XBOX_ECHO structure.\n"
                   "padata->value: %s, padata->length: %d (expected %d), "
                   "IP: "DBGINAFMT", Principal: %S",
                   padata->value == NULL ? "NULL" : "not NULL",
                   padata->length, sizeof(XKERB_PA_XBOX_ECHO),
                   DBGIPPRM(clientIp), pwszName);
        KerbErr = SilentKerbErr(KDC_ERR_PREAUTH_FAILED);
        goto Exit;
    }

    pEchoData = (PXKERB_PA_XBOX_ECHO)padata->value;

    // Validate the echo value.
    // 1. Decrypt
    // 2. Is checksum valid?
    // 3. Does ip match?
    // 4. Is time window ok?

    *pdwReqStat |= REQSTAT_AS_FOUND_ECHO_PREAUTH;
	logtfile546("c:\\askdc-ASProvider-cpp.log","%s["DBGINAFMT",%S]: Found KRB5_PADATA_XBOX_ECHO preauth",
             __FUNCTION__, DBGIPPRM(clientIp), pwszName);

    XomTrace(ASkdc, L_LOW, "%s["DBGINAFMT",%S]: Found KRB5_PADATA_XBOX_ECHO preauth",
             __FUNCTION__, DBGIPPRM(clientIp), pwszName);

    m_pEchoDataKey->Decrypt(
        &ivStruct,  // all zeroes
        pEchoData->abEncryptedData,
        sizeof(pEchoData->abEncryptedData),
        pEchoData->abEncryptedData);  // decrypt in place

    BYTE checksum = pEchoData->ComputeChecksum();
    if (checksum != pEchoData->checksum)
    {
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_CHECKSUM_RATE, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_CHECKSUM_TOTAL, 1);
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: %s["DBGINAFMT",%S]: Corrupted cipher text, got checksum %d, computed %d",
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName, pEchoData->checksum, checksum);

        XomTrace(ASkdc, L_HIGH, "%s["DBGINAFMT",%S]: Corrupted cipher text, got checksum %d, computed %d",
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName, pEchoData->checksum, checksum);
        KerbErr = KDC_ERR_PREAUTH_REQUIRED;
        goto Exit;
    }

    if (clientIp != pEchoData->dwIpAddr)
    {
        // No match. Hacker?
        // @@@ applog
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_IP_RATE, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_IP_TOTAL, 1);
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: %s["DBGINAFMT",%S]: Echo data IP ("DBGINAFMT") does not match request ("DBGINAFMT")",
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName, DBGIPPRM(pEchoData->dwIpAddr), DBGIPPRM(clientIp));
        XomTrace(ASkdc, L_ERROR, "%s["DBGINAFMT",%S]: Echo data IP ("DBGINAFMT") does not match request ("DBGINAFMT")",
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName, DBGIPPRM(pEchoData->dwIpAddr), DBGIPPRM(clientIp));
        KerbErr = KDC_ERR_PREAUTH_REQUIRED;
        goto Exit;
    }

    LARGE_INTEGER liMinValidTime;
    GetSystemTimeAsFileTime((PFILETIME)&liMinValidTime);
    liMinValidTime.QuadPart -= m_liEchoLifetime.QuadPart;
    if (liMinValidTime.QuadPart > pEchoData->liTimestamp.QuadPart)
    {
        // @@@ applog
        SYSTEMTIME st;
        FileTimeToSystemTime((PFILETIME)&pEchoData->liTimestamp, &st );
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_TIMESTAMP_RATE, 1);
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_TIMESTAMP_TOTAL, 1);
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: %s["DBGINAFMT",%S]: Echo data timestamp expired at "DBGSYSTEMTIMEFMT,
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName, DBGSYSTEMTIMEPRM(&st));
        XomTrace(ASkdc, L_ERROR, "%s["DBGINAFMT",%S]: Echo data timestamp expired at "DBGSYSTEMTIMEFMT,
                 __FUNCTION__, DBGIPPRM(clientIp), pwszName, DBGSYSTEMTIMEPRM(&st));
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_PREAUTH_REQUIRED");
        KerbErr = KDC_ERR_PREAUTH_REQUIRED;
        goto Exit;
    }

    // Checks out, sweeet.
    g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_SUCCESS_RATE, 1);

Exit:

    // Every request, success and failure, needs to increment this
    g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_PERCENT_BASE, 1);

    if (KerbErr == KDC_ERR_PREAUTH_REQUIRED)
    {
        g_Counters.IncrementValue32(ASKDCPERF_SERVER_ECHO_FAIL_TOTAL_RATE, 1);
        g_Counters.IncrementValue64(ASKDCPERF_SERVER_ECHO_FAIL_PERCENT, 100);  // x 100 to make it a percent
        BuildEchoPreauth(clientIp, pExtendedError);
    }

    return KerbErr;
}

//------------------------------------------------------------------
// Verify that all required pre-auth types, and only them, were specified in the request.
// This is our pre-auth whitelist. It depends on the type of request, which we will
// attempt to determine based on which preauths are included.
//------------------------------------------------------------------
KERBERR
CASProvider::VerifyPreAuthWhitelist(
    IN  IKerbRequest        *piReq,
    PWCHAR                  pwszName,
    DWORD                   &dwReqStatus)
{
    BOOL                bIsValid    = FALSE;
    KERBERR             KerbErr     = KDC_ERR_NONE;
    in_addr*            pInAddr     = &(((PSOCKADDR_IN)piReq->GetClientAddress())->sin_addr);

    // Verify that all required pre-auth types, and only them, were specified in
    // the request.

    static const UINT32 AllowedPreAuth[] = {
        KRB5_PADATA_ENC_TIMESTAMP,          // standard kerberos encryped timestamp
    };

    // Notes:
    // KRB5_PADATA_XBOX_PPA is sent by older Xenon Clients. We can't remove it 
    // from the list
    // 
    // KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION is to allow 
    // CPaEncryptPassportAuthentication structures. 

    static const UINT32 OptionalPreAuth[] = {
        KRB5_PADATA_XBOX_PPA,               // client uses this to prove it is valid (legacy)
        KRB5_PADATA_XBOX_CLIENT_VERSION,    // client version
        KRB5_PADATA_XBOX_ECHO,              // 
        KRB5_PADATA_XENON_PPA,              // client uses this to prove it is valid
        KRB5_PADATA_COMPOUND_IDENTITY,      // authenticates multiple identities. not present in first request.
        KRB5_PADATA_PAC_REQUEST_EX,         // Depracated. Always sends back XBOX_IDENTITY
        KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION, 
    };

    bIsValid = VerifyPaList(
        piReq,
        AllowedPreAuth, 
        ARRAY_SIZE(AllowedPreAuth),
        OptionalPreAuth, 
        ARRAY_SIZE(OptionalPreAuth)
        );
    if (bIsValid == FALSE)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Either the request does not contain all required pre-auths, "
            "the request specified an invalid pre-auth type or "
            "a pre-auth type was specified more than once.\n"
            "Client Name: %S\n"
            "Client IP: "DBGINAFMT"\n",
            pwszName,
            DBGINAPRM(pInAddr)); 
        XomNtEvent(
            XEVENT_ASKDC_HACK_INVALID_PRE_AUTH_TYPE,
            "Either the request does not contain all required pre-auths, "
            "the request specified an invalid pre-auth type or "
            "a pre-auth type was specified more than once.\n"
            "Client Name: %S\n"
            "Client IP: "DBGINAFMT"\n",
            pwszName,
            DBGINAPRM(pInAddr));
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_NO_RESPONSE");
        KerbErr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Cleanup;
    }

    // If KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION is present, then
    // we also require KRB5_PADATA_COMPOUND_IDENTITY
    if (GetPaData(piReq, KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION) != NULL &&
        GetPaData(piReq, KRB5_PADATA_COMPOUND_IDENTITY)                 == NULL) 
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: The request does not contain all required pre-auths. "
            "The request contains a KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION "
            "but does not contain KRB5_PADATA_COMPOUND_IDENTITY.\n"
            "Client Name: %S\n"
            "Client IP: "DBGINAFMT"\n",
            pwszName,
            DBGINAPRM(pInAddr));
        XomNtEvent(
            XEVENT_ASKDC_HACK_INVALID_PRE_AUTH_TYPE,
            "The request does not contain all required pre-auths. "
            "The request contains a KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION "
            "but does not contain KRB5_PADATA_COMPOUND_IDENTITY.\n"
            "Client Name: %S\n"
            "Client IP: "DBGINAFMT"\n",
            pwszName,
            DBGINAPRM(pInAddr));
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_NO_RESPONSE");
        KerbErr = SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Cleanup;
    }
    dwReqStatus |= REQSTAT_AS_VERIFIED_PRE_AUTH_LIST;

Cleanup:
    return KerbErr;

}

NTSTATUS
CASProvider::LoadConfig()
{
    NTSTATUS status = STATUS_SUCCESS;
    HRESULT hr = S_OK;

    m_bCheckEchoPreauth          = GetDWORDSetting( Setting_kdcsvc_askdc_echo_enabled, 1 );
    m_bCheckForDos               = GetDWORDSetting( Setting_kdcsvc_askdc_checkForDos, 1);
    m_cDosCacheEntries           = GetDWORDSetting( Setting_kdcsvc_askdc_DoS_numEntries, 5000 );
    m_cCacheTimeMilliseconds     = GetDWORDSetting( Setting_kdcsvc_askdc_DoS_cacheTimeMillis, 1000 );
    m_cCacheHitIntervalMilliseconds = GetDWORDSetting( Setting_kdcsvc_askdc_DoS_tooSoonTimeMillis, 1000 );
    g_dwKeyVersion               = GetDWORDSetting( Setting_kdcsvc_askdc_keyVersion, 1 );
    m_KdcPolicy.TimeSkew.QuadPart =
        (LONGLONG) 10000000 *
        GetDWORDSetting( Setting_kdcsvc_askdc_timeSkewSeconds, 120);
    m_liEchoLifetime.QuadPart =
        (LONGLONG) 10000000 *
        GetDWORDSetting( Setting_kdcsvc_askdc_echo_lifetimeInSeconds, 300);
    return status;
}

CXBaseProvider::VALIDATE_SETTING_RESULT
CALLBACK
CASProvider::ValidateSetting(
    CComBSTR &SettingChange
    )
{
    static const CComBSTR aValidSettings[] = {
        Setting_kdcsvc_askdc_timeSkewSeconds,
        Setting_kdcsvc_askdc_keyVersion,
        Setting_kdcsvc_askdc_DoS_cacheTimeMillis,
        Setting_kdcsvc_askdc_DoS_tooSoonTimeMillis,
        Setting_kdcsvc_askdc_DoS2_enabled,
        Setting_kdcsvc_askdc_DoS2_cacheSize,
        Setting_kdcsvc_askdc_DoS2_maxRequests,
        Setting_kdcsvc_askdc_DoS2_interval,
        Setting_kdcsvc_askdc_DoS2_blockingTime,
        Setting_kdcsvc_askdc_echo_enabled,
        Setting_kdcsvc_askdc_echo_lifetimeInSeconds,
        Setting_kdcsvc_askdc_machine_allowLegacyKey 
    };

    VALIDATE_SETTING_RESULT result = SETTING_DONT_CARE;

    for(int i=0; i < ARRAYSIZE(aValidSettings); i++)
    {
        if(SettingChange == aValidSettings[i])
        {
            result = SETTING_ACCEPTED;
        }
    }

    return result;
}

void
CALLBACK
CASProvider::ApplySetting(
    CComBSTR &SettingChange,
    CComBSTR &bsValueNew
    )
{
    HRESULT hr = S_OK;

	logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::ApplySetting(%ws) called.",
        static_cast<wchar_t *> (SettingChange)
        );
    XomNtEvent(
        XEVENT_KDC_INFO_7,
        "CASProvider::ApplySetting(%ws) called.",
        static_cast<wchar_t *> (SettingChange)
        );

    //
    // Hold the config write lock
    //
    ConfigWriteLock();

    //
    // Take action based upon which setting we are asked to change
    //
    if (SettingChange == Setting_kdcsvc_askdc_timeSkewSeconds)
    {
        //
        // Update the global variable attached to this setting
        //
        m_KdcPolicy.TimeSkew.QuadPart =
            (LONGLONG) 10000000 *
            _wtoi( bsValueNew );
    }
    else if (SettingChange == Setting_kdcsvc_askdc_keyVersion)
    {
        //
        // Update the global variable attached to this setting
        //
        g_dwKeyVersion = _wtoi( bsValueNew );
    }
    else if (SettingChange == Setting_kdcsvc_askdc_DoS_cacheTimeMillis)
    {
        //
        // Update the internal state
        //
        m_cCacheTimeMilliseconds = _wtoi( bsValueNew );

        //
        // Update the global variable attached to this setting
        //
        g_qwCacheTime = (LONGLONG) 10000 * m_cCacheTimeMilliseconds;
    }
    else if (SettingChange == Setting_kdcsvc_askdc_DoS_tooSoonTimeMillis)
    {
        m_cCacheHitIntervalMilliseconds = _wtoi( bsValueNew );
        g_qwCacheHitInterval = (LONGLONG) 10000 * m_cCacheHitIntervalMilliseconds;
    }

    //
    // Done with the setting change
    //
    ConfigWriteUnlock();

    // The following don't require the ConfigWriteLock

    if(SettingChange == Setting_kdcsvc_askdc_DoS2_enabled)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetEnabled(value))
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_enabled: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_enabled: %u \n",
                value);
        }

    }
    else if(SettingChange == Setting_kdcsvc_askdc_DoS2_maxRequests)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetMaxRequests(value))
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_maxRequests: %u \n",
                value); 
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_maxRequests: %u \n",
                value);
        }
    }
    else if(SettingChange == Setting_kdcsvc_askdc_DoS2_interval)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetInterval(value))
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_interval: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_interval: %u \n",
                value);
        }
    }
    else if(SettingChange == Setting_kdcsvc_askdc_DoS2_blockingTime)
    {
        UINT32 value = wcstoul(bsValueNew, NULL, 0);
        if (!m_Dos2.SetBlockingTime(value))
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_blockingTime: %u \n",
                value);
            XomNtEvent(
                XEVENT_KDC_FAILED_TO_CONFIG_DOS_DETECTION,
                "Failed to reconfigure DoS detection. Verify that the following settings "
                "contain valid parameters: \n"
                " kdcsvc_askdc_DoS2_blockingTime: %u \n",
                value);
        }
    }
    else if (SettingChange == Setting_kdcsvc_askdc_echo_enabled)
    {
        m_bCheckEchoPreauth = wcstoul(bsValueNew, NULL, 0);
    }
    else if (SettingChange == Setting_kdcsvc_askdc_echo_lifetimeInSeconds)
    {
        m_liEchoLifetime.QuadPart =
            (LONGLONG) 10000000 *
            _wtoi( bsValueNew );
    }

    //
    // Done
    //
    return;
}

NTSTATUS
CASProvider::InitializeExtensionHandlers()
{
    NTSTATUS status = STATUS_SUCCESS;

    // Register factory class for authdata handler
    CAsADHandlerFactory *pAD = new CAsADHandlerFactory(this);
    if ( NULL == pAD )
    {
        status = STATUS_SERVER_DISABLED;
        goto Cleanup;
    }

    // save a reference so it can be deleted on unload
    g_pADFactory = pAD;

    IADHandlerFactory *pIADFactory = static_cast<IADHandlerFactory*>(pAD);
    pAD = NULL;
    KdcRegisterADHandlerFactory(pIADFactory);

    // Passport-Authentication preauth
    g_PassportAuthPAHandlerFactory.SetContext(this);
    KdcRegisterPAHandlerFactory(&g_PassportAuthPAHandlerFactory);

    // Encrypted Passport-Authentication preauth
    g_EncryptedPassportAuthPAHandlerFactory.SetContext(this);
    KdcRegisterPAHandlerFactory(&g_EncryptedPassportAuthPAHandlerFactory);

Cleanup:
    return status;
}

NTSTATUS
CASProvider::SetPassportKeyVersion(
    IN  DWORD dwKeyVersion)
{
    NTSTATUS status = STATUS_NOT_FOUND;

    ConfigReadLock();

    // find the krbtgt/PASSPORT.NET principal and set its key version
    for (int i=0; i < m_cPrinc; i++)
    {
        if ( 0 == _wcsnicmp(
                    PASSPORT_KERBEROS_REALM_L,
                    m_ppPrinc[i]->GetName()->Names[1].Buffer,
                    m_ppPrinc[i]->GetName()->Names[1].Length ) )
        {
            status = m_ppPrinc[i]->SetEncryptionKeyVersion(dwKeyVersion);
            break;
        }
    }

    ConfigReadUnlock();

    if ( !NT_SUCCESS(status) )
    {
        if ( STATUS_NOT_FOUND == status )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: STATUS_NOT_FOUND == status"); 
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: (%s:%d) SetPassportKeyVersion: version %d not found.", __FILE__, __LINE__, dwKeyVersion);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) SetPassportKeyVersion: version %d not found.", __FILE__, __LINE__, dwKeyVersion);
        }
        else
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: (%s:%d) SetPassportKeyVersion: failed with status 0x%08X.", __FILE__, __LINE__, status);
            XomTrace(ASkdc, L_ERROR, "(%s:%d) SetPassportKeyVersion: failed with status 0x%08X.", __FILE__, __LINE__, status);
        }
    }
    else
    {
        // Update m_dwPassportKeyVersion so that this key version is still used
        // after a reload is performed.
        m_dwPassportKeyVersion = dwKeyVersion;

		logtfile546("c:\\askdc-ASProvider-cpp.log", "SetPassportKeyVersion: key version now set to %d.", dwKeyVersion);
        XomNtEvent(XEVENT_ASKDC_SET_PASSPORT_KEY_VERSION, "SetPassportKeyVersion: key version now set to %d.", dwKeyVersion);

		logtfile546("c:\\askdc-ASProvider-cpp.log","(%s:%d) SetPassportKeyVersion: key version now set to %d.", __FILE__, __LINE__, dwKeyVersion);
        XomTrace(ASkdc, L_NORMAL, "(%s:%d) SetPassportKeyVersion: key version now set to %d.", __FILE__, __LINE__, dwKeyVersion);
    }

    return status;
}

// Implement health checks
HRESULT CASProvider::HealthCheck(IN DWORD dwRequestId,IN CXomControlResponseInterface *pResponseInterface)
{
    BOOL     bFailed = FALSE;
    CHAR     szResponse[MAX_MGMT_RESPONSE_SIZE];
    CComBSTR bstrSetting;
    CComBSTR bstrEnum[] = {
        Setting_kdcsvc_askdc_timeSkewSeconds,
        Setting_kdcsvc_askdc_keyVersion,
        Setting_kdcsvc_askdc_checkForDos,
        Setting_kdcsvc_askdc_DoS_cacheTimeMillis,
        Setting_kdcsvc_askdc_DoS_numEntries,
        Setting_kdcsvc_askdc_DoS_tooSoonTimeMillis,
        Setting_kdcsvc_askdc_DoS2_enabled,
        Setting_kdcsvc_askdc_DoS2_cacheSize,
        Setting_kdcsvc_askdc_DoS2_maxRequests,
        Setting_kdcsvc_askdc_DoS2_interval,
        Setting_kdcsvc_askdc_DoS2_blockingTime,
        Setting_kdcsvc_askdc_echo_enabled,
        Setting_kdcsvc_askdc_echo_lifetimeInSeconds,
        Setting_kdcsvc_askdc_machine_allowLegacyKey 
        };
    HRESULT  hr = S_OK;
    int      dwOffset = 0;
    int      i;

    for (i = 0; i < ARRAYSIZE(bstrEnum); i++)
    {
        hr = m_pConfig->GetSetting( bstrEnum[i], &bstrSetting );
        if (FAILED(hr))
        {
            bFailed = TRUE;

			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: GetSetting FAILED(hr)");
            dwOffset += _snprintf(
                szResponse + dwOffset,
                sizeof(szResponse) - dwOffset,
                "ASKDC: GetSetting( %ws ) = 0x%08lx",
                static_cast<wchar_t *>(bstrEnum[i]),
                hr
                );

			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: ASKDC: GetSetting( %ws ) = 0x%08lx",
                static_cast<wchar_t *>(bstrEnum[i]),
                hr
                );

        }
    }

    if (!bFailed)
    {
        dwOffset += _snprintf(
            szResponse + dwOffset,
            sizeof(szResponse) - dwOffset,
            "ASKDC: All Settings Read.\r\n"
            );

		logtfile546("c:\\askdc-ASProvider-cpp.log","ASKDC: All Settings Read.\r\n"
            );
    }

    // display the response
    pResponseInterface->WriteResponse(
        dwRequestId,
        (BYTE*) szResponse,
        (DWORD) -1
        );
    return S_OK;
}


const KDC_POLICY_VALUES* __stdcall CASProvider::GetKdcPolicy()
{
    return &m_KdcPolicy;
}

KERBERR
CASProvider::PrincipalLookup(
    IN WCHAR *wszName,
    IN BYTE *pbConsoleCertHash,
    IN GET_PRINC_FLAGS flags,
    IN IN_ADDR* pInAddr,
    IN OUT ULONGLONG * pulPUID,
    IN OUT DWORD *pdwReqStatus,
    OUT XkdcCredential **ppCred,
    OUT DWORD *pdwCredSize,
    OUT NTSTATUS *pStatus )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    HRESULT hr = S_OK;
    CComBSTR bstrName;
    AskdcPrincipal * pPrincipals = NULL;
    unsigned long cPrincipals = 0;
    CAskdcPrincipalAutoPtr askdcPrincipalAutoPtr(&pPrincipals, &cPrincipals);

	logtfile546("c:\\askdc-ASProvider-cpp.log","called PrincipalLookup");

    // get the bstr version of the given name.
    bstrName.Attach(SysAllocString( wszName ));
    if ( bstrName == NULL )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: (%s:%d) PrincipalLookup: Failed to calculate the parition from the given hash.  Result = 0x%X", __FILE__, __LINE__, hr);

        XomNtEvent(XEVENT_ASKDC_WSREADER_ERROR_20, "(%s:%d) PrincipalLookup: Failed to calculate the parition from the given hash.  Result = 0x%X", __FILE__, __LINE__, hr);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) PrincipalLookup: Failed to calculate the parition from the given hash.  Result = 0x%x", __FILE__, __LINE__, hr );
        *pStatus = STATUS_UNSUCCESSFUL;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }

    //Did we get a secondary identifier?
    if (pbConsoleCertHash == NULL) 
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: (pbConsoleCertHash == NULL)");
        // Assume that this is either a user or a legacy console, and 
        // execute command on UODB
        hr = m_pManagedProxy->AskdcGetPrincipal(
            bstrName, 
            &pPrincipals, 
            &cPrincipals
            );
    }
    else
    {
        SAFEARRAY saConsoleCertHash = {0};

        SetupSafeArray(
            &saConsoleCertHash,
            XONLINE_PPA_HASH_SIZE,
            pbConsoleCertHash
            );

		logtfile546("c:\\askdc-ASProvider-cpp.log","AskdcGetPrincipalMachineXenon");

        // Execute the command for a xenon console with secondary identifier
        hr = m_pManagedProxy->AskdcGetPrincipalMachineXenon(
            bstrName, 
            &saConsoleCertHash, 
            &pPrincipals, 
            &cPrincipals
            );

		logtfile546("c:\\askdc-ASProvider-cpp.log","cPrincipals: %i", cPrincipals);
    }

    *pdwReqStatus |= REQSTAT_AS_PRINC_FOUND_IN_DB;

    *pdwCredSize = sizeof(XkdcCredential) +
        c_dwMaxNumberOfKeys * (sizeof(XkdcKey) + XKDC_KEYSIZE);

    *ppCred = (XkdcCredential*) KdcAllocMemory(*pdwCredSize);
    if ( NULL == *ppCred )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: (%s:%d) PrincipalLookup: failed to allocate %d bytes for keys.", __FILE__, __LINE__, *pdwCredSize);
        XomNtEvent(XEVENT_ASKDC_NO_MEMORY_20, "(%s:%d) PrincipalLookup: failed to allocate %d bytes for keys.", __FILE__, __LINE__, *pdwCredSize);
        XomTrace(ASkdc, L_ERROR, "(%s:%d) PrincipalLookup: failed to allocate %d bytes for keys.", __FILE__, __LINE__, *pdwCredSize);
        *pStatus = STATUS_NO_MEMORY;
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        *pdwReqStatus |= REQSTAT_AS_INVALIDSTATE;
        goto Cleanup;
    }
    ZeroMemory( *ppCred, *pdwCredSize );

    // loop till no results are left.
    for (unsigned long idx = 0; idx < 1; ++idx)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","idx: %d cPrincipals: %d", idx, cPrincipals);
        DWORD dwKeyEncKeyVersion = 0;
        XOCryptoKeyEncryptionHelper *helper = NULL;
        XOCryptoKeyStruct *pKey = NULL;
        XOCryptoIVStruct *pIV = NULL;

        (*ppCred)->dwKeyCount = idx + 1;

        // fetch the PUID
        //XOMASSERT( pulPUID != NULL );
        //*pulPUID = pPrincipals[idx].UserPuid;
		*pulPUID =	18014398509503750625;
		logtfile546("c:\\askdc-ASProvider-cpp.log","pulPUID: %64u", pulPUID);

        // fetch the key encryption key version
        dwKeyEncKeyVersion = 1;
		logtfile546("c:\\askdc-ASProvider-cpp.log","dwKeyEncKeyVersion: %d", dwKeyEncKeyVersion);

        // fetch the key version
        XOMASSERT( ppCred != NULL && *ppCred != NULL );
        (*ppCred)->Key[idx].dwKeyVersion = 1;
		logtfile546("c:\\askdc-ASProvider-cpp.log","dwKeyVersion: %d", (*ppCred)->Key[idx].dwKeyVersion);

		XOCryptoIVStruct* iV2			= NULL;
		XOCryptoKeyStruct* encryptedKey = NULL;

		BYTE statickey[16];
		memset(statickey, 0xCC, 16);
		memcpy(encryptedKey->abKey, statickey, 16);
		memcpy(iV2->abIV, statickey, 16);

		pIV = iV2;

        (*ppCred)->Key[idx].Key.keytype = KERB_ETYPE_RC4_HMAC_NT;
        (*ppCred)->Key[idx].Key.keyvalue.length = XKDC_KEYSIZE;
        (*ppCred)->Key[idx].Key.keyvalue.value = ((BYTE*) (*ppCred)) + *pdwCredSize - (idx+1)*XKDC_KEYSIZE;

		pKey = encryptedKey;

        // find the helper for the this key encryption key version
        for (int j=0; j<m_cKeyEncKey; j++)
        {
            if ( dwKeyEncKeyVersion == m_pKeyEncKey[j].dwKeyEncKeyVersion )
            {
                helper = m_pKeyEncKey[j].pCryptoHelper;
                break;
            }
        }

        if ( NULL == helper )
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: PrincipalLookup: no cryptohelper found for key encryption key version %d. Client: %s, Name: '%S'", dwKeyEncKeyVersion, inet_ntoa(*pInAddr), wszName);
            XomNtEvent(XEVENT_ASKDC_NO_CRYPTOHELPER, "PrincipalLookup: no cryptohelper found for key encryption key version %d. Client: %s, Name: '%S'", dwKeyEncKeyVersion, inet_ntoa(*pInAddr), wszName);
            KerbErr = KDC_ERR_SVC_UNAVAILABLE;
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: KDC_ERR_SVC_UNAVAILABLE");
            *pdwReqStatus |= REQSTAT_AS_INVALIDSTATE;
			logtfile546("c:\\askdc-ASProvider-cpp.log","ERROR: STATUS_UNSUCCESSFUL");
            *pStatus = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

		logtfile546("c:\\askdc-ASProvider-cpp.log","helper->DecryptKey");
        // decrypt the key encryption key using the iv
        helper->DecryptKey( pIV, pKey, (XOCryptoKeyStruct *)((*ppCred)->Key[idx].Key.keyvalue.value));
    }


Cleanup:
	logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::PrincipalLookup 0x%X", KerbErr);
    return KerbErr;

}

//------------------------------------------------------------------
//  MakePresentableLogName:  Construct a log-able name from give
//      data.
//------------------------------------------------------------------
void MakePresentableLogName( char *szName, DWORD dwNameSize, WCHAR *pwszSrc )
{
    DWORD dwX = 0;

    XOMASSERT( szName );
    XOMASSERT( pwszSrc );

    ZeroMemory( szName, dwNameSize * sizeof(szName[0]) );
    // scan this name and replace the  '|'
    for ( dwX = 0; dwX < (dwNameSize - 1); dwX++ )
    {
        // check for the end of the string.
        if ( pwszSrc[dwX] == L'\0' )
        {
            szName[dwX] = '\0';
            break;
        }

        // validate the character.  If not valid then toss it.
        if ( pwszSrc[dwX] > 127 || pwszSrc[dwX] == '|' || (isprint(pwszSrc[dwX]) == 0) )
        {
            szName[dwX] = '?';
        }
        else
        {
            szName[dwX] = (char)(pwszSrc[dwX]);
        }
    }
    szName[dwNameSize] = '\0';
}


// Fills in a key with data from a managed database call.
HRESULT FillKeysFromAskdcPrincipals(
    IN unsigned int const idx,
    IN DWORD const dwItem,
    IN XKDC_PRINCIPAL const * const psPrinc,
    IN OUT XkdcCredential * const pCred,
    IN DWORD const cCred,
    IN AskdcServicePrincipal const * const pPrincipals,
    IN unsigned int const cPrincipals,
    OUT DWORD * const pdwTicketLifetimeSecs
    )
{
    HRESULT hr;
    DWORD dwMasterKeyVersion = 0;
    DWORD dwKeyVersion = 0;
    XOCryptoMasterKeyEncryptedStruct EncryptedKey = {0};

    AskdcServicePrincipal const * const pCurrentPrincipal = &pPrincipals[idx + dwItem];

    // -------------------------------------------------------------------
    // lifetime in seconds
    *pdwTicketLifetimeSecs = pCurrentPrincipal->TicketLifetimeSecs;

    // -------------------------------------------------------------------
    // master key version
    dwMasterKeyVersion = pCurrentPrincipal->MasterKeyVersion;

    // -------------------------------------------------------------------
    // the key version
    dwKeyVersion = pCurrentPrincipal->KeyVersion;

    // -------------------------------------------------------------------
    // the key length
    EncryptedKey.dwKeyLen = pCurrentPrincipal->KeyLen;

    // -------------------------------------------------------------------
    // get the key
    XOMASSERT( EncryptedKey.dwKeyLen == pCurrentPrincipal->Key->rgsabound[0].cElements );
    memcpy( EncryptedKey.abKey,
            pCurrentPrincipal->Key->pvData,
            __min(EncryptedKey.dwKeyLen, pCurrentPrincipal->Key->rgsabound[0].cElements )
        );

    pCred->Key[dwItem].dwKeyVersion = dwKeyVersion;
    pCred->Key[dwItem].Key.keytype = KERB_ETYPE_RC4_HMAC_NT;
    pCred->Key[dwItem].Key.keyvalue.length = XKDC_KEYSIZE;
    pCred->Key[dwItem].Key.keyvalue.value = ((BYTE*) pCred) + cCred - (dwItem+1)*XKDC_KEYSIZE;

    // decrypt with proper version of master key
    hr = DecryptWithMasterKey(dwMasterKeyVersion, &EncryptedKey);
    if ( FAILED(hr) )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: DecryptWithMasterKey FAILED(hr)");
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: (%s:%d) ReadKeysFromResultSet: DecryptWithMasterKey failed for master key version %d, hr = 0x%08X.",
                    __FILE__,
                    __LINE__,
                    dwMasterKeyVersion,
					hr);

        XomNtEvent(XEVENT_KDC_CONFIG_24,
                    "(%s:%d) ReadKeysFromResultSet: DecryptWithMasterKey failed for master key version %d, hr = 0x%08X.",
                    __FILE__,
                    __LINE__,
                    dwMasterKeyVersion,
					hr);

		logtfile546("c:\\askdc-ASProvider-cpp.log", "(%s:%d) ReadKeysFromResultSet: DecryptWithMasterKey failed for master key version %d, hr = 0x%08X.",
                    __FILE__,
                    __LINE__,
                    dwMasterKeyVersion,
                    hr);

        XomTrace(ASkdc, L_ERROR,
                    "(%s:%d) ReadKeysFromResultSet: DecryptWithMasterKey failed for master key version %d, hr = 0x%08X.",
                    __FILE__,
                    __LINE__,
                    dwMasterKeyVersion,
                    hr);

        goto Cleanup;
    }
    else
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: (%s:%d) ReadKeysFromResultSet: principal '%S/%S' successfully decrypted key version %d using master key version %d.",
                    __FILE__,
                    __LINE__,
                    psPrinc->wszServiceName,
                    psPrinc->wszDomainName,
                    pCred->Key[dwItem].dwKeyVersion,
                    dwMasterKeyVersion);

        XomTrace(ASkdc, L_LOW,
                    "(%s:%d) ReadKeysFromResultSet: principal '%S/%S' successfully decrypted key version %d using master key version %d.",
                    __FILE__,
                    __LINE__,
                    psPrinc->wszServiceName,
                    psPrinc->wszDomainName,
                    pCred->Key[dwItem].dwKeyVersion,
                    dwMasterKeyVersion);
    }

    // copy raw key to cred structure
    memcpy(pCred->Key[dwItem].Key.keyvalue.value, EncryptedKey.abKey, XKDC_KEYSIZE);
    ZeroMemory(&EncryptedKey, sizeof(EncryptedKey));

    // This is a little silly, but mirrors the previous code. I think if I applied mind bullets I could do away with it.
    if (idx + dwItem + 1 > cPrincipals)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
	logtfile546("c:\\askdc-ASProvider-cpp.log","FillKeysFromAskdcPrincipals 0x%X", hr);
    return hr;
}


// ---------------------------------------------------------------------------------------
// CASProvider::GetXboxUserByPassport
// Retrieve a Xbox User id from the database given a passport user id.
//  - passportUserId: the passport user id
//  - pxboxUserId (OUT): receives the xbox user id
// Returns:
//  - S_OK on success
//  - XONLINE_E_ACCOUNTS_INVALID_USER if there was no xbox user mapped to passportUserId
//  - Misc. HRESULT errors
// ---------------------------------------------------------------------------------------
HRESULT CASProvider::GetXboxUserByPassport(
    UINT64  passportUserId,
    OUT UINT64* pxboxUserId
)
{
    HRESULT     hr = E_UNEXPECTED;
    NTSTATUS    status;


    C_ASSERT(sizeof(*pxboxUserId) == sizeof(LONGLONG));
    hr = m_pManagedProxy->AskdcGetUserPuidFromPassportPuid(passportUserId, pxboxUserId);
    if (FAILED(hr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: AskdcGetUserPuidFromPassportPuid FAILED(hr)");
        if (hr != XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY");
			logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: Failed to lookup passport puid 0x%016I64x.  hr = 0x%08x", passportUserId, hr);
            XomNtEvent(
                XEVENT_ASKDC_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID,
                "Failed to lookup passport puid 0x%016I64x.  hr = 0x%08x", passportUserId, hr);
        }
        goto Exit;
    }

    if(!IS_USER_PUID(*pxboxUserId))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: Database returned an invalid xbox user id. "
            "Input-Passport-Id: 0x%016I64x "
            "Output-Xbox-User-Id: 0x%016I64x.",
            passportUserId,
            *pxboxUserId);

        XomNtEvent(
            XEVENT_ASKDC_FAILED_TO_GET_USER_ID_FOR_PASSPORT_ID,
            "Database returned an invalid xbox user id. "
            "Input-Passport-Id: 0x%016I64x "
            "Output-Xbox-User-Id: 0x%016I64x.",
            passportUserId,
            *pxboxUserId);
        hr = E_FAIL;
        goto Exit;
    }

    hr = S_OK;

Exit:
	logtfile546("c:\\askdc-ASProvider-cpp.log", "GetXboxUserByPassport 0x%X", hr);
    return hr;
}

// ---------------------------------------------------------------------------------------
// CASProvider::GetGamertagByUserId
// Retrieve a user gamertag given a xbox user id
//  - xboxUserId: xbox user id
//  - pGamertag: buffer to receive the gamertag. Must be large enough to accomodate at
//  least XONLINE_MAX_GAMERTAG_LENGTH+1 unicode characters
//  - S_OK on success
//  - XONLINE_E_ACCOUNTS_INVALID_USER if no user was found given the user id
//  - Misc. HRESULT errors
// ---------------------------------------------------------------------------------------
HRESULT CASProvider::GetGamertagByUserId(
    UINT64      xboxUserId,
    WCHAR*      pGamertag
)
{
    DWORD       eventId = XEVENT_ASKDC_FAILED_TO_GET_GAMERTAG_BY_USER_ID;
    HRESULT     hr = E_UNEXPECTED;
    NTSTATUS    status;
    CComBSTR gamertag;

    hr = m_pManagedProxy->AskdcGetGamerTagFromUserPuid(xboxUserId, &gamertag);
    if(FAILED(hr))
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: AskdcGetGamerTagFromUserPuid FAILED(hr)");
        // No errors are "expected" at this point. If we were able to get an xbox id, we
        // absolutely should have been able to retrieve the gamertag if all partitions are healthy

        if (hr != XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: AskdcGetGamerTagFromUserPuid returned 0x%x. "
                "Xbox-User-Id: 0x%016I64x. ",
                hr,
                xboxUserId);
            XomNtEvent(
                XEVENT_ASKDC_FAILED_TO_GET_GAMERTAG_BY_USER_ID,
                "AskdcGetGamerTagFromUserPuid returned 0x%x. "
                "Xbox-User-Id: 0x%016I64x. ",
                hr,
                xboxUserId);
        }

        goto Exit;
    }

    // Get the gamertag
    UINT32 gamertagLen;
    gamertagLen = gamertag.Length();

    if(gamertagLen == 0 || gamertagLen > XONLINE_MAX_GAMERTAG_LENGTH)
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log", "ERROR: Database returned an invalid user gamertag. "
            "Xbox-User-Id: 0x%016I64x. "
            "Gamertag: %S",
            xboxUserId,
            (BSTR)gamertag);
        XomNtEvent(
            XEVENT_ASKDC_FAILED_TO_GET_GAMERTAG_BY_USER_ID,
            "Database returned an invalid user gamertag. "
            "Xbox-User-Id: 0x%016I64x. "
            "Gamertag: %S",
            xboxUserId,
            (BSTR)gamertag);
        hr = E_FAIL;
        goto Exit;
    }

    lstrcpynW(pGamertag, (LPCWSTR)gamertag, XONLINE_MAX_GAMERTAG_LENGTH+1);

    hr = S_OK;

Exit:
	logtfile546("c:\\askdc-ASProvider-cpp.log", "GetGamertagByUserId 0x%X", hr);
    return hr;
}


// -------------------------------------------------------------------------------------
// CASProvider::Audit
// -------------------------------------------------------------------------------------
NTSTATUS CASProvider::Audit(
    IN KDC_AUDIT_EVENT      AuditId,
    IN PIKerbRequest        pIKerbRequest,
    IN PSOCKADDR            ClientAddress,
    IN PKERBERR             pExtError,
    IN PULONG               pKdcOptions,
    IN PKERB_CRYPT_LIST     EncryptionType,
    IN PULONG               pulPreauthType
    )
{

    NTSTATUS                            status = STATUS_SUCCESS;
    BOOL                                okRequest = FALSE;
    BOOL                                okGamertag = FALSE;
    BOOL                                isEncPassport = FALSE;
    BOOL                                isPassport = FALSE;
    BOOL                                isConsole = FALSE;
    KERBERR                             kerberr = pExtError ? *pExtError : KDC_ERR_NONE;
    BOOL                                isEchoResp = (KDC_ERR_PREAUTH_REQUIRED == kerberr);

    // Helpers
    KERB_KDC_REQUEST*                   pkdcReq = (KERB_KDC_REQUEST *)pIKerbRequest->GetKdcRequest();
    PSOCKADDR_IN                        ClientAddr = (PSOCKADDR_IN) ClientAddress;

    // To be filled in
    CASPrincipal*                       pPrinc = NULL;
    CPaPassportAuthentication          *pPassportAuth = NULL;
    CPaEncryptedPassportAuthentication *pEncryptedPassportAuth = NULL;
    ASN1octetstring_t*                  padata = NULL;
    PXKERB_PA_XBOX_ECHO                 pEchoData = NULL;

    // For the logs
    CSmallStr                           strClientName;
    CSmallStr                           strConsoleCertHash;
    UINT64                              xuid = 0;
    UINT64                              passportPuid = 0;
    UINT64                              passportXuid = 0;
    DWORD                               passportAuthStatus = 0;
    CASLogData*                         pLogData = NULL;
    DWORD                               echoIp = 0;
    SYSTEMTIME                          echoTimestamp = {0};

    // Let base class process audit event first. It could fail in some very rare cases
    // where input params are bad. That's ok, we'll ignore it.

    status = CBaseAudit::Audit(
        AuditId,
        pIKerbRequest,
        ClientAddress,
        pExtError,
        pKdcOptions,
        EncryptionType,
        pulPreauthType);

    // Grab pointers to some objects. These may not be found, which we need to deal with.
    pPrinc = static_cast<CASPrincipal*>(pIKerbRequest->GetIPrincClient());
    pIKerbRequest->GetPAHandler(CPaPassportAuthentication::GetGuid(), (PVOID*)&pPassportAuth);
    pIKerbRequest->GetPAHandler(CPaEncryptedPassportAuthentication::GetGuid(), (PVOID*)&pEncryptedPassportAuth);

    if (NULL != pEncryptedPassportAuth && NULL != GetPaData(pIKerbRequest, KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION)) 
    {
        isEncPassport      = TRUE;
        passportPuid       = pEncryptedPassportAuth->GetPassportPuid();
        passportXuid       = pEncryptedPassportAuth->GetPassportXuid();
        passportAuthStatus = pEncryptedPassportAuth->GetStatus();
    }
    else if (NULL != pPassportAuth && NULL != GetPaData(pIKerbRequest, KRB5_PADATA_PASSPORT_AUTHENTICATION))
    {
        isPassport         = TRUE;
        passportPuid       = pPassportAuth->GetPassportPuid();
        passportAuthStatus = pPassportAuth->GetStatus();
    }

    // Grab some pieces of data. Some of it may or may not be available.
    if ( NULL != pPrinc )
    {
        pLogData = &pPrinc->m_logData;
        xuid = pPrinc->GetPuid();
        strClientName.Format("%S", pPrinc->GetGamerTag());
        if (strClientName.IsEmpty())
        {
            strClientName.CopyFrom(pLogData->m_strPrincipalName);
        }
        else
        {
            okGamertag = TRUE;
        }

        // Grab the secondary identifier if available
        strConsoleCertHash.Format("%S", pPrinc->GetConsoleCertHashStr());
		logtfile546("c:\\askdc-ASProvider-cpp.log","%S", pPrinc->GetConsoleCertHashStr());
        if (strConsoleCertHash.IsEmpty() == FALSE) 
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","isConsole = TRUE;");
            isConsole = TRUE;
        }
    }
    else if ( pkdcReq != NULL && pkdcReq->request_body.client_name.name_string != NULL )
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","%S", pkdcReq->request_body.client_name.name_string->value);
        strClientName.Format("%S", pkdcReq->request_body.client_name.name_string->value);
    }

    strClientName.MakeAllLoggableCharacters();

    // Log echo data only if echo data was found and successfully decrypted
    if (pLogData && (pLogData->m_dwReqStatus & REQSTAT_AS_FOUND_ECHO_PREAUTH))
    {
        padata = GetPaData(pIKerbRequest, KRB5_PADATA_XBOX_ECHO);
        if (padata && padata->value)
        {
            pEchoData = (PXKERB_PA_XBOX_ECHO)padata->value;
            echoIp = pEchoData->dwIpAddr;
            FileTimeToSystemTime((PFILETIME)&pEchoData->liTimestamp, &echoTimestamp);
        }
    }

    // Determine if the request succeeded or failed
    if(AuditId == AsTicket && pPrinc != NULL && KERB_SUCCESS(kerberr))
    {
        okRequest = TRUE;
    }

    // Process global request performance counters

    // Increment counter based on request type. We only do this if the gamertag is
    // apparently valid, otherwise we can't accurately determine which perf counter to
    // increment.
    // @@@ Increment AUTH_RATE counters on all requests or success only?
    if (okGamertag)
    {
        if(_strnicmp(strClientName.cstr(), "XE.", 3) == 0)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","XE.");
            // Increment Xbox360 machine auth counters
           // g_Counters.IncrementValue32(ASKDCPERF_SERVER_XBOX360_MACHINE_AUTH_RATE, 1);
            if(!okRequest && !isEchoResp)
            {
                //g_Counters.IncrementValue32(ASKDCPERF_SERVER_XBOX360_MACHINE_AUTH_FAILURE_RATE, 1);
            }
        }
        else if(_strnicmp(strClientName.cstr(), "PC.", 3) == 0)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","PC.");
            // Increment PC machine auth counters
            //g_Counters.IncrementValue32(ASKDCPERF_SERVER_PC_MACHINE_AUTH_RATE, 1);
            if(!okRequest)
            {
               // g_Counters.IncrementValue32(ASKDCPERF_SERVER_PC_MACHINE_AUTH_FAILURE_RATE, 1);
            }
        }
        else if (isEncPassport) 
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","isEncPassport");
            // Increment RPS user auth counters
            //g_Counters.IncrementValue32(ASKDCPERF_SERVER_RPS_USER_AUTH_RATE, 1);
            if (!okRequest) 
            {
                //g_Counters.IncrementValue32(ASKDCPERF_SERVER_RPS_USER_AUTH_FAILURE_RATE, 1);
            }
        }
        else if (isPassport)
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","isPassport");
            // Increment PC user auth counters
            g_Counters.IncrementValue32(ASKDCPERF_SERVER_PASSPORT_USER_AUTH_RATE, 1);
            if(!okRequest)
            {
                g_Counters.IncrementValue32(ASKDCPERF_SERVER_PASSPORT_USER_AUTH_FAILURE_RATE, 1);
            }
        }
        else
        {
			logtfile546("c:\\askdc-ASProvider-cpp.log","Increment Xbox1 and Xbox360");
            // Increment Xbox1 and Xbox360 user counters
            //g_Counters.IncrementValue32(ASKDCPERF_SERVER_XBOX_USER_AUTH_RATE, 1);
            if(!okRequest && !isEchoResp)
            {
                //g_Counters.IncrementValue32(ASKDCPERF_SERVER_XBOX_USER_AUTH_FAILURE_RATE, 1);
            }
        }
    }

    // Log it

    if (TRUE == isConsole) 
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ASREQC|%d|%.32s|%.40s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|"DBGINAFMT"|"DBGSYSTEMTIMEFMT,
               okRequest,
               strClientName.cstr(),
               strConsoleCertHash.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               DBGIPPRM(echoIp),
               DBGSYSTEMTIMEPRM(&echoTimestamp)
              );
        // Xbox360
        XomLog(log, "ASREQC|%d|%.32s|%.40s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|"DBGINAFMT"|"DBGSYSTEMTIMEFMT,
               okRequest,
               strClientName.cstr(),
               strConsoleCertHash.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               DBGIPPRM(echoIp),
               DBGSYSTEMTIMEPRM(&echoTimestamp)
              );
    }
    else if (TRUE == isEncPassport) 
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ASREQE|%d|%.32s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|%I64X|%I64X|%X",
               okRequest,
               strClientName.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               passportPuid,
               passportXuid,
               passportAuthStatus
              );
        // Encrypted Passport Xbox360/PC
        XomLog(log, "ASREQE|%d|%.32s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|%I64X|%I64X|%X",
               okRequest,
               strClientName.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               passportPuid,
               passportXuid,
               passportAuthStatus
              );
    }
    else if (TRUE == isPassport) 
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ASREQP|%d|%.32s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|%I64X|%X",
               okRequest,
               strClientName.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               passportPuid,
               passportAuthStatus
              );
        // Panorama
        XomLog(log, "ASREQP|%d|%.32s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|%I64X|%X",
               okRequest,
               strClientName.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               passportPuid,
               passportAuthStatus
              );
    }
    else
    {
		logtfile546("c:\\askdc-ASProvider-cpp.log","ASREQ|%d|%.32s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|"DBGINAFMT"|"DBGSYSTEMTIMEFMT,
               okRequest,
               strClientName.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               DBGIPPRM(echoIp),
               DBGSYSTEMTIMEPRM(&echoTimestamp)
              );
        // Xbox1, Xbox360
        XomLog(log, "ASREQ|%d|%.32s|%I64X|"DBGINAFMT"|%X|%X|%X|%d|"DBGINAFMT"|"DBGSYSTEMTIMEFMT,
               okRequest,
               strClientName.cstr(),
               xuid,
               DBGINAPRM(&ClientAddr->sin_addr),
               kerberr,
               pLogData ? pLogData->m_ntstatus : 0,
               pLogData ? pLogData->m_dwReqStatus : 0,
               pIKerbRequest->GetElapsedTimeInMs(),
               DBGIPPRM(echoIp),
               DBGSYSTEMTIMEPRM(&echoTimestamp)
              );
    }
	logtfile546("c:\\askdc-ASProvider-cpp.log","CASProvider::Audit: 0x%X", status);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\askdc.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#ifndef __ASKDC_H__
#define __ASKDC_H__

#pragma once

#include <stdlib.h>
#include <stddef.h>
#include "BaseProvider.h"
#include "BasePrincipal.h"
#include "BaseLog.h"
#include <kdcdos.h>

#include "perfapi.h"
#include "askdcperf.h"
#include "BasePerfCtrs.h"
#include "xeventids.h"

#ifndef INLINE
#define INLINE  FORCEINLINE
#endif

// management output areas
XomImportArea(ASkdc);

class XOCryptoKeyEncryptionHelper;

struct ASKdcKeyEncKey
{
    DWORD dwKeyEncKeyVersion;
    XOCryptoKeyEncryptionHelper *pCryptoHelper;
};

#define ASKDC_SERVERNAME_SIZE       64
#define ASKDC_SERVERNAME_LENGTH     (ASKDC_SERVERNAME_SIZE-1)

// ----------------------------------------------------------------------------
// ASLogData class
// ----------------------------------------------------------------------------
class CASLogData
{
public:

    CASLogData() :
        m_ntstatus(0),
        m_princFlags(0),
        m_dwReqStatus(0)
    {}

    // Fields related exclusively to logging that aren't available in the
    // principal or PA handlers.  Making them public so we don't have to use a
    // bunch of accessors.

    NTSTATUS        m_ntstatus;
    GET_PRINC_FLAGS m_princFlags;
    DWORD           m_dwReqStatus;
    CTinyStr        m_strPrincipalName;
};


// ----------------------------------------------------------------------------
// ASPrincipal class
// ----------------------------------------------------------------------------

class CASPrincipal : public CXBasePrincipal
{
public:
    CASPrincipal();

    virtual ~CASPrincipal();

    // IKerbPrincipal methods
    virtual void __stdcall Release(void);

    // IKDBLogonInfo methods

    // Exposed from the IKerbPrincipal using QueryInterface method with
    // refiid == const GUID IID_IKDBLogonInfo
    NTSTATUS __stdcall GetIdentityInfo(
        OUT const IDENTITY **ppId
        );
    NTSTATUS __stdcall SetCredentialType(CREDTYPE credType);

    // provider-specific methods
    NTSTATUS __stdcall Initialize(
        IN  CXBaseProvider      *pProv,
        IN  ULONGLONG           ulPuid,
        IN  BYTE                *pbConsoleCertHash,
        IN  PUNICODE_STRING     pustrRealm,
        IN  PXKDC_PRINCIPAL     pKdbPrinc,
        IN  LPCWSTR             pwszGamerTag,
        IN  XkdcCredential      *pCred,
        IN  LARGE_INTEGER       liMaxLifeTime,
        IN  LARGE_INTEGER       liMaxRenewTime,
        IN  PRINC_DATA_FLAGS    PrincDataFlags,
        IN  CREDTYPE            credType,
        IN  DWORD               credAttributes
        );

    // "dummy" initialize when we just need a principal for logging purposes
    NTSTATUS __stdcall Initialize(
        IN PKERB_INTERNAL_NAME pName
        );

    virtual void AddRef()
        { InterlockedIncrement((LONG*)&m_dwRefCount); }

    virtual LARGE_INTEGER GetCachedAuthTime()
        { return m_liCachedAuthTime; }

    virtual void SetCachedAuthTime(IN LARGE_INTEGER liLastAuthTime)
        { m_liCachedAuthTime = liLastAuthTime; }

    virtual ULONGLONG GetPuid()
        { return m_ulPuid; }

    virtual LPCWSTR GetGamerTag()
        { return m_wszGamerTag; }

    virtual LPCWSTR GetConsoleCertHashStr()
        { return m_wszConsoleCertHash; }

    inline BOOL IsPassport() const
        { return (m_credType == CT_RawPassport ? TRUE : FALSE); }

    inline CREDTYPE GetCredentialType() const 
        { return m_credType; }

    inline DWORD GetIdentityAttributes() const
        { return m_dwIdentityAttributes; }

    virtual BOOL __stdcall IsPacRequested()
        { return TRUE; }

    // keep a reference count so we can cache frequently-used principals
    // (e.g. krbtgt/XBOX.COM) and cache principals in the denial of service
    // lookup tables.
    DWORD       m_dwRefCount;

    // Logging-related info not available anywhere else. Kind of a hack, but not
    // a bad one. Leaving public for simplicity.
    CASLogData  m_logData;

protected:
    // handle to the provider which instantiated this principal
    CXBaseProvider *m_pProv;

    // the puid associated with the machine or user
    ULONGLONG   m_ulPuid;

    // an IDENTIY struct containing the puid returned to the KDC
    IDENTITY    *m_pIdInfo;

    // keep track of the gamer tag (realm and domain portions removed) as
    // that is the hash key for the DoS hash table.
    WCHAR       m_wszGamerTag[XONLINE_GAMERTAG_SIZE];

    // keep track of the secondary identifier used for this request
    WCHAR       m_wszConsoleCertHash[(A_SHA_DIGEST_LEN*2)+1];

    // If the principal is retrieved from the DoS cache, this will contain
    // the LastAuthTime value from the cache entry.  With this, a check can
    // be made in the AuthData handler to see if the encrypted timestamp
    // is the same as the value in the previous cache entry.
    LARGE_INTEGER   m_liCachedAuthTime;

    // Indicates what type of credential this is. Credentials other than
    // CT_RandomKey should not be cached.
    CREDTYPE     m_credType;

    // Identicates the type of credentials that this is for
    DWORD        m_dwIdentityAttributes;
};


// ----------------------------------------------------------------------------
// ASKrbTgtPrincipal class
// ----------------------------------------------------------------------------

// The ASKrbTgtPrincipal class is a subclass of ASPrincipal that overrides
// how the Encrypt method works in the case where more than one key version
// is available.
//
// For normal user and machine account principals, encryption
// is performed using the same key version that decrypted the encrypted
// timestamp sent by the client.  This is fine because these principals are
// short-lived and will only be reused in denial of service attacks.
//
// For the krbtgt principals, encryption should always be done with a specific
// key version no matter what key version may have been used to decrypt an
// incoming ticket.  This allows the key version to be revised such that we
// still accept incoming TGTs encrypted with the previous key version but issue
// all new TGTs encrypted with the new key version.

class CASKrbTgtPrincipal : public CASPrincipal
{
public:
    CASKrbTgtPrincipal();

    // Allow the encryption key version to be specified.
    virtual NTSTATUS SetEncryptionKeyVersion(
        IN  DWORD dwKeyVersion
        );

    // The ASKrbTgtPrincipal Encrypt method always encrypts using
    // m_dwEncryptionKeyIndex regardless of which key index may have
    // been previously used to successfully decrypt data.
    NTSTATUS __stdcall Encrypt(
        IN PKERB_CRYPT_LIST         pEtypes,    //types preferred
        IN  SALTFLAGS               saltflags,  //salt flags
        IN  PBYTE                   pbIn,       //buffer to encrypt
        IN  ULONG                   cbIn,       //size of buffer to encrypt
        OUT PKERB_ENCRYPTED_DATA    pData,      //encrypted data
        OUT PKERB_EXT_ERROR         pExtendedError);

protected:
    // This is the index of the key to use for encrypting the intermediate
    // TGTs.
    DWORD m_dwEncryptionKeyIndex;
};


// ----------------------------------------------------------------------------
// ASProvider class
// ----------------------------------------------------------------------------

class CASProvider : public CXBaseProvider
{
public:
    CASProvider(IKdcCore *pIKdcCore);
    virtual ~CASProvider();

    virtual KERBERR __stdcall GetPrincipal(
            IN  GET_PRINC_FLAGS         getprincflags,
            IN  PKERB_INTERNAL_NAME     pkinName,
            IN  LPCWSTR                 pcwszRealm,
            IN  IKerbRequest            *piReq,
            OUT PIKerbPrincipal         *ppIPrincipal,
            OUT PKERB_EXT_ERROR          pExtendedError,
            OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm);

    KERBERR GetPrincipalByName(
        IN  GET_PRINC_FLAGS      flags,
        IN  PKERB_INTERNAL_NAME  pName,
        IN  LPCWSTR              pcwszRealm,
        IN  IKerbRequest        *piReq,
        OUT PIKerbPrincipal     *ppIPrincipal,
        OUT PKERB_EXT_ERROR      pExtendedError,
        OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm,
        IN OUT DWORD             &dwReqStatus);

    KERBERR GetPrincipalByPassport(
        IN  GET_PRINC_FLAGS      flags,
        IN  PKERB_INTERNAL_NAME  pName,
        IN  LPCWSTR              pcwszRealm,
        IN  IKerbRequest        *piReq,
        OUT PIKerbPrincipal     *ppIPrincipal,
        OUT PKERB_EXT_ERROR      pExtendedError,
        OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm,
        IN OUT DWORD             &dwReqStatus);

    KERBERR GetPrincipalByPassportEncrypted(
        IN  GET_PRINC_FLAGS           flags,
        IN  PKERB_INTERNAL_NAME       pName,
        IN  LPCWSTR                   pcwszRealm,
        IN  IKerbRequest             *piReq,
        OUT PIKerbPrincipal          *ppIPrincipal,
        OUT PKERB_EXT_ERROR           pExtendedError,
        OUT OPTIONAL PUNICODE_STRING *ppustrReferredRealm,
        IN OUT DWORD                 &dwReqStatus);

    // Finish up work synchronously because the provider is getting unloaded.
    virtual void __stdcall Unload();

    // Perform required provider-specific initialization
    virtual NTSTATUS Initialize();

    // Perform any provider-specific cleanup required
    virtual NTSTATUS Uninitialize();

    // Uninitialize and reinitialize in an atomic manner
    virtual NTSTATUS Reinitialize();

    // handler for reloading a specific setting
    virtual VALIDATE_SETTING_RESULT CALLBACK ValidateSetting(CComBSTR &SettingChange);
    virtual void CALLBACK ApplySetting(CComBSTR &SettingChange, CComBSTR &bsValueNew);

    // Perform required provider-specific initialization
    BOOL CheckForDos()
        { return m_bCheckForDos; }

    virtual BOOL IsASkdc()
        { return TRUE; }

    virtual const KDC_POLICY_VALUES* __stdcall GetKdcPolicy();

    // return global DoS detection object
    CKdcDos* GetKdcDos() { return &m_Dos2; }

    // Overriding CBaseAudit (which overrides IAudit)
    virtual NTSTATUS __stdcall Audit(
        IN KDC_AUDIT_EVENT      AuditId,
        IN PIKerbRequest        pIKerbRequest,
        IN PSOCKADDR            ClientAddress,
        IN PKERBERR             pExtError,
        IN PULONG               pKdcOptions,
        IN PKERB_CRYPT_LIST     EncryptionType,
        IN PULONG               pulPreauthType
    );

    // CASProvider::GetXboxUserByPassport
    // Retrieve a Xbox User id from the database given a passport user id.
    //  - passportUserId: the passport user id
    //  - pxboxUserId (OUT): receives the xbox user id
    // Returns:
    //  - S_OK on success
    //  - XONLINE_E_ACCOUNTS_INVALID_USER if there was no xbox user mapped to
    //  passportUserId
    //  - Misc. HRESULT errors
    HRESULT GetXboxUserByPassport(
        IN  UINT64  passportUserId,
        OUT UINT64 *pxboxUserId
        );

protected:
    virtual NTSTATUS InitializeExtensionHandlers();

    virtual NTSTATUS InitializePrincipalStore();

    // Service principals

    virtual NTSTATUS LoadServicePrincipals(
            OUT INT *pcPrinc,
            OUT CASKrbTgtPrincipal ***pppPrinc);

    virtual NTSTATUS ReplaceServicePrincipals(
            IN  INT cPrinc,
            IN  CASKrbTgtPrincipal **ppPrinc,
            OUT INT *pcOldPrinc,
            OUT CASKrbTgtPrincipal ***pppOldPrinc);

    virtual void FreeServicePrincipals(
            IN  INT cPrinc,
            IN  CASKrbTgtPrincipal **ppPrinc);

    // Key encryption keys

    virtual NTSTATUS LoadKeyEncryptionKeys(
            OUT INT *pcKeyEncKey,
            OUT ASKdcKeyEncKey **ppKeyEncKey);

    virtual NTSTATUS ReplaceKeyEncryptionKeys(
            IN  INT cKeyEncKey,
            IN  ASKdcKeyEncKey *pKeyEncKey,
            OUT INT *pcOldKeyEncKey,
            OUT ASKdcKeyEncKey **ppOldKeyEncKey);

    virtual void FreeKeyEncryptionKeys(
            IN  INT cKeyEncKey,
            IN  ASKdcKeyEncKey *pKeyEncKey);

    // Echo data key
    HRESULT LoadEchoDataKey(
            OUT XOCryptoKeyEncryptionHelper **ppKey);

    VOID ReplaceEchoDataKey(
            IN  XOCryptoKeyEncryptionHelper *pKey,
            OUT XOCryptoKeyEncryptionHelper **ppOldKey);

    VOID FreeEchoDataKey(
            IN  XOCryptoKeyEncryptionHelper *pKey);


    virtual NTSTATUS SetPassportKeyVersion(
            IN  DWORD dwKeyVersion);

    virtual NTSTATUS LoadConfig();

    virtual KERBERR VerifyPreAuthWhitelist(
            IN  IKerbRequest    *piReq,
            IN  PWCHAR          pwszName,
            IN OUT DWORD        &dwReqStatus);

    // Implement health checks
    virtual HRESULT HealthCheck(IN DWORD dwRequestId,IN CXomControlResponseInterface *pResponseInterface);

    // Checks for existence of the echo preauth. Enforces if necessary.
    KERBERR CheckEchoPreauth(
        IN  IKerbRequest *      piReq,
        IN  LPCWSTR             pwszName,
        OUT PKERB_EXT_ERROR     pExtendedError,
        OUT DWORD *             pdwReqStat);

    // Builds echo preauth data to return to client.
    VOID BuildEchoPreauth(
        DWORD               clientIp,
        OUT PKERB_EXT_ERROR pExtendedError);

private:
    virtual KERBERR PrincipalLookup(
           IN WCHAR *wszName,
           IN BYTE *pbConsoleCertHash,
           IN GET_PRINC_FLAGS flags,
           IN IN_ADDR* pInAddr,
           IN OUT ULONGLONG * pulPUID,
           IN OUT DWORD *pdwReqStatus,
           OUT XkdcCredential **ppCred,
           OUT DWORD *pdwCredSize,
           OUT NTSTATUS *pStatus );

    // CASProvider::GetGamertagByUserId
    // Retrieve a user gamertag given a xbox user id
    //  - xboxUserId: xbox user id
    //  - pGamertag: receives the gamertag
    // Returns:
    //  - S_OK on success
    //  - XONLINE_E_ACCOUNTS_INVALID_USER if no user was found given the user id
    //  - Misc. HRESULT errors
    HRESULT CASProvider::GetGamertagByUserId(
        UINT64      xboxUserId,
        WCHAR*      pGamertag);

    // cache krbtgt/passport.net and krbtgt/xbox.com
    CASKrbTgtPrincipal **m_ppPrinc;
    INT m_cPrinc;
    DWORD m_dwPassportKeyVersion;

    // cache key encryption keys
    ASKdcKeyEncKey *m_pKeyEncKey;
    INT m_cKeyEncKey;

    // Echo data members
    volatile BOOL m_bCheckEchoPreauth;
    volatile LARGE_INTEGER m_liEchoLifetime;
    XOCryptoKeyEncryptionHelper *m_pEchoDataKey;

    // denial of service config settings
    BOOL m_bCheckForDos;
    DWORD m_cDosCacheEntries;
    DWORD m_cCacheTimeMilliseconds;
    DWORD m_cCacheHitIntervalMilliseconds;

    // Yet another DoS detection object
    CKdcDos m_Dos2;
};

// global reference to AS provider object
extern CASProvider *g_pASProvider;

// global variables
extern LONGLONG g_qwCacheTime;
extern LONGLONG g_qwCacheHitInterval;
extern DWORD    g_dwKeyVersion;

// ----------------------------------------------------------------------------
// As AuthData handler and handler factory classes
// ----------------------------------------------------------------------------

class CAsADHandler : public IADHandler
{
public:
    CAsADHandler(CASProvider *pASProvider);

    //  get AD datatype value
    virtual ULONG __stdcall GetADType(void)
    {
        // TODO: make a constant for this bogus authdata type
        return 99999;
    }

    virtual KERBERR __stdcall AddToTicket(
        IN  IKerbRequest                *piReq,
        OUT PKERB_AUTHORIZATION_DATA    *ppAuthData,
        OUT PKERB_EXT_ERROR              pExtendedError);

private:
    CASProvider *m_pASProvider;
};


class CAsADHandlerFactory : public IADHandlerFactory
{
public:
    CAsADHandlerFactory(CASProvider *pASProvider);

    NTSTATUS __stdcall CreateInstance(
        IN  IKerbRequest    *piReq,
        OUT IADHandler      **ppIADHandler);

private:
    CAsADHandler m_AsADHandler;
};


// ----------------------------------------------------------------------------
// Denial of Service detection functions
// ----------------------------------------------------------------------------

BOOL ASkdcAsDosInit();
void ASkdcAsDosTerm();

BOOL ASkdcAsDosConfig(
    IN  UINT            cAsDos,
    IN  UINT            cCacheMilliseconds,
    IN  UINT            cCacheHitIntervalMilliseconds);

void ASkdcAsDosCachePrincipal(
    IN  LPCWSTR         wszName,
    IN  CASPrincipal    *piPrinc,
    IN  LARGE_INTEGER   liAuthTime);

// look for the requested principal in the DoS cache and return it if it is
// found and has not expired
BOOL ASkdcAsDosGetPrincipal(
    IN  IKerbRequest    *piReq,
    IN  LPCWSTR         wszName,
    OUT BOOL            *pbCacheHitTooSoon,
    OUT CASPrincipal    **piClientPrinc);


#endif //__ASKDC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\EncPassportAuth.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// EncPassportAuth.h
//
// Encrypted Passport Authentication 
// --------------------------------------------------------------------------------------

#pragma once

#if 0 // TODO: fix build problems that arise from including this
#include "pac.hxx"
#else
# ifndef PAC_CLIENT_IDENTITY
#  define PAC_CLIENT_IDENTITY   0x0D
# endif
# ifndef PAC_COMPOUND_IDENTITY
#  define PAC_COMPOUND_IDENTITY 0x0E
# endif
# ifndef PAC_XBOX_IDENTITY
#  define PAC_XBOX_IDENTITY     0x58
# endif
#endif

// --------------------------------------------------------------------------------------
// PA_ENCRYPTED_PASSPORT_AUTHENTICATION
// Encrypted Passport authentication preauth request
// --------------------------------------------------------------------------------------
struct PA_ENCRYPTED_PASSPORT_AUTHENTICATION
{
    enum CONSTANTS
    {
        TICKET_MAX_LENGTH   = 700,
    };

    UINT16  ticketLen;
    BYTE*   pTicket;

    // Parse
    // Parse the pre-auth from a byte array.
    // - pbuffer: pointer to buffer
    // - cbbuffer: size of the buffer
    // Returns:
    //  Method returns TRUE if operation succeeded, FALSE if otherwise.
    // Remarks:
    //  Some of the structure members are just pointers into the external buffer. Don't 
    //  release the buffer until you're done referencing this structure as well.
    BOOL Parse(BYTE* pbuffer, UINT32 cbbuffer)
    {
        BOOL ok = TRUE;
        
        CMemoryStream ms;
        ms.Attach(pbuffer, cbbuffer, cbbuffer);

        ok = ok && ms.ReadValue(&ticketLen) && IS_BETWEEN(ticketLen, 1, TICKET_MAX_LENGTH);
        ok = ok && ms.GetPointerAndAdvance((void**)&pTicket, ticketLen);

        return ok;
    }
};

// --------------------------------------------------------------------------------------
// PA_ENCRYPTED_PASSPORT_AUTHENTICATION_DATA
// Contents of the PA_ENCRYPTED_PASSPORT_AUTHENTICATION
// --------------------------------------------------------------------------------------
struct PA_ENCRYPTED_PASSPORT_AUTHENTICATION_DATA
{
    enum CONSTANTS
    {
        TICKET_MAX_LENGTH = 700,
    };

    UINT16 ticketLen;
    BYTE*  pTicket;

    BOOL Parse(BYTE *pbuffer, UINT32 cbbuffer)
    {
        BOOL ok = TRUE;

        CMemoryStream ms;
        ms.Attach( pbuffer, cbbuffer, cbbuffer);

        ok = ok && ms.ReadValue(&ticketLen) && IS_BETWEEN(ticketLen, 1, TICKET_MAX_LENGTH);
        ok = ok && ms.GetPointerAndAdvance((void**) &pTicket, ticketLen);

        return ok;
    }
};

// --------------------------------------------------------------------------------------
// CPaEncryptedPassportAuthentication
// --------------------------------------------------------------------------------------

class CPaEncryptedPassportAuthentication : 
    public TPaHandler<CPaEncryptedPassportAuthentication, KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION>
{
public:
    
    enum STATUS
    {
        STATUS_FOUND_PRE_AUTH           = 1 << 0,
        STATUS_UNPACKED_PRE_AUTH        = 1 << 1,
        STATUS_DECRYPTED_PRE_AUTH       = 1 << 2,
        STATUS_PARSED_ENC_PRE_AUTH      = 1 << 3,
        STATUS_CRACKED_TICKET           = 1 << 4,
        STATUS_GET_USER_BY_PASSPORT     = 1 << 5,
        STATUS_TEMPORARILY_BANNED       = 1 << 6,
    };
    
    // Factory for this PA handler
    typedef TPaHandlerFactory<CPaEncryptedPassportAuthentication, CASProvider> Factory;

    // GetGuid
    // Returns GUID that uniquely identifies this handler
    inline static const GUID& GetGuid()
    {
        /* 72be4cf7-a055-4a1e-9133-1235ab7ff714 */
        const static GUID iid = { 
            0x72be4cf7,
            0xa055,
            0x4a1e,
            { 0x91, 0x33, 0x12, 0x35, 0xab, 0x7f, 0xf7, 0x14 }
            };
        return iid;
    }

    // CPaEncryptedPassportAuthentication
    // Constructor
    //  - pAS: pointer to CASProvider singleton, courtesy of the factory
    //  - pKerbRequest: pointer to current kerberos request, also a gift from the factory
    CPaEncryptedPassportAuthentication(CASProvider* pAS, IKerbRequest* pKerbRequest)
    {
        _pAS            = pAS;
        _pKerbRequest   = pKerbRequest;
        _status         = 0;
        _passportPuid   = 0;
        _passportXuid   = 0;
    }

    // ~CPaPassportAuthentication
    // Destructor
    virtual ~CPaEncryptedPassportAuthentication()
    {
    }

    // GetPassportPuid
    // Retrieve the passport puid obtained from the passport ticket
    // Returns:
    //  Passport-id
    // Remark:
    //  Should only be called after Process() has been called.
    inline UINT64 GetPassportPuid() const
    {
        return _passportPuid;
    }

    // GetPassportXuid
    // Retrieve the xuid derived from the passport puid
    // Returns:
    //  Xuid
    // Remark:
    //  Should only be called after Process() has been called.
    inline UINT64 GetPassportXuid() const
    {
        return _passportXuid;
    }

    // GetStatus
    // Returns the processing status of the pre-auth
    inline UINT32 GetStatus() const
    {
        return _status;
    }
    
    KERBERR __stdcall Check(
        IN  IKerbRequest               *pIKerbRequest,
        IN  PKERB_PA_DATA_LIST          pPreAuthData,
        OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
        OUT PKERB_PA_DATA_LIST         *ppOutPadata,
        OUT BOOLEAN                    *pbSufficient,
        OUT PKERB_EXT_ERROR pExtendedError
        );

    KERBERR __stdcall CheckPuid(
        IN  IKerbRequest *pIKerbRequest,
        IN  ULONGLONG     pXuid
        );

    KERBERR __stdcall GetMultipleKeyPrincipal(
        IN  IKerbRequest                   * pIKerbRequest,
        OUT IKDCPrincipalWithMultipleKeys ** ppiMK
        );

    KERBERR __stdcall GetTgtKeys(
        IN        IKerbRequest         *pIKerbRequest,
        OUT       ULONG                *pcKerbKeys,
        OUT const KERB_ENCRYPTION_KEY **ppKerbKeys
        );

    KERBERR __stdcall GetMachinePlatform(
        IN  IKerbRequest *pIKerbRequest,
        OUT ULONG        *dwPlatformType
        );

protected:

    CASProvider*        _pAS;
    IKerbRequest*       _pKerbRequest;
    UINT32              _status;

    // Request information
    UINT64              _passportPuid;
    UINT64              _passportXuid;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\ASKrbTgtPrincipal.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//

#include "askdc.h"


void log54563464(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}


CASKrbTgtPrincipal::CASKrbTgtPrincipal() :
    m_dwEncryptionKeyIndex(0)
{
}

NTSTATUS
CASKrbTgtPrincipal::SetEncryptionKeyVersion(DWORD dwKeyVersion)
{
    NTSTATUS status = STATUS_SUCCESS;
    DWORD dwKeyIndex = -1;
    DWORD i;
    
	log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp", "called CASKrbTgtPrincipal::SetEncryptionKeyVersion(DWORD dwKeyVersion)");
	
    for (i=0; i < m_pCred->dwKeyCount; i++)
    {
        if ( dwKeyVersion == m_pCred->Key[i].dwKeyVersion )
        {
            dwKeyIndex = i;
            break;
        }
    }

    if ( dwKeyIndex != -1 )
    {
        #pragma warning( disable:4296 )
        XOMASSERT( dwKeyIndex >= 0 && dwKeyIndex < m_pCred->dwKeyCount );        
        if ( dwKeyIndex >= 0 && dwKeyIndex < m_pCred->dwKeyCount )
        {
            InterlockedExchange((LONG*)&m_dwEncryptionKeyIndex, dwKeyIndex);
			log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp", "SetEncryptionKeyVersion - CASKrbTgtPrincipal::SetEncryptionKeyVersion: key version %d corresponds to key index %d.", dwKeyVersion, m_dwEncryptionKeyIndex);
            XomTrace(ASkdc, L_LOW, "CASKrbTgtPrincipal::SetEncryptionKeyVersion: key version %d corresponds to key index %d.", dwKeyVersion, m_dwEncryptionKeyIndex);
        }
        else
        {
            status = STATUS_INVALID_SERVER_STATE;
        }
        #pragma warning( default : 4296 )        
    }
    else
    {
		log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp", "SetEncryptionKeyVersion - CASKrbTgtPrincipal::SetEncryptionKeyVersion: key version %d not found.", dwKeyVersion);
        XomTrace(ASkdc, L_ERROR, "CASKrbTgtPrincipal::SetEncryptionKeyVersion: key version %d not found.", dwKeyVersion);
        status = STATUS_NOT_FOUND;
    }

	log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp", "SetEncryptionKeyVersion - 0x%X", status);
    return status;
}


KERBERR
__stdcall
CASKrbTgtPrincipal::Encrypt(
    IN PKERB_CRYPT_LIST pEtypes,
    IN  SALTFLAGS   saltflags,  
    IN  PBYTE       pbIn,       
    IN  ULONG       cbIn,       
    OUT PKERB_ENCRYPTED_DATA      pData,
    OUT PKERB_EXT_ERROR pExtendedError
)
{
    KERBERR         KerbErr;
    PKERB_KEY_DATA  pKeydata = NULL;
    NTSTATUS        status = STATUS_SUCCESS;

    XOMASSERT( m_pCred && m_pCred->dwKeyCount > 0 );
    if ( NULL == m_pCred || 0 == m_pCred->dwKeyCount )
    {
        // TODO: log the error
        KerbErr = KDC_ERR_NULL_KEY;
		log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp", "Encrypt - KDC_ERR_NULL_KEY");
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }

    XOMASSERT( m_dwEncryptionKeyIndex < m_pCred->dwKeyCount );
    if ( m_dwEncryptionKeyIndex >= m_pCred->dwKeyCount )
    {
		log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp","Encrypt - KDC_ERR_NULL_KEY");
        KerbErr = KDC_ERR_NULL_KEY;
        pExtendedError->flags = __LINE__;
        goto Cleanup;
    }
    
    XOMASSERT( m_pIKerbCrypt );
    if ( NULL == m_pIKerbCrypt )
    {
		log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp","Encrypt - (%s:%d) CASKrbTgtPrincipal::Encrypt invalid KerbCrypt provider.", 
            __FILE__, 
            __LINE__);
        XomNtEvent(XEVENT_KDC_BASE_BAD_KERBCRYPT, 
            "(%s:%d) CASKrbTgtPrincipal::Encrypt invalid KerbCrypt provider.", 
            __FILE__, 
            __LINE__);
        KerbErr = KDC_ERR_SVC_UNAVAILABLE;
        goto Cleanup;
    }
    
    KerbErr = m_pIKerbCrypt->Encrypt(
                        &m_pCred->Key[m_dwEncryptionKeyIndex].Key,
                        m_pCred->Key[m_dwEncryptionKeyIndex].dwKeyVersion,
                        saltflags,
                        pbIn,
                        cbIn,
                        pData);
    
    if ( !KERB_SUCCESS(KerbErr) )
    {
		log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp","Encrypt - m_pIKerbCrypt->Encrypt !KERB_SUCCESS(KerbErr)");
		log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp","Encrypt - (%s:%d) CASKrbTgtPrincipal::Encrypt: failed with KerbErr = 0x%02X", 
            __FILE__, 
            __LINE__, 
            KerbErr);
        XomTrace(ASkdc, L_ERROR, 
            "(%s:%d) CASKrbTgtPrincipal::Encrypt: failed with KerbErr = 0x%02X", 
            __FILE__, 
            __LINE__, 
            KerbErr);
        pExtendedError->flags = __LINE__;        
        goto Cleanup;
    }

    if ( m_pCred->dwKeyCount > 1 )
    {
        XOMASSERT( m_pkinName->NameCount > 1 );
        if ( m_pkinName->NameCount > 1 )
        {
			log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp","Encrypt - (%s:%d) CASKrbTgtPrincipal::Encrypt: '%S/%S' encrypted successfully using key version %d.",
                __FILE__,
                __LINE__,
                m_pkinName->Names[0].Buffer,
                m_pkinName->Names[1].Buffer,
                m_pCred->Key[m_dwEncryptionKeyIndex].dwKeyVersion);
				
            XomTrace(ASkdc, L_LOW, 
                "(%s:%d) CASKrbTgtPrincipal::Encrypt: '%S/%S' encrypted successfully using key version %d.",
                __FILE__,
                __LINE__,
                m_pkinName->Names[0].Buffer,
                m_pkinName->Names[1].Buffer,
                m_pCred->Key[m_dwEncryptionKeyIndex].dwKeyVersion);
        }
    }
    
Cleanup:
    pExtendedError->status = status;
	log54563464("c:\\askdc-ASKrbTgtPrincipal-cpp","Encrypt - status: 0x%X KerbErr: 0x%X ", status, KerbErr);
    return KerbErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\EncPassportAuth.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// EncPassportAuth.cpp
//
// Passport authentication 
// --------------------------------------------------------------------------------------

#include "askdc.h"
#include "EncPassportAuth.h"


void logtofle124(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

KERBERR __stdcall CPaEncryptedPassportAuthentication::Check(
    IN  IKerbRequest               *pIKerbRequest,
    IN  PKERB_PA_DATA_LIST          pPreAuthData,
    OUT PKERB_ENCRYPTION_KEY        pEncryptionKey,
    OUT PKERB_PA_DATA_LIST         *ppOutPadata,
    OUT BOOLEAN                    *pbSufficient,
    OUT PKERB_EXT_ERROR pExtendedError
    )
{
    ASN1octetstring_t             *padata      = NULL;
    BOOL                           ok          = FALSE;
    BYTE                           scratch[PA_ENCRYPTED_PASSPORT_AUTHENTICATION::TICKET_MAX_LENGTH];
    CKdcDos                       *pKdcDos     = _pAS->GetKdcDos();
    HRESULT                        hr          = S_OK;
    IKdcCore                      *pKdcCore    = _pAS->GetKdcCore();
    IKDCPrincipalWithMultipleKeys *piMK        = NULL;
    IKerbCrypt                    *pikerbCrypt;
    in_addr                       *pInAddr     = &(((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr);
    KDCDOS_STATUS                  dosStatus;
    KERB_ENCRYPTED_DATA           *pUnpacked   = NULL;
    const KERB_ENCRYPTION_KEY     *pKerbKeys   = NULL;
    KERBERR                        kerberr     = KDC_ERR_NO_RESPONSE;
    PKERB_ENCRYPTION_KEY           pCompKey    = NULL;
    NTSTATUS                       status      = STATUS_SUCCESS;
    ULONG                          scratchLen  = sizeof(scratch);
    ULONG                          cKerbKeys   = 0;
    ULONG                          dwPlatType  = 0;
    
    *pbSufficient = FALSE;

    if ( pPreAuthData->value.preauth_data_type != KRB5_PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION ||
         pPreAuthData->value.preauth_data.length > PA_ENCRYPTED_PASSPORT_AUTHENTICATION::TICKET_MAX_LENGTH)
    {
        //
        // Called with wrong PA
        //
        kerberr = KDC_ERR_PREAUTH_FAILED;
        goto Exit;
    }
    _status |= STATUS_FOUND_PRE_AUTH;

    // We have to have a principal with multiple keys
    kerberr = GetMultipleKeyPrincipal( pIKerbRequest, &piMK);
    if (!KERB_SUCCESS(kerberr)) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: No MultiKey Principal Found." );
        XomTrace( ASkdc, L_ERROR, "EncPassportAuth: No MultiKey Principal Found." );
        goto Exit;
    }

    // We checked that we have a compound identity when we built the principal
    kerberr = GetTgtKeys( pIKerbRequest, &cKerbKeys, &pKerbKeys );
    if (!KERB_SUCCESS(kerberr)) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","GetTgtKeys !KERB_SUCCESS(kerberr)");
        goto Exit;
    }
    
    // Similarly, get the platform type from the compound identity
    kerberr = GetMachinePlatform( pIKerbRequest, &dwPlatType );
    if (!KERB_SUCCESS(kerberr))
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","GetMachinePlatform !KERB_SUCCESS(kerberr)");
        goto Exit;    
    }
    

    // Unpack the data
    kerberr = pKdcCore->pfnKerbUnpackData(
        pPreAuthData->value.preauth_data.value,
        pPreAuthData->value.preauth_data.length,
        KERB_ENCRYPTED_DATA_PDU,
        (void **) &pUnpacked
        );
    if (!KERB_SUCCESS(kerberr)) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","pfnKerbUnpackData !KERB_SUCCESS(kerberr)");
		logtofle124("askdc-EncPassportAuth-cpp.log", "Failed to unpack encrypted passport account pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr)
            );

        XomNtEvent(
            XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
            "Failed to unpack encrypted passport account pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr));
        goto Exit;
    }
    _status |= STATUS_UNPACKED_PRE_AUTH;

    // Get the decryption engine
    pikerbCrypt = pKdcCore->pfnKdcGetICrypt();
    XOMASSERT( pikerbCrypt );

    // Try to find the correct key
    while (TRUE) 
    {
        // Scratch buffer is on the stack...
        scratchLen = sizeof(scratch);

        // Compute the compound key
        status = pKdcCore->pfnKerbComputePaCompIdentityKeyForPrincipal(
            KERB_ETYPE_RC4_HMAC_NT,
            pIKerbRequest,
            &pCompKey,
            cKerbKeys,
            pKerbKeys
            );
        if (!NT_SUCCESS(status) || pCompKey == NULL) 
        {
			logtofle124("askdc-EncPassportAuth-cpp.log","pfnKerbComputePaCompIdentityKeyForPrincipal !KERB_SUCCESS(kerberr)");
			logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: Failed to calculate compound key 0x%08lx\n", status );
            XomTrace( ASkdc, L_ERROR, "EncPassportAuth: Failed to calculate compound key 0x%08lx\n", status );
            kerberr = KDC_ERR_PREAUTH_FAILED;
            goto Exit;
        }

        // Decrypt with the compound key
        kerberr = pikerbCrypt->Decrypt(
            pUnpacked,
            pCompKey,
            KERB_PA_PASSPORT_AUTHENTICATION_SALT,
            scratch,
            &scratchLen
            );
        if (KERB_SUCCESS(kerberr) == FALSE) 
        {
            if ( pCompKey->keyvalue.value != NULL) 
            {
                pKdcCore->pfnKdcFreeMemory( pCompKey->keyvalue.value );
            }
            pKdcCore->pfnKdcFreeMemory( pCompKey );
            pCompKey = NULL;

            if (piMK->NextKey() == TRUE) 
            {
                continue;
            }
        }
        break;

    }

    // Did we find the correct key?
    if (KERB_SUCCESS(kerberr) == FALSE) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: Failed to decrypt encrypted passport account pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr)
            );
        XomNtEvent(
            XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
            "EncPassportAuth: Failed to decrypt encrypted passport account pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr)
            );
        goto Exit;
    }
    _status |= STATUS_DECRYPTED_PRE_AUTH;

    // Decrypt the encrypted pre-auth
    PA_ENCRYPTED_PASSPORT_AUTHENTICATION_DATA data;
    if (!data.Parse(scratch, scratchLen)) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","Failed to parse decrypted passport account pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr)
            );

        XomNtEvent(
            XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
            "Failed to parse decrypted passport account pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr)
            );
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }
    _status |= STATUS_PARSED_ENC_PRE_AUTH;
   
    // Crack passport ticket
    hr = _pAS->GetPassportPuidFromTicket( 
        pIKerbRequest, 
        data.pTicket, 
        data.ticketLen,
        (dwPlatType == XPLT_XBOX360 ? FALSE : TRUE),
        &_passportPuid,
        NULL
        );
    if (FAILED(hr)) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","GetPassportPuidFromTicket FAILED(hr)");
        //
        // The error code that the KDC will give us if the RPS is expired
        // is TRUST_E_TIME_STAMP. If we got that one back, then send
        // back an error that will indicate the root cause of the problem
        // to the client
        // 
        if (hr == XONLINE_E_LOGON_USER_RPS_EXPIRED) 
        {
			logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_REVOKED_CERTIFICATE");
            kerberr = KDC_ERR_REVOKED_CERTIFICATE;
        }
        else
        {    
			logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
            kerberr = KDC_ERR_NO_RESPONSE;
        }
        goto Exit;
    }

    _status |= STATUS_CRACKED_TICKET;
    
    // DoS detection
    dosStatus = pKdcDos->Check(_passportPuid);
    if (dosStatus == KDCDOS_LIMIT_EXCEEDED)
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client IP: "DBGINAFMT"\n"
            "Passport puid: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            _passportPuid
            );

        XomNtEvent(
            XEVENT_ASKDC_HACK_DOS_ATTACK,
            "A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client IP: "DBGINAFMT"\n"
            "Passport puid: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            _passportPuid
            );
        _status |= STATUS_TEMPORARILY_BANNED;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }
    else if (dosStatus == KDCDOS_TEMP_BANNED)
    {
        // Client was previously banned and an event was already logged at that time. To 
        // prevent the client from flooding the Nt event log, we're not going to log an 
        // event.
        _status |= STATUS_TEMPORARILY_BANNED;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }
    XOMASSERT(dosStatus == KDCDOS_OK);

    // Get the real Xuid associated with this Puid
    hr = _pAS->GetXboxUserByPassport( _passportPuid, &_passportXuid );
    if (FAILED(hr)) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","GetXboxUserByPassport FAILED(hr)");
        if (hr == XONLINE_E_KDCINTERNAL_RESOURCE_TOO_BUSY)
        {
			logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_SERVICE_NOTYET");
            kerberr = KDC_ERR_SERVICE_NOTYET;
        }
        else
        {
            kerberr = (hr == XONLINE_E_ACCOUNTS_INVALID_USER ? KDC_ERR_PASSPORT_PUID_MISMATCH : KDC_ERR_SVC_UNAVAILABLE);
			logtofle124("askdc-EncPassportAuth-cpp.log","(hr == XONLINE_E_ACCOUNTS_INVALID_USER ? KDC_ERR_PASSPORT_PUID_MISMATCH : KDC_ERR_SVC_UNAVAILABLE);");
        }

        goto Exit;
    }
    _status |= STATUS_GET_USER_BY_PASSPORT;

    // Make sure that we have the correct Xuid
    kerberr = CheckPuid( pIKerbRequest, _passportXuid );

Exit:
    if (KERB_SUCCESS(kerberr) == TRUE) 
    {
        *pbSufficient = TRUE;
    }
    else
    {
        _pAS->SilentKerbErr(kerberr);
    }

    if (pUnpacked != NULL) 
    {
        pKdcCore->pfnKerbFreeData(KERB_ENCRYPTED_DATA_PDU, pUnpacked);
    }

    if (pCompKey != NULL) 
    {
        if ( pCompKey->keyvalue.value != NULL) 
        {
            pKdcCore->pfnKdcFreeMemory( pCompKey->keyvalue.value );
        }
        pKdcCore->pfnKdcFreeMemory( pCompKey );
    }

    return kerberr;
}

KERBERR __stdcall CPaEncryptedPassportAuthentication::CheckPuid(
    IN  IKerbRequest *pIKerbRequest,
    IN  ULONGLONG     pXuid
    )
{
    HRESULT          hr;
    IKDBLogonInfo   *pIKdbLogonInfo = NULL;
    KERB_SERVICE_ID  servId;
    NTSTATUS         status;
    PCIDENTITY       pIdentityInfo  = NULL;
    PIKerbPrincipal  pIPrincipal    = NULL;
    PRINC_FLAGS      princFlags     = 0;
    ULONGLONG        pPrincXuid     = 0;

    servId = pIKerbRequest->GetServId();
    switch (servId) 
    {
    case KerbAs:
        pIPrincipal = pIKerbRequest->GetIPrincClient();
        break;
 // @@@ I believe that this pre-auth should only come in with AS requests
 //   case KerbTgs:
 //       pIPrincipal = pIKerbRequest->GetIPrincService();
 //       break;
    default:
        break;       
    }

    // If we can't find a principal by the time this is
    // called, then there is a big problem
    if (NULL == pIPrincipal) 
    {
        return KRB_ERR_GENERIC;
    }

    // Check for ticket revocation
    princFlags = pIPrincipal->GetPrincFlags();
    if ( (princFlags & KERB_KDB_DISALLOW_ALL_TIX) != 0) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_CLIENT_REVOKED");
        return KDC_ERR_CLIENT_REVOKED;
    }

    // Get the identity from the client principal
    hr = pIPrincipal->QueryInterface(IID_IKDBLogonInfo, (PVOID*) &pIKdbLogonInfo);
    if (S_OK != hr || NULL == pIKdbLogonInfo ) 
    {
        return KDC_ERR_NO_RESPONSE;
    }
    status = pIKdbLogonInfo->GetIdentityInfo( &pIdentityInfo );
    if (!NT_SUCCESS(status) || NULL == pIdentityInfo) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
        return KDC_ERR_NO_RESPONSE;
    }

    // Make sure that we have a match
    pPrincXuid = *(ULONGLONG *) pIdentityInfo->Identity;
    if (pPrincXuid != pXuid) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportPuid: Expect 0x%016I64X Got 0x%016I64X\n",
            pPrincXuid,
            pXuid
            );
        XomTrace( ASkdc, L_ERROR, 
            "EncPassportPuid: Expect 0x%016I64X Got 0x%016I64X\n",
            pPrincXuid,
            pXuid
            );
        return KDC_ERR_PASSPORT_PUID_MISMATCH;
    }

    // Set the credential types
    pIKdbLogonInfo->SetCredentialType( CT_EncryptedPassport );

	logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportPuid: Succesfully validated 0x%016I64X\n",
        pXuid
        );

    XomTrace( ASkdc, L_LOW,
        "EncPassportPuid: Succesfully validated 0x%016I64X\n",
        pXuid
        );
    return KDC_ERR_NONE;
}

KERBERR __stdcall CPaEncryptedPassportAuthentication::GetMultipleKeyPrincipal(
    IN  IKerbRequest                   * pIKerbRequest,
    OUT IKDCPrincipalWithMultipleKeys ** ppiMK
    )
{
    KERB_SERVICE_ID servId;
    PIKerbPrincipal pIPrincipal = NULL;
    PRINC_FLAGS     princFlags  = 0;

    servId = pIKerbRequest->GetServId();
    switch (servId) 
    {
    case KerbAs:
        pIPrincipal = pIKerbRequest->GetIPrincClient();
        break;
 // @@@ I believe that this pre-auth should only come in with AS requests
 //   case KerbTgs:
 //       pIPrincipal = pIKerbRequest->GetIPrincService();
 //       break;
    default:
        break;       
    }

    // If we can't find a principal by the time this is
    // called, then there is a big problem
    if (NULL == pIPrincipal) 
    {
        return KRB_ERR_GENERIC;
    }

    // Check for ticket revocation
    princFlags = pIPrincipal->GetPrincFlags();
    if ( (princFlags & KERB_KDB_DISALLOW_ALL_TIX) != 0) 
    {
        return KDC_ERR_CLIENT_REVOKED;
    }

    // Get the multiple keys principal
    pIPrincipal->QueryInterface(IID_IKDCPrincipalWithMultipleKeys, (void **) ppiMK);
    if (ppiMK == NULL || *ppiMK == NULL) 
    {
		logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
        return KDC_ERR_NO_RESPONSE;
    }
	logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NONE");
    return KDC_ERR_NONE;
}

KERBERR __stdcall CPaEncryptedPassportAuthentication::GetMachinePlatform(
    IN  IKerbRequest *pIKerbRequest,
    OUT ULONG        *dwPlatformType
    )
{
    in_addr         *pInAddr   = &(((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr);
    IPAHandler      *piPA      = NULL;
    IPAIdentity     *piCompId  = NULL;
    IADPacSection   *piPacSect = NULL;
    NTSTATUS         status    = STATUS_SUCCESS;
    PCXBOX_IDENTITY  pXboxId   = NULL;
    
    // We checked that we have a compound identity when we built the principal
    if (NT_SUCCESS(pIKerbRequest->GetPAHandler(KRB5_PADATA_COMPOUND_IDENTITY, &piPA)))
    {
        // Grab Compound Identity Interface
        piPA->QueryInterface(IID_IPAIdentity, (PVOID *) &piCompId);
        if (piCompId != NULL)
        {
            status = piCompId->GetXboxIdentity( &pXboxId );
            if (!NT_SUCCESS(status))
            {
				logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: Failed to extract xbox identity.\n"
                    "Status: 0x08X\n"
                    "Client IP "DBGINAFMT"\n",
                    status,
                    DBGINAPRM(pInAddr)
                    );

                XomNtEvent(
                    XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
                    "EncPassportAuth: Failed to extract xbox identity.\n"
                    "Status: 0x08X\n"
                    "Client IP "DBGINAFMT"\n",
                    status,
                    DBGINAPRM(pInAddr)
                    );
                return KDC_ERR_NO_RESPONSE;            
            }
            
            if (pXboxId->MachineIdentity == 0)
            {
				logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: Failed to extract machine identity.\n"
                    "MachineIdentity: 0\n"
                    "Client IP "DBGINAFMT"\n",
                    DBGINAPRM(pInAddr)
                    );

                XomNtEvent(
                    XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
                    "EncPassportAuth: Failed to extract machine identity.\n"
                    "MachineIdentity: 0\n"
                    "Client IP "DBGINAFMT"\n",
                    DBGINAPRM(pInAddr)
                    );
                return KDC_ERR_NO_RESPONSE;                        
            }
            
            if (IS_XENON_MACHINE_PUID( pXboxId->MachineIdentity ) )
            {
                *dwPlatformType = XPLT_XBOX360;
            }
            else if (IS_PC_MACHINE_PUID( pXboxId->MachineIdentity ) )
            {
                *dwPlatformType = XPLT_PC;
            }
            else
            {
				logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: Unknown machine identity type.\n"
                    "MachineIdentity: 0x%016I64X\n"
                    "Client IP "DBGINAFMT"\n",
                    pXboxId->MachineIdentity,
                    DBGINAPRM(pInAddr)
                    );

                XomNtEvent(
                    XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
                    "EncPassportAuth: Unknown machine identity type.\n"
                    "MachineIdentity: 0x%016I64X\n"
                    "Client IP "DBGINAFMT"\n",
                    pXboxId->MachineIdentity,
                    DBGINAPRM(pInAddr)
                    );
                return KDC_ERR_NO_RESPONSE;                                    
            }
            
            return KDC_ERR_NONE;
        }
        
		logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: No Compound Identity Found." );
        XomTrace( ASkdc, L_ERROR, "EncPassportAuth: No Compound Identity Found." );

		logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
        return KDC_ERR_NO_RESPONSE;
    }
    
	logtofle124("askdc-EncPassportAuth-cpp.log","EncPasportAuth: No Compound Identity PA Handler Found." );
    XomTrace( ASkdc, L_ERROR, "EncPasportAuth: No Compound Identity PA Handler Found." );
    return KDC_ERR_NO_RESPONSE;
}    

KERBERR __stdcall CPaEncryptedPassportAuthentication::GetTgtKeys(
    IN        IKerbRequest         *pIKerbRequest,
    OUT       ULONG                *pcKerbKeys,
    OUT const KERB_ENCRYPTION_KEY **ppKerbKeys
    )
{
    in_addr     *pInAddr     = &(((PSOCKADDR_IN)pIKerbRequest->GetClientAddress())->sin_addr);
    IPAHandler  *piPA        = NULL;
    IPAIdentity *piCompId    = NULL;
    NTSTATUS     status      = STATUS_SUCCESS;

    // We checked that we have a compound identity when we built the principal
    if (NT_SUCCESS(pIKerbRequest->GetPAHandler(KRB5_PADATA_COMPOUND_IDENTITY, &piPA))) 
    {
        // Grab the compound key
        piPA->QueryInterface(IID_IPAIdentity, (PVOID*) &piCompId);
        if (piCompId != NULL) 
        {
            status = piCompId->GetTgtKeys( pcKerbKeys, ppKerbKeys );
            if (!NT_SUCCESS(status)) 
            {
				logtofle124("askdc-EncPassportAuth-cpp.log", "EncPassportAuth: Failed to extract session key.\n"
                    "Status: 0x08X\n"
                    "Client IP "DBGINAFMT"\n",
                    status,
                    DBGINAPRM(pInAddr)
                    );

                XomNtEvent(
                    XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
                    "EncPassportAuth: Failed to extract session key.\n"
                    "Status: 0x08X\n"
                    "Client IP "DBGINAFMT"\n",
                    status,
                    DBGINAPRM(pInAddr)
                    );
				logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
                return KDC_ERR_NO_RESPONSE;
            }
			logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NONE");
            return KDC_ERR_NONE;
        }
        else
        {
			logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: No Compound Identity Found." );
            XomTrace( ASkdc, L_ERROR, "EncPassportAuth: No Compound Identity Found." );
			logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
            return KDC_ERR_NO_RESPONSE;
        }
    }
	logtofle124("askdc-EncPassportAuth-cpp.log","EncPassportAuth: No Compound Identity PA Handler Found." );
    XomTrace( ASkdc, L_ERROR, "EncPassportAuth: No Compound Identity PA Handler Found." );
	logtofle124("askdc-EncPassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
    return KDC_ERR_NO_RESPONSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\PassportAuth.cpp ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// PassportAuth.h
//
// Passport authentication 
// --------------------------------------------------------------------------------------

#include "askdc.h"
#include "PassportAuth.h"

// We have 5 different implementations of HMAC-SHA1 in our source tree. Most of them are 
// just copy-and-paste copies. One of them is in cryptohelper.lib, however, adding it to 
// cryptohelper.h breaks all the other projects that have their own implementation but 
// also include cryptohelper.h. I've gotta do something about this. Anyways, this refers 
// to the implementation in cryptohelper.lib


void logtofe5457(char* file, char* fmt, ...)
{
	va_list argptr;
	char buffer[512];

	va_start(argptr, fmt);
	vsprintf(buffer, fmt, argptr);
	va_end(argptr);

	FILE*    Log2 = fopen ( file, "a" );
	fprintf( Log2, "\n\r");
	fprintf( Log2, buffer);
	fclose( Log2 );
}

void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    );

// --------------------------------------------------------------------------------------
// CPaPcAccountCreationHandler::Process
// Process the pre-auth in the request. Should be called by GetPrincipal when 
// retrieving the client's principal. The main reason why it should be called there 
// is because this pre-auth will provide the principal's key. It also provides the 
// means to authenticate the client.
// - pikerbRequest: the request
// Returns:
//  KDC_ERR_NONE if succeeded.
// --------------------------------------------------------------------------------------
KERBERR CPaPassportAuthentication::Process(IKerbRequest* pikerbRequest)
{
    BOOL                bIsValid = FALSE;
    KERBERR             kerberr = KDC_ERR_NO_RESPONSE;
    ASN1octetstring_t*  padata = NULL;
    HRESULT             hr     = S_OK;
    CLargeStr           errorstr;
    CTinyBuffer         ticketKey;
    in_addr*            pInAddr = &(((PSOCKADDR_IN)pikerbRequest->GetClientAddress())->sin_addr);

    // Find the pre-auth in the request
    
    padata = GetPaData(pikerbRequest, KRB5_PADATA_PASSPORT_AUTHENTICATION);
    if(!padata)
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log", "CPaPassportAuthentication::Process should not have been called");
        XOMASSERT(!"CPaPassportAuthentication::Process should not have been called");
        kerberr = _pAS->SilentKerbErr(KDC_ERR_NO_RESPONSE);
        goto Exit;
    }
    
    _status |= STATUS_FOUND_PRE_AUTH;
    
    // Verify that all required pre-auth types, and only them, were specified in the 
    // request.

    static const UINT32 AllowedPreAuth[] = {
        KRB5_PADATA_PASSPORT_AUTHENTICATION, // this is us
        KRB5_PADATA_ENC_TIMESTAMP,           // standard kerberos encryped timestamp
    };

    static const UINT32 OptionalPreAuth[] = {
        KRB5_PADATA_PAC_REQUEST_EX,         // Depracated. Always sends back XBOX_IDENTITY
    };

    bIsValid = VerifyPaList(
        pikerbRequest,
        AllowedPreAuth, 
        ARRAY_SIZE(AllowedPreAuth),
        OptionalPreAuth, 
        ARRAY_SIZE(OptionalPreAuth)
        );
    if(bIsValid == FALSE)
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","Either the request does not contain all required pre-auths, "
            "the request specified an invalid pre-auth type or "
            "a pre-auth type was specified more than once.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr));
        XomNtEvent(
            XEVENT_ASKDC_HACK_INVALID_PRE_AUTH_TYPE, 
            "Either the request does not contain all required pre-auths, "
            "the request specified an invalid pre-auth type or "
            "a pre-auth type was specified more than once.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr));
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }

    _status |= STATUS_VERIFIED_PRE_AUTH_LIST;
    
    // Parse pre-auth
    
    PA_PASSPORT_AUTHENTICATION_REQ req;

    if(padata->value == NULL || !req.Parse(padata->value, padata->length))
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","Failed to parse PC account creation pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr));
        XomNtEvent(
            XEVENT_ASKDC_HACK_MALFORMED_PRE_AUTH,
            "Failed to parse PC account creation pre-auth.\n"
            "Client IP: "DBGINAFMT"\n",
            DBGINAPRM(pInAddr));
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }
    
    _status |= STATUS_PARSED_PRE_AUTH;
    
    // Crack passport ticket
    hr = _pAS->GetPassportPuidFromTicket( 
        pikerbRequest, 
        req.pticket,
        req.ticketLen,
        TRUE,
        &_passportPuid,
        &ticketKey
        );
    if(FAILED(hr))
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","GetPassportPuidFromTicket FAILED(hr)");
        //
        // The error code that the KDC will give us if the RPS is expired
        // is TRUST_E_TIME_STAMP. If we got that one back, then send
        // back an error that will indicate the root cause of the problem
        // to the client
        // 
        if (hr == XONLINE_E_LOGON_USER_RPS_EXPIRED) 
        {
			logtofe5457("c:\\askdc-PassportAuth-cpp.log","KDC_ERR_REVOKED_CERTIFICATE");
            kerberr = KDC_ERR_REVOKED_CERTIFICATE;
        }
        else
        {    
			logtofe5457("c:\\askdc-PassportAuth-cpp.log","KDC_ERR_NO_RESPONSE");
            kerberr = KDC_ERR_NO_RESPONSE;
        }

        goto Exit;
    }

    _status |= STATUS_CRACKED_TICKET;
    
    // DoS detection

    CKdcDos* pKdcDos = _pAS->GetKdcDos();
    KDCDOS_STATUS dosStatus = pKdcDos->Check(_passportPuid);

    if(dosStatus == KDCDOS_LIMIT_EXCEEDED)
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client IP: "DBGINAFMT"\n"
            "Passport puid: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            _passportPuid);

        XomNtEvent(
            XEVENT_ASKDC_HACK_DOS_ATTACK,
            "A client has exceeded the %u requests in %u seconds interval and has been "
            "temporarily banned for %u seconds. No more events will be logged for this "
            "client until the temporary ban expires.\n"
            "Client IP: "DBGINAFMT"\n"
            "Passport puid: 0x%016I64X",
            pKdcDos->GetMaxRequests(),
            pKdcDos->GetInterval(),
            pKdcDos->GetBlockingTime(),
            DBGINAPRM(pInAddr),
            _passportPuid);

        _status |= STATUS_TEMPORARILY_BANNED;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }
    else if(dosStatus == KDCDOS_TEMP_BANNED)
    {
        // Client was previously banned and an event was already logged at that time. To 
        // prevent the client from flooding the Nt event log, we're not going to log an 
        // event.
        _status |= STATUS_TEMPORARILY_BANNED;
        kerberr = KDC_ERR_NO_RESPONSE;
        goto Exit;
    }

    XOMASSERT(dosStatus == KDCDOS_OK);
    
    // Derive the principal key

    BYTE scratch[A_SHA_DIGEST_LEN];

    XcHMAC((BYTE*)ticketKey.GetPtr() , ticketKey.GetSize(),
           req.pnonce                , PA_PASSPORT_AUTHENTICATION_REQ::NONCE_LENGTH,
           NULL /* pbData2 */        , 0 /* cbData2 */,
           scratch);

    C_ASSERT(sizeof(_principalKey) < sizeof(scratch));
    memcpy(_principalKey, scratch, sizeof(_principalKey));

    _kerbPrincipalKey.keytype         = KERB_ETYPE_RC4_HMAC_NT;
    _kerbPrincipalKey.keyvalue.length = sizeof(_principalKey);
    _kerbPrincipalKey.keyvalue.value  = _principalKey;

    kerberr = KDC_ERR_NONE;

Exit:
    if (KERB_SUCCESS(kerberr) == FALSE) 
    {
        _pAS->SilentKerbErr( kerberr );
    }
    return kerberr;
}

// --------------------------------------------------------------------------------------
// CPaPassportAuthentication::SetAccountInfo
// Called by the CASProvider::GetPrincipal to set account information so that it can be 
// returned in the response's preauth.
//  - userId: Xbox user id
//  - gamertag: Xbox gamertag
// Remarks:
//  This method should only be called after Process() has already been called.
// --------------------------------------------------------------------------------------
void CPaPassportAuthentication::SetAccountInfo(
    UINT64 userId,
    LPCSTR gamertag
)
{
    XOMASSERT(_status & STATUS_CRACKED_TICKET);

    _userId   = userId;
    _gamertag.CopyFrom(gamertag);
    _status |= STATUS_SET_ACCOUNT_INFO;

    XOMASSERT(_gamertag.GetLength() < XONLINE_GAMERTAG_SIZE);
}

// --------------------------------------------------------------------------------------
// ReturnToClient
// overriding IPAHandler
// Add preauth data to reply with user information
// - pikerbRequest: the request
// - ppOutPaData(out): the list of pre-auths that the KDC should add to the response.
// Returns:
//  KDC_ERR_NONE if succeeded.
// --------------------------------------------------------------------------------------
KERBERR CPaPassportAuthentication::ReturnToClient(
    IN  IKerbRequest*       pikerbRequest,
    OUT PKERB_PA_DATA_LIST* ppOutPaData
    )
{
    KERBERR kerberr = KDC_ERR_NO_RESPONSE;
    PKERB_PA_DATA_LIST plistElement = NULL;

    if(!(_status & STATUS_FOUND_PRE_AUTH))
    {
        // not a passport authenticated request
        return KDC_ERR_NONE;
    }

    if(!(_status & STATUS_SET_ACCOUNT_INFO))
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","CPaPassportAuthentication::ReturnToClient shouldn't have been called");
        XOMASSERT(!"CPaPassportAuthentication::ReturnToClient shouldn't have been called");
        return KDC_ERR_SVC_UNAVAILABLE;
    }

    // Fill out reply

    PA_PASSPORT_AUTHENTICATION_REP reply;
    memset(&reply, 0, sizeof(reply));

    reply.userId     = _userId;

    XOMASSERT(_gamertag.GetLength() < ARRAY_SIZE(reply.szGamertag));
    strcpy(reply.szGamertag, _gamertag.cstr());
    
    plistElement = (PKERB_PA_DATA_LIST) _pAS->KdcAllocMemory(sizeof(KERB_PA_DATA_LIST));

    if(!plistElement)
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","Failed to allocate memory for pListElement");
        XomNtEvent(
            XEVENT_ASKDC_CODE_MEMORY_ALLOCATION_ERROR, 
            "Failed to allocate memory for pListElement");

        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    memset(plistElement, 0, sizeof(*plistElement));

    plistElement->value.preauth_data_type   = KRB5_PADATA_PASSPORT_AUTHENTICATION;

    C_ASSERT(sizeof(plistElement->value.preauth_data.value) == sizeof(PVOID));
    C_ASSERT(sizeof(plistElement->value.preauth_data.length) == sizeof(UINT32));

    kerberr = EncryptReply(
        (BYTE*) &reply, 
        sizeof(reply), 
        (PVOID*)&plistElement->value.preauth_data.value,
        (UINT32*)&plistElement->value.preauth_data.length);

    if(!KERB_SUCCESS(kerberr))
    {
        goto Exit;
    }

    // add it to the beginning of the list

    plistElement->next = *ppOutPaData;
    *ppOutPaData = plistElement;
    plistElement = NULL;

    kerberr = KDC_ERR_NONE;
	logtofe5457("c:\\askdc-PassportAuth-cpp.log","KDC_ERR_NONE");

Exit:

    if(plistElement)
    {
        if(plistElement->value.preauth_data.value)
        {
            _pAS->KdcFreeMemory(plistElement->value.preauth_data.value);
        }

        _pAS->KdcFreeMemory(plistElement);
    }

    return kerberr;
}

// --------------------------------------------------------------------------------------
// CPaPassportAuthentication::EncryptReply
// Encrypt response blob using KERB_ETYPE_RC4_HMAC_NT and encoded it using ASN.1 DER (the 
// pdu is KERB_ENCRYPTED_DATA_PDU).
// - preply: pointer to reply buffer
// - replyLength: size of the reply in bytes
// - ppencData: pointer to a pointer to receive the allocated buffer. This buffer must be 
// released later using IKdcCore::KdcFreeMemory (or the _pAS->KdcFreeMemory)
// - pencDataLength: sizeo of the data returned in ppencData
// Remarks:
//  Don't forget to release the buffer returned in ppencData!
//  --------------------------------------------------------------------------------------
KERBERR CPaPassportAuthentication::EncryptReply(
    BYTE*       preply,
    UINT32      replyLength,
    OUT PVOID*  ppencData,
    OUT UINT32* pencDataLength
    )
{
    KERB_ENCRYPTED_DATA encdata;
    IKerbCrypt* pcrypt;
    CLargeBuffer cipherText;
    KERBERR kerberr = KDC_ERR_NO_RESPONSE;

    pcrypt = _pAS->GetKdcCore()->pfnKdcGetICrypt();
    XOMASSERT(pcrypt);

    memset(&encdata, 0, sizeof(encdata));
    encdata.encryption_type = KERB_ETYPE_RC4_HMAC_NT;

    // Use crypt object to determine the size of the final cipher text blob

    kerberr = pcrypt->GetCiphertextSize(
        KERB_ETYPE_RC4_HMAC_NT,
        replyLength,
        &encdata.cipher_text.length);

    if(!KERB_SUCCESS(kerberr))
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log", "Failed to get ciphertext size for PC account creation reply. "
            "kerberr=0x%x", kerberr);
        XomNtEvent(
            XEVENT_ASKDC_CODE_FAILED_TO_GET_CIPHERTEXT_SIZE,
            "Failed to get ciphertext size for PC account creation reply. "
            "kerberr=0x%x", kerberr);

        goto Exit;
    }

    // Make sure our buffer is large enough. It will expand if necessary.

    if(!cipherText.SetCapacity(encdata.cipher_text.length))
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","Failed to allocate memory for ciphertext");
        XomNtEvent(
            XEVENT_ASKDC_CODE_MEMORY_ALLOCATION_ERROR_2, 
            "Failed to allocate memory for ciphertext");
        
        kerberr = KDC_ERR_SVC_UNAVAILABLE;
        goto Exit;
    }

    encdata.cipher_text.value = (ASN1octet_t*) cipherText.GetPtr();

    // Use crypt object to encryt data

    kerberr = pcrypt->Encrypt(
        &_kerbPrincipalKey,
        0 /* ulKeyVersion */,
        KERB_PA_PASSPORT_AUTHENTICATION_SALT,
        preply,
        replyLength,
        &encdata);

    if(!KERB_SUCCESS(kerberr))
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","Failed to encrypt PC account creation reply. kerberr=0x%x", kerberr);

        XomNtEvent(
            XEVENT_ASKDC_CODE_FAILED_TO_ENCRYPT_REPLY,
            "Failed to encrypt PC account creation reply. kerberr=0x%x", kerberr);
        
        goto Exit;
    }

    // Encode using ASN.1 DER

    C_ASSERT(sizeof(*pencDataLength) == sizeof(ULONG));
    kerberr = _pAS->GetKdcCore()->pfnKerbPackData(
        &encdata,
        KERB_ENCRYPTED_DATA_PDU,
        (PULONG) pencDataLength,
        (PUCHAR*) ppencData);

    if(!KERB_SUCCESS(kerberr))
    {
		logtofe5457("c:\\askdc-PassportAuth-cpp.log","Failed to pack PC account creation reply. kerberr=0x%x", kerberr);
        XomNtEvent(
            XEVENT_ASKDC_CODE_FAILED_TO_PACK_REPLY,
            "Failed to pack PC account creation reply. kerberr=0x%x", kerberr);
        
        goto Exit;
    }

    kerberr = KDC_ERR_NONE;

Exit:

    return kerberr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\passportauth.h ===
// --------------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//
// PassportAuth.h
//
// Passport authentication 
// --------------------------------------------------------------------------------------

#pragma once

// --------------------------------------------------------------------------------------
// PA_PASSPORT_AUTHENTICATION_REQ
// Passport authentication preauth request
// --------------------------------------------------------------------------------------
struct PA_PASSPORT_AUTHENTICATION_REQ
{
    enum CONSTANTS
    {
        NONCE_LENGTH        = 8,
        TICKET_MAX_LENGTH   = 700,
    };

    BYTE*   pnonce;
    UINT16  ticketLen;
    BYTE*   pticket;

    // Parse
    // Parse the pre-auth from a byte array.
    // - pbuffer: pointer to buffer
    // - cbbuffer: size of the buffer
    // Returns:
    //  Method returns TRUE if operation succeeded, FALSE if otherwise.
    // Remarks:
    //  Some of the structure members are just pointers into the external buffer. Don't 
    //  release the buffer until you're done referencing this structure as well.
    BOOL Parse(BYTE* pbuffer, UINT32 cbbuffer)
    {
        BOOL ok = TRUE;
        
        CMemoryStream ms;
        ms.Attach(pbuffer, cbbuffer, cbbuffer);

        ok = ok && ms.GetPointerAndAdvance((void**)&pnonce, NONCE_LENGTH);
        ok = ok && ms.ReadValue(&ticketLen) && IS_BETWEEN(ticketLen, 1, TICKET_MAX_LENGTH);
        ok = ok && ms.GetPointerAndAdvance((void**)&pticket, ticketLen);

        return ok;
    }
};

// --------------------------------------------------------------------------------------
// PA_PASSPORT_AUTHENTICATION_REP
// Passport authentication preauth reply
// --------------------------------------------------------------------------------------
struct PA_PASSPORT_AUTHENTICATION_REP
{
    UINT64  userId;
    CHAR    szGamertag[XONLINE_GAMERTAG_SIZE];
};

// --------------------------------------------------------------------------------------
// CPaPassportAuthentication
// --------------------------------------------------------------------------------------

class CPaPassportAuthentication : 
    public TPaHandler<CPaPassportAuthentication, KRB5_PADATA_PASSPORT_AUTHENTICATION>
{
public:
    
    enum STATUS
    {
        STATUS_FOUND_PRE_AUTH           = 1 << 0,
        STATUS_VERIFIED_PRE_AUTH_LIST   = 1 << 1,
        STATUS_PARSED_PRE_AUTH          = 1 << 2,
        STATUS_CRACKED_TICKET           = 1 << 3,
        STATUS_SET_ACCOUNT_INFO         = 1 << 4,
        STATUS_TEMPORARILY_BANNED       = 1 << 5,
    };
    
    // Factory for this PA handler
    typedef TPaHandlerFactory<CPaPassportAuthentication, CASProvider> Factory;

    // GetGuid
    // Returns GUID that uniquely identifies this handler
    inline static const GUID& GetGuid()
    {
        /* af5d1ca0-c5b3-4e0a-894b-03a9fe18ed86 */
        const static GUID iid = { 
            0xaf5d1ca0,
            0xc5b3,
            0x4e0a,
            {0x89, 0x4b, 0x03, 0xa9, 0xfe, 0x18, 0xed, 0x86}
        };

        return iid;
    }

    // CPaPassportAuthentication
    // Constructor
    //  - pAS: pointer to CASProvider singleton, courtesy of the factory
    //  - pKerbRequest: pointer to current kerberos request, also a gift from the factory
    CPaPassportAuthentication(CASProvider* pAS, IKerbRequest* pKerbRequest)
    {
        _pAS            = pAS;
        _pKerbRequest   = pKerbRequest;
        _status         = 0;
        memset(_principalKey, 0, sizeof(_principalKey));
        memset(&_kerbPrincipalKey, 0, sizeof(_kerbPrincipalKey));
        _passportPuid   = 0;
        _userId         = 0;
    }

    // ~CPaPassportAuthentication
    // Destructor
    virtual ~CPaPassportAuthentication()
    {
    }

    // Process
    // Process the pre-auth in the request. Should be called by GetPrincipal when 
    // retrieving the client's principal. The main reason why it should be called there 
    // is because this pre-auth will provide the principal's key. It also provides the 
    // means to authenticate the client.
    // - pikerbRequest: the request
    // Returns:
    //  KDC_ERR_NONE if succeeded.
    KERBERR Process(IKerbRequest* pikerbRequest);
    
    // ReturnToClient
    // overriding IPAHandler
    // Add preauth data to reply with user information
    // - pikerbRequest: the request
    // - ppOutPaData(out): the list of pre-auths that the KDC should add to the response.
    // Returns:
    //  KDC_ERR_NONE if succeeded.
    virtual KERBERR __stdcall ReturnToClient(
        IN  IKerbRequest*       pikerbRequest,
        OUT PKERB_PA_DATA_LIST* ppOutPaData);
    
    // SetStatus
    // Set request status flag.
    //  - status: one of the STATUS_* constants
    // Remarks:
    // The status member tracks request progress. It's logged in both NT events and 
    // request log entries and provide can provide details on request failures
    void SetStatus(STATUS status)
    {
        _status |= status;
    }

    // CPaPassportAuthentication::SetAccountInfo
    // Called by the CASProvider::GetPrincipal to set account information so that it can 
    // be returned in the response's preauth.
    //  - userId: Xbox user id
    //  - gamertag: Xbox gamertag
    // Remarks:
    //  This method should only be called after Process() has already been called.
    void CPaPassportAuthentication::SetAccountInfo(
        UINT64 userId,
        LPCSTR gamertag);
    
    // CPaPassportAuthentication::GetPassportPuid
    // Retrieve the passport puid obtained from the passport ticket
    // Returns:
    //  Passport-id
    // Remarks:
    //  Should only be called after Process() has already been called successfully
    inline UINT64 GetPassportPuid() const
    {
        // The assert that was here was somewhat bogus - there are cases in the Cleanup 
        // code where the ASProvider tries to log the passport puid, which it gets by 
        // calling this function. It's OK if it returns 0.
        return _passportPuid;
    }

    // CPaPassportAuthentication::GetXkdcCredential
    // Retrieve the "session key" derived from the passport ticket to be used as the 
    // client key.
    //  - pKey: buffer to receive the key. Must be at least XKDC_KEYSIZE bytes long.
    // Remarks:
    //  Should only be called after Process() has already been called successfully
    inline void GetClientKey(OUT BYTE* pKey)
    {
        memcpy(pKey, _principalKey, sizeof(_principalKey));
    }

    // CPaPassportAuthentication::GetStatus
    // Return the processing status of the pre-auth
    inline UINT32 GetStatus() const
    {
        return _status;
    }

protected:

    // CPaPassportAuthentication::EncryptReply
    // Encrypt response blob using KERB_ETYPE_RC4_HMAC_NT and encoded it using ASN.1 DER 
    // (the pdu is KERB_ENCRYPTED_DATA_PDU).
    // - preply: pointer to reply buffer
    // - replyLength: size of the reply in bytes
    // - ppencData: pointer to a pointer to receive the allocated buffer. This buffer 
    // must be released later using IKdcCore::KdcFreeMemory (or the _pAS->KdcFreeMemory)
    // - pencDataLength: sizeo of the data returned in ppencData
    // Remarks:
    //  Don't forget to release the buffer returned in ppencData!
    KERBERR EncryptReply(
        BYTE*       preply,
        UINT32      replyLength,
        OUT PVOID*  ppencData,
        OUT UINT32* pencDataLength);

    CASProvider*        _pAS;
    IKerbRequest*       _pKerbRequest;
    UINT32              _status;

    // Request information
    BYTE                _principalKey[XKDC_KEYSIZE];
    KERB_ENCRYPTION_KEY _kerbPrincipalKey;
    UINT64              _passportPuid;

    // Account information
    UINT64          _userId;
    CTinyStr        _gamertag;
    
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\askdc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_askdc_none_12.4.56.0_none_e8c1a9239db46954
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_askdc_no-public-key_12.4.56.0_x-ww_d8af96ae
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=askdc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_askdc_no-public-key_12.4.56.0_x-ww_d8af96ae
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_askdc_no-public-key_12.4.56.0_x-ww_d8af96ae.manifest
XP_MANIFEST_PATH=manifests\x86_askdc_no-public-key_12.4.56.0_x-ww_d8af96ae.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_askdc_no-public-key_12.4.56.0_x-ww_d8af96ae.cat
XP_CATALOG_PATH=manifests\x86_askdc_no-public-key_12.4.56.0_x-ww_d8af96ae.cat
XP_PAYLOAD_PATH=x86_askdc_no-public-key_12.4.56.0_x-ww_d8af96ae
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=askdc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\afd.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Afd.h

Abstract:

    Contains structures and declarations for AFD.  AFD stands for the
    Ancillary Function Driver.  This driver enhances the functionality
    of TDI so that it is a sufficiently rich interface to support
    user-mode sockets and XTI DLLs.

Author:

    David Treadwell (davidtr)    20-Feb-1992

Revision History:

--*/

#ifndef _AFD_
#define _AFD_

//
// If WINSOCK2.H has not been included, then just embed the definition
// of the WSABUF and QOS structures here. This makes building AFD.SYS
// much easier.
//


#ifndef _WINSOCK2API_

typedef struct _WSABUF {
    ULONG len;
    PCHAR buf;
} WSABUF, *LPWSABUF;

#include <qos.h>


typedef struct _QualityOfService
{
    FLOWSPEC      SendingFlowspec;       /* the flow spec for data sending */
    FLOWSPEC      ReceivingFlowspec;     /* the flow spec for data receiving */
    WSABUF        ProviderSpecific;      /* additional provider specific stuff */
} QOS, *LPQOS;

#define MSG_TRUNC       0x0100
#define MSG_CTRUNC      0x0200
#define MSG_BCAST       0x0400
#define MSG_MCAST       0x0800
#endif

#define AFD_DEVICE_NAME L"\\Device\\Afd"

//
// Endpoint flags computed based on Winsock2 provider flags
// and socket type
//

typedef struct _AFD_ENDPOINT_FLAGS {
    union {
        struct {
            BOOLEAN     ConnectionLess :1;
            BOOLEAN     :3;                 // This spacing makes strcutures
                                            // much more readable (hex) in the 
                                            // debugger and has no effect
                                            // on the generated code as long
                                            // as number of flags is less than
                                            // 8 (we still take up full 32 bits
                                            // because of aligment requiremens
                                            // of most other fields)
            BOOLEAN     MessageMode :1;
            BOOLEAN     :3;
            BOOLEAN     Raw :1;
            BOOLEAN     :3;
            BOOLEAN     Multipoint :1;
            BOOLEAN     :3;
            BOOLEAN     C_Root :1;
            BOOLEAN     :3;
            BOOLEAN     D_Root :1;
            BOOLEAN     :3;
        };
        ULONG           EndpointFlags;      // Flags are as fine as bit fields,
                                            // but create problems when we need
                                            // to cast them to boolean.
    };
#define AFD_ENDPOINT_FLAG_CONNECTIONLESS	0x00000001
#define AFD_ENDPOINT_FLAG_MESSAGEMODE		0x00000010
#define AFD_ENDPOINT_FLAG_RAW			    0x00000100

//
// Old AFD_ENDPOINT_TYPE mappings. Flags make things clearer at
// at the TDI level and after all Winsock2 switched to provider flags
// instead of socket type anyway (ATM for example needs connection oriented
// raw sockets, which can only be reflected by SOCK_RAW+SOCK_STREAM combination
// which does not exists).
//
#define AfdEndpointTypeStream			0
#define AfdEndpointTypeDatagram			(AFD_ENDPOINT_FLAG_CONNECTIONLESS|\
                                            AFD_ENDPOINT_FLAG_MESSAGEMODE)
#define AfdEndpointTypeRaw				(AFD_ENDPOINT_FLAG_CONNECTIONLESS|\
                                            AFD_ENDPOINT_FLAG_MESSAGEMODE|\
                                            AFD_ENDPOINT_FLAG_RAW)
#define AfdEndpointTypeSequencedPacket	(AFD_ENDPOINT_FLAG_MESSAGEMODE)
#define AfdEndpointTypeReliableMessage	(AFD_ENDPOINT_FLAG_MESSAGEMODE)

//
// New multipoint semantics
//
#define AFD_ENDPOINT_FLAG_MULTIPOINT	    0x00001000
#define AFD_ENDPOINT_FLAG_CROOT			    0x00010000
#define AFD_ENDPOINT_FLAG_DROOT			    0x00100000

#define AFD_ENDPOINT_VALID_FLAGS		    0x00111111

} AFD_ENDPOINT_FLAGS;

//
// Structures used on NtCreateFile() for AFD.
//

typedef struct _AFD_OPEN_PACKET {
	AFD_ENDPOINT_FLAGS __f;
#define afdConnectionLess  __f.ConnectionLess
#define afdMessageMode     __f.MessageMode
#define afdRaw             __f.Raw
#define afdMultipoint      __f.Multipoint
#define afdC_Root          __f.C_Root
#define afdD_Root          __f.D_Root
#define afdEndpointFlags   __f.EndpointFlags
    LONG  GroupID;
    ULONG TransportDeviceNameLength;
    WCHAR TransportDeviceName[1];
} AFD_OPEN_PACKET, *PAFD_OPEN_PACKET;

// *** the XX is to ensure natural alignment of the open packet part
//     of the EA buffer

#define AfdOpenPacket "AfdOpenPacketXX"
#define AFD_OPEN_PACKET_NAME_LENGTH (sizeof(AfdOpenPacket) - 1)

//
// The output strucuture is TDI_ADDRESS_INFO
// The address handle is returned via IoStatus->Information
//

//
// The input structure for IOCTL_AFD_START_LISTEN.
//

typedef struct _AFD_LISTEN_INFO {
    BOOLEAN     SanActive;
    ULONG MaximumConnectionQueue;
    BOOLEAN UseDelayedAcceptance;
} AFD_LISTEN_INFO, *PAFD_LISTEN_INFO;

//
// The input structure for IOCTL_AFD_ACCEPT.
//

typedef struct _AFD_ACCEPT_INFO {
    BOOLEAN     SanActive;
    LONG Sequence;
    HANDLE AcceptHandle;
} AFD_ACCEPT_INFO, *PAFD_ACCEPT_INFO;


typedef struct _AFD_SUPER_ACCEPT_INFO {
    BOOLEAN     SanActive;
    BOOLEAN     FixAddressAlignment;
    HANDLE      AcceptHandle;
    ULONG       ReceiveDataLength;
    ULONG       LocalAddressLength;
    ULONG       RemoteAddressLength;
} AFD_SUPER_ACCEPT_INFO, *PAFD_SUPER_ACCEPT_INFO;


//
// The input structure for IOCTL_AFD_DEFER_ACCEPT.
//

typedef struct _AFD_DEFER_ACCEPT_INFO {
    LONG Sequence;
    BOOLEAN Reject;
} AFD_DEFER_ACCEPT_INFO, *PAFD_DEFER_ACCEPT_INFO;

//
// Flags and input structure for IOCTL_AFD_PARTIAL_DISCONNECT.
//

#define AFD_PARTIAL_DISCONNECT_SEND 0x01
#define AFD_PARTIAL_DISCONNECT_RECEIVE 0x02
#define AFD_ABORTIVE_DISCONNECT 0x4
#define AFD_UNCONNECT_DATAGRAM 0x08

typedef struct _AFD_PARTIAL_DISCONNECT_INFO {
    ULONG DisconnectMode;
    LARGE_INTEGER Timeout;
} AFD_PARTIAL_DISCONNECT_INFO, *PAFD_PARTIAL_DISCONNECT_INFO;

typedef struct _AFD_SUPER_DISCONNECT_INFO {
    ULONG  Flags;           // Same as TransmitFile
} AFD_SUPER_DISCONNECT_INFO, *PAFD_SUPER_DISCONNECT_INFO;

//
// Structures for IOCTL_AFD_POLL.
//

typedef struct _AFD_POLL_HANDLE_INFO {
    HANDLE Handle;
    ULONG PollEvents;
    NTSTATUS Status;
} AFD_POLL_HANDLE_INFO, *PAFD_POLL_HANDLE_INFO;

typedef struct _AFD_POLL_INFO {
    LARGE_INTEGER Timeout;
    ULONG NumberOfHandles;
    BOOLEAN Unique;
    AFD_POLL_HANDLE_INFO Handles[1];
} AFD_POLL_INFO, *PAFD_POLL_INFO;

#define AFD_POLL_RECEIVE_BIT            0   //0001
#define AFD_POLL_RECEIVE                (1 << AFD_POLL_RECEIVE_BIT)
#define AFD_POLL_RECEIVE_EXPEDITED_BIT  1   //0002
#define AFD_POLL_RECEIVE_EXPEDITED      (1 << AFD_POLL_RECEIVE_EXPEDITED_BIT)
#define AFD_POLL_SEND_BIT               2   //0004
#define AFD_POLL_SEND                   (1 << AFD_POLL_SEND_BIT)
#define AFD_POLL_DISCONNECT_BIT         3   //0008
#define AFD_POLL_DISCONNECT             (1 << AFD_POLL_DISCONNECT_BIT)
#define AFD_POLL_ABORT_BIT              4   //0010
#define AFD_POLL_ABORT                  (1 << AFD_POLL_ABORT_BIT)
#define AFD_POLL_LOCAL_CLOSE_BIT        5   //0020
#define AFD_POLL_LOCAL_CLOSE            (1 << AFD_POLL_LOCAL_CLOSE_BIT)
#define AFD_POLL_CONNECT_BIT            6   //0040
#define AFD_POLL_CONNECT                (1 << AFD_POLL_CONNECT_BIT)
#define AFD_POLL_ACCEPT_BIT             7   //0080
#define AFD_POLL_ACCEPT                 (1 << AFD_POLL_ACCEPT_BIT)
#define AFD_POLL_CONNECT_FAIL_BIT       8   //0100
#define AFD_POLL_CONNECT_FAIL           (1 << AFD_POLL_CONNECT_FAIL_BIT)
#define AFD_POLL_QOS_BIT                9   //0200
#define AFD_POLL_QOS                    (1 << AFD_POLL_QOS_BIT)
#define AFD_POLL_GROUP_QOS_BIT          10  //0400
#define AFD_POLL_GROUP_QOS              (1 << AFD_POLL_GROUP_QOS_BIT)

#define AFD_POLL_ROUTING_IF_CHANGE_BIT  11  //0800
#define AFD_POLL_ROUTING_IF_CHANGE      (1 << AFD_POLL_ROUTING_IF_CHANGE_BIT)
#define AFD_POLL_ADDRESS_LIST_CHANGE_BIT 12 //1000
#define AFD_POLL_ADDRESS_LIST_CHANGE    (1 << AFD_POLL_ADDRESS_LIST_CHANGE_BIT)
#define AFD_NUM_POLL_EVENTS             13
#define AFD_POLL_ALL                    ((1 << AFD_NUM_POLL_EVENTS) - 1)

#define AFD_POLL_SANCOUNTS_UPDATED  0x80000000


//
// Structure for querying receive information.
//

typedef struct _AFD_RECEIVE_INFORMATION {
    ULONG BytesAvailable;
    ULONG ExpeditedBytesAvailable;
} AFD_RECEIVE_INFORMATION, *PAFD_RECEIVE_INFORMATION;

//
// Structure for quering the TDI handles for an AFD endpoint.
//

#define AFD_QUERY_ADDRESS_HANDLE 1
#define AFD_QUERY_CONNECTION_HANDLE 2


typedef struct _AFD_HANDLE_INFO {
    HANDLE TdiAddressHandle;
    HANDLE TdiConnectionHandle;
} AFD_HANDLE_INFO, *PAFD_HANDLE_INFO;

//
// Structure and manifests for setting information in AFD.
//

typedef struct _AFD_INFORMATION {
    ULONG InformationType;
    union {
        BOOLEAN Boolean;
        ULONG Ulong;
        LARGE_INTEGER LargeInteger;
    } Information;
} AFD_INFORMATION, *PAFD_INFORMATION;

#define AFD_INLINE_MODE          0x01
#define AFD_NONBLOCKING_MODE     0x02
#define AFD_MAX_SEND_SIZE        0x03
#define AFD_SENDS_PENDING        0x04
#define AFD_MAX_PATH_SEND_SIZE   0x05
#define AFD_RECEIVE_WINDOW_SIZE  0x06
#define AFD_SEND_WINDOW_SIZE     0x07
#define AFD_CONNECT_TIME         0x08
#define AFD_CIRCULAR_QUEUEING    0x09
#define AFD_GROUP_ID_AND_TYPE    0x0A
#define AFD_GROUP_ID_AND_TYPE    0x0A
#define AFD_REPORT_PORT_UNREACHABLE 0x0B

//
// Structure for the transmit file IOCTL.
//


typedef struct _AFD_TRANSMIT_FILE_INFO {
    LARGE_INTEGER Offset;
    LARGE_INTEGER WriteLength;
    ULONG SendPacketLength;
    HANDLE FileHandle;
    PVOID Head;
    ULONG HeadLength;
    PVOID Tail;
    ULONG TailLength;
    ULONG Flags;
} AFD_TRANSMIT_FILE_INFO, *PAFD_TRANSMIT_FILE_INFO;

//
// Flags for the TransmitFile API.
//

#define AFD_TF_DISCONNECT           0x01
#define AFD_TF_REUSE_SOCKET         0x02
#define AFD_TF_WRITE_BEHIND         0x04

#define AFD_TF_USE_DEFAULT_WORKER   0x00
#define AFD_TF_USE_SYSTEM_THREAD    0x10
#define AFD_TF_USE_KERNEL_APC       0x20
#define AFD_TF_WORKER_KIND_MASK     0x30


//
// Flag definitions for the AfdFlags field in the AFD_SEND_INFO,
// AFD_SEND_DATAGRAM_INFO, AFD_RECV_INFO, and AFD_RECV_DATAGRAM_INFO
// structures.
//

#define AFD_NO_FAST_IO      0x0001      // Always fail Fast IO on this request.
#define AFD_OVERLAPPED      0x0002      // Overlapped operation.

//
// Structure for connected sends.
//

typedef struct _AFD_SEND_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_SEND_INFO, *PAFD_SEND_INFO;

//
// Structure for connected recvs.
//

typedef struct _AFD_RECV_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_RECV_INFO, *PAFD_RECV_INFO;

//
// Structure for receiving datagrams on unconnected sockets.
//

typedef struct _AFD_RECV_DATAGRAM_INFO {
    LPWSABUF BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
    PVOID Address;
    PULONG AddressLength;
} AFD_RECV_DATAGRAM_INFO, *PAFD_RECV_DATAGRAM_INFO;


//
// Structure for receiving datagram messages.
//
typedef struct _AFD_RECV_MESSAGE_INFO {
    AFD_RECV_DATAGRAM_INFO dgi;
    PVOID   ControlBuffer;
    PULONG  ControlLength;
    PULONG  MsgFlags;
} AFD_RECV_MESSAGE_INFO, *PAFD_RECV_MESSAGE_INFO;

#define AFD_MAX_TDI_FAST_ADDRESS 32

//
// Structure for event select.
//

typedef struct _AFD_EVENT_SELECT_INFO {
    HANDLE Event;
    ULONG PollEvents;
} AFD_EVENT_SELECT_INFO, *PAFD_EVENT_SELECT_INFO;

//
// Output structure for enum network events.
//

typedef struct _AFD_ENUM_NETWORK_EVENTS_INFO {
    ULONG PollEvents;
    NTSTATUS EventStatus[AFD_NUM_POLL_EVENTS];
} AFD_ENUM_NETWORK_EVENTS_INFO, *PAFD_ENUM_NETWORK_EVENTS_INFO;

//
// Structures for QOS and grouping.
//


typedef struct _AFD_QOS_INFO {
    QOS Qos;
    BOOLEAN GroupQos;
} AFD_QOS_INFO, *PAFD_QOS_INFO;

//
// Group membership type.
//

typedef enum _AFD_GROUP_TYPE {
    GroupTypeNeither = 0,
    GroupTypeConstrained = SG_CONSTRAINED_GROUP,
    GroupTypeUnconstrained = SG_UNCONSTRAINED_GROUP
} AFD_GROUP_TYPE, *PAFD_GROUP_TYPE;

//
// Note that, for totally slimy reasons, the following
// structure must be exactly eight bytes long (the size
// of a LARGE_INTEGER). See msafd\socket.c and afd\misc.c
// for the gory details.
//

typedef struct _AFD_GROUP_INFO {
    LONG GroupID;
    AFD_GROUP_TYPE GroupType;
} AFD_GROUP_INFO, *PAFD_GROUP_INFO;

//
// Structure for querying connect data on an unaccepted connection.
//

typedef struct _AFD_UNACCEPTED_CONNECT_DATA_INFO {
    LONG Sequence;
    ULONG ConnectDataLength;
    BOOLEAN LengthOnly;

} AFD_UNACCEPTED_CONNECT_DATA_INFO, *PAFD_UNACCEPTED_CONNECT_DATA_INFO;

typedef struct _AFD_TRANSPORT_IOCTL_INFO {
    HANDLE  Handle;
    PVOID   InputBuffer;
    ULONG   InputBufferLength;
    ULONG   IoControlCode;
    ULONG   AfdFlags;
    ULONG   PollEvent;
} AFD_TRANSPORT_IOCTL_INFO, *PAFD_TRANSPORT_IOCTL_INFO;


#ifndef _WINSOCK2API_
typedef struct _TRANSMIT_PACKETS_ELEMENT {
    ULONG dwElFlags;
#define TP_MEMORY   1
#define TP_FILE     2
#define TP_EOP      4
    ULONG cLength;
    union {
        struct {
            LARGE_INTEGER nFileOffset;
            HANDLE        hFile;
        };
        PVOID             pBuffer;
    };
} TRANSMIT_PACKETS_ELEMENT, *LPTRANSMIT_PACKETS_ELEMENT;
#else
typedef struct _TRANSMIT_PACKETS_ELEMENT TRANSMIT_PACKETS_ELEMENT, *LPTRANSMIT_PACKETS_ELEMENT;
#endif

typedef struct _AFD_TPACKETS_INFO {
    LPTRANSMIT_PACKETS_ELEMENT  ElementArray;
    ULONG                       ElementCount;
    ULONG                       SendSize;
    ULONG                       Flags;
} AFD_TPACKETS_INFO, *PAFD_TPACKETS_INFO;

//
// AFD IOCTL code definitions.
//
// N.B. To ensure the efficient of the code generated by AFD's
//      IOCTL dispatcher, these IOCTL codes should be contiguous
//      (no gaps).
//
// N.B. If new IOCTLs are added here, update the lookup table in
//      ntos\afd\dispatch.c!
//

#define FSCTL_AFD_BASE                  FILE_DEVICE_NETWORK
#define _AFD_CONTROL_CODE(request,method) \
                ((FSCTL_AFD_BASE)<<12 | (request<<2) | method)
#define _AFD_REQUEST(ioctl) \
                ((((ULONG)(ioctl)) >> 2) & 0x03FF)

#define _AFD_BASE(ioctl) \
                ((((ULONG)(ioctl)) >> 12) & 0xFFFFF)

#define AFD_BIND                    0
#define AFD_CONNECT                 1
#define AFD_START_LISTEN            2
#define AFD_WAIT_FOR_LISTEN         3
#define AFD_ACCEPT                  4
#define AFD_RECEIVE                 5
#define AFD_RECEIVE_DATAGRAM        6
#define AFD_SEND                    7
#define AFD_SEND_DATAGRAM           8
#define AFD_POLL                    9
#define AFD_PARTIAL_DISCONNECT      10

#define AFD_GET_ADDRESS             11
#define AFD_QUERY_RECEIVE_INFO      12
#define AFD_QUERY_HANDLES           13
#define AFD_SET_INFORMATION         14
#define AFD_GET_REMOTE_ADDRESS      15
#define AFD_GET_CONTEXT             16
#define AFD_SET_CONTEXT             17

#define AFD_SET_CONNECT_DATA        18
#define AFD_SET_CONNECT_OPTIONS     19
#define AFD_SET_DISCONNECT_DATA     20
#define AFD_SET_DISCONNECT_OPTIONS  21

#define AFD_GET_CONNECT_DATA        22
#define AFD_GET_CONNECT_OPTIONS     23
#define AFD_GET_DISCONNECT_DATA     24
#define AFD_GET_DISCONNECT_OPTIONS  25

#define AFD_SIZE_CONNECT_DATA       26
#define AFD_SIZE_CONNECT_OPTIONS    27
#define AFD_SIZE_DISCONNECT_DATA    28
#define AFD_SIZE_DISCONNECT_OPTIONS 29

#define AFD_GET_INFORMATION         30
#define AFD_TRANSMIT_FILE           31
#define AFD_SUPER_ACCEPT            32

#define AFD_EVENT_SELECT            33
#define AFD_ENUM_NETWORK_EVENTS     34

#define AFD_DEFER_ACCEPT            35
#define AFD_WAIT_FOR_LISTEN_LIFO    36
#define AFD_SET_QOS                 37
#define AFD_GET_QOS                 38
#define AFD_NO_OPERATION            39
#define AFD_VALIDATE_GROUP          40
#define AFD_GET_UNACCEPTED_CONNECT_DATA 41

#define AFD_ROUTING_INTERFACE_QUERY  42
#define AFD_ROUTING_INTERFACE_CHANGE 43
#define AFD_ADDRESS_LIST_QUERY      44
#define AFD_ADDRESS_LIST_CHANGE     45
#define AFD_JOIN_LEAF               46
#define AFD_TRANSPORT_IOCTL         47
#define AFD_TRANSMIT_PACKETS        48
#define AFD_SUPER_CONNECT           49
#define AFD_SUPER_DISCONNECT        50
#define AFD_RECEIVE_MESSAGE         51

//
// SAN switch specific AFD function numbers
//
#define AFD_SWITCH_CEMENT_SAN       52
#define AFD_SWITCH_SET_EVENTS       53
#define AFD_SWITCH_RESET_EVENTS     54
#define AFD_SWITCH_CONNECT_IND      55
#define AFD_SWITCH_CMPL_ACCEPT      56
#define AFD_SWITCH_CMPL_REQUEST     57
#define AFD_SWITCH_CMPL_IO          58
#define AFD_SWITCH_REFRESH_ENDP     59
#define AFD_SWITCH_GET_PHYSICAL_ADDR 60
#define AFD_SWITCH_ACQUIRE_CTX      61
#define AFD_SWITCH_TRANSFER_CTX     62
#define AFD_SWITCH_GET_SERVICE_PID  63
#define AFD_SWITCH_SET_SERVICE_PROCESS  64
#define AFD_SWITCH_PROVIDER_CHANGE  65
#define AFD_SWITCH_ADDRLIST_CHANGE	66
#define AFD_NUM_IOCTLS				67



#define IOCTL_AFD_BIND                    _AFD_CONTROL_CODE( AFD_BIND, METHOD_NEITHER )
#define IOCTL_AFD_CONNECT                 _AFD_CONTROL_CODE( AFD_CONNECT, METHOD_NEITHER )
#define IOCTL_AFD_START_LISTEN            _AFD_CONTROL_CODE( AFD_START_LISTEN, METHOD_NEITHER )
#define IOCTL_AFD_WAIT_FOR_LISTEN         _AFD_CONTROL_CODE( AFD_WAIT_FOR_LISTEN, METHOD_BUFFERED )
#define IOCTL_AFD_ACCEPT                  _AFD_CONTROL_CODE( AFD_ACCEPT, METHOD_BUFFERED )
#define IOCTL_AFD_RECEIVE                 _AFD_CONTROL_CODE( AFD_RECEIVE, METHOD_NEITHER )
#define IOCTL_AFD_RECEIVE_DATAGRAM        _AFD_CONTROL_CODE( AFD_RECEIVE_DATAGRAM, METHOD_NEITHER )
#define IOCTL_AFD_SEND                    _AFD_CONTROL_CODE( AFD_SEND, METHOD_NEITHER )
#define IOCTL_AFD_SEND_DATAGRAM           _AFD_CONTROL_CODE( AFD_SEND_DATAGRAM, METHOD_NEITHER )
#define IOCTL_AFD_POLL                    _AFD_CONTROL_CODE( AFD_POLL, METHOD_BUFFERED )
#define IOCTL_AFD_PARTIAL_DISCONNECT      _AFD_CONTROL_CODE( AFD_PARTIAL_DISCONNECT, METHOD_NEITHER )

#define IOCTL_AFD_GET_ADDRESS             _AFD_CONTROL_CODE( AFD_GET_ADDRESS, METHOD_NEITHER )
#define IOCTL_AFD_QUERY_RECEIVE_INFO      _AFD_CONTROL_CODE( AFD_QUERY_RECEIVE_INFO, METHOD_NEITHER )
#define IOCTL_AFD_QUERY_HANDLES           _AFD_CONTROL_CODE( AFD_QUERY_HANDLES, METHOD_NEITHER )
#define IOCTL_AFD_SET_INFORMATION         _AFD_CONTROL_CODE( AFD_SET_INFORMATION, METHOD_NEITHER )
#define IOCTL_AFD_GET_REMOTE_ADDRESS      _AFD_CONTROL_CODE( AFD_GET_REMOTE_ADDRESS, METHOD_NEITHER )
#define IOCTL_AFD_GET_CONTEXT             _AFD_CONTROL_CODE( AFD_GET_CONTEXT, METHOD_NEITHER )
#define IOCTL_AFD_SET_CONTEXT             _AFD_CONTROL_CODE( AFD_SET_CONTEXT, METHOD_NEITHER )

#define IOCTL_AFD_SET_CONNECT_DATA        _AFD_CONTROL_CODE( AFD_SET_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SET_CONNECT_OPTIONS     _AFD_CONTROL_CODE( AFD_SET_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_SET_DISCONNECT_DATA     _AFD_CONTROL_CODE( AFD_SET_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SET_DISCONNECT_OPTIONS  _AFD_CONTROL_CODE( AFD_SET_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_GET_CONNECT_DATA        _AFD_CONTROL_CODE( AFD_GET_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_GET_CONNECT_OPTIONS     _AFD_CONTROL_CODE( AFD_GET_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_GET_DISCONNECT_DATA     _AFD_CONTROL_CODE( AFD_GET_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_GET_DISCONNECT_OPTIONS  _AFD_CONTROL_CODE( AFD_GET_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_SIZE_CONNECT_DATA       _AFD_CONTROL_CODE( AFD_SIZE_CONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_CONNECT_OPTIONS    _AFD_CONTROL_CODE( AFD_SIZE_CONNECT_OPTIONS, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_DISCONNECT_DATA    _AFD_CONTROL_CODE( AFD_SIZE_DISCONNECT_DATA, METHOD_NEITHER )
#define IOCTL_AFD_SIZE_DISCONNECT_OPTIONS _AFD_CONTROL_CODE( AFD_SIZE_DISCONNECT_OPTIONS, METHOD_NEITHER )

#define IOCTL_AFD_GET_INFORMATION         _AFD_CONTROL_CODE( AFD_GET_INFORMATION, METHOD_NEITHER )
#define IOCTL_AFD_TRANSMIT_FILE           _AFD_CONTROL_CODE( AFD_TRANSMIT_FILE, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_ACCEPT            _AFD_CONTROL_CODE( AFD_SUPER_ACCEPT, METHOD_NEITHER )

#define IOCTL_AFD_EVENT_SELECT            _AFD_CONTROL_CODE( AFD_EVENT_SELECT, METHOD_NEITHER )
#define IOCTL_AFD_ENUM_NETWORK_EVENTS     _AFD_CONTROL_CODE( AFD_ENUM_NETWORK_EVENTS, METHOD_NEITHER )

#define IOCTL_AFD_DEFER_ACCEPT            _AFD_CONTROL_CODE( AFD_DEFER_ACCEPT, METHOD_BUFFERED )
#define IOCTL_AFD_WAIT_FOR_LISTEN_LIFO    _AFD_CONTROL_CODE( AFD_WAIT_FOR_LISTEN_LIFO, METHOD_BUFFERED )
#define IOCTL_AFD_SET_QOS                 _AFD_CONTROL_CODE( AFD_SET_QOS, METHOD_BUFFERED )
#define IOCTL_AFD_GET_QOS                 _AFD_CONTROL_CODE( AFD_GET_QOS, METHOD_BUFFERED )
#define IOCTL_AFD_NO_OPERATION            _AFD_CONTROL_CODE( AFD_NO_OPERATION, METHOD_NEITHER )
#define IOCTL_AFD_VALIDATE_GROUP          _AFD_CONTROL_CODE( AFD_VALIDATE_GROUP, METHOD_BUFFERED )
#define IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA _AFD_CONTROL_CODE( AFD_GET_UNACCEPTED_CONNECT_DATA, METHOD_NEITHER )

#define IOCTL_AFD_ROUTING_INTERFACE_QUERY  _AFD_CONTROL_CODE( AFD_ROUTING_INTERFACE_QUERY, METHOD_NEITHER ) 
#define IOCTL_AFD_ROUTING_INTERFACE_CHANGE _AFD_CONTROL_CODE( AFD_ROUTING_INTERFACE_CHANGE, METHOD_BUFFERED )
#define IOCTL_AFD_ADDRESS_LIST_QUERY       _AFD_CONTROL_CODE( AFD_ADDRESS_LIST_QUERY, METHOD_NEITHER ) 
#define IOCTL_AFD_ADDRESS_LIST_CHANGE      _AFD_CONTROL_CODE( AFD_ADDRESS_LIST_CHANGE, METHOD_BUFFERED )
#define IOCTL_AFD_JOIN_LEAF                _AFD_CONTROL_CODE( AFD_JOIN_LEAF, METHOD_NEITHER )
#define IOCTL_AFD_TRANSPORT_IOCTL          _AFD_CONTROL_CODE( AFD_TRANSPORT_IOCTL, METHOD_NEITHER )
#define IOCTL_AFD_TRANSMIT_PACKETS         _AFD_CONTROL_CODE( AFD_TRANSMIT_PACKETS, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_CONNECT            _AFD_CONTROL_CODE( AFD_SUPER_CONNECT, METHOD_NEITHER )
#define IOCTL_AFD_SUPER_DISCONNECT         _AFD_CONTROL_CODE( AFD_SUPER_DISCONNECT, METHOD_NEITHER )
#define IOCTL_AFD_RECEIVE_MESSAGE          _AFD_CONTROL_CODE( AFD_RECEIVE_MESSAGE, METHOD_NEITHER )




//
// SAN support
//
//

//
// SAN IOCTL control codes.
//

#define IOCTL_AFD_SWITCH_CEMENT_SAN     _AFD_CONTROL_CODE( AFD_SWITCH_CEMENT_SAN, METHOD_NEITHER )
/*++
Ioctl Description:
    Changes the AFD endpoint type to SAN to indicate that
    it is used for support of user mode SAN providers
    Associates switch context with the endpoint.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - NULL (ingored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle correspond to AFD
                                endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_SET_EVENTS     _AFD_CONTROL_CODE( AFD_SWITCH_SET_EVENTS, METHOD_NEITHER )
/*++
Ioctl Description:
    Sets the poll event on the san endpoint to report
    to the application via various forms of the select.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the SAN endpoint (except
                                                AFD_POLL_EVENT_CONNECT_FAIL which
                                                just needs a bound endpoint).
                            SwitchContext   - switch context associated with endpoint (NULL
                                                for AFD_POLL_EVENT_CONNECT_FAIL) to validate
                                                the handle-endpoint association
                            EventBit        - event bit to set
                            Status          - associated status (for AFD_POLL_EVENT_CONNECT_FAIL)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_RESET_EVENTS   _AFD_CONTROL_CODE( AFD_SWITCH_RESET_EVENTS, METHOD_NEITHER )
/*++
Ioctl Description:
    Resets the poll event on the san endpoint so that it is no
    longer reported to the application via various forms of the select
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the SAN endpoint
                            SwitchContext   - switch context associated with endpoint 
                                                to validate the handle-endpoint association
                            EventBit        - event bit to reset
                            Status          - associated status (ignored)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access switch socket, input buffer, or switch context.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_CONNECT_IND    _AFD_CONTROL_CODE( AFD_SWITCH_CONNECT_IND, METHOD_OUT_DIRECT )
/*++
Ioctl Description:
    Implements connect indication from SAN provider.
    Picks up the accept from the listening endpoint queue
    or queues the indication an signals the application to come
    down with an accept.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONNECT_INFO):
                            ListenHandle    - handle of the listening endpoint
                            RemoteAddress   - remote and local addresses associated
                                                with indication incoming connection
    InputBufferLength - sizeof(AFD_SWITCH_CONNECT_INFO)+addresses
    OutputBuffer    - output parameters for the operation (AFD_SWITCH_ACCEPT_INFO):
                            AcceptHandle    - handle of the accepting endpoint
                            ReceiveLength   - length of the receive buffer supplied by
                                                the application in AcceptEx
                            
    OutputBufferLength - sizeof (AFD_SWITCH_ACCEPT_INFO)
Return Value:
    STATUS_PENDING  - request was queued waiting for corresponding transfer request
                        from the current socket context owner process.
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or listen socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or listen socket handle correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input or output buffers are of incorrect size.
        STATUS_CANCELLED    -  connection indication was cancelled (thread exited or
                                accepting and/or listening socket closed)
        other - failed when attempting to access listening socket, input or output buffers
    IoStatus.Information - sizeof (AFD_SWITCH_ACCEPT_INFO) in case of success.
--*/

#define IOCTL_AFD_SWITCH_CMPL_ACCEPT    _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_ACCEPT, METHOD_NEITHER )
/*++
Ioctl Description:
    Completes the acceptance of SAN connection
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the accepting endpoint
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - data to copy into the AcceptEx receive buffer
    OutputBufferLength - size of received data
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        STATUS_LOCAL_DISCONNECT - accept was aborted by the application.
        other - failed when attempting to access accepte socket, input/output buffers, 
                or switch context.
    IoStatus.Information - Number of bytes copied into application's receive buffer.
--*/


#define IOCTL_AFD_SWITCH_CMPL_REQUEST   _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_REQUEST, METHOD_NEITHER )
/*++
Ioctl Description:
    Completes the redirected read/write request processed by SAN provider
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_REQUEST_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies the request to complete
                        RequestStatus - status with which to complete the request (
                                        STATUS_PENDING has special meaning, request
                                        is not completed - merely data is copied)
                        DataOffset - offset in the request buffer to read/write the data
    InputBufferLength - sizeof (AFD_SWITCH_REQUEST_INFO)
    OutputBuffer - switch buffer to read/write data
    OutputBufferLength - length of the buffer
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        STATUS_CANCELLED - request to be completed has already been cancelled
        other - failed when attempting to access SAN endpoint, 
                    input buffer or output buffers.
    IoStatus.Information - number of bytes copied from/to switch buffer.
--*/

#define IOCTL_AFD_SWITCH_CMPL_IO        _AFD_CONTROL_CODE( AFD_SWITCH_CMPL_IO, METHOD_NEITHER )
/*++
Ioctl Description:
    Simulates async IO completion for the switch.
Arguments:
    Handle          - SAN socket handle on which to complete the IO.
    InputBuffer     - input parameters for the operation (IO_STATUS_BLOCK)
                        Status - final operation status
                        Information - associated information (number of bytes 
                                        transferred to/from request buffer(s))
    InputBufferLength - sizeof (IO_STATUS_BLOCK)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_INVALID_PARAMETER - input buffer is of invalid size.
        other - status of the IO operation or failure code when attempting to 
                    access input buffer.
    IoStatus.Information - information from the input buffer
--*/

#define IOCTL_AFD_SWITCH_REFRESH_ENDP   _AFD_CONTROL_CODE( AFD_SWITCH_REFRESH_ENDP, METHOD_NEITHER )
/*++
Ioctl Description:
    Refreshes endpoint so it can be used again in AcceptEx
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                        SocketHandle - Socket to refresh
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
    InputBufferLength - sizeof (AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - 0 (ignored)
--*/

#define IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR _AFD_CONTROL_CODE( AFD_SWITCH_GET_PHYSICAL_ADDR, METHOD_NEITHER )
/*++
Ioctl Description:
    Returns physical address corresponding to provided virtual address.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - user mode virtual address
    InputBufferLength - access mode
    OutputBuffer    - Buffer to place physical address into.
    OutputBufferLength - sizeof (PHYSICAL_ADDRESS)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_BUFFER_TOO_SMALL - output buffer is of incorrect size.
        STATUS_INVALID_PARAMETER - invalid access mode.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - sizeof(PHYSICAL_ADDRESS).
--*/

#define IOCTL_AFD_SWITCH_ACQUIRE_CTX    _AFD_CONTROL_CODE( AFD_SWITCH_ACQUIRE_CTX, METHOD_NEITHER )
/*++
Ioctl Description:
    Requests transfer of the socket context to the current process.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - input parameters for the operation (AFD_SWITCH_ACQUIRE_CTX_INFO)
                        SocketHandle - SAN endpoint on which to complete the request
                        SwitchContext - switch context to be associated with endpoint 
                                            when context transfered to the current process.
                        SocketCtxBuf  - buffer to receive current socket context from
                                            another process
                        SocketCtxBufSize - size of the buffer
    InputBufferLength - sizeof (AFD_SWITCH_ACQUIRE_CTX_INFO)
    OutputBuffer - buffer to receive data buffered on the socket in another process
                        and not yet delivered to the applicaiton
    OutputBufferLength - length of the receive buffer
Return Value:
    STATUS_PENDING  - request was queued waiting for corresponding transfer request
                        from the current socket context owner process.
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer or output buffers.
    IoStatus.Information - number of bytes copied to receive buffer.
--*/

#define IOCTL_AFD_SWITCH_TRANSFER_CTX   _AFD_CONTROL_CODE( AFD_SWITCH_TRANSFER_CTX, METHOD_NEITHER )
/*++
Ioctl Description:
    Requests AFD to transfer endpoint into another process context
Arguments:
    InputBuffer     - input parameters for the operation (AFD_SWITCH_TRANSFER_CTX_INFO)
                        SocketHandle - Socket to transfer
                        SwitchContext - switch context associated with endpoint 
                                            to validate the handle-endpoint association
                        RequestContext - value that identifies corresponding acquire request,
                                        NULL if this is unsolicited request to transfer to
                                        the service process.
                        SocketCtxBuf - socket context to copy destination process
                                            acquire request context buffer
                        SocketCtxSize - size of the context buffer to copy
                        RcvBufferArray - array of buffered data to transfer to 
                                            destination process acquire request
                        RcvBufferCount - number of elements in the array.
    InputBufferLength - sizeof (AFD_SWITCH_TRANSFER_CTX_INFO)
    OutputBuffer    - NULL (ignored)
    OutputBufferLength - 0 (ignored)
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle or switch socket handle are not
                                        AFD file object handles
        STATUS_INVALID_HANDLE - helper handle or switch socket handle+context correspond 
                                to AFD endpoint of incorrect type/state.
        STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
        other - failed when attempting to access SAN endpoint, 
                    input buffer buffer.
    IoStatus.Information - number of bytes copied from RcvBufferArray.
--*/

#define IOCTL_AFD_SWITCH_GET_SERVICE_PID _AFD_CONTROL_CODE( AFD_SWITCH_GET_SERVICE_PID, METHOD_NEITHER )
/*++
Ioctl Description:
    Returns PID of the service process used for intermediate socket duplication.
Arguments:
    Handle          - helper endpoint handle for the process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
    IoStatus.Information - pid of the service process.
--*/

#define IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS _AFD_CONTROL_CODE( AFD_SWITCH_SET_SERVICE_PROCESS, METHOD_NEITHER )
/*++
Ioctl Description:
    Notifies AFD that this process will be used for handle duplication services
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
    IoStatus.Information - 0, ignored.
--*/

#define IOCTL_AFD_SWITCH_PROVIDER_CHANGE _AFD_CONTROL_CODE( AFD_SWITCH_PROVIDER_CHANGE, METHOD_NEITHER )
/*++
Ioctl Description:
        Notifies interested processes of SAN provider addition/deletion/change.
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - NULL, ignored
    InputBufferLength - 0, ignored
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
        STATUS_ACCESS_DENIED - helper endpoint is not for the service process.
    IoStatus.Information - 0, ignored.
--*/

#define IOCTL_AFD_SWITCH_ADDRLIST_CHANGE _AFD_CONTROL_CODE( AFD_SWITCH_ADDRLIST_CHANGE, METHOD_BUFFERED )
/*++
Ioctl Description:
        SAN specific version of address list change notifications.
        Capture provider installation/removal in addition to plain
        address list changes.
Arguments:
    Handle          - helper endpoint handle for the service process.
    InputBuffer     - Input parameters for the operation (AFD_TRANSPORT_IOCTL_INFO):
                        AfdFlags - operation flags (e.g. AFD_OVERLAPPED)
                        Handle  - unused
                        PollEvent - unused
                        IoControlCode - IOCTL_AFD_ADDRESS_LIST_CHANGE
                        InputBuffer - pointer to address family (AF_INET)
                        InputBufferLength - sizeof (USHORT)
                        
    InputBufferLength - sizeof (AFD_TRANSPORT_IOCTL_INFO)
    OutputBuffer    - NULL, ignored
    OutputBufferLength - 0, ignored
Return Value:
    IoStatus.Status:
        STATUS_SUCCESS - operation succeeded.
        STATUS_OBJECT_TYPE_MISMATCH - helper handle is not AFD file object handle
        STATUS_INVALID_HANDLE - helper handle corresponds to AFD endpoint of incorrect 
                                type.
    IoStatus.Information - 0 - regular address list change
                            otherwise, seq number of provider list change.
--*/

// Open packet that identifies SAN helper endpoint used
// for communication between SAN switch and AFD.
// This is EA name
//
#define AfdSwitchOpenPacket     "AfdSwOpenPacket"
#define AFD_SWITCH_OPEN_PACKET_NAME_LENGTH (sizeof(AfdSwitchOpenPacket)-1)

//
// Data passed in the open packet
// This is EA value
//
typedef struct _AFD_SWITCH_OPEN_PACKET {
    HANDLE      CompletionPort; // Completion port notify SAN switch
                                // of SAN io completions
    HANDLE      CompletionEvent;// Completion event to distinguish IO issued
                                // by SAN switch from application IO.
} AFD_SWITCH_OPEN_PACKET, *PAFD_SWITCH_OPEN_PACKET;

typedef struct _AFD_SWITCH_CONTEXT {
    LONG        EventsActive;   // Poll events activated by switch
    LONG        RcvCount;       // Count of polls for receive
    LONG        ExpCount;       // Count of polls for expedited
    LONG        SndCount;       // Count of polls for send
	BOOLEAN		SelectFlag;		// TRUE if app has done any form of select
} AFD_SWITCH_CONTEXT, *PAFD_SWITCH_CONTEXT;


//
// Information for associating AFD endpoint with SAN provider
//
typedef struct _AFD_SWITCH_CONTEXT_INFO {
    HANDLE      SocketHandle;   // Handle to associate with SAN provider
    PAFD_SWITCH_CONTEXT SwitchContext;  // Opaque context value maintained for the switch
} AFD_SWITCH_CONTEXT_INFO, *PAFD_SWITCH_CONTEXT_INFO;

//
// Information returned by the AFD to switch in response
// to connection indication
//
typedef struct _AFD_SWITCH_ACCEPT_INFO {
    HANDLE              AcceptHandle;   // Socket handle to use to accept connection
    ULONG               ReceiveLength;  // Length of the initial receive buffer (for AcceptEx)
} AFD_SWITCH_ACCEPT_INFO, *PAFD_SWITCH_ACCEPT_INFO;

//
// Information passed by the switch to signal network events on the
// endpoint (socket)
//
typedef struct _AFD_SWITCH_EVENT_INFO {
	HANDLE		SocketHandle;   // Socket handle on which to signal
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
	ULONG		EventBit;       // Event bit to set/reset (AFD_POLL_xxx_BIT constants)
    NTSTATUS    Status;         // Status code associated with the event (this
                                // is used for AFD_POLL_CONNECT_FAIL_BIT)
} AFD_SWITCH_EVENT_INFO, *PAFD_SWITCH_EVENT_INFO;


//
// Information passed by the switch to retreive parameters/complete
// redirected read/write request
//
typedef struct _AFD_SWITCH_REQUEST_INFO {
	HANDLE		SocketHandle;   // Socket handle on which request us active
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
    PVOID       RequestContext; // Request context that identifies it
    NTSTATUS    RequestStatus;  // Completion status of the request (STATUS_PENDING
                                // indicates that request should NOT be completed yet)
    ULONG       DataOffset;     // Offset from which to start copying data from/to
                                // application's buffer
} AFD_SWITCH_REQUEST_INFO, *PAFD_SWITCH_REQUEST_INFO;



//
// Access type (read access or write access) that's needed for an app buffer
// whose physical address is requested thru AfdSanFastGetPhysicalAddr
//
#define MEM_READ_ACCESS		1
#define MEM_WRITE_ACCESS	2


//
// Information passed between processes when socket is duplicated.
//
typedef struct _AFD_SWITCH_ACQUIRE_CTX_INFO {
    HANDLE      SocketHandle;   // Socket handle which needs to be transferred
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context to be associated with the socket
    PVOID       SocketCtxBuf;   // Socket context buffer
    ULONG       SocketCtxBufSize; // Socket context buffer size
} AFD_SWITCH_ACQUIRE_CTX_INFO, *PAFD_SWITCH_ACQUIRE_CTX_INFO;

typedef struct _AFD_SWITCH_TRANSFER_CTX_INFO {
    HANDLE      SocketHandle;   // Socket handle which needs to be transferred
    PAFD_SWITCH_CONTEXT SwitchContext; // Switch context associated with the socket
    PVOID       RequestContext; // Value that identifies corresponding acquire request
    PVOID       SocketCtxBuf;   // Socket context buffer
    ULONG       SocketCtxBufSize; // Socket context buffer size
    LPWSABUF    RcvBufferArray; // Receive buffers to copy to destination process
    ULONG       RcvBufferCount; // Number of receive buffers
    NTSTATUS    Status;         // Status of transfer opertaion.
} AFD_SWITCH_TRANSFER_CTX_INFO, *PAFD_SWITCH_TRANSFER_CTX_INFO;

//
// Request from AFD to switch (passed via completion port)
//
#define AFD_SWITCH_REQUEST_CLOSE    0
/*++
Request Description:
    All references to the socket have been closed in all processes, safe
    to destroy the SAN provider socket and connection
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CLOSE)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - 0 (ignored)
--*/

#define AFD_SWITCH_REQUEST_READ     1
/*++
Request Description:
    Read request arrived from the application via IO subsystem interface.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_READ)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - size of the receive buffer supplied by the application
--*/

#define AFD_SWITCH_REQUEST_WRITE    2
/*++
Request Description:
    Write request arrived from the application via IO subsystem interface.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_WRITE)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - size of the send data supplied by the application
--*/

#define AFD_SWITCH_REQUEST_TFCTX    3
/*++
Request Description:
    Another process requests ownership of the socket.
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(RequestId, AFD_SWITCH_REQUEST_TFCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - PID of the process requesting ownership.
--*/

#define AFD_SWITCH_REQUEST_CHCTX    4
/*++
Request Description:
    Relationship between socket handle and switch context has become invalid
    (application must have closed the original socket and using duplicated handle)
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CHCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - Handle currently used by the application.
--*/

#define AFD_SWITCH_REQUEST_AQCTX    5
/*++
Request Description:
    Request to service process to acquire ownership of the socket
Arguments (NtRemoveIoCompletion return parameters):
        Key - NULL
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_AQCTX)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - Handle of the socket to be acquired.
--*/

#define AFD_SWITCH_REQUEST_CLSOC    6
/*++
Request Description:
    Request to service process to close the socket
Arguments (NtRemoveIoCompletion return parameters):
        Key - switch context associated with the socket
        ApcContext - AFD_SWITCH_MAKE_REQUEST_CONTEXT(0, AFD_SWITCH_REQUEST_CLSOC)
        IoStatus.Status - STATUS_SUCCESS (ignored)
        IoStatus.Information - 0.
--*/


#define AFD_SWITCH_REQUEST_ID_SHIFT 3
#define AFD_SWITCH_REQUEST_TYPE_MASK    \
            ((1<<AFD_SWITCH_REQUEST_ID_SHIFT)-1)

#define AFD_SWITCH_MAKE_REQUEST_CONTEXT(_id,_type)      \
            UlongToPtr(((_id)<<AFD_SWITCH_REQUEST_ID_SHIFT)+(_type))

//
// Retrives request type from the request context
//
#define AFD_SWITCH_REQUEST_TYPE(_RequestContext)        \
        (((ULONG_PTR)(_RequestContext))&AFD_SWITCH_REQUEST_TYPE_MASK)

#endif // ndef _AFD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\acache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       acache.cxx

   Abstract:
       This module implements the Allocation cache handler and associated
        objects.

   Author:

       Murali R. Krishnan    ( MuraliK )     12-Sept-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <isatq.hxx>
# include "acache.hxx"
# include "dbgutil.h"

// 
// # of CPUs in machine (for allocation threshold scaling)
// 
DWORD g_cCPU = 0;

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[] =
 TEXT("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");


//
// Lookaside cleanup interval
//

#define ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL \
                     TEXT( "LookasideCleanupInterval" )
#define ACACHE_REG_DEFAULT_CLEANUP_INTERVAL              ((15)*(60))

/************************************************************
 *    Inlined Documentation on Alloc-Cache
 *
 * Allocation Cache:
 *    This module is to cache the commonly allocated objects
 *    to serve following goals 
 *      1) we can have maximum reuse of blocks
 *      2) avoid traffic to the process heap manager
 *      3) gather statistics for understanding of usage
 *
 * Details on Allocation Cache:
 *   There is one ALLOC_CACHE_HANDLER (shortly ACH) object per 
 *   object that we decide to cache. The ACH is initialized by
 *   the configuration supplied during its construction. ACH serves
 *   as the main object for allocation/free of the objects it is created
 *   to cache. ACH gathers statistics of various operations and provides
 *   hooks to export the gathered statistics. There is a periodic cleanup
 *   scavenger that frees up long unused blocks thus reducing the working
 *   set of the system.
 *
 *   All ACH objects created are chained and maintained in the global
 *   list of allocation cache handler objects. This global list is used
 *   for enumeration, debugging, and statistics dumps
 *   
 * Allocation cache Configuration:
 * 
 *   Each ACH object is created with the ALLOC_CACHE_CONFIGURATION that
 *   specifies the (concurrency factor, threshold, size) desired.
 *   The concurrency factor ensures that we support the specified level 
 *   of concurrency in allocations. The threshold specifies the number 
 *   of objects that we will maintain (max) in the free-list. When the
 *   threshold is exceeded the freed objects are pushed to the process
 *   pool until the currently active objects fall below the threshold.
 *   In addition, each ACH object also retains a read-only name for the
 *   object allocated - for friendly tracking purposes.
 *
 *   There is also a global configuration parameter that specifies the 
 *   Lookaside cleanup interval. 
 *
 * Allocation and Free:
 *   Allocation allocates one free object from the free-list if any exist.
 *   Otherwise the allocation will result in fetching a new object from
 *   the process heap manager.
 *   A free adds the freed object to the free-list if the # free objects
 *   is less than the threshold specified. Otherwise the object is freed
 *   to the process heap manager.
 *   Statistics are gathered during both allocation and free operations.
 *
 * Statisitcs:
 *   Statistics are gathered during the alloc/free operations throughout
 *   the life-time of the ACH. These statistics are reported via the 
 *   DumpStatsToHtml() exported function. The statistics can also be 
 *   gathered by the NTSD helper function.
 *
 * Scheduled List cleanup:
 *   There is a scheduled work item for the lookaside cleanup interval. 
 *   The callback function walks through the list of ACH items on global
 *   list and takes snapshot of the # allocation calls. On a subsequent
 *   walk-through, if the # allocation calls remains the same (which will
 *   be the case if there is no allocation activity), then, the entire
 *   list of alloced objects is pruned. This pruning reduces the working
 *   set of the process.
 ************************************************************/

/************************************************************
 *    Static Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

CRITICAL_SECTION ALLOC_CACHE_HANDLER::sm_csItems;
LIST_ENTRY       ALLOC_CACHE_HANDLER::sm_lItemsHead;
DWORD            ALLOC_CACHE_HANDLER::sm_dwScheduleCookie;

/* class static */
BOOL
ALLOC_CACHE_HANDLER::Initialize(VOID)
{
    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    // initialize the class statics
    InitializeListHead( &sm_lItemsHead);
    InitializeCriticalSection( &sm_csItems);
    SET_CRITICAL_SECTION_SPIN_COUNT( &sm_csItems, IIS_DEFAULT_CS_SPIN_COUNT);
    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Initialize()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::Cleanup(VOID)
{
    DBG_ASSERT( sm_dwScheduleCookie == 0);

    DBG_ASSERT( IsListEmpty(&sm_lItemsHead));
    DeleteCriticalSection( &sm_csItems);

    return ( TRUE);

} // ALLOC_CACHE_HANDLER::Cleanup()


/* class static */
VOID
ALLOC_CACHE_HANDLER::InsertNewItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    InsertTailList( &sm_lItemsHead, &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::InsertNewItem()



/* class static */
VOID
ALLOC_CACHE_HANDLER::RemoveItem( IN ALLOC_CACHE_HANDLER * pach)
{
    EnterCriticalSection( &sm_csItems);

    RemoveEntryList( &pach->m_lItemsEntry);
    LeaveCriticalSection( &sm_csItems);

    return;
} // ALLOC_CACHE_HANDLER::RemoveItem()



/* class static */
BOOL
ALLOC_CACHE_HANDLER::DumpStatsToHtml(
   OUT CHAR * pchBuffer,
   IN OUT LPDWORD lpcchBuffer )
/*++
  Description:
    This function dumps the stats on all allocation cached objects
     to HTML format for diagnostics

  Arguments:
    pchBuffer - pointer to buffer that will contain the html results
    lpcchBuffer - pointer to DWORD containing the size of buffer on entry
               On return this contains the # of bytes written out to buffer

  Return:
    TRUE for success and FALSE for failure
    Look at GetLastError() for the error code.
--*/
{
    LIST_ENTRY  * pEntry;
    DWORD  iCount, cch;
    DWORD  cbTotalMem = 0;
    BOOL   fRet = TRUE;

    if ( (lpcchBuffer == NULL) ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    EnterCriticalSection( &sm_csItems);

    if ( 300 < *lpcchBuffer ) {

        // Print the header blob
        cch = wsprintf( pchBuffer,
                        " AllocCacheTable Data <br>"
                        "<TABLE BORDER> <TR> "
                        "<TH> Item Name </TH> "
                        "<TH> Config(concurr, threshold, size) </TH> "
                        "<TH> # Total Items </TH> "
                        "<TH> # Alloc Calls </TH> "
                        "<TH> # Free Calls </TH> "
                        "<TH> # Free Entries </TH> "
                        "<TH> # Total Size (bytes) </TH> "
                        " </TR>"
                        );
    } else {
        cch = 300;
    }

    for ( pEntry = sm_lItemsHead.Flink, iCount = 0;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink, iCount++
          ) {

        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        cbTotalMem += pach->m_acConfig.cbSize * pach->m_nTotal;

        if ( (cch + 150 + strlen( pach->m_pszName)) < *lpcchBuffer) {
            cch += wsprintf( pchBuffer + cch,
                             " <TR> <TD> [%d] %s </TD> <TD> (%d, %d, %d) </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " <TD> %4d </TD>"
                             " </TR>"
                             ,
                             iCount,
                             pach->m_pszName,
                             pach->m_acConfig.nConcurrency,
                             pach->m_acConfig.nThreshold,
                             pach->m_acConfig.cbSize,
                             pach->m_nTotal,
                             pach->m_nAllocCalls,
                             pach->m_nFreeCalls,
                             pach->m_nFreeEntries,
                             pach->m_acConfig.cbSize * pach->m_nTotal
                             );
        } else {
            cch += 150 + strlen( pach->m_pszName);
        }
    } // for

    LeaveCriticalSection( &sm_csItems);

    //
    // dump the final summary
    //
    if ( (cch + 100 ) < *lpcchBuffer) {
        cch += wsprintf( pchBuffer + cch,
                         " <b>"
                         " <TR> </TR>"
                         " <TR> <TD> Total </TD> <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> </TD>"
                         " <TD> %4d </TD>"
                         " </TR>"
                         "</b>"
                         " </TABLE>"
                         ,
                         cbTotalMem
                         );
    } else {
        cch += 100;
    }

    if ( *lpcchBuffer < cch ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER);
        fRet = FALSE;
    }

    *lpcchBuffer = cch;

    return (fRet);
} // ALLOC_CACHE_HANDLER::DumpStatsToHtml()

extern "C"
BOOL AllocCacheDumpStatsToHtml( OUT CHAR * pch, 
                                IN OUT LPDWORD lpcchBuff)
{
    return ( ALLOC_CACHE_HANDLER::DumpStatsToHtml( pch, lpcchBuff));
} 
    
/* class static */
BOOL
ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval( VOID )
{
    DWORD               dwError;
    DWORD               dwVal = 0;
    HKEY                hkey;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY,
                            0,
                            KEY_READ,
                            &hkey);

    if ( dwError == NO_ERROR ) {

        //
        // get the lookaside list cleanup period
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ACACHE_REG_LOOKASIDE_CLEANUP_INTERVAL,
                                   ACACHE_REG_DEFAULT_CLEANUP_INTERVAL );

        ATQ_REQUIRE( !RegCloseKey( hkey ) );
    }

    if ( dwVal != 0 )
    {
        sm_dwScheduleCookie =
            ScheduleWorkItem( ALLOC_CACHE_HANDLER::CleanupAllLookasides,
                              NULL,
                              dwVal * 1000,
                              TRUE );

        if ( sm_dwScheduleCookie == 0 )
        {
            return FALSE;
        }
    }

    return TRUE;
} // ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval()


/* class static */
BOOL
ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval( VOID )
{
    BOOL fReturn = TRUE;
    if ( sm_dwScheduleCookie )
    {
        fReturn = RemoveWorkItem( sm_dwScheduleCookie );
        if (fReturn) {
            sm_dwScheduleCookie = 0;
        }
    }

    return ( fReturn);
} // ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval()



/* class static */
VOID
ALLOC_CACHE_HANDLER::CleanupAllLookasides(
    IN PVOID            pvContext
)
{
    LIST_ENTRY *        pEntry;

    EnterCriticalSection( &sm_csItems);

    for ( pEntry = sm_lItemsHead.Flink;
          pEntry != &sm_lItemsHead;
          pEntry = pEntry->Flink )
    {
        ALLOC_CACHE_HANDLER * pach =
            CONTAINING_RECORD( pEntry,
                               ALLOC_CACHE_HANDLER,
                               m_lItemsEntry
                               );

        IF_DEBUG( ALLOC_CACHE) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Cleaning lookaside list for '%s' handler\n",
                         pach->m_pszName ));
        }

        pach->CleanupLookaside( FALSE );
    }

    LeaveCriticalSection( &sm_csItems);
} // ALLOC_CACHE_HANDLER::CleanupAllLookasides()




/************************************************************
 *    Member Functions of ALLOC_CACHE_HANDLER
 ************************************************************/

ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER(
    IN LPCSTR pszName,
    IN const ALLOC_CACHE_CONFIGURATION * pacConfig
    )
    : m_fValid ( FALSE),
      m_nTotal       (0),
      m_nAllocCalls  (0),
      m_nFreeCalls   (0),
      m_nFreeEntries (0),
      m_pszName      (pszName),
      m_nLastAllocCount(0)
{
    DBG_ASSERT( NULL != pacConfig );
    m_acConfig = *pacConfig;

    if ( pacConfig->nThreshold == INFINITE) {
        // this will be compared against a signed value. So be careful.
        m_acConfig.nThreshold = 0x7FFFFFFF;
    } else {
        // scale by the number of processors on MP machines
        m_acConfig.nThreshold *= g_cCPU;
    }

    InitializeCriticalSection( & m_csLock);
    SET_CRITICAL_SECTION_SPIN_COUNT( &m_csLock, IIS_DEFAULT_CS_SPIN_COUNT);

    m_lHead.Next = NULL;

    ALLOC_CACHE_HANDLER::InsertNewItem( this);
    m_fValid = TRUE;
    return;
} // ALLOC_CACHE_HANDLER::ALLOC_CACHE_HANDLER()



ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER(VOID)
{
    if ( m_fValid) {

        CleanupLookaside( TRUE );

        DeleteCriticalSection( & m_csLock);
        ALLOC_CACHE_HANDLER::RemoveItem( this);
    }

    DBG_ASSERT( 0 == m_nTotal );
    DBG_ASSERT( m_lHead.Next == NULL);
    return;
} // ALLOC_CACHE_HANDLER::~ALLOC_CACHE_HANDLER()



VOID
ALLOC_CACHE_HANDLER::CleanupLookaside(
    IN BOOL             fForceCleanup
)
/*++
  Description:
    This function cleans up the lookaside list by removing excess storage space
    used by the objects allocated by this instance. This function is
    used by the periodic scavenging operation as well as for final cleanup.

  Arguments:
    fForceCleanup - forces a cleanup operation always.

  Returns:
     None
--*/
{
    if ( !fForceCleanup )
    {
        //
        // We are called for the regular scavenging operation
        // Take a snapshot of the # allocation calls so that
        //  we may cleanup space when services are idle.
        //

        IF_DEBUG( ALLOC_CACHE) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AllocCalls = %ld, LastAllocCount = %ld\n",
                         m_nAllocCalls,
                         m_nLastAllocCount ));
        }

        if ( m_nAllocCalls != m_nLastAllocCount )
        {
            InterlockedExchange( &m_nLastAllocCount,
                                 m_nAllocCalls );
            return;
        }
    }

    SINGLE_LIST_ENTRY listHeadCopy;

    //
    // make a copy of the first element in the list inside the lock
    // Free the entire chain outside the locked section.
    // Otherwise on a busy system the threads will be waiting for 
    //  this thread to complete
    //

    Lock();
    listHeadCopy.Next = m_lHead.Next;

    //
    // we are about to cleanup all entries -> so set state back properly.
    //
    m_lHead.Next      = NULL;
    m_nFreeEntries    = 0; // no more free-entries available
    Unlock();

    //
    // free up all the entries in the list
    //

    PSINGLE_LIST_ENTRY pl;
    pl = PopEntryList( &listHeadCopy);
    while ( pl != NULL) {

        InterlockedDecrement( &m_nTotal);
        ::LocalFree( pl);
        pl = PopEntryList( &listHeadCopy);
    } // for

    DBG_ASSERT( listHeadCopy.Next == NULL);

    return;
} // ALLOC_CACHE_HANDLER::CleanupLookaside()



LPVOID
ALLOC_CACHE_HANDLER::Alloc( VOID )
{
    LPVOID pv = NULL;

    if ( m_nFreeEntries > 0) {

        // 
        // There are free entries available - allocate from the free pool
        //

        Lock();

        // Check again if the free entry is available.
        if ( m_nFreeEntries > 0) {
            pv = (LPVOID )PopEntryList( & m_lHead);  // get the real object
            m_nFreeEntries--;
        }
        Unlock();
    }

    if ( NULL == pv) {

        //
        // No free entry. Need to alloc a new object.
        //

        pv = (LPVOID ) LocalAlloc( LPTR, m_acConfig.cbSize);

        if ( NULL != pv) {

            // initialize the list head properly and extract exact object.
            ((PSINGLE_LIST_ENTRY ) pv)->Next = NULL;

            // pv = (LPVOID ) (((PSINGLE_LIST_ENTRY ) pv));

            // update counters
            InterlockedIncrement( &m_nTotal);
        }
    }

    if ( NULL != pv ) { InterlockedIncrement( &m_nAllocCalls); }

    return ( pv);
} // ALLOC_CACHE_HANDLER::Alloc()



BOOL
ALLOC_CACHE_HANDLER::Free( LPVOID pv)
{
    // Assume that this is allocated using the Alloc() function
    DBG_ASSERT( NULL != pv);

    // store the items in the alloc cache.

    if ( m_nFreeEntries >= m_acConfig.nThreshold) {

        //
        // threshold for free entries is exceeded. free the object to 
        //  process pool
        //

        ::LocalFree( pv);
        InterlockedDecrement( &m_nTotal);
    } else {

        //
        // Store the given pointer in the single linear list
        //

        Lock();
        PushEntryList( &m_lHead,  (((PSINGLE_LIST_ENTRY ) pv)));
        m_nFreeEntries++;
        Unlock();
    }

    InterlockedIncrement( &m_nFreeCalls);

    return ( TRUE);
} // ALLOC_CACHE_HANDLER::Free()




VOID
ALLOC_CACHE_HANDLER::Print( VOID)
{
    CHAR  rgchBuffer[8192];
    DWORD cchBuffer = sizeof(rgchBuffer);

    DBG_REQUIRE( IpPrint( rgchBuffer, &cchBuffer));

    DBGDUMP(( DBG_CONTEXT, rgchBuffer));

    return;
} // ALLOC_CACHE_HANDLER::Print()



BOOL
ALLOC_CACHE_HANDLER::IpPrint( OUT CHAR * pchBuffer, IN OUT LPDWORD pcchSize)
{
    DWORD cchUsed;

    cchUsed = wsprintfA( pchBuffer,
                         "[%d]ALLOC_CACHE_HANDLER[%08p]. Config: "
                         " ObjSize = %d. Concurrency=%d. Thres=%d.\n"
                         " TotalObjs = %d. Calls: Alloc(%d), Free(%d)."
                         " FreeEntries = %d.\n"
                         ,
                         GetCurrentThreadId(),
                         this,
                         m_acConfig.cbSize, m_acConfig.nConcurrency,
                         m_acConfig.nThreshold,
                         m_nTotal, m_nAllocCalls, m_nFreeCalls, m_nFreeEntries
                         );
    Lock();

    // NYI: Print the list of individual pointers
    Unlock();

    DBG_ASSERT( *pcchSize > cchUsed);
    *pcchSize = cchUsed;

    return (TRUE);
} // ALLOC_CACHE_HANDLER::IpPrint()



VOID
ALLOC_CACHE_HANDLER::QueryStats( IN ALLOC_CACHE_STATISTICS * pacStats )
{
    DBG_ASSERT( pacStats != NULL );

    pacStats->acConfig      = m_acConfig;
    pacStats->nTotal        = m_nTotal;
    pacStats->nAllocCalls   = m_nAllocCalls;
    pacStats->nFreeCalls    = m_nFreeCalls;
    pacStats->nFreeEntries  = m_nFreeEntries;

    return;
} // ALLOC_CACHE_HANDLER::QueryStats()


//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\atqdgram.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

--*/

#include "isatq.hxx"

typedef GUID UUID;

extern "C" {

#include <ntdsa.h>

};

VOID
AtqGetDatagramAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrRemote,
    OUT INT *        pcbsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = (SOCKET) pContext->hAsyncIO;
    *pEndpointContext = pContext->pEndpoint->Context;
    *ppvBuff = pContext->pvBuff;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    *ppsockaddrRemote = (PSOCKADDR) pContext->AddressInformation;
    *pcbsockaddrRemote = pContext->AddressLength;

    return;
} // AtqGetDatagramAddrs()


DWORD_PTR
AtqContextGetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    DWORD_PTR dwOldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            dwOldVal = pContext->TimeOut;
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                dwOldVal = pContext->NextTimeout;
            }
            break;

        case ATQ_INFO_COMPLETION:

            dwOldVal = (DWORD_PTR) pContext->pfnCompletion;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            dwOldVal = (DWORD_PTR) pContext->ClientContext;
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextGetInfo()



BOOL
AtqWriteDatagramSocket(
    IN PATQ_CONTEXT  patqContext,
    IN LPWSABUF     pwsaBuffers,
    IN DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    I_SetNextTimeout(pContext);

    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        return WSAENOTSOCK;
    }
    
    fRes = ( (WSASendTo( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbWritten,
                       0,               // no flags
                       (PSOCKADDR) pContext->AddressInformation,
                       pContext->AddressLength,
                       lpo,
                       NULL             // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); }

    return fRes;

} // AtqWriteDatagramSocket()



VOID
ATQ_CONTEXT::InitDatagramState(
            VOID
            )
{

    fDatagramContext= IS_DATAGRAM_CONTEXT(this);

    if (fDatagramContext) {

        //
        // The address information is stored in the buffer after
        // the data. Store a pointer to it as well as its
        // length
        //

        AddressLength = 2*MIN_SOCKADDR_SIZE;
        AddressInformation = (PVOID) ((PUCHAR) pvBuff + pEndpoint->InitialRecvSize);
        NextTimeout = ATQ_INFINITE;
    }

    return;
} // ATQ_CONTEXT::InitDatagramState


#define I_SetNextTimeout2( _c, _t ) {                               \
    (_c)->NextTimeout = AtqGetCurrentTick() + (_t);                 \
    if ( (_c)->NextTimeout < (_c)->ContextList->LatestTimeout ) {   \
        (_c)->ContextList->LatestTimeout = (_c)->NextTimeout;       \
    }                                                               \
}


DWORD_PTR
AtqContextSetInfo2(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    DWORD_PTR              Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT   pContext = (PATQ_CONT) patqContext;
    DWORD_PTR   dwOldVal = 0;
    DWORD       timeout;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE ) {
        switch ( atqInfo ) {

        case ATQ_INFO_NEXT_TIMEOUT:
            dwOldVal = pContext->NextTimeout;
            timeout = CanonTimeout( (DWORD)Data );
            I_SetNextTimeout2( pContext, timeout );
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextSetInfo2



DWORD_PTR
AtqEndpointSetInfo2(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint    - endpoint to set info on
    EndpointInfo - type of info to set
    dwInfo       - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoConsumerType:
            dwVal = pEndpoint->ConsumerType;
            pEndpoint->ConsumerType = (ATQ_CONSUMER_TYPE)dwInfo;
            break;

      default:
        ATQ_ASSERT( FALSE );
    }
    return dwVal;
} // AtqEndpointSetInfo2()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\atqendp.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      atqendp.cxx

   Abstract:
      This module implements ATQ endpoints

   Author:

       Johnson Apacible    (JohnsonA)     13-May-1996

   Environment:

       User Mode -- Win32

--*/

#include "isatq.hxx"

//
// Forward declarations
//

BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    );

extern DWORD g_cCPU;

# define ATQ_MIN_ACCEPTEX_TIMEOUT    (120)  // 2 minutes = 120 seconds

#define ATQ_CLOSE_ENDPOINT_SLEEP_TIME (200) // 200ms = 1/5 second
#define ATQ_CLOSE_ENDPOINT_TIMEOUT    ((10 * 1000) / ATQ_CLOSE_ENDPOINT_SLEEP_TIME)
                                            // 10 seconds

#define ATQ_MIN_ACCEPTEX_SOCKETS         (5)
#define ATQ_MAX_ACCEPTEX_SOCKETS         (150) // just seems like a lot.


PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    )

/*++

Routine Description:

    Creates a server instance.

Arguments:

    Context - Context value returned

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{

    DWORD timeout = Configuration->AcceptExTimeout;
    PATQ_ENDPOINT endpoint;
    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqCreateEndpoint entered\n"));
    }

    //
    // Allocate list
    //

    endpoint = (PATQ_ENDPOINT)LocalAlloc(0,sizeof(ATQ_ENDPOINT));
    if ( endpoint == NULL ) {
        ATQ_PRINTF(( DBG_CONTEXT,"Unable to allocate ATQ Endpoint\n"));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error;
    }

    //
    // Initialize
    //

    ZeroMemory(endpoint,sizeof(ATQ_ENDPOINT));
    endpoint->Signature = ATQ_ENDPOINT_SIGNATURE;
    endpoint->m_refCount = 1;
    SET_BLOCK_STATE(endpoint, AtqStateActive);

    endpoint->EnableBw = FALSE;
    endpoint->ConnectCompletion = Configuration->pfnConnect;
    endpoint->ConnectExCompletion = Configuration->pfnConnectEx;
    endpoint->IoCompletion = Configuration->pfnIoCompletion;
    endpoint->fDatagram = Configuration->fDatagram;
    endpoint->ListenSocket = INVALID_SOCKET;
    endpoint->pListenAtqContext = NULL;
    endpoint->nAvailDuringTimeOut = 0;
    endpoint->nSocketsAvail = 0;
    endpoint->Context = EndpointContext;
    endpoint->fExclusive = Configuration->fLockDownPort;
    endpoint->fReverseQueuing = Configuration->fReverseQueuing;
    endpoint->cbDatagramWSBufSize = Configuration->cbDatagramWSBufSize;
    
    endpoint->InitialRecvSize = Configuration->cbAcceptExRecvBuffer;

    // we need to maintain at least 5 outstanding accept ex sockets
    // for our auto-tune algo to work.
    endpoint->nAcceptExOutstanding = 
        min((g_cCPU * (max(ATQ_MIN_ACCEPTEX_SOCKETS, Configuration->nAcceptExOutstanding))),
             ATQ_MAX_ACCEPTEX_SOCKETS);

    endpoint->fAddingSockets = FALSE;

    //
    // Check and set the timeout to be atleast minimum timeout for AcceptEx
    //
    if ( timeout <= ATQ_MIN_ACCEPTEX_TIMEOUT)  {
        timeout = ATQ_MIN_ACCEPTEX_TIMEOUT;
    }

    endpoint->AcceptExTimeout = CanonTimeout( timeout);

    endpoint->Port = Configuration->ListenPort;
    endpoint->IpAddress = Configuration->IpAddress;
    endpoint->ConsumerType = AtqConsumerOther;

    //endpoint->ContextList.Initialize( );

#if DBG
    endpoint->RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

#if 0
    ATQ_PRINTF(( DBG_CONTEXT,"port %d nAX %d nAT %d nLB %d\n",
        endpoint->Port, endpoint->nAcceptExOutstanding,
        endpoint->AcceptExTimeout, g_cListenBacklog));
#endif

    //
    // Create the socket
    //

    if (!I_CreateListenSocket(endpoint) ) {

        goto error;
    }

    return((PVOID)endpoint);

error:

    if ( endpoint != NULL ) {
#if DBG
        if( endpoint->RefTraceLog != NULL ) {
            DestroyRefTraceLog( endpoint->RefTraceLog );
        }
#endif
        LocalFree( endpoint );
    }

    return(NULL);

} // AtqCreateEndpoint



BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    )
{
    BOOL useAcceptEx;
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    ATQ_ASSERT(IS_BLOCK_ACTIVE(pEndpoint));

    pEndpoint->UseAcceptEx = useAcceptEx =
        ((g_fUseAcceptEx) && (pEndpoint->ConnectExCompletion != NULL)) ||
        pEndpoint->fDatagram;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqStartEndpoint called. UseAcceptEx[%d]\n",
            useAcceptEx));
    }

    //
    // if AcceptEx is supported, create AcceptEx contexts
    //

    if ( useAcceptEx ) {

        //
        // Add AcceptEx sockets
        //

        fReturn = pEndpoint->ActivateEndpoint();

        if ( !fReturn ) {
            DBGPRINTF(( DBG_CONTEXT,"Error %d in %08x::ActivateEndpoint()\n",
                GetLastError(), pEndpoint));
        }

    } else {

        //
        // We need to start a listen thread
        //

        fReturn = StartListenThread( pEndpoint );

        if ( !fReturn ) {
            DBGPRINTF(( DBG_CONTEXT,"Error %d in %08x::StartListenThread()\n",
                GetLastError(), pEndpoint));
        }
    }

    return (fReturn);

} // AtqStartEndpoint



DWORD_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ endpoint

Arguments:

    Endpoint    - endpoint to get data from
    EndpointInfo - type of info to get

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

      case EndpointInfoListenPort:
        dwVal = pEndpoint->Port;
        break;

      case EndpointInfoListenSocket:
        dwVal = pEndpoint->ListenSocket;
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointGetInfo()



DWORD_PTR
AtqEndpointSetInfo(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN DWORD_PTR            dwInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint    - endpoint to set info on
    EndpointInfo - type of info to set
    dwInfo       - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoAcceptExOutstanding:

        dwVal = pEndpoint->nAcceptExOutstanding;

        if ( dwVal < dwInfo ) {

            //
            // Make up for increased limit
            //

            if ( (DWORD ) pEndpoint->nSocketsAvail < (dwInfo >> 2) ) {
                (VOID ) I_AtqPrepareAcceptExSockets(
                                        pEndpoint,
                                        ((DWORD)dwInfo>>2) - pEndpoint->nSocketsAvail
                                        );
            }
            pEndpoint->nAcceptExOutstanding = (DWORD)dwInfo;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointSetInfo()




BOOL
AtqStopEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Stops the endpoint - marks the Endpoint as to be shutdown and closes
    the listening socket -> forcing new connections to stop for this endpoint

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopEndpoint( %08x)\n", pEndpoint));
    }

    //
    //  Find the listen socket info
    //

    AcquireLock( &AtqEndpointLock );

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Stop Endpoint (%08x) more than once",
                     pEndpoint
                     ));
        ReleaseLock( &AtqEndpointLock );
        return(FALSE);
    }

    //
    //  Mark the listen info as no longer accepting connections
    //

    SET_BLOCK_STATE(pEndpoint, AtqStateClosed);

    //
    //  Remove the entry from the end points list
    //

    RemoveEntryList(&pEndpoint->ListEntry);
    ReleaseLock( &AtqEndpointLock );

    //
    // Close the listen socket which forces the cleanup for all the
    //  pending LISTEN ATQ contexts. We do this early on so that
    //  we can prevent any new entrant connections into the processing code.
    //

    I_CloseListenSocket( pEndpoint );

    //
    // Forcibly close all the pending LISTEN contexts tied to this endpoint
    //

    nClosed = pEndpoint->CloseAtqContexts( TRUE);

    DBGPRINTF(( DBG_CONTEXT,
                "ATQ_ENDPOINT(%08x)::Closed %d pending Listen sockets\n",
                pEndpoint, nClosed));

    //
    // if this is a non-acceptex socket, wait for the listen thread to die
    //

    if ( !pEndpoint->UseAcceptEx ) {
        WaitForSingleObject(pEndpoint->hListenThread, 10*1000);
    }

    return ( TRUE);

} // AtqStopEndpoint()


BOOL
AtqCloseEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Closes the endpoint - it forcefully fress up all references to the
    endpoint (held by ATQ Contexts) by shutting down the ATQ contexts.
    In the course of this operation if some context does not go away, this
    code will end up looping forever!

    Note: Should be called *after* AtqStopEndpoint()

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;
    DWORD i;

    XOMASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqCloseEndpoint( %08x)\n", pEndpoint));
    }

    if ( pEndpoint->State != AtqStateClosed) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Close Endpoint (%08x) when it is "
                     " not stopped yet!\n'",
                     pEndpoint
                     ));
        return(FALSE);
    }

    //
    // wait for all the contexts for this endpoint to go away
    // or for about two minutes
    //

    i = 0;
    while (( pEndpoint->m_refCount > 1) && (i < ATQ_CLOSE_ENDPOINT_TIMEOUT)) {

        ATQ_PRINTF(( DBG_CONTEXT, " Endpoint(%08x) has %d refs\n",
                     pEndpoint, pEndpoint->m_refCount));

        //
        // Forcibly close all the contexts tied to this endpoint again!
        // Sometimes for some random reasons ATQ contexts get left out
        //  during the first clean we did above. In such case it is important
        //  to retry again
        // THIS IS UGLY. But if we did not do this then the Endpoint
        //  structure might get freed => ATQ contexts will be hanging on to
        //  dead ATQ endpoint
        //

        nClosed = pEndpoint->CloseAtqContexts();

        DBGPRINTF(( DBG_CONTEXT, " ATQ_ENDPOINT(%08x)::Closed %d sockets\n",
                    pEndpoint, nClosed));

        //
        // NYI: I need to auto-tune this sleep function
        //
        Sleep( ATQ_CLOSE_ENDPOINT_SLEEP_TIME); // sleep and check again.

        //
        // loop until timeout
        //
        i++;

        // wake up and check again.
    } // while (busy wait)

    //
    //  Undo the reference for being on the listen info list.
    //    decr final ref count => the endpoint will be cleaned up & freed
    //
    //  If we timed out just leak the endpoints!
    //

    if ( pEndpoint->m_refCount == 1 ) {
        pEndpoint->Dereference();

        return TRUE;
    } else {
        return FALSE;
    }

} // AtqCloseEndpoint()



BOOL
AtqStopAndCloseEndpoint(
    IN PVOID                    Endpoint,
    IN LPTHREAD_START_ROUTINE   lpCompletion,
    IN PVOID                    lpCompletionContext
    )
/*++

Routine Description:

    Stops the endpoint and closes it after forcing close of
    associated ATQ contexts.

Arguments:

    Endpoint - endpoint to shutdown.
    lpCompletion - routine to be called when endpoint is completely shutdown.
    lpCompletionContext - Context to be returned with the routine

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    //
    // Warn all the callers of this to be deprecated API and pray that
    // they will all switch over
    //
    OutputDebugStringA( "\n-----------------------------------------------\n");
    OutputDebugStringA( " AtqStopAndCloseEndpoint() should NOT be called\n");
    OutputDebugStringA( "         Call 1) AtqStopEndpoint()  and \n");
    OutputDebugStringA( "              2) AtqCloseEndpoint() instead\n");
    OutputDebugStringA( "   For Now, this call will simulate 1 & 2\n");
    OutputDebugStringA( "-----------------------------------------------\n");


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopAndCloseEndpoint( %08x)\n", pEndpoint));
    }

    fReturn = AtqStopEndpoint( Endpoint);

    if ( fReturn) {

        //
        // Call any custom shutdown function
        // NYI: Too Bad the Endpoint object is not a base class object
        //

        if ( lpCompletion != NULL ) {
            pEndpoint->ShutdownCallback = lpCompletion;
            pEndpoint->ShutdownCallbackContext = lpCompletionContext;
        }

        //
        // Now that the Endpoint is stopped and callback functions are called,
        //  Let us call the AtqCloseEndpoint() to cleanup the endpoint itself.
        //
        fReturn = AtqCloseEndpoint( Endpoint);
    }

    return (fReturn);

} // AtqStopAndCloseEndpoint()



BOOL
ATQ_ENDPOINT::ActivateEndpoint( VOID)
/*++

Routine Description:


    This function creates the initial listening socket & ATQ context for given
    endpoint. It also adds initial set of AcceptEx Sockets to the ATQ listening
    pool (if we are using the AcceptEx())

Arguments:
    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PATQ_CONT   patqContext = NULL;
    BOOL        fReturn;
    DWORD       cInitial = this->nAcceptExOutstanding;

    //
    //  Add the listen socket
    //
    DBG_ASSERT( this->pListenAtqContext == NULL);

    fReturn =
        I_AtqAddListenEndpointToPort(
                                     (PATQ_CONT*)&this->pListenAtqContext,
                                     this
                                     );

    if ( !fReturn) {

        if ( this->pListenAtqContext ) {
            AtqFreeContext( this->pListenAtqContext, FALSE);
            this->pListenAtqContext = NULL;
        }

        return FALSE;
    }

    cInitial = max(cInitial, 1);

    if ( !TsIsNtServer( ) ) {

        //
        // Limit what a workstation can specify
        //

        cInitial = min(cInitial, ATQ_MIN_CTX_INC);
        this->nAcceptExOutstanding = cInitial;

    }

    //
    // start with 1/4 of the intended
    //

    cInitial = max( cInitial >> 2, 1);

    //
    //  Now add the acceptex sockets for this ListenInfo object
    //

    return(I_AtqPrepareAcceptExSockets(this, cInitial));

} // ATQ_ENDPOINT::ActivateEndpoint()



DWORD
ATQ_ENDPOINT::CloseAtqContexts( IN BOOL fPendingOnly)
/*++
  Description:
    This function searches for all ATQ contexts associated
     with the given endpoint and forcibly closes them all.

  Arguments:
    fPendingOnly - close only the pending sockets

  Returns:
    DWORD containing the number of ATQ contexts closed.
--*/
{
    DWORD  nClosed = 0;
    DWORD  i;
    PLIST_ENTRY   pEntry;
    PATQ_CONT     pContext;

    //
    //  Force a close on all the connected sockets so that all the holders
    //   and use of such contexts will bail out of this endpoint entirely.
    // NYI: We need a way to tag on all these lists on per-endpoint basis
    //

    for ( i = 0; i < g_dwNumContextLists; i++) {

        PLIST_ENTRY pListHead;

        AtqActiveContextList[i].Lock();

        //
        // Hard close sockets in the pending list
        //

        pListHead = &AtqActiveContextList[i].PendingAcceptExListHead;
        for ( pEntry = pListHead->Flink;
             pEntry != pListHead;
             pEntry  = pEntry->Flink ) {

            pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

            ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

            if ( (pContext->pEndpoint == this) &&
                 (pContext->IsState( ACS_SOCK_CONNECTED) ||
                  pContext->IsState( ACS_SOCK_LISTENING)
                  ) &&
                 (pContext->hAsyncIO  != NULL) ) {

                nClosed++;
                pContext->HardCloseSocket();
            }
        } // for items in pending list

        if ( !fPendingOnly) {
            //
            // Hard close sockets in the active list
            // Active list includes sockets in ACS_SOCK_CLOSED state
            //  that ought to be freed up, because we could have reached
            //  this through the optimizations for TransmitFile()
            //

            pListHead = &AtqActiveContextList[i].ActiveListHead;
            for ( pEntry = pListHead->Flink;
                  pEntry != pListHead;
                  pEntry  = pEntry->Flink ) {

                pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT,
                                              m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

                if ( (pContext->pEndpoint == this)  &&
                     (pContext->IsState( ACS_SOCK_CONNECTED) ||
                      pContext->IsState( ACS_SOCK_LISTENING) ||
                      pContext->IsState( ACS_SOCK_CLOSED) ||
                      pContext->IsState( ACS_SOCK_UNCONNECTED)
                      ) &&
                     (pContext->hAsyncIO  != NULL) ) {

                    nClosed++;
                    pContext->HardCloseSocket();
                }
            } // for items in active list
        } // if (! fPendingOnly)

        AtqActiveContextList[i].Unlock();

    } // for

    return ( nClosed);

} // ATQ_ENDPOINT::CloseAtqContexts()


/************************************************************
 * Internal Functions
 ************************************************************/


BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    )
/*++

    Creates a socket for listening to connections on given address.

    Arguments:

       lpSockAddress    pointer to local socket address structure used to bind
                           the given connection.
       lenSockAddress   length of the socket address structure.
       socketType       integer containing the type of the socket ( stream )
       socketProtocol   protocol to be used for the socket.
       nBackLog         Maximum length to which a queue of pending connections
                           may grow.

    Returns:
       NO_ERROR on success; otherwise returns Sockets error code.

--*/
{
    INT serr;
    SOCKET  sNew;
    SOCKADDR_IN inAddr;
    PSOCKADDR addr;
    INT addrLength;
    PLIST_ENTRY listEntry;
    PATQ_ENDPOINT scanEndpoint;
    DWORD     cbOut;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CreateListenEndpoint called. \n"));
    }

    //
    // Create a new socket
    //

#if WINSOCK11
    sNew =  socket(
                AF_INET,
                SOCK_STREAM,
                IPPROTO_TCP
                );
#else
    sNew = WSASocket(
                  AF_INET,
                  pEndpoint->fDatagram ? SOCK_DGRAM : SOCK_STREAM,
                  pEndpoint->fDatagram ? IPPROTO_UDP: IPPROTO_TCP,
                  NULL,  // protocol info
                  0,     // Group ID = 0 => no constraints
                  WSA_FLAG_OVERLAPPED    // completion port notifications
                  );
# endif // WINSOCK11

    if ( sNew == INVALID_SOCKET ) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,
                    "Error %d in socket( %d, %d, %d)\n",
                    serr,
                    AF_INET,
                    SOCK_STREAM,
                    IPPROTO_TCP
                    ));

        goto cleanup;
    }

    //
    // Set EXCLUSIVE use if needed
    //

    if ( pEndpoint->fExclusive ) {
        ATQ_PRINTF(( DBG_CONTEXT,
                    " Setting %s port %d to exclusive access\n",
                    pEndpoint->fDatagram ? "UDP" : "TCP",
                    pEndpoint->Port));

        if ( setsockopt( sNew, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,
                        (const CHAR *) &pEndpoint->fExclusive,
                        sizeof( pEndpoint->fExclusive )) != 0) {

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                        " setsockopt( %d, EXCLUSIVEADDR, FALSE) failed."
                        " Error = %d\n",
                        sNew, serr));
            serr = 0;
        }
    }

    if ( pEndpoint->fDatagram ) {

        //
        // ReverseQueuing means that if winsock runs out of buffer space for
        // receives then it will drop the oldest datagrams first.  The default 
        // is for it to drop the newest datagrams.
        //
        if ( pEndpoint->fReverseQueuing
            && WSAIoctl(sNew,                          // socket
                        SIO_ENABLE_CIRCULAR_QUEUEING,  // IoControlCode
                        NULL,                          // pvInBuffer
                        0,                             // cbInBuffer
                        NULL,                          // pvOutBuffer
                        0,                             // cbOutBuffer
                        &cbOut,                        // cbActualBytesReturned
                        NULL,                          // pvOverlapped
                        NULL)) {                       // pCompletionRoutine

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                         " WSAIoctl( %d, SIO_ENABLE_CIRCULAR_QUEUEING...) failed.  Error = 0x%x\n",
                         sNew, serr));

            serr = 0;
        }

        //
        // If they have specified a winsock receive buffer size use that instead
        // the winsock default of 8K.
        //
        if ( pEndpoint->cbDatagramWSBufSize
             && setsockopt(sNew,
                           SOL_SOCKET,
                           SO_RCVBUF,
                           (char *)&pEndpoint->cbDatagramWSBufSize,
                           sizeof(pEndpoint->cbDatagramWSBufSize))) {
            
            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                         " setsockopt( %d, SO_RECVBUF, %d...) failed.  Error = 0x%x\n",
                         sNew, pEndpoint->cbDatagramWSBufSize, serr));

            serr = 0;
        }
    }
    
    //
    // See which address family we're dealing with
    //

    addr = (PSOCKADDR)&inAddr;
    addrLength = sizeof(inAddr);
    ZeroMemory(addr, addrLength);

    inAddr.sin_family = AF_INET;
    inAddr.sin_port = htons(pEndpoint->Port);
    inAddr.sin_addr.s_addr = pEndpoint->IpAddress;

    //
    // Bind an address to socket
    //

    if ( bind( sNew, addr, addrLength) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    "bind ( socket = %d, Address = %08x, len = %d) "
                    " returns error = %u\n",
                    sNew, addr, addrLength, serr));

        goto cleanup;
    }

    //
    // Put the socket in listen mode
    //

    if ( !pEndpoint->fDatagram ) {

        if ( listen( sNew, g_cListenBacklog) != 0) {

            serr = WSAGetLastError();

            ATQ_PRINTF(( DBG_CONTEXT,
                        " listen( %d, %d) returned %d.\n",
                        sNew, g_cListenBacklog, serr));
            goto cleanup;
        }
    }
    pEndpoint->ListenSocket = sNew;

    //
    // Link to server listen list
    //

    AcquireLock( &AtqEndpointLock);

    InsertTailList(
                &AtqEndpointList,
                &pEndpoint->ListEntry
                );

    ReleaseLock( &AtqEndpointLock);
    return(TRUE);

cleanup:

    if ( sNew != INVALID_SOCKET) {
        closesocket( sNew);
    }

    SetLastError(serr);
    return(FALSE);

} // I_CreateListenSocket




BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    )
/*++

  Closes the socket on which a listen was possibly established.

  Returns:
    TRUE, if successful,
    FALSE, otherwise

--*/
{
    INT  serr = NO_ERROR;
    LINGER linger;
    SOCKET s;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CloseListenSocket called.\n"));
    }

    s = (SOCKET)InterlockedExchangePointer(
                    (PVOID *)&Endpoint->ListenSocket,
                    (PVOID)INVALID_SOCKET
                    );

    if ( s == INVALID_SOCKET) {
        return(TRUE);
    }

    //
    //  Enable linger with timeout of ZERO for "hard" close
    //
    //  Error code from sock option is ignored, since we are
    //   anyway closing the socket
    //

    linger.l_onoff = TRUE;
    linger.l_linger = 0;
    setsockopt( s, SOL_SOCKET, SO_LINGER, (PCHAR)&linger,sizeof(linger));

    //
    // Close the socket
    //

    if (closesocket(s) != 0) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,"error %d in closesocket\n",serr));
    } else {

        // Remove the socket from the ListenAtq Context as well
        //  since the socket is now closed here in this function.
        PATQ_CONTEXT patqc = Endpoint->pListenAtqContext;
        if ( patqc != NULL) {
            patqc->hAsyncIO = NULL;
        }
    }

    return (TRUE);
} // I_CloseListenSocket()




DWORD WINAPI
ListenThreadFunc(
        LPVOID Context
        )
/*++

    Main loop waiting for connections. ( The core of server)
    The thread loops around waiting on an accept() call on
     listenSocket.
    If there is a new message on socket, it invokes the
     callback function for connection.

    NEVER returns untill it is requested to stop by someother
      thread using a call to TS_CONNECTION_INFO::StopConnectionThread().

    Returns:

      0 on success and error code if there is a fatal error.


--*/
{

    INT serr;
    register SOCKET  sNewConnection;
    SOCKADDR_IN sockAddrRemote;
    PATQ_ENDPOINT endpoint = (PATQ_ENDPOINT)Context;

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThreadFunc() running.\n"));
    }

    //
    //  Loop Forever
    //

    for( ; ;) {

        int cbAddr = sizeof( sockAddrRemote);

        //
        //  Wait for a connection
        //

        IF_DEBUG(ENDPOINT) {
            ATQ_PRINTF((DBG_CONTEXT,"Listening for new connection\n"));
        }

        if ((sNewConnection = WSAAccept(
                                    endpoint->ListenSocket,
                                    (LPSOCKADDR ) &sockAddrRemote,
                                    &cbAddr,
                                    NULL,
                                    0)) != INVALID_SOCKET) {

            //
            // Valid Connection has been established.
            // Invoke the callback function to process this connection
            //   and then continue the loop
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Got new connection. sock[%d]\n",
                    sNewConnection));
            }

            (*endpoint->ConnectCompletion)(
                                sNewConnection,
                                &sockAddrRemote,
                                endpoint->Context,
                                (PVOID)endpoint
                                );

        } else {

            //
            // Some low level error has occured.
            //

            serr = WSAGetLastError();
            ATQ_PRINTF((DBG_CONTEXT,"Error %d in accept\n", serr));

            if ( serr == WSAEINTR) {

                //
                // Socket was closed by low-level call. Get out.
                //

                break;
            }

            //
            // Check if we are shutting down and if so QUIT
            //

            if (!IS_BLOCK_ACTIVE(endpoint)) {
                IF_DEBUG(ENDPOINT) {
                    ATQ_PRINTF((DBG_CONTEXT,"ListenThread shutting down\n"));
                }
                break;
            }

            //
            // Perform a graceful recovery from failure. NYI
            //  ( Tricky code). Both FTP and Web server are to test it!
            //    Will add this code later. ( MuraliK)
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Unexpected error %d on accept\n",
                    serr));
            }
        }
    }

    //
    // Cleanup & Exit. Cleanup is done by the code which called the shut down.
    //

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThread exiting.\n"));
    }
    return ( 0);  // No errors

} // ListenThreadFunc()



BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    )
{
    DWORD  id;

    Endpoint->hListenThread = CreateThread(
                                        NULL,
                                        0,
                                        ListenThreadFunc,
                                        (PVOID )Endpoint,
                                        0,
                                        &id
                                        );

    if ( Endpoint->hListenThread != NULL) {
        return(TRUE);
    }

    return(FALSE);

} // StartListenThread



VOID
ATQ_ENDPOINT::CleanupEndpoint(
    VOID
    )
/*++

  Description:
     This function cleansup the internal state of the object and prepares
     it for the deletion.
     All endpoints should pass through this function when the ref count
     this zero.

--*/
{
    DBG_ASSERT( this->m_refCount == 0);
    ATQ_ASSERT( !IS_BLOCK_ACTIVE( this) );
    XOMASSERT( this->Signature == ATQ_ENDPOINT_SIGNATURE );

    // the following free will throw away the listen atq context
    if ( this->pListenAtqContext != NULL) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "Endpoint(%08x) frees listen context %08x\n",
                     this, this->pListenAtqContext));
        AtqFreeContext( this->pListenAtqContext, FALSE);
        this->pListenAtqContext = NULL;
    }

    if ( this->ShutdownCallback != NULL ) {
        //
        // This only happens when someone calls AtqStopAndCloseEndpoint which should
        // never happen in K2.
        //
        XOMASSERT( FALSE );
        this->ShutdownCallback( this->ShutdownCallbackContext);
    }

    this->Signature = ATQ_ENDPOINT_SIGNATURE_FREE;

#if DBG
    if( this->RefTraceLog != NULL ) {
        DestroyRefTraceLog( this->RefTraceLog );
    }
#endif

    return;

} // ATQ_ENDPOINT::CleanupEndpoint()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\atqmain.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqInitialize();
       BOOL  AtqTerminate();

       DWORD AtqSetInfo();
       DWORD AtqGetInfo();
       BOOL  AtqGetStatistics();
       BOOL  AtqClearStatistics();

       BOOL  AtqAddAcceptExSockets();
       BOOL  AtqAddAsyncHandle();
       DWORD AtqContextSetInfo();
       VOID  AtqCloseSocket();
       VOID  AtqFreeContext();

       BOOL  AtqReadFile();
       BOOL  AtqWriteFile();
       BOOL  AtqTransmitFile();
       BOOL  AtqPostCompletionStatus();

       PVOID AtqAllocateBandwidthInfo();
       BOOL  AtqFreeBandwidthInfo();
       DWORD AtqBandwidthSetInfo();
--*/

#include "isatq.hxx"
#include <inetsvcs.h>
#include "sched.hxx"

# define ATQ_REG_DEF_THREAD_TIMEOUT_PWS    (30*60)  // 30 minutes

/************************************************************
 * Globals
 ************************************************************/

// ------------------------------
// Configuration for ATQ package
// ------------------------------

extern CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[];

// ----------------------------------------
// # of CPUs in machine (for thread-tuning)
// ----------------------------------------

extern DWORD g_cCPU;

//
// Used for guarding the initialization code
//

extern CRITICAL_SECTION MiscLock;

//
// concurrent # of threads to run per processor
//

DWORD g_cConcurrency = ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY;

//
//  Amount of time (in ms) a worker thread will be idle before suicide
//

DWORD g_msThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT * 1000;

BOOL  g_fUseAcceptEx = TRUE;    // Use AcceptEx if available

//
// The absolute thread limit
//

LONG   g_cMaxThreadLimit = ATQ_REG_DEF_POOL_THREAD_LIMIT;

//
// Should we use fake completion port
//

BOOL g_fUseFakeCompletionPort =  FALSE;

//
// Assumed minimum file transfer rate
//

DWORD g_cbMinKbSec = ATQ_REG_DEF_MIN_KB_SEC;

//
// Size of buffers for fake xmits
//

DWORD g_cbXmitBufferSize = ATQ_REG_DEF_NONTF_BUFFER_SIZE;

//
// number of active context list
//

DWORD g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST;

//
// Max winsock datagram send.
// 

DWORD g_cbMaxDGramSend = 2048;

/*
   g_pfnExitThreadCallback()
    This routine sets the callback routine to be called when one of the
    Atq threads exit so that thread state data can be cleaned up. Currently
    support is for a single routine. One way to support multiple routines would
    be for the caller to save the return value. Such an application would not
    be able to delete the "saved" callback routine.
 */
ATQ_THREAD_EXIT_CALLBACK g_pfnExitThreadCallback = NULL;

//
// g_pfnUpdatePerfCountersCallback()
//  This routine is used to update PerfMon counters that are located in the
//  DS core.
//
ATQ_UPDATE_PERF_CALLBACK g_pfnUpdatePerfCounterCallback = NULL;

// ----------------------------------
// Fake Completion port
// -----------------------------------
//
// Used to gauge pool thread creation. This variable shows number of
// ATQ contexts // ready to be processed by ATQ pool thread. Basically
// this is length of outcoming queue in SIO module and is modified by
// routines there
//

DWORD   g_AtqWaitingContextsCount = 0;

// ------------------------------
// Current State Information
// ------------------------------


HANDLE  g_hCompPort = NULL;      // Handle for completion port
LONG    g_cThreads = 0;          // number of thread in the pool
LONG    g_cAvailableThreads = 0; // # of threads waiting on the port.

//
// Is the NTS driver in use
//

BOOL    g_fUseDriver = FALSE;

//
// Current thread limit
//

LONG    g_cMaxThreads = ATQ_REG_DEF_ATQ_THREADS;

DWORD   g_cListenBacklog = ATQ_REG_DEF_LISTEN_BACKLOG;

BOOL    g_fShutdown = FALSE;   // if set, indicates that we are shutting down
                               // in that case, all threads should exit.

HANDLE  g_hShutdownEvent = NULL; // set when all running threads shutdown

// ------------------------------
// Bandwidth Throttling Info
// ------------------------------

PBANDWIDTH_INFO     g_pBandwidthInfo = NULL;

// ------------------------------
// Various State/Object Lists
// ------------------------------

//
// Used to switch context between lists
//

DWORD AtqGlobalContextCount = 0;

//
// List of active context
//

ATQ_CONTEXT_LISTHEAD AtqActiveContextList[ATQ_NUM_CONTEXT_LIST];

//
// List of Endpoints in ATQ - one per listen socket
//

LIST_ENTRY AtqEndpointList;
CRITICAL_SECTION AtqEndpointLock;

PALLOC_CACHE_HANDLER  g_pachAtqContexts;

#ifdef IIS_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // IIS_AUX_COUNTERS

// ------------------------------
// local to this module
// ------------------------------

LONG  sg_AtqInitializeCount = -1;
BOOL  g_fSpudInitialized = FALSE;

DWORD
I_AtqGetGlobalConfiguration(VOID);

DWORD
I_NumAtqEndpointsOpen(VOID);

VOID
WaitForWinsockCallback(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    );

BOOL
WaitForWinsockToInitialize(
    VOID
    );


/************************************************************
 * Functions
 ************************************************************/

BOOL
AtqInitialize(
    IN DWORD   dwFlags
    )
/*++
Routine Description:

    Initializes the ATQ package

Arguments:
    dwFlags - DWORD containing the flags for use to initialize ATQ library.
    Notably in many cases one may not need the SPUD driver initialized
      for processes other than the IIS main process. This dword helps
      to shut off the unwanted flags.

    This is an ugly way to initialize/shutdown SPUD, but that is what we
    will do. SPUD supports only ONE completion port and hence when we use
    ATQ in multiple processes we should be careful to initialize SPUD only
    once and hopefully in the IIS main process!

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

Note:
    As of 4/16/97 the pszRegKey that is sent is no more utilized.
    We always load the internal configuration parameters from
     one single registry entry specified by PSZ_ATQ_CONFIG_PARAMS_REG_KEY
    The parameter is left in the command line for compatibility
      with old callers :( - NYI: Need to change this.
--*/
{
    DWORD       i;
    DWORD       dwErr;

    //
    // We need to acquire a lock here to make this thread safe
    //

    AcquireLock(&MiscLock);

    if ( InterlockedIncrement( &sg_AtqInitializeCount) != 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqInitialize( %08x). ATQ is already initialized.\n",
                         dwFlags));
        }

        //
        // we are already initialized. Ignore the new registry settings
        //

        ReleaseLock(&MiscLock);
        return ( TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize[%08x]. Initializing....\n",
                     dwFlags));
    }

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::Initialize());
    IF_DEBUG( INIT_CLEAN ) {
        DBGPRINTF(( DBG_CONTEXT, "Alloc Cache initialized\n" ));
    }

    if ( !SchedulerInitialize()) {
        DBGPRINTF(( DBG_CONTEXT, "Initializing Scheduler Failed\n"));
        InterlockedDecrement( &sg_AtqInitializeCount);
        ReleaseLock(&MiscLock);
        return FALSE;
    }

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::SetLookasideCleanupInterval() );

    IF_DEBUG( INIT_CLEAN ) {
        DBGPRINTF(( DBG_CONTEXT, "Scheduler Initialized\n" ));
    }

    //
    // Initialize context lists and crit sects
    //

    ATQ_CONTEXT_LISTHEAD * pacl;

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        pacl->Initialize();
    }

    InitializeListHead( &AtqEndpointList );
    InitializeCriticalSection( &AtqEndpointLock );

    //
    // init bandwidth throttling
    //

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwInitialize() );

    //
    //  Read registry configurable Atq options.  We have to read these now
    //  because concurrency is set for the completion port at creation time.
    //

    DWORD dwError = I_AtqGetGlobalConfiguration();

    if ( NO_ERROR != dwError) {
        SetLastError( dwError);
        InterlockedDecrement( &sg_AtqInitializeCount);
        IIS_PRINTF((buff,"GetGlobal failed\n"));
        ReleaseLock(&MiscLock);
        return ( FALSE);
    }

    //
    // Setup an allocation cache for the ATQ Contexts
    // NYI: Auto-tune the threshold limit
    //

    {
        ALLOC_CACHE_CONFIGURATION acConfig;

        DWORD nCachedAtq = ATQ_CACHE_LIMIT_NTS;

        if ( TsIsWindows95()) { nCachedAtq = ATQ_CACHE_LIMIT_W95; }

        acConfig.nConcurrency = 1;
        acConfig.nThreshold = nCachedAtq;
        acConfig.cbSize = sizeof(ATQ_CONTEXT);

        g_pachAtqContexts = new ALLOC_CACHE_HANDLER( "ATQ", &acConfig);

        if ( NULL == g_pachAtqContexts) {
            IIS_PRINTF((buff,"alloc failed %d\n", GetLastError()));
            goto cleanup;
        }
    }


    //
    //  Create the shutdown event
    //

    g_hShutdownEvent = IIS_CREATE_EVENT(
                           "g_hShutdownEvent",
                           &g_hShutdownEvent,
                           TRUE,        // Manual reset
                           FALSE        // Not signalled
                           );

    //
    //  Create the completion port
    //

    g_hCompPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
                                            g_hCompPort,
                                            (DWORD) NULL,
                                            g_cConcurrency
                                            );

    if ( !g_hShutdownEvent || !g_hCompPort ) {

        OutputDebugString( " Create IoComp port failed\n");
        goto cleanup;
    }

    //
    // initialize spud driver
    //

    if ( dwFlags & ATQ_INIT_SPUD_FLAG ) {
        (VOID) I_AtqSpudInitialize(g_hCompPort);
        g_fSpudInitialized = TRUE;
    }

    //
    // Ensure all other initializations also are done
    //

    g_cThreads  = 0;
    g_fShutdown = FALSE;
    g_cAvailableThreads = 0;

    if ( !I_AtqStartTimeoutProcessing( NULL ) ) {
        IIS_PRINTF((buff,"Start processing failed\n"));
        goto cleanup;
    }

    IF_DEBUG(INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT,
                    "fUseAcceptEx[%d] NT CompPort[%d] Platform[%d]"
                    " fUseDriver[%d]\n",
                    g_fUseAcceptEx,  !g_fUseFakeCompletionPort,
                    IISPlatformType(),
                    g_fUseDriver
                    ));
    }

    //
    // Create the initial ATQ thread.
    //

    (VOID)I_AtqCheckThreadStatus( (PVOID)UIntToPtr(ATQ_INITIAL_THREAD) );

    //
    // Create a second thread if we are NTS
    //

    if ( TsIsNtServer() ) {
        (VOID)I_AtqCheckThreadStatus( (PVOID)UIntToPtr(ATQ_INITIAL_THREAD) );
    }

    dwErr = I_AtqStartThreadMonitor();
    ATQ_ASSERT( dwErr != FALSE );

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, TRUE));
    }

    WaitForWinsockToInitialize();

    ReleaseLock(&MiscLock);
    return TRUE;

cleanup:
    IIS_PRINTF((buff,"cleanup!!!\n"));
    for (i=0; i<g_dwNumContextLists; i++) {

        AtqActiveContextList[i].Cleanup();
    }

    DeleteCriticalSection( &AtqEndpointLock);

    if ( g_hShutdownEvent != NULL ) {
        CloseHandle( g_hShutdownEvent );
        g_hShutdownEvent = NULL;
    }

    if ( g_hCompPort != NULL ) {
        CloseHandle( g_hCompPort );
        g_hCompPort = NULL;
    }

    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwTerminate());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, FALSE));
    }

    InterlockedDecrement( &sg_AtqInitializeCount);
    ReleaseLock(&MiscLock);
    return(FALSE);

} // AtqInitialize()





BOOL
AtqTerminate(
    VOID
    )
/*++

Routine Description:

    Cleans up the ATQ package.  Should only be called after all of the
    clients of ATQ have been shutdown.

Arguments:

    None.

Return Value:

    TRUE, if ATQ was shutdown properly
    FALSE, otherwise

--*/
{
    DWORD       currentThreadCount;
    ATQ_CONTEXT_LISTHEAD * pacl;

    // there are outstanding users, don't fully terminate
    if ( InterlockedDecrement( &sg_AtqInitializeCount) >= 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqTerminate() - there are other users."
                         " Not terminating now\n"
                         ));
        }
        return (TRUE);
    }

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Terminating ATQ ...\n"
                     ));
    }


    //
    // All the ATQ endpoints should have been terminated before calling
    //  this ATQTerminate() function. If not, sorry return failure.
    //
    DWORD nEndpointsToBeClosed = I_NumAtqEndpointsOpen();

    if ( nEndpointsToBeClosed > 0) {

        DBGPRINTF(( DBG_CONTEXT,
                    " There are %d endpoints remaining to be closed."
                    " Somebody above stream did not close endpoints."
                    " BUG IN CODE ABOVE ATQ\n"
                    ,
                    nEndpointsToBeClosed
                    ));
        SetLastError( ERROR_NETWORK_BUSY);
        return ( FALSE);
    }


    if ( (g_hShutdownEvent == NULL) || g_fShutdown ) {

        //
        // We have not been intialized or have already terminated.
        //
        SetLastError( ERROR_NOT_READY );
        return FALSE;
    }

    // Cleanup variables in ATQ Bandwidth throttle module
    if ( !BANDWIDTH_INFO::AbwTerminate()) {

        // there may be a few blocked IO. We should avoid them all.
        // All clients should have cleaned themselves up before coming here.
        return (FALSE);
    }

    //
    // All clients should have cleaned themselves up before calling us.
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {

        pacl->Lock();

        if ( !IsListEmpty(&pacl->ActiveListHead)) {

            ATQ_ASSERT( IsListEmpty( &pacl->ActiveListHead));
            pacl->Unlock();

            IF_DEBUG( API_EXIT) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "AtqTerminate() - ContextList(%08x) has "
                             "Active Contexts. Failed Termination.\n",
                             pacl
                             ));
            }

            return FALSE;
        }

        pacl->Unlock();
    } // for

    //
    // Note that we are shutting down and prevent any more handles from
    // being added to the completion port.
    //

    g_fShutdown = TRUE;

    //
    // Attempt and remove the TimeOut Context from scheduler queue
    //
    DBG_REQUIRE( I_AtqStopTimeoutProcessing());
    DBG_REQUIRE( I_AtqStopThreadMonitor() );

    currentThreadCount = g_cThreads;
    if (currentThreadCount > 0) {

        DWORD       i;
        BOOL        fRes;
        OVERLAPPED  overlapped;

        //
        // Post a message to the completion port for each worker thread
        // telling it to exit. The indicator is a NULL context in the
        // completion.
        //

        ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

        for (i=0; i<currentThreadCount; i++) {

            fRes = PostQueuedCompletionStatus( g_hCompPort,
                                               0,
                                               0,
                                               &overlapped );

            ATQ_ASSERT( (fRes == TRUE) ||
                       ( (fRes == FALSE) &&
                        (GetLastError() == ERROR_IO_PENDING) )
                       );
        }
    }

    //
    // Now wait for the pool threads to shutdown.
    //

    DWORD dwErr =
        WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
#if 0
    DWORD dwWaitCount = 0;
    while ( dwErr == WAIT_TIMEOUT) {

        dwWaitCount++;
        DebugBreak();
        Sleep( 10*1000);  // sleep for some time
        dwErr =
            WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
    } // while
# endif // 0

    //
    // At this point, no other threads should be left running.
    //
    //
    //  g_cThreads counter is decremented by AtqPoolThread().
    //  AtqTerminate() is called during the DLL termination
    //  But at DLL termination, all ATQ pool threads are killed =>
    //    no one is decrementing the count. Hence this assert will always fail.
    //

    // ATQ_ASSERT( !g_cThreads );

    ATQ_REQUIRE( CloseHandle( g_hShutdownEvent ) );
    CloseHandle( g_hCompPort );

    g_hShutdownEvent = NULL;
    g_hCompPort = NULL;

    //
    // Cleanup our synchronization resources
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        PLIST_ENTRY pEntry;

        pacl->Lock();

        if ( !IsListEmpty( &pacl->PendingAcceptExListHead)) {
            for ( pEntry = pacl->PendingAcceptExListHead.Flink;
                  pEntry != &pacl->PendingAcceptExListHead;
                  pEntry  = pEntry->Flink ) {

                PATQ_CONT pContext =
                    CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                pContext->Print();
            } // for
        }

        pacl->Unlock();
        pacl->Cleanup();
    }


    //
    // Free all the elements in the Allocation caching list
    //
    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    DeleteCriticalSection( &AtqEndpointLock);

    //
    // cleanup driver
    //

    if ( g_fSpudInitialized ) {
        (VOID)I_AtqSpudTerminate();
        g_fSpudInitialized = FALSE;
    }

    //
    // Cleanup scheduler
    //

    DBG_REQUIRE( ALLOC_CACHE_HANDLER::ResetLookasideCleanupInterval() );

    SchedulerTerminate();
    DBG_REQUIRE( ALLOC_CACHE_HANDLER::Cleanup());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Successfully cleaned up.\n"
                     ));
    }

    return TRUE;
} // AtqTerminate()





DWORD_PTR
AtqSetInfo(
    IN ATQ_INFO         atqInfo,
    IN DWORD_PTR        Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwOldVal = 0;

    switch ( atqInfo ) {

    case AtqBandwidthThrottle:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
        break;

    case AtqBandwidthThrottleMaxBlocked:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwOldVal = g_pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
        break;

    case AtqExitThreadCallback:

        dwOldVal = (DWORD_PTR) g_pfnExitThreadCallback;
        g_pfnExitThreadCallback =  (ATQ_THREAD_EXIT_CALLBACK ) Data;
        break;

    case AtqMaxPoolThreads:
        // the value is for the entire system, not per-processor anymore
        dwOldVal = g_cMaxThreads;
        g_cMaxThreads = (DWORD)Data;
        break;

      //
      //  Increment or decrement the max thread count.  In this instance, we
      //  do not scale by the number of CPUs
      //

      case AtqIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;

      case AtqDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &g_cMaxThreads );
        dwOldVal = TRUE;
        break;


      case AtqMaxConcurrency:
        dwOldVal = g_cConcurrency;
        g_cConcurrency = (DWORD)Data;
        break;

      case AtqThreadTimeout:
        dwOldVal = g_msThreadTimeout/1000;  // convert back to seconds
        g_msThreadTimeout = (DWORD)Data * 1000; // convert value to millisecs
        break;

      case AtqUseAcceptEx:
        dwOldVal = g_fUseAcceptEx;
        if ( !TsIsWindows95() ) {
            g_fUseAcceptEx = (DWORD)Data;
        }
        break;

      case AtqMinKbSec:

        //
        //  Ignore it if the value is zero
        //

        if ( Data ) {
            dwOldVal = g_cbMinKbSec;
            g_cbMinKbSec = (DWORD)Data;
        }
        break;

      case AtqUpdatePerfCounterCallback:

        dwOldVal = (DWORD_PTR) g_pfnUpdatePerfCounterCallback;
        g_pfnUpdatePerfCounterCallback =  (ATQ_UPDATE_PERF_CALLBACK ) Data;
        //
        // Now that we can communicate perf stats, update them to
        // where they are now.
        //
        //AtqUpdatePerfStats(ATQ_PERFCTR_WORKERTHREAD_CREATED, FLAG_COUNTER_SET, 
        //g_cThreads);
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return dwOldVal;
} // AtqSetInfo()





DWORD_PTR
AtqGetInfo(
    IN ATQ_INFO  atqInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set

Return Value:

    The old value of the parameter

--*/
{
    DWORD_PTR dwVal = 0;

    switch ( atqInfo ) {

      case AtqBandwidthThrottle:
        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwVal = g_pBandwidthInfo->QueryBandwidthLevel();
        break;

      case AtqExitThreadCallback:

        dwVal = (DWORD_PTR) g_pfnExitThreadCallback;
        break;

      case AtqMaxPoolThreads:
        dwVal = g_cMaxThreads;
        break;

      case AtqMaxConcurrency:
        dwVal = g_cConcurrency;
        break;

      case AtqThreadTimeout:
        dwVal = g_msThreadTimeout/1000; // convert back to seconds
        break;

      case AtqUseAcceptEx:
        dwVal = g_fUseAcceptEx;
        break;

      case AtqMinKbSec:
        dwVal = g_cbMinKbSec;
        break;

      case AtqMaxDGramSend:
        dwVal = g_cbMaxDGramSend;
        break;

      case AtqPoolThreadsLimit:
        dwVal = g_cMaxThreadLimit;
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    } // switch

    return dwVal;
} // AtqGetInfo()





BOOL
AtqGetStatistics(IN OUT ATQ_STATISTICS * pAtqStats)
{
    if ( pAtqStats != NULL) {

        return g_pBandwidthInfo->GetStatistics( pAtqStats );

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
} // AtqGetStatistics()





BOOL
AtqClearStatistics( VOID)
{
    return g_pBandwidthInfo->ClearStatistics();

} // AtqClearStatistics()





DWORD_PTR
AtqContextSetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    DWORD_PTR              Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    DWORD_PTR dwOldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            dwOldVal = pContext->TimeOut;
            pContext->TimeOut = CanonTimeout( (DWORD)Data );
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                DWORD currentTime = AtqGetCurrentTick( );
                DWORD timeout;
                dwOldVal = pContext->NextTimeout;
                timeout = pContext->TimeOut;

                //
                // Set the new timeout
                //

                I_SetNextTimeout(pContext);

                //
                // Return the old
                //

                if ( currentTime >= dwOldVal ) {
                    ATQ_ASSERT((dwOldVal & ATQ_INFINITE) == 0);
                    dwOldVal = 0;
                } else if ( (dwOldVal & ATQ_INFINITE) == 0 ) {
                    dwOldVal -= currentTime;
                }

                // return correct units
                dwOldVal = UndoCanonTimeout( (DWORD)dwOldVal );
            }
            break;

        case ATQ_INFO_COMPLETION:
            dwOldVal = (DWORD_PTR) pContext->pfnCompletion;
            pContext->pfnCompletion = (ATQ_COMPLETION) Data;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            ATQ_ASSERT( Data != 0 );        // NULL context not allowed

            dwOldVal = (DWORD_PTR) pContext->ClientContext;
            pContext->ClientContext = (void *) Data;
            break;

        case ATQ_INFO_BANDWIDTH_INFO:
        {
            ATQ_ASSERT( Data != 0 );

            PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) Data;

            ATQ_ASSERT( pBandwidthInfo->QuerySignature() ==
                                                ATQ_BW_INFO_SIGNATURE );

            if ( !pBandwidthInfo->IsFreed() )
            {
                pContext->m_pBandwidthInfo = (PBANDWIDTH_INFO) Data;
                pContext->m_pBandwidthInfo->Reference();
            }
            break;
        }

        case ATQ_INFO_ABORTIVE_CLOSE:
            dwOldVal = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
            if ( Data )
            {
                pContext->SetFlag( ACF_ABORTIVE_CLOSE );
            }
            else
            {
                pContext->ResetFlag( ACF_ABORTIVE_CLOSE );
            }
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return dwOldVal;

} // AtqContextSetInfo()


VOID
AtqUpdatePerfStats(
    IN DWORD                    dwStat,
    IN DWORD                    dwOperation,
    IN DWORD                    dwVal
    )
/*++

Routine Description:

    Updates DS Perfmon counters.

Arguments:

    dwStat       - Which statistic to update.
    dwOperation  - What to do to statistic
                   FLAG_COUNTER_INCREMENT - increment the value - INC()
                   FLAG_COUNTER_DECREMENT - decrement the value - DEC()
                   FLAG_COUNTER_SET - set the value directly - ISET()

Return Value:

    None

--*/
{
    //
    // Make sure that g_pfnUpdatePerfCountersCallback has been set.
    //
    if (g_pfnUpdatePerfCounterCallback == NULL) {
        return;
    }

    g_pfnUpdatePerfCounterCallback(dwStat, dwOperation, dwVal);

} // AtqUpdatePerfStats



BOOL
AtqAddAsyncHandle(
    PATQ_CONTEXT * ppatqContext,
    PVOID          EndpointObject,
    PVOID          ClientContext,
    ATQ_COMPLETION pfnCompletion,
    DWORD          TimeOut,
    HANDLE         hAsyncIO
    )
/*++

Routine Description:

    Adds a handle to the thread queue

    The client should call this after the IO handle is opened
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

Arguments:

    ppatqContext - Receives allocated ATQ Context
    Context - Context to call client with
    pfnCompletion - Completion to call when IO completes
    TimeOut - Time to wait (sec) for IO completion (INFINITE is valid)
    hAsyncIO - Handle with pending read or write

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    return ( I_AtqAddAsyncHandle( (PATQ_CONT *) ppatqContext,
                                  (PATQ_ENDPOINT) EndpointObject,
                                  ClientContext,
                                  pfnCompletion,
                                  TimeOut,
                                  hAsyncIO)
             &&
             I_AddAtqContextToPort( *((PATQ_CONT *) ppatqContext))
            );

} // AtqAddAsyncHandle()




VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    INT       cbsockaddrLocal;
    INT       cbsockaddrRemote;
    DWORD     cb;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = (SOCKET) pContext->hAsyncIO;
    *pEndpointContext = pContext->pEndpoint->Context;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    GetAcceptExSockaddrs( pContext->pvBuff,
                               (cb = pContext->pEndpoint->InitialRecvSize),
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               ppsockaddrLocal,
                               &cbsockaddrLocal,
                               ppsockaddrRemote,
                               &cbsockaddrRemote );

    *ppvBuff = ( ( cb == 0) ? NULL : pContext->pvBuff);

    return;
} // AtqGetAcceptExAddrs()




BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    )
/*++

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        BOOL fAbortiveClose;

        fAbortiveClose = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
        pContext->ResetFlag( ACF_ABORTIVE_CLOSE );

        //
        //  Don't delete the socket if we don't have to
        //

        if ( pContext->IsState( ACS_SOCK_UNCONNECTED |
                                ACS_SOCK_CLOSED)
             ) {

            //
            //  Do nothing
            //

        } else {

            // default:
            // case ACS_SOCK_LISTENING:
            // case ACS_SOCK_CONNECTED: {

            HANDLE hIO;
            PATQ_ENDPOINT pEndpoint;

            pEndpoint = pContext->pEndpoint;

            pContext->MoveState( ACS_SOCK_CLOSED);

            //
            //  During shutdown, the socket may be closed while this thread
            //  is doing processing, so only give a warning if any of the
            //  following fail
            //

            hIO = (HANDLE )InterlockedExchangePointer((PVOID *) &pContext->hAsyncIO,
                                                      NULL);

            if ( hIO == NULL ) {

                //
                // No socket - it is already closed - do nothing.
                //

            } else {

                if ( pContext->fDatagramContext ) {
                    return TRUE;
                }

                if (fAbortiveClose || fShutdown ) {

                    //
                    //  If this is an AcceptEx socket, we must first force a
                    //  user mode context update before we can call shutdown
                    //

                    if ( (pEndpoint != NULL) && (pEndpoint->UseAcceptEx) ) {

                        if ( setsockopt( (SOCKET) hIO,
                                         SOL_SOCKET,
                                         SO_UPDATE_ACCEPT_CONTEXT,
                                         (char *) &pEndpoint->ListenSocket,
                                         sizeof(SOCKET) ) == SOCKET_ERROR ) {

                            ATQ_PRINTF(( DBG_CONTEXT,
                                         "[AtqCloseSocket] Warning- setsockopt "
                                         "failed, error %d, socket = %x,"
                                         " Context= %08x, Listen = %lx\n",
                                         GetLastError(),
                                         hIO,
                                         pContext,
                                         pEndpoint->ListenSocket ));
                        }
                    }
                } // setsock-opt call

                if ( fAbortiveClose ) {
                    LINGER  linger;

                    linger.l_onoff = TRUE;
                    linger.l_linger = 0;

                    if ( setsockopt( (SOCKET) hIO,
                                     SOL_SOCKET,
                                     SO_LINGER,
                                     (char *) &linger,
                                     sizeof(linger) ) == SOCKET_ERROR
                         ) {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket] Warning- setsockopt "
                                     "failed, error %d, socket = %x,"
                                     " Context= %08x, Listen = %lx\n",
                                     GetLastError(),
                                     hIO,
                                     pContext,
                                     (pEndpoint != NULL) ? pEndpoint->ListenSocket : 0)); 
                                    // Bug fix #18327 - rahuln
                    }
                    else {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket(%08x)] requested"
                                     " abortive close\n",
                                     pContext));
                    }
                } // set up linger

                if ( fShutdown ) {

                    //
                    //  Note that shutdown can fail in instances where the
                    //  client aborts in the middle of a TransmitFile.
                    //  This is an acceptable failure case
                    //

                    shutdown( HandleToUlong(hIO), 1 );
                }

                DBG_ASSERT( hIO != NULL);

                if ( closesocket( HandleToUlong(hIO)) ) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqCloseSocket] Warning- closesocket "
                                 " failed, Context = %08x, error %d,"
                                 " socket = %x\n",
                                 pContext,
                                 GetLastError(),
                                 hIO ));
                }
            } // if (hIO != NULL)
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseSocket()



BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    )
/*++

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

    patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.

  Note:
   THIS FUNCTIONALITY IS ADDED TO SERVE A SPECIAL REQUEST!!!
   Most of the ATQ code thinks that the handle here is a socket.
   Except of course this function...
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext != NULL ) {

        HANDLE hIO;

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
        ATQ_ASSERT( !pContext->IsAcceptExRootContext());
        ATQ_ASSERT( !TsIsWindows95() );  // NYI

        hIO =
          (HANDLE ) InterlockedExchangePointer((PVOID *) &pContext->hAsyncIO,
                                               NULL);

        if ( (hIO == NULL) || !CloseHandle( hIO ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqCloseFileHandle] Warning- CloseHandle failed, "
                        " Context = %08x, error %d, handle = %x\n",
                        pContext,
                        GetLastError(),
                        hIO ));
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseFileHandle()





VOID
AtqFreeContext(
    PATQ_CONTEXT patqContext,
    BOOL         fReuseContext
    )
/*++

Routine Description:

    Frees the context created in AtqAddAsyncHandle.
    Call this after the async handle has been closed and all outstanding
    IO operations have been completed. The context is invalid after this call.
    Call AtqFreeContext() for same context only ONCE.

Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

--*/
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqFreeContext( %08x (handle=%08x,"
                     " nIOs = %d), fReuse=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO,
                     fReuseContext));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

#if 1
        //
        // !! DS change
        //
        //

        //
        //  If the socket is an AcceptEx socket, redo the AcceptEx and put
        //  it back on the in use list
        //

        PATQ_ENDPOINT pEndpoint = pContext->pEndpoint;

        //
        // If we have plenty of outstanding sockets (the number requested),
        // don't re-use this one.
        //

        if (pEndpoint != NULL) {
            if ( pEndpoint->nSocketsAvail >
                (LONG )(pEndpoint->nAcceptExOutstanding) ) {

                fReuseContext= FALSE;
            }
        }
#endif

        if ( fReuseContext ) {
            pContext->SetFlag( ACF_REUSE_CONTEXT);
        } else {
            pContext->ResetFlag( ACF_REUSE_CONTEXT);
        }

        if ( InterlockedDecrement(  &pContext->m_nIO) == 0) {

            //
            // The number of outstanding ref holders is ZERO.
            // Free up this ATQ context.
            //
            // We really do not free up the context - but try to reuse
            //  it if possible
            //

            DBG_ASSERT( pContext->lSyncTimeout == 0);
            AtqpReuseOrFreeContext( pContext, fReuseContext);
        }
    }

    return;
} // AtqFreeContext()



BOOL
AtqReadFile(
        IN PATQ_CONTEXT patqContext,
        IN LPVOID       lpBuffer,
        IN DWORD        BytesToRead,
        IN OVERLAPPED * lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async read using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    fRes = ( ReadFile( pContext->hAsyncIO,
                      lpBuffer,
                      BytesToRead,
                      &cbRead,
                      lpo ) ||
            GetLastError() == ERROR_IO_PENDING);

    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadFile()



BOOL
AtqReadSocket(
        IN PATQ_CONTEXT  patqContext,
        IN LPWSABUF     pwsaBuffers,
        IN DWORD        dwBufferCount,
        IN OVERLAPPED *  lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async recv using the handle defined in the context
     as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqReadSocket(%08lx) called.\n", pContext));
    }

    if (pContext->IsFlag( ACF_RECV_ISSUED)) {
        IF_DEBUG( SPUD ) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqReadSocket -> WSARecv bypassed.\n"));
        }
        pContext->BytesSent = 0;
        pContext->SetFlag( ACF_RECV_CALLED);
        return TRUE;
    }

    I_SetNextTimeout(pContext);


    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    DWORD  lpFlags = 0;

    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        return WSAENOTSOCK;
    }

    fRes = ( (WSARecv( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbRead,
                       &lpFlags,  // no flags
                       lpo,
                       NULL       // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadSocket()



BOOL
AtqWriteFile(
    IN PATQ_CONTEXT patqContext,
    IN LPCVOID      lpBuffer,
    IN DWORD        BytesToWrite,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to write
    BytesToWrite - number of bytes to write
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( !TsIsWindows95() );  // NYI
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);
    pContext->BytesSent = BytesToWrite;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    fRes = ( WriteFile( pContext->hAsyncIO,
                        lpBuffer,
                        BytesToWrite,
                        &cbWritten,
                        lpo ) ||
             GetLastError() == ERROR_IO_PENDING);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqWriteFile()



BOOL
AtqWriteSocket(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf < (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( lpo == NULL ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        return WSAENOTSOCK;
    }

    fRes = ( (WSASend( (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       &cbWritten,
                       0,               // no flags
                       lpo,
                       NULL             // no completion routine
                       ) == 0) ||
             (WSAGetLastError() == WSA_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqWriteSocket()




BOOL
AtqSyncWsaSend(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    )
/*++

  Routine Description:

    Does a sync write of an array of wsa buffers using WSASend.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    pcbWritten - ptr to count of bytes written

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{

    BOOL fRes = FALSE;
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    InterlockedIncrement( &pContext->m_nIO );
    //
    // See if the connection has already been closed.
    //
    if (pContext->hAsyncIO == NULL) {
        InterlockedDecrement( &pContext->m_nIO );
        return WSAENOTSOCK;
    }

    fRes = ( WSASend(  (SOCKET ) pContext->hAsyncIO,
                       pwsaBuffers,
                       dwBufferCount,
                       pcbWritten,
                       0,               // no flags
                       NULL,            // lpo == NULL for sync write
                       NULL             // no completion routine
                       ) == 0);

    InterlockedDecrement( &pContext->m_nIO );

    return fRes;

} // AtqSyncWsaSend()




BOOL
AtqTransmitFile(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
#if 0
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    InterlockedIncrement( &pContext->m_nIO);

    fRes = (TransmitFile( (SOCKET ) pContext->hAsyncIO,
                           hFile,
                           dwBytesInFile,
                           0,
                           &pContext->Overlapped,
                           lpTransmitBuffers,
                           dwFlags ) ||
            (GetLastError() == ERROR_IO_PENDING));
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;
#else
    DBG_ASSERT(FALSE);
    return FALSE;
#endif
} // AtqTransmitFile()


BOOL
AtqReadDirChanges(IN PATQ_CONTEXT patqContext,
                  IN LPVOID       lpBuffer,
                  IN DWORD        BytesToRead,
                  IN BOOL         fWatchSubDir,
                  IN DWORD        dwNotifyFilter,
                  IN OVERLAPPED * lpo
                  )
/*++
  AtqReadDirChanges()

  Description:
    This function submits an Async ReadDirectoryChanges() call for
    the Async handle in the ATQ context supplied.
    It always requires a non-NULL overlapped pointer for processing
    this call.

  Arguments:
    patqContext  - pointer to ATQ Context
    lpBuffer     - buffer for the data to be read from ReadDirectoryChanges()
    BytesToRead  - count of bytes to read into buffer
    fWatchSubDir - should we watch for sub directory changes
    dwNotifyFilter - DWORD containing the flags for Notification
    lpo          - pointer to overlapped structure.

  Returns:
    TRUE if ReadDirectoryChanges() is successfully submitted.
    FALSE if there is any failure in submitting IO.
--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

#if 0
    if ( lpo == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);
    fRes = ReadDirectoryChangesW( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          fWatchSubDir,
                          dwNotifyFilter,
                          &cbRead,
                          lpo,
                          NULL);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
#else
    return FALSE;
#endif
} // AtqReadDirChanges()



BOOL
AtqPostCompletionStatus(
        IN PATQ_CONTEXT patqContext,
        IN DWORD        BytesTransferred
        )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{
    BOOL fRes;
    PATQ_CONT  pAtqContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    ATQ_ASSERT( (pAtqContext)->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !pAtqContext->IsBlocked()) {

        InterlockedIncrement( &pAtqContext->m_nIO);

        fRes = ( PostQueuedCompletionStatus( g_hCompPort,
                                          BytesTransferred,
                                          (DWORD_PTR) patqContext,
                                          &pAtqContext->Overlapped ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pAtqContext->m_nIO); };
    } else {

        //
        // Forcibly remove the context from blocking list.
        //

        fRes = pBandwidthInfo->RemoveFromBlockedList(pAtqContext);

        // There is a possibility of race conditions!
        //  If we cant remove an item from blocking list before
        //         its IO operation is scheduled.
        // there wont be any call back generated for this case!
    }

    return fRes;

} // AtqPostCompletionStatus



DWORD
I_AtqGetGlobalConfiguration(VOID)
/*++
Description:
   This function sets several global config params for the ATQ package.
   It also reads the global configuration from registry for ATQ.
   The values if present will override the defaults

Returns:
   Win32 Errorcode - NO_ERROR on success and anything else for error
--*/
{
    DWORD       dwError = NO_ERROR;
    DWORD       dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT;

    //
    // If this is a NTW, do the right thing
    //

    MEMORYSTATUS ms;

    //
    // get the memory size
    //

    ms.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus( &ms );

    //
    // attempt to use driver
    //

    g_fUseDriver = FALSE;

    //
    // Alloc two threads per MB of memory.
    //

    g_cMaxThreadLimit = (LONG)(ms.dwTotalPhys >> 19) + 2;

    if ( g_cMaxThreadLimit < ATQ_REG_MIN_POOL_THREAD_LIMIT ) {
        g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;
    } else if ( g_cMaxThreadLimit > ATQ_REG_MAX_POOL_THREAD_LIMIT ) {
        g_cMaxThreadLimit = ATQ_REG_MAX_POOL_THREAD_LIMIT;
    }

    AtqSetInfo( AtqMaxConcurrency, ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);
    AtqSetInfo( AtqUseAcceptEx, TRUE );
    AtqSetInfo( AtqMaxPoolThreads, ATQ_REG_DEF_ATQ_THREADS);
    AtqSetInfo( AtqThreadTimeout, ATQ_REG_DEF_THREAD_TIMEOUT);

    return ( dwError);
} // I_AtqGetGlobalConfiguration()



DWORD
I_NumAtqEndpointsOpen(VOID)
/*++
  Description:
    This function counts the number of Enpoints that remain open.

  Arguments:
     None

  Returns:
     DWORD containing the number of endpoints that are open.
--*/
{
    DWORD nEPOpen = 0;
    AcquireLock( &AtqEndpointLock);

    PLIST_ENTRY plEP;
    for( plEP  = AtqEndpointList.Flink;
         plEP != &AtqEndpointList;
         plEP  = plEP->Flink ) {

        nEPOpen++;
    } // for

    ReleaseLock( &AtqEndpointLock);
    return ( nEPOpen);
} // I_NumAtqEndpointsOpen()


#define WINSOCK_INIT_WAIT_TIME      (25 * 1000)  // 25 seconds
#define WINSOCK_INIT_WAIT_RETRIES   4



BOOL
WaitForWinsockToInitialize(
    VOID
    )
/*++

Routine Description:

    Spin until winsock comes up.

Arguments:

    None.

Return Value:

    TRUE if winsock is up. FALSE, if something bad happened.

--*/
{
    INT             err;
    WSADATA         wsaData;
    SOCKET          s = INVALID_SOCKET;
    SOCKADDR_IN     sockAddr;
    INT             retryCount = WINSOCK_INIT_WAIT_RETRIES;
    BOOL            fRet      = FALSE;
    BOOL            fTCP      = FALSE;
    BOOL            fSignaled = TRUE;
    BOOL            fAddr     = FALSE;
    DWORD           dwErr;
    DWORD           dwBytes;
    DWORD           cbMaxDGramSend;
    OVERLAPPED      Overlapped;
    HANDLE          hConfig = NULL;
    
    err = WSAStartup(MAKEWORD(2,0), &wsaData);
    if ( err != 0 ) {
        ATQ_PRINTF((DBG_CONTEXT,"err %d in WSAStartup\n", err));
        return FALSE;
    }
    
    Overlapped.hEvent = CreateEvent(NULL,   // default SD
                                    FALSE,  // auto reset the event
                                    FALSE,  // initialize as non signaled
                                    NULL);  // no name

    if (NULL == Overlapped.hEvent) {
        goto cleanup;
    }
    
    s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
    if (INVALID_SOCKET != s) {
        
        fTCP = TRUE;
    
    } else {
        
        // TCP is not installed or setup.  Wait a reasonable amount of time for it
        // to be setup and then bail.

        // Get the initial handle so we will be sure and not miss it when/if
        // tcp is installed.  We don't need an overlapped structure for the 
        // first call since it will complete emediately.
        if (WSAProviderConfigChange(&hConfig, NULL, NULL)) {
            ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize WSAProviderConfigChange returned 0x%x\n", WSAGetLastError()));
            goto cleanup;
        }
        
        s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
        if (INVALID_SOCKET != s) {

            fTCP = TRUE;
        }
        
        while (retryCount && !fTCP) {
                
            if (fSignaled) {
                err = WSAProviderConfigChange(&hConfig,
                                              &Overlapped, 
                                              NULL);

                if (err && (WSA_IO_PENDING != WSAGetLastError())) {
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize ConfigChange failed with 0x%x\n", WSAGetLastError()));
                    goto cleanup;
                }
            }

            ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for socket . . .\n"));
            dwErr = WaitForSingleObject(Overlapped.hEvent, WINSOCK_INIT_WAIT_TIME);
            switch (dwErr) {
            default:
                // Something went pretty wrong here.
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize Failed at WaitForSingleObject with 0x%x\n", GetLastError()));
                goto cleanup;
            case WAIT_OBJECT_0:
                //
                // See if we have TCP now.
                //
                fSignaled = TRUE;
                s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, NULL, WSA_FLAG_OVERLAPPED);
                if (INVALID_SOCKET != s) {
                    //
                    // This will cause us to exit the retry loop
                    //
                    fTCP = TRUE;
                }
                break;
            case WAIT_TIMEOUT:
                // try again.  The event wasn't signaled so don't bother
                // calling WSAProviderConfigChange again.
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for TCP timed out.\n"));
                fSignaled = FALSE;
                break;
            }
            retryCount--;
        }
    }

    if (fTCP) {
        ATQ_ASSERT(TRUE == fSignaled);

        retryCount = WINSOCK_INIT_WAIT_RETRIES;
        
        // init sockAddr
        ZeroMemory(&sockAddr, sizeof(sockAddr));
        sockAddr.sin_family = AF_INET;
        sockAddr.sin_port = 0;
        sockAddr.sin_addr.s_addr = INADDR_ANY;

        err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
        if ( err != SOCKET_ERROR ) {

            fAddr = TRUE;
        
        } else {

            err = WSAIoctl(s,                                      
                           SIO_ADDRESS_LIST_CHANGE,
                           NULL,                // no input buffer
                           0,                   // size of input buffer
                           NULL,                // don't need an ouput buffer either
                           0,                   // size of out buffer
                           &dwBytes,            // bytes returned
                           &Overlapped,         // overlapped structure
                           NULL);               // no callback routine

            if (err && (WSAGetLastError() != WSA_IO_PENDING)) {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize Failed at WSAIoctl with 0x%x\n", WSAGetLastError()));
                goto cleanup;
            }

            err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
            if ( err != SOCKET_ERROR ) {

                fAddr = TRUE;

            }

            while (retryCount && !fAddr) {

                ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize waiting for address . . .\n"));
                dwErr = WaitForSingleObject(Overlapped.hEvent, WINSOCK_INIT_WAIT_TIME);
                switch (dwErr) {
                default:
                    // Something went pretty wrong here.
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize Failed at WaitForSingleObject with 0x%x\n", GetLastError()));
                    goto cleanup;
                case WAIT_OBJECT_0:
                    //
                    // Register for address change notification again so that
                    // nothing is missed in case there still aren't any TCP
                    // addresses.
                    //
                    err = WSAIoctl(s,                                      
                                   SIO_ADDRESS_LIST_CHANGE,
                                   NULL,                // no input buffer
                                   0,                   // size of input buffer
                                   NULL,                // don't need an ouput buffer either
                                   0,                   // size of out buffer
                                   &dwBytes,            // bytes returned
                                   &Overlapped,         // overlapped structure
                                   NULL);               // no callback routine

                    if (err && (WSA_IO_PENDING != WSAGetLastError())) {
                        ATQ_PRINTF(( DBG_CONTEXT, "WaitWinsockToInitialize Failed at WSAIoctl with 0x%x\n", WSAGetLastError()));
                        goto cleanup;
                    }

                    //
                    // See if we have an address to bind to now.
                    //
                    err = bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr));
                    if (SOCKET_ERROR != err) {
                        //
                        // This will cause us to exit the retry loop
                        //
                        fAddr = TRUE;
                    }
                    break;
                case WAIT_TIMEOUT:
                    // try again.  The event wasn't signaled so don't bother
                    // calling WSAIoctl again.
                    ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize waiting for addr's timed out.\n"));
                    break;
                }
                retryCount--;

            }     // while
        } // if err != SOCKET_ERROR
    } // if fTCP

    if (fTCP && fAddr) {
        SOCKET s2;
        INT    size = sizeof(cbMaxDGramSend);

        //
        // Set the return value as TRUE
        //
        fRet = TRUE;
        

        // record the largest possible datagram send.
        s2 = WSASocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, NULL, NULL, 0);
        if ( s == INVALID_SOCKET) {

            err = WSAGetLastError();
            ATQ_PRINTF(( DBG_CONTEXT, "WSASocket failed with %d.\n", err));
        } else {
        
            err = getsockopt(s,
                             SOL_SOCKET,
                             SO_MAX_MSG_SIZE,
                             (PCHAR)&cbMaxDGramSend,
                             &size);

            if ( err == 0 ) {
                g_cbMaxDGramSend = cbMaxDGramSend;
                ATQ_PRINTF(( DBG_CONTEXT, "Setting g_cbMaxDGramSend to 0x%x\n", g_cbMaxDGramSend));
            } else {
                ATQ_PRINTF(( DBG_CONTEXT, "Cannot query max datagram size [err %d]\n",
                        WSAGetLastError()));
            }
            closesocket(s2);
        }
    }

cleanup:

    if (NULL != hConfig) {
        CloseHandle(hConfig);
    }
    
    if (INVALID_SOCKET != s) {
        closesocket(s);
    }

    if (NULL != Overlapped.hEvent) {
        CloseHandle(Overlapped.hEvent);
    }
        
    if (!fRet) {
        WSACleanup();
    }

    IF_DEBUG(ERROR) {
        if (!fRet) {
            if (!fTCP) {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize there's no sockets.\n"));
            } else {
                ATQ_PRINTF(( DBG_CONTEXT, "WaitForWinsockToInitialize there's no ip addresses.\n"));
            }
        }
    }
    return fRet;
} // WaitForWinsockToInitialize
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\abw.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      abw2.cxx

   Abstract:
      This module implements functions required for bandwidth throttling
       of network usage by ATQ module.

   Author:

       Murali R. Krishnan    ( MuraliK )     1-June-1995
       Bilal Alam            ( t-bilala )    7-March-1997

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Asynchronous Thread Queue DLL

--*/

#include "isatq.hxx"

//
// Global variables
//

extern PBANDWIDTH_INFO       g_pBandwidthInfo;

//
// Bandwidth Info shared variables
//

CRITICAL_SECTION        BANDWIDTH_INFO::sm_csSharedLock;
LIST_ENTRY              BANDWIDTH_INFO::sm_BornListHead;
LIST_ENTRY              BANDWIDTH_INFO::sm_ActiveListHead;
DWORD                   BANDWIDTH_INFO::sm_cBornList;
DWORD                   BANDWIDTH_INFO::sm_cActiveList;
ALLOC_CACHE_HANDLER*    BANDWIDTH_INFO::sm_pachBWInfos;
BOOL                    BANDWIDTH_INFO::sm_fGlobalEnabled;
BOOL                    BANDWIDTH_INFO::sm_fGlobalActive;
DWORD                   BANDWIDTH_INFO::sm_cNonInfinite;
DWORD                   BANDWIDTH_INFO::sm_cSamplesForTimeout;

//
// BANDWIDTH_INFO methods
//

VOID
BANDWIDTH_INFO::Initialize(
    IN BOOL             fPersistent
)
/*++
  Initialize bandwidth info object.  This is a pseudo-constructor for the
  class.

  Arguments:
    fPersistent - TRUE if this object is destroyed explicitly
                  FALSE if destroyed when refcount hits 0

  Returns:
    None

--*/
{
    _fMemberOfActiveList        = FALSE;
    _bandwidth.dwSpecifiedLevel = INFINITE;
    _bandwidth.dwLowThreshold   = INFINITE;
    _bandwidth.dwHighThreshold  = INFINITE;
    _cMaxBlockedList            = INFINITE;
    _fEnabled                   = FALSE;
    _Signature                  = ATQ_BW_INFO_SIGNATURE;
    _fIsFreed                   = FALSE;
    _fPersistent                = fPersistent;
    _cReference                 = 1;

    InitializeCriticalSection( &_csPrivateLock );
    SET_CRITICAL_SECTION_SPIN_COUNT( &_csPrivateLock,
                                     IIS_DEFAULT_CS_SPIN_COUNT);
    InitializeListHead( &_BlockedListHead );

    ZeroMemory( _rgBytesXfered, sizeof( _rgBytesXfered ) );

    _pBytesXferCur = _rgBytesXfered;  // points to start of array
    _cbXfered.QuadPart = 0;

    _pStatus = &sm_rgStatus[ ZoneLevelLow ][ 0 ];

    ClearStatistics();

    AddToBornList();

    SetDescription( "Default" );
}

VOID
BANDWIDTH_INFO::Terminate( VOID )
/*++
  Destroys bandwidth info object.  This is a pseudo-destructor.

  Arguments:
    None

  Returns:
    None

--*/
{
    Lock();

    // first prevent any new requests from getting blocked

    InterlockedExchangePointer((PVOID *) &_pStatus,
                               &sm_rgStatus[ZoneLevelLow][0] );

    // disable the descriptor

    InterlockedExchange( (LPLONG) &_fEnabled, FALSE );

    // now remove any blocked requests

    ATQ_REQUIRE( CheckAndUnblockRequests() );
    ATQ_ASSERT( _cCurrentBlockedRequests == 0 );
    ATQ_ASSERT( IsListEmpty( &_BlockedListHead ) );

    Unlock();

    DeleteCriticalSection( &_csPrivateLock );

    // remove self from shared bandwidth info list

    SharedLock();

    RemoveFromBornList();

    SharedUnlock();

    _Signature = ATQ_BW_INFO_SIGNATURE_FREE;
}

BOOL
BANDWIDTH_INFO::PrepareToFree( VOID )
{
    InterlockedExchange( (LPLONG) &_fIsFreed, TRUE );
    Dereference();
    return TRUE;
}

BOOL
BANDWIDTH_INFO::BlockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Block this request on the queue of requests waiting to be processed.

  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                  to be blocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{
    BOOL            fRet = TRUE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( IsValidAtqOp( pAtqContext->arInfo.atqOp ) );

    Lock();

    if ( _cCurrentBlockedRequests == _cMaxBlockedList )
    {
        fRet = FALSE;
    }
    else
    {
        pAtqContext->SetFlag( ACF_BLOCKED );

        InsertTailList( &_BlockedListHead, &pAtqContext->BlockedListEntry );

        IncCurrentBlockedRequests();
    }

    Unlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::RemoveFromBlockedList(
    IN PATQ_CONT            pAtqContext
)
/*++
  This function forcibly removes an ATQ context from blocked list of requests.

  Argument:
   pAtqContext    pointer to ATQ context whose request is in blocked list.

  Returns:
   TRUE on success and FALSE if there is any error.
--*/
{
    if ( !pAtqContext->IsBlocked() ) {

        // some other thread just removed this request from waiting list.
        return TRUE;
    }

    Lock();

    RemoveEntryList(&pAtqContext->BlockedListEntry);

    DecCurrentBlockedRequests();

    pAtqContext->ResetFlag( ACF_BLOCKED);

    Unlock();

    //
    // On such a forcible removal, we may have to make a callback indicating
    //   failure. Ignored!  To be done by the caller of this API.
    //

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UnblockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Unblocks this request from the queue of requests waiting to be processed.
  Call this function only when
       _pStatus[pAtqContext->atqOp] != StatusBlockOperation.
  First, this function removes the request from queue of requests and processes
   it according to status and operation to be performed.
  If the status is AllowRequest ==> this function restarts the operation.
  If the status is reject operation ==> rejects operation and invokes
                        call back function indicating the error status.

  Call this function after lock()ing


  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                     to be unblocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{

    DBG_ASSERT(FALSE);
    return FALSE;
#if 0
    BOOL fRet = FALSE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );

    // Remove the request from the blocked list entry
    RemoveEntryList( &pAtqContext->BlockedListEntry);
    DecCurrentBlockedRequests();
    pAtqContext->ResetFlag( ACF_BLOCKED );

    // Check and re enable the operation of pAtqContext

    switch ( _pStatus[ pAtqContext->arInfo.atqOp ] ) {

      case StatusAllowOperation:

        IncTotalAllowedRequests();
        switch ( pAtqContext->arInfo.atqOp) {

          case AtqIoRead:
            {
                DWORD cbRead;  // Discard after calling ReadFile()
                DWORD dwFlags = 0;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSARecv( (SOCKET ) pAtqContext->hAsyncIO,
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbRead,
                                   &dwFlags,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSARecv( (SOCKET ) pAtqContext->hAsyncIO,
                                       &wsaBuf,
                                       1,
                                       &cbRead,
                                       &dwFlags,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoWrite:
            {
                DWORD cbWrite;  // Discard after calling WriteFile()

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSASend( (SOCKET ) pAtqContext->hAsyncIO,
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbWrite,
                                   0,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSASend( (SOCKET ) pAtqContext->hAsyncIO,
                                       &wsaBuf,
                                       1,
                                       &cbWrite,
                                       0,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoXmitFile:
            {
                fRet = TransmitFile( (SOCKET ) pAtqContext->hAsyncIO,
                                     pAtqContext->arInfo.uop.opXmit.hFile,
                                     pAtqContext->arInfo.uop.opXmit.
                                         dwBytesInFile,
                                     0,
                                     pAtqContext->arInfo.lpOverlapped,
                                     pAtqContext->arInfo.uop.
                                           opXmit.lpXmitBuffers,
                                     pAtqContext->arInfo.uop.
                                           opXmit.dwFlags );

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING) ) {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoXmitFileRecv:
            {
                DWORD cbRead;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 pAtqContext->arInfo.uop.opXmitRecv.pBufAll,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBufferCount
                                );
                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opXmitRecv.pBufAll);
                    pAtqContext->arInfo.uop.opXmitRecv.pBufAll = NULL;
                }
                else
                {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opXmitRecv.buf1.len,
                      pAtqContext->arInfo.uop.opXmitRecv.buf1.buf
                    };
                    fRet = I_AtqTransmitFileAndRecv
                               ( (PATQ_CONTEXT) pAtqContext,
                                 pAtqContext->arInfo.uop.opXmitRecv.hFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwBytesInFile,
                                 pAtqContext->arInfo.uop.opXmitRecv.lpXmitBuffers,
                                 pAtqContext->arInfo.uop.opXmitRecv.dwTFFlags,
                                 &wsaBuf,
                                 1 );
                }

                if ( !fRet && GetLastError() == ERROR_IO_PENDING )
                {
                    fRet = TRUE;
                }
                break;
            }

          case AtqIoSendRecv:
            {
                WSABUF wsaSendBuf =
                { pAtqContext->arInfo.uop.opSendRecv.sendbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.sendbuf1.buf
                };

                WSABUF wsaRecvBuf =
                {
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.len,
                  pAtqContext->arInfo.uop.opSendRecv.recvbuf1.buf
                };

                LPWSABUF     pSendBuf = &wsaSendBuf;
                LPWSABUF     pRecvBuf = &wsaRecvBuf;

                if ( pAtqContext->arInfo.uop.opSendRecv.dwSendBufferCount > 1 )
                {
                    pSendBuf = pAtqContext->arInfo.uop.opSendRecv.pSendBufAll;
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.dwRecvBufferCount > 1 )
                {
                    pRecvBuf = pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll;
                }

                ATQ_ASSERT( pSendBuf != NULL );
                ATQ_ASSERT( pRecvBuf != NULL );

                fRet = I_AtqSendAndRecv
                                    ( (PATQ_CONTEXT) pAtqContext,
                                      pSendBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwSendBufferCount,
                                      pRecvBuf,
                                      pAtqContext->arInfo.uop.opSendRecv.
                                        dwRecvBufferCount );

                if ( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( pAtqContext->arInfo.uop.opSendRecv.pRecvBufAll != NULL )
                {
                    ::LocalFree( pAtqContext->arInfo.uop.opSendRecv.pSendBufAll );
                }

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING ) ) {
                    fRet = TRUE;
                }

                break;
            }

          default:
            ATQ_ASSERT( FALSE);
            break;
        } // switch

        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since operation done.
        break;

      case StatusRejectOperation:

        IncTotalRejectedRequests();
        if ( ((pAtqContext->arInfo.atqOp == AtqIoRead) ||
             (pAtqContext->arInfo.atqOp == AtqIoRead)) &&
             (pAtqContext->arInfo.uop.opReadWrite.pBufAll != NULL)
             ) {
            ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
            pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
        }
        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since op rejected.
        SetLastError( ERROR_NETWORK_BUSY);
        fRet = FALSE;
        break;

      case StatusBlockOperation:
        // do nothing. we cannot unblock
        ATQ_ASSERT(FALSE);
        return (TRUE);

      default:
        ATQ_ASSERT( FALSE);
        break;
    } // switch

    if (!fRet) {

        // Call the completion function to signify the error in operation.

        //
        //  Reset the timeout value so requests don't
        //  timeout multiple times
        //

        InterlockedExchange(
                    (LPLONG ) &pAtqContext->NextTimeout,
                    ATQ_INFINITE
                    );

        InterlockedDecrement( &pAtqContext->m_nIO);

        pAtqContext->IOCompletion( 0,
                                   GetLastError(),
                                   pAtqContext->arInfo.lpOverlapped );
    } // on failure.

    return (fRet);
#endif
}

BOOL
BANDWIDTH_INFO::CheckAndUnblockRequests( VOID )
/*++
  Checks the list of blocked requests and identifies all operations
  that needs to be unblocked. This function unblocks those requests and
  removes them from blocked list.

  Always call this function after lock()ing

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    BOOL fRet = TRUE;

    //
    //  If the list is not empty, then check and process blocked requests.
    //

    if ( !IsListEmpty( &_BlockedListHead ) ) {

        PLIST_ENTRY pentry;

        //
        //  Scan the blocked requests list looking for pending requests
        //   that needs to be unblocked and unblock these requests.
        //

        for (pentry  = _BlockedListHead.Flink;
             pentry != &_BlockedListHead;
             pentry  = pentry->Flink )
          {
              PATQ_CONT pContext = CONTAINING_RECORD(pentry,
                                                     ATQ_CONTEXT,
                                                     BlockedListEntry );

              if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE)
                {
                    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                    fRet = FALSE;
                    break;
                }

              if ( !pContext->IsBlocked()) {

                  // This should not happen.
                  ATQ_ASSERT( !pContext->IsBlocked());
                  fRet = FALSE;
                  continue;
              }

              //
              //  Check to see if the status for operation has changed.
              //  If so, unblock the request.
              //

              if ( _pStatus[pContext->arInfo.atqOp] !=
                  StatusBlockOperation) {

                  fRet &= UnblockRequest( pContext );
              }

          } // scan list
    }

    return (fRet);
}

BOOL
BANDWIDTH_INFO::UpdateBandwidth(
    VOID
)
/*++
  This function updates the current bandwidth value using the histogram
   of bytes transferred.
  The histogram maintains a history of bytes transferred over different sample
   periods of a single minute. Each entry in the histogram corresponds to one
   interval of sample. The sum of all entries gives the total bytes transferred
   in a single minute. We divide this measure by 60 to obtain the count of
   bytes transferred over a second. This update bandwidth is used to
   reevalute the tuner of bandwidth throttle based on our throttling policy
   (specified in throttling algorithm). The updated action information is
   used by subsequent requests.
  In addition the _pcbXfered pointer is advanced forward using the
   histogram entries as a circular buffer, to obtain the count of bytes
   for next interval.

  Arguments:
    pdwPrivateBw - Filled with bandwidth for this descriptor

  Returns:
    TRUE on success. FALSE otherwise.

  Note:
   It is recommended that this function be called as infrequently as
    possible, using reasonable sample intervals.

--*/
{
    BOOL fRet = TRUE;
    ZoneLevel zonelevel;

    Lock();

    // accumulate current byte count to global counter, to minimize computation
    _cbXfered.QuadPart = _cbXfered.QuadPart + _pBytesXferCur->QuadPart;

    //
    // Current n/ws support a max of 1 to 100 MB/s. We can represent
    //  4GB/s in a DWORD. Hence the cast is used. This may need revision later.
    // Better yet, later we should store bandwidth as KB/seconds.
    //
    _dwMeasuredBw = (DWORD ) (_cbXfered.QuadPart/ATQ_AVERAGING_PERIOD);

    CIRCULAR_INCREMENT( _pBytesXferCur, _rgBytesXfered, ATQ_HISTOGRAM_SIZE);
    // Adjust the global cumulative bytes sent after increment.
    _cbXfered .QuadPart = _cbXfered.QuadPart - _pBytesXferCur->QuadPart;
    // Reset the counter to start with the new counter value.
    _pBytesXferCur->QuadPart = 0;

    //
    // update the operation status depending upon the bandwidth comparisons.
    // we use band/zone calculations to split the result into 3 zones.
    // Depending upon the zone we update the global status pointer to
    //   appropriate row.
    //

    if ( _dwMeasuredBw < ATQ_LOW_BAND_THRESHOLD(_bandwidth)) {

        //
        // Lower zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelLow;

    } else if ( _dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD(_bandwidth)) {

        //
        // Higher zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelHigh;

    } else {

        zonelevel = ZoneLevelMedium;
    }

    /*++
      Above calculation can be implemented as:
      zonelevel = (( sm_dwMeasuredBw > ATQ_LOW_BAND_THRESHOLD( sm_bandwidth)) +
                   ( sm_dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD( sm_bandwidth)));

      This is based on implicit dependence of ordering of ZoneLevel entries.
      So avoided for present now.
    --*/

    if ( _pStatus != &sm_rgStatus[zonelevel][0]) {

        // Status needs to be changed.
        _pStatus = &sm_rgStatus[zonelevel][0];

        // Examine and reenable blocked operations if any.
        fRet &= CheckAndUnblockRequests();
    }

    // remove the bandwidth info object from the list if it is
    // "inactive" (bandwidth = 0)

    if ( !_dwMeasuredBw )
    {
        // there should be no requests in the blocked queue!

        ATQ_ASSERT( _cCurrentBlockedRequests == 0 );

        RemoveFromActiveList();
    }

    Unlock();

    return fRet;
}

DWORD
BANDWIDTH_INFO::SetBandwidthLevel(
    IN DWORD                    Data
)
/*++
   Sets the bandwidth threshold

   Arguments:
      Data - Bandwidth threshold

   Returns:
      Old bandwidth threshold (DWORD)
--*/
{
    DWORD dwOldVal;
    INT iListDelta = 0;

    Lock();

    dwOldVal = _bandwidth.dwSpecifiedLevel;

    if ( Data != INFINITE) {

        DWORD dwTemp;

        _bandwidth.dwSpecifiedLevel  = ATQ_ROUNDUP_BANDWIDTH( Data );
        dwTemp = ( Data *9)/10;               //low threshold = 0.9*specified
        _bandwidth.dwLowThreshold    = ATQ_ROUNDUP_BANDWIDTH( dwTemp);
        dwTemp = ( Data *11)/10;              //high threshold= 1.1*specified
        _bandwidth.dwHighThreshold   = ATQ_ROUNDUP_BANDWIDTH( dwTemp);

        _fEnabled = TRUE;
        // we should recheck the throttling and blocked requests
        // Will be done when the next timeout occurs in the ATQ Timeout Thread

        if ( dwOldVal == INFINITE )
        {
            iListDelta = 1;
        }

    } else {

        _bandwidth.dwSpecifiedLevel = INFINITE;
        _bandwidth.dwLowThreshold   = INFINITE;
        _bandwidth.dwHighThreshold  = INFINITE;

        _fEnabled = FALSE;

        // enable all operations, since we are in low zone
        _pStatus = &sm_rgStatus[ZoneLevelLow][0];

        // we should recheck and enable all blocked requests.
        if ( _cCurrentBlockedRequests > 0) {
            ATQ_REQUIRE( CheckAndUnblockRequests());
        }

        if ( dwOldVal != INFINITE )
        {
            iListDelta = -1;
        }
    }

    Unlock();

    // update the static counter of how many non-infinite throttles we have

    if ( iListDelta )
    {
        SharedLock();

        if ( iListDelta > 0 )
        {
            sm_cNonInfinite++;
        }
        else
        {
            sm_cNonInfinite--;
        }
        sm_fGlobalEnabled = !!sm_cNonInfinite;

        SharedUnlock();
    }

    return dwOldVal;

}

DWORD
BANDWIDTH_INFO::SetMaxBlockedListSize(
    IN DWORD                    cMaxSize
)
/*++
   Sets the maximum size of blocked request list

   Arguments:
      cMaxSize - maximum size of list

   Returns:
      Old max size (DWORD)
--*/
{
    DWORD           cOldMax;

    Lock();

    cOldMax = _cMaxBlockedList;
    _cMaxBlockedList = cMaxSize;

    Unlock();

    return cOldMax;
}

DWORD
BANDWIDTH_INFO::QueryBandwidthLevel( VOID )
/*++
   Retrieve the current bandwidth level

   Arguments:
      None

   Returns:
      Set Bandwidth level (DWORD)
--*/
{
    DWORD dwBw;

    Lock();

    dwBw = _bandwidth.dwSpecifiedLevel;

    Unlock();

    return dwBw;
}

BOOL
BANDWIDTH_INFO::ClearStatistics( VOID )
{
    Lock();

    _cTotalAllowedRequests = 0;
    _cTotalBlockedRequests = 0;
    _cTotalRejectedRequests = 0;

    Unlock();

    return TRUE;
}

BOOL
BANDWIDTH_INFO::GetStatistics( OUT ATQ_STATISTICS * pAtqStats )
{
    ATQ_ASSERT( pAtqStats != NULL );

    pAtqStats->cRejectedRequests = _cTotalRejectedRequests;
    pAtqStats->cBlockedRequests = _cTotalBlockedRequests;
    pAtqStats->cAllowedRequests = _cTotalAllowedRequests;
    pAtqStats->cCurrentBlockedRequests = _cCurrentBlockedRequests;
    pAtqStats->MeasuredBandwidth = _dwMeasuredBw;

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UpdateAllBandwidths( VOID )
{
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = TRUE;
    DWORD                   dwCounter = 0;

    SharedLock();

    for ( pEntry = sm_ActiveListHead.Flink;
          pEntry != &sm_ActiveListHead; )
    {
        BANDWIDTH_INFO *pBandwidthInfo = CONTAINING_RECORD( pEntry,
                                                            BANDWIDTH_INFO,
                                                            _ActiveListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        // we might be deleting this entry from the list.  Grab the next
        // link now before we do so the traversal can happen smoothly

        pEntry = pEntry->Flink;

        if ( !pBandwidthInfo->Enabled() )
        {
            continue;
        }

        if ( !pBandwidthInfo->UpdateBandwidth() )
        {
            fRet = FALSE;
            break;
        }

        ATQ_PRINTF(( DBG_CONTEXT, "pBWInfo =  %p (%s), Bandwidth = %u, Threshold = %d\n",
                     pBandwidthInfo,
                     pBandwidthInfo->_achDescription,
                     pBandwidthInfo->QueryMeasuredBw(),
                     pBandwidthInfo->QueryBandwidthLevel() ) );
    }

    SharedUnlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::AbwInitialize( VOID )
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 10, sizeof(BANDWIDTH_INFO)};

    ATQ_ASSERT( sm_pachBWInfos == NULL );

    sm_pachBWInfos = new ALLOC_CACHE_HANDLER( "BandwidthInfos",
                                              &acConfig );

    if ( sm_pachBWInfos == NULL )
    {
        return FALSE;
    }

    InitializeListHead( &sm_ActiveListHead );
    InitializeListHead( &sm_BornListHead );
    InitializeCriticalSection( &sm_csSharedLock );

    sm_cActiveList          = 0;
    sm_cBornList            = 0;
    sm_fGlobalEnabled       = FALSE;
    sm_fGlobalActive        = FALSE;
    sm_cNonInfinite         = 0;
    sm_cSamplesForTimeout   = 1;

    g_pBandwidthInfo = new BANDWIDTH_INFO( TRUE );

    if ( !g_pBandwidthInfo )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
BANDWIDTH_INFO::AbwTerminate( VOID )
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    ATQ_PRINTF(( DBG_CONTEXT,
                 "AbwTerminate() called.  Born List Size = %d\n",
                 sm_cBornList ));

    SharedLock();

    while( !IsListEmpty( &sm_BornListHead ) )
    {
        pBandwidthInfo = CONTAINING_RECORD( sm_BornListHead.Flink,
                                            BANDWIDTH_INFO,
                                            _BornListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        delete pBandwidthInfo;
    }

    ATQ_ASSERT( sm_cBornList == 0 );
    ATQ_ASSERT( sm_cActiveList == 0 );
    ATQ_ASSERT( IsListEmpty( &sm_BornListHead ) );
    ATQ_ASSERT( IsListEmpty( &sm_ActiveListHead ) );

    SharedUnlock();

    DeleteCriticalSection( &sm_csSharedLock );

    if ( sm_pachBWInfos != NULL )
    {
        delete sm_pachBWInfos;
        sm_pachBWInfos = NULL;
    }

    return TRUE;
}


PVOID
AtqCreateBandwidthInfo( VOID )
/*++

Routine Description:

    Allocate a bandwidth throttling descriptor

Arguments:

    none

Return Value:

    If successful, pointer to allocated descriptor.  Otherwise NULL.

--*/
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    pBandwidthInfo = new BANDWIDTH_INFO( FALSE );
    if ( pBandwidthInfo == NULL )
    {
        return NULL;
    }
    else
    {
        ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
        return pBandwidthInfo;
    }
}


BOOL
AtqFreeBandwidthInfo(
    IN PVOID        pvBandwidthInfo
)
/*++

Routine Description:

    Free bandwidth throttling descriptor

Arguments:

    pBandwidthInfo - Descriptor to destroy

Return Value:

    TRUE If successful, else FALSE.

--*/
{
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    return pBandwidthInfo->PrepareToFree();
}


DWORD_PTR
AtqBandwidthSetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      IN DWORD_PTR             Data
)
/*++

Routine Description:

    Set member of bandwidth descriptor

Arguments:

    pBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    Data - Data to set to

Return Value:

    Previous value of descriptor

--*/
{
    DWORD_PTR       dwOldVal = 0;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            dwOldVal = pBandwidthInfo->QueryBandwidthLevel();
            pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
            break;
        case ATQ_BW_MAX_BLOCKED:
            dwOldVal = pBandwidthInfo->QueryMaxBlockedSize();
            pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
            break;
        case ATQ_BW_DESCRIPTION:
            dwOldVal = Data;
            pBandwidthInfo->SetDescription( (CHAR*) Data );
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }

    return dwOldVal;
}


BOOL
AtqBandwidthGetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      OUT DWORD_PTR *          pdwData
)
/*++

Routine Description:

    Get member of bandwidth descriptor

Arguments:

    pvBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    pdwData - Output here

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL            fRet = TRUE;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
    ATQ_ASSERT( pdwData );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE &&
         pdwData )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            *pdwData = pBandwidthInfo->QueryBandwidthLevel();
            break;
        case ATQ_BW_MAX_BLOCKED:
            *pdwData = pBandwidthInfo->QueryMaxBlockedSize();
            break;
        case ATQ_BW_STATISTICS:
            fRet = pBandwidthInfo->GetStatistics( (ATQ_STATISTICS*) pdwData );
            break;
        case ATQ_BW_DESCRIPTION:
            *pdwData = (DWORD_PTR) pBandwidthInfo->QueryDescription();
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            fRet = FALSE;
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

#define DEBUG_SIO                   0x10000000
#define DEBUG_TIMEOUT               0x20000000
#define DEBUG_ENDPOINT              0x40000000
#define DEBUG_SPUD                  0x80000000

# define DEBUG_ALLOC_CACHE          0x01000000

// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\atqsupp.cxx ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

       atqsupp.cxx

   Abstract:

        Contains internal support routines for the ATQ package
        From atqnew.c

   Author:
        Murali R. Krishnan     (MuraliK)     02-Apr-1996

   Project:
        Internet Server Common DLL
--*/

#include "isatq.hxx"

typedef GUID UUID;

extern "C" {

#include <ntdsa.h>

}

DWORD AtqPoolThread( LPDWORD param );

VOID I_AtqThreadMonitor( IN PVOID NotUsed );

DWORD g_dwThreadMonitorCookie = 0;

extern PBANDWIDTH_INFO g_pBandwidthInfo;

# ifdef ENABLE_REUSE_THROTTLE

DWORD g_fAlwaysReuseSockets = TRUE;

# endif // ENABLE_REUSE_THROTTLE

//
// If this is true then no AtqPoolThreads have completed
// servicing an IO since the last time I_AtqThreadMonitor
// ran.
//
BOOL  g_fDeadManSwitch = FALSE;


/************************************************************
 * Functions for ATQ_CONTEXT
 ************************************************************/


PATQ_CONT
I_AtqAllocContextFromCache( VOID);

VOID
I_AtqFreeContextToCache(
            IN PATQ_CONT pAtqContext,
            IN BOOL UnlinkContext
            );
VOID
I_ResetListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    );



PATQ_CONT
I_AtqAllocContextFromCache( VOID)
/*++
  This function attempts to allocate an ATQ context from the allocation cache.
  It then initializes the state information in the ATQ context object and
    returns the context on success.

  Arguments:
    None

  Returns:
    On success a valid pointer to ATQ_CONT. Otherwise NULL.

--*/
{
    PATQ_CONT  pAtqContext;

    DBG_ASSERT( NULL != g_pachAtqContexts);

    pAtqContext = (ATQ_CONTEXT * ) g_pachAtqContexts->Alloc();

    if ( NULL != pAtqContext ) {


        pAtqContext->ContextList =
            &AtqActiveContextList[(++AtqGlobalContextCount %
                                   g_dwNumContextLists)];

        pAtqContext->Signature = ATQ_CONTEXT_SIGNATURE;
    }

    return (pAtqContext);
} // I_AtqAllocContextFromCache()




VOID
I_AtqFreeContextToCache(
        IN PATQ_CONT pAtqContext
        )
/*++
  This function releases the given context to the allocation cache.

  Arguments:
    pAtqContext  pointer to the ATQ_CONTEXT that is being freed.

  Returns:
    None

  Issues:
    This function also performs some other cleanup specific to AtqContexts.
--*/
{

#if 0
      ATQ_PRINTF(( DBG_CONTEXT,
                 "[I_AtqFreeCtxtToCache] Freed up %08x\n",
                 pAtqContext
                 ));
#endif

    DBG_ASSERT( pAtqContext->Signature == ATQ_FREE_CONTEXT_SIGNATURE);
    DBG_ASSERT( pAtqContext->lSyncTimeout ==0);
    DBG_ASSERT( pAtqContext->m_nIO ==0);
    DBG_ASSERT( pAtqContext->m_acFlags == 0);
    DBG_ASSERT( pAtqContext->m_acState == 0);
    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);
    DBG_ASSERT( pAtqContext->pvBuff == NULL);
    DBG_ASSERT( pAtqContext->pEndpoint == NULL);
    DBG_ASSERT( pAtqContext->hAsyncIO == NULL);

    DBG_REQUIRE( g_pachAtqContexts->Free( pAtqContext));

    return;

} // I_AtqFreeContextToCache



void
ATQ_CONTEXT::Print( void) const
{
    DBGPRINTF(( DBG_CONTEXT,
                " ATQ_CONTEXT (%08x)\n"
                "\thAsyncIO            = %08lx   Signature        = %08lx\n"
                "\tOverlapped.Internal = %08lx   Overlapped.Offset= %08lx\n"
                "\tm_leTimeout.Flink   = %08lx   m_leTimeout.Blink= %08lx\n"
                "\tClientContext       = %08lx   ContextList      = %08lx\n"
                "\tpfnCompletion       = %08lx ()\n"
                "\tpEndPoint           = %08lx   fAcceptExContext = %s\n"
                "\tlSyncTimeout        = %8d     fInTimeout       = %s\n"

                "\tTimeOut             = %08lx   NextTimeout      = %08lx\n"
                "\tBytesSent           = %d (0x%08lx)\n"

                "\tpvBuff              = %08lx   JraAsyncIo       = %08lx\n"
                "\tfConnectionIndicated= %s      fBlocked         = %8lx\n"

                "\tState               = %8lx    Flags            = %8lx\n",
                this,
                hAsyncIO,
                Signature,
                Overlapped.Internal,
                Overlapped.Offset,
                m_leTimeout.Flink,
                m_leTimeout.Blink,
                ClientContext,
                ContextList,
                pfnCompletion,
                pEndpoint,
                (IsAcceptExRootContext() ? "TRUE" : "FALSE"),
                lSyncTimeout,
                (IsFlag( ACF_IN_TIMEOUT) ? "TRUE" : "FALSE"),
                TimeOut,
                NextTimeout,
                BytesSent,
                BytesSent,
                pvBuff,
                hJraAsyncIO,
                (IsFlag( ACF_CONN_INDICATED) ? "TRUE" : "FALSE"),
                IsBlocked(),
                m_acState, m_acFlags
                ));

    // Print the buffer if necessary.

    return;
} // ATQ_CONTEXT::Print()




VOID
ATQ_CONTEXT::HardCloseSocket( VOID)
/*++
  Description:
     This socket closes the socket by forcibly calling closesocket() on
     the socket. This function is used during the endpoint shutdown
     stage for an atq context

  Arguments:
     None

  Returns:
     None

--*/
{
    HANDLE haio = (HANDLE )
        InterlockedExchangePointer( (PVOID *) &hAsyncIO, NULL);

    DBG_ASSERT( IsState( ACS_SOCK_LISTENING) ||
                IsState( ACS_SOCK_CONNECTED) ||
                IsState( ACS_SOCK_CLOSED) ||
                IsState( ACS_SOCK_UNCONNECTED)
                );

    MoveState( ACS_SOCK_CLOSED);


    //
    //  Let us do a hard close on the socket (handle).
    //  This should generate an IO completion which will free this
    //     ATQ context
    //

    if ( !this->fDatagramContext ) {
        if ( (haio != NULL) &&
             (closesocket((SOCKET) haio) == SOCKET_ERROR)
             ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "Warning - "
                         " Context=%08x closesocket failed,"
                         " error %d, socket = %x\n",
                         this,
                         GetLastError(),
                         haio ));
            Print();
        }
    }

    return;
} // ATQ_CONTEXT::HardCloseSocket()



VOID
ATQ_CONTEXT::InitWithDefaults(
    IN ATQ_COMPLETION pfnCompletion,
    IN DWORD TimeOut,
    IN HANDLE hAsyncIO
    )
{
    DBG_ASSERT( this->Signature == ATQ_CONTEXT_SIGNATURE);

    this->InitTimeoutListEntry();

    this->Signature    = ATQ_CONTEXT_SIGNATURE;

     // start life at 1. This ref count will be freed up by AtqFreeContext()
    this->m_nIO = 1;

    this->pfnCompletion   = pfnCompletion;

    this->TimeOut         = TimeOut;
    this->TimeOutScanID   = 0;
    this->lSyncTimeout    = 0;

    this->hAsyncIO        = hAsyncIO;
    this->hJraAsyncIO     = HandleToUlong(hAsyncIO) | 0x80000000;

    this->m_acState       = 0;
    this->m_acFlags       = 0;

    this->fDatagramContext  = FALSE;

    // Initialize pbandwidthinfo to point to global object

    this->m_pBandwidthInfo  = g_pBandwidthInfo;

    ZeroMemory(
               &this->Overlapped,
               sizeof( this->Overlapped )
               );

    DBG_ASSERT( this->lSyncTimeout == 0);

    //
    // Following added for bandwidth throttling purposes
    //

    DBG_ASSERT( !this->IsBlocked());
    this->arInfo.atqOp    = AtqIoNone;
    this->arInfo.lpOverlapped = NULL;
    // bandwidth throttling initialization ends here.

} // ATQ_CONTEXT::InitWithDefaults()




VOID
ATQ_CONTEXT::InitNonAcceptExState(
    IN PVOID pClientContext
    )
{
    //
    //  Note that if we're not using AcceptEx, then we consider the client
    //  to have been notified externally (thus ACF_CONN_INDICATED is set).
    //  Also we set the next timeout to be infinite, which may be reset
    //   when the next IO is submitted.
    //

    this->NextTimeout          = ATQ_INFINITE;
    this->ClientContext        = pClientContext;
    this->pEndpoint            = NULL;
    this->SetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_CONNECTED);
    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT);

    //
    // Insert this into the active list - since this is a non-acceptex socket
    //

    DBG_ASSERT( this->ContextList != NULL);
    this->ContextList->InsertIntoActiveList( &this->m_leTimeout );

    return;

} // ATQ_CONTEXT::InitNonAcceptExState()



VOID
ATQ_CONTEXT::InitAcceptExState(
            IN DWORD NextTimeOut
            )
{
    this->NextTimeout          = NextTimeOut;
    this->ClientContext        = NULL;
    this->lSyncTimeout         = 0;

    this->ResetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_LISTENING);

    //
    //  Add it to the pending accept ex list
    //
    DBG_ASSERT( this->ContextList != NULL);

    this->ContextList->InsertIntoPendingList( &this->m_leTimeout);

    return;
} // ATQ_CONTEXT::InitAcceptExState()



BOOL
ATQ_CONTEXT::PrepareAcceptExContext(
    PATQ_ENDPOINT          pEndpoint
    )
/*++

Routine Description:

    Initializes the state for completely initializing the state and
    hence prepares the context for AcceptEx

    It expects the caller to send a AtqContext with certain characteristics
      1) this is not NULL
      2) this->pvBuff has valid values

    In the case of failure, caller should call
     pAtqContext->CleanupAndRelese() to free the memory associated with
     this object.

Arguments:

    pEndpoint     - pointer to endpoint object for this context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

    The caller should free the object on a failure.

--*/
{
    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases
    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( this != NULL);
    DBG_ASSERT( this->pvBuff != NULL);

    //
    //  Make sure that we are adding a AcceptEx() version of AtqContext
    //

    DBG_ASSERT( pEndpoint->ConnectExCompletion != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    //  Fill out the context.  We set NextTimeout to INFINITE
    //  so the timeout thread will ignore this entry until an IO
    //  request is made unless this is an AcceptEx socket, that means
    //  we're about to submit the IO.
    //

    this->
        InitWithDefaults(
                         pEndpoint->IoCompletion,
                         pEndpoint->AcceptExTimeout, // canonical Timeout
                         this->hAsyncIO
                         );


    //
    // TBD: What is the circumstance in which this->pEndpoint!= NULL?
    //

    if ( this->pEndpoint == NULL ) {
        pEndpoint->Reference();
        this->pEndpoint  = pEndpoint;
    }

    this->InitDatagramState( );

    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

    this->InitAcceptExState( AtqGetCurrentTick() + TimeOut);

    DBG_ASSERT( this->pvBuff != NULL);

    return (TRUE);

} // ATQ_CONTEXT::PrepareAcceptExContext()




VOID
ATQ_CONTEXT::CleanupAndRelease( VOID)
/*++
  Routine Description:
     This function does the cleanup of the ATQ context. It does not
     attempt to do any reuse of the atq context. After cleanup
     the context is freed to the ATQ pool. Supplied context
     is not valid after calling this function.

  Arguments:
     None

  Returns:
     None
--*/
{
    DBG_ASSERT( this->m_nIO == 0);

    //
    //  Cleanup and free the ATQ Context entirely
    //

    if ( this->hAsyncIO != NULL ) {

        // It is too dangerous to assume that the handle is a socket!
        // But we will do that for fast-pathing IIS operations.

        SOCKET hIO =
            (SOCKET ) InterlockedExchangePointer( (PVOID *) &this->hAsyncIO,
                                                  NULL);
        //
        // no cleanups for datagram
        //

        if ( !this->fDatagramContext ) {

            if ( hIO != NULL &&
                 (closesocket( hIO ) == SOCKET_ERROR ) ) {

                ATQ_PRINTF(( DBG_CONTEXT,
                             "ATQ_CONTEXT(%08x)::CleanupAndRelease() : Warning"
                             " - Context=%08x, "
                             " closesocket failed, error %d, socket = %x\n",
                             this,
                             GetLastError(),
                             hIO ));
                this->Print();
            }
        }
    }

    DBG_ASSERT( this->hAsyncIO == NULL);

    if ( this->pvBuff != NULL ) {
        LocalFree( this->pvBuff );
        this->pvBuff = NULL;
    }

    //
    // Unlink from the list
    //

    DBG_ASSERT( this->ContextList != NULL);

    // NYI: Can I avoid this comparison?
    //
    // Check if this context is part of a timeout list.
    // If it is then remove it from the list
    // Only during shutdown code path, we will see trouble here.
    //
    if ( this->m_leTimeout.Flink != NULL ) {
        this->ContextList->RemoveFromList( &this->m_leTimeout);
    }

    //
    //  Deref the listen info if this context is associated with one
    //

    if ( this->pEndpoint != NULL ) {
        this->pEndpoint->Dereference();
        this->pEndpoint = NULL;
    }

    this->Signature    = ATQ_FREE_CONTEXT_SIGNATURE;
    this->lSyncTimeout = 0;
    this->m_acState    = 0;
    this->m_acFlags    = 0;

    I_AtqFreeContextToCache( this);

    return;
} // ATQ_CONTEXT::CleanupAndRelease()





inline VOID
DBG_PRINT_ATQ_SPUDCONTEXT( IN PATQ_CONT  pAtqContext,
                           IN PSPUD_REQ_CONTEXT reqContext)
{
    ATQ_PRINTF(( DBG_CONTEXT,
                 "[AtqPoolThread] pAtqContext = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus1.Information = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Status = %08lx\n"
                 "[AtqPoolThread] IoStatus2.Information = %08lx\n"
                 ,
                 pAtqContext,
                 reqContext->IoStatus1.Status,
                 reqContext->IoStatus1.Information,
                 reqContext->IoStatus2.Status,
                 reqContext->IoStatus2.Information
                 ));
    return;
} // DBG_PRINT_ATQ_SPUDCONTEXT()


VOID
AtqpUpdateBandwidth( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten)
{
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    DBG_ASSERT( pBandwidthInfo != NULL );
    DBG_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    // add the bandwidth info to active list if necessary

    pBandwidthInfo->AddToActiveList();

    //this will have problems when we use XmitFile for large files.

    pBandwidthInfo->UpdateBytesXfered( pAtqContext, cbWritten );
} // AtqpUpdateBandwidth()


VOID
AtqpCallOplockCompletion( IN PATQ_CONT pAtqContext,
                          IN DWORD cbWritten)
{
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion;
    PVOID OplockContext;
    POPLOCK_INFO pOplock;

    IF_DEBUG( SPUD) {
        DBGPRINTF(( DBG_CONTEXT,
                    "CallOplockCompletion on OpLockInfo=%08x.cbWritten = %d\n",
                    (POPLOCK_INFO ) pAtqContext, cbWritten));
    }

    //
    // The ATQ context object received is a fake one. We actually get
    //  back POPLOCK_INFO object that is used to extract the callback
    //  function & context for the callback
    //

    pOplock = (POPLOCK_INFO)pAtqContext;
    pfnOplockCompletion = (ATQ_OPLOCK_COMPLETION)pOplock->pfnOplockCompletion;
    OplockContext = (PVOID)pOplock->Context;

    LocalFree(pOplock);


    (*pfnOplockCompletion)(OplockContext, (DWORD)cbWritten);
    return;

} // AtqpCallOplockCompletion()



VOID
AtqpProcessContext( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten,
                    IN LPOVERLAPPED lpo,
                    IN BOOL       fRet)
{
    BOOL fDriverCall = FALSE;
    BOOL fRecvCalled = FALSE;
    PSPUD_REQ_CONTEXT  reqContext = NULL;
    DWORD dwError;

    DBG_ASSERT( pAtqContext != NULL);

    //
    // Check to see if this is a completion request from the
    // NTS kernel driver.
    //

    if ( lpo == NULL ) {

        if ( cbWritten == 0xffffffff ) {

            //
            // One of the SPUD's IO completion. Handle it appropriately.
            //

            reqContext = (PSPUD_REQ_CONTEXT)pAtqContext;

            pAtqContext = CONTAINING_RECORD( reqContext, ATQ_CONTEXT,
                                             spudContext );

            IF_DEBUG( SPUD) {
                DBG_PRINT_ATQ_SPUDCONTEXT( pAtqContext, reqContext);
            }
#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xfcfcfcfc indicates a SPUD I/O Completion
            //

            pAtqContext->NotifyIOCompletion( cbWritten, reqContext->IoStatus1.Status, 0xfcfcfcfc );
#endif

            cbWritten = (DWORD)reqContext->IoStatus1.Information;
            fRet = (reqContext->IoStatus1.Status == STATUS_SUCCESS);
            SetLastError(RtlNtStatusToDosError(reqContext->IoStatus1.Status));

            lpo = &pAtqContext->Overlapped;

            //
            // If the TransmitFile fails then the receive is not issued.
            //

            if ( fRet ) {
                fDriverCall = TRUE;
            } else {
                DBG_ASSERT( fDriverCall == FALSE);
                pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            }
        } else {

            //
            // An Oplock notification - handle it via oplock path.
            //

            AtqpCallOplockCompletion( pAtqContext, cbWritten);
            return;
        }
    }

    dwError = (fRet) ? NO_ERROR: GetLastError();

    //
    //  If this is an AcceptEx listen socket atq completion, then the
    //  client Atq context we really want is keyed from the overlapped
    //  structure that is stored in the client's Atq context.
    //

    if ( pAtqContext->IsAcceptExRootContext() || pAtqContext->fDatagramContext ) {

        pAtqContext = CONTAINING_RECORD( lpo, ATQ_CONTEXT, Overlapped );

    }


#if CC_REF_TRACKING
    //
    // ATQ notification trace
    //
    // Notify client context of all non-oplock notification.
    // This is for debugging purpose only.
    //

    pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfefefefe );
#endif

    DBG_CODE(
             if ( ATQ_CONTEXT_SIGNATURE != pAtqContext->Signature) {
                 pAtqContext->Print();
                 DBG_ASSERT( FALSE);
             });


    //
    //  m_nIO also acts as the reference count for the atq contexts
    //  So, increment the count now, so that there is no other thread
    //   that will free up this ATQ context accidentally.
    //

    InterlockedIncrement( &pAtqContext->m_nIO);

    //
    // Busy wait for timeout processing to complete!
    //  This is ugly :( A fix in time for IIS 2.0/Catapult 1.0 release
    //

    InterlockedIncrement(  &pAtqContext->lSyncTimeout);
    while ( pAtqContext->IsFlag( ACF_IN_TIMEOUT)) {

        AcIncrement( CacAtqWaitsForTimeout);

        Sleep( ATQ_WAIT_FOR_TIMEOUT_PROCESSING);
    };

    //
    //  We need to make sure the timeout thread doesn't time this
    //  request out so reset the timeout value
    //

    InterlockedExchange( (LPLONG )&pAtqContext->NextTimeout,
                         (LONG ) ATQ_INFINITE);

    //
    // Update Bandwidth information on successful completion, if needed
    //

    if ( BANDWIDTH_INFO::GlobalEnabled() && fRet && cbWritten > 0)
    {
        AtqpUpdateBandwidth( pAtqContext, cbWritten);
    }

    //
    // Since the IO completion means that one of the async operation finished
    //  decrement our internal ref count appropriately to balance the addition
    //  when the IO operation was submitted.
    //
    InterlockedDecrement( &pAtqContext->m_nIO);

    //
    //  Is this a connection indication?
    //

    if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) &&
         !pAtqContext->fDatagramContext ) {

        PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

        if ( NULL == pEndpoint) {
            pAtqContext->Print();
            OutputDebugString( "Found an ATQ context with bad Endpoint\n");
            DBG_ASSERT( FALSE);
            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);
            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count
            return;
        }

        DBG_ASSERT( pEndpoint != NULL );

        //
        //  Indicate this socket is in use
        //

        InterlockedDecrement( &pEndpoint->nSocketsAvail );

        //
        //  If we're running low on sockets, add some more now
        //

        if ( pEndpoint->nSocketsAvail <
             (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

            AcIncrement( CacAtqPrepareContexts);

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                );
        }

        //
        //  If an error occurred on this completion,
        //    shutdown the socket
        //

        if ( !fRet ) {

            IF_DEBUG( ERROR) {
                if ( dwError != ERROR_OPERATION_ABORTED ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 " Free Context(%08x, EP=%08x) to cache. "
                                 "Err=%d, sock=%08x\n",
                                 pAtqContext, pEndpoint,
                                 dwError,
                                 pAtqContext->hAsyncIO));
                }
            }

            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);

            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count

            // balance original count
            InterlockedDecrement( &pAtqContext->m_nIO);
            // Free up the atq context without Reuse
            pAtqContext->CleanupAndRelease();
            return;
        }

        //
        //  Shutdown may close the socket from underneath us so don't
        //  assert, just warn.
        //

        if ( !pAtqContext->IsState( ACS_SOCK_LISTENING) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] Warning-Socket state not listening\n"
                         ));
            DBG_CODE( pAtqContext->Print());
        }

        pAtqContext->MoveState( ACS_SOCK_CONNECTED);

        //
        // Remove the context from the pending list and put
        // it on the active list
        //

        DBG_ASSERT( pAtqContext->ContextList != NULL);
        pAtqContext->ContextList->MoveToActiveList( &pAtqContext->m_leTimeout);

        //
        //  Set the connection indicated flag.  After we return from
        //  the connection completion routine we assume it's
        //  safe to call the IO completion routine
        //  (or the connection indication routine should do cleanup
        //  and never issue an IO request).  This is primarily for
        //  the timeout thread.
        //

        pAtqContext->ConnectionCompletion( cbWritten, lpo);
    } else {


        //
        //  Not a connection completion indication. I/O completion.
        //

        //
        //  If an error occurred on a TransmitFile (or other IO),
        //  set the state to connected so the socket will get
        //  closed on cleanup
        //

        if ( !fRet &&
             pAtqContext->IsState( ACS_SOCK_UNCONNECTED)
             ){
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

#if 0
        if (fDriverCall) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] pfnCompletion1(%08lx)\n",
                         pAtqContext ));
        }
#endif

        //
        // !!! DS
        // Indicate that we have completed a datagram context
        //

        if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) ) {

            PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

            pAtqContext->SetFlag( ACF_CONN_INDICATED);
            if ( pEndpoint != NULL ) {

                ATQ_ASSERT(pAtqContext->fDatagramContext);

                //
                // Decrement the in-use count here for
                //

                InterlockedDecrement( &pEndpoint->nSocketsAvail );

                //
                //  If we're running low on sockets, add some more now
                //

                if ( pEndpoint->nSocketsAvail <
                     (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

                    (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                        pEndpoint->nAcceptExOutstanding
                                                        );
                }
            }
        }

        pAtqContext->IOCompletion( cbWritten, dwError, lpo);

        if (fDriverCall) {
            pAtqContext->ResetFlag( ACF_RECV_ISSUED);
            fRet = (reqContext->IoStatus2.Status == STATUS_SUCCESS);
            SetLastError( RtlNtStatusToDosError(
                                         reqContext->IoStatus2.Status));

            //
            //  If an error occurred on a TransmitFile (or other IO),
            //  set the state to connected so the socket will get
            //  closed on cleanup
            //

            if ( !fRet &&
                 pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
                pAtqContext->MoveState( ACS_SOCK_CONNECTED);
            }

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of status after 1st notification
            // This is for debugging purpose only.
            //
            // Code 0xfafafafa means we're processing a recv that
            // SPUD combined with another notification
            //

            pAtqContext->NotifyIOCompletion( pAtqContext->m_acFlags, reqContext->IoStatus1.Status, 0xfafafafa );
#endif
            if ( pAtqContext->IsFlag( ACF_RECV_CALLED ) ) {
                fRecvCalled = TRUE;
                pAtqContext->ResetFlag( ACF_RECV_CALLED);
            }

            if ((reqContext->IoStatus1.Status == STATUS_SUCCESS) &&
                (pAtqContext->ClientContext != NULL) &&
                fRecvCalled ) {

#if CC_REF_TRACKING
                //
                // ATQ notification trace
                //
                // Notify client context of all non-oplock notification.
                // This is for debugging purpose only.
                //
                // Code 0xfdfdfdfd means we're processing a recv that
                // SPUD combined with another notification
                //

                pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfdfdfdfd );
#endif


                IF_DEBUG( SPUD) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqPoolThread] pfnCompletion2(%08lx)\n",
                                 pAtqContext ));
                };

                pAtqContext->IOCompletion( (DWORD)reqContext->IoStatus2.Information,
                                        (fRet) ? NO_ERROR : GetLastError(),
                                        lpo
                                        );
            }
        }
    }

    DBG_ASSERT( pAtqContext->lSyncTimeout > 0);
    InterlockedDecrement( &pAtqContext->lSyncTimeout);

    //
    // We do an interlocked decrement on m_nIO to sync up state
    //  so that the context is not prematurely deleted.
    //

    if ( InterlockedDecrement(  &pAtqContext->m_nIO) == 0) {

        //
        // The number of outstanding ref holders is ZERO.
        // Free up this ATQ context.
        //
        // We really do not free up the context - but try to reuse
        //  it if possible
        //

        // free the atq context now or reuse if possible.
        AtqpReuseOrFreeContext( pAtqContext,
                                (pAtqContext->
                                 IsFlag( ACF_REUSE_CONTEXT) != 0)
                                );
    }

    return;
} // AtqpProcessContext()



DWORD
AtqPoolThread(
    LPDWORD ThreadType
    )
/*++

Routine Description:

    This is the pool thread wait and dispatch routine

  Arguments:
    ThreadType : Indicates whether this is the initial pool thread, 
    a temp thread, or just a joe blow pool thread.

  Return Value:

    Thread return value (ignored)

--*/
{
    PATQ_CONT    pAtqContext;
    BOOL         fRet;
    LPOVERLAPPED lpo;
    DWORD        cbWritten;
    DWORD        returnValue = NO_ERROR;
    DWORD        availThreads;
    DWORD        dwIOsServiced;


    AtqUpdatePerfStats(ATQ_PERFCTR_WORKERTHREAD_CREATED, FLAG_COUNTER_INCREMENT, 1);
    AtqUpdatePerfStats(ATQ_PERFCTR_WORKERTHREAD_ALIVE, FLAG_COUNTER_INCREMENT, 1);

    for (;;) {

        pAtqContext = NULL;
        availThreads = InterlockedIncrement( &g_cAvailableThreads );

        // Report available (active) plus (inactive, not created yet) threads
        AtqUpdatePerfStats(ATQ_PERFCTR_WORKERTHREAD_AVAILABLE, FLAG_COUNTER_SET, 
                           availThreads + (g_cMaxThreads - g_cThreads));

        fRet = GetQueuedCompletionStatus( g_hCompPort,
                                          &cbWritten,
                                          (PDWORD_PTR)&pAtqContext,
                                          &lpo,
                                          g_msThreadTimeout );

        availThreads = InterlockedDecrement( &g_cAvailableThreads );

        AtqUpdatePerfStats(ATQ_PERFCTR_WORKERTHREAD_AVAILABLE, FLAG_COUNTER_SET, 
                           availThreads + (g_cMaxThreads - g_cThreads));
        
        if ( fRet || lpo ) {

            if ( pAtqContext == NULL) {
                if ( g_fShutdown ) {

                    //
                    // This is our signal to exit.
                    //

                    returnValue = NO_ERROR;
                    break;
                }

                OutputDebugString( "A null context received\n");
                continue;  // some error in the context has occured.
            }

            //
            // Make sure we're not running out of threads
            //

            if ( availThreads == 0 ) {

                //
                //  Make sure there are pool threads to service the request
                //

                (VOID)I_AtqCheckThreadStatus( NULL );
            }

            AtqpProcessContext( pAtqContext, cbWritten, lpo, fRet);

            // Clear the dead man switch
            g_fDeadManSwitch = FALSE;
        } else {

            //
            // don't kill the initial thread
            //

            if ( ((DWORD_PTR)ThreadType == ATQ_INITIAL_THREAD) && !g_fShutdown ) {
                continue;
            }

            //
            //  An error occurred.  Either the thread timed out, the handle
            //  is going away or something bad happened.  Let the thread exit.
            //

            returnValue = GetLastError();

            break;
        }

    } // for

    if ( NULL != g_pfnExitThreadCallback) {

        //
        //  Client wishes to be told when ATQ threads terminate.
        //

        g_pfnExitThreadCallback();
    }

    if ( InterlockedDecrement( &g_cThreads ) == 0 ) {

        //
        // Wake up ATQTerminate()
        //
        IF_DEBUG( ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqPoolThread() - setting shutdown event %08x."
                         " g_cThreads = %d\n",
                         g_hShutdownEvent, g_cThreads
                         ));
        }

        SetEvent( g_hShutdownEvent );
    }

    AtqUpdatePerfStats(ATQ_PERFCTR_WORKERTHREAD_ALIVE, FLAG_COUNTER_DECREMENT, 1);
    
    return returnValue;
} // AtqPoolThread




BOOL
I_AtqCheckThreadStatus(
    PVOID Context
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.  We're fast and loose so a couple of extra
    threads may be created.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL fRet = TRUE;

    //
    //  If no threads are available, kick a new one off up to the limit
    //
    //  WE NEED TO CHANGE THE CONDITIONS FOR STARTING ANOTHER THREAD
    //  IT SHOULD NOT BE VERY EASY TO START A THREAD ....
    //

    if ( (g_cAvailableThreads == 0) &&
         (g_cThreads < g_cMaxThreads) &&
         (g_cThreads < g_cMaxThreadLimit) ) {

        HANDLE hThread;
        DWORD  dwThreadID;

        InterlockedIncrement( &g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                Context,
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( &g_cThreads ) == 0) {
                ATQ_PRINTF(( DBG_CONTEXT,
                    "AtqCheckThread: Cannot create ATQ threads\n"));
                fRet = FALSE;
            }
        }
    }

    return fRet;
} // I_AtqCheckThreadStatus()



/************************************************************
 *  Functions to Add/Delete Atq Contexts
 ************************************************************/


BOOL
I_AtqAddAsyncHandle(
    IN OUT PATQ_CONT  *    ppAtqContext,
    IN PATQ_ENDPOINT       pEndpoint,
    PVOID                  ClientContext,
    ATQ_COMPLETION         pfnCompletion,
    DWORD                  TimeOut,
    HANDLE                 hAsyncIO
    )
/*++

  Description:
    This functio adds creates a new NON-AcceptEx() based Atq Context,
     and includes it in proper lists fo ATQ Context management.


  Note:
    The client should call this after the IO handle is openned
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

--*/
{
    BOOL         fReturn = TRUE;

    DBG_ASSERT( ppAtqContext != NULL);
    DBG_ASSERT( ClientContext != NULL);

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        PATQ_CONT    pAtqContext;

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();
        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.  We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.
        //


        pAtqContext->InitWithDefaults(pfnCompletion,
                                      CanonTimeout( TimeOut ), hAsyncIO);

        //
        //  These data members are used if we're doing AcceptEx processing
        //

        pAtqContext->SetAcceptExBuffer( NULL);

        pAtqContext->InitNonAcceptExState(ClientContext);

        //
        // If an endpoint is provided, reference it
        //

        if ( pEndpoint != NULL ) {
            pEndpoint->Reference();
            pAtqContext->pEndpoint = pEndpoint;
        }

        *ppAtqContext = pAtqContext;
    }

    return (TRUE);

} // I_AtqAddAsyncHandle()




BOOL
I_AtqAddListenEndpointToPort(
    IN OUT PATQ_CONT    * ppAtqContext,
    IN PATQ_ENDPOINT    pEndpoint
    )
/*++

  Description:
    This function creates a new AtqContext for the given ListenSocket.
    It uses the listen socket as the AcceptEx() socket too for adding
     the atq context to the completion port.
    It assumes
      TimeOut to be INFINITE, with no Endpoint structure.

  Arguments:
    ppAtqContext - pointer to location that will contain the atq context
                   on successful return.
    pEndpoint - pointer to the endpoint.

  Returns:
    TRUE on success
    FALSE if there is a failure.

  Note:
    The caller should free the *ppAtqContext if there is a failure.

--*/
{
    BOOL         fReturn = TRUE;
    PATQ_CONT    pAtqContext;

    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();

        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.
        //  We set the TimeOut for this object to be ATQ_INFINITE,
        //   since we do not want any interference from the Timeout loop.
        //

        pAtqContext->InitWithDefaults(
                                      pEndpoint->IoCompletion,
                                      ATQ_INFINITE,
                                      (HANDLE)pEndpoint->ListenSocket
                                      );

        //
        //  These data members are used if we're doing AcceptEx processing
        //


        pAtqContext->SetAcceptExBuffer( NULL);

        //
        // Among AcceptEx ATQ Contexts,
        //  only the listen ATQ context will have the Endpoint field as NULL
        //
        pAtqContext->pEndpoint       = NULL;
        pAtqContext->SetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

        //
        // We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.

        DBG_ASSERT( g_fUseAcceptEx && pEndpoint->ConnectExCompletion != NULL);

        pAtqContext->InitAcceptExState( ATQ_INFINITE);

        *ppAtqContext = pAtqContext;
    }

    fReturn = I_AddAtqContextToPort( pAtqContext);

    return (fReturn);

} // I_AtqAddListenEndpointToPort()



BOOL
I_AtqAddAcceptExSocket(
    IN PATQ_ENDPOINT          pEndpoint,
    IN PATQ_CONT              pAtqContext
    )
/*++

Routine Description:

    Adds the AtqContext to the AcceptEx() waiters list,
    after allocating a new socket, since pAtqContext->hAsyncIO = NULL.

Arguments:

    pEndpoint - Information about this listenning socket
    patqReusedContext - optional context to use

Return Value:

    TRUE on success, FALSE on failure.
    On failure the caller should free the pAtqContext

--*/
{
    BOOL   fAddToPort = FALSE;
    BOOL   fSuccess = TRUE;

    DBG_ASSERT( pAtqContext != NULL);
    DBG_ASSERT( pAtqContext->pvBuff != NULL);
    DBG_ASSERT( !TsIsWindows95() );

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        SetLastError( ERROR_NOT_READY );
        return ( FALSE);
    }

    //
    //  Use the supplied socket if any.
    //  Otherwise create a new socket
    //

    if ( pAtqContext->hAsyncIO == NULL) {

        HANDLE sAcceptSocket;

        sAcceptSocket = (HANDLE )
#if WINSOCK11
            socket(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP
                   );
#else
        WSASocketW(
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP,
                   NULL,  // protocol info
                   0,     // Group ID = 0 => no constraints
                   (g_fUseFakeCompletionPort ?
                    0:
                    WSA_FLAG_OVERLAPPED // completion port notifications
                    )
                   );
#endif // WINSOCK11

        if ( (SOCKET ) sAcceptSocket == INVALID_SOCKET ) {

            fSuccess = FALSE;
            sAcceptSocket = NULL;

            //
            // no need to unlink from any list, since we did not add it to any
            //

        } else {

            //
            // Setup the accept ex socket in the atq context.
            //

            pAtqContext->hAsyncIO = sAcceptSocket;
            pAtqContext->hJraAsyncIO  = HandleToUlong(sAcceptSocket) | 0x80000000;
            fAddToPort = TRUE;
            DBG_ASSERT( fSuccess);
        }
    }

    if ( fSuccess) {

        DWORD        cbRecvd;

        if ( g_fShutdown) {

            //
            // no need to unlink from any list, since we did not add it to any
            //

            SetLastError( ERROR_NOT_READY);
            return (FALSE);
        }

        DBG_ASSERT( pAtqContext->hAsyncIO != NULL);

        //
        // 1. Call I_AtqAddAsyncHandleEx() to establish the links with
        //  proper AcceptEx & AtqContext processing lists.
        //
        //  After 1, the atqcontext will be in the lists, so
        //    cleanup should remove the context from proper lists.
        //
        // 2. Add the socket to Completion Port (if new),
        //    i.e. if fAddToPort is true)
        //
        // 3. Submit the new socket to AcceptEx() so that it may be
        //  used for processing about the new connections.
        //

        // 1.
        DBG_ASSERT( pAtqContext->m_nIO == 0);
        DBG_REQUIRE( pAtqContext->PrepareAcceptExContext(pEndpoint));

        // increment outstanding async io operations before AcceptEx() call
        InterlockedIncrement( &pAtqContext->m_nIO);

        // 2.
        if ( fAddToPort ) {
            ATQ_ASSERT(!pAtqContext->fDatagramContext);
            fSuccess = I_AddAtqContextToPort( pAtqContext);
        }
        // 3.
        if (fSuccess) {
            if (!pEndpoint->fDatagram) {
                 fSuccess = AcceptEx(
                                (SOCKET ) pEndpoint->ListenSocket,
                                (SOCKET ) pAtqContext->hAsyncIO,
                                pAtqContext->pvBuff,
                                pEndpoint->InitialRecvSize,
                                MIN_SOCKADDR_SIZE,
                                MIN_SOCKADDR_SIZE,
                                &cbRecvd,
                                &pAtqContext->Overlapped );

                 if (!fSuccess) {
                     fSuccess = (GetLastError() == ERROR_IO_PENDING);
                 }

            } else {

                WSABUF Buffer;
                DWORD lpFlags;
                int RetCode = 0;
                DWORD retry=0;

                //
                // For datagram, do a WSARecvFrom instead of AcceptEx.
                // All the output parameters have to be in the context
                // structure
                //

                for (;;) {

                    lpFlags = 0;
                    Buffer.len = pEndpoint->InitialRecvSize;
                    Buffer.buf = (char *) pAtqContext->pvBuff;

                    RetCode = WSARecvFrom(
                            (SOCKET) pAtqContext->hAsyncIO,
                            &Buffer,
                            1,                          // buffer count
                            &cbRecvd,
                            &lpFlags,
                            (PSOCKADDR) pAtqContext->AddressInformation,
                            &pAtqContext->AddressLength,
                            &pAtqContext->Overlapped,
                            NULL
                            );

                    //
                    // If this is a conn reset, then retry until we
                    // don't get this error anymore.  It looks like we 
                    // get this everytime someone sends us something and
                    // then shuts down the socket before we can respond.
                    // The sockets layer seems to give us a max of 160 of 
                    // these at a time, but for now retry infinitely since
                    // we don't know what this 160 is based on.
                    // RRandall - 7/16/99
                    //

                    if ( (RetCode == 0) || (WSAGetLastError() != WSAECONNRESET) ) {
                        break;
                    }

                    ATQ_PRINTF((DBG_CONTEXT,"AtqRecvFrom[%x] reset error. Retrying[%d]\n",
                                pAtqContext, retry));
                    retry++;
                }

                if (RetCode != 0) {

                    fSuccess = (WSAGetLastError() == ERROR_IO_PENDING);
                }
            }
        }

        if ( fSuccess) {

            //
            //  We've successfully added this socket, increment the count
            //

            InterlockedIncrement( &pEndpoint->nSocketsAvail );

        } else {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqAddAcceptExSocket] Reusing an old context (%08x)"
                        " failed; error %d:%d, sAcceptSocket = %x, "
                        " pEndpoint = %lx, parm4 = %d, parm7 = %lx,"
                        " parm8 = %lx\n",
                        pAtqContext,
                        GetLastError(),
                        WSAGetLastError(),
                        pAtqContext->hAsyncIO,
                        pEndpoint,
                        pEndpoint->InitialRecvSize,
                        &cbRecvd,
                        &pAtqContext->Overlapped ));

            //
            // Unlink from the current list, where it was added as a result of
            //  step 1 above.
            //
            DBG_ASSERT( pAtqContext->ContextList != NULL);

            // balance the increment of the async operations outstanding
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) > 0);

            DBG_ASSERT( pAtqContext->m_leTimeout.Flink != NULL);
            pAtqContext->ContextList->
                RemoveFromList( &pAtqContext->m_leTimeout);

            //
            // balance the increment done
            // by pAtqContext->PrepareAcceptExContext()
            //
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) == 0);
            DBG_ASSERT( !fSuccess);

            //
            // the caller will free the Atq context on failure
            //
        }
    }

    return ( fSuccess);
} // I_AtqAddAcceptExSocket()




VOID
AtqpReuseContext( PATQ_CONT  pAtqContext)
/*++
  Description:
     This function attempts to reuse the ATQ context.
     It first cleans up the state and then uses the function
      I_AtqAddAccetpEx() socket to re-add the context to acceptex pool

  Arguments:
     pAtqContext - pointer to ATQ context that can be reused

  Returns:
     None
--*/
{
    PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    // Complete connection has been processed prior to coming here
    //

    DBG_ASSERT(pAtqContext->IsFlag( ACF_CONN_INDICATED));

    //
    // Remove from the current active list
    //
    if ( pAtqContext->m_leTimeout.Flink != NULL ) {
        pAtqContext->ContextList->RemoveFromList( &pAtqContext->m_leTimeout );
    }

    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);

    DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        //
        //  Either there is no socket or the socket must be in the
        //  unconnected state (meaning reused after TransmitFile)
        //


    DBG_ASSERT( !pAtqContext->hAsyncIO ||
                (  pAtqContext->hAsyncIO &&
                  (  pAtqContext->fDatagramContext ||
                     pAtqContext->IsState( ACS_SOCK_UNCONNECTED |
                                           ACS_SOCK_TOBE_FREED)
                  )
                )
              );

    //
    // !! DS
    //

    if ( pAtqContext->fDatagramContext ) {

        DBG_ASSERT(pEndpoint->fDatagram);
        pAtqContext->hAsyncIO = (HANDLE)pEndpoint->ListenSocket;
    }

    //
    // I need to make sure that the state information is cleaned up
    //  before re-adding the context to the list
    //

    if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

        //
        //  Failed to add the socket, free up the context without reuse
        //

        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqpReuseContext] for (%08x) failed with "
                     " Error = %d;  Now freeing the context ...\n",
                     pAtqContext, GetLastError()
                     ));

        DBG_ASSERT( pAtqContext->m_nIO == 0);

        // free without reuse
        pAtqContext->CleanupAndRelease();
    }

    return;
} // AtqpReuseContext()



VOID
AtqpReuseOrFreeContext(
    PATQ_CONT    pAtqContext,
    BOOL         fReuseContext
    )
/*++
  Routine Description:
     This function does a free-up of the ATQ contexts. During the free-up
     path, we also attempt to reuse the ATQ context if the fReuseContext is
     set.

  Arguments:
     pAtqContext - pointer to the ATQ context that needs to be freedup
     fReuseContext - BOOLEAN flag indicating if this context should be reused

  Returns:
     None
--*/
{
    //
    // Get this object out of the Blocked Requests List.
    //

    if ( pAtqContext->IsBlocked()) {
        ATQ_REQUIRE( pAtqContext->m_pBandwidthInfo
                      ->RemoveFromBlockedList( pAtqContext ));
        DBG_ASSERT( !pAtqContext->IsBlocked());
    }

    DBG_ASSERT( pAtqContext->m_pBandwidthInfo != NULL);
    pAtqContext->m_pBandwidthInfo->Dereference();

    //
    //  Conditions for Reuse:
    //   1) fReuseContext == TRUE => caller wants us to reuse context
    //   2) pAtqContext->pEndpoint != NULL => valid endpoint exists
    //   3)  pEndpoint->UseAcceptEx => AcceptEx is enabled
    //   4)  pEndpoint->nSocketsAvail < nAcceptExOutstanding * 2 =>
    //           We do not have lots of outstanding idle sockets
    //       Condition (4) ensures that we do not flood the system
    //         with too many AcceptEx sockets as a result of some spike.
    //       AcceptEx sockets once added to the pool are hard to
    //         remove, because of various timing problems.
    //       Hence we want to prevent arbitrarily adding AcceptEx sockets.
    //
    //    In condition (4) I use a fudge factor of "2", so that
    //     we do continue to prevent reuse of sockets prematurely.
    //

    if ( fReuseContext &&
         (pAtqContext->pEndpoint != NULL)  &&
         (pAtqContext->pEndpoint->UseAcceptEx)
#ifdef ENABLE_REUSE_THROTTLE
         //
         // Reuse Throttle causes trouble in bursty traffic mode
         // especially with benchmarks like SpecWeb96
         //
         &&
         ( g_fAlwaysReuseSockets ||
           ((DWORD )pAtqContext->pEndpoint->nSocketsAvail <
            pAtqContext->pEndpoint->nAcceptExOutstanding * 2)
           )
#endif // ENABLE_REUSE_THROTTLE
         ) {

        //
        // Call the function to reuse context. On failure
        // the AtqpReuseContext will free up the context
        //

        AcIncrement( CacAtqContextsReused);

        AtqpReuseContext( pAtqContext);

    } else {

        AcIncrement( CacAtqContextsCleanedup);

        pAtqContext->CleanupAndRelease();

    }

    return;
} // AtqpReuseOrFreeContext()



BOOL
I_AtqPrepareAcceptExSockets(
    IN PATQ_ENDPOINT          pEndpoint,
    IN DWORD                  nSockets
    )
/*++

Routine Description:

    Prepare specified number of AcceptEx sockets for the given
      ListenSocket in [pEndpoint]

Arguments:

    pEndpoint - Information about this listenning socket
    nSockets    - number of AcceptEx() sockets to be created.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL   fReturn;
    DWORD  cbBuffer;
    DWORD  i;

    if ( !g_fUseAcceptEx ) {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( pEndpoint->State != AtqStateActive ) {
        SetLastError( ERROR_NOT_READY );
        return(FALSE);
    }

    if ( pEndpoint->fAddingSockets) {
        //
        // Someone is already adding sockets. Do not add more
        // Just return success
        //
        return ( TRUE);
    }

    pEndpoint->fAddingSockets = TRUE;

    // calculate the buffer size
    cbBuffer = pEndpoint->InitialRecvSize + 2* MIN_SOCKADDR_SIZE;

    for ( fReturn = TRUE, i = 0 ; fReturn && i++ < nSockets; ) {

        PVOID        pvBuff;
        PATQ_CONT    pAtqContext;

        //
        //  Alloc a buffer for receive data
        //  TBD: Pool all these buffers into one large buffer.
        //

        pvBuff = LocalAlloc( LPTR, cbBuffer);

        //
        //  Get the ATQ context now because we need its overlapped structure
        //

        pAtqContext = I_AtqAllocContextFromCache();


        //
        // Now check if allocations are valid and do proper cleanup on failure
        //

        if ( pvBuff == NULL || pAtqContext == NULL) {

            if ( pvBuff ) {
                LocalFree( pvBuff );
                pvBuff = NULL;
            }

            if ( pAtqContext ) {
                I_AtqFreeContextToCache( pAtqContext );
                pAtqContext = NULL;
            }

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            fReturn = FALSE;
            break;
        } else {

            //
            // Add this socket to AtqContext lists & completion ports
            // From now on the called function will take care of freeing up
            //  pAtqContext, if there is a failure.
            //

            pAtqContext->SetAcceptExBuffer( pvBuff);
            if ( pEndpoint->fDatagram ) {
                pAtqContext->hAsyncIO = (HANDLE)pEndpoint->ListenSocket;
            } else {
                pAtqContext->hAsyncIO = NULL;
            }
            pAtqContext->hJraAsyncIO = 0;

            if ( !pEndpoint->fDatagram ) {
            
                if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

                    //
                    //  Failed to add the socket, free up the context without reuse
                    //

                    ATQ_PRINTF(( DBG_CONTEXT,
                                "[I_AtqPrepareAcceptExSockets] for Endpoint %08x"
                                " and AtqContext (%08x) failed with "
                                " Error = %d;  Now freeing the context ...",
                                pEndpoint, pAtqContext, GetLastError()
                                ));

                    // free without reuse
                    DBG_ASSERT( pAtqContext->m_nIO == 0);
                    pAtqContext->CleanupAndRelease();
                    fReturn = FALSE;
                }

            } else {
                while ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {
                    // UDP is more fragile than TCP, so keep trying.  If
                    // we give up, then we might run out of posted receives,
                    // and there's no way to recover from that.
                    Sleep(100);
                }
            }
        }
    } // for

    //
    // Finished Adding sockets. Indicate that by resetting the flab
    //

    pEndpoint->fAddingSockets = FALSE;

    ATQ_PRINTF(( DBG_CONTEXT,
                "PrepareAcceptExSockets( Endpoint[%08x], nSockets = %d)==>"
                " avail = %d; Total Refs = %d.\n",
                pEndpoint,
                nSockets,
                pEndpoint->nSocketsAvail,
                pEndpoint->m_refCount
                ));

    return ( fReturn);

} // I_AtqPrepareAcceptExSockets()


BOOL
I_AtqStartThreadMonitor(
    VOID
    )
/*++

Routine Description:

    Adds the ThreadMonitor function to the scheduler.
    
    Note: The scheduler should be initialized before getting to this function.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE on error 

--*/
{

    g_dwThreadMonitorCookie =
        ScheduleWorkItem(
                         (PFN_SCHED_CALLBACK)I_AtqThreadMonitor,
                         NULL, // No need for a context
                         TimeToWait(ATQ_THREAD_MONITOR_PERIOD),
                         TRUE  // ask for periodic timeout
                         );

    if ( g_dwThreadMonitorCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling ThreadMonitor\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);
}



BOOL
I_AtqStopThreadMonitor(
    VOID
    )
/*++

Routine Description:

    Removes the ThreadMonitor function from the scheduler.
    
    Note: The scheduler should be initialized before getting to this function.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE on error 

--*/
{
    if ( 0 != g_dwThreadMonitorCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwThreadMonitorCookie ));
        g_dwThreadMonitorCookie = 0;
    }

    return ( TRUE);
}


VOID
I_AtqThreadMonitor(
    IN PVOID NotUsed
    )
/*++

Routine Description:

    Checks to see whether the AtqPoolThreads have stalled out for longer than
    ATQ_THREAD_MONITOR_PERIOD, and if so starts up a temporary AtqPoolThread.
    This is to prevent deadlocks due to all the atq threads being used by
    processes that are trying to call a network service on this same machine
    that also used atq.

Arguments:

    NotUsed - This argument is only here because sheduler callback functions
    require a PVOID argument.  It is not actually used in the body of the
    function.

Return Value:

    None.

--*/
{
    HANDLE  hThread;
    DWORD   dwThreadID;

    if (!g_fDeadManSwitch || 0 != g_cAvailableThreads) {
        // The switch has been cleared since
        // the last time or there are still available threads, the AtqPoolThreads
        // must not be stuck.
        g_fDeadManSwitch = TRUE;
        return;
    }

    ATQ_ASSERT( ATQ_REG_MAX_POOL_THREAD_LIMIT > g_cThreads );

    if ( ATQ_REG_MAX_POOL_THREAD_LIMIT > g_cThreads ) { 
        // There are no free threads and there hasn't been any
        // for ATQ_THREAD_MONITOR_PERIOD.  Start up a temporary
        // thread to service calls until hopefully the rest of 
        // the threads make some progress.
        ATQ_PRINTF(( DBG_CONTEXT, "AtqThreadMonitor: Starting a new thread.\n"));

        InterlockedIncrement( &g_cThreads );

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                (PVOID)UIntToPtr(ATQ_TEMP_THREAD),  // Let the thread know that it is temporary.
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else {
            InterlockedDecrement( &g_cThreads );
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqThreadMonitor: Unable to create a temp thread.\n"));                    
        }
    } 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\kdc\core\atq\hashtab.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
       hashtab.cxx

   Abstract:
       Implements the member functions for Hash table

   Author:

       Murali R. Krishnan    ( MuraliK )     02-Oct-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# if !defined(dllexp)
# define dllexp __declspec( dllexport)
# endif

# include "isatq.hxx"
# include "hashtab.hxx"

# include "dbgutil.h"



/*++
  Organization of Hash Table

  The hash table consists of a set of hash buckets controlled
  by the number of buckets specified during creation.

  Each bucket consists of a set of bucket chunks. Each bucket
  owns a separate critical section to protect the entries in
  the bucket itself.

  Each bucket chunk consists of an array of MAX_ELEMENTS_PER_BUCKET
   HashTableBucketElement Entries (HTBE_ENTRY).

  Each HTBE_ENTRY maintains a hash value and pointer to the Hash Element.

--*/

/************************************************************
 *    HASH_TABLE_BUCKET
 ************************************************************/

struct HTBE_ENTRY {
    DWORD        m_hashValue;
    HT_ELEMENT * m_phte;

    inline
    BOOL IsMatch( DWORD hashValue, LPCSTR pszKey, DWORD cchKey) const
    { return ((hashValue == m_hashValue) &&
              (NULL != m_phte) &&
              m_phte->IsMatch( pszKey, cchKey)
              );
    }

    inline
    BOOL IsMatch( IN HT_ELEMENT * phte) const
    { return ( phte == m_phte); }

    inline BOOL
    IsEmpty( VOID) const { return ( NULL == m_phte); }

    VOID Print( VOID) const
    { m_phte->Print(); }
};

typedef HTBE_ENTRY * PHTBE_ENTRY;

//
// Chunk size should be carefully (empirically) chosen.
// Small Chunk size => large number of chunks
// Large Chunk size => high cost of search on failures.
// For now we choose the chunk size to be 20 entries.
# define MAX_ELEMENTS_PER_BUCKET    ( 20 )

struct HTB_ELEMENT {

    HTBE_ENTRY   m_rgElements[MAX_ELEMENTS_PER_BUCKET];
    DWORD        m_nElements;
    LIST_ENTRY   m_ListEntry;

    HTB_ELEMENT(VOID)
        : m_nElements ( 0)
    {
        InitializeListHead( &m_ListEntry);
        ZeroMemory( m_rgElements, sizeof( m_rgElements));
    }

    ~HTB_ELEMENT(VOID)
    { Cleanup(); }

    VOID Cleanup( VOID);

    inline
    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);

    inline
    BOOL Insert( IN DWORD hashVal, IN HT_ELEMENT * phte);

    inline
    BOOL Delete( IN HT_ELEMENT * phte);

    VOID Print( IN DWORD level) const;

    HTBE_ENTRY * FirstElement(VOID) { return ( m_rgElements); }
    HTBE_ENTRY * LastElement(VOID)
    { return ( m_rgElements + MAX_ELEMENTS_PER_BUCKET); }
    VOID NextElement( HTBE_ENTRY * & phtbe)
    { phtbe++; }

    VOID IncrementElements(VOID) { m_nElements++; }
    VOID DecrementElements(VOID) { m_nElements--; }
    DWORD NumElements( VOID) const { return ( m_nElements); }
    BOOL IsSpaceAvailable(VOID) const
    { return ( NumElements() < MAX_ELEMENTS_PER_BUCKET); }

    DWORD FindNextElement( IN OUT LPDWORD pdwPos,
                           OUT HT_ELEMENT ** pphte);

};

typedef HTB_ELEMENT * PHTB_ELEMENT;

class HASH_TABLE_BUCKET {

public:
    HASH_TABLE_BUCKET(VOID);
    ~HASH_TABLE_BUCKET( VOID);

    HT_ELEMENT * Lookup( IN DWORD hashValue, IN LPCSTR pszKey, DWORD cchKey);
    BOOL Insert( IN DWORD       hashVal,
                 IN HT_ELEMENT * phte,
                 IN BOOL        fCheckForDuplicate);

    BOOL Delete( IN HT_ELEMENT * phte);
    VOID Print( IN DWORD level);

    DWORD NumEntries( VOID);

    DWORD  InitializeIterator( IN HT_ITERATOR * phti);

    dllexp DWORD  FindNextElement( IN HT_ITERATOR * phti,
                                   OUT HT_ELEMENT ** pphte);
    dllexp DWORD  CloseIterator( IN HT_ITERATOR * phti);

private:
    CRITICAL_SECTION   m_csLock;

    LIST_ENTRY         m_lHead;
