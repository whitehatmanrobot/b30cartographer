ad
                    // and set something.
                    //
                    if(Err == NO_ERROR) {
                        Err = ERROR_INVALID_DATA;
                    }

                    MyFree(Hash);
                    if(Err != ERROR_INSUFFICIENT_BUFFER) {
                        //
                        // The API failed for some reason other than
                        // buffer-too-small.  We will try to check if the file
                        // is self-signed.
                        //
                        Hash = NULL;  // reset this so we won't try to free it
                                      //  later
                        hCatInfo = NULL;
                        TrySelfSign = TRUE;
                        WriteLogEntry(
                                    (PSETUP_LOG_CONTEXT)LogContext,
                                    SETUP_LOG_VERBOSE|SETUP_LOG_BUFFER,
                                    MSG_LOG_HASH_ERROR,
                                    NULL,
                                    FileFullPath ? FileFullPath : TEXT(""),
                                    Catalog ? Catalog : TEXT(""),
                                    Key
                                    );
                        WriteLogError(
                                    (PSETUP_LOG_CONTEXT)LogContext,
                                    SETUP_LOG_VERBOSE,
                                    Err
                                    );
                        LoggedWarning = TRUE;

                        break;
                    }
                }
            } while(Err != NO_ERROR);

            if(!TrySelfSign) {

                if(Err == NO_ERROR) {
                    //
                    // Now we have the file's hash.  Initialize the structures that
                    // will be used later on in calls to WinVerifyTrust.
                    //
                    WintrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
                    WintrustData.pCatalog = &WintrustCatalogInfo;

                    ZeroMemory(&WintrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
                    WintrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
                    WintrustCatalogInfo.pbCalculatedFileHash = Hash;
                    WintrustCatalogInfo.cbCalculatedFileHash = HashSize;

                    //
                    // WinVerifyTrust is case-sensitive, so ensure that the key
                    // being used is all lower-case!
                    //
#ifdef UNICODE
                    //
                    // Copy the key to a writable Unicode character buffer so we
                    // can lower-case it.
                    //
                    lstrcpyn(UnicodeKey, Key, SIZECHARS(UnicodeKey));
                    CharLower(UnicodeKey);
#else
                    //
                    // Copy the key to a writable ANSI character buffer so we can
                    // lower-case it (prior to converting the string to Unicode).
                    //
                    lstrcpyn(AnsiBuffer, Key, SIZECHARS(AnsiBuffer));
                    CharLower(AnsiBuffer);
                    MultiByteToWideChar(CP_ACP, 0, AnsiBuffer, -1, UnicodeKey, SIZECHARS(UnicodeKey));
#endif
                    WintrustCatalogInfo.pcwszMemberTag = UnicodeKey;

                    if(Catalog && (Catalog != pSetupGetFileTitle(Catalog))) {
                        //
                        // We know in this case we're always going to examine
                        // exactly one catalog.
                        //
                        if(NumCatalogsConsidered) {
                            *NumCatalogsConsidered = 1;
                        }

                        //
                        // Fill in the catalog information since we know which
                        // catalog we're going to be using...
                        //
#ifdef UNICODE
                        WintrustCatalogInfo.pcwszCatalogFilePath = Catalog;
#else
                        //
                        // Use the handy-dandy unicode catalog filename buffer
                        // provided for us by the CatInfo.wszCatalogFile field.
                        //
                        MultiByteToWideChar(CP_ACP, 0, Catalog, -1, CatInfo.wszCatalogFile, SIZECHARS(CatInfo.wszCatalogFile));
                        WintrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;
#endif
                        //
                        // The caller supplied the path to the catalog file to be
                        // used for verification--we're ready to go!  First, verify
                        // the catalog (unless the caller already did it), and if
                        // that succeeds, then verify the file.
                        //
                        if(!CatalogAlreadyVerified) {

                            DWORD dwStateAction;

                            //
                            // Before validating the catalog, we'll flush the
                            // crypto cache.  Otherwise, it can get fooled when
                            // validating against a catalog at a specific
                            // location, because that catalog can change
                            // "behind its back".
                            //
                            dwStateAction = WintrustData.dwStateAction;

                            WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE_FLUSH;

                            Err = (DWORD)WinVerifyTrust(NULL,
                                                        &DriverVerifyGuid,
                                                        &WintrustData
                                                       );
                            if(Err != NO_ERROR) {
                                //
                                // This shouldn't fail, but log a warning if it
                                // does...
                                //
                                WriteLogEntry(
                                            (PSETUP_LOG_CONTEXT)LogContext,
                                            SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                                            MSG_LOG_CRYPTO_CACHE_FLUSH_FAILURE,
                                            NULL,
                                            Catalog
                                            );
                                WriteLogError(
                                            (PSETUP_LOG_CONTEXT)LogContext,
                                            SETUP_LOG_WARNING,
                                            Err
                                            );
                                //
                                // treat this error as non-fatal
                                //
                            }

                            //
                            // When flushing the cache, crypto isn't supposed
                            // to be allocating a pcSignerCertContext...
                            //
                            MYASSERT(!VersionInfo.pcSignerCertContext);
                            if(VersionInfo.pcSignerCertContext) {
                                CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                                VersionInfo.pcSignerCertContext = NULL;
                            }

                            //
                            // Now back to our regularly-scheduled programming...
                            //
                            WintrustData.dwStateAction = dwStateAction;

                            Err = pSetupVerifyCatalogFile(Catalog);
                        }

                        if(Err != NO_ERROR) {
                            WriteLogEntry(
                                        (PSETUP_LOG_CONTEXT)LogContext,
                                        GetCatLogLevel(Err)|SETUP_LOG_BUFFER,
                                        MSG_LOG_VERIFYCAT_ERROR,
                                        NULL,
                                        Catalog ? Catalog : TEXT("")
                                        );
                            WriteLogError(
                                        (PSETUP_LOG_CONTEXT)LogContext,
                                        GetCatLogLevel(Err),
                                        Err
                                        );
                            LoggedWarning = TRUE;
                            if(Problem) {
                                *Problem = SetupapiVerifyCatalogProblem;
                                lstrcpy(ProblemFile, Catalog);
                            }
                        } else {
                            //
                            // Catalog was verified, now verify the file using that
                            // catalog.
                            //
                            if(CatalogFileUsed) {
                                lstrcpy(CatalogFileUsed, Catalog);
                            }

                            Err = (DWORD)WinVerifyTrust(NULL,
                                                        &DriverVerifyGuid,
                                                        &WintrustData
                                                       );

                            //
                            // Fill in the DigitalSigner and SignerVersion if
                            // they were passed in.
                            //
                            if (Err == NO_ERROR) {
                                if (DigitalSigner) {
#ifdef UNICODE
                                    lstrcpy(DigitalSigner, VersionInfo.wszSignedBy);
#else
                                    WideCharToMultiByte(
                                           CP_ACP,
                                           0,
                                           VersionInfo.wszSignedBy,
                                           -1,
                                           DigitalSigner,
                                           MAX_PATH,
                                           NULL,
                                           NULL
                                           );
#endif
                                }

                                if (SignerVersion) {
#ifdef UNICODE
                                    lstrcpy(SignerVersion, VersionInfo.wszVersion);
#else
                                    WideCharToMultiByte(
                                           CP_ACP,
                                           0,
                                           VersionInfo.wszVersion,
                                           -1,
                                           SignerVersion,
                                           MAX_PATH,
                                           NULL,
                                           NULL
                                           );
#endif
                                }
                            }

                            //
                            // The DRIVER_VER_INFO structure was filled in with
                            // a pointer that we must free!
                            //
                            if(VersionInfo.pcSignerCertContext) {
                                CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                                VersionInfo.pcSignerCertContext = NULL;
                            }

                            if (Err != NO_ERROR) {

                                TrySelfSign = TRUE;

                                WriteLogEntry(
                                            (PSETUP_LOG_CONTEXT)LogContext,
                                            GetCatLogLevel(Err)|SETUP_LOG_BUFFER,
                                            MSG_LOG_VERIFYFILE_ERROR,
                                            NULL,
                                            FileFullPath ? FileFullPath : TEXT(""),
                                            Catalog ? Catalog : TEXT(""),
                                            Key
                                            );
                                WriteLogError(
                                            (PSETUP_LOG_CONTEXT)LogContext,
                                            GetCatLogLevel(Err),
                                            Err
                                            );
                                LoggedWarning = TRUE;
                            } else {
                                WriteLogEntry(
                                            (PSETUP_LOG_CONTEXT)LogContext,
                                            SETUP_LOG_VERBOSE,
                                            MSG_LOG_VERIFYFILE_OK,
                                            NULL,
                                            FileFullPath ? FileFullPath : TEXT(""),
                                            Catalog ? Catalog : TEXT(""),
                                            Key
                                            );
                            }
                        }

                    } else {
                        //
                        // Search through installed catalogs looking for those that
                        // contain data for a file with the hash we just calculated.
                        //
                        PrevCat = NULL;
                        hCatInfo = CryptCATAdminEnumCatalogFromHash(LocalhCatAdmin,
                                                                    Hash,
                                                                    HashSize,
                                                                    0,
                                                                    &PrevCat
                                                                   );

                        while(hCatInfo) {

                            CatInfo.cbStruct = sizeof(CATALOG_INFO);
                            if(CryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {
#ifdef UNICODE
                                CatalogFullPath = CatInfo.wszCatalogFile;
#else
                                WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    CatInfo.wszCatalogFile,
                                    -1,
                                    AnsiBuffer,
                                    sizeof(AnsiBuffer),
                                    NULL,
                                    NULL
                                    );
                                CatalogFullPath = AnsiBuffer;
#endif
                                //
                                // If we have a catalog name we're looking for,
                                // see if the current catalog matches.  If the
                                // caller didn't specify a catalog, then just
                                // attempt to validate against each catalog we
                                // enumerate.  Note that the catalog file info
                                // we get back gives us a fully qualified path.
                                //
                                if(Catalog) {
                                    FoundMatchingImage = !lstrcmpi(
                                                            pSetupGetFileTitle(CatalogFullPath),
                                                            Catalog
                                                            );
                                } else {

                                    if((Flags & VERIFY_FILE_USE_OEM_CATALOGS) ||
                                       !IsInstalledCatalogFromOem(pSetupGetFileTitle(CatalogFullPath))) {

                                        FoundMatchingImage = TRUE;
                                    } else {
                                        FoundMatchingImage = FALSE;
                                    }
                                }

                                if(FoundMatchingImage) {
                                    //
                                    // Increment our counter of how many
                                    // catalogs we've considered.
                                    //
                                    if(NumCatalogsConsidered) {
                                        (*NumCatalogsConsidered)++;
                                    }

                                    //
                                    // If the caller supplied a mapped-in image
                                    // of the catalog we're looking for, then
                                    // check to see if this catalog matches by
                                    // doing a binary compare.
                                    //
                                    if(CatalogBaseAddress) {

                                        FoundMatchingImage = GetFileAttributesEx(
                                                                CatalogFullPath,
                                                                GetFileExInfoStandard,
                                                                &FileAttribData
                                                               );
                                        //
                                        // Check to see if the catalog we're looking
                                        // at is the same size as the one we're
                                        // verifying.
                                        //
                                        if(FoundMatchingImage &&
                                           (FileAttribData.nFileSizeLow != CatalogImageSize)) {

                                            FoundMatchingImage = FALSE;
                                        }

                                        if(FoundMatchingImage) {

                                            if(pSetupOpenAndMapFileForRead(CatalogFullPath,
                                                                     &CurCatFileSize,
                                                                     &CurCatFileHandle,
                                                                     &CurCatMappingHandle,
                                                                     &CurCatBaseAddress) == NO_ERROR) {

                                                MYASSERT(CurCatFileSize == CatalogImageSize);

                                                //
                                                // Surround the following in try/except, in case we get an inpage error.
                                                //
                                                try {
                                                    //
                                                    // We've found a potential match.
                                                    //
                                                    FoundMatchingImage = !memcmp(
                                                                             CatalogBaseAddress,
                                                                             CurCatBaseAddress,
                                                                             CatalogImageSize
                                                                             );

                                                } except(EXCEPTION_EXECUTE_HANDLER) {
                                                    FoundMatchingImage = FALSE;
                                                }

                                                pSetupUnmapAndCloseFile(CurCatFileHandle,
                                                                  CurCatMappingHandle,
                                                                  CurCatBaseAddress
                                                                 );
                                            } else {
                                                FoundMatchingImage = FALSE;
                                            }
                                        }

                                    } else {
                                        //
                                        // Since there was no catalog image supplied
                                        // to match against, the catalog we're
                                        // currently looking at is considered a
                                        // valid match candidate.
                                        //
                                        FoundMatchingImage = TRUE;
                                    }

                                    if(FoundMatchingImage) {
                                        //
                                        // We found an applicable catalog, now
                                        // validate the file against that catalog.
                                        //
                                        // NOTE:  Because we're using cached
                                        // catalog information (i.e., the
                                        // WTD_STATEACTION_AUTO_CACHE flag), we
                                        // don't need to explicitly validate the
                                        // catalog itself first.
                                        //
                                        WintrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

                                        Err = (DWORD)WinVerifyTrust(NULL,
                                                                    &DriverVerifyGuid,
                                                                    &WintrustData
                                                                   );

                                        //
                                        // Fill in the DigitalSigner and SignerVersion if
                                        // they were passed in.
                                        //
                                        if (Err == NO_ERROR) {
                                            if (DigitalSigner) {
#ifdef UNICODE
                                                lstrcpy(DigitalSigner, VersionInfo.wszSignedBy);
#else
                                                WideCharToMultiByte(
                                                       CP_ACP,
                                                       0,
                                                       VersionInfo.wszSignedBy,
                                                       -1,
                                                       DigitalSigner,
                                                       MAX_PATH,
                                                       NULL,
                                                       NULL
                                                       );
#endif
                                            }

                                            if (SignerVersion) {
#ifdef UNICODE
                                                lstrcpy(SignerVersion, VersionInfo.wszVersion);
#else
                                                WideCharToMultiByte(
                                                       CP_ACP,
                                                       0,
                                                       VersionInfo.wszVersion,
                                                       -1,
                                                       SignerVersion,
                                                       MAX_PATH,
                                                       NULL,
                                                       NULL
                                                       );
#endif
                                            }
                                        }

                                        //
                                        // The DRIVER_VER_INFO structure was filled in with
                                        // a pointer that we must free!
                                        //
                                        if(VersionInfo.pcSignerCertContext) {
                                            CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                                            VersionInfo.pcSignerCertContext = NULL;
                                        }

                                        if (Err != NO_ERROR) {
                                            WriteLogEntry(
                                                        (PSETUP_LOG_CONTEXT)LogContext,
                                                        GetCatLogLevel(Err)|SETUP_LOG_BUFFER,
                                                        MSG_LOG_VERIFYFILE_ERROR,
                                                        NULL,
                                                        FileFullPath ? FileFullPath : TEXT(""),
                                                        CatalogFullPath ? CatalogFullPath : TEXT(""),
                                                        Key
                                                        );
                                            WriteLogError(
                                                        (PSETUP_LOG_CONTEXT)LogContext,
                                                        GetCatLogLevel(Err),
                                                        Err
                                                        );
                                            LoggedWarning = TRUE;
                                        } else {
                                            WriteLogEntry(
                                                        (PSETUP_LOG_CONTEXT)LogContext,
                                                        SETUP_LOG_VERBOSE,
                                                        MSG_LOG_VERIFYFILE_OK,
                                                        NULL,
                                                        FileFullPath ? FileFullPath : TEXT(""),
                                                        CatalogFullPath ? CatalogFullPath : TEXT(""),
                                                        Key
                                                        );
                                        }

                                        if(Err == NO_ERROR) {
                                            //
                                            // We successfully verified the
                                            // file--store the name of the
                                            // catalog used, if the caller
                                            // requested it.
                                            //
                                            if(CatalogFileUsed) {
                                                lstrcpy(CatalogFileUsed, CatalogFullPath);
                                            }
                                        } else {
                                            if(Catalog || CatalogBaseAddress) {
                                                if(CatalogFileUsed) {
                                                    lstrcpy(CatalogFileUsed, CatalogFullPath);
                                                }
                                                if(Problem) {
                                                    *Problem = SetupapiVerifyFileProblem;
                                                    lstrcpy(ProblemFile, FileFullPath);
                                                }
                                            }
                                        }

                                        //
                                        // If the result of the above validations is
                                        // success, then we're done.  If not, and we're
                                        // looking for a relevant catalog file (i.e.,
                                        // the INF didn't specify one), then we move
                                        // on to the next catalog.  Otherwise, we've
                                        // failed.
                                        //
                                        if((Err == NO_ERROR) || Catalog || CatalogBaseAddress) {

                                            CryptCATAdminReleaseCatalogContext(LocalhCatAdmin, hCatInfo, 0);
                                            break;
                                        }
                                    }
                                }
                            }

                            PrevCat = hCatInfo;
                            hCatInfo = CryptCATAdminEnumCatalogFromHash(LocalhCatAdmin, Hash, HashSize, 0, &PrevCat);
                        }

                        if(!hCatInfo) {
                            //
                            // We exhausted all the applicable catalogs without
                            // finding the one we needed.
                            //
                            Err = GetLastError();
                            MYASSERT(Err != NO_ERROR);
                            //
                            // Make sure we have a valid error code.
                            //
                            if(Err == NO_ERROR) {
                                Err = ERROR_INVALID_DATA;
                            }
                            TrySelfSign = TRUE;
                            //
                            // report failure if we haven't already done so
                            //
                            if(!LoggedWarning) {
                                WriteLogEntry((PSETUP_LOG_CONTEXT)LogContext,
                                              GetCatLogLevel(Err)|SETUP_LOG_BUFFER,
                                              MSG_LOG_VERIFYFILE_ERROR,
                                              NULL,
                                              FileFullPath ? FileFullPath : TEXT(""),
                                              Catalog ? Catalog : TEXT(""),
                                              Key
                                              );
                                WriteLogError((PSETUP_LOG_CONTEXT)LogContext,GetCatLogLevel(Err),Err);
                            }
                        }
                    }
                } else {
                    if(Problem) {
                        *Problem = SetupapiVerifyFileProblem;
                        lstrcpy(ProblemFile, FileFullPath);
                    }
                }
            }
            if (TrySelfSign) {
                if(!(Flags & VERIFY_FILE_IGNORE_SELFSIGNED)) {
                    //
                    // The file failed to validate using any catalogs
                    // See if the file validates without a
                    // catalog (i.e., the file contains its own
                    // signature).
                    //
                    WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
                    WintrustData.pFile = &WintrustFileInfo;
                    ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
                    WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
#ifdef UNICODE
                    WintrustFileInfo.pcwszFilePath = FileFullPath;
#else
                    //
                    // Use the UnicodeKey buffer to hold the unicode
                    // version of the full pathname of the file to be
                    // verified.
                    //
                    MultiByteToWideChar(CP_ACP, 0, FileFullPath, -1, UnicodeKey, SIZECHARS(UnicodeKey));
                    WintrustFileInfo.pcwszFilePath = UnicodeKey;
#endif
                    Err = (DWORD)WinVerifyTrust(NULL,
                                                &DriverVerifyGuid,
                                                &WintrustData
                                               );

                    //
                    // Fill in the DigitalSigner and SignerVersion if
                    // they were passed in.
                    //
                    if (Err == NO_ERROR) {
                        if (DigitalSigner) {
#ifdef UNICODE
                            lstrcpy(DigitalSigner, VersionInfo.wszSignedBy);
#else
                            WideCharToMultiByte(
                                   CP_ACP,
                                   0,
                                   VersionInfo.wszSignedBy,
                                   -1,
                                   DigitalSigner,
                                   MAX_PATH,
                                   NULL,
                                   NULL
                                   );
#endif
                        }

                        if (SignerVersion) {
#ifdef UNICODE
                            lstrcpy(SignerVersion, VersionInfo.wszVersion);
#else
                            WideCharToMultiByte(
                                   CP_ACP,
                                   0,
                                   VersionInfo.wszVersion,
                                   -1,
                                   SignerVersion,
                                   MAX_PATH,
                                   NULL,
                                   NULL
                                   );
#endif
                        }
                    }

                    //
                    // The DRIVER_VER_INFO structure was filled in with
                    // a pointer that we must free!
                    //
                    if(VersionInfo.pcSignerCertContext) {
                        CertFreeCertificateContext(VersionInfo.pcSignerCertContext);
                        VersionInfo.pcSignerCertContext = NULL;
                    }

                    if (Err != NO_ERROR) {
                        WriteLogEntry(
                                    (PSETUP_LOG_CONTEXT)LogContext,
                                    SETUP_LOG_VERBOSE|SETUP_LOG_BUFFER,
                                    MSG_LOG_SELFSIGN_ERROR,
                                    NULL,
                                    FileFullPath ? FileFullPath : TEXT(""),
                                    Key
                                    );
                        WriteLogError(
                                    (PSETUP_LOG_CONTEXT)LogContext,
                                    SETUP_LOG_VERBOSE,
                                    Err
                                    );
                        LoggedWarning = TRUE;
                    } else {
                        WriteLogEntry(
                                    (PSETUP_LOG_CONTEXT)LogContext,
                                    SETUP_LOG_VERBOSE,
                                    MSG_LOG_SELFSIGN_OK,
                                    NULL,
                                    FileFullPath ? FileFullPath : TEXT(""),
                                    Key
                                    );
                    }
                }
                if(Err == NO_ERROR) {
                    //
                    // The file validated without a catalog.  Store an empty
                    // string in the CatalogFileUsed buffer (if supplied).
                    //
                    if(CatalogFileUsed) {
                        *CatalogFileUsed = TEXT('\0');
                    }
                } else {
                    //
                    // report error prior to Self-Sign check
                    //
                    if(Problem) {
                        *Problem = SetupapiVerifyFileProblem;
                        lstrcpy(ProblemFile, FileFullPath);
                    }
                }
            }
            if (Hash) {
                MyFree(Hash);
            }
        }

    } else {
        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
        //
        // Make sure we have a valid error code.
        //
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }

        if(Problem) {
            //
            // We failed too early to blame the file as the problem, but it's
            // the only filename we currently have to return as the problematic
            // file.
            //
            *Problem = SetupapiVerifyFileProblem;
            lstrcpy(ProblemFile, FileFullPath);
        }
    }

    if (Err != NO_ERROR) {
        //
        // report failure if we haven't already done so
        //
        if(!LoggedWarning) {
            WriteLogEntry(LogContext,
                          GetCatLogLevel(Err)|SETUP_LOG_BUFFER,
                          MSG_LOG_VERIFYFILE_ERROR,
                          NULL,
                          FileFullPath ? FileFullPath : TEXT(""),
                          Catalog ? Catalog : TEXT(""),
                          Key
                          );
            WriteLogError((PSETUP_LOG_CONTEXT)LogContext,GetCatLogLevel(Err),Err);
        }
    }

clean0:
#ifdef UNICODE
    if(!hSDBDrvMain && LocalhSDBDrvMain) {
        //
        // Don't need to return our HSDB to the caller, so free
        // it now.
        //
        SdbReleaseDatabase(LocalhSDBDrvMain);
    }
#endif
    if(hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
    if(AltPlatSlot) {
        ReleaseLogInfoSlot(LogContext,AltPlatSlot);
    }
    if(!hCatAdmin && LocalhCatAdmin) {
        CryptCATAdminReleaseContext(LocalhCatAdmin, 0);
    }
    SetLastError(Err);
    return Err;
}


DWORD
pSetupVerifyFile(
    IN  PSETUP_LOG_CONTEXT      LogContext,
    IN  LPCTSTR                 Catalog,                OPTIONAL
    IN  PVOID                   CatalogBaseAddress,     OPTIONAL
    IN  DWORD                   CatalogImageSize,
    IN  LPCTSTR                 Key,
    IN  LPCTSTR                 FileFullPath,
    OUT SetupapiVerifyProblem  *Problem,                OPTIONAL
    OUT LPTSTR                  ProblemFile,            OPTIONAL
    IN  BOOL                    CatalogAlreadyVerified,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT PDWORD                  NumCatalogsConsidered   OPTIONAL
    )

/*++

Routine Description:

    See _VerifyFile

    Since this private API is exported for use by other system components
    (e.g., syssetup), we make a check to ensure that the AltPlatformInfo, if
    specified, is of the correct version.

--*/

{
    if(AltPlatformInfo) {
        if(AltPlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) {
            return ERROR_INVALID_PARAMETER;
        }
        if(!(AltPlatformInfo->Flags & SP_ALTPLATFORM_FLAGS_VERSION_RANGE)) {
            //
            // this flag must be set to indicate the version range fields are valid
            //
            return ERROR_INVALID_PARAMETER;
        }
    }

    return _VerifyFile(LogContext,
                       NULL,
                       NULL,
                       Catalog,
                       CatalogBaseAddress,
                       CatalogImageSize,
                       Key,
                       FileFullPath,
                       Problem,
                       ProblemFile,
                       CatalogAlreadyVerified,
                       AltPlatformInfo,
                       VERIFY_FILE_USE_OEM_CATALOGS,
                       CatalogFileUsed,
                       NumCatalogsConsidered,
                       NULL,
                       NULL
                      );
}


BOOL
IsInfForDeviceInstall(
    IN  PSETUP_LOG_CONTEXT       LogContext,           OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid, OPTIONAL
    IN  PLOADED_INF              LoadedInf,            OPTIONAL
    OUT PTSTR                   *DeviceDesc,           OPTIONAL
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform,   OPTIONAL
    OUT PDWORD                   PolicyToUse,          OPTIONAL
    OUT PBOOL                    UseOriginalInfName    OPTIONAL
    )

/*++

Routine Description:

    This routine determines whether the specified INF is a device INF.  If so,
    it returns a generic string to use in identifying the device installation
    when there is no device description available (e.g., installing a printer).
    It can also return the appropriate platform parameters to be used in
    digital signature verification for this INF, as well as the codesigning
    policy to employ should a digital signature validation failure occur.
    Finally, this routine can indicate whether the INF should be installed
    under its original name (i.e., because it's an exception package INF).

Arguments:

    LogContext - Optionally, supplies the log context for any log entries that
        might be generated by this routine.

    DeviceSetupClassGuid - Optionally, supplies the address of a GUID that
        indicates which device setup class is to be used in determining
        information such as description, validation platform, and policy to
        use.  If this parameter is NULL, then the GUID is retrieved from the
        INF list supplied via the LoadedInf parameter.

    LoadedInf - Optionally, supplies the address of a loaded INF list we need
        to examine to see if any of the members therein are device INFs.  An
        INF is a device INF if it specifies a class association (via either
        Class= or ClassGUID= entries) in its [Version] section.  If the
        DeviceSetupClassGuid parameter is supplied (i.e., non-NULL), then this
        parameter is ignored.  If this parameter is also NULL, then it is
        assumed the installation is not device-related.

        The presence of a device INF anywhere in this list will cause us to
        consider this a device installation.  However, the _first_ INF we
        encounter having a class association is what will be used in determining
        the device description (see below).

        ** NOTE:  The caller is responsible for locking the loaded INF **
        **        list prior to calling this routine!                  **

    DeviceDesc - Optionally, supplies the address of a string pointer that will
        be filled in upon return with a (newly-allocated) descriptive string to
        be used when referring to this installation (e.g., for doing driver
        signing failure popups).  We will first try to retrieve the friendly
        name for this INF's class (whose determination is described above).  If
        that's not possible (e.g., the class isn't yet installed), then we'll
        return the class name.  If that's not possible, then we'll return a
        (localized) generic string such as "Unknown driver software package".

        This output parameter (if supplied) will only ever be set to a non-NULL
        value when the routine returns TRUE.  The caller is responsible for
        freeing this character buffer.  If an out-of-memory failure is
        encountered when trying to allocate memory for this buffer, the
        DeviceDesc pointer will simply be set to NULL.  It will also be set to
        NULL if we're dealing with an exception package (since we don't want
        to treat this like a "hardware install" for purposes of codesigning
        blocking UI).

    ValidationPlatform - Optionally, supplies the address of a (version 2)
        altplatform info pointer that is filled in upon return with a newly-
        allocated structure specifying the appropriate parameters to be passed
        to WinVerifyTrust when validating this INF.  These parameters are
        retrieved from certclas.inf for the relevant device setup class GUID.
        If no special parameters are specified for this class (or if the INF
        has no class at all), then this pointer is returned as NULL, which
        causes us to use WinVerifyTrust's default validation.  Note that if
        we fail to allocate this structure due to low-memory, the pointer will
        be returned as NULL in that case as well.  This is OK, because this
        simply means we'll do default validation in that case.

        By this mechanism, we can easily deal with the different validation
        policies in effect for the various device classes we have in the system.

        The caller is responsible for freeing the memory allocated for this
        structure.

    PolicyToUse - Optionally, supplies the address of a dword variable that is
        set upon return to indicate what codesigning policy (i.e., Ignore, Warn,
        or Block) should be used for this INF.  This determination is made based
        on whether any INF in the list is of a class that WHQL has a
        certification program for (as specified in %windir%\Inf\certclas.inf).

        Additionally, if any INF in the list is of the exception class, then
        the policy is automatically set to Block (i.e., it's not configurable
        via driver signing or non-driver-signing policy/preference settings).

    UseOriginalInfName - Optionally, supplies the address of a boolean variable
        that is set upon return to indicate whether the INF should be installed
        into %windir%\Inf under its original name.  This will only be true if
        the INF is an exception INF.

Return Value:

    If the INF is a device INF, the return value is TRUE.  Otherwise, it is
    FALSE.

--*/

{
    PLOADED_INF CurInf, NextInf;
    GUID ClassGuid;
    BOOL DeviceInfFound, ClassInDrvSignList;
    TCHAR ClassDescBuffer[LINE_LEN];
    PCTSTR ClassDesc;
    DWORD Err;

    if(DeviceDesc) {
        *DeviceDesc = NULL;
    }

    if(ValidationPlatform) {
        *ValidationPlatform = NULL;
    }

    if(UseOriginalInfName) {
        *UseOriginalInfName = FALSE;
    }

    if(!DeviceSetupClassGuid && !LoadedInf) {
        //
        // Not a whole lot to do here.  Assume non-driver-signing policy and
        // return.
        //
        if(PolicyToUse) {
            *PolicyToUse = pSetupGetCurrentDriverSigningPolicy(FALSE);
        }

        return FALSE;
    }

    if(PolicyToUse || ValidationPlatform) {

        if(PolicyToUse) {
            //
            // Initialize policy to "Ignore"
            //
            *PolicyToUse = DRIVERSIGN_NONE;
        }

        ClassInDrvSignList = FALSE;
    }

    //
    // If DeviceSetupClassGuid was specified, then retrieve information
    // pertaining to that class.  Otherwise, traverse the individual INFs in
    // the LOADED_INF list, examining each one to see if it's a device INF.
    //
    DeviceInfFound = FALSE;

    for(CurInf = LoadedInf; CurInf || DeviceSetupClassGuid; CurInf = NextInf) {
        //
        // Setup a "NextInf" pointer so we won't dereference NULL when we go
        // back through the loop in the case where we have a
        // DeviceSetupClassGuid instead of a LoadedInf list.
        //
        NextInf = CurInf ? CurInf->Next : NULL;

        if(!DeviceSetupClassGuid) {
            if(ClassGuidFromInfVersionNode(&(CurInf->VersionBlock), &ClassGuid)) {
                DeviceSetupClassGuid = &ClassGuid;
            } else {
                //
                // This INF doesn't have an associated device setup class GUID,
                // so skip it and continue on with our search for a device INF.
                //
                continue;
            }
        }

        //
        // NOTE: From this point forward, you must reset the
        // DeviceSetupClasGuid pointer to NULL before making another pass
        // through the loop.  Otherwise, we'll enter an infinite loop, since
        // we can enter the loop if that pointer is non-NULL.
        //

        if(IsEqualGUID(DeviceSetupClassGuid, &GUID_NULL)) {
            //
            // The INF specified a ClassGUID of GUID_NULL (e.g., like some of
            // our non-device system INFs such as layout.inf do).  Skip it, and
            // continue on with our search for a device INF.
            //
            DeviceSetupClassGuid = NULL;
            continue;
        }

        //
        // If we get to this point, we have a device setup class GUID.  If this
        // is the first device INF we've encountered (or our first and only
        // time through the loop when the caller passed us in a
        // DeviceSetupClassGuid), then do our best to retrieve a description
        // for it (if we've been asked to do so).  We do not do this for
        // exception packages, because we don't want them to be referred to as
        // "hardware installs" in the Block dialog if a signature verification
        // failure occurs.
        //
        if(!DeviceInfFound) {

            DeviceInfFound = TRUE;

            if(DeviceDesc) {

                if(!IsEqualGUID(DeviceSetupClassGuid, &GUID_DEVCLASS_WINDOWS_COMPONENT_PUBLISHER)) {
                    //
                    // First, try to retrieve the class's friendly name.
                    //
                    if(SetupDiGetClassDescription(DeviceSetupClassGuid,
                                                  ClassDescBuffer,
                                                  SIZECHARS(ClassDescBuffer),
                                                  NULL)) {

                        ClassDesc = ClassDescBuffer;

                    } else if(CurInf) {
                        //
                        // OK, so the class isn't installed yet.  Retrieve the
                        // class name from the INF itself.
                        //
                        ClassDesc = pSetupGetVersionDatum(&(CurInf->VersionBlock),
                                                          pszClass
                                                         );
                    } else {
                        //
                        // The caller passed us in a device setup class GUID
                        // instead of an INF.  The class hasn't been installed yet,
                        // so we have no idea what to call it.
                        //
                        ClassDesc = NULL;
                    }

                    if(!ClassDesc) {
                        //
                        // We have a non-installed class, either with no INF, or
                        // with an INF that specifies a ClassGUID= entry, but no
                        // Class= entry in its [Version] section.  If we tried
                        // to actually install a device from such an INF, we'd
                        // get a failure in SetupDiInstallClass because the
                        // class name is required when installing the class.
                        // However, this INF might never be used in a device
                        // installation, but it definitely is a device INF.
                        // Therefore, we just give it a generic description.
                        //
                        if(LoadString(MyDllModuleHandle,
                                      IDS_UNKNOWN_DRIVER,
                                      ClassDescBuffer,
                                      SIZECHARS(ClassDescBuffer))) {

                            ClassDesc = ClassDescBuffer;
                        } else {
                            ClassDesc = NULL;
                        }
                    }

                    //
                    // OK, we have a description for this device (unless we hit
                    // some weird error).
                    //
                    if(ClassDesc) {
                        *DeviceDesc = DuplicateString(ClassDesc);
                    }
                }
            }
        }

        //
        // If we get to this point, we know that:  (a) we have a device setup
        // class GUID and (b) we've retrieved a device description, if
        // necessary.
        //
        if(PolicyToUse || ValidationPlatform) {
            //
            // First, check to see if this is an exception class--if it is,
            // then policy is Block, and we want to install the INF and CAT
            // files using their original names.
            //
            if(IsEqualGUID(DeviceSetupClassGuid, &GUID_DEVCLASS_WINDOWS_COMPONENT_PUBLISHER)) {

                if(PolicyToUse) {
                    *PolicyToUse = DRIVERSIGN_BLOCKING;
                }

                if(UseOriginalInfName) {
                    *UseOriginalInfName = TRUE;
                }
            }

            //
            // Now check to see if this class is in our list of classes that
            // WHQL has certification programs for (hence should be subject to
            // driver signing policy).
            //
            // NOTE: We may also find the exception class GUID in this list.
            // This may be used as an override mechanism, in case we decide to
            // allow 5.0-signed exception packages install on 5.1, for example.
            //
            ClassInDrvSignList = ClassGuidInDrvSignPolicyList(
                                     LogContext,
                                     DeviceSetupClassGuid,
                                     ValidationPlatform
                                     );

            if(ClassInDrvSignList) {
                //
                // Once we encounter a device INF whose class is in our driver
                // signing policy list, we can stop looking...
                //
                break;
            }

        } else {
            //
            // The caller doesn't care about whether this class is subject to
            // driver signing policy.  Since we've already retrieved the info
            // they care about, we can get out of this loop.
            //
            break;
        }

        DeviceSetupClassGuid = NULL;  // break out in no-INF case
    }

    if(PolicyToUse) {
        //
        // Unless we've already established that the policy to use is "Block"
        // (because we found an exception INF), we should retrieve the
        // applicable policy now...
        //
        if(*PolicyToUse != DRIVERSIGN_BLOCKING) {

            *PolicyToUse =
                pSetupGetCurrentDriverSigningPolicy(DeviceInfFound && ClassInDrvSignList);
        }
    }

    return DeviceInfFound;
}


DWORD
GetCodeSigningPolicyForInf(
    IN  PSETUP_LOG_CONTEXT       LogContext,         OPTIONAL
    IN  HINF                     InfHandle,
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform, OPTIONAL
    OUT PBOOL                    UseOriginalInfName  OPTIONAL
    )

/*++

Routine Description:

    This routine returns a value indicating the appropriate policy to be
    employed should a digital signature verification failure arise from some
    operation initiated by that INF.  It figures out whether the INF is subject
    to driver signing or non-driver signing policy (based on the INF's class
    affiliation, and the presence of an applicable WHQL program).  It also can
    return an altplatform info structure indicating how validation should be
    done (i.e., if certclas.inf indicates that a range of OSATTR versions should
    be considered valid).

Arguments:

    LogContext - Optionally, supplies the log context for any log entries that
        might be generated by this routine.

    InfHandle - Supplies the handle of the INF for which policy is to be
        retrieved.

    ValidationPlatform - See preamble of IsInfForDeviceInstall routine for
        details.

    UseOriginalInfName - Optionally, supplies the address of a boolean variable
        that is set upon return to indicate whether the INF should be installed
        into %windir%\Inf under its original name.  This will only be true if
        the INF is an exception INF.

Return Value:

    If the INF is a device INF, the return value is TRUE.  Otherwise, it is
    FALSE.

--*/

{
    DWORD Policy;

    if(!LockInf((PLOADED_INF)InfHandle)) {
        //
        // This is an internal-only routine, and all callers should be
        // passing in valid INF handles.
        //
        MYASSERT(FALSE);
        //
        // If this does happen, just assume this isn't a device INF.
        //
        if(UseOriginalInfName) {
            *UseOriginalInfName = FALSE;
        }
        if(ValidationPlatform) {
            *ValidationPlatform = NULL;
        }
        return pSetupGetCurrentDriverSigningPolicy(FALSE);
    }

    IsInfForDeviceInstall(LogContext,
                          NULL,
                          (PLOADED_INF)InfHandle,
                          NULL,
                          ValidationPlatform,
                          &Policy,
                          UseOriginalInfName
                         );

    UnlockInf((PLOADED_INF)InfHandle);

    return Policy;
}


VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );

DWORD
pSetupGetCurrentDriverSigningPolicy(
    IN BOOL IsDeviceInstallation
    )

/*++

Routine Description:

    (The following description describes the strategy behind the selection of
    policy.  The implementation, however, follows a few twists and turns due to
    unscupulous individuals who would subvert digital signature UI in order to
    avoid having to get their packages signed...)

    This routine returns a value indicating what action should be taken when a
    digital signature verification failure is encountered.  Separate "policies"
    are maintained for "DriverSigning" (i.e., device installer activities) and
    "NonDriverSigning" (i.e., everything else).

    For driver signing, there are actually 3 sources of policy:

        1.  HKLM\Software\Microsoft\Driver Signing : Policy : REG_BINARY (REG_DWORD also supported)
            This is a Windows 98-compatible value that specifies the default
            behavior which applies to all users of the machine.

        2.  HKCU\Software\Microsoft\Driver Signing : Policy : REG_DWORD
            This specifies the user's preference for what behavior to employ
            upon verification failure.

        3.  HKCU\Software\Policies\Microsoft\Windows NT\Driver Signing : BehaviorOnFailedVerify : REG_DWORD
            This specifies the administrator-mandated policy on what behavior
            to employ upon verification failure.  This policy, if specified,
            overrides the user's preference.

    The algorithm for deciding on the behavior to employ is as follows:

        if (3) is specified {
            policy = (3)
        } else {
            policy = (2)
        }
        policy = MAX(policy, (1))

    For non-driver signing, the algorithm is the same, except that values (1),
    (2), and (3) come from the following registry locations:

        1.  HKLM\Software\Microsoft\Non-Driver Signing : Policy : REG_BINARY (REG_DWORD also supported)

        2.  HKCU\Software\Microsoft\Non-Driver Signing : Policy : REG_DWORD

        3.  HKCU\Software\Policies\Microsoft\Windows NT\Non-Driver Signing : BehaviorOnFailedVerify : REG_DWORD

    NOTE:  If we're in non-interactive mode, policy is always Block, so we
           don't even bother trying to retrieve any of these registry settings.
           Another reason to avoid doing so is to keep from jumping to the
           wrong conclusion that someone has tampered with policy when in
           reality, we're in a service that loaded in GUI setup prior to the 
           time when the policy values were fully initialized.
          
Arguments:

    IsDeviceInstallation - If non-zero, then driver signing policy should be
        retrieved.  Otherwise, non-driver signing policy should be used.

Return Value:

    Value indicating the policy in effect.  May be one of the following three
    values:

        DRIVERSIGN_NONE    -  silently succeed installation of unsigned/
                              incorrectly-signed files.  A PSS log entry will
                              be generated, however (as it will for all 3 types)
        DRIVERSIGN_WARNING -  warn the user, but let them choose whether or not
                              they still want to install the problematic file
        DRIVERSIGN_BLOCKING - do not allow the file to be installed

    (If policy can't be retrieved from any of the sources described above, the
    default is DRIVERSIGN_NONE.)

--*/

{
    SYSTEMTIME RealSystemTime;
    DWORD PolicyFromReg, PolicyFromDS, RegDataType, RegDataSize;
    HKEY hKey;
    BOOL UserPolicyRetrieved = FALSE;
    WORD w;

    if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
        return DRIVERSIGN_BLOCKING;
    }

    w = IsDeviceInstallation?1:0;
    RealSystemTime.wDayOfWeek = (LOWORD(&hKey)&~4)|(w<<2);
    pSetupGetRealSystemTime(&RealSystemTime);
    PolicyFromReg = (((RealSystemTime.wMilliseconds+2)&15)^8)/4;
    MYASSERT(PolicyFromReg <= DRIVERSIGN_BLOCKING);

    //
    // Retrieve the user policy.  If policy isn't set for this user, then
    // retrieve the user's preference, instead.
    //
    PolicyFromDS = DRIVERSIGN_NONE;

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                     (IsDeviceInstallation ? pszDrvSignPolicyPath
                                                           : pszNonDrvSignPolicyPath),
                                     0,
                                     KEY_READ,
                                     &hKey))
    {
        RegDataSize = sizeof(PolicyFromDS);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey,
                                            pszDrvSignBehaviorOnFailedVerifyDS,
                                            NULL,
                                            &RegDataType,
                                            (PBYTE)&PolicyFromDS,
                                            &RegDataSize))
        {
            if((RegDataType == REG_DWORD) &&
               (RegDataSize == sizeof(DWORD)) &&
               ((PolicyFromDS == DRIVERSIGN_NONE) || (PolicyFromDS == DRIVERSIGN_WARNING) || (PolicyFromDS == DRIVERSIGN_BLOCKING)))
            {
                //
                // We successfully retrieved user policy, so we won't need to
                // retrieve user preference.
                //
                UserPolicyRetrieved = TRUE;
            }
        }

        RegCloseKey(hKey);
    }

    //
    // If we didn't find a user policy, then retrieve the user preference.
    //
    if(!UserPolicyRetrieved) {

        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                         (IsDeviceInstallation ? pszDrvSignPath
                                                               : pszNonDrvSignPath),
                                         0,
                                         KEY_READ,
                                         &hKey))
        {
            RegDataSize = sizeof(PolicyFromDS);
            if(ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                pszDrvSignPolicyValue,
                                                NULL,
                                                &RegDataType,
                                                (PBYTE)&PolicyFromDS,
                                                &RegDataSize))
            {
                if((RegDataType != REG_DWORD) ||
                   (RegDataSize != sizeof(DWORD)) ||
                   !((PolicyFromDS == DRIVERSIGN_NONE) || (PolicyFromDS == DRIVERSIGN_WARNING) || (PolicyFromDS == DRIVERSIGN_BLOCKING)))
                {
                    //
                    // Bogus entry for user preference--ignore it.
                    //
                    PolicyFromDS = DRIVERSIGN_NONE;

                }
            }

            RegCloseKey(hKey);
        }
    }

    //
    // Now return the more restrictive of the two policies.
    //
    if(PolicyFromDS > PolicyFromReg) {
        return PolicyFromDS;
    } else {
        return PolicyFromReg;
    }
}


DWORD
VerifySourceFile(
    IN  PSETUP_LOG_CONTEXT      LogContext,
    IN  PSP_FILE_QUEUE          Queue,                      OPTIONAL
    IN  PSP_FILE_QUEUE_NODE     QueueNode,                  OPTIONAL
    IN  PCTSTR                  Key,
    IN  PCTSTR                  FileToVerifyFullPath,
    IN  PCTSTR                  OriginalSourceFileFullPath, OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,            OPTIONAL
    IN  DWORD                   Flags,
    OUT SetupapiVerifyProblem  *Problem,
    OUT LPTSTR                  ProblemFile,
    OUT LPTSTR                  CatalogFileUsed,            OPTIONAL
    OUT LPTSTR                  DigitalSigner,              OPTIONAL
    OUT LPTSTR                  SignerVersion               OPTIONAL
    )

/*++

Routine Description:

    This routine verifies the digital signature of the specified file either
    globally (i.e., using all catalogs), or based on the catalog file specified
    in the supplied queue node.

Arguments:

    LogContext - supplies a context for logging the verify

    Queue - supplies pointer to the queue structure.  This contains information
        about the default verification method to use when the file isn't
        associated with a particular catalog.

    QueueNode - Optionally, supplies the queue node containing catalog
        information to be used when verifying the file's signature.  If not
        supplied, then the file will be verified using all applicable installed
        catalogs.  If this pointer is supplied, then so must the Queue
        parameter.

    Key - Supplies a value that "indexes" the catalog, telling the verify APIs
        which signature datum within the catalog it should use. Typically
        the key is the name of the destination file (sans path) that the source
        file is to be copied to.

    FileToVerifyFullPath - Supplies the full path of the file to be verified.

    OriginalSourceFileFullPath - Optionally, supplies the original source file's
        name, to be returned in the ProblemFile buffer when an error occurs.  If
        this parameter is not specified, then the source file's original name is
        assumed to be the same as the filename we're verifying, and the path
        supplied in FileToVerifyFullPath will be returned in the ProblemFile
        buffer in case of error.

    AltPlatformInfo - optionally, supplies alternate platform information used
        to fill in a DRIVER_VER_INFO structure (defined in sdk\inc\softpub.h)
        that is passed to WinVerifyTrust.

        **  NOTE:  This structure _must_ have its cbSize field set to        **
        **  sizeof(SP_ALTPLATFORM_INFO_V2) -- validation on client-supplied  **
        **  buffer is the responsibility of the caller.                      **

    Flags - supplies flags that alter that behavior of this routine.  May be a
        combination of the following values:

        VERIFY_FILE_IGNORE_SELFSIGNED - if this bit is set, then this routine
                                        will fail validation for self-signed
                                        binaries.

        VERIFY_FILE_USE_OEM_CATALOGS  - if this bit is set, then all catalogs
                                        installed in the system will be scanned
                                        to verify the given file.  Otherwise,
                                        OEM (3rd party) catalogs will NOT be
                                        scanned to verify the given file.  This
                                        is only applicable if a QueueNode
                                        specifying a specific catalog is not
                                        given.

        VERIFY_FILE_FAIL_COPIED_INFS  - if this bit is set, then INFs destined
                                        for %windir%\Inf will automatically
                                        fail verification.

        VERIFY_FILE_DRIVERBLOCKED_ONLY - Only check if the file is in the bad
                                         driver database, don't do any digital
                                         sigature validation.

    Problem - Points to a variable that will be filled in upon unsuccessful
        return with the cause of failure.

    ProblemFile - Supplies the address of a character buffer that will be filled
        in upon unsuccessful return to indicate the file that failed verification.
        This may be the name of the file we're verifying (or it's original name,
        if supplied), or it may be the name of the catalog used for verification,
        if the catalog itself isn't properly signed.  (The type of file can be
        ascertained from the value returned in the Problem output parameter.)

    CatalogFileUsed - if supplied, this parameter points to a character buffer
        at least MAX_PATH characters big that receives the name of the catalog
        file used to verify the specified file.  This is only filled in upon
        successful return, or when the Problem is SetupapiVerifyFileProblem
        (i.e., the catalog verified, but the file did not).  If this buffer is
        set to the empty string upon a SetupapiVerifyFileProblem failure, then
        we didn't find any applicable catalogs to use for validation.

        Also, this buffer will contain an empty string upon successful return
        if the file was validated without using a catalog (i.e., the file
        contains its own signature).

    DigitalSigner - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the name of who digitally
        signed the specified file. This value is only set if the Key is
        correctly signed (i.e. the function returns NO_ERROR).

    SignerVersion - if supplied, this parameter points to a character buffer of
        at least MAX_PATH characters that receives the the signer version as
        returned in the szwVerion field of the DRIVER_VER_INFO structure in
        our call to WinVerifyTrust.

Return Value:

    If successful, the return value is NO_ERROR;
    If unsuccessful, the return value is the Win32 error code indicating the
    cause of the failure.

--*/

{
    DWORD rc;
    PCTSTR AltCatalogFile;
    LPCTSTR InfFullPath;

    MYASSERT(!QueueNode || Queue);

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // Nobody had better be calling this expecting to get back any info
        // about a successful verification!
        //
        MYASSERT(!CatalogFileUsed);
        MYASSERT(!DigitalSigner);
        MYASSERT(!SignerVersion);

        return NO_ERROR;
    }

    //
    // If we know the file's destination (i.e., we have a QueueNode), and we've
    // been asked to fail any INFs headed for %windir%\Inf, we check for that
    // up-front.  We don't do this for exception packages, since it's assumed
    // (whether correctly or incorrectly) that they're "part of the OS", and as
    // such, they know what they're doing.
    //
    if(QueueNode && (Flags & VERIFY_FILE_FAIL_COPIED_INFS) &&
       !(Queue->Flags & FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES)) {

        TCHAR   TargetPath[MAX_PATH];
        LPCTSTR TargetFilename, p;

        //
        // Is the target file an INF?
        //
        TargetFilename = pSetupStringTableStringFromId(Queue->StringTable,
                                                       QueueNode->TargetFilename
                                                      );

        p = _tcsrchr(TargetFilename, TEXT('.'));

        if(p && !lstrcmpi(p, pszInfSuffix)) {
            //
            // It's an INF.  Construct the full target path to see where it's
            // going.
            //
            lstrcpyn(
                TargetPath,
                pSetupStringTableStringFromId(Queue->StringTable, QueueNode->TargetDirectory),
                SIZECHARS(TargetPath)
                );

            pSetupConcatenatePaths(TargetPath,
                                   TargetFilename,
                                   SIZECHARS(TargetPath),
                                   NULL
                                  );

            if(!pSetupInfIsFromOemLocation(TargetPath, TRUE)) {
                //
                // It is invalid to copy an INF into %windir%\Inf via a file
                // queue.  Report this file as unsigned...
                //
                *Problem = SetupapiVerifyIncorrectlyCopiedInf;
                lstrcpy(ProblemFile, FileToVerifyFullPath);

                return ERROR_INCORRECTLY_COPIED_INF;
            }
        }
    }

    //
    // Check to see if the source file is signed.
    //
    if(QueueNode && QueueNode->CatalogInfo) {
        //
        // We should never have the IQF_FROM_BAD_OEM_INF internal flag set in
        // this case.
        //
        MYASSERT(!(QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF));

        if(*(QueueNode->CatalogInfo->CatalogFilenameOnSystem)) {
            //
            // The fact that our catalog info node has a filename filled in
            // means we successfully verfied this catalog previously.  So
            // all we need _VerifyFile to do is just verify the temporary
            // (source) file against that catalog.
            //
            rc = _VerifyFile(LogContext,
                             &(Queue->hCatAdmin),
                             &(Queue->hSDBDrvMain),
                             QueueNode->CatalogInfo->CatalogFilenameOnSystem,
                             NULL,
                             0,
                             Key,
                             FileToVerifyFullPath,
                             Problem,
                             ProblemFile,
                             TRUE,
                             AltPlatformInfo,
                             Flags,
                             CatalogFileUsed,
                             NULL,
                             DigitalSigner,
                             SignerVersion
                            );
        } else {
            //
            // If there's no error associated with this catalog info node, then
            // that simply means that the INF didn't specify a CatalogFile=
            // entry, thus we should do global validation.  If there is an
            // error then we still need to check if the driver is in the bad
            // driver database.
            //
            // If the queue has an alternate default catalog file associated
            // with it, then retrieve that catalog's name for use later.
            //
            AltCatalogFile = (Queue->AltCatalogFile != -1)
                           ? pSetupStringTableStringFromId(Queue->StringTable, Queue->AltCatalogFile)
                           : NULL;

            rc = _VerifyFile(LogContext,
                             &(Queue->hCatAdmin),
                             &(Queue->hSDBDrvMain),
                             AltCatalogFile,
                             NULL,
                             0,
                             Key,
                             FileToVerifyFullPath,
                             Problem,
                             ProblemFile,
                             FALSE,
                             AltPlatformInfo,
                             Flags |
                             ((QueueNode->CatalogInfo->VerificationFailureError == NO_ERROR)
                               ? 0
                               : VERIFY_FILE_DRIVERBLOCKED_ONLY),
                             CatalogFileUsed,
                             NULL,
                             DigitalSigner,
                             SignerVersion
                            );

            if ((rc == NO_ERROR)  &&
                (QueueNode->CatalogInfo->VerificationFailureError != NO_ERROR)) {
                //
                // If there is an error associated with this catalog info node
                // and the file was not in the bad driver database then return
                // the error.
                //
                rc = QueueNode->CatalogInfo->VerificationFailureError;

                if(rc == ERROR_NO_CATALOG_FOR_OEM_INF) {
                    //
                    // The failure is the INF's fault (it's an OEM INF that
                    // copies files without specifying a catalog).  Blame the
                    // INF, not the file being copied.
                    //
                    *Problem = SetupapiVerifyInfProblem;
                    MYASSERT(QueueNode->CatalogInfo->InfFullPath != -1);
                    InfFullPath = pSetupStringTableStringFromId(
                                      Queue->StringTable,
                                      QueueNode->CatalogInfo->InfFullPath
                                      );
                    lstrcpy(ProblemFile, InfFullPath);

                } else {
                    //
                    // We previously failed to validate the catalog file
                    // associated with this queue node.
                    //
                    *Problem = SetupapiVerifyFileNotSigned;
                    //
                    // If the caller didn't supply us with an original source filepath
                    // (which will be taken care of later), go ahead and copy the path
                    // of the file that was to be verified.
                    //
                    if(!OriginalSourceFileFullPath) {
                        lstrcpy(ProblemFile, FileToVerifyFullPath);
                    }
                }
            }
        }

    } else {
        //
        // We have no queue, or we couldn't associate this source file back
        // to a catalog info node that tells us exactly which catalog to use
        // for verification.  Thus, we'll have to settle for global
        // validation.
        //
        BOOL InfIsBad = FALSE;
        rc = NO_ERROR;

        if(Queue) {

            if(Queue->AltCatalogFile == -1) {

                if(QueueNode && (QueueNode->InternalFlags & IQF_FROM_BAD_OEM_INF)) {
                    InfIsBad = TRUE;
                }

                AltCatalogFile = NULL;

            } else {
                //
                // We have an alternate catalog file to use instead of global
                // validation.
                //
                AltCatalogFile = pSetupStringTableStringFromId(Queue->StringTable, Queue->AltCatalogFile);
            }

        } else {
            AltCatalogFile = NULL;
        }

        rc = _VerifyFile(LogContext,
                         Queue ? &(Queue->hCatAdmin) : NULL,
                         Queue ? &(Queue->hSDBDrvMain) : NULL,
                         AltCatalogFile,
                         NULL,
                         0,
                         Key,
                         FileToVerifyFullPath,
                         Problem,
                         ProblemFile,
                         FALSE,
                         AltPlatformInfo,
                         Flags |
                         (InfIsBad ? VERIFY_FILE_DRIVERBLOCKED_ONLY : 0),
                         CatalogFileUsed,
                         NULL,
                         DigitalSigner,
                         SignerVersion
                        );

        if (rc == NO_ERROR) {
            if(InfIsBad) {
                //
                // The driver file was not blocked, but the INF was bad so set
                // the appropriate error and problem values.
                //
                rc = ERROR_NO_CATALOG_FOR_OEM_INF;
                *Problem = SetupapiVerifyFileProblem;
                lstrcpy(ProblemFile, FileToVerifyFullPath);
            }
        }
    }

    //
    // If the problem was with the file (as opposed to with the catalog), then
    // use the real source name, if supplied, as opposed to the temporary
    // filename we passed into _VerifyFile.
    //
    if((rc != NO_ERROR) && OriginalSourceFileFullPath &&
       ((*Problem == SetupapiVerifyFileNotSigned) || (*Problem == SetupapiVerifyFileProblem))) {

        lstrcpy(ProblemFile, OriginalSourceFileFullPath);
    }

    return rc;
}


BOOL
VerifyDeviceInfFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin,              OPTIONAL
    IN     LPCTSTR                 CurrentInfName,
    IN     PLOADED_INF             pInf,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion           OPTIONAL
    )
/*++

Routine Description:

    This routine performs a digital signature verification on the specified
    INF file.

Arguments:

    LogContext - supplies the log context to be used in logging an error if
        we encounter an error.

    hCatAdmin - optionally, supplies the address of an HCATADMIN handle.  If
        the handle pointed to is NULL, a handle will be acquired (if possible)
        via CryptCATAdminAcquireContext and returned to the caller.  If the
        handle pointed to is non-NULL, then that handle will be used for any
        validation done via this routine.  If the pointer itself is NULL, then
        an hCatAdmin will be acquired for the duration of this call, and
        released before returning.

        NOTE: it is the caller's responsibility to free the crypto context
        handle returned by this routine by calling CryptCATAdminReleaseContext.
        This handle may be opened in either success or failure cases, so the
        caller must check for non-NULL returned handle in both cases.

    CurrentInfName - supplies the full path to the INF to be validated

    pInf - supplies a pointer to the LOADED_INF structure corresponding to this
        INF.

    AltPlatformInfo - optionally, supplies alternate platform information to
        be used when validating this INF.

    CatalogFileUsed - optionally, supplies a character buffer that must be at
        least MAX_PATH characters in size.  Upon successful return, this buffer
        will be filled in with the catalog file used to validate the INF.

    DigitalSigner - optionally, supplies a character buffer that must be at
        least MAX_PATH characters in size.  Upon successful return, this buffer
        will be filled in with the name of the signer.

    SignerVersion - optionally, supplies a character buffer that must be at
        least MAX_PATH characters in size.  Upon successful return, this buffer
        will be filled in with the signer version information.

Return Value:

    If the INF's signature is successfully verified, the return value is
    non-zero (TRUE).
    Otherwise, the return value is FALSE.  GetLastError can be used to obtain
    the Win32 error code indicating the cause of failure.

--*/
{
    BOOL DifferentOriginalName;
    TCHAR OriginalCatalogName[MAX_PATH];
    TCHAR CatalogPath[MAX_PATH];
    TCHAR OriginalInfFileName[MAX_PATH];
    DWORD Err;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // Nobody had better be calling this expecting to get back any info
        // about a successful verification!
        //
        MYASSERT(!CatalogFileUsed);
        MYASSERT(!DigitalSigner);
        MYASSERT(!SignerVersion);

        return TRUE;
    }

    if(GlobalSetupFlags & PSPGF_AUTOFAIL_VERIFIES) {
        SetLastError(TRUST_E_FAIL);
        return FALSE;
    }

    CatalogPath[0] = TEXT('\0');

    Err = pGetInfOriginalNameAndCatalogFile(pInf,
                                            NULL,
                                            &DifferentOriginalName,
                                            OriginalInfFileName,
                                            SIZECHARS(OriginalInfFileName),
                                            OriginalCatalogName,
                                            SIZECHARS(OriginalCatalogName),
                                            AltPlatformInfo
                                           );

    if(Err != NO_ERROR) {
        SetLastError(Err);
        return FALSE;
    }

    if(pSetupInfIsFromOemLocation(CurrentInfName, TRUE)) {
        //
        // INF isn't in %windir%\Inf (i.e., it's 3rd-party), so it had better
        // specify a catalog file...
        //
        if(!*OriginalCatalogName) {
            SetLastError(ERROR_NO_CATALOG_FOR_OEM_INF);
            return FALSE;
        }

        //
        // ...and the CAT must reside in the same directory as the INF.
        //
        lstrcpy(CatalogPath, CurrentInfName);
        lstrcpy((PTSTR)pSetupGetFileTitle(CatalogPath), OriginalCatalogName);

    } else {
        //
        // The INF lives in %windir%\Inf.
        // If it is a 3rd party INF then we want to set the CatalogPath to
        // the current INF name with .CAT at the end instead of .INF (e.g
        // oem1.cat).  If this is not an OEM catalog then we won't set the
        // CatalogPath so we can search all of the catalogs in the system.
        //
        // We will assume that if the INF had a different original name.
        //
        if (DifferentOriginalName) {
            lstrcpy(CatalogPath, pSetupGetFileTitle(CurrentInfName));
            lstrcpy(_tcsrchr(CatalogPath, TEXT('.')), pszCatSuffix);
        }
    }

    if(DifferentOriginalName) {
        MYASSERT(*OriginalInfFileName);
    } else {
        //
        // INF's current name is the same as its original name, so store the
        // simple filename (sans path) for use as the validation key in the
        // upcoming call to _VerifyFile.
        //
        lstrcpy(OriginalInfFileName, pSetupGetFileTitle(CurrentInfName));
    }

    //
    // If the caller didn't supply alternate platform information, we need to
    // check and see whether a range of OSATTR versions should be considered
    // valid for this INF's class.
    //
    if(!AltPlatformInfo) {

        IsInfForDeviceInstall(LogContext,
                              NULL,
                              pInf,
                              NULL,
                              &ValidationPlatform,
                              NULL,
                              NULL
                             );
    } else {
        ValidationPlatform = NULL;
    }

    Err = _VerifyFile(LogContext,
                      hCatAdmin,
                      NULL,
                      (*CatalogPath ? CatalogPath : NULL),
                      NULL,
                      0,
                      OriginalInfFileName,
                      CurrentInfName,
                      NULL,
                      NULL,
                      FALSE,
                      (AltPlatformInfo ? AltPlatformInfo : ValidationPlatform),
                      (VERIFY_FILE_IGNORE_SELFSIGNED
                       | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                      CatalogFileUsed,
                      NULL,
                      DigitalSigner,
                      SignerVersion);

    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }

    SetLastError(Err);

    return (Err == NO_ERROR);
}


BOOL
IsFileProtected(
    IN  LPCTSTR            FileFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    OUT PHANDLE            phSfp         OPTIONAL
    )
/*++

Routine Description:

    This routine determines whether the specified file is a protected system
    file.

Arguments:

    FileFullPath - supplies the full path to the file of interest

    LogContext - supplies the log context to be used in logging an error if
        we're unable to open an SFC handle.

    phSfp - optionally, supplies the address of a handle variable that will be
        filled in with a handle to the SFC server.  This will only be supplied
        when the routine returns TRUE (i.e., the file is SFP-protected).

Return Value:

    If the file is protected, the return value is TRUE, otherwise it is FALSE.

--*/
{
    BOOL ret;

#ifdef UNICODE
    HANDLE hSfp;

    hSfp = SfcConnectToServer(NULL);

    if(!hSfp) {
        //
        // This ain't good...
        //
        WriteLogEntry(LogContext,
                      SETUP_LOG_ERROR,
                      MSG_LOG_SFC_CONNECT_FAILED,
                      NULL
                     );

        return FALSE;
    }

    try {
        ret = SfcIsFileProtected(hSfp, FileFullPath);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }

    //
    // If the file _is_ protected, and the caller wants the SFP handle (e.g.,
    // to subsequently exempt an unsigned replacement operation), then save
    // the handle in the caller-supplied buffer.  Otherwise, close the handle.
    //
    if(ret && phSfp) {
        *phSfp = hSfp;
    } else {
        SfcClose(hSfp);
    }

#else // no file protection on Win9x
    ret = FALSE;
#endif

    return ret;
}

PSTR
GetAnsiMuiSafePathname(
    IN  PCTSTR      FilePath
    )
/*++

Routine Description:

    Remove filename portion of FilePath
    and convert rest of path to be MUI parse safe
    Note that the returned pathname is such that the FileName can be cat'd
    so for "E:\i386\myfile.dl_" FilePath = "E:\i386\" and FileName = "myfile.dl_"

    *This is required* (it also happens to make this code easier)

Arguments:

    FilePath - path+filename to convert

Return Value:

    If successful, the return value is pointer to ANSI filepath (memory allocated by pSetupMalloc)
    If unsuccessful, the return value is NULL and GetLastError returns error

--*/
{
    TCHAR Buffer[MAX_PATH];
    LPTSTR FilePart;
    DWORD actsz;

    actsz = GetFullPathName(FilePath,MAX_PATH,Buffer,&FilePart);
    if(actsz == 0) {
        //
        // GetLastError has error
        //
        return NULL;
    }
    if(actsz >= MAX_PATH) {
        //
        // can't do anything with this path
        //
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }
    if(FilePart==NULL) {
        Buffer[0] = TEXT('\0');
    } else {
        FilePart[0] = TEXT('\0');
    }
    return GetAnsiMuiSafeFilename(Buffer);
}


#ifdef UNICODE

PSTR
GetAnsiMuiSafeFilename(
    IN  PCTSTR      FilePath
    )
/*++

Routine Description:

    Convert FilePath, which is a native file path to one that is safe to parse
    by ansi API's in an MUI environment.

    returned pointer is allocated and should be free'd

Arguments:

    FilePath - path to convert

Return Value:

    If successful, the return value is pointer to ANSI filepath (memory allocated by pSetupMalloc)
    If unsuccessful, the return value is NULL and GetLastError returns error

--*/
{
    TCHAR Buffer[MAX_PATH];
    PTSTR p;
    PSTR ansiPath;
    DWORD actsz;
    DWORD err;

    actsz = GetShortPathName(FilePath,Buffer,MAX_PATH);
    if(actsz >= MAX_PATH) {
        //
        // file path too big
        //
        SetLastError(ERROR_INVALID_DATA);
        return NULL;
    }
    if(!actsz)
    {
        //
        // some other error - resort back to current path name
        //
        lstrcpyn(Buffer,FilePath,MAX_PATH);
    }
    //
    // convert to ansi now we've (if we can) converted to short path name
    //
    ansiPath = pSetupUnicodeToAnsi(Buffer);
    if(!ansiPath) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }
    return ansiPath;
}

#else

PSTR
GetAnsiMuiSafeFilename(
    IN  PCTSTR      FilePath
    )
/*++

Routine Description:

    See above, this is almost a no-op in ANSI

Arguments:

    FilePath - supplies a context for logging the verify

Return Value:

    If successful, the return value is pointer to ANSI filepath (memory allocated by pSetupMalloc)
    If unsuccessful, the return value is NULL and GetLastError returns error

--*/
{
    PSTR res = DuplicateString(FilePath);
    if(!res) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return res;
}

#endif

BOOL
pSetupAppendPath(
    IN  PCTSTR  Path1,
    IN  PCTSTR  Path2,
    OUT PTSTR*  Combined
    )
/*++

Routine Description:

    Call pSetupConcatenatePaths
    dynamically modifying memory/pointer

Arguments:

    Path1/Path2 - to concatenate
    Combined    - resultant path


Return Value:

    TRUE if the full path fit in Target buffer. Otherwise the path
    not created.

--*/
{
    PTSTR FinalPath;
    UINT Len;

    if(!Path1 && !Path2) {
        *Combined = NULL;
        return TRUE;
    }
    if(!Path1) {
        *Combined = DuplicateString(Path2);
        return *Combined ? TRUE : FALSE;
    }
    if(!Path2) {
        *Combined = DuplicateString(Path1);
        return *Combined ? TRUE : FALSE;
    }

    Len = lstrlen(Path1)+lstrlen(Path2)+2; // slash and null

    FinalPath = MyMalloc(Len*sizeof(TCHAR));
    if(!FinalPath) {
        *Combined = NULL;
        return FALSE;
    }
    lstrcpy(FinalPath,Path1);
    if(!pSetupConcatenatePaths(FinalPath,Path2,Len,NULL)) {
        MyFree(FinalPath);
        *Combined = NULL;
        return FALSE;
    }
    *Combined = FinalPath;
    return TRUE;
}

BOOL
pSetupApplyExtension(
    IN  PCTSTR  Original,
    IN  PCTSTR  Extension,
    OUT PTSTR*  NewName
    )
/*++

Routine Description:

    Apply Extension onto Original to obtain NewName

Arguments:

    Original    - original name with old extension
    Extension   - new extension to apply (with or without dot)
    NewName     - allocated buffer containing new filename


Return Value:

    TRUE if the full path fit in Target buffer. Otherwise the path
    not created.

--*/
{
    PCTSTR End = Original+lstrlen(Original);
    PCTSTR OldExt = End;
    PTSTR NewString = NULL;
    TCHAR c;
    UINT len;
    UINT sublen;
    if(Extension && (Extension[0] == TEXT('.'))) {
        Extension++;
    }

    while(End!= Original) {
        End = CharPrev(Original,End);
        if((*End == TEXT('/')) || (*End == TEXT('\\'))) {
            break;
        }
        if(*End == TEXT('.')) {
            OldExt = End;
            break;
        }
    }
    sublen = (UINT)(OldExt-Original);
    len = sublen + lstrlen(Extension) + 2;
    NewString = MyMalloc(len*sizeof(TCHAR));
    if(!NewString) {
        *NewName = NULL;
        return FALSE;
    }
    memcpy(NewString,Original,(sublen)*sizeof(TCHAR));
    NewString[sublen++] = Extension ? TEXT('.') : TEXT('\0');
    if(Extension) {
        lstrcpy(NewString+sublen,Extension);
    }
    *NewName = NewString;
    return TRUE;
}


BOOL
ClassGuidInDrvSignPolicyList(
    IN  PSETUP_LOG_CONTEXT       LogContext,           OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid,
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform    OPTIONAL
    )

/*++

Routine Description:

    This routine determines whether the specified device setup class is among
    the list of classes for which driver signing policy is applicable (i.e., as
    indicated by the class's inclusion in the [DriverSigningClasses] section of
    %windir%\Inf\certclas.inf).  Additionally, if an non-native signature
    validation lower-bound is applicable, a newly-allocated alternate platform
    info structure is returned to the caller (if requested) to be used in
    subsequent validation attempts associated with this class.

Arguments:

    LogContext - Optionally, supplies the log context for any log entries that
        might be generated by this routine.

    DeviceSetupClassGuid - Supplies the address of the GUID we're attempting to
        find in our driver signing policy list.

    ValidationPlatform - Optionally, supplies the address of a (version 2)
        altplatform info pointer (initialized to NULL) that is filled in upon
        return with a newly-allocated structure specifying the appropriate
        parameters to be passed to WinVerifyTrust when validating this INF.
        These parameters are retrieved from certclas.inf for the relevant
        device setup class GUID.  If no special parameters are specified for
        this class (or if the INF has no class at all), then this pointer is
        not modified (i.e., left as NULL) causes us to use WinVerifyTrust's
        default validation.  Note that if we fail to allocate this structure
        due to low-memory, the pointer will be left as NULL in that case as
        well.  This is OK, because this simply means we'll do default
        validation in that case.

        The caller is responsible for freeing the memory allocated for this
        structure.

Return Value:

    If the device setup class is in our driver signing policy list, the return
    value is non-zero (TRUE).  Otherwise, it is FALSE.

--*/

{
    DWORD Err;
    BOOL UseDrvSignPolicy;
    INT i;
    TCHAR CertClassInfPath[MAX_PATH];
    HINF hCertClassInf = INVALID_HANDLE_VALUE;
    INFCONTEXT InfContext;
    UINT ErrorLine;
    LONG LineCount;
    PCTSTR GuidString;

    //
    // Default is to lump all device installs under driver signing policy
    //
    UseDrvSignPolicy = TRUE;

    //
    // If the caller supplied the ValidationPlatform parameter it must be
    // pointing to a NULL pointer...
    //
    MYASSERT(!ValidationPlatform || !*ValidationPlatform);

    if(LockDrvSignPolicyList(&GlobalDrvSignPolicyList)) {

        if(GlobalDrvSignPolicyList.NumMembers == -1) {
            //
            // We've not yet retrieved the list from certclas.inf.  First,
            // verify the INF to make sure no one has tampered with it...
            //
            lstrcpyn(CertClassInfPath, InfDirectory,SIZECHARS(CertClassInfPath)-13);
            lstrcat(CertClassInfPath, TEXT("\\certclas.inf"));

            Err = _VerifyFile(LogContext,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              0,
                              pSetupGetFileTitle(CertClassInfPath),
                              CertClassInfPath,
                              NULL,
                              NULL,
                              FALSE,
                              NULL,
                              (VERIFY_FILE_IGNORE_SELFSIGNED | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                              NULL,
                              NULL,
                              NULL,
                              NULL
                             );

            if(Err == NO_ERROR) {
                //
                // Open up driver signing class list INF for use when examining
                // the individual INFs in the LOADED_INF list below.
                //
                hCertClassInf = SetupOpenInfFile(CertClassInfPath,
                                                 NULL,
                                                 INF_STYLE_WIN4,
                                                 &ErrorLine
                                                );

                if(hCertClassInf == INVALID_HANDLE_VALUE) {
                    //
                    // This failure is highly unlikely to occur, since we just got
                    // through validating the INF.
                    //
                    Err = GetLastError();

                    WriteLogEntry(LogContext,
                                  SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                                  MSG_LOG_CERTCLASS_LOAD_FAILED,
                                  NULL,
                                  CertClassInfPath,
                                  ErrorLine
                                 );
                }

            } else {

                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              MSG_LOG_CERTCLASS_INVALID,
                              NULL,
                              CertClassInfPath
                             );
            }

            if(Err != NO_ERROR) {
                //
                // Somebody mucked with/deleted certclas.inf!  (Or, much less
                // likely, we encountered some other failure whilst trying to
                // load the INF.)  Since we don't know which classes are
                // subject to driver signing policy, we assume they all are.
                //
                WriteLogError(LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              Err
                             );

                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_DRIVER_SIGNING_FOR_ALL_CLASSES,
                              NULL
                             );

                //
                // Set the NumMembers field to zero, so we'll know we
                // previously attempted (and failed) to retrieve the list.  We
                // do this so we don't keep re-trying to get this list.
                //
                GlobalDrvSignPolicyList.NumMembers = 0;

            } else {
                //
                // Certclas.inf validated, and we successfully opened it.  Now
                // retrieve the list contained therein.
                //
                LineCount = SetupGetLineCount(hCertClassInf,
                                              pszDriverSigningClasses
                                             );

                if((LineCount > 0) &&
                   (NULL != (GlobalDrvSignPolicyList.Members = MyMalloc(LineCount * sizeof(DRVSIGN_CLASS_LIST_NODE))))) {

                    if(SetupFindFirstLine(hCertClassInf,
                                          pszDriverSigningClasses,
                                          NULL,
                                          &InfContext)) {

                        i = 0;

                        do {

                            MYASSERT(i < LineCount);

                            //
                            // The format of a line in the [DriverSigningClasses]
                            // section is as follows:
                            //
                            // {GUID} [= FirstValidatedMajorVersion, FirstValidatedMinorVersion]
                            //
                            GuidString = pSetupGetField(&InfContext, 0);

                            if(GuidString &&
                               (NO_ERROR == pSetupGuidFromString(GuidString, &(GlobalDrvSignPolicyList.Members[i].DeviceSetupClassGuid)))) {

                                if(SetupGetIntField(&InfContext, 1, &(GlobalDrvSignPolicyList.Members[i].MajorVerLB)) &&
                                   SetupGetIntField(&InfContext, 2, &(GlobalDrvSignPolicyList.Members[i].MinorVerLB))) {
                                    //
                                    // We successfully retrieved major/minor
                                    // version info for validation lower-bound.
                                    // Do a sanity-check on these.
                                    //
                                    if(GlobalDrvSignPolicyList.Members[i].MajorVerLB <= 0) {

                                        GlobalDrvSignPolicyList.Members[i].MajorVerLB = -1;
                                        GlobalDrvSignPolicyList.Members[i].MinorVerLB = -1;
                                    }

                                } else {
                                    //
                                    // Set major/minor version info to -1 to
                                    // indicate there's no validation platform
                                    // override.
                                    //
                                    GlobalDrvSignPolicyList.Members[i].MajorVerLB = -1;
                                    GlobalDrvSignPolicyList.Members[i].MinorVerLB = -1;
                                }

                                i++;
                            }

                        } while(SetupFindNextLine(&InfContext, &InfContext));

                        //
                        // Update NumMembers field in our list to indicate the
                        // number of class GUID entries we actually found.
                        //
                        GlobalDrvSignPolicyList.NumMembers = i;
                    }
                }

                SetupCloseInfFile(hCertClassInf);
            }
        }

        //
        // We now have a list.  If the list is empty, this means we
        // encountered some problem retrieving the list, thus all device
        // classes should be subject to driver signing policy.  Otherwise,
        // try to find the caller-specified class in our list.
        //
        if(GlobalDrvSignPolicyList.NumMembers) {
            //
            // OK, we know we have a valid list--now default to non-driver
            // signing policy unless our list search proves fruitful.
            //
            UseDrvSignPolicy = FALSE;

            for(i = 0; i < GlobalDrvSignPolicyList.NumMembers; i++) {

                if(!memcmp(DeviceSetupClassGuid,
                           &(GlobalDrvSignPolicyList.Members[i].DeviceSetupClassGuid),
                           sizeof(GUID))) {
                    //
                    // We found a match!
                    //
                    UseDrvSignPolicy = TRUE;

                    //
                    // Now, check to see if we have any validation platform
                    // override info...
                    //
                    if(ValidationPlatform &&
                       (GlobalDrvSignPolicyList.Members[i].MajorVerLB != -1)) {

                        MYASSERT(GlobalDrvSignPolicyList.Members[i].MinorVerLB != -1);

                        *ValidationPlatform = MyMalloc(sizeof(SP_ALTPLATFORM_INFO_V2));

                        //
                        // If the memory allocation fails, we just won't report
                        // the altplatform info, so the validation will be done
                        // based on the current OS version (instead of widening
                        // it up to allow a range of valid versions).
                        //
                        if(*ValidationPlatform) {
                            ZeroMemory(*ValidationPlatform, sizeof(SP_ALTPLATFORM_INFO_V2));

                            (*ValidationPlatform)->cbSize = sizeof(SP_ALTPLATFORM_INFO_V2);
                            (*ValidationPlatform)->Platform = VER_PLATFORM_WIN32_NT;
                            (*ValidationPlatform)->Flags = SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
                            (*ValidationPlatform)->MajorVersion = VER_PRODUCTMAJORVERSION;
                            (*ValidationPlatform)->MinorVersion = VER_PRODUCTMINORVERSION;

                            (*ValidationPlatform)->ProcessorArchitecture =
#if defined(_AXP64_)
                                PROCESSOR_ARCHITECTURE_ALPHA64;
#elif defined(_ALPHA_)
                                PROCESSOR_ARCHITECTURE_ALPHA;
#elif defined(_MIPS_)
                                PROCESSOR_ARCHITECTURE_MIPS;
#elif defined(_PPC_)
                                PROCESSOR_ARCHITECTURE_PPC;
#elif defined(_X86_)
                                PROCESSOR_ARCHITECTURE_INTEL;
#elif defined(_IA64_)
                                PROCESSOR_ARCHITECTURE_IA64;
#elif defined(_AMD64_)
                                PROCESSOR_ARCHITECTURE_AMD64;
#else
#error "no target architecture"
#endif

                            (*ValidationPlatform)->FirstValidatedMajorVersion
                                = (DWORD)(GlobalDrvSignPolicyList.Members[i].MajorVerLB);

                            (*ValidationPlatform)->FirstValidatedMinorVersion
                                = (DWORD)(GlobalDrvSignPolicyList.Members[i].MinorVerLB);
                        }
                    }

                    //
                    // Since we've found a match, we can break out of the loop.
                    //
                    break;
                }
            }
        }

        UnlockDrvSignPolicyList(&GlobalDrvSignPolicyList);
    }

    return UseDrvSignPolicy;
}


BOOL
InitDrvSignPolicyList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the global "Driver Signing Policy" list that is
    retrieved (on first use) from %windir%\Inf\certclas.inf.

Arguments:

    None

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    ZeroMemory(&GlobalDrvSignPolicyList, sizeof(DRVSIGN_POLICY_LIST));
    GlobalDrvSignPolicyList.NumMembers = -1;
    return InitializeSynchronizedAccess(&GlobalDrvSignPolicyList.Lock);
}


VOID
DestroyDrvSignPolicyList(
    VOID
    )
/*++

Routine Description:

    This routine destroys the global "Driver Signing Policy" list that is
    retrieved (on first use) from %windir%\Inf\certclas.inf.

Arguments:

    None

Return Value:

    None

--*/
{
    if(LockDrvSignPolicyList(&GlobalDrvSignPolicyList)) {
        if(GlobalDrvSignPolicyList.Members) {
            MyFree(GlobalDrvSignPolicyList.Members);
        }
        DestroySynchronizedAccess(&GlobalDrvSignPolicyList.Lock);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\helpids.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    helpids.h

Abstract:

    Private header file defining help id's for dialogs.

Author:

    Jamie Hunter (jamiehun) Aug 20 1998

Revision History:

--*/

#define IDH_NOHELP  ((DWORD) -1) // Disables Help for a control (for help compiles)

//
// Main property page on the Resources tab
// Created 5/11/98 by WGruber NTUA, JamieHun NTDEV
// also see DevResHelpIDs in DevRes.c
// dialog IDD_DEF_DEVRESOURCE_PROP
//

#define IDH_DEVMGR_RESOURCES_SETTINGS   2001100
#define IDH_DEVMGR_RESOURCES_BASEDON    2001110
#define IDH_DEVMGR_RESOURCES_CHANGE     2001120
#define IDH_DEVMGR_RESOURCES_AUTO       2001130
#define IDH_DEVMGR_RESOURCES_CONFLICTS  2001140
#define IDH_DEVMGR_RESOURCES_PARENT     2001150
#define IDH_DEVMGR_RESOURCES_SETMANUALLY 2001160

//
// Edit property page invoked from Resources tab
// Created 5/11/98 by WGruber NTUA, JamieHun NTDEV
// also see EditResHelpIDs in DevRes1.c
// dialog IDD_EDIT_RESOURCE
//

#define IDH_DEVMGR_RESOURCES_EDIT_VALUE 2100100
#define IDH_DEVMGR_RESOURCES_EDIT_INFO  2100110

//
// Select device dialog box.
// dialog DLG_DEINSTALL
//
#define IDH_DEVMGR_SELECTDEVICE_MANUFACTURER	    109010
#define IDH_DEVMGR_SELECTDEVICE_MODEL		        109020
#define IDH_DEVMGR_SELECTDEVICE_SHOWCOMPATIBLE	    109030
#define IDH_DEVMGR_SELECTDEVICE_SHOWALLHARDWARE	    109040
#define IDH_DEVMGR_SELECTDEVICE_SHOWSIMILARHARDWARE	109050
#define IDH_DEVMGR_SELECTDEVICE_WINDOWSUPDATE	    109060
#define IDH_DEVMGR_SELECTDEVICE_HAVEDISK            109070
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infcache.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    infcache.h

Abstract:

    Private header for INFCACHE functions/structures
    (See also infcache.c)

Author:

    Jamie Hunter (jamiehun) Jan-27-2000

Revision History:

--*/

#define INFCACHE_VERSION (1)                // increment for every schema change
#define INFCACHE_NAME_TEMPLATE TEXT("INFCACHE.%d")   // name of cache file (number fills last 3 digits)
#define OLDCACHE_NAME_TEMPLATE TEXT("OLDCACHE.%03d")   // old cache file
#define INFCACHE_INF_WILDCARD  TEXT("*.inf")

//
// file layout is:
//
// CACHEHEADER
// <MatchTable>
// <InfTable>
// <ListData>
//
// file size = sizeof(CACHEHEADER) + MatchTableSize + InfTableSize + ListDataCount*sizeof(CACHELISTENTRY)
// first entry of <ListData> is reference to free-list
//

#include "pshpack1.h"

typedef struct tag_CACHEHEADER {
    ULONG Version;                          // indicates file schema
    LCID Locale;                            // locale (as written)
    DWORD Flags;                            // various flags
    ULONG FileSize;                         // size of file, including header
    ULONG MatchTableOffset;                 // offset of match table portion (allowing for alignment)
    ULONG MatchTableSize;                   // size of match table portion
    ULONG InfTableOffset;                   // offset of inf table portion (allowing for alignment)
    ULONG InfTableSize;                     // size of inf table portion
    ULONG ListDataOffset;                   // offset of list data portion (allowing for alignment)
    ULONG ListDataCount;                    // number of list data items
} CACHEHEADER, * PCACHEHEADER;

//
// MatchTable datum
//
typedef struct tag_CACHEMATCHENTRY {
    ULONG InfList;                          // index into ListTable of list of "hit" INFs
} CACHEMATCHENTRY, * PCACHEMATCHENTRY;

//
// InfTable datum
//
typedef struct tag_CACHEINFENTRY {
    FILETIME FileTime;                      // exactly same as FileTime saved in PNF
    ULONG MatchList;                        // into ListTable (first entry is GUID) cross-link of references to INF
    ULONG MatchFlags;                       // various flags to help expand/reduce search criteria
} CACHEINFENTRY, * PCACHEINFENTRY;
//
// special MatchList values
//
#define CIE_INF_INVALID         (ULONG)(-1) // indicates INF entry is outdated

#define CIEF_INF_NOTINF         0           // if flags is zero, this is not a valid INF
#define CIEF_INF_OLDNT          0x00000001  // indicates INF is old-style (Style == INF_STYLE_OLDNT)
#define CIEF_INF_WIN4           0x00000002  // indicates INF is Win4 style (Style == INF_STYLE_WIN4)
#define CIEF_INF_ISINF          (CIEF_INF_OLDNT|CIEF_INF_WIN4)
#define CIEF_INF_URL            0x00000004  // indicates INF InfSourceMediaType == SPOST_URL
#define CIEF_INF_CLASSNAME      0x00000008  // indicates INF has a Class Name (or Legacy name if OLDNT)
#define CIEF_INF_CLASSGUID      0x00000010  // indicates INF has a Class GUID
#define CIEF_INF_CLASSINFO      (CIEF_INF_CLASSNAME|CIEF_INF_CLASSGUID)
#define CIEF_INF_NULLGUID       0x00000020  // indicates INF has a Class GUID of {0}
#define CIEF_INF_MANUFACTURER   0x00000040  // indicates INF has at least one manufacturer

//
// CacheList datum
//
typedef struct tag_CACHELISTENTRY {
    LONG Value;                             // Typically StringID. For HWID/GUID, index into MatchTable. for INF, index into InfTable
    ULONG Next;                             // index to next entry
} CACHELISTENTRY, * PCACHELISTENTRY;

#include "poppack.h"

//
// Run-Time cache information
//

typedef struct tag_INFCACHE {
    HANDLE FileHandle;                      // information regarding the in-memory image of the cache file
    HANDLE MappingHandle;
    PVOID BaseAddress;

    PCACHEHEADER pHeader;                   // pointer to header in file image
    PVOID pMatchTable;                      // pointer to match table
    PVOID pInfTable;                        // pointer to inf table
    PCACHELISTENTRY pListTable;             // pointer to list table
    ULONG ListDataAlloc;                    // how much space is allocated, >= ListDataCount
    PVOID pSearchTable;                     // transient table to handle search state
    BOOL bReadOnly;                         // set if this is mapped, unset if allocated
    BOOL bDirty;                            // set if modified
    BOOL bNoWriteBack;                      // set if we shouldn't write cache (a failure occured so cache isn't good)
} INFCACHE, * PINFCACHE;

#define CHE_FLAGS_PENDING     0x00000001    // set if file is yet to be processed
#define CHE_FLAGS_GUIDMATCH   0x00000002    // set if during search pass we consider this a GUID MATCH
#define CHE_FLAGS_IDMATCH     0x00000004    // set if during search pass we got at least one ID MATCH

//
// SearchTable data
//
typedef struct tag_CACHEHITENTRY {
    ULONG Flags;                            // CHE_FLAGS_xxxx
} CACHEHITENTRY, * PCACHEHITENTRY;

//
// callback
//
typedef BOOL (CALLBACK * InfCacheCallback)(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR InfPath,
    IN PLOADED_INF pInf,
    IN BOOL PnfWasUsed,
    IN PVOID Context
    );

//
// stringtable callback for INF enumeration
//
typedef struct tag_INFCACHE_ENUMDATA {
    PSETUP_LOG_CONTEXT LogContext;
    PCTSTR InfDir;
    InfCacheCallback Callback;
    PVOID Context;
    ULONG Requirement;
    DWORD ExitStatus;
} INFCACHE_ENUMDATA, *PINFCACHE_ENUMDATA;

//
// action flags
//
#define INFCACHE_DEFAULT     0x00000000      // default operation
#define INFCACHE_REBUILD     0x00000001      // ignore existing cache
#define INFCACHE_NOWRITE     0x00000002      // don't write back
#define INFCACHE_ENUMALL     0x00000003      // special combination, just enum all
#define INFCACHE_ACTIONBITS  0x000000FF      // primary action bits

#define INFCACHE_EXC_OLDINFS   0x00000100    // exclude INFs that are OLDNT
#define INFCACHE_EXC_URL       0x00000200    // exclude INFs that are marked SPOST_URL
#define INFCACHE_EXC_NOCLASS   0x00000400    // excludes INFs that has no class information
#define INFCACHE_EXC_NULLCLASS 0x00000800    // excludes INFs that has null class
#define INFCACHE_EXC_NOMANU    0x00001000    // excludes INFs that has no (or empty) [Manufacturers] - ignored for OLDNT

#define INFCACHE_FORCE_CACHE 0X00010000      // (try and) force cache creating even if "OEM dir"
#define INFCACHE_FORCE_PNF   0X00020000      // (try and) force PNF creating even if "OEM dir"


DWORD InfCacheSearchPath(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN DWORD Action,
    IN PCTSTR InfDirPath, OPTIONAL
    IN InfCacheCallback Callback, OPTIONAL
    IN PVOID Context, OPTIONAL
    IN PCTSTR ClassId, OPTIONAL
    IN PCTSTR HwIdList OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infcache.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    infcache.c

Abstract:

    INF Cache management functions

Author:

    Jamie Hunter (jamiehun) Jan-27-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define BOUNDSCHECK(base,size,limit) ( \
                ((base)<=(limit)) && \
                ((size)<=(limit)) && \
                ((base+size)<=(limit)) && \
                ((base+size)>=(base)))

//
// Macros used to quadword-align Cache blocks.
//
#define CACHE_ALIGNMENT      ((DWORD)8)
#define CACHE_ALIGN_MASK     (~(DWORD)(CACHE_ALIGNMENT - 1))
#define CACHE_ALIGN_BLOCK(x) ((x & CACHE_ALIGN_MASK) + ((x & ~CACHE_ALIGN_MASK) ? CACHE_ALIGNMENT : 0))

BOOL
AlignForNextBlock(
    IN HANDLE hFile,
    IN DWORD  ByteCount
    );



#ifdef UNICODE

VOID InfCacheFreeCache(
    IN PINFCACHE pInfCache
    )
/*++

Routine Description:

    Delete/Release in-memory image of INF CACHE

Arguments:

    pInfCache - pointer to Run-Time data

Return Value:

    none

--*/
{
    if (pInfCache == NULL) {
        //
        // no cache
        //
        return;
    }
    if(pInfCache->bReadOnly && pInfCache->BaseAddress) {
        //
        // we're looking at memory mapped cache
        //
        pStringTableDestroy(pInfCache->pMatchTable);
        pStringTableDestroy(pInfCache->pInfTable);
        pSetupUnmapAndCloseFile(pInfCache->FileHandle, pInfCache->MappingHandle, pInfCache->BaseAddress);

    } else {
        //
        // if cache is writable, this data is transient
        //
        if(pInfCache->pHeader) {
            MyFree(pInfCache->pHeader);
        }
        if(pInfCache->pMatchTable) {
            pStringTableDestroy(pInfCache->pMatchTable);
        }
        if(pInfCache->pInfTable) {
            pStringTableDestroy(pInfCache->pInfTable);
        }
        if(pInfCache->pListTable) {
            MyFree(pInfCache->pListTable);
        }
    }
    //
    // transient information
    //
    if(pInfCache->pSearchTable) {
        pStringTableDestroy(pInfCache->pSearchTable);
    }
    MyFree(pInfCache);
}

#endif


#ifdef UNICODE

PINFCACHE InfCacheCreateNewCache(
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    Create new empty cache

Arguments:

    LogContext - for logging

Return Value:

    pointer to Run-Time header if succeeded, NULL if out of memory.

--*/
{
    PINFCACHE pInfCache = (PINFCACHE)MyMalloc(sizeof(INFCACHE));
    if(pInfCache == NULL) {
        return NULL;
    }
    ZeroMemory(pInfCache,sizeof(INFCACHE));
    //
    // set initial state
    //
    pInfCache->BaseAddress = NULL;
    pInfCache->bReadOnly = FALSE;
    pInfCache->bDirty = TRUE;
    pInfCache->bNoWriteBack = FALSE;
    //
    // create transient data
    //
    pInfCache->pHeader = (PCACHEHEADER)MyMalloc(sizeof(CACHEHEADER));
    if(pInfCache->pHeader == NULL) {
        goto cleanup;
    }
    pInfCache->pMatchTable = pStringTableInitialize(sizeof(CACHEMATCHENTRY));
    if(pInfCache->pMatchTable == NULL) {
        goto cleanup;
    }
    pInfCache->pInfTable = pStringTableInitialize(sizeof(CACHEINFENTRY));
    if(pInfCache->pInfTable == NULL) {
        goto cleanup;
    }
    pInfCache->pHeader->Version = INFCACHE_VERSION;
    pInfCache->pHeader->Locale = GetThreadLocale();
    pInfCache->pHeader->Flags = 0;
    pInfCache->pHeader->FileSize = 0; // in memory image
    pInfCache->pHeader->MatchTableOffset = 0; // in memory image
    pInfCache->pHeader->MatchTableSize = 0; // in memory image
    pInfCache->pHeader->InfTableOffset = 0; // in memory image
    pInfCache->pHeader->InfTableSize = 0; // in memory image
    pInfCache->pHeader->ListDataOffset = 0; // in memory image
    pInfCache->pHeader->ListDataCount = 1; // initial size (count the free list node)
    pInfCache->ListDataAlloc = 32768; // initial size of allocation
    pInfCache->pListTable = (PCACHELISTENTRY)MyMalloc(sizeof(CACHELISTENTRY)*pInfCache->ListDataAlloc);
    if(pInfCache->pListTable == NULL) {
        goto cleanup;
    }
    //
    // initialize free-list to empty (even though we allocated enough space, we don't commit it until needed)
    //
    pInfCache->pListTable[0].Value = 0; // how many free entries
    pInfCache->pListTable[0].Next = 0;
    //
    // search table
    //
    pInfCache->pSearchTable = pStringTableInitialize(sizeof(CACHEHITENTRY));
    if(pInfCache->pSearchTable == NULL) {
        goto cleanup;
    }

    WriteLogEntry(LogContext,
                  DRIVER_LOG_VVERBOSE,
                  MSG_LOG_USING_NEW_INF_CACHE,
                  NULL
                  );
    return pInfCache;

cleanup:

    InfCacheFreeCache(pInfCache);
    return NULL;
}

#endif

#ifdef UNICODE

DWORD MarkForDelete(
    IN LPCTSTR FilePath
    )
/*++

Routine Description:

    Special delete operation that will open the file with required access
    mark it as needs deleting
    and then close it again

Arguments:

    FilePath - name of file to delete

Return Value:

    Success status

--*/
{
    TCHAR TmpFilePath[MAX_PATH*2];
    PTSTR FileName;
    HANDLE hFile;
    int c;

    hFile = CreateFile(FilePath,
                       0,
                       FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                       NULL
                      );

    if(hFile == INVALID_HANDLE_VALUE) {
        //
        // this can fail for various reasons
        //
        if(GetLastError() == ERROR_FILE_NOT_FOUND) {
            return NO_ERROR;
        }
        return GetLastError();
    }
    //
    // rename file to a temporary one for period that file remains alive
    //
    lstrcpyn(TmpFilePath,FilePath,MAX_PATH);

    FileName = (PTSTR)pSetupGetFileTitle(TmpFilePath);
    for(c=0;c<1000;c++) {
        _stprintf(FileName,OLDCACHE_NAME_TEMPLATE,c);
        if (MoveFile(FilePath,TmpFilePath)) {
            break;
        }
        if (GetLastError() != ERROR_FILE_EXISTS) {
            MYASSERT(GetLastError() == ERROR_FILE_EXISTS);
            break;
        }
    }
    MYASSERT(c<1000);

    //
    // ok, done (file may go away as soon as we close handle)
    //
    CloseHandle(hFile);

    return NO_ERROR;
}

#endif

#ifdef UNICODE

DWORD InfCacheGetFileNames(
    IN LPCTSTR InfDirectory,
    OUT TCHAR InfPath[3][MAX_PATH]
    )
{
    TCHAR InfName[MAX_PATH];
    int c;

    for(c=0;c<3;c++) {
        lstrcpyn(InfPath[c],InfDirectory,MAX_PATH);
        _stprintf(InfName,INFCACHE_NAME_TEMPLATE,c);
        if(!pSetupConcatenatePaths(InfPath[c],InfName,MAX_PATH,NULL)) {
            //
            // filename too big, fall into default search mode (we'll never be able to save the cache)
            //
            return ERROR_BAD_PATHNAME;
        }
    }
    return NO_ERROR;
}

#endif

#ifdef UNICODE

PINFCACHE InfCacheLoadCache(
    IN LPCTSTR InfDirectory,
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    Retrieves cache for INF directory, if any.
    We'll try
    1) INFCACHE.1 (if it's a bad file, we'll rename to OLDCACHE.xxx)
    2) INFCACHE.2 (ditto)
    if we can't open a either of them, we'll skip over. We'll only have
    both if something happened during write (such as reboot)
    the OLDCACHE.xxx will be deleted when last handle to it is closed

    we attempt to return (1) existing cache, (2) empty cache, (3) NULL

Arguments:

    InfDirectory - directory to find cache in
    LogContext   - for logging

Return Value:

    pointer to Run-Time header if succeeded, NULL if fatal error (go into default search mode)

--*/
{

    //
    // currently only support for unicode setupapi
    //

    TCHAR InfPath[3][MAX_PATH];
    int c;
    DWORD FileSize;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HANDLE MappingHandle = NULL;
    PVOID BaseAddress = NULL;
    PCACHEHEADER pHeader = NULL;
    PINFCACHE pInfCache = NULL;
    DWORD Err;

    MYASSERT(InfDirectory);

    if ((Err = InfCacheGetFileNames(InfDirectory,InfPath))!=NO_ERROR) {
        return NULL;
    }

    //
    // look at INFCACHE.1 (primary) INFCACHE.2 (backup)
    //
    for(c=1;c<3;c++) {
        //
        // try and map this file into memory
        //
        //
        FileHandle = CreateFile(
                        InfPath[c],
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_DELETE, // need delete permission
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

        if(FileHandle == INVALID_HANDLE_VALUE) {

            continue; // this file is locked, or doesn't exist

        }
        if((Err = pSetupMapFileForRead(FileHandle,&FileSize,&MappingHandle,&BaseAddress)) != NO_ERROR) {
            //
            // shouldn't happen on a good file, so clean it up
            //
            MarkForDelete(InfPath[c]);
            continue;
        }

        if(FileSize >= sizeof(CACHEHEADER)) {
            pHeader = (PCACHEHEADER)BaseAddress;
            if(pHeader->Version == INFCACHE_VERSION &&
                pHeader->FileSize <= FileSize &&
                BOUNDSCHECK(pHeader->MatchTableOffset,pHeader->MatchTableSize,pHeader->FileSize) &&
                BOUNDSCHECK(pHeader->InfTableOffset,pHeader->InfTableSize,pHeader->FileSize) &&
                BOUNDSCHECK(pHeader->ListDataOffset,(pHeader->ListDataCount*sizeof(CACHELISTENTRY)),pHeader->FileSize) &&
                (pHeader->MatchTableOffset >= sizeof(CACHEHEADER)) &&
                (pHeader->InfTableOffset >= pHeader->MatchTableOffset+pHeader->MatchTableSize) &&
                (pHeader->ListDataOffset >= pHeader->InfTableOffset+pHeader->InfTableSize)) {
                //
                // we're reasonably happy this file is valid
                //
                break;
            }
        }
        //
        // bad file (we was able to open file for reading, so it wasn't locked for writing)
        //
        MarkForDelete(InfPath[c]);
        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
    }

    switch(c) {
        case 0: // obtained primary file
        case 1: // obtained secondary file
        case 2: // obtained backup file, don't move as secondary may exist as locked
            WriteLogEntry(LogContext,
                          DRIVER_LOG_VVERBOSE,
                          MSG_LOG_USING_INF_CACHE,
                          NULL,
                          InfPath[c]);
            break;
        case 3: // obtained no file
            return InfCacheCreateNewCache(LogContext);
        default: // whoops?
            MYASSERT(FALSE);
            return InfCacheCreateNewCache(LogContext);
    }

    //
    // if we get here, we have a mapped file
    //
    MYASSERT(BaseAddress);
    pInfCache = (PINFCACHE)MyMalloc(sizeof(INFCACHE));
    if(pInfCache == NULL) {
        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
        return NULL;
    }
    ZeroMemory(pInfCache,sizeof(INFCACHE));
    //
    // set initial state
    //
    pInfCache->FileHandle = FileHandle;
    pInfCache->MappingHandle = MappingHandle;
    pInfCache->BaseAddress = BaseAddress;
    pInfCache->bReadOnly = TRUE;
    pInfCache->bDirty = FALSE;
    pInfCache->bNoWriteBack = FALSE;
    //
    // make Runtime-Data point to relevent data structures
    //
    pInfCache->pHeader = pHeader;

    //
    // note that  InitializeStringTableFromMemoryMappedFile creates a header that must be
    // released by MyFree instead of pSetupStringTableDestroy
    //
    pInfCache->pMatchTable = InitializeStringTableFromMemoryMappedFile(
                                    (PBYTE)BaseAddress+pHeader->MatchTableOffset,
                                    pInfCache->pHeader->MatchTableSize,
                                    pInfCache->pHeader->Locale,
                                    sizeof(CACHEMATCHENTRY)
                                    );

    pInfCache->pInfTable = InitializeStringTableFromMemoryMappedFile(
                                    (PBYTE)BaseAddress+pHeader->InfTableOffset,
                                    pInfCache->pHeader->InfTableSize,
                                    pInfCache->pHeader->Locale,
                                    sizeof(CACHEINFENTRY)
                                    );

    pInfCache->pListTable = (PCACHELISTENTRY)((PBYTE)BaseAddress+pHeader->ListDataOffset);
    pInfCache->ListDataAlloc = 0; // initial size of allocation (0 since this is static)

    //
    // search table - transient and empty
    //
    pInfCache->pSearchTable = pStringTableInitialize(sizeof(CACHEHITENTRY));

    //
    // ok, now did all memory allocations succeed?
    //
    if(pInfCache->pMatchTable==NULL || pInfCache->pInfTable==NULL || pInfCache->pSearchTable==NULL) {
        InfCacheFreeCache(pInfCache);
        return NULL;
    }

    return pInfCache;

    //
    // for ANSI version, just use default search mode (for now)
    //
    return NULL;
}

#endif

#ifdef UNICODE

DWORD InfCacheMakeWritable(
    IN OUT PINFCACHE pInfCache
    )
/*++

Routine Description:

    Modifies InfCache in such a way that it can be written to
    This is expensive as all previously memory-mapped data must be copied into memory

Arguments:

    pInfCache - the cache we want to make writable

Return Value:

    status, typically NO_ERROR

--*/
{
    PCACHEHEADER pNewCacheHeader = NULL;
    PVOID pNewMatchTable = NULL;
    PVOID pNewInfTable = NULL;
    PCACHELISTENTRY pNewListTable = NULL;
    ULONG ListAllocSize = 0;

    if(pInfCache == NULL || !pInfCache->bReadOnly) {
        //
        // not a cache we can/need to modify
        //
        return NO_ERROR;
    }
    if (pInfCache->bNoWriteBack) {
        //
        // we've already attempted this once, cache now invalid
        //
        return ERROR_INVALID_DATA;
    }
    MYASSERT(pInfCache->BaseAddress);
    MYASSERT(!pInfCache->bDirty);
    //
    // allocatable data we need to duplicate is
    // CACHEHEADER
    // MatchStringTable
    // InfStringTable
    // DataList
    //
    pNewCacheHeader = (PCACHEHEADER)MyMalloc(sizeof(CACHEHEADER));
    if(pNewCacheHeader == NULL) {
        goto cleanup;
    }
    ZeroMemory(pNewCacheHeader,sizeof(CACHEHEADER));
    pNewCacheHeader->FileSize = 0;
    pNewCacheHeader->Flags = 0;
    pNewCacheHeader->InfTableOffset = 0;
    pNewCacheHeader->InfTableSize = 0;
    pNewCacheHeader->ListDataCount = pInfCache->pHeader->ListDataCount;
    pNewCacheHeader->Locale = pInfCache->pHeader->Locale;
    pNewCacheHeader->Version = INFCACHE_VERSION;

    pNewMatchTable = pStringTableDuplicate(pInfCache->pMatchTable);
    if(pNewMatchTable == NULL) {
        goto cleanup;
    }
    pNewInfTable = pStringTableDuplicate(pInfCache->pInfTable);
    if(pNewInfTable == NULL) {
        goto cleanup;
    }
    ListAllocSize = pNewCacheHeader->ListDataCount + 32768;
    pNewListTable = (PCACHELISTENTRY)MyMalloc(sizeof(CACHELISTENTRY)*ListAllocSize);
    if(pNewListTable == NULL) {
        goto cleanup;
    }
    //
    // copy the table
    //
    CopyMemory(pNewListTable,pInfCache->pListTable,pNewCacheHeader->ListDataCount*sizeof(CACHELISTENTRY));

    //
    // ok, now commit - delete & replace old data
    //
    pStringTableDestroy(pInfCache->pMatchTable);
    pStringTableDestroy(pInfCache->pInfTable);
    pSetupUnmapAndCloseFile(pInfCache->FileHandle, pInfCache->MappingHandle, pInfCache->BaseAddress);

    pInfCache->FileHandle = INVALID_HANDLE_VALUE;
    pInfCache->MappingHandle = NULL;
    pInfCache->BaseAddress = NULL;
    pInfCache->bReadOnly = FALSE;

    pInfCache->pHeader = pNewCacheHeader;
    pInfCache->pMatchTable = pNewMatchTable;
    pInfCache->pInfTable = pNewInfTable;
    pInfCache->pListTable = pNewListTable;
    pInfCache->ListDataAlloc = ListAllocSize;

    return NO_ERROR;

cleanup:

    //
    // we don't have enough memory to duplicate
    //
    if(pNewCacheHeader) {
        MyFree(pNewCacheHeader);
    }
    if(pNewMatchTable) {
        pStringTableDestroy(pNewMatchTable);
    }
    if(pNewInfTable) {
        pStringTableDestroy(pNewInfTable);
    }
    if(pNewListTable) {
        MyFree(pNewListTable);
    }
    return ERROR_NOT_ENOUGH_MEMORY;
}

#endif

#ifdef UNICODE

DWORD InfCacheWriteCache(
    IN LPCTSTR InfDirectory,
    IN OUT PINFCACHE pInfCache,
    IN PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    Writes a cache file to the INF directory being searched
    Worst case scenario is we abandon the write, possibly leaving
    a file turd around (until next inf search)
    Typically,
    1) we'll write to INFCACHE.0
    2) we'll rename INFCACHE.2 to OLDCACHE.xxx (only if INFCACHE.1&2 exists)
    3) we'll rename INFCACHE.1 to INFCACHE.2
    4) we'll rename INFCACHE.0 to INFCACHE.1
    5) we'll rename INFCACHE.1 to OLDCACHE.xxx
    at stage 4, new callers may fail to open INFCACHE.1 and attempt INFCACHE.2
    OLDCACHE.xxx will be deleted when last handle to it is closed

Arguments:

    pInfCache - the cache we want to make writable

Return Value:

    status, typically NO_ERROR

--*/
{
    HANDLE hFile;
    HANDLE hFile2;
    TCHAR InfPath[3][MAX_PATH];
    DWORD Offset;
    DWORD BytesWritten;
    PVOID MatchTableBlock;
    PVOID InfTableBlock;
    DWORD Err;
    DWORD CacheIndex = 0;

    //
    // don't bother writing it if we don't have to
    //
    if(pInfCache->bNoWriteBack) {
        return ERROR_INVALID_DATA;
    }
    if(!pInfCache->bDirty || pInfCache->bReadOnly) {
        return NO_ERROR;
    }

    MYASSERT(InfDirectory);

    if ((Err = InfCacheGetFileNames(InfDirectory,InfPath))!=NO_ERROR) {
        return Err;
    }

    //
    // attempt to open the temporary file for writing
    //
    hFile = CreateFile(InfPath[0],
                       GENERIC_WRITE,
                       FILE_SHARE_DELETE, // exclusive, but can be deleted/renamed
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );

    if(hFile == INVALID_HANDLE_VALUE) {
        //
        // this will fail if we're non-admin, or we're already writing the cache
        //
        return GetLastError();
    }

    //
    // align past header
    //
    Offset = CACHE_ALIGN_BLOCK(sizeof(CACHEHEADER));
    MYASSERT(Offset>=sizeof(CACHEHEADER));

    //
    // get information about MatchTable
    //
    pInfCache->pHeader->MatchTableOffset = Offset;
    pInfCache->pHeader->MatchTableSize = pStringTableGetDataBlock(pInfCache->pMatchTable, &MatchTableBlock);
    Offset += CACHE_ALIGN_BLOCK(pInfCache->pHeader->MatchTableSize);
    MYASSERT(Offset>=pInfCache->pHeader->MatchTableOffset+pInfCache->pHeader->MatchTableSize);

    //
    // get information about InfTable
    //
    pInfCache->pHeader->InfTableOffset = Offset;
    pInfCache->pHeader->InfTableSize = pStringTableGetDataBlock(pInfCache->pInfTable, &InfTableBlock);
    Offset += CACHE_ALIGN_BLOCK(pInfCache->pHeader->InfTableSize);
    MYASSERT(Offset>=pInfCache->pHeader->InfTableOffset+pInfCache->pHeader->InfTableSize);

    //
    // get information about ListData
    //
    pInfCache->pHeader->ListDataOffset = Offset;
    Offset += CACHE_ALIGN_BLOCK((pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY)));
    MYASSERT(Offset>=pInfCache->pHeader->ListDataOffset+pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY));

    //
    // size of file now computed
    //
    pInfCache->pHeader->FileSize = Offset;

    //
    // write the file out
    //
    Offset = 0;

    //
    // cache header
    //
    if(!WriteFile(hFile, pInfCache->pHeader, sizeof(CACHEHEADER), &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == sizeof(CACHEHEADER));
    Offset += BytesWritten;

    //
    // MatchTable
    //
    if(AlignForNextBlock(hFile, pInfCache->pHeader->MatchTableOffset - Offset)) {
        Offset = pInfCache->pHeader->MatchTableOffset;
    } else {
        Err = GetLastError();
        goto clean;
    }

    if(!WriteFile(hFile, MatchTableBlock, pInfCache->pHeader->MatchTableSize, &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == pInfCache->pHeader->MatchTableSize);
    Offset += BytesWritten;

    //
    // InfTable
    //
    if(AlignForNextBlock(hFile, pInfCache->pHeader->InfTableOffset - Offset)) {
        Offset = pInfCache->pHeader->InfTableOffset;
    } else {
        Err = GetLastError();
        goto clean;
    }

    if(!WriteFile(hFile, InfTableBlock, pInfCache->pHeader->InfTableSize, &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == pInfCache->pHeader->InfTableSize);
    Offset += BytesWritten;

    //
    // ListData
    //

    if(AlignForNextBlock(hFile, pInfCache->pHeader->ListDataOffset - Offset)) {
        Offset = pInfCache->pHeader->ListDataOffset;
    } else {
        Err = GetLastError();
        goto clean;
    }

    if(!WriteFile(hFile, pInfCache->pListTable, pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY), &BytesWritten, NULL)) {
        Err = GetLastError();
        goto clean;
    }

    MYASSERT(BytesWritten == pInfCache->pHeader->ListDataCount*sizeof(CACHELISTENTRY));
    Offset += BytesWritten;

    //
    // final padding
    //

    if(AlignForNextBlock(hFile, pInfCache->pHeader->FileSize - Offset)) {
        Offset = pInfCache->pHeader->FileSize;
    } else {
        Err = GetLastError();
        goto clean;
    }

    FlushFileBuffers(hFile);

    //
    // new cache written, do we need to shuffle primary to backup?
    //
    hFile2 = CreateFile(InfPath[1],
                       GENERIC_READ,
                       FILE_SHARE_READ|FILE_SHARE_DELETE, // lock this file in place
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );
    if(hFile2 != INVALID_HANDLE_VALUE) {
        //
        // ok, we have a primary, so back it up
        // delete the old backup first
        // once in place, any new opens will find it in backup position
        // until we move and release new cache
        //
        MarkForDelete(InfPath[2]);
        MoveFile(InfPath[1],InfPath[2]);
        CloseHandle(hFile2);
    }
    //
    // now attempt to move our cache
    //
    if(MoveFile(InfPath[0],InfPath[1])) {
        CacheIndex = 1;
    }
    CloseHandle(hFile);
    //
    // new cache committed & ready for reading
    // try not to leave turds around
    //
    MarkForDelete(InfPath[2]);
    MarkForDelete(InfPath[0]);

    pInfCache->bDirty = FALSE;

    WriteLogEntry(LogContext,
                  CacheIndex ? DRIVER_LOG_INFO : DRIVER_LOG_ERROR,
                  CacheIndex ? MSG_LOG_MODIFIED_INF_CACHE : MSG_LOG_FAILED_MODIFY_INF_CACHE,
                  NULL,
                  InfPath[CacheIndex]);

    return NO_ERROR;

clean:

    //
    // abandon the file
    // delete first, we can do this since we opened the file shared-delete
    // don't close before delete, otherwise we might delete a file someone else is writing
    //
    DeleteFile(InfPath[0]);
    CloseHandle(hFile);

    return Err;
}

#endif

#ifdef UNICODE

ULONG InfCacheAllocListEntry(
    IN OUT PINFCACHE pInfCache,
    IN LONG init
    )
/*++

Routine Description:

    Allocates a single list entry, initializing the datum to init

    Side effect: if pInfCache not writable, it will be made writable
    Side effect: if pInfCache not dirty, it will be marked dirty

Arguments:

    pInfCache - the cache we're going to modify
    init - initial value of datum

Return Value:

    index of datum, or 0 on failure. (GetLastError indicates error)

--*/
{
    DWORD status;
    ULONG entry;

    if(pInfCache->bReadOnly) {
        status = InfCacheMakeWritable(pInfCache);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            SetLastError(status);
            return 0;
        }
    }
    //
    // query free-list
    //
    entry = pInfCache->pListTable[0].Next;
    if(entry) {
        //
        // allocate from free list - reuse space
        //
        pInfCache->pListTable[0].Value--;
        pInfCache->pListTable[0].Next = pInfCache->pListTable[entry].Next;
        pInfCache->pListTable[entry].Value = init;
        pInfCache->pListTable[entry].Next = 0;
        pInfCache->bDirty = TRUE;
        return entry;
    }
    if(pInfCache->pHeader->ListDataCount >= pInfCache->ListDataAlloc) {
        //
        // allocate some extra space
        //
        ULONG CountNewSpace;
        PCACHELISTENTRY pNewSpace;

        MYASSERT(pInfCache->ListDataAlloc);
        CountNewSpace = pInfCache->ListDataAlloc*2;
        pNewSpace = (PCACHELISTENTRY)MyRealloc(pInfCache->pListTable,sizeof(CACHELISTENTRY)*CountNewSpace);
        if(pNewSpace == NULL) {
            //
            // ack!
            //
            pInfCache->bNoWriteBack = TRUE; // junk this cache at end
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return 0;
        }
        pInfCache->ListDataAlloc = CountNewSpace;
        pInfCache->pListTable = pNewSpace;
    }
    //
    // allocate from extra space
    //
    entry = pInfCache->pHeader->ListDataCount;
    pInfCache->pHeader->ListDataCount++;
    pInfCache->pListTable[entry].Value = init;
    pInfCache->pListTable[entry].Next = 0;
    pInfCache->bDirty = TRUE;
    return entry;
}

#endif

#ifdef UNICODE

DWORD InfCacheFreeListEntry(
    IN OUT PINFCACHE pInfCache,
    IN ULONG entry
    )
/*++

Routine Description:

    Releases a single list entry (no modifications to prev/next links made)

    Side effect: if pInfCache not writable, it will be made writable
    Side effect: if pInfCache not dirty, it will be marked dirty

Arguments:

    pInfCache - the cache we're going to modify
    entry - list entry to add to free list

Return Value:

    status, typically NO_ERROR

--*/
{
    DWORD status;

    if(entry == 0 || pInfCache == NULL || entry >= pInfCache->pHeader->ListDataCount) {
        return ERROR_INVALID_DATA;
    }
    if(pInfCache->bReadOnly) {
        status = InfCacheMakeWritable(pInfCache);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            return status;
        }
    }
    pInfCache->pListTable[entry].Value = -1;
    pInfCache->pListTable[entry].Next = pInfCache->pListTable[0].Next;
    pInfCache->pListTable[0].Next = entry;
    pInfCache->pListTable[0].Value++;
    pInfCache->bDirty = TRUE;
    return NO_ERROR;
}

#endif

#ifdef UNICODE

DWORD InfCacheRemoveMatchRefToInf(
    IN OUT PINFCACHE pInfCache,
    IN LONG MatchEntry,
    IN LONG InfEntry
    )
/*++

Routine Description:

    Removes details about a specific INF from specific HWID entry

    assumptions: pInfCache already writable

Arguments:

    pInfCache - the cache we're going to modify
    MatchEntry - the Match list we need to remove INF from
    InfEntry - the INF we need to remove from Match list

Return Value:

    status, typically NO_ERROR

--*/
{
    DWORD status;
    CACHEMATCHENTRY matchdata;
    ULONG parent_index;
    ULONG index;
    ULONG newindex;
    BOOL head;

    MYASSERT(pInfCache);
    MYASSERT(!pInfCache->bReadOnly);
    MYASSERT(MatchEntry);
    MYASSERT(InfEntry);

    if(!pStringTableGetExtraData(pInfCache->pMatchTable,MatchEntry,&matchdata,sizeof(matchdata))) {
        MYASSERT(FALSE); // should not fail
    }

    parent_index = 0;
    index = matchdata.InfList;
    head = FALSE;

    while (index) {

        newindex = pInfCache->pListTable[index].Next;

        if (pInfCache->pListTable[index].Value == InfEntry) {
            //
            // remove
            //
            pInfCache->bDirty = TRUE;
            if(parent_index) {
                pInfCache->pListTable[parent_index].Next = newindex;
            } else {
                matchdata.InfList = newindex;
                head = TRUE;
            }
            status = InfCacheFreeListEntry(pInfCache,index);
            if(status != NO_ERROR) {
                pInfCache->bNoWriteBack = TRUE; // cache now invalid
                return status;
            }
        } else {
            parent_index = index;
        }
        index = newindex;
    }

    if (head) {
        //
        // we modified the head item
        //
        if(!pStringTableSetExtraData(pInfCache->pMatchTable,MatchEntry,&matchdata,sizeof(matchdata))) {
            MYASSERT(FALSE); // should not fail
        }
    }

    return NO_ERROR;
}

#endif


#ifdef UNICODE

DWORD InfCacheRemoveInf(
    IN OUT PINFCACHE pInfCache,
    IN LONG nHitEntry,
    IN PCACHEINFENTRY inf_entry
    )
/*++

Routine Description:

    Removes details about a specific INF from cache

    Side effect: if pInfCache not writable, it will be made writable
    Side effect: if pInfCache not dirty, it will be marked dirty

Arguments:

    pInfCache - the cache we're going to modify
    nHitEntry - string id in Inf StringTable
    inf_entry - structure obtained from Inf StringTable

Return Value:

    status, typically NO_ERROR

--*/
{
    DWORD status;
    DWORD hwstatus;
    ULONG parent_index;
    CACHEINFENTRY dummy_entry;

    MYASSERT(inf_entry); // later we may make this optional
    MYASSERT(nHitEntry);

    if(inf_entry->MatchList == CIE_INF_INVALID) {
        //
        // already showing as deleted
        //
        return NO_ERROR;
    }

    if(pInfCache == NULL || pInfCache->bNoWriteBack) {
        return ERROR_INVALID_DATA;
    }

    if(pInfCache->bReadOnly) {
        status = InfCacheMakeWritable(pInfCache);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            return status;
        }
    }

    pInfCache->bDirty = TRUE;
    parent_index = inf_entry->MatchList;

    //
    // invalidate inf_entry
    //
    dummy_entry.MatchList = CIE_INF_INVALID;
    dummy_entry.FileTime.dwLowDateTime = 0;
    dummy_entry.FileTime.dwHighDateTime = 0;
    dummy_entry.MatchFlags = CIEF_INF_NOTINF;
    if(!pStringTableSetExtraData(pInfCache->pInfTable,nHitEntry,&dummy_entry,sizeof(dummy_entry))) {
        MYASSERT(FALSE); // should not fail
    }
    //
    // parse through and delete list of match ID's
    //
    hwstatus = NO_ERROR;

    while(parent_index>0 && parent_index<pInfCache->pHeader->ListDataCount) {
        LONG value = pInfCache->pListTable[parent_index].Value;
        ULONG next = pInfCache->pListTable[parent_index].Next;
        //
        // free the list entry for re-use
        //
        status = InfCacheFreeListEntry(pInfCache,parent_index);
        if(status != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            hwstatus = status;
        }
        parent_index = next;
        //
        // for each Match ID, delete all references to the INF
        //
        status = InfCacheRemoveMatchRefToInf(pInfCache,value,nHitEntry);
        if(hwstatus == NO_ERROR) {
            hwstatus = status;
        }
    }

    return hwstatus;
}

#endif

#ifdef UNICODE

LONG InfCacheLookupInf(
    IN OUT PINFCACHE pInfCache,
    IN LPWIN32_FIND_DATA FindFileData,
    OUT PCACHEINFENTRY inf_entry
    )
/*++

Routine Description:

    looks up the file as given by FindFileData to see if it's in the cache
    If it's in the cache marked valid, and the date-stamp in cache is same as date-stamp of INF
    then it's a 'HIT'
    If it's in the cache marked valid, but date-stamp is wrong, then it's deleted and considered
    a "MISS'
    All other cases, consider it a 'MISS'

Arguments:

    pInfCache - the cache we're using
    FindFileData - information about a specific file we're looking at
    inf_entry - structure obtained from Inf StringTable

Return Value:

    -1 for a 'MISS'. StringID of INF for a 'HIT'
    inf_entry filled out with MatchList == CIE_INF_INVALID for a miss.

--*/
{
    LONG i;
    DWORD StringLength;

    MYASSERT(pInfCache);
    //
    // determine if the cache entry of pInfCache is considered valid
    //
    i = pStringTableLookUpString(pInfCache->pInfTable,
                                        FindFileData->cFileName,
                                        &StringLength,
                                        NULL, // hash value
                                        NULL, // find context
                                        STRTAB_CASE_INSENSITIVE,
                                        inf_entry,
                                        sizeof(CACHEINFENTRY));
    if(i>=0 && inf_entry->MatchList != CIE_INF_INVALID) {
        //
        // cache hit (and matchlist is valid)
        //
        if(CompareFileTime(&inf_entry->FileTime,&FindFileData->ftLastWriteTime)==0) {
            //
            // valid cache hit
            //
            return i;
        }
        //
        // cache out of date miss
        // although we'll rebuild it later, let's use this opportunity to delete the entry
        //
        InfCacheRemoveInf(pInfCache,i,inf_entry);
    }
    //
    // we're here because we have a miss, however fill in a new (empty) inf_entry
    // MatchList set to CIE_INF_INVALID to indicate list is invalid and inf must be searched
    //
    inf_entry->FileTime = FindFileData->ftLastWriteTime;
    inf_entry->MatchList = CIE_INF_INVALID;
    inf_entry->MatchFlags = CIEF_INF_NOTINF;

    return -1;
}

#endif

#ifdef UNICODE

ULONG InfCacheAddListTail(
    IN OUT PINFCACHE pInfCache,
    IN OUT PULONG head,
    IN OUT PULONG tail,
    IN LONG value
    )
/*++

Routine Description:

    Adds value to tail of a list where *tail is an entry in the list

Arguments:

    pInfCache - cache to modify
    head - head of list
    tail - DataList entry
    value - data to add

Return Value:

    new entry position, 0 on error (GetLastError() returns error)

--*/
{
    ULONG next;
    ULONG first;

    MYASSERT(pInfCache);
    MYASSERT(head == NULL || head != tail);
    if (tail) {
        first = *tail;
    } else if (head) {
        first = *head;
    } else {
        MYASSERT(head || tail);
    }
    if (!first) {
        next = InfCacheAllocListEntry(pInfCache,value);
        if (!next) {
            return 0;
        }
        if (head) {
            *head = next;
        }
    } else {
        //
        // move head to last item in list
        //
        while(pInfCache->pListTable[first].Next) {
            first = pInfCache->pListTable[first].Next;
        }
        next = InfCacheAllocListEntry(pInfCache,value);
        if(!next) {
            return 0;
        }
        pInfCache->pListTable[first].Next = next;
    }
    if(tail) {
        *tail = next;
    }
    return next;
}

#endif

#ifdef UNICODE

LONG InfCacheAddMatchItem(
    IN OUT PINFCACHE pInfCache,
    IN LPCTSTR key,
    IN LONG InfEntry
    )
/*++

Routine Description:

    Given an INF StringID (InfEntry) and match key,
    obtain (and return) Match StringID
    while also adding InfEntry to head of Match's INF list
    (if not already at head)
    Order is not particularly important, however adding to head is
    quicker to do, and easier to reduce number of times we add inf
    if match id is referenced multiple times

Arguments:

    pInfCache - cache to modify
    key - match string (buffer must be writable)
    InfEntry - StringID

Return Value:

    new entry in match table, -1 on error (GetLastError() returns error)

--*/
{
    LONG MatchIndex;
    CACHEMATCHENTRY matchentry;
    DWORD StringLength;

    MYASSERT(pInfCache);
    MYASSERT(key);
    MYASSERT(InfEntry>=0);

    //
    // if cache is invalid, we'll skip this as optimization
    //
    if(pInfCache->bNoWriteBack) {
        SetLastError(ERROR_INVALID_DATA);
        return -1;
    }

    MatchIndex = pStringTableLookUpString(pInfCache->pMatchTable,
                                                    (LPTSTR)key, // will not be modified
                                                    &StringLength,
                                                    NULL, // hash value
                                                    NULL, // find context
                                                    STRTAB_CASE_INSENSITIVE,
                                                    &matchentry,
                                                    sizeof(matchentry));

    if(MatchIndex < 0) {
        //
        // entirely new entry
        //
        matchentry.InfList = InfCacheAllocListEntry(pInfCache,InfEntry);
        if(matchentry.InfList == 0) {
            return -1;
        }
        MatchIndex = pStringTableAddString(pInfCache->pMatchTable,
                                                    (LPTSTR)key, // will not be modified
                                                    STRTAB_CASE_INSENSITIVE|STRTAB_NEW_EXTRADATA,
                                                    &matchentry,
                                                    sizeof(matchentry));
        if(MatchIndex<0) {
            pInfCache->bNoWriteBack = TRUE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return -1;
        }
    } else {
        MYASSERT(matchentry.InfList<pInfCache->pHeader->ListDataCount);
        //
        // if we came across this same match earlier for this inf,
        // the inf should still be at head of list
        // the world doesn't come to an end though if we end up adding
        // the inf twice - we check for this when deleting the inf
        //
        if (pInfCache->pListTable[matchentry.InfList].Value != InfEntry) {
            ULONG newentry = InfCacheAllocListEntry(pInfCache,InfEntry);
            if(newentry == 0) {
                return -1;
            }
            pInfCache->pListTable[newentry].Next = matchentry.InfList;
            matchentry.InfList = newentry;
            if(!pStringTableSetExtraData(pInfCache->pMatchTable,MatchIndex,&matchentry,sizeof(matchentry))) {
                MYASSERT(FALSE); // should not fail
            }
        }
    }
    return MatchIndex;
}

#endif

#ifdef UNICODE

LONG InfCacheAddInf(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN OUT PINFCACHE pInfCache,
    IN LPWIN32_FIND_DATA FindFileData,
    OUT PCACHEINFENTRY inf_entry,
    IN PLOADED_INF pInf
    )
/*++

Routine Description:

    Called to add a newly discovered INF to the cache
    If hINF is "bad", then we'll mark the INF as an exclusion
    so we don't waste time with it in future
    If we return with an error, caller knows that the INF
    must be searched if it can be searched

Arguments:

    LogContext - logging context for errors

    pInfCache - cache to modify

    FindFileData - contains name of INF and date-stamp

    inf_entry - returns list of match ID's associated with INF

    pINF - opened INF to add information about.  NOTE: Either this INF must
           be locked by the caller, or the INF cannot be accessed by any other
           thread.  THIS ROUTINE DOES NOT DO LOCKING ON THE INF.

Return Value:

    InfEntry - -1 if error (GetLastError returns status)

--*/
{
    //
    // FindFileData contains name & date-stamp of INF
    // we need to process all search information out of the INF
    //
    LONG nInfIndex = -1;
    LONG nMatchId = -1;
    ULONG last_list_entry = 0;
    ULONG head_list_entry = 0;
    DWORD Err = NO_ERROR;
    PCTSTR MatchString;
    GUID guid;
    PINF_SECTION MfgListSection;
    PINF_LINE MfgListLine;
    UINT MfgListLineIndex;
    PTSTR CurMfgSecName;
    TCHAR CurMfgSecWithExt[MAX_SECT_NAME_LEN];

    MYASSERT(pInfCache);
    MYASSERT(FindFileData);
    MYASSERT(inf_entry);

    if (pInfCache->bNoWriteBack) {
        //
        // cache is already bad, so don't waste time updating it
        // note though that the INF should be searched
        //
        return ERROR_INVALID_DATA;
    }
    if(pInfCache->bReadOnly) {
        Err = InfCacheMakeWritable(pInfCache);
        if(Err != NO_ERROR) {
            pInfCache->bNoWriteBack = TRUE; // cache now invalid
            return Err;
        }
    }

    //
    // this stuff should be set up earlier
    //
    MYASSERT(inf_entry->MatchList == CIE_INF_INVALID);
    MYASSERT(inf_entry->MatchFlags == CIEF_INF_NOTINF);
    MYASSERT(inf_entry->FileTime.dwHighDateTime = FindFileData->ftLastWriteTime.dwHighDateTime);
    MYASSERT(inf_entry->FileTime.dwLowDateTime = FindFileData->ftLastWriteTime.dwLowDateTime);
    MYASSERT(!pInfCache->bReadOnly);

    //
    // we need the InfIndex before we start (also mark this as file physically exist)
    //
    inf_entry->MatchList = 0;
    nInfIndex = pStringTableAddString(pInfCache->pInfTable,
                                        FindFileData->cFileName,
                                        STRTAB_CASE_INSENSITIVE|STRTAB_NEW_EXTRADATA,
                                        inf_entry,
                                        sizeof(CACHEINFENTRY));
    if (nInfIndex<0) {
        //
        // ack, out of memory
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(pInf) {
        if(pInf->Style == INF_STYLE_WIN4) {

            inf_entry->MatchFlags |= CIEF_INF_WIN4;

            if(pInf->InfSourceMediaType == SPOST_URL) {
                inf_entry->MatchFlags |= CIEF_INF_URL;
            }

            //
            // for a Win4 style INF, we're going to add Class GUID & Class Name to the
            // pool of ID's we can match on
            // note that if one or the other is missing, we don't lookup here as registry
            // information could change
            // we do the cross-lookups at the time of the INF search
            //
            if((MatchString = pSetupGetVersionDatum(&pInf->VersionBlock, pszClassGuid))!=NULL) {
                //
                // we found a class GUID
                //
                inf_entry->MatchFlags |= CIEF_INF_CLASSGUID;

                nMatchId = InfCacheAddMatchItem(pInfCache,MatchString,nInfIndex);
                if (nMatchId<0) {
                    Err = GetLastError();
                    goto cleanup;
                }
                if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                    Err = GetLastError();
                    goto cleanup;
                }

                //
                // check out a special case {0}
                //
                if(pSetupGuidFromString(MatchString, &guid) == NO_ERROR && pSetupIsGuidNull(&guid)) {
                    inf_entry->MatchFlags |= CIEF_INF_NULLGUID;
                }

            }
            if((MatchString = pSetupGetVersionDatum(&pInf->VersionBlock, pszClass))!=NULL) {
                //
                // we found a class name
                //
                inf_entry->MatchFlags |= CIEF_INF_CLASSNAME;

                nMatchId = InfCacheAddMatchItem(pInfCache,MatchString,nInfIndex);
                if (nMatchId<0) {
                    Err = GetLastError();
                    goto cleanup;
                }
                if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                    Err = GetLastError();
                    goto cleanup;
                }
            }

            //
            // enumerate all manufacturers
            //
            if((MfgListSection = InfLocateSection(pInf, pszManufacturer, NULL)) &&
               MfgListSection->LineCount) {
                //
                // We have a [Manufacturer] section and there is at least one
                // line within it.
                //
                inf_entry->MatchFlags |= CIEF_INF_MANUFACTURER;

                for(MfgListLineIndex = 0;
                    InfLocateLine(pInf, MfgListSection, NULL, &MfgListLineIndex, &MfgListLine);
                    MfgListLineIndex++) {
                    //
                    // Make sure the current line is one of these valid forms:
                    //
                    // MfgDisplayNameAndModelsSection
                    // MfgDisplayName = MfgModelsSection [,TargetDecoration...]
                    //
                    if(!ISSEARCHABLE(MfgListLine)) {
                        //
                        // We have a line with multiple fields but no key--skip
                        // it.
                        //
                        continue;
                    }

                    if(CurMfgSecName = InfGetField(pInf, MfgListLine, 1, NULL)) {

                        INFCONTEXT device;

                        //
                        // Check to see if there is an applicable
                        // TargetDecoration entry for this manufacturer's
                        // models section (if so, the models section name will
                        // be appended with that decoration).
                        //
                        if(GetDecoratedModelsSection(LogContext,
                                                     pInf,
                                                     MfgListLine,
                                                     NULL,
                                                     CurMfgSecWithExt)) {
                            //
                            // From here on, use the decorated models section...
                            //
                            CurMfgSecName = CurMfgSecWithExt;
                        }

                        if(SetupFindFirstLine(pInf, CurMfgSecName, NULL, &device)) {
                            do {
                                TCHAR devname[LINE_LEN];
                                DWORD devindex;
                                DWORD fields = SetupGetFieldCount(&device);
                                //
                                // for a device line, field 1 = section, field 2+ = match keys
                                //
                                for(devindex=2;devindex<=fields;devindex++) {
                                    if(SetupGetStringField(&device,devindex,devname,LINE_LEN,NULL)) {
                                        //
                                        // finally, a hit key to add
                                        //
                                        nMatchId = InfCacheAddMatchItem(pInfCache,devname,nInfIndex);
                                        if(nMatchId<0) {
                                            Err = GetLastError();
                                            goto cleanup;
                                        }
                                        if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                                            Err = GetLastError();
                                            goto cleanup;
                                        }
                                    }
                                }
                            } while(SetupFindNextLine(&device,&device));
                        }
                    }
                }
            }

        } else if (pInf->Style == INF_STYLE_OLDNT) {
            //
            // for an OLDNT style INF, we'll add Legacy class name to the pool of ID's
            // we can match on
            //
            inf_entry->MatchFlags |= CIEF_INF_OLDNT;

            if((MatchString = pSetupGetVersionDatum(&pInf->VersionBlock, pszClass))!=NULL) {
                //
                // we found a (legacy) class name
                //
                inf_entry->MatchFlags |= CIEF_INF_CLASSNAME;

                nMatchId = InfCacheAddMatchItem(pInfCache,MatchString,nInfIndex);
                if (nMatchId<0) {
                    Err = GetLastError();
                    goto cleanup;
                }
                if (!InfCacheAddListTail(pInfCache,&head_list_entry,&last_list_entry,nMatchId)) {
                    Err = GetLastError();
                    goto cleanup;
                }
            }

        } else {
            MYASSERT(FALSE);
        }
    }

    //
    // now re-write the inf data with new flags & match patterns
    //
    inf_entry->MatchList = head_list_entry;
    if(!pStringTableSetExtraData(pInfCache->pInfTable,nInfIndex,inf_entry,sizeof(CACHEINFENTRY))) {
        MYASSERT(FALSE); // should not fail
    }
    return nInfIndex;

cleanup:

    pInfCache->bNoWriteBack = TRUE;
    MYASSERT(Err);
    SetLastError(Err);
    return -1;
}

#endif

#ifdef UNICODE

LONG InfCacheSearchTableLookup(
    IN OUT PINFCACHE pInfCache,
    IN PCTSTR filename,
    IN OUT PCACHEHITENTRY hitstats)
/*++

Routine Description:

    Looks up filename in the search table, returning search information
    if filename was not already in search table, it's added

Arguments:

    pInfCache - cache to modify
    filename - file to obtain hit-entry information for
    hitstats - information obtained (such as if this files been processed etc)

Return Value:

    index in search table (-1 if error)

--*/
{
    LONG nHitIndex;
    DWORD StringLength;

    MYASSERT(pInfCache);
    MYASSERT(filename);
    MYASSERT(hitstats);

    nHitIndex = pStringTableLookUpString(pInfCache->pSearchTable,
                                                    (PTSTR)filename, // filename wont be changed
                                                    &StringLength,
                                                    NULL, // hash value
                                                    NULL, // find context
                                                    STRTAB_CASE_INSENSITIVE,
                                                    hitstats,
                                                    sizeof(CACHEHITENTRY));

    if(nHitIndex < 0) {
        //
        // entirely new entry (hitstats expected to have a value)
        //
        nHitIndex = pStringTableAddString(pInfCache->pSearchTable,
                                                    (PTSTR)filename, // filename wont be changed
                                                    STRTAB_CASE_INSENSITIVE|STRTAB_NEW_EXTRADATA,
                                                    hitstats,
                                                    sizeof(CACHEHITENTRY));
        if (nHitIndex<0) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return -1;
        }
    }

    return nHitIndex;
}

#endif

#ifdef UNICODE

ULONG InfCacheSearchTableSetFlags(
    IN OUT PINFCACHE pInfCache,
    IN PCTSTR filename,
    IN ULONG setflags,
    IN ULONG clrflags
    )
/*++

Routine Description:

    Modifies flags associated with a filename

Arguments:

    pInfCache - cache to modify
    filename - file to obtain hit-entry information for
    setflags - flags to set
    clrflags - flags to clear

Return Value:

    combined flags, or (ULONG)(-1) on error.

--*/
{
    CACHEHITENTRY searchentry;
    LONG nHitIndex;
    ULONG flags;

    MYASSERT(pInfCache);
    MYASSERT(filename);

    searchentry.Flags = setflags; // prime in case of new entry
    nHitIndex = InfCacheSearchTableLookup(pInfCache,filename,&searchentry);
    if(nHitIndex<0) {
        return (ULONG)(-1);
    }
    flags = (searchentry.Flags&~clrflags) | setflags;
    if (flags != searchentry.Flags) {
        searchentry.Flags = flags;
        if(!pStringTableSetExtraData(pInfCache->pSearchTable,nHitIndex,&searchentry,sizeof(searchentry))) {
            MYASSERT(FALSE); // should not fail
        }
    }
    return searchentry.Flags;
}

#endif

#ifdef UNICODE

DWORD InfCacheMarkMatchInfs(
    IN OUT PINFCACHE pInfCache,
    IN PCTSTR MatchString,
    IN ULONG MatchFlag
    )
/*++

Routine Description:

    Called to iterate through the INF's associated with MatchString
    and flag them using MatchFlag

Arguments:

    pInfCache - cache to check (may modify search data)
    MatchString - match string to include
    MatchFlag - flag to set in all INF's associated with match string

Return Value:

    status - typically NO_ERROR

--*/
{
    LONG MatchIndex;
    DWORD StringLength;
    CACHEMATCHENTRY matchentry;
    ULONG entry;
    PTSTR InfName;
    ULONG SearchFlags;

    MYASSERT(pInfCache);
    MYASSERT(MatchString);
    MYASSERT(MatchFlag);

    //
    // find list of Inf's associated with match string
    //
    MatchIndex = pStringTableLookUpString(pInfCache->pMatchTable,
                                                    (PTSTR)MatchString, // it will not be modified
                                                    &StringLength,
                                                    NULL, // hash value
                                                    NULL, // find context
                                                    STRTAB_CASE_INSENSITIVE,
                                                    &matchentry,
                                                    sizeof(matchentry));
    if(MatchIndex < 0) {
        //
        // no match
        //
        return NO_ERROR;
    }
    for(entry = matchentry.InfList ; entry > 0 && entry < pInfCache->pHeader->ListDataCount ; entry = pInfCache->pListTable[entry].Next) {
        LONG InfEntry = pInfCache->pListTable[entry].Value;
        //
        // obtain name of Inf
        //
        InfName = pStringTableStringFromId(pInfCache->pInfTable,InfEntry);
        SearchFlags = InfCacheSearchTableSetFlags(pInfCache,InfName,MatchFlag,0);
        if(SearchFlags == (ULONG)(-1)) {
            //
            // failed - huh?
            // abort into fail-safe pass
            //
            MYASSERT(SearchFlags != (ULONG)(-1));
            return GetLastError();
        }
    }
    return NO_ERROR;
}

#endif

#ifdef UNICODE

BOOL
InfCacheSearchEnum(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Callback for Phase-3 of InfCacheSearchDirectory

Arguments:

    StringTable - unused
    StringId - unused
    String - used to form INF name
    ExtraData - points to flags
    ExtraDataSize - unused
    lParam - points to InfCacheEnumData

Return Value:

    always TRUE unless out of memory condition

--*/
{
    PINFCACHE_ENUMDATA enum_data = (PINFCACHE_ENUMDATA)lParam;
    CACHEHITENTRY *hit_stats = (CACHEHITENTRY *)ExtraData;
    PTSTR InfFullPath = NULL;
    DWORD InfFullPathSize;
    BOOL b;
    WIN32_FIND_DATA FindData;
    PLOADED_INF pInf = NULL;
    UINT ErrorLineNumber;
    BOOL PnfWasUsed;
    BOOL cont = TRUE;

    MYASSERT(ExtraDataSize == sizeof(CACHEHITENTRY));
    MYASSERT(String);
    MYASSERT(enum_data);
    MYASSERT(hit_stats);
    MYASSERT(enum_data->Requirement);
    MYASSERT(enum_data->Callback);

    //
    // see if this is an INF of interest
    //
    if((hit_stats->Flags & enum_data->Requirement) == enum_data->Requirement) {
        //
        // this is a HIT
        // we need to open HINF
        //
        InfFullPathSize = lstrlen(enum_data->InfDir)+MAX_PATH+2;
        InfFullPath = MyMalloc(InfFullPathSize*sizeof(TCHAR));
        if (!InfFullPath) {
            return TRUE; // out of memory (does not abort search)
        }
        lstrcpy(InfFullPath,enum_data->InfDir);
        pSetupConcatenatePaths(InfFullPath,String,InfFullPathSize,NULL);

        if(b = FileExists(InfFullPath, &FindData)) {

            if(LoadInfFile(InfFullPath,
                           &FindData,
                           INF_STYLE_WIN4 | INF_STYLE_OLDNT, // we've filtered this ourselves
                           LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | LDINF_FLAG_ALWAYS_TRY_PNF,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           enum_data->LogContext,
                           &pInf,
                           &ErrorLineNumber,
                           &PnfWasUsed) != NO_ERROR) {
                pInf = NULL;
                WriteLogEntry(
                            enum_data->LogContext,
                            DRIVER_LOG_VVERBOSE,
                            MSG_LOG_COULD_NOT_LOAD_HIT_INF,
                            NULL,
                            InfFullPath);
            }
        } else {
            pInf = NULL;
        }

        if (pInf) {
            cont = enum_data->Callback(enum_data->LogContext,InfFullPath,pInf,PnfWasUsed,enum_data->Context);
            if(!cont) {
                enum_data->ExitStatus = GetLastError();
                MYASSERT(enum_data->ExitStatus);
            }
            FreeInfFile(pInf);
        }
    }
    if (InfFullPath) {
        MyFree(InfFullPath);
    }

    return cont;
}

#endif

DWORD InfCacheSearchDirectory(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN DWORD Action,
    IN PCTSTR InfDir,
    IN InfCacheCallback Callback, OPTIONAL
    IN PVOID Context, OPTIONAL
    IN PCTSTR ClassIdList, OPTIONAL
    IN PCTSTR HwIdList OPTIONAL
    )
/*++

Routine Description:

    Main workhorse of the InfCache
    Search a single specified directory
    calling Callback(hInf,Context) for each inf that has a likelyhood of matching

    note that Action flags, ClassId and HwIdList are hints, and Callback may get
    called for any/all INF's Callback must re-check for all search criteria.

    Searching is done in 3 phases

    Phase 1: Parse all INF's in directory. If an INF is not in cache, *almost always* call
    callback. If special inclusions (OLD INF's INF's with no Class GUID's) specified, then
    INF's that match the special criteria are processed here (since they can't be processed
    in Phase 2). All INF's that exist, haven't been processed and haven't been excluded get
    marked with CHE_FLAGS_PENDING ready for phase-2

    Phase 2: Process ClassId and HwIdList matching, setting CHE_FLAGS_GUIDMATCH and
    CHE_FLAGS_IDMATCH apropriately in matching INF's and search criteria flags. Search
    criteria will either be:
    CHE_FLAGS_PENDING - callback on all Win4 style INF's
    CHE_FLAGS_PENDING | CHE_FLAGS_GUIDMATCH - callback on all Win4 INF's that have matching class
    CHE_FLAGS_PENDING | CHE_FLAGS_IDMATCH - wildcard class, matching hardware ID's
    CHE_FLAGS_PENDING | CHE_FLAGS_GUIDMATCH | CHE_FLAGS_IDMATCH - most specific match

    Phase 3: enumerate through all INF's that we've marked with exact same flags as
    search criteria, and call callback on those INF's

    Using this search method, Win4 INF's that are in the cache are always processed last.

Arguments:

    LogContext - for logging
    InfDir - single directory to search
    Callback - function to call on a likely match
    Context - parameter to pass to function
    ClassIdList (optional) - multi-sz list of class id's (typically guid, name and legacy name)
    HwIdList (optional)- multi-sz list of hardware id's


Return Value:

    status, typically NO_ERROR

--*/
{
    PINFCACHE pInfCache = NULL;
    PTSTR InfPath = NULL;
    UINT PathSize;
    DWORD Err = NO_ERROR;
    WIN32_FIND_DATA FindFileData;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    BOOL bNoWriteBack = FALSE;
    LONG InfId;
    LONG SearchId;
    ULONG SearchFlags;
    CACHEINFENTRY inf_entry;
    CACHEHITENTRY hit_stats;
    ULONG ReqFlags;
    INFCACHE_ENUMDATA enum_data;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    BOOL TryPnf = FALSE;
    BOOL TryCache = FALSE;

    MYASSERT(InfDir);

    //
    // obtain cache for directory of interest
    // we should be able to handle a NULL return
    // note that caller can either treat these two bits
    // as an operation (0-3) or as bitmaps
    // the result would be the same
    //

    if(!LogContext) {
        if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
            LogContext = LocalLogContext;
        } else {
            LocalLogContext = NULL;
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    WriteLogEntry(
                LogContext,
                DRIVER_LOG_VVERBOSE,
                MSG_LOG_ENUMERATING_FILES,
                NULL,
                InfDir);

    PathSize = lstrlen(InfDir)+10;
    InfPath = MyMalloc(PathSize*sizeof(TCHAR));
    if(!InfPath) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    lstrcpy(InfPath,InfDir);
    pSetupConcatenatePaths(InfPath,INFCACHE_INF_WILDCARD,PathSize,NULL);

#ifdef UNICODE
    if (pSetupInfIsFromOemLocation(InfPath,FALSE)) {
        if (Action & INFCACHE_FORCE_CACHE) {
            TryCache = TRUE;
        }
        if (Action & INFCACHE_FORCE_PNF) {
            TryPnf = TRUE;
        }
    } else {

        TryPnf = TRUE;

        //
        // Try using INF cache unless we're doing an INFCACHE_ENUMALL
        //
        if((Action & INFCACHE_ACTIONBITS) != INFCACHE_ENUMALL) {
            TryCache = TRUE;
        }
    }
    if (!TryCache) {
        //
        // directory is not in our default search path
        // treat as INFCACHE_ENUMALL
        //
        pInfCache = NULL;
    } else {
        switch(Action & INFCACHE_ACTIONBITS) {
            case INFCACHE_NOWRITE:
                pInfCache = InfCacheLoadCache(InfDir,LogContext);
                bNoWriteBack = TRUE;
                break;
            case INFCACHE_DEFAULT:
                pInfCache = InfCacheLoadCache(InfDir,LogContext);
                break;
            case INFCACHE_REBUILD:
                pInfCache = InfCacheCreateNewCache(LogContext);
                break;
            case INFCACHE_ENUMALL:
                pInfCache = NULL;
                break;
            default:
                MYASSERT(FALSE);
        }
    }
#else
    pInfCache = NULL;
#endif

    //
    // first phase - enumerate the INF directory
    //
    FindHandle = FindFirstFile(InfPath,&FindFileData);
    if(FindHandle != INVALID_HANDLE_VALUE) {
        do {
            BOOL NewInf = FALSE;
            BOOL bCallCallback = FALSE;
            PLOADED_INF pInf = NULL;
            UINT ErrorLineNumber;
            BOOL PnfWasUsed;

#ifdef UNICODE
            if(!pInfCache || pInfCache->bNoWriteBack) {
                //
                // fallen into failsafe mode
                //
                bCallCallback = TRUE;
            } else {
                //
                // mark this INF as existing
                //
                SearchFlags = InfCacheSearchTableSetFlags(pInfCache,
                                                    FindFileData.cFileName,
                                                        CHE_FLAGS_PENDING, // start off expecting this INF to be processed later
                                                    0);
                if(SearchFlags == (ULONG)(-1)) {
                    //
                    // failed - handle here
                    //
                    bCallCallback = TRUE;
                }
                InfId = InfCacheLookupInf(pInfCache,&FindFileData,&inf_entry);
                if (InfId<0) {
                    NewInf = TRUE;
                } else {
#if 0
                    //
                    // handle special inclusions (we can't handle these in Phase 2)
                    //
                    if (((Action&INFCACHE_INC_OLDINFS) && (inf_entry.MatchFlags&CIEF_INF_OLDINF)) ||
                        ((Action&INFCACHE_INC_NOCLASS) && (inf_entry.MatchFlags&CIEF_INF_NOCLASS))) {
                        bCallCallback = TRUE;
                    }
#endif
                    //
                    // handle exclusions (so that they will get excluded in Phase 2)
                    // exclusions are different for OLDNT and WIN4
                    //
                    if (inf_entry.MatchFlags & CIEF_INF_WIN4) {
                        //
                        // WIN4 INF
                        //
                        if(((Action & INFCACHE_EXC_URL) && (inf_entry.MatchFlags & CIEF_INF_URL)) ||
                           ((Action & INFCACHE_EXC_NULLCLASS) && (inf_entry.MatchFlags & CIEF_INF_NULLGUID)) ||
                           ((Action & INFCACHE_EXC_NOMANU) && !(inf_entry.MatchFlags & CIEF_INF_MANUFACTURER)) ||
                           ((Action & INFCACHE_EXC_NOCLASS) && !(inf_entry.MatchFlags & CIEF_INF_CLASSINFO))) {
                            //
                            // exclude this INF
                            //
                            InfCacheSearchTableSetFlags(pInfCache,
                                                        FindFileData.cFileName,
                                                        0,
                                                        CHE_FLAGS_PENDING);
                            WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_VVERBOSE,
                                        MSG_LOG_EXCLUDE_WIN4_INF,
                                        NULL,
                                        FindFileData.cFileName);
                        }

                    } else if (inf_entry.MatchList & CIEF_INF_OLDNT) {

                        if((Action & INFCACHE_EXC_OLDINFS) ||
                           ((Action & INFCACHE_EXC_NOCLASS) && !(inf_entry.MatchList & CIEF_INF_CLASSINFO))) {
                            //
                            // exclude this INF
                            //
                            InfCacheSearchTableSetFlags(pInfCache,
                                                        FindFileData.cFileName,
                                                        0,
                                                        CHE_FLAGS_PENDING);
                            WriteLogEntry(
                                        LogContext,
                                        DRIVER_LOG_VVERBOSE,
                                        MSG_LOG_EXCLUDE_OLDNT_INF,
                                        NULL,
                                        FindFileData.cFileName);
                        } else {
                            //
                            // allow old INF's to match with any HwId's
                            // by considering it already matched
                            //
                            InfCacheSearchTableSetFlags(pInfCache,
                                                        FindFileData.cFileName,
                                                        CHE_FLAGS_IDMATCH,
                                                        0);
                        }
                    } else {
                        //
                        // always exclude non-inf's
                        //
                        InfCacheSearchTableSetFlags(pInfCache,
                                                    FindFileData.cFileName,
                                                    0,
                                                    CHE_FLAGS_PENDING);
                    }
                }
            }
#else
            bCallCallback = TRUE; // Win9x
#endif
            if (!Callback) {
                //
                // we were only called to re-build the cache
                //
                bCallCallback = FALSE;
            }
            if (NewInf || bCallCallback) {
                PTSTR InfFullPath = NULL;
                DWORD InfFullPathSize = lstrlen(InfDir)+MAX_PATH+2;

                //
                // we need to open HINF in either case
                //
                InfFullPath = MyMalloc(InfFullPathSize*sizeof(TCHAR));
                if(InfFullPath == NULL) {
                    //
                    // carry on with other files, even if out of memory
                    // not the best thing to do, but consistant with
                    // what we did before.
                    //
                    continue;
                }
                lstrcpy(InfFullPath,InfDir);
                pSetupConcatenatePaths(InfFullPath,FindFileData.cFileName,InfFullPathSize,NULL);

                if((Err=LoadInfFile(InfFullPath,
                               &FindFileData,
                               INF_STYLE_WIN4 | INF_STYLE_OLDNT, // we'll filter this ourselves
                               LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf?LDINF_FLAG_ALWAYS_TRY_PNF:0),
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               LogContext,
                               &pInf,
                               &ErrorLineNumber,
                               &PnfWasUsed)) != NO_ERROR) {
                    pInf = NULL;
                    WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_VVERBOSE,
                                MSG_LOG_COULD_NOT_LOAD_NEW_INF,
                                NULL,
                                InfFullPath);
                }

#ifdef UNICODE
                if(NewInf) {
                    //
                    // if opening the INF failed, we still want to record this fact
                    // in the cache so we don't try to re-open next time round
                    //
                    InfId = InfCacheAddInf(LogContext,pInfCache,&FindFileData,&inf_entry,pInf);

                    if(Callback) {
                        bCallCallback = TRUE;
                    }
                }
#endif
                if (pInf) {
                    if (bCallCallback && Callback) {
                        //
                        // we're processing the INF now
                        // clear pending flag (if we can) so we don't try and process INF a 2nd time
                        // the only time this can fail is if we haven't already added the INF
                        // so either way we wont callback twice
                        //
#ifdef UNICODE
                        if (pInfCache) {
                            //
                            // only set flags in the cache
                            // if we have a cache :-)
                            //
                            InfCacheSearchTableSetFlags(pInfCache,FindFileData.cFileName,0,CHE_FLAGS_PENDING);
                        }
#endif
                        if(!Callback(LogContext,InfFullPath,pInf,PnfWasUsed,Context)) {
                            Err = GetLastError();
                            MYASSERT(Err);
                            FreeInfFile(pInf);
                            MyFree(InfFullPath);
                            goto cleanup;
                        }
                    }
                    FreeInfFile(pInf);
                }
                MyFree(InfFullPath);
            }

        } while (FindNextFile(FindHandle,&FindFileData));
        FindClose(FindHandle);
    }

    if (!pInfCache) {
        //
        // we have processed all files already
        // skip cache search code, since we don't
        // have a cache to search
        //
        Err = NO_ERROR;
        goto cleanup;
    }

#ifdef UNICODE
    //
    // at this point we can commit cache
    //
    WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_END_CACHE_1,
                NULL);

    if(pInfCache && !bNoWriteBack) {
        InfCacheWriteCache(InfDir,pInfCache,LogContext);
    }

    if (!Callback) {
        //
        // optimization: no callback
        // (we were only called, eg, to update cache)
        // leave early
        //
        Err = NO_ERROR;
        goto cleanup;
    }

    //
    // Phase 2 - determine all other INF's to process via Cache
    //
    // will want INFs that exist, haven't yet been processed
    // and haven't been excluded
    //

    ReqFlags = CHE_FLAGS_PENDING;

    if (ClassIdList && ClassIdList[0]) {

        PCTSTR ClassId;

        //
        // Primary list (typically Class GUID, Class Name and Legacy Class Name)
        //
        Err = NO_ERROR;
        for(ClassId = ClassIdList;*ClassId;ClassId += lstrlen(ClassId)+1) {
            Err = InfCacheMarkMatchInfs(pInfCache,ClassId,CHE_FLAGS_GUIDMATCH);
            if (Err != NO_ERROR) {
                break;
            }
        }
        if (Err == NO_ERROR) {
            //
            // succeeded, restrict requirement
            //
            ReqFlags |= CHE_FLAGS_GUIDMATCH;
        }
    }
    if (HwIdList && HwIdList[0]) {

        PCTSTR HwId;

        //
        // Secondary list
        // if a list of hardware Id's specified, we only want hits that include
        // any of the hardware Id's
        //
        Err = NO_ERROR;
        for(HwId = HwIdList;*HwId;HwId += lstrlen(HwId)+1) {
            Err = InfCacheMarkMatchInfs(pInfCache,HwId,CHE_FLAGS_IDMATCH);
            if(Err != NO_ERROR) {
                break;
            }
        }
        if (Err == NO_ERROR) {
            //
            // succeeded, restrict requirement
            //
            ReqFlags |= CHE_FLAGS_IDMATCH;
        }
    }

    //
    // Phase 3 - process all INF's that meet requirements
    // do this by simply enumerating the search string table
    //
    enum_data.LogContext = LogContext;
    enum_data.Callback = Callback;
    enum_data.Context = Context;
    enum_data.InfDir = InfDir;
    enum_data.Requirement = ReqFlags;
    enum_data.ExitStatus = NO_ERROR;

    Err = NO_ERROR;
    if(!pStringTableEnum(pInfCache->pSearchTable,
                        &hit_stats,
                        sizeof(hit_stats),
                        InfCacheSearchEnum,
                        (LPARAM)&enum_data)) {
        //
        // we'll only fail for error condition
        //

        Err = enum_data.ExitStatus;
    }

    WriteLogEntry(
                LogContext,
                DRIVER_LOG_TIME,
                MSG_LOG_END_CACHE_2,
                NULL);


#else

    Err = NO_ERROR;

#endif

cleanup:

#ifdef UNICODE
    if (pInfCache) {
        InfCacheFreeCache(pInfCache);
    }
#endif
    if (InfPath) {
        MyFree(InfPath);
    }
    if (LogContext && LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }

    return Err;
}


DWORD InfCacheSearchPath(
    IN PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    IN DWORD Action,
    IN PCTSTR InfDirPath, OPTIONAL
    IN InfCacheCallback Callback, OPTIONAL
    IN PVOID Context, OPTIONAL
    IN PCTSTR ClassIdList, OPTIONAL
    IN PCTSTR HwIdList OPTIONAL
    )
/*++

Routine Description:

    Iterates InfDirPath calling InfCacheSearchDirectory for each entry

Arguments:

    LogContext - for logging
    InfDir - single directory to search - if not specified, uses driver path
    Callback - function to call on a likely match
    Context - parameter to pass to function
    ClassIdList (optional) - multi-sz list of class id's (typically guid, name and legacy name)
    HwIdList (optional)- multi-sz list of hardware id's


Return Value:

    status, typically NO_ERROR

--*/
{

    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    DWORD Err = NO_ERROR;
    PCTSTR InfDir;

    if (!InfDirPath) {
        InfDirPath = InfSearchPaths;
    }

    if(!LogContext) {
        if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
            LogContext = LocalLogContext;
        } else {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for (InfDir = InfDirPath; *InfDir; InfDir+=lstrlen(InfDir)+1) {
        Err = InfCacheSearchDirectory(LogContext,Action,InfDir,Callback,Context,ClassIdList,HwIdList);
        if(Err != NO_ERROR) {
            break;
        }
    }

    if (LogContext && LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }

    return Err;
}

#ifdef UNICODE

BOOL WINAPI pSetupInfCacheBuild(
    IN DWORD Action
    )
/*++

Routine Description:

    Privately exported, called from (eg) syssetup to reset cache(s)

Arguments:

    Action - one of:
        INFCACHEBUILD_UPDATE
        INFCACHEBUILD_REBUILD

Return Value:

    TRUE if success, FALSE on Error (GetLastError indicates error)

--*/
{
    DWORD RealAction;
    DWORD Err;

    switch(Action) {
        case INFCACHEBUILD_UPDATE:
            RealAction = INFCACHE_DEFAULT;
            break;
        case INFCACHEBUILD_REBUILD:
            RealAction = INFCACHE_REBUILD;
            break;
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }
    RealAction |= INFCACHE_FORCE_CACHE|INFCACHE_FORCE_PNF;

    try {
        Err = InfCacheSearchPath(NULL,
                                    RealAction,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL
                                    );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_DATA;
    }
    SetLastError(Err);

    return Err==NO_ERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\inf.h ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    infload.h

Abstract:

    Private header file for internal inf routines.

Author:

    Ted Miller (tedm) 19-Jan-1995

Revision History:

    Gabe Schaffer (t-gabes) 19-Jul-1998
        Added LogContext to LOADED_INF
--*/


//
// Define maximum string sizes allowed in INFs.
//
#define MAX_STRING_LENGTH 511 // this is the maximum size of an unsubstituted string
#define MAX_SECT_NAME_LEN 255
#if MAX_SECT_NAME_LEN > MAX_STRING_LENGTH
#error MAX_SECT_NAME_LEN is too large!
#endif

#define MAX_LOGCONFKEYSTR_LEN       15

#include "pshpack1.h"

//
// Make absolutely sure that these structures are DWORD aligned
// because we turn alignment off, to make sure sdtructures are
// packed as tightly as possible into memory blocks.
//

//
// Internal representation of a section in an inf file
//
typedef struct _INF_LINE {

    //
    // Number of values on the line
    // This includes the key if Flags has INF_LINE_HASKEY
    // (In that case the first two entries in the Values array
    // contain the key--the first one in case-insensitive form used
    // for lookup, and the second in case-sensitive form for display.
    // INF lines with a single value (no key) are treated the same way.)
    // Otherwise the first entry in the Values array is the first
    // value on the line
    //
    WORD ValueCount;
    WORD Flags;

    //
    // String IDs for the values on the line.
    // The values are stored in the value block,
    // one after another.
    //
    // The value is the offset within the value block as opposed to
    // an actual pointer. We do this because the value block gets
    // reallocated as the inf file is loaded.
    //
    UINT Values;

} INF_LINE, *PINF_LINE;

//
// INF_LINE.Flags
//
#define INF_LINE_HASKEY     0x0000001
#define INF_LINE_SEARCHABLE 0x0000002

#define HASKEY(Line)       ((Line)->Flags & INF_LINE_HASKEY)
#define ISSEARCHABLE(Line) ((Line)->Flags & INF_LINE_SEARCHABLE)

//
// INF section
// This guy is kept separate and has a pointer to the actual data
// to make sorting the sections a little easier
//
typedef struct _INF_SECTION {
    //
    // String Table ID of the name of the section
    //
    LONG  SectionName;

    //
    // Number of lines in this section
    //
    DWORD LineCount;

    //
    // The section's lines. The line structures are stored packed
    // in the line block, one after another.
    //
    // The value is the offset within the line block as opposed to
    // an actual pointer. We do it this way because the line block
    // gets reallocated as the inf file is loaded.
    //
    UINT Lines;

} INF_SECTION, *PINF_SECTION;

//
// Params for section enumeration
//

typedef struct {
    PTSTR       Buffer;
    UINT        Size;
    UINT        SizeNeeded;
    PTSTR       End;
} SECTION_ENUM_PARAMS, *PSECTION_ENUM_PARAMS;


#include "poppack.h"

//
// Define structures for user-defined DIRID storage.
//
typedef struct _USERDIRID {
    UINT Id;
    TCHAR Directory[MAX_PATH];
} USERDIRID, *PUSERDIRID;

typedef struct _USERDIRID_LIST {
    PUSERDIRID UserDirIds;  // may be NULL
    UINT UserDirIdCount;
} USERDIRID_LIST, *PUSERDIRID_LIST;

typedef struct _STRINGSUBST_NODE {
    UINT ValueOffset;
    LONG TemplateStringId;
    BOOL CaseSensitive;
} STRINGSUBST_NODE, *PSTRINGSUBST_NODE;

//
// Any system DIRID (i.e., >0x8000) that has bit 0x4000 set is a 'volatile'
// DIRID (these DIRIDs are volatile in the sense that, while they're not in the
// user-definable range, they're treated as if they were, and string replacement
// is done on-the-fly each time the PNF is loaded.  The shell special folders
// (CSIDL_* defines in sdk\inc\shlobj.h), for example, are in this range.  In
// the case of shell special folders, the actual CSIDL value (i.e., as is
// passed into SHGetSpecialFolderPath) can be obtained by simply masking out
// the volatile DIRID bit.
//
// Define the bitmask used to determine whether a system DIRID is volatile.
//
#define VOLATILE_DIRID_FLAG 0x4000

//
// Version block structure that is stored (packed) in the opaque
// VersionData buffer of a caller-supplied SP_INF_INFORMATION structure.
//
typedef struct _INF_VERSION_BLOCK {
    UINT NextOffset;
    FILETIME LastWriteTime;
    WORD DatumCount;
    WORD OffsetToData; // offset (in bytes) from beginning of Filename buffer.
    UINT DataSize;     // DataSize and TotalSize are both byte counts.
    UINT TotalSize;
    TCHAR Filename[ANYSIZE_ARRAY];
    //
    // Data follows Filename in the buffer
    //
} INF_VERSION_BLOCK, *PINF_VERSION_BLOCK;

//
// Internal version block node.
//
typedef struct _INF_VERSION_NODE {
    FILETIME LastWriteTime;
    UINT FilenameSize;
    CONST TCHAR *DataBlock;
    UINT DataSize;
    WORD DatumCount;
    TCHAR Filename[MAX_PATH];
} INF_VERSION_NODE, *PINF_VERSION_NODE;

//
// Internal representation of an inf file.
//
typedef struct _LOADED_INF {
    DWORD Signature;

    //
    // The following 3 fields are used for precompiled INFs (PNF).
    // If FileHandle is not INVALID_HANDLE_VALUE, then this is a PNF,
    // and the MappingHandle and ViewAddress fields are also valid.
    // Otherwise, this is a plain old in-memory INF.
    //
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID  ViewAddress;

    PVOID StringTable;
    DWORD SectionCount;
    PINF_SECTION SectionBlock;
    PINF_LINE LineBlock;
    PLONG ValueBlock;
    INF_VERSION_NODE VersionBlock;
    BOOL HasStrings;

    //
    // If this INF contains any DIRID references to the system partition, then
    // store the OsLoader path that was used when compiling this INF here.  (This
    // value will always be correct when the INF is loaded.  However, if drive letters
    // are subsequently reassigned, then it will be incorrect until the INF is unloaded
    // and re-loaded.)
    //
    PCTSTR OsLoaderPath;    // may be NULL

    //
    // Remember the location where this INF originally came from (may be a directory
    // path or a URL).
    //
    DWORD  InfSourceMediaType;  // SPOST_PATH or SPOST_URL
    PCTSTR InfSourcePath;       // may be NULL

    //
    // Remember the INF's original filename, before it was installed into
    // %windir%\Inf (i.e., automatically via device installation or explicitly
    // via SetupCopyOEMInf).
    //
    PCTSTR OriginalInfName;     // may be NULL

    //
    // Maintain a list of value offsets that require string substitution at
    // run-time.
    //
    PSTRINGSUBST_NODE SubstValueList;   // may be NULL
    WORD SubstValueCount;

    //
    // Place the style WORD here (immediately following another WORD field),
    // to fill a single DWORD.
    //
    WORD Style;                         // INF_STYLE_OLDNT, INF_STYLE_WIN4

    //
    // Sizes in bytes of various buffers
    //
    UINT SectionBlockSizeBytes;
    UINT LineBlockSizeBytes;
    UINT ValueBlockSizeBytes;

    //
    // Track what language was used when loading this INF.
    //
    DWORD LanguageId;

    //
    // Embedded structure containing information about the current user-defined
    // DIRID values.
    //
    USERDIRID_LIST UserDirIdList;

    //
    // Synchronization.
    //
    MYLOCK Lock;

    //
    // Log context for error logging
    //
    PSETUP_LOG_CONTEXT LogContext;

    //
    // Other flags
    //
    DWORD Flags;

    //
    // INFs are append-loaded via a doubly-linked list of LOADED_INFs.
    // (list is not circular--Prev of head is NULL, Next of tail is NULL)
    //
    struct _LOADED_INF *Prev;
    struct _LOADED_INF *Next;

} LOADED_INF, *PLOADED_INF;

#define LOADED_INF_SIG   0x24666e49      // Inf$

#define LockInf(Inf)    BeginSynchronizedAccess(&(Inf)->Lock)
#define UnlockInf(Inf)  EndSynchronizedAccess(&(Inf)->Lock)

//
// Define values for LOADED_INF.Flags field
//
//
// WARNING: The LIF_INF_DIGITALLY_SIGNED flag does not guarantee that the INF
// is currently digitally signed. When creating the PNF we verify that the INF
// is correctly digitally signed and then set this bit in the PNF. Currently we
// only use this flag to determine whether we should use the DriverVer date
// or not.
//
#define LIF_HAS_VOLATILE_DIRIDS    (0x00000001)
#define LIF_INF_DIGITALLY_SIGNED   (0x00000002)
#define LIF_OEM_F6_INF             (0x00000004)


//
// Helper define
//
#define INF_STYLE_ALL   (INF_STYLE_WIN4 | INF_STYLE_OLDNT)


//
// Define file header structure for precompiled INF (.PNF).
//
typedef struct _PNF_HEADER {

    WORD  Version;  // HiByte - Major Ver#, LoByte - Minor Ver#
    WORD  InfStyle;
    DWORD Flags;

    DWORD    InfSubstValueListOffset;
    WORD     InfSubstValueCount;

    WORD     InfVersionDatumCount;
    DWORD    InfVersionDataSize;
    DWORD    InfVersionDataOffset;
    FILETIME InfVersionLastWriteTime;

    DWORD StringTableBlockOffset;
    DWORD StringTableBlockSize;

    DWORD InfSectionCount;
    DWORD InfSectionBlockOffset;
    DWORD InfSectionBlockSize;
    DWORD InfLineBlockOffset;
    DWORD InfLineBlockSize;
    DWORD InfValueBlockOffset;
    DWORD InfValueBlockSize;

    DWORD WinDirPathOffset;
    DWORD OsLoaderPathOffset;

    WORD StringTableHashBucketCount;

    WORD LanguageId;

    DWORD InfSourcePathOffset;      // may be 0

    DWORD OriginalInfNameOffset;    // may be 0

} PNF_HEADER, *PPNF_HEADER;

//
// Define Major and Minor versions of the PNF format (currently 1.1)
//
#define PNF_MAJOR_VERSION (0x01)
#define PNF_MINOR_VERSION (0x01)

//
// Define flag values for the PNF header's Flags field.
//
// WARNING: The PNF_FLAG_INF_DIGITALLY_SIGNED flag does not guarantee that the INF
// is currently digitally signed. When creating the PNF we verify that the INF
// is correctly digitally signed and then set this bit in the PNF. Currently we
// only use this flag to determine whether we should use the DriverVer date
// or not.

#define PNF_FLAG_IS_UNICODE             (0x00000001)
#define PNF_FLAG_HAS_STRINGS            (0x00000002)
#define PNF_FLAG_SRCPATH_IS_URL         (0x00000004)
#define PNF_FLAG_HAS_VOLATILE_DIRIDS    (0x00000008)
#define PNF_FLAG_RESERVED1              (0x00000010) // was PNF_FLAG_INF_VERIFIED for Win2k
#define PNF_FLAG_INF_DIGITALLY_SIGNED   (0x00000020)
#define PNF_FLAG_OEM_F6_INF             (0x00000040)
#define PNF_FLAG_16BIT_SUITE            (0x00000080) // if set, lower 16 bits of suite
                                                     // is in upper 16 bits of flags
#define PNF_FLAG_INF_VERIFIED           (0x00000100)



//
// Public inf functions in infload.c. All other routines are private to
// the inf handler package.
//
DWORD
DetermineInfStyle(
    IN PCTSTR            Filename,
    IN LPWIN32_FIND_DATA FindData
    );

//
// Flags for LoadInfFile.
//
#define LDINF_FLAG_MATCH_CLASS_GUID        (0x00000001)
#define LDINF_FLAG_ALWAYS_TRY_PNF          (0x00000002)
#define LDINF_FLAG_IGNORE_VOLATILE_DIRIDS  (0x00000004) // includes system partition
#define LDINF_FLAG_IGNORE_LANGUAGE         (0x00000008)
#define LDINF_FLAG_REGENERATE_PNF          (0x00000010)
#define LDINF_FLAG_SRCPATH_IS_URL          (0x00000020)
#define LDINF_FLAG_ALWAYS_GET_SRCPATH      (0x00000040) // used to work around TZ change in FAT
#define LDINF_FLAG_OEM_F6_INF              (0x00000080)
#define LDINF_FLAG_ALLOW_PNF_SHARING_LOCK  (0x00000100) // don't fail if PNF locked

DWORD
LoadInfFile(
    IN  PCTSTR            Filename,
    IN  LPWIN32_FIND_DATA FileData,
    IN  DWORD             Style,
    IN  DWORD             Flags,
    IN  PCTSTR            ClassGuidString, OPTIONAL
    IN  PCTSTR            InfSourcePath,   OPTIONAL
    IN  PCTSTR            OriginalInfName, OPTIONAL
    IN  PLOADED_INF       AppendInf,       OPTIONAL
    IN  PSETUP_LOG_CONTEXT LogContext,     OPTIONAL
    OUT PLOADED_INF      *LoadedInf,
    OUT UINT             *ErrorLineNumber,
    OUT BOOL             *PnfWasUsed       OPTIONAL
    );

VOID
FreeInfFile(
    IN PLOADED_INF LoadedInf
    );


//
// Global strings used throughout the inf loaders/runtime stuff.  Sizes are
// included so that we can do sizeof() instead of lstrlen() to determine string
// length.
//
// The content of the following strings is defined in infstr.h:
//
extern CONST TCHAR pszSignature[SIZECHARS(INFSTR_KEY_SIGNATURE)],
                   pszVersion[SIZECHARS(INFSTR_SECT_VERSION)],
                   pszClass[SIZECHARS(INFSTR_KEY_HARDWARE_CLASS)],
                   pszClassGuid[SIZECHARS(INFSTR_KEY_HARDWARE_CLASSGUID)],
                   pszProvider[SIZECHARS(INFSTR_KEY_PROVIDER)],
                   pszStrings[SIZECHARS(SZ_KEY_STRINGS)],
                   pszLayoutFile[SIZECHARS(SZ_KEY_LAYOUT_FILE)],
                   pszManufacturer[SIZECHARS(INFSTR_SECT_MFG)],
                   pszControlFlags[SIZECHARS(INFSTR_CONTROLFLAGS_SECTION)],
                   pszSourceDisksNames[SIZECHARS(SZ_KEY_SRCDISKNAMES)],
                   pszSourceDisksFiles[SIZECHARS(SZ_KEY_SRCDISKFILES)],
                   pszDestinationDirs[SIZECHARS(SZ_KEY_DESTDIRS)],
                   pszDefaultDestDir[SIZECHARS(SZ_KEY_DEFDESTDIR)],
                   pszReboot[SIZECHARS(INFSTR_REBOOT)],
                   pszRestart[SIZECHARS(INFSTR_RESTART)],
                   pszClassInstall32[SIZECHARS(INFSTR_SECT_CLASS_INSTALL_32)],
                   pszAddInterface[SIZECHARS(SZ_KEY_ADDINTERFACE)],
                   pszInterfaceInstall32[SIZECHARS(INFSTR_SECT_INTERFACE_INSTALL_32)],
                   pszAddService[SIZECHARS(SZ_KEY_ADDSERVICE)],
                   pszDelService[SIZECHARS(SZ_KEY_DELSERVICE)],
                   pszCatalogFile[SIZECHARS(INFSTR_KEY_CATALOGFILE)],
                   pszMemConfig[SIZECHARS(INFSTR_KEY_MEMCONFIG)],
                   pszIOConfig[SIZECHARS(INFSTR_KEY_IOCONFIG)],
                   pszIRQConfig[SIZECHARS(INFSTR_KEY_IRQCONFIG)],
                   pszDMAConfig[SIZECHARS(INFSTR_KEY_DMACONFIG)],
                   pszPcCardConfig[SIZECHARS(INFSTR_KEY_PCCARDCONFIG)],
                   pszMfCardConfig[SIZECHARS(INFSTR_KEY_MFCARDCONFIG)],
                   pszConfigPriority[SIZECHARS(INFSTR_KEY_CONFIGPRIORITY)],
                   pszDriverVer[SIZECHARS(INFSTR_DRIVERVERSION_SECTION)];

//
// Other misc. global strings:
//
#define DISTR_INF_DRVDESCFMT               (TEXT("%s.") INFSTR_STRKEY_DRVDESC)
#define DISTR_INF_HWSECTIONFMT             (TEXT("%s.") INFSTR_SUBKEY_HW)
#define DISTR_INF_CHICAGOSIG               (TEXT("$Chicago$"))
#define DISTR_INF_WINNTSIG                 (TEXT("$Windows NT$"))
#define DISTR_INF_WIN95SIG                 (TEXT("$Windows 95$"))
#define DISTR_INF_WIN_SUFFIX               (TEXT(".") INFSTR_PLATFORM_WIN)
#define DISTR_INF_NT_SUFFIX                (TEXT(".") INFSTR_PLATFORM_NT)
#define DISTR_INF_PNF_SUFFIX               (TEXT(".PNF"))
#define DISTR_INF_INF_SUFFIX               (TEXT(".INF"))
#define DISTR_INF_CAT_SUFFIX               (TEXT(".CAT"))
#define DISTR_INF_SERVICES_SUFFIX          (TEXT(".") INFSTR_SUBKEY_SERVICES)
#define DISTR_INF_INTERFACES_SUFFIX        (TEXT(".") INFSTR_SUBKEY_INTERFACES)
#define DISTR_INF_COINSTALLERS_SUFFIX      (TEXT(".") INFSTR_SUBKEY_COINSTALLERS)
#define DISTR_INF_LOGCONFIGOVERRIDE_SUFFIX (TEXT(".") INFSTR_SUBKEY_LOGCONFIGOVERRIDE)
//
// Define all platform-specific suffix strings for which we support non-native
// digital signature verification...
//
#define DISTR_INF_NTALPHA_SUFFIX           (TEXT(".") INFSTR_PLATFORM_NTALPHA)
#define DISTR_INF_NTX86_SUFFIX             (TEXT(".") INFSTR_PLATFORM_NTX86)
#define DISTR_INF_NTIA64_SUFFIX            (TEXT(".") INFSTR_PLATFORM_NTIA64)
#define DISTR_INF_NTAXP64_SUFFIX           (TEXT(".") INFSTR_PLATFORM_NTAXP64)
#define DISTR_INF_NTAMD64_SUFFIX           (TEXT(".") INFSTR_PLATFORM_NTAMD64)
//
// Define platform decoration strings for use on [SourceDisksNames] and
// [SourceDisksFiles] sections.
//
#define DISTR_INF_SRCDISK_SUFFIX_ALPHA  (TEXT("Alpha"))
#define DISTR_INF_SRCDISK_SUFFIX_X86    (TEXT("x86"))
#define DISTR_INF_SRCDISK_SUFFIX_IA64   (TEXT("ia64"))
#define DISTR_INF_SRCDISK_SUFFIX_AXP64  (TEXT("axp64"))
#define DISTR_INF_SRCDISK_SUFFIX_AMD64  (TEXT("amd64"))

//
// (Sizes are included for all strings that we define privately.  This
// is done so that we can do sizeof() instead of lstrlen() to determine
// string length.  Keep in sync with definitions in infload.c!)
//
extern CONST TCHAR pszDrvDescFormat[SIZECHARS(DISTR_INF_DRVDESCFMT)],
                   pszHwSectionFormat[SIZECHARS(DISTR_INF_HWSECTIONFMT)],
                   pszChicagoSig[SIZECHARS(DISTR_INF_CHICAGOSIG)],
                   pszWindowsNTSig[SIZECHARS(DISTR_INF_WINNTSIG)],
                   pszWindows95Sig[SIZECHARS(DISTR_INF_WIN95SIG)],
                   pszWinSuffix[SIZECHARS(DISTR_INF_WIN_SUFFIX)],
                   pszNtSuffix[SIZECHARS(DISTR_INF_NT_SUFFIX)],
                   pszNtAlphaSuffix[SIZECHARS(DISTR_INF_NTALPHA_SUFFIX)],
                   pszNtX86Suffix[SIZECHARS(DISTR_INF_NTX86_SUFFIX)],
                   pszNtIA64Suffix[SIZECHARS(DISTR_INF_NTIA64_SUFFIX)],
                   pszNtAXP64Suffix[SIZECHARS(DISTR_INF_NTAXP64_SUFFIX)],
                   pszNtAMD64Suffix[SIZECHARS(DISTR_INF_NTAMD64_SUFFIX)],
                   pszPnfSuffix[SIZECHARS(DISTR_INF_PNF_SUFFIX)],
                   pszInfSuffix[SIZECHARS(DISTR_INF_INF_SUFFIX)],
                   pszCatSuffix[SIZECHARS(DISTR_INF_CAT_SUFFIX)],
                   pszServicesSectionSuffix[SIZECHARS(DISTR_INF_SERVICES_SUFFIX)],
                   pszInterfacesSectionSuffix[SIZECHARS(DISTR_INF_INTERFACES_SUFFIX)],
                   pszCoInstallersSectionSuffix[SIZECHARS(DISTR_INF_COINSTALLERS_SUFFIX)],
                   pszLogConfigOverrideSectionSuffix[SIZECHARS(DISTR_INF_LOGCONFIGOVERRIDE_SUFFIX)],
                   pszAlphaSrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_ALPHA)],
                   pszX86SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_X86)],
                   pszIa64SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_IA64)],
                   pszAxp64SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_AXP64)],
                   pszAmd64SrcDiskSuffix[SIZECHARS(DISTR_INF_SRCDISK_SUFFIX_AMD64)];

//
// Define constants that equate to native architecture suffixes...
//
#if defined(_ALPHA_)
#define pszNtPlatformSuffix       pszNtAlphaSuffix
#define pszPlatformSrcDiskSuffix  pszAlphaSrcDiskSuffix
#elif defined(_X86_)
#define pszNtPlatformSuffix       pszNtX86Suffix
#define pszPlatformSrcDiskSuffix  pszX86SrcDiskSuffix
#elif defined(_IA64_)
#define pszNtPlatformSuffix       pszNtIA64Suffix
#define pszPlatformSrcDiskSuffix  pszIa64SrcDiskSuffix
#elif defined(_AXP64_)
#define pszNtPlatformSuffix       pszNtAXP64Suffix
#define pszPlatformSrcDiskSuffix  pszAxp64SrcDiskSuffix
#elif defined(_AMD64_)
#define pszNtPlatformSuffix       pszNtAMD64Suffix
#define pszPlatformSrcDiskSuffix  pszAmd64SrcDiskSuffix
#else
#error Unknown processor type
#endif
//
// for now, platform name is same as pszPlatformSrcDiskSuffix (Alpha, x86, ia64, axp64, amd64)
//
#define pszPlatformName pszPlatformSrcDiskSuffix

//
// Define a (non-CONST) array of strings that specifies what lines to look for
// in an INF's [ControlFlags] section when determining whether a particular device
// ID should be excluded.  This is filled in during process attach for speed
// reasons.
//
// The max string length (including NULL) is 32, and there can be a maximum of 3
// such strings.  E.g.: ExcludeFromSelect, ExcludeFromSelect.NT, ExcludeFromSelect.NTAlpha
//
extern TCHAR pszExcludeFromSelectList[3][32];
extern DWORD ExcludeFromSelectListUb;  // contains the number of strings in the above list (2 or 3).


//
// Routine to determine whether a character is whitespace.
//
BOOL
IsWhitespace(
    IN PCTSTR pc
    );

//
// Routine to skip whitespace (but not newlines)
//
VOID
SkipWhitespace(
    IN OUT PCTSTR *Location,
    IN     PCTSTR  BufferEnd
    );

PINF_SECTION
InfLocateSection(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    OUT PUINT       SectionNumber   OPTIONAL
    );

BOOL
InfLocateLine(
    IN     PLOADED_INF   Inf,
    IN     PINF_SECTION  Section,
    IN     PCTSTR        Key,        OPTIONAL
    IN OUT PUINT         LineNumber,
    OUT    PINF_LINE    *Line
    );

PTSTR
InfGetKeyOrValue(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    IN  PCTSTR      LineKey,     OPTIONAL
    IN  UINT        LineNumber,  OPTIONAL
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    );

PTSTR
InfGetField(
    IN  PLOADED_INF Inf,
    IN  PINF_LINE   InfLine,
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    );

PINF_LINE
InfLineFromContext(
    IN PINFCONTEXT Context
    );


//
// Define a macro to retrieve the case-insensitive (i.e., searchable) string ID
// for an INF line's key, or -1 if there is no key.
// NOTE: INF lock must have been acquired before calling this macro!
//
// LONG
// pInfGetLineKeyId(
//     IN  PLOADED_INF Inf,
//     IN  PINF_LINE   InfLine
//     )
//
#define pInfGetLineKeyId(Inf,InfLine)  (ISSEARCHABLE(InfLine) ? (Inf)->ValueBlock[(InfLine)->Values] : -1)

//
// Routine to allocate and initialize a loaded inf descriptor.
//
PLOADED_INF
AllocateLoadedInfDescriptor(
    IN DWORD SectionBlockSize,
    IN DWORD LineBlockSize,
    IN DWORD ValueBlockSize,
    IN  PSETUP_LOG_CONTEXT LogContext OPTIONAL
    );

VOID
FreeInfOrPnfStructures(
    IN PLOADED_INF Inf
    );

//
// Define a macro to free all memory blocks associated with a loaded INF or PNF,
// and then free the memory for the loaded INF structure itself
//
// VOID
// FreeLoadedInfDescriptor(
//     IN PLOADED_INF Inf
//     );
//
#define FreeLoadedInfDescriptor(Inf) {  \
    FreeInfOrPnfStructures(Inf);        \
    MyTaggedFree(Inf,MEMTAG_INF);       \
}

BOOL
AddDatumToVersionBlock(
    IN OUT PINF_VERSION_NODE VersionNode,
    IN     PCTSTR            DatumName,
    IN     PCTSTR            DatumValue
    );

//
// Old inf manipulation routines, called by new inf loader
//
DWORD
ParseOldInf(
    IN  PCTSTR       FileImage,
    IN  DWORD        FileImageSize,
    IN  PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT UINT        *ErrorLineNumber
    );

DWORD
ProcessOldInfVersionBlock(
    IN PLOADED_INF Inf
    );

//
// Run-time helper routines.
//
PCTSTR
pSetupFilenameFromLine(
    IN PINFCONTEXT Context,
    IN BOOL        GetSourceName
    );


//
// Logical configuration stuff, inflogcf.c
//
DWORD
pSetupInstallLogConfig(
    IN HINF    Inf,
    IN PCTSTR  SectionName,
    IN DEVINST DevInst,
    IN DWORD   Flags,
    IN HMACHINE hMachine
    );

//
// INF Version information retrieval
//
PCTSTR
pSetupGetVersionDatum(
    IN PINF_VERSION_NODE VersionNode,
    IN PCTSTR            DatumName
    );

BOOL
pSetupGetCatalogFileValue(
    IN  PINF_VERSION_NODE       InfVersionNode,
    OUT LPTSTR                  Buffer,
    IN  DWORD                   BufferSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    );

VOID
pSetupGetPhysicalInfFilepath(
    IN  PINFCONTEXT LineContext,
    OUT LPTSTR      Buffer,
    IN  DWORD       BufferSize
    );

//
// Private installation routines.
//

//
// Private Flags & context for _SetupInstallFromInfSection.
// passed onto pSetupInstallRegistry
//

typedef struct _REGMOD_CONTEXT {
    DWORD               Flags;          // indicates what fields are filled in
    HKEY                UserRootKey;    // HKR
    LPGUID              ClassGuid;      // INF_PFLAG_CLASSPROP
    HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
    DWORD               DevInst;        // INF_PFLAG_DEVPROP
} REGMOD_CONTEXT, *PREGMOD_CONTEXT;

#define INF_PFLAG_CLASSPROP        (0x00000001)  // set if called for a ClassInstall32 section
#define INF_PFLAG_DEVPROP          (0x00000002)  // set if called for registry properties
#define INF_PFLAG_HKR              (0x00000004)  // indicates override _SetupInstallFromInfSection RelativeKeyRoot

BOOL
_SetupInstallFromInfSection(
    IN HWND             Owner,              OPTIONAL
    IN HINF             InfHandle,
    IN PCTSTR           SectionName,
    IN UINT             Flags,
    IN HKEY             RelativeKeyRoot,    OPTIONAL
    IN PCTSTR           SourceRootPath,     OPTIONAL
    IN UINT             CopyFlags,
    IN PVOID            MsgHandler,
    IN PVOID            Context,            OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN BOOL             IsMsgHandlerNativeCharWidth,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    );

DWORD
pSetupInstallFiles(
    IN HINF              Inf,
    IN HINF              LayoutInf,         OPTIONAL
    IN PCTSTR            SectionName,
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN PSP_FILE_CALLBACK MsgHandler,        OPTIONAL
    IN PVOID             Context,           OPTIONAL
    IN UINT              CopyStyle,
    IN HWND              Owner,             OPTIONAL
    IN HSPFILEQ          UserFileQ,         OPTIONAL
    IN BOOL              IsMsgHandlerNativeCharWidth
    );

DWORD
pSetupInstallRegistry(
    IN HINF             Inf,
    IN PCTSTR           SectionName,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    );

DWORD
_AppendStringToMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN BOOL             AllowDuplicates,
    IN PREGMOD_CONTEXT  RegContext,         OPTIONAL
    IN UINT             Flags               OPTIONAL
    );

DWORD
_DeleteStringFromMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN UINT             Flags,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infflist.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infflist.c

Abstract:

    Externally exposed routines for manipulating file lists,
    disk descriptors, and directory descriptors in INF files.

Author:

    Ted Miller (tedm) 3-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <winspool.h>

//
// Locations of various fields on lines in a copy section.
// First field is 'target' filename.
// Second field is 'source' filename and is optional for copy sections
// and not used at all in delete sections.
#define COPYSECT_TARGET_FILENAME    1
#define COPYSECT_SOURCE_FILENAME    2

//
// Locations of various fields on lines in a file layout section.
//
#define LAYOUTSECT_FILENAME     0       // key
#define LAYOUTSECT_DISKID       1
#define LAYOUTSECT_SUBDIR       2
#define LAYOUTSECT_SIZE         3
#define LAYOUTSECT_CHECKSUM     4

//
// Locations of various fields on lines in a [DestinationDirs] section.
//
#define DIRSECT_DIRID           1
#define DIRSECT_SUBDIR          2


//
// Names of various sections in an INF.
// (string constants defined in infstr.h)
//
CONST TCHAR pszSourceDisksNames[] = SZ_KEY_SRCDISKNAMES,
            pszSourceDisksFiles[] = SZ_KEY_SRCDISKFILES,
            pszDestinationDirs[]  = SZ_KEY_DESTDIRS,
            pszDefaultDestDir[]   = SZ_KEY_DEFDESTDIR;


BOOL
_SetupGetSourceFileLocation(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,       OPTIONAL
    IN  PCTSTR                  FileName,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,  OPTIONAL
    OUT PUINT                   SourceId,         OPTIONAL
    OUT PTSTR                   ReturnBuffer,     OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize,     OPTIONAL
    OUT PINFCONTEXT             LineContext       OPTIONAL
    )

/*++

Routine Description:

    Determine the location of a source file, as listed in an inf file.

Arguments:

    InfHandle - supplies the handle to a loaded inf file that contains
        file layout information, ie, has [SourceDisksNames] and
        [SourceDisksFiles] sections.

    InfContext - specifies a line in a copy section of an inf file
        for which the full source path is to be retreived. If this
        parameter is not specified, then FileName will be searched for
        in the [SourceDisksFiles] section of the INF specified by InfHandle.

    FileName - supplies the filename (no path) for which to return the
        full source location. Must be specified if InfContext is not.

    AltPlatformInfo - optionally, supplies alternate platform to be used
        when looking for decorated [SourceDisksFiles] section.

    SourceId - receives the source id of the source media where the
        file is located. This parameter may be NULL if this information
        is not desired.

    ReturnBuffer - receives the source path (relative to the source LDD).
        This path contains neither a drivespec nor the filename itself.
        The path never starts or ends with \, so the empty string
        means the root.

    ReturnBufferSize - specified the size in characters of the buffer
        pointed to by ReturnBuffer.

    RequiredSize - receives the number of characters required
        in ReturnBuffer. If the buffer is too small GetLastError
        returns ERROR_INSUFFICIENT_BUFFER.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PCTSTR fileName, PlatformName;
    INFCONTEXT DecContext;
    INFCONTEXT UnDecContext;
    PINFCONTEXT lineContext;
    UINT Length;
    PCTSTR SubDir;
    TCHAR FileListSectionName[64];
    BOOL bDec = FALSE;
    BOOL bUnDec = FALSE;

    //
    // If caller gave a line context, the first field on the line
    // is the filename. Retreive it.
    //
    try {
        fileName = InfContext ? pSetupGetField(InfContext,COPYSECT_TARGET_FILENAME) : FileName;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // InfContext must be a bad pointer
        //
        fileName = NULL;
    }

    if(!fileName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Now look for the filename's line in the [SourceDisksFiles] section.
    // Look in the platform-specific one first and the platform-independent
    // one if not found.
    //
    if(AltPlatformInfo) {

        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL :
                PlatformName = pszX86SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA :
                PlatformName = pszAlphaSrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_IA64 :
                PlatformName = pszIa64SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA64 :
                PlatformName = pszAxp64SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_AMD64 :
                PlatformName = pszAmd64SrcDiskSuffix;
                break;

            default :
                //
                // unknown/unsupported processor architecture.
                //
                MYASSERT((AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)  ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA64) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                        );

                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
        }

    } else {
        PlatformName = pszPlatformSrcDiskSuffix;
    }

    _sntprintf(FileListSectionName,
               SIZECHARS(FileListSectionName),
               TEXT("%s.%s"),
               pszSourceDisksFiles,
               PlatformName
              );

    bDec = SetupFindFirstLine(InfHandle,FileListSectionName,fileName,&DecContext);
    if(bDec && (DecContext.CurrentInf == InfHandle)) {
        //
        // found Decorated section in same INF as source file
        //
        lineContext = &DecContext;
    } else {
        //
        // didn't find decorated section in expected INF, try undecorated in expected INF
        //
        bUnDec = SetupFindFirstLine(InfHandle,pszSourceDisksFiles,fileName,&UnDecContext);
        if(bUnDec  && (UnDecContext.CurrentInf == InfHandle)) {
            //
            // found in Undecorated section in same INF as source file
            //
            lineContext = &UnDecContext;
        } else if(bDec) {
            //
            // any decorated section (should only be one)
            //
            lineContext = &DecContext;
        } else if(bUnDec) {
            //
            // any undecorated section (should only be one)
            //
            lineContext = &UnDecContext;
        } else {
            //
            // none found
            //
            SetLastError(ERROR_LINE_NOT_FOUND);
            return(FALSE);
        }
    }

    //
    // Got the line. If the caller wants it, give it to him.
    // We don't guard this with try/except because this routine is internal
    // and any fault is a bug in the caller.
    //
    if(LineContext) {
        *LineContext = *lineContext;
    }

    //
    // Get the disk id.
    //
    if(SourceId) {
        if(!SetupGetIntField(lineContext,LAYOUTSECT_DISKID,SourceId)) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }
    }

    //
    // If all the caller was interested in was the disk ID (i.e., they passed in ReturnBuffer
    // and RequiredSize both as NULL), then we can save the extra work and return now.
    //
    if(!(ReturnBuffer || RequiredSize)) {
        return TRUE;
    }

    //
    // Now get the path relative to the LDD.
    //
    SubDir = pSetupGetField(lineContext,LAYOUTSECT_SUBDIR);
    if(!SubDir) {
        SubDir = TEXT("");
    }

    Length = lstrlen(SubDir);

    //
    // Ignore leading path sep if present.
    //
    if(SubDir[0] == TEXT('\\')) {
        Length--;
        SubDir++;
    }

    //
    // See if there's a trailing path sep.
    //
    if(Length && *CharPrev(SubDir,SubDir+Length) == TEXT('\\')) {
        Length--;
    }

    //
    // Leave space for the nul
    //
    if(RequiredSize) {
        *RequiredSize = Length+1;
    }

    //
    // Place data in caller's buffer.
    // If caller didn't specify a buffer we're done.
    //
    if(ReturnBuffer) {
        if(ReturnBufferSize <= Length) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return(FALSE);
        }

        //
        // Don't use lstrcpy, because if we are stripping
        // a trailing path sep, lstrcpy could write the nul byte
        // past the end of the buffer.
        //
        CopyMemory(ReturnBuffer,SubDir,Length*sizeof(TCHAR));
        ReturnBuffer[Length] = 0;
    }

    return(TRUE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetSourceFileLocationA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    WCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCWSTR filename;
    UINT sourceid;
    DWORD rc;
    BOOL b;
    PCSTR ansireturn;

    rc = NO_ERROR;
    if(FileName) {
        rc = pSetupCaptureAndConvertAnsiArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }

    b = _SetupGetSourceFileLocation(
            InfHandle,
            InfContext,
            filename,
            NULL,
            &sourceid,
            returnbuffer,
            MAX_PATH,
            &requiredsize,
            NULL
            );

    rc = GetLastError();

    if(b) {
        rc = NO_ERROR;

        if(ansireturn = pSetupUnicodeToAnsi(returnbuffer)) {

            requiredsize = lstrlenA(ansireturn)+1;

            try {
                *SourceId = sourceid;
                if(RequiredSize) {
                    *RequiredSize = requiredsize;
                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
                b = FALSE;
            }

            if(rc == NO_ERROR) {

                if(ReturnBuffer) {

                    if(requiredsize <= ReturnBufferSize) {

                        //
                        // lstrcpy won't generate an exception on NT even if
                        // ReturnBuffer is invalid, but will return NULL
                        //
                        try {
                            if(!lstrcpyA(ReturnBuffer,ansireturn)) {
                                b = FALSE;
                                rc = ERROR_INVALID_PARAMETER;
                            }
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                            b = FALSE;
                            rc = ERROR_INVALID_PARAMETER;
                        }
                    } else {
                        b = FALSE;
                        rc = ERROR_INSUFFICIENT_BUFFER;
                    }
                }
            }

            MyFree(ansireturn);

        } else {
            b = FALSE;
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(filename) {
        MyFree(filename);
    }
    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetSourceFileLocationW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      FileName,         OPTIONAL
    OUT PUINT       SourceId,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetSourceFileLocation(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,         OPTIONAL
    IN  PCTSTR      FileName,           OPTIONAL
    OUT PUINT       SourceId,
    OUT PTSTR       ReturnBuffer,       OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize        OPTIONAL
    )
{
    TCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCTSTR filename;
    UINT sourceid;
    DWORD rc;
    BOOL b;

    rc = NO_ERROR;
    if(FileName) {
        rc = CaptureStringArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }

    b = _SetupGetSourceFileLocation(
            InfHandle,
            InfContext,
            filename,
            NULL,
            &sourceid,
            returnbuffer,
            MAX_PATH,
            &requiredsize,
            NULL
            );

    rc = GetLastError();

    if(b) {
        rc = NO_ERROR;

        try {
            *SourceId = sourceid;
            if(RequiredSize) {
                *RequiredSize = requiredsize;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
            b = FALSE;
        }

        if(rc == NO_ERROR) {

            if(ReturnBuffer) {

                if(requiredsize <= ReturnBufferSize) {

                    //
                    // lstrcpy won't generate an exception on NT even if
                    // ReturnBuffer is invalid, but will return NULL
                    //
                    try {
                        if(!lstrcpy(ReturnBuffer,returnbuffer)) {
                            b = FALSE;
                            rc = ERROR_INVALID_PARAMETER;
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        b = FALSE;
                        rc = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    b = FALSE;
                    rc = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }
    }

    if(filename) {
        MyFree(filename);
    }
    SetLastError(rc);
    return(b);
}


BOOL
_SetupGetSourceFileSize(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,      OPTIONAL
    IN  PCTSTR                  FileName,        OPTIONAL
    IN  PCTSTR                  Section,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo, OPTIONAL
    OUT PDWORD                  FileSize,
    IN  UINT                    RoundingFactor   OPTIONAL
    )

/*++

Routine Description:

    Determine the (uncompressed) size of a source file,
    as listed in an inf file.

Arguments:

    InfHandle - supplies the handle to a loaded inf file that contains
        file layout information, ie, has [SourceDisksNames] and
        optionally [SourceDisksFiles] sections.

    InfContext - specifies a line in a the copy section of an inf file
        for which the size is to be retreived. If this parameter is
        not specified, the FileName parameter is checked next.

    FileName - supplies the filename (no path) for which to return the
        size. If this parameter is not specified the Section parameter
        is used (see below).

    Section - specifies the name of a section in the INF file specified
        by InfHandle. The total sizes of all files in the section is
        computed.

    AltPlatformInfo - optionally, supplies alternate platform information
        to be used in selecting a decorated [SourceDisksFiles] section.

    FileSize - receives the file size(s).

    RoundingFactor - If specified, supplies a value for rounding file sizes.
        All file sizes will be rounded up to be a multiple of this number
        before being added to the total size. This is useful for more
        exact determinations of the space a file will occupy on a given volume,
        because it allows the caller to have file sizes rounded up to be a
        multiple of the cluster size. If not specified no rounding takes place.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PCTSTR fileName, PlatformName;
    INFCONTEXT LayoutSectionContext;
    INFCONTEXT CopySectionContext;
    BOOL b;
    UINT Size;
    LONG File,FileCount;
    TCHAR FileListSectionName[64];
    DWORD rc;

    //
    // If the rounding factor is not specified, set it to 1 so the math
    // below works without special cases.
    //
    if(!RoundingFactor) {
        RoundingFactor = 1;
    }

    // Establish an inf line context for the line in the copy list section,
    // unless the caller passed us an absolute filename.
    //
    fileName = NULL;
    FileCount = 1;
    if(InfContext) {

        //
        // Caller passed INF line context.
        // Remember the context in preparation for retreiving the filename
        // from the line later.
        //
        // fileName must be NULL so we look at the line
        // and get the correct source name
        //
        b = TRUE;
        try {
            CopySectionContext = *InfContext;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
        }
        if(!b) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

    } else {
        if(FileName) {
            //
            // Caller passed an absolute file name. Remember it.
            //
            fileName = FileName;

        } else {
            //
            // Caller must have passed a section, the contents of which lists
            // a set of files whose sizes are to be totalled. Determine the number
            // of lines in the section and establish a context.
            //
            if(Section) {

                FileCount = SetupGetLineCount(InfHandle,Section);

                if((FileCount == -1)
                || !SetupFindFirstLine(InfHandle,Section,NULL,&CopySectionContext)) {
                    rc = GetLastError();
                    pSetupLogSectionError(InfHandle,NULL,NULL,NULL,Section,MSG_LOG_NOSECTION_FILESIZE,rc,NULL);
                    SetLastError(ERROR_SECTION_NOT_FOUND); // ignoring rc for compatability with older versions of setupAPI
                    return(FALSE);
                }
            } else {
                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }
    }

    *FileSize = 0;
    for(File=0; File<FileCount; File++) {

        if(File) {
            //
            // This is not the first pass through the loop. We need
            // to locate the next line in the copy list section.
            //
            b = SetupFindNextLine(&CopySectionContext,&CopySectionContext);
            if(!b) {
                SetLastError(ERROR_INVALID_DATA);
                return(FALSE);
            }

            fileName = pSetupGetField(&CopySectionContext,COPYSECT_SOURCE_FILENAME);
            if(fileName == NULL || fileName[0] == 0) {
                fileName = pSetupGetField(&CopySectionContext,COPYSECT_TARGET_FILENAME);
            }
        } else {
            //
            // First pass through the loop. May need to get a filename.
            //
            if(!fileName) {
                fileName = pSetupGetField(&CopySectionContext,COPYSECT_SOURCE_FILENAME);
                if(fileName == NULL || fileName[0] == 0) {
                    fileName = pSetupGetField(&CopySectionContext,COPYSECT_TARGET_FILENAME);
                }
            }
        }

        //
        // If we don't have a filename by now, the inf is corrupt.
        //
        if(!fileName) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Locate the line in [SourceDisksFiles] that is for the filename
        // we are currently dealing with. Look in the platform-specific
        // section first.
        //
        if(AltPlatformInfo) {

            switch(AltPlatformInfo->ProcessorArchitecture) {

                case PROCESSOR_ARCHITECTURE_INTEL :
                    PlatformName = pszX86SrcDiskSuffix;
                    break;

                case PROCESSOR_ARCHITECTURE_ALPHA :
                    PlatformName = pszAlphaSrcDiskSuffix;
                    break;

                case PROCESSOR_ARCHITECTURE_IA64 :
                    PlatformName = pszIa64SrcDiskSuffix;
                    break;

                case PROCESSOR_ARCHITECTURE_ALPHA64 :
                    PlatformName = pszAxp64SrcDiskSuffix;
                    break;

                case PROCESSOR_ARCHITECTURE_AMD64 :
                    PlatformName = pszAmd64SrcDiskSuffix;
                    break;

                default :
                    //
                    // unknown/unsupported processor architecture.
                    //
                    MYASSERT((AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) ||
                             (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) ||
                             (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)  ||
                             (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA64) ||
                             (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                            );

                    SetLastError(ERROR_INVALID_PARAMETER);
                    return(FALSE);
            }

        } else {
            PlatformName = pszPlatformSrcDiskSuffix;
        }

        _sntprintf(
            FileListSectionName,
            sizeof(FileListSectionName)/sizeof(FileListSectionName[0]),
            TEXT("%s.%s"),
            pszSourceDisksFiles,
            PlatformName
            );
        b = SetupFindFirstLine(InfHandle,FileListSectionName,fileName,&LayoutSectionContext);
        if(!b) {
            b = SetupFindFirstLine(InfHandle,pszSourceDisksFiles,fileName,&LayoutSectionContext);
        }
        if(!b) {
            SetLastError(ERROR_LINE_NOT_FOUND);
            return(FALSE);
        }

        //
        // Get the size data for the file.
        //
        b = SetupGetIntField(&LayoutSectionContext,LAYOUTSECT_SIZE,&Size);
        if(!b) {
            SetLastError(ERROR_INVALID_DATA);
            return(FALSE);
        }

        //
        // Round size up to be an even multiple of the rounding factor
        //
        if(Size % RoundingFactor) {
            Size += RoundingFactor - (Size % RoundingFactor);
        }

        *FileSize += Size;
    }

    return(TRUE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetSourceFileSizeA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCSTR       FileName,       OPTIONAL
    IN  PCSTR       Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    )
{
    PCWSTR filename,section;
    BOOL b;
    DWORD rc;
    DWORD size;

    if(FileName) {
        rc = pSetupCaptureAndConvertAnsiArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }
    if(Section) {
        rc = pSetupCaptureAndConvertAnsiArg(Section,&section);
        if(rc != NO_ERROR) {
            if(filename) {
                MyFree(filename);
            }
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        section = NULL;
    }

    b = _SetupGetSourceFileSize(InfHandle,
                                InfContext,
                                filename,
                                section,
                                NULL,
                                &size,
                                RoundingFactor
                               );
    rc = GetLastError();

    if (b) {
        try {
            *FileSize = size;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(filename) {
        MyFree(filename);
    }
    if(section) {
        MyFree(section);
    }

    SetLastError(rc);
    return(b);
}

#else
//
// Unicode stub
//
BOOL
SetupGetSourceFileSizeW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCWSTR      FileName,       OPTIONAL
    IN  PCWSTR      Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(FileSize);
    UNREFERENCED_PARAMETER(RoundingFactor);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetSourceFileSize(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,     OPTIONAL
    IN  PCTSTR      FileName,       OPTIONAL
    IN  PCTSTR      Section,        OPTIONAL
    OUT PDWORD      FileSize,
    IN  UINT        RoundingFactor  OPTIONAL
    )
{
    PCTSTR filename,section;
    BOOL b;
    DWORD rc;
    DWORD size;

    if(FileName) {
        rc = CaptureStringArg(FileName,&filename);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        filename = NULL;
    }
    if(Section) {
        rc = CaptureStringArg(Section,&section);
        if(rc != NO_ERROR) {
            if(filename) {
                MyFree(filename);
            }
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        section = NULL;
    }

    b = _SetupGetSourceFileSize(InfHandle,
                                InfContext,
                                filename,
                                section,
                                NULL,
                                &size,
                                RoundingFactor
                               );
    rc = GetLastError();

    if (b) {
        try {
            *FileSize = size;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(filename) {
        MyFree(filename);
    }
    if(section) {
        MyFree(section);
    }

    SetLastError(rc);
    return(b);
}


BOOL
_SetupGetTargetPath(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCTSTR      Section,          OPTIONAL
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )

/*++

Routine Description:

    Determine the target directory for a given file list section.
    A file list section may be for copy, rename, or delete; in any case
    all the files in the section are in one directory and that directory
    is listed in the [DestinationDirs] section of the inf.

    Where InfContext is specified, we will look for [DestinationDirs]
    from the current inf in the context first. This will help the scenario
    where X.INF includes Y.INF includes LAYOUT.INF, both X&Y have entries
    but the section was found in Y. We want to find the section in X last.

Arguments:

    InfHandle - supplies the handle to a loaded inf file
        that contains a [DestinationDirs] section.

    InfContext - specifies a line in a the copy section of an inf file.
        The target directory for this section is retreived.

    Section - Supplies the section in InfHandle whose destination directory
        is to be retreived. Ignored if InfContext is specified.
        If neither InfContext nor Section are specified, this function retreives
        the default target path.

    ReturnBuffer - if specified, receives the full win32 path of the target.
        This value is guaranteed not to end with \.

    ReturnBufferSize - specifies the size in characters of the buffer pointed
        to by ReturnBuffer.

    RequiredSize - receives the size in characters of a buffer required to hold
        the output data.

Return Value:

    Boolean value indicating outcome. GetLastError() returns extended error info.
    ERROR_INSUFFICIENT_BUFFER is returned if the function fails because
    ReturnBuffer is too small.

--*/

{
    PINF_SECTION DestDirsSection;
    UINT LineNumber;
    PINF_LINE Line;
    PCTSTR DirId;
    PCTSTR SubDir;
    PCTSTR ActualPath;
    UINT DirIdInt;
    PLOADED_INF Inf, CurInf, DefaultDestDirInf;
    DWORD TmpRequiredSize;
    BOOL DestDirFound, DefaultDestDirFound;
    DWORD Err;
    PINF_LINE DefaultDestDirLine;
    PCTSTR InfSourcePath;

    //
    // If an INF context was specified, use it to determine the name
    // the section the context describes. If inf context was not specified,
    // then a section name must have been.
    //
    Err = NO_ERROR;
    try {
        Inf = InfContext ? (PLOADED_INF)InfContext->Inf : (PLOADED_INF)InfHandle;

        if(!LockInf(Inf)) {
            Err = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }
    if(Err != NO_ERROR) {
        SetLastError(Err);
        return(FALSE);
    }

    //
    // If we get here then InfContext is a good pointer if specified;
    // if not then Inf is a good pointer.
    //
    if(InfContext) {
        CurInf = (PLOADED_INF)InfContext->CurrentInf;
        InfSourcePath = CurInf->InfSourcePath;

        Section = pStringTableStringFromId(
                      CurInf->StringTable,
                      CurInf->SectionBlock[InfContext->Section].SectionName
                     );
    } else {
        InfSourcePath = Inf->InfSourcePath;

        if(!Section) {
            Section = pszDefaultDestDir;
        }
    }

    //
    // Traverse the linked list of INFs, looking for a [DestinationDirs] section
    // in each one.
    //
    DestDirFound = DefaultDestDirFound = FALSE;
    Err = NO_ERROR;

    if (InfContext) {
        //
        // first consider the CurrentInf as being Local scope
        //
        CurInf = InfContext->CurrentInf;

        if((DestDirsSection = InfLocateSection(CurInf, pszDestinationDirs, NULL))!=NULL) {
            //
            // Locate the line in [DestinationDirs] that gives the target path
            // for the section. The section name will be the key on the relevant line.
            // If that's not there, and we haven't already encountered a DefaultDestDir
            // entry, then look for that as well, and remember it if we find one.
            //
            LineNumber = 0;
            if(InfLocateLine(CurInf, DestDirsSection, Section, &LineNumber, &Line)) {
                //
                // Got the line in [DestinationDirs]. Pull out the directory. The subdir is optional.
                //
                DirId = InfGetField(CurInf, Line, DIRSECT_DIRID, NULL);
                if(!DirId) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }

                SubDir = InfGetField(CurInf, Line, DIRSECT_SUBDIR, NULL);

                DestDirFound = TRUE;
            } else if(InfLocateLine(CurInf, DestDirsSection, pszDefaultDestDir, &LineNumber, &Line)) {
                DefaultDestDirInf = CurInf;
                DefaultDestDirLine = Line;
                DefaultDestDirFound = TRUE;
            }
        }
    }

    if(!DestDirFound && !DefaultDestDirFound) {
        //
        // search for any matches at all
        //
        for(CurInf = Inf; CurInf; CurInf = CurInf->Next) {

            if(!(DestDirsSection = InfLocateSection(CurInf, pszDestinationDirs, NULL))) {
                continue;
            }

            //
            // Locate the line in [DestinationDirs] that gives the target path
            // for the section. The section name will be the key on the relevant line.
            // If that's not there, and we haven't already encountered a DefaultDestDir
            // entry, then look for that as well, and remember it if we find one.
            //
            LineNumber = 0;
            if(InfLocateLine(CurInf, DestDirsSection, Section, &LineNumber, &Line)) {
                //
                // Got the line in [DestinationDirs]. Pull out the directory. The subdir is optional.
                //
                DirId = InfGetField(CurInf, Line, DIRSECT_DIRID, NULL);
                if(!DirId) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }

                SubDir = InfGetField(CurInf, Line, DIRSECT_SUBDIR, NULL);

                DestDirFound = TRUE;
                break;
            }

            if(!DefaultDestDirFound &&
                    InfLocateLine(CurInf, DestDirsSection, pszDefaultDestDir, &LineNumber, &Line)) {
                DefaultDestDirInf = CurInf;
                DefaultDestDirLine = Line;
                DefaultDestDirFound = TRUE;
            }
        }
    }

    if(!DestDirFound) {
        //
        // If we found a DefaultDestDir, then use that, otherwise, use a default.
        //
        if(DefaultDestDirFound) {

            DirId = InfGetField(DefaultDestDirInf, DefaultDestDirLine, DIRSECT_DIRID, NULL);
            if(!DirId) {
                Err = ERROR_INVALID_DATA;
                goto clean0;
            }
            SubDir = InfGetField(DefaultDestDirInf, DefaultDestDirLine, DIRSECT_SUBDIR, NULL);
            CurInf = DefaultDestDirInf;
        } else {
            SubDir = NULL;
            DirId = NULL;
            DirIdInt = DIRID_DEFAULT;
            CurInf = NULL;
        }
    }

    //
    // Translate dirid/subdir to actual path.
    //
    ActualPath = pSetupDirectoryIdToPath(DirId,
                                         &DirIdInt,
                                         SubDir,
                                         InfSourcePath,
                                         (CurInf && CurInf->OsLoaderPath)
                                             ? &(CurInf->OsLoaderPath)
                                             : NULL
                                        );

    if(!ActualPath) {
        //
        // If the default DIRID lookup failed because DirId is in the
        // user-defined range, then GetLastError will return NO_ERROR.
        // Otherwise, we should bail now.
        //
        if((Err = GetLastError()) != NO_ERROR) {
            goto clean0;
        }

        //
        // Now see if we there's a user-defined DIRID for this.
        //
        if(!(ActualPath = pSetupVolatileDirIdToPath(NULL,
                                                DirIdInt,
                                                SubDir,
                                                Inf))) {
            Err = GetLastError();
            goto clean0;
        }
    }

    //
    // Put actual path in caller's buffer.
    //
    TmpRequiredSize = lstrlen(ActualPath) + 1;
    if(RequiredSize) {
        *RequiredSize = TmpRequiredSize;
    }

    if(ReturnBuffer) {
        if(TmpRequiredSize > ReturnBufferSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
        } else {
            lstrcpy(ReturnBuffer, ActualPath);
        }
    }

    MyFree(ActualPath);

clean0:
    UnlockInf(Inf);

    if(Err == NO_ERROR) {
        return TRUE;
    } else {
        SetLastError(Err);
        return FALSE;
    }
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetTargetPathA(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    WCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCWSTR section;
    PCSTR ansireturn;

    if(Section) {
        rc = pSetupCaptureAndConvertAnsiArg(Section,&section);
    } else {
        section = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = _SetupGetTargetPath(InfHandle,InfContext,section,returnbuffer,MAX_PATH,&requiredsize);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(b) {

        if(ansireturn = pSetupUnicodeToAnsi(returnbuffer)) {

            rc = NO_ERROR;

            requiredsize = lstrlenA(ansireturn) + 1;

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(rc == NO_ERROR) {

                if(ReturnBuffer) {
                    if(requiredsize <= ReturnBufferSize) {

                        //
                        // At least on NT lstrcpy won't fault if an arg is invalid
                        // but it will return false.
                        //
                        if(!lstrcpyA(ReturnBuffer,ansireturn)) {
                            rc = ERROR_INVALID_PARAMETER;
                            b = FALSE;
                        }

                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                        b = FALSE;
                    }
                }
            }

            MyFree(ansireturn);
        } else {
            b = FALSE;
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(section) {
        MyFree(section);
    }
    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetTargetPathW(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetTargetPath(
    IN  HINF        InfHandle,
    IN  PINFCONTEXT InfContext,       OPTIONAL
    IN  PCTSTR      Section,          OPTIONAL
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    TCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    PCTSTR section;

    if(Section) {
        rc = CaptureStringArg(Section,&section);
    } else {
        section = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = _SetupGetTargetPath(InfHandle,InfContext,section,returnbuffer,MAX_PATH,&requiredsize);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(b) {
        rc = NO_ERROR;

        if(RequiredSize) {
            try {
                *RequiredSize = requiredsize;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
                b = FALSE;
            }
        }

        if(rc == NO_ERROR) {

            if(ReturnBuffer) {
                if(requiredsize <= ReturnBufferSize) {

                    //
                    // At least on NT lstrcpy won't fault if an arg is invalid
                    // but it will return false.
                    //
                    if(!lstrcpy(ReturnBuffer,returnbuffer)) {
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }

                } else {
                    rc = ERROR_INSUFFICIENT_BUFFER;
                    b = FALSE;
                }
            }
        }
    }

    if(section) {
        MyFree(section);
    }
    SetLastError(rc);
    return(b);
}


PCTSTR
pSetupDirectoryIdToPath(
    IN     PCTSTR  DirectoryId,    OPTIONAL
    IN OUT PUINT   DirectoryIdInt, OPTIONAL
    IN     PCTSTR  SubDirectory,   OPTIONAL
    IN     PCTSTR  InfSourcePath,  OPTIONAL
    IN OUT PCTSTR *OsLoaderPath    OPTIONAL
    )
/*++

    (See pSetupDirectoryIdToPathEx for details.)

--*/
{
    return pSetupDirectoryIdToPathEx(DirectoryId,
                                     DirectoryIdInt,
                                     SubDirectory,
                                     InfSourcePath,
                                     OsLoaderPath,
                                     NULL
                                    );
}


PCTSTR
pSetupDirectoryIdToPathEx(
    IN     PCTSTR  DirectoryId,        OPTIONAL
    IN OUT PUINT   DirectoryIdInt,     OPTIONAL
    IN     PCTSTR  SubDirectory,       OPTIONAL
    IN     PCTSTR  InfSourcePath,      OPTIONAL
    IN OUT PCTSTR *OsLoaderPath,       OPTIONAL
    OUT    PBOOL   VolatileSystemDirId OPTIONAL
    )

/*++

Routine Description:

    Translate a directory id/subdirectory pair to an actual path.
    The directory ids are reserved string values that we share with Win9x (and
    then some).

    VOLATILE SYSTEM DIRID PATHS AND USER-DEFINED DIRID PATHS ARE NOT RETURNED
    BY THIS ROUTINE!!!

Arguments:

    DirectoryId - Optionally, supplies the (base-10) textual representation of
        the directory ID number to use.  If this parameter is not specified,
        then DirectoryIdInt must be specified.

    DirectoryIdInt - Optionally, supplies the address of an integer variable
        that specifies, on input, the DIRID to use.  This is only used if
        DirectoryID is not specified.  On output, if DirectoryId was used,
        then this variable receives the numeric value contained in the
        DirectoryId string.

    SubDirectory - Optionally, supplies a subdirectory string that will be
        appended with the DIRID path.

    InfSourcePath - Optionally, supplies the path to be used if the ID turns
        out to be DIRID_SRCPATH.  If this parameter is NULL, and the SourcePath
        DIRID is the one we are to use, then we use the global source path.

    OsLoaderPath - Optionally, supplies the address of a string pointer containing
        the OsLoader path.  If the address points to a NULL string pointer, it will
        be filled in with a newly-allocated character buffer containing the OsLoader
        path, as retrieved from the registry.  This will only be done if the DirectoryId
        being used is on the system partition.

    VolatileSystemDirId - Optionally, supplies the address of a boolean variable
        that, upon successful return, indicates whether or not the specified
        DIRID was a volatile system DIRID.

Return Value:

    If successful, the return value is a pointer to a newly-allocated buffer
    containing the directory path matching the specified DIRID.
    THE CALLER IS RESPONSIBLE FOR FREEING THIS BUFFER!

    If failure, the return value is NULL.  GetLastError() returns the reason
    for failure.  If the failure was because the DIRID was a user-defined one,
    then GetLastError() will return NO_ERROR.

--*/

{
    UINT Value;
    PTCHAR End;
    PCTSTR FirstPart;
    PTSTR Path;
    UINT Length;
    TCHAR Buffer[MAX_PATH];
    BOOL b;
    DWORD err;

    if(VolatileSystemDirId) {
        *VolatileSystemDirId = FALSE;
    }

    if(DirectoryId) {
        //
        // We only allow base-10 integer ids for now.
        // Only the terminating nul should cause the conversion to stop.
        // In any other case there were non-digits in the string.
        // Also disallow the empty string.
        //
        Value = _tcstoul(DirectoryId, &End, 10);

        if(*End || (End == DirectoryId)) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }

        if(DirectoryIdInt) {
            *DirectoryIdInt = Value;
        }

    } else {
        MYASSERT(DirectoryIdInt);
        Value = *DirectoryIdInt;
    }

    if(!SubDirectory) {
        SubDirectory = TEXT("");
    }

    Path = NULL;

    switch(Value) {

    case DIRID_NULL:
    case DIRID_ABSOLUTE:
    case DIRID_ABSOLUTE_16BIT:
        //
        // Absolute.
        //
        FirstPart = NULL;
        break;

    case DIRID_SRCPATH:
        //
        // If the caller supplied a path, then use it, otherwise, use our global default one.
        //
        if(InfSourcePath) {
            FirstPart = InfSourcePath;
        } else {
            FirstPart = SystemSourcePath;
        }
        break;

    case DIRID_BOOT:
    case DIRID_LOADER:
        //
        // System partition DIRIDS
        //
        if(OsLoaderPath && *OsLoaderPath) {
            lstrcpyn(Buffer, *OsLoaderPath, SIZECHARS(Buffer));
        } else {
            err = pSetupGetOsLoaderDriveAndPath(FALSE, Buffer, SIZECHARS(Buffer), &Length);
            if(err) {
                SetLastError(err);
                return NULL;
            }

            if(OsLoaderPath) {
                //
                // allocate a buffer to return the OsLoaderPath to the caller.
                //
                Length *= sizeof(TCHAR);    // need # bytes--not chars

                if(!(*OsLoaderPath = MyMalloc(Length))) {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return(NULL);
                }

                CopyMemory((PVOID)(*OsLoaderPath), Buffer, Length);
            }
        }
        if(Value == DIRID_BOOT) {
            if(Buffer[0] && Buffer[1] == TEXT(':') && Buffer[2] == TEXT('\\')) {
                //
                // got a simple directory to return
                //
                Buffer[3] = TEXT('\0'); // just want "<drive>:\" part.
            } else {
                //
                // use OsSystemPartitionRoot instead
                //
                lstrcpyn(Buffer,OsSystemPartitionRoot,MAX_PATH);
            }
        }
        FirstPart = Buffer;
        break;

    case DIRID_SHARED:
        //
        // On Win95 there is an installation mode that allows most of
        // the OS to exist on a server. If the system is installed in that mode
        // DIRID_SHARED is the location of the windows dir on the server.
        // Otherwise it just maps to the windows dir. For now just map to
        // sysroot.
        //
    case DIRID_WINDOWS:
        //
        // Windows directory
        //
        FirstPart = WindowsDirectory;
        break;

    case DIRID_SYSTEM:
        //
        // Windows system directory
        //
        FirstPart = SystemDirectory;
        break;

    case DIRID_DRIVERS:
        //
        // io subsys directory (drivers)
        //
        FirstPart = DriversDirectory;
        break;

    case DIRID_INF:
        //
        // inf directory
        //
        FirstPart = InfDirectory;
        break;

    case DIRID_HELP:
        //
        // Help directory
        //
        lstrcpyn(Buffer,WindowsDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("help"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_FONTS:
        //
        // Fonts directory
        //
        lstrcpyn(Buffer,WindowsDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("fonts"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_VIEWERS:
        //
        // Viewers directory
        //
        lstrcpyn(Buffer,SystemDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("viewers"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_COLOR:
        //
        // ICM directory
        //
        lstrcpyn(Buffer, SystemDirectory, MAX_PATH);
        if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            //
            // On NT, the path is system32\spool\drivers\color
            //
            pSetupConcatenatePaths(Buffer, TEXT("spool\\drivers\\color"), MAX_PATH, NULL);
        } else {
            //
            // On Win9x, the path is system\color
            //
            pSetupConcatenatePaths(Buffer, TEXT("color"), MAX_PATH, NULL);
        }
        FirstPart = Buffer;
        break;

    case DIRID_APPS:
        //
        // Application directory.
        //
        lstrcpyn(Buffer,WindowsDirectory,MAX_PATH);
        Buffer[2] = 0;
        FirstPart = Buffer;
        break;

    case DIRID_SYSTEM16:
        //
        // 16-bit system directory
        //
        FirstPart = System16Directory;
        break;

    case DIRID_SPOOL:
        //
        // spool directory
        //
        lstrcpyn(Buffer,SystemDirectory,MAX_PATH);
        pSetupConcatenatePaths(Buffer,TEXT("spool"),MAX_PATH,NULL);
        FirstPart = Buffer;
        break;

    case DIRID_SPOOLDRIVERS:

        b = GetPrinterDriverDirectory(
                NULL,                       // local machine
                NULL,                       // default platform
                1,                          // structure level
                (PVOID)Buffer,
                sizeof(Buffer),
                (PDWORD)&Length
                );

        if(!b) {
            return NULL;
        }
        FirstPart = Buffer;
        break;

    case DIRID_PRINTPROCESSOR:

        b = GetPrintProcessorDirectory(
                NULL,                       // local machine
                NULL,                       // default platform
                1,                          // structure level
                (PVOID)Buffer,
                sizeof(Buffer),
                (PDWORD)&Length
                );

        if(!b) {
            return NULL;
        }
        FirstPart = Buffer;
        break;

    case DIRID_USERPROFILE:

        b = GetEnvironmentVariable (
            TEXT("USERPROFILE"),
            Buffer,
            MAX_PATH
            );

        if(!b) {
            //
            // Can this happen?
            //
            return NULL;
        }

        FirstPart = Buffer;
        break;

    default:

        FirstPart = NULL;
        if((Value >= DIRID_USER) || (Value & VOLATILE_DIRID_FLAG)) {
            //
            // User-defined or volatile dirid--don't do anything with this here
            // except let the caller know if it's a volatile system DIRID (if
            // they requested this information).
            //
            if(Value < DIRID_USER && VolatileSystemDirId) {
                *VolatileSystemDirId = TRUE;
            }

            SetLastError(NO_ERROR);
            return NULL;
        }

        //
        // Default to system32\unknown
        //
        if(!FirstPart) {
            lstrcpyn(Buffer,SystemDirectory,MAX_PATH);
            pSetupConcatenatePaths(Buffer,TEXT("unknown"),MAX_PATH,NULL);
            FirstPart = Buffer;
        }
        break;
    }

    if(FirstPart) {

        pSetupConcatenatePaths((PTSTR)FirstPart,SubDirectory,0,&Length);

        Path = MyMalloc(Length * sizeof(TCHAR));
        if(!Path) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        lstrcpy(Path,FirstPart);
        pSetupConcatenatePaths(Path,SubDirectory,Length,NULL);

    } else {
        //
        // Just use subdirectory.
        //
        Path = DuplicateString(SubDirectory);
    }

    //
    // Make sure the path doesn't end with a \. This could happen if
    // subdirectory is the empty string, etc.  Don't do this, however,
    // if it's a root path (e.g., 'A:\').
    //
    if (Path) {
        Length = lstrlen(Path);
        if(Length && *CharPrev(Path,Path+Length) == TEXT('\\')) {
            if((Length != 3) || (Path[1] != TEXT(':'))) {
                Path[Length-1] = 0;
            }
        }
    }
    return(Path);
}


PCTSTR
pGetPathFromDirId(
    IN     PCTSTR      DirectoryId,
    IN     PCTSTR      SubDirectory,   OPTIONAL
    IN     PLOADED_INF pLoadedInf
    )
/*
    Wrapper function that merges functionality of pSetupDirectoryIdToPathEx
    and pSetupVolatileDirIdToPath to return the DIRID that is needed, be it regular,
    volatile or user defined.

*/
{
    BOOL IsVolatileDirID=FALSE;
    PCTSTR ReturnPath;
    UINT Value = 0;

    MYASSERT(DirectoryId);
    MYASSERT(pLoadedInf);

    if( ReturnPath = pSetupDirectoryIdToPathEx(DirectoryId,
                                               &Value,
                                               SubDirectory,
                                               pLoadedInf->InfSourcePath,
                                               NULL,
                                               &IsVolatileDirID) ){

        return( ReturnPath );
    }

    if( IsVolatileDirID || (Value >= DIRID_USER) ){

        ReturnPath = pSetupVolatileDirIdToPath(DirectoryId,
                                               0,
                                               SubDirectory,
                                               pLoadedInf);

        return( ReturnPath );


    }

    // Should never happen

    return NULL;

}




PCTSTR
pSetupFilenameFromLine(
    IN PINFCONTEXT Context,
    IN BOOL        GetSourceName
    )
{
    return(pSetupGetField(Context,GetSourceName ? COPYSECT_SOURCE_FILENAME : COPYSECT_TARGET_FILENAME));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupSetDirectoryIdExA(
    IN HINF  InfHandle,
    IN DWORD Id,        OPTIONAL
    IN PCSTR Directory, OPTIONAL
    IN DWORD Flags,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR directory;

    if(Directory) {
        rc = pSetupCaptureAndConvertAnsiArg(Directory,&directory);
    } else {
        directory = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {
        b = SetupSetDirectoryIdExW(InfHandle,Id,directory,Flags,Reserved1,Reserved2);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    if(directory) {
        MyFree(directory);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupSetDirectoryIdExW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Id);
    UNREFERENCED_PARAMETER(Directory);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupSetDirectoryIdEx(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCTSTR Directory,    OPTIONAL
    IN DWORD  Flags,
    IN DWORD  Reserved1,
    IN PVOID  Reserved2
    )

/*++

Routine Description:

    Associate a directory id in the user directory id range with a particular
    directory. The caller can use this function prior to queueing files for
    copy, for getting files copied to a target location known only at runtime.

    After setting the directory ID, this routine traverses all loaded INFs in
    the InfHandle's linked list, and sees if any of them have unresolved string
    substitutions.  If so, it attempts to re-apply string substitution to them
    based on the new DIRID mapping.  Thus, some INF values may change after calling
    this routine.

Arguments:

    Id - supplies the directory id to use for the association. This value
        MUST be >= DIRID_USER or the function fails and GetLastError
        returns ERROR_INVALID_PARAMETER. If an association for this id
        already exists it is overwritten. If not specified (ie, 0), then
        Directory is ignored, and the entire current set of user-defined
        directory ids is deleted.

    Directory - if specified, supplies the directory path to associate with
        the given id. If not specified, any directory associated with Id
        is unassociated. No error results if Id is not currently associated
        with any directory.

    Flags - supplies a set of flags controlling operation.

        SETDIRID_NOT_FULL_PATH - indicates that the given Directory is not
            a full path specification but is one or more intermediate
            components in a path. Internally, the routine skips its usual
            call to GetFullPathName() if this flag is set.

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information:

    ERROR_NOT_ENOUGH_MEMORY: a memory allocation failed

    ERROR_INVALID_PARAMETER: the Id parameter is not >= DIRID_USER, or
        Directory is not a valid string.

--*/

{
    PCTSTR directory;
    DWORD rc;
    PUSERDIRID UserDirId;
    UINT u;
    TCHAR Buffer[MAX_PATH];
    PTSTR p;
    PUSERDIRID_LIST UserDirIdList;
    DWORD RequiredSize;

    //
    // Validate Id parameter.
    // Also as a special case disallow the 16-bit -1 value.
    // Make sure reserved params are 0.
    //
    if((Id && ((Id < DIRID_USER) || (Id == DIRID_ABSOLUTE_16BIT))) || Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Capture directory, if specified. Ignore if Id is not specified.
    //
    rc = NO_ERROR;
    if(Id && Directory) {
        try {
            directory = DuplicateString(Directory);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
    } else {
        directory = NULL;
    }

    if(rc == NO_ERROR) {
        if(directory) {
            if(Flags & SETDIRID_NOT_FULL_PATH) {
                lstrcpyn(Buffer, directory, MAX_PATH);
                MyFree(directory);
            } else {

                RequiredSize = GetFullPathName(directory,
                                               SIZECHARS(Buffer),
                                               Buffer,
                                               &p
                                              );
                if(!RequiredSize) {
                    rc = GetLastError();
                } else if(RequiredSize >= SIZECHARS(Buffer)) {
                    MYASSERT(0);
                    rc = ERROR_BUFFER_OVERFLOW;
                }

                MyFree(directory);

                if(rc != NO_ERROR) {
                    SetLastError(rc);
                    return(FALSE);
                }
            }
            directory = Buffer;
        }

    } else {
        SetLastError(rc);
        return(FALSE);
    }

    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
      rc = ERROR_INVALID_HANDLE;
    }
    if (rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    UserDirIdList = &(((PLOADED_INF)InfHandle)->UserDirIdList);

    if(Id) {
        //
        // Got an id to use. Find any existing association for it.
        //
        UserDirId = NULL;
        for(u = 0; u < UserDirIdList->UserDirIdCount; u++) {
            if(UserDirIdList->UserDirIds[u].Id == Id) {
                UserDirId = &(UserDirIdList->UserDirIds[u]);
                break;
            }
        }

        if(directory) {

            if(UserDirId) {
                //
                // Overwrite existing association.
                //
                lstrcpy(UserDirId->Directory, directory);

            } else {
                //
                // Add a new association at the end of the list.
                //
                UserDirId = UserDirIdList->UserDirIds
                          ? MyRealloc(UserDirIdList->UserDirIds,
                                      (UserDirIdList->UserDirIdCount+1)*sizeof(USERDIRID))
                          : MyMalloc(sizeof(USERDIRID));

                if(UserDirId) {

                    UserDirIdList->UserDirIds = UserDirId;

                    lstrcpy(UserDirIdList->UserDirIds[UserDirIdList->UserDirIdCount].Directory, directory);
                    UserDirIdList->UserDirIds[UserDirIdList->UserDirIdCount].Id = Id;

                    UserDirIdList->UserDirIdCount++;

                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            //
            // Need to delete any existing association we found.
            //
            if(UserDirId) {
                //
                // Close up the hole in the array.
                // Note that when we get here u is the index of the
                // array slot where we found the match.
                //
                MoveMemory(
                    &(UserDirIdList->UserDirIds[u]),
                    &(UserDirIdList->UserDirIds[u+1]),
                    ((UserDirIdList->UserDirIdCount-u)-1) * sizeof(USERDIRID)
                    );

                //
                // Try to shrink the array -- this really should never fail
                // but we won't fail the call if it does fail for some reason.
                //
                if(UserDirId = MyRealloc(UserDirIdList->UserDirIds,
                                         (UserDirIdList->UserDirIdCount-1)*sizeof(USERDIRID))) {

                    UserDirIdList->UserDirIds = UserDirId;
                }
                UserDirIdList->UserDirIdCount--;
            }
        }

    } else {
        //
        // Id was not specified -- delete any set of associations.
        //
        if(UserDirIdList->UserDirIds) {
            MyFree(UserDirIdList->UserDirIds);
            UserDirIdList->UserDirIds = NULL;
            UserDirIdList->UserDirIdCount = 0;
        }
        MYASSERT(UserDirIdList->UserDirIdCount == 0);    // sanity check.
    }

    if(rc == NO_ERROR) {
        //
        // Now apply new DIRID mappings to all unresolved string substitutions
        // in the loaded INFs.
        //
        rc = ApplyNewVolatileDirIdsToInfs((PLOADED_INF)InfHandle, NULL);
    }

    UnlockInf((PLOADED_INF)InfHandle);

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
SetupSetDirectoryIdA(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCSTR  Directory     OPTIONAL
    )
{
    return(SetupSetDirectoryIdExA(InfHandle,Id,Directory,0,0,0));
}

BOOL
SetupSetDirectoryIdW(
    IN HINF   InfHandle,
    IN DWORD  Id,           OPTIONAL
    IN PCWSTR Directory     OPTIONAL
    )
{
    return(SetupSetDirectoryIdExW(InfHandle,Id,Directory,0,0,0));
}


PCTSTR
pSetupVolatileDirIdToPath(
    IN PCTSTR      DirectoryId,    OPTIONAL
    IN UINT        DirectoryIdInt, OPTIONAL
    IN PCTSTR      SubDirectory,   OPTIONAL
    IN PLOADED_INF Inf
    )

/*++

Routine Description:

    Translate a volatile system DIRID or user-defined DIRID (along with an
    optional subdirectory) to an actual path.

    THIS ROUTINE DOES NOT DO INF LOCKING--CALLER MUST DO IT!

Arguments:

    DirectoryId - Optionally, supplies the directory id in string form.  If
        this parameter is not specified, then DirectoryIdInt is used directly.

    DirectoryIdInst - Supplies the DIRID to find the path for.  This parameter
        is ignored if DirectoryId is supplied.

    SubDirectory - Optionally, supplies a subdirectory to be appended to the
        path specified by the given DIRID.

    Inf - Supplies the address of the loaded INF structure containing the
        user-defined DIRID values to use.

Return Value:

    If success, a pointer to a path string is returned.  The caller is
    responsible for freeing this memory.
    If failure, the return value is NULL, and GetLastError() indicates the
    cause of failure.

--*/

{
    UINT Value;
    PTCHAR End;
    PCTSTR FirstPart;
    PTSTR Path;
    UINT Length;
    PUSERDIRID_LIST UserDirIdList;
    TCHAR SpecialFolderPath[MAX_PATH];

    if(DirectoryId) {
        //
        // We only allow base-10 integer ids for now.
        // Only the terminating nul should cause the conversion to stop.
        // In any other case there were non-digits in the string.
        // Also disallow the empty string.
        //
        Value = _tcstoul(DirectoryId, &End, 10);

        if(*End || (End == DirectoryId)) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }
    } else {
        Value = DirectoryIdInt;
    }

    if(!SubDirectory) {
        SubDirectory = TEXT("");
    }

    Path = NULL;
    FirstPart = NULL;

    if((Value < DIRID_USER) &&  (Value & VOLATILE_DIRID_FLAG)) {

#ifdef ANSI_SETUPAPI

        {
            HRESULT Result;
            LPITEMIDLIST ppidl;

            Result = SHGetSpecialFolderLocation (
                        NULL,
                        Value ^ VOLATILE_DIRID_FLAG,
                        &ppidl
                        );

            if (SUCCEEDED (Result)) {
                if (SHGetPathFromIDList (
                        ppidl,
                        SpecialFolderPath
                        )) {

                    FirstPart = SpecialFolderPath;
                }
            }
        }

#else

        //
        // This is a volatile system DIRID.  Presently, we only support DIRIDs
        // representing shell special folders, and we chose those DIRID values
        // to make it easy to convert to the CSIDL value necessary to hand into
        // SHGetSpecialFolderPath.
        //
        if(SHGetSpecialFolderPath(NULL,
                                  SpecialFolderPath,
                                  (Value ^ VOLATILE_DIRID_FLAG),
                                  TRUE // does this help?
                                 )) {

            FirstPart = SpecialFolderPath;
        }
#endif

    } else {
        //
        // This is a user-defined DIRID--look it up in our list of user DIRIDs
        // presently defined.
        //
        UserDirIdList = &(Inf->UserDirIdList);

        for(Length = 0; Length < UserDirIdList->UserDirIdCount; Length++) {

            if(UserDirIdList->UserDirIds[Length].Id == Value) {

                FirstPart = UserDirIdList->UserDirIds[Length].Directory;
                break;
            }
        }
    }

    if(FirstPart) {

        pSetupConcatenatePaths((PTSTR)FirstPart, SubDirectory, 0, &Length);

        Path = MyMalloc(Length * sizeof(TCHAR));
        if(!Path) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

        lstrcpy(Path, FirstPart);
        pSetupConcatenatePaths(Path, SubDirectory, Length, NULL);

    } else {
        //
        // Just use subdirectory.
        //
        Path = DuplicateString(SubDirectory);
    }

    //
    // Make sure the path doesn't end with a \. This could happen if
    // subdirectory is the empty string, etc.
    //
    if (Path) {
        Length = lstrlen(Path);
        if(Length && (*CharPrev(Path,Path+Length) == TEXT('\\'))) {
            //
            // Special case when we have a path like "A:\"--we don't want
            // to strip the backslash in that scenario.
            //
            if((Length != 3) || (Path[1] != TEXT(':'))) {
                Path[Length-1] = 0;
            }
        }
    }

    return Path;
}


VOID
InfSourcePathFromFileName(
    IN  PCTSTR  InfFileName,
    OUT PTSTR  *SourcePath,  OPTIONAL
    OUT PBOOL   TryPnf
    )
/*++

Routine Description:

    This routine determines whether the specified INF path is in our INF search path list,
    or in %windir%, %windir%\INF, %windir%\system32, or %windir%\system.  If so, then it
    returns NULL.  If not, then it returns a copy of our flobal source path (which must be
    freed via MyFree).

Arguments:

    InfFileName - Supplies the fully-qualified path to the INF.

    SourcePath - Optionally, supplies the address of a variable that receives the address of
        a newly-allocated buffer containing the SourcePath to use, or NULL if the default
        should be used.

    TryPnf - Supplies the address of a variable that is set upon return to indicate whether
        or not this INF was in one of the directories in our INF search path list.

Return Value:

    None.

--*/
{
    TCHAR PathBuffer[MAX_PATH];
    INT TempLen;
    PTSTR s;

    if(SourcePath) {
        *SourcePath = NULL;
    }

    //
    // First, determine if this INF is located somewhere in our search path list.  If so,
    // then there's nothing more to do.
    //
    if(!pSetupInfIsFromOemLocation(InfFileName, FALSE)) {
        *TryPnf = TRUE;
        return;
    } else {
        *TryPnf = FALSE;
        if(!SourcePath) {
            //
            // If the caller doesn't care about the source path, then we're done.
            //
            return;
        }
    }

    //
    // We need to use the directory path where this INF came from as our SourcePath.
    //
    lstrcpy(PathBuffer, InfFileName);
    s = (PTSTR)pSetupGetFileTitle(PathBuffer);

    if(((s - PathBuffer) == 3) && (PathBuffer[1] == TEXT(':'))) {
        //
        // This path is a root path (e.g., 'A:\'), so don't strip the trailing backslash.
        //
        *s = TEXT('\0');
    } else {
        //
        // Strip the trailing backslash.
        //
        if((s > PathBuffer) && (*CharPrev(PathBuffer,s) == TEXT('\\'))) {
            s--;
        }
        *s = TEXT('\0');
    }

    //
    // Next, see if this file exists in any of the following locations:
    //
    // %windir%
    // %windir%\INF
    // %windir%\system32
    // %windir%\system
    //
    if (!lstrcmpi(PathBuffer, WindowsDirectory) ||
        !lstrcmpi(PathBuffer, InfDirectory) ||
        !lstrcmpi(PathBuffer, SystemDirectory) ||
        !lstrcmpi(PathBuffer, System16Directory)) {
        //
        // It is one of the above directories--no need to use any source path
        // other than the default.
        //
        return;
    }

    *SourcePath = DuplicateString(PathBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infinst.c

Abstract:

    High-level INF install section processing API.

Author:

    Ted Miller (tedm) 6-Mar-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Define invalid flags for SetupInstallServicesFromInfSection(Ex)
//
#define SPSVCINST_ILLEGAL_FLAGS (~( SPSVCINST_TAGTOFRONT               \
                                  | SPSVCINST_ASSOCSERVICE             \
                                  | SPSVCINST_DELETEEVENTLOGENTRY      \
                                  | SPSVCINST_NOCLOBBER_DISPLAYNAME    \
                                  | SPSVCINST_NOCLOBBER_STARTTYPE      \
                                  | SPSVCINST_NOCLOBBER_ERRORCONTROL   \
                                  | SPSVCINST_NOCLOBBER_LOADORDERGROUP \
                                  | SPSVCINST_NOCLOBBER_DEPENDENCIES   \
                                  | SPSVCINST_STOPSERVICE              ))

//
// Flags for UpdateInis in INFs
//
#define FLG_MATCH_KEY_AND_VALUE 1

//
// Flags for UpdateIniFields in INFs
//
#define FLG_INIFIELDS_WILDCARDS 1
#define FLG_INIFIELDS_USE_SEP2  2

#define TIME_SCALAR                   (1000)
#define REGISTER_WAIT_TIMEOUT_DEFAULT (60)
#define RUNONCE_TIMEOUT               (2*60*1000)
#define RUNONCE_THRESHOLD             (20) // * RUNONCE_TIMEOUT

#define DLLINSTALL      "DllInstall"
#define DLLREGISTER     "DllRegisterServer"
#define DLLUNREGISTER   "DllUnregisterServer"
#define EXEREGSVR       TEXT("/RegServer")
#define EXEUNREGSVR     TEXT("/UnRegServer")

typedef struct _INIFILESECTION {
    PTSTR IniFileName;
    PTSTR SectionName;
    PTSTR SectionData;
    int BufferSize;
    int BufferUsed;
    struct _INIFILESECTION *Next;
} INIFILESECTION, *PINIFILESECTION;

typedef struct _INISECTIONCACHE {
    //
    // Head of section list.
    //
    PINIFILESECTION Sections;
} INISECTIONCACHE, *PINISECTIONCACHE;

#ifdef CHILDREGISTRATION
typedef struct _WOWSURRAGATE_IPC {
    GUID    MemoryRegionName;
    HANDLE  hFileMap;
    PVOID   MemoryRegion;
    GUID    SignalReadyToRegisterName;
    HANDLE  SignalReadyToRegister;
    GUID    SignalRegistrationCompleteName;
    HANDLE  SignalRegistrationComplete;
    HANDLE  hProcess;
} WOWSURRAGATE_IPC, *PWOWSURRAGATE_IPC;
#endif

typedef struct _REF_STATUS {
    DWORD RefCount;
    DWORD ExtendedStatus;
#if PRERELEASE
    unsigned ThreadId;
#endif
} REF_STATUS, *PREF_STATUS;


typedef struct _OLE_CONTROL_DATA {
    LPTSTR              FullPath;
    UINT                RegType;
    PSETUP_LOG_CONTEXT  LogContext;

    BOOL                Register; // or unregister

    LPCTSTR             Argument;

    PREF_STATUS         Status;
#ifdef CHILDREGISTRATION
    PWOWSURRAGATE_IPC   WowIpcData;
#endif
} OLE_CONTROL_DATA, *POLE_CONTROL_DATA;



CONST TCHAR pszUpdateInis[]      = SZ_KEY_UPDATEINIS,
            pszUpdateIniFields[] = SZ_KEY_UPDATEINIFIELDS,
            pszIni2Reg[]         = SZ_KEY_INI2REG,
            pszAddReg[]          = SZ_KEY_ADDREG,
            pszDelReg[]          = SZ_KEY_DELREG,
            pszBitReg[]          = SZ_KEY_BITREG,
            pszRegSvr[]          = SZ_KEY_REGSVR,
            pszUnRegSvr[]        = SZ_KEY_UNREGSVR,
            pszProfileItems[]    = SZ_KEY_PROFILEITEMS;

//
// Separator chars in an ini field
//
TCHAR pszIniFieldSeparators[] = TEXT(" ,\t");

//
// Mapping between registry key specs in an inf file
// and predefined registry handles.
//

STRING_TO_DATA InfRegSpecTohKey[] = {
    TEXT("HKEY_LOCAL_MACHINE"), ((UINT_PTR)HKEY_LOCAL_MACHINE),
    TEXT("HKLM")              , ((UINT_PTR)HKEY_LOCAL_MACHINE),
    TEXT("HKEY_CLASSES_ROOT") , ((UINT_PTR)HKEY_CLASSES_ROOT),
    TEXT("HKCR")              , ((UINT_PTR)HKEY_CLASSES_ROOT),
    TEXT("HKR")               , ((UINT_PTR)NULL),
    TEXT("HKEY_CURRENT_USER") , ((UINT_PTR)HKEY_CURRENT_USER),
    TEXT("HKCU")              , ((UINT_PTR)HKEY_CURRENT_USER),
    TEXT("HKEY_USERS")        , ((UINT_PTR)HKEY_USERS),
    TEXT("HKU")               , ((UINT_PTR)HKEY_USERS),
    NULL                      , ((UINT_PTR)NULL)
};

//
// Mapping between registry value names and CM device registry property (CM_DRP) codes
//
// These values must be in the exact ordering of the SPDRP codes, as defined in setupapi.h.
// This allows us to easily map between SPDRP and CM_DRP property codes.
//
 STRING_TO_DATA InfRegValToDevRegProp[] = { pszDeviceDesc,               CM_DRP_DEVICEDESC,
                                            pszHardwareID,               CM_DRP_HARDWAREID,
                                            pszCompatibleIDs,            CM_DRP_COMPATIBLEIDS,
                                            TEXT(""),                    CM_DRP_UNUSED0,
                                            pszService,                  CM_DRP_SERVICE,
                                            TEXT(""),                    CM_DRP_UNUSED1,
                                            TEXT(""),                    CM_DRP_UNUSED2,
                                            pszClass,                    CM_DRP_CLASS,
                                            pszClassGuid,                CM_DRP_CLASSGUID,
                                            pszDriver,                   CM_DRP_DRIVER,
                                            pszConfigFlags,              CM_DRP_CONFIGFLAGS,
                                            pszMfg,                      CM_DRP_MFG,
                                            pszFriendlyName,             CM_DRP_FRIENDLYNAME,
                                            pszLocationInformation,      CM_DRP_LOCATION_INFORMATION,
                                            TEXT(""),                    CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            pszCapabilities,             CM_DRP_CAPABILITIES,
                                            pszUiNumber,                 CM_DRP_UI_NUMBER,
                                            pszUpperFilters,             CM_DRP_UPPERFILTERS,
                                            pszLowerFilters,             CM_DRP_LOWERFILTERS,
                                            TEXT(""),                    CM_DRP_BUSTYPEGUID,
                                            TEXT(""),                    CM_DRP_LEGACYBUSTYPE,
                                            TEXT(""),                    CM_DRP_BUSNUMBER,
                                            TEXT(""),                    CM_DRP_ENUMERATOR_NAME,
                                            TEXT(""),                    CM_DRP_SECURITY,
                                            pszDevSecurity,              CM_DRP_SECURITY_SDS,
                                            pszDevType,                  CM_DRP_DEVTYPE,
                                            pszExclusive,                CM_DRP_EXCLUSIVE,
                                            pszCharacteristics,          CM_DRP_CHARACTERISTICS,
                                            TEXT(""),                    CM_DRP_ADDRESS,
                                            pszUiNumberDescFormat,       CM_DRP_UI_NUMBER_DESC_FORMAT,
                                            TEXT(""),                    CM_DRP_DEVICE_POWER_DATA,
                                            TEXT(""),                    CM_DRP_REMOVAL_POLICY,
                                            TEXT(""),                    CM_DRP_REMOVAL_POLICY_HW_DEFAULT,
                                            pszRemovalPolicyOverride,    CM_DRP_REMOVAL_POLICY_OVERRIDE,
                                            TEXT(""),                    CM_DRP_INSTALL_STATE,
                                            NULL,                        0
                                         };

//
// Mapping between registry value names and CM class registry property (CM_CRP) codes
//
// These values must be in the exact ordering of the SPCRP codes, as defined in setupapi.h.
// This allows us to easily map between SPCRP and CM_CRP property codes.
//
STRING_TO_DATA InfRegValToClassRegProp[] = { TEXT(""),                  0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       0,
                                        TEXT(""),                       CM_CRP_SECURITY,
                                        pszDevSecurity,                 CM_CRP_SECURITY_SDS,
                                        pszDevType,                     CM_CRP_DEVTYPE,
                                        pszExclusive,                   CM_CRP_EXCLUSIVE,
                                        pszCharacteristics,             CM_CRP_CHARACTERISTICS,
                                        TEXT(""),                       0,
                                        NULL,                           0
                                     };

//
// Linked list of RunOnce entries encountered during INF processing while
// running in unattended mode.  The contents of this list are accessed by the
// caller via pSetupAccessRunOnceNodeList, and freed via
// pSetupDestroyRunOnceNodeList.
//
// ** NOTE -- THIS LIST IS NOT THREAD SAFE, AND IS FOR USE SOLELY BY THE **
// **         SINGLE THREAD IN UMPNPMGR THAT DOES DEVICE INSTALLATIONS.  **
//
PPSP_RUNONCE_NODE RunOnceListHead = NULL;



HKEY
pSetupInfRegSpecToKeyHandle(
    IN PCTSTR InfRegSpec,
    IN HKEY   UserRootKey,
    IN PBOOL  NeedToCloseKey
    );

DWORD
pSetupValidateDevRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    );

DWORD
pSetupValidateClassRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    );

//
// Internal ini file routines.
//
PINIFILESECTION
pSetupLoadIniFileSection(
    IN     PCTSTR           FileName,
    IN     PCTSTR           SectionName,
    IN OUT PINISECTIONCACHE SectionList
    );

DWORD
pSetupUnloadIniFileSections(
    IN PINISECTIONCACHE SectionList,
    IN BOOL             WriteToFile
    );

PTSTR
pSetupFindLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,      OPTIONAL
    IN PCTSTR          RightHandSide OPTIONAL
    );

BOOL
pSetupReplaceOrAddLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide,   OPTIONAL
    IN BOOL            MatchRHS
    );

BOOL
pSetupAppendLineToSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    );

BOOL
pSetupDeleteLineFromSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    );

DWORD
pSetupSetSecurityForAddRegSection(
    IN HINF Inf,
    IN PCTSTR Section,
    IN PVOID  Context
    );

DWORD
LoadNtOnlyDll(
    IN  PCTSTR DllName,
    OUT HINSTANCE *Dll_Handle
    );

VOID
pSetupFreeOleControlData(
    IN POLE_CONTROL_DATA OleControlData);

DWORD
pSetupEnumInstallationSections(
    IN PVOID  Inf,
    IN PCTSTR Section,
    IN PCTSTR Key,
    IN ULONG_PTR  (*EnumCallbackFunc)(PVOID,PINFCONTEXT,PVOID),
    IN PVOID  Context
    )

/*++

Routine Description:

    Iterate all values on a line in a given section with a given key,
    treating each as the name of a section, and then pass each of the lines
    in the referenced sections to a callback function.

Arguments:

    Inf - supplies a handle to an open inf file.

    Section - supplies the name of the section in which the line whose
        values are to be iterated resides.

    Key - supplies the key of the line whose values are to be iterated.

    EnumCallbackFunc - supplies a pointer to the callback function.
        Each line in each referenced section is passed to this function.

    Context - supplies a context value to be passes through to the
        callback function.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    BOOL b;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    DWORD Field;
    DWORD d;
    PCTSTR SectionName;
    INFCONTEXT FirstLineContext;

    //
    // Find the relevent line in the given install section.
    // If not present then we're done -- report success.
    //
    b = SetupFindFirstLine(Inf,Section,Key,&LineContext);
    if(!b) {
        d = GetLastError();
        if ((d != NO_ERROR) && (d != ERROR_SECTION_NOT_FOUND) && (d != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,NULL,Section,MSG_LOG_INSTALLSECT_ERROR,d,NULL);
        }
        return NO_ERROR; // for compatibility with older SetupAPI
    }

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; Field<=FieldCount; Field++) {

            if((SectionName = pSetupGetField(&LineContext,Field))
            && SetupFindFirstLine(Inf,SectionName,NULL,&FirstLineContext)) {
                //
                // Call the callback routine for every line in the section.
                //
                do {
                    d = (DWORD)EnumCallbackFunc(Inf,&FirstLineContext,Context);
                    if(d != NO_ERROR) {
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionName,MSG_LOG_SECT_ERROR,d,Key);
                        return(d);
                    }
                } while(SetupFindNextLine(&FirstLineContext,&FirstLineContext));
            }
        }
    } while(SetupFindNextMatchLine(&LineContext,Key,&LineContext));

    SetLastError(NO_ERROR);
    return(NO_ERROR);
}

#ifdef UNICODE
DWORD
pSetupSetSecurityForAddRegSection(
    IN HINF Inf,
    IN PCTSTR Section,
    IN PVOID  Context
    )
/*

  This function takes an Addreg section and processes its corresponding .Security section
  if it exists

Arguments:


    Inf - supplies an INF handle so we can get a LogContext.

    Section - Name of the section to process

    Context - supplies the address of a registry modification context
        structure used in adding the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                DWORD               Flags;          // indicates what fields are filled in
                HKEY                UserRootKey;    // HKR
                PGUID               ClassGuid;      // INF_PFLAG_CLASSPROP
                HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
                DWORD               DevInst;        // INF_PFLAG_DEVPROP

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the AddReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is set via a CM API instead of via the registry API
        (which doesn't refer to the same location on Windows NT).
        Flags indicates if DevInst should be used, or if ClassGuid/hMachine pair should be used

Return Value:

    Win32 error code indicating outcome.

*/
{

    BOOL b;
    DWORD ret, LoadStatus;
    DWORD error = NO_ERROR;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    DWORD Field;
    PCTSTR SectionName;
    INFCONTEXT FirstLineContext;
    PREGMOD_CONTEXT RegModContext;
    PCTSTR RootKeySpec;
    FARPROC SceRegUpdate;
    HKEY RootKey;
    HINSTANCE Sce_Dll;
    DWORD slot_regop = 0;
    BOOL CloseKey = FALSE;
    PCTSTR SubKeyName, SecDesc;
    SecDesc = NULL;

    //
    // If we're in "Disable SCE" mode on embedded, then don't process security
    // stuff.
    //
    if(GlobalSetupFlags & PSPGF_NO_SCE_EMBEDDED) {
        return NO_ERROR;
    }

    //
    // Find the relevent line in the given install section.
    // If not present then we're done -- report success.
    //
    b = SetupFindFirstLine(Inf,Section,pszAddReg,&LineContext);
    if(!b) {
        return( NO_ERROR );
    }


    slot_regop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; Field<=FieldCount; Field++) {


            if( (SectionName = pSetupGetField(&LineContext,Field)) &&
                (SetupFindFirstLine(Inf,SectionName,NULL,&FirstLineContext)) ){

                //
                //If security section not present then don't bother and goto next section
                //
                if( !pSetupGetSecurityInfo( Inf, SectionName, &SecDesc )) {
                    continue;
                }

                //
                // Call the callback routine for every line in the section.
                //
                do {
                    RegModContext = (PREGMOD_CONTEXT)Context;
                    if(RootKeySpec = pSetupGetField(&FirstLineContext,1)) {
                        CloseKey = FALSE;
                        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey,&CloseKey);
                        if(!RootKey) {
                            if (slot_regop) {
                                ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
                            }

                            return( ERROR_BADKEY );
                        }

                        SubKeyName = pSetupGetField(&FirstLineContext,2);

                        //
                        // log the fact that we're setting the security...
                        //
                        WriteLogEntry(
                            ((PLOADED_INF) Inf)->LogContext,
                            slot_regop,
                            MSG_LOG_SETTING_SECURITY_ON_SUBKEY,
                            NULL,
                            RootKeySpec,
                            (SubKeyName ? TEXT("\\") : TEXT("")),
                            (SubKeyName ? SubKeyName : TEXT("")),
                            SecDesc);

                        error = ERROR_INVALID_DATA;
                        try {
                            error = (DWORD)SceSetupUpdateSecurityKey( RootKey, (PWSTR)SubKeyName, 0, (PWSTR)SecDesc);
                        } except(EXCEPTION_EXECUTE_HANDLER) {
                            error = ERROR_INVALID_DATA;
                        }
                        if(error) {
                            WriteLogError(
                                ((PLOADED_INF) Inf)->LogContext,
                                SETUP_LOG_ERROR,
                                error);

                            if (CloseKey) {
                                RegCloseKey( RootKey );
                            }

                            return( error );
                        }
                    } else {
                        if (slot_regop) {
                            ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
                        }

                        return( ERROR_INVALID_DATA );
                    }

                    if (CloseKey) {
                        RegCloseKey( RootKey );
                    }

                } while(SetupFindNextLine(&FirstLineContext,&FirstLineContext));

            }

        }
    }while(SetupFindNextMatchLine(&LineContext,pszAddReg,&LineContext));

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }

    return( NO_ERROR );

}

#endif // UNICODE






DWORD_PTR
pSetupProcessUpdateInisLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line containing update-inis directives.

    The line is expected to be in the following format:

    <filename>,<section>,<old-entry>,<new-entry>,<flags>

    <filename> supplies the filename of the ini file.

    <section> supplies the section in the ini file.

    <old-entry> is optional and if specified supplies an entry to
        be removed from the section, in the form "key=val".

    <new-entry> is optional and if specified supplies an entry to
        be added to the section, in the form "key=val".

    <flags> are optional flags
        FLG_MATCH_KEY_AND_VALUE (1)

Arguments:

    Inf - supplies an INF handle so we can get a LogContext.

    InfLineContext - supplies context for current line in the section.

    Context - Supplies pointer to structure describing loaded ini file sections.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR File;
    PCTSTR Section;
    PCTSTR OldLine;
    PCTSTR NewLine;
    BOOL b;
    DWORD d;
    PTCHAR Key,Value;
    PTCHAR p;
    UINT Flags;
    PINIFILESECTION SectData;
    PTSTR LineData;
    PINISECTIONCACHE IniSectionCache;

    IniSectionCache = Context;

    //
    // Get fields from the line.
    //
    File = pSetupGetField(InfLineContext,1);
    Section = pSetupGetField(InfLineContext,2);

    OldLine = pSetupGetField(InfLineContext,3);
    if(OldLine && (*OldLine == 0)) {
        OldLine = NULL;
    }

    NewLine = pSetupGetField(InfLineContext,4);
    if(NewLine && (*NewLine == 0)) {
        NewLine = NULL;
    }

    if(!SetupGetIntField(InfLineContext,5,&Flags)) {
        Flags = 0;
    }

    //
    // File and section must be specified.
    //
    if(!File || !Section) {
        return(ERROR_INVALID_DATA);
    }

    //
    // If oldline and newline are both not specified, we're done.
    //
    if(!OldLine && !NewLine) {
        return(NO_ERROR);
    }

    //
    // Open the file and section.
    //
    SectData = pSetupLoadIniFileSection(File,Section,IniSectionCache);
    if(!SectData) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // If there's an old entry specified, delete it.
    //
    if(OldLine) {

        Key = DuplicateString(OldLine);
        if(!Key) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        p = Key;

        if(Value = _tcschr(Key,TEXT('='))) {
            //
            // Delete by key.
            //
            *Value = 0;
            Value = NULL;
        } else {
            //
            // Delete by value.
            //
            Value = Key;
            Key = NULL;
        }

        pSetupDeleteLineFromSection(SectData,Key,Value);

        MyFree(p);
    }

    //
    // If there's a new entry specified, add it.
    //
    if(NewLine) {

        Key = DuplicateString(NewLine);
        if(!Key) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        p = Key;

        if(Value = _tcschr(Key,TEXT('='))) {
            //
            // There is a key. Depending on flags, we want to match
            // key only or key and value.
            //
            *Value++ = 0;
            b = ((Flags & FLG_MATCH_KEY_AND_VALUE) != 0);

        } else {
            //
            // No key. match whole line. This is the same as matching
            // the RHS only, since no line with a key can match.
            //
            Value = Key;
            Key = NULL;
            b = TRUE;
        }

        if(!pSetupReplaceOrAddLineInSection(SectData,Key,Value,b)) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        MyFree(p);

    }

    return(NO_ERROR);
}


BOOL
pSetupFieldPresentInIniFileLine(
    IN  PTCHAR  Line,
    IN  PCTSTR  Field,
    OUT PTCHAR *Start,
    OUT PTCHAR *End
    )
{
    TCHAR c;
    PTCHAR p,q;
    BOOL b;

    //
    // Skip the key if there is one (there should be one since we use
    // GetPrivateProfileString to query the value!)
    //
    if(p = _tcschr(Line,TEXT('='))) {
        Line = p+1;
    }

    //
    // Skip ini field separators.
    //
    Line += _tcsspn(Line,pszIniFieldSeparators);

    while(*Line) {
        //
        // Locate the end of the field.
        //
        p = Line;
        while(*p && !_tcschr(pszIniFieldSeparators,*p)) {
            if(*p == TEXT('\"')) {
                //
                // Find terminating quote. If none, ignore the quote.
                //
                if(q = _tcschr(p,TEXT('\"'))) {
                    p = q;
                }
            }
            p++;
        }

        //
        // p now points to first char past end of field.
        // Make sure the field is 0-terminated and see if we have
        // what we're looking for.
        c = *p;
        *p = 0;
        b = (lstrcmpi(Line,Field) == 0);
        *p = c;
        //
        // Skip separators so p points to first char in next field,
        // or to the terminating 0.
        //
        p += _tcsspn(p,pszIniFieldSeparators);

        if(b) {
            *Start = Line;
            *End = p;
            return(TRUE);
        }

        Line = p;
    }

    return(FALSE);
}


DWORD_PTR
pSetupProcessUpdateIniFieldsLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line containing update-ini-fields directives. Such directives
    allow individual values in ini files to be removed, added, or replaced.

    The line is expected to be in the following format:

    <filename>,<section>,<key>,<old-field>,<new-field>,<flags>

    <filename> supplies the filename of the ini file.

    <section> supplies the section in the ini file.

    <key> supplies the keyname of the line in the section in the ini file.

    <old-field> supplies the field to be deleted, if specified.

    <new-field> supplies the field to be added to the line, if specified.

    <flags> are optional flags

Arguments:

    InfLineContext - supplies context for current line in the section.

    Context - Supplies pointer to structure describing loaded ini file sections.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR File;
    PCTSTR Section;
    PCTSTR Key;
    TCHAR Value[512];
    #define BUF_SIZE (sizeof(Value)/sizeof(TCHAR))
    TCHAR CONST *Old,*New;
    PTCHAR Start,End;
    BOOL b;
    DWORD d;
    DWORD Space;
    PCTSTR Separator;
    UINT Flags;
    PINISECTIONCACHE IniSectionCache;
    PINIFILESECTION SectData;
    PTSTR Line;

    IniSectionCache = Context;

    //
    // Get fields.
    //
    File = pSetupGetField(InfLineContext,1);
    Section = pSetupGetField(InfLineContext,2);
    Key = pSetupGetField(InfLineContext,3);

    Old = pSetupGetField(InfLineContext,4);
    if(Old && (*Old == 0)) {
        Old = NULL;
    }

    New = pSetupGetField(InfLineContext,5);
    if(New && (*New == 0)) {
        New = NULL;
    }

    if(!SetupGetIntField(InfLineContext,6,&Flags)) {
        Flags = 0;
    }

    //
    // Filename, section name, and key name are mandatory.
    //
    if(!File || !Section || !Key) {
        return(ERROR_INVALID_DATA);
    }

    //
    // If oldline and newline are both not specified, we're done.
    //
    if(!Old && !New) {
        return(NO_ERROR);
    }

    //
    // Open the file and section.
    //
    SectData = pSetupLoadIniFileSection(File,Section,IniSectionCache);
    if(!SectData) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Separator = (Flags & FLG_INIFIELDS_USE_SEP2) ? TEXT(", ") : TEXT(" ");

    if(Line = pSetupFindLineInSection(SectData,Key,NULL)) {
        lstrcpyn(Value, Line, BUF_SIZE);
    } else {
        *Value = TEXT('\0');
    }

    //
    // Look for the old field if specified and remove it.
    //
    if(Old) {
        if(pSetupFieldPresentInIniFileLine(Value,Old,&Start,&End)) {
            MoveMemory(Start,End,(lstrlen(End)+1)*sizeof(TCHAR));
        }
    }

    //
    // If a replacement/new field is specified, put it in there.
    //
    if(New) {
        //
        // Calculate the number of chars that can fit in the buffer.
        //
        Space = BUF_SIZE - (lstrlen(Value) + 1);

        //
        // If there's space, stick the new field at the end of the line.
        //
        if(Space >= (DWORD)lstrlen(Separator)) {
            lstrcat(Value,Separator);
            Space -= lstrlen(Separator);
        }

        if(Space >= (DWORD)lstrlen(New)) {
            lstrcat(Value,New);
        }
    }

    //
    // Write the line back out.
    //
    b = pSetupReplaceOrAddLineInSection(SectData,Key,Value,FALSE);
    d = b ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;

    return(d);
    #undef BUF_SIZE
}


DWORD_PTR
pSetupProcessDelRegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line in the registry that contains delete-registry instructions.
    The line is expected to be in the following forms:

    <root-spec>,<subkey> - delete whole key
    <root-spec>,[<subkey>],[<value-name>][,[<flags>][,<string>]] - delete value

    <Root-spec> is one of HKR, HKLM, etc.

    <subkey> specifies the subkey relative to Root-spec.

    <value-name> is optional. If present if specifies a value entry to be deleted
        from the key. If not present the entire key is deleted. This routine
        cannot handle deleting subtrees; the key to be deleted must not have any
        subkeys or the routine will fail.

    <flags> indicate any special symantics on how to delete this value, and how to interpret the string

    <string> is optional. If flags = FLG_DELREG_MULTI_SZ_DELSTRING, all instances of this string will be removed

Arguments:

    Inf - supplies an INF handle so we can get a LogContext.

    InfLineContext - supplies inf line context for the line containing
        delete-registry instructions.

    Context - supplies the address of a registry modification context
        structure used in deleting the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                DWORD               Flags;          // indicates what fields are filled in
                HKEY                UserRootKey;    // HKR
                PGUID               ClassGuid;      // INF_PFLAG_CLASSPROP
                HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
                DWORD               DevInst;        // INF_PFLAG_DEVPROP

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the DelReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is deleted via a CM API _as well as_ via a registry API
        (the property is stored in a different location inaccessible to the registry
        APIs under Windows NT).

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR RootKeySpec,SubKeyName,ValueName,Data;
    HKEY RootKey,Key;
    DWORD d,rc;
    PREGMOD_CONTEXT RegModContext = (PREGMOD_CONTEXT)Context;
    UINT_PTR CmPropertyCode;
    DWORD slot_regop = 0;
    BOOL CloseKey;
    UINT DelFlags = 0;
    BOOL NonFatal = FALSE;
    CONFIGRET cr;

    //
    // We shouldn't be doing this against a remote machine.
    //
    MYASSERT(!(RegModContext->hMachine));

    //
    // Get root key spec, subkey name, and value name.
    //
    d = ERROR_INVALID_DATA;
    if((RootKeySpec = pSetupGetField(InfLineContext,1))
    && (SubKeyName = pSetupGetField(InfLineContext,2))) {

        ValueName = pSetupGetField(InfLineContext,3);
        if(!SetupGetIntField(InfLineContext,4,&DelFlags)){
            DelFlags = 0;
        }

        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey, &CloseKey);
        if(RootKey) {
            //
            // Make an information log entry saying we are deleting a key.
            // Note that we must allow for the fact that some parts of the
            // name may be missing.
            //
            if (slot_regop == 0) {
                slot_regop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);
            }
            WriteLogEntry(
                ((PLOADED_INF) Inf)->LogContext,
                slot_regop,
                (ValueName ? MSG_LOG_DELETING_REG_VALUE : MSG_LOG_DELETING_REG_KEY),
                NULL,
                RootKeySpec,
                SubKeyName,
                (*SubKeyName && ValueName ? TEXT("\\") : TEXT("")),
                (ValueName ? (*ValueName ? ValueName : TEXT("-")) : TEXT("")));
            if(ValueName && !(DelFlags & FLG_DELREG_KEYONLY_COMMON)) {

                //
                // at this point, we have been given root,subkey,value
                // we might have flags and other parameters
                //

                if(DelFlags & FLG_ADDREG_DELREG_BIT) {
                    //
                    // if we have a flag and that flag indicates
                    // that the entry must be interpreted as DELREG flags
                    // determine how to process flag
                    //
                    switch (DelFlags) {
                        case FLG_DELREG_32BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
                        case FLG_DELREG_64BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
                        case FLG_DELREG_MULTI_SZ_DELSTRING: {
                            Data = pSetupGetField(InfLineContext,5);
                            if (Data && *Data) {
                                //
                                // we have valid parameters for this flag
                                //
                                REGMOD_CONTEXT NewContext = *RegModContext;
                                if(NewContext.UserRootKey != RootKey) {
                                    NewContext.Flags = 0;               // if root is not HKR, clear context flags
                                    NewContext.UserRootKey = RootKey;
                                }

                                WriteLogEntry(
                                    ((PLOADED_INF) Inf)->LogContext,
                                    slot_regop,
                                    MSG_LOG_DELETING_REG_KEY_DELSTRING,
                                    NULL,
                                    RootKeySpec,
                                    SubKeyName,
                                    (*SubKeyName ? TEXT("\\") : TEXT("")),
                                    (*ValueName ? ValueName : TEXT("-")),
                                    Data);

                                //
                                // handling of all special cases done via this internal function
                                //
                                d = _DeleteStringFromMultiSz(
                                        SubKeyName,
                                        ValueName,
                                        Data,
                                        DelFlags,           // specify exact flag
                                        &NewContext
                                        );
                                if (d == ERROR_INVALID_DATA) {
                                    //
                                    // this error code is over-used :-( but get's returned if type mismatches
                                    // we don't consider type mismatch as fatal
                                    //
                                    NonFatal = TRUE;
                                }
                            } else {
                                WriteLogEntry(
                                    ((PLOADED_INF) Inf)->LogContext,
                                    slot_regop,
                                    MSG_LOG_DELETING_REG_KEY_FLAGS,
                                    NULL,
                                    RootKeySpec,
                                    SubKeyName,
                                    (*SubKeyName ? TEXT("\\") : TEXT("")),
                                    (*ValueName ? ValueName : TEXT("-")),
                                    DelFlags);

                                d = ERROR_INVALID_DATA;
                            }
                            goto clean0;
                        }

                        default:
                            WriteLogEntry(
                                ((PLOADED_INF) Inf)->LogContext,
                                slot_regop,
                                MSG_LOG_DELETING_REG_KEY_FLAGS,
                                NULL,
                                RootKeySpec,
                                SubKeyName,
                                (*SubKeyName ? TEXT("\\") : TEXT("")),
                                (*ValueName ? ValueName : TEXT("-")),
                                DelFlags);

                            d = ERROR_INVALID_DATA;
                            goto clean0;
                    }
                }


                if(*ValueName && !(*SubKeyName)) {
                    //
                    // If the key being used is HKR with no subkey specified, and if we
                    // are doing the DelReg for a hardware key (i.e., DevInst is non-NULL,
                    // then we need to check to see whether the value entry is the name of
                    // a device registry property.
                    //
                    if ((RegModContext->Flags & INF_PFLAG_CLASSPROP) != 0 &&
                        LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode)) {
                        //
                        // This value is a class registry property--we must delete the property
                        // by calling a CM API.
                        //
                        cr = CM_Set_Class_Registry_Property(RegModContext->ClassGuid,
                                                         (ULONG)CmPropertyCode,
                                                         NULL,
                                                         0,
                                                         0,
                                                         RegModContext->hMachine
                                                        );
                        switch (cr) {
                            case CR_SUCCESS:
                                rc = NO_ERROR;
                                break;

                            case CR_NO_SUCH_VALUE:
                                rc = ERROR_FILE_NOT_FOUND;
                                break;

                            case CR_INVALID_DEVINST:
                                rc = ERROR_NO_SUCH_DEVINST;
                                break;

                            default:
                                rc = ERROR_INVALID_DATA;
                                break;
                        }
                        if (rc != NO_ERROR && rc != ERROR_FILE_NOT_FOUND) {
                            //
                            // Log that an error occurred accessing CM value
                            //
                            WriteLogError(
                                ((PLOADED_INF) Inf)->LogContext,
                                SETUP_LOG_ERROR,
                                rc);
                        }
                        //
                        // fall through to delete normal registry value, if one exists
                        //
                    } else if ((RegModContext->Flags & INF_PFLAG_DEVPROP) != 0 &&
                       LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode)) {
                        //
                        // This value is a device registry property--we must delete the property
                        // by calling a CM API.
                        //
                        cr = CM_Set_DevInst_Registry_Property(RegModContext->DevInst,
                                                         (ULONG)CmPropertyCode,
                                                         NULL,
                                                         0,
                                                         0
                                                        );
                        switch (cr) {
                            case CR_SUCCESS:
                                rc = NO_ERROR;
                                break;

                            case CR_NO_SUCH_VALUE:
                                rc = ERROR_FILE_NOT_FOUND;
                                break;

                            case CR_INVALID_DEVINST:
                                rc = ERROR_NO_SUCH_DEVINST;
                                break;

                            default:
                                rc = ERROR_INVALID_DATA;
                                break;
                        }
                        if (rc != NO_ERROR && rc != ERROR_FILE_NOT_FOUND) {
                            //
                            // Log that an error occurred accessing CM value
                            //
                            WriteLogError(
                                ((PLOADED_INF) Inf)->LogContext,
                                SETUP_LOG_ERROR,
                                rc);
                        }
                        //
                        // fall through to delete normal registry value, if one exists
                        //
                    }
                }

                //
                // Open subkey for delete.
                //
                d = RegOpenKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
#ifdef _WIN64
                        (( DelFlags & FLG_DELREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( DelFlags & FLG_DELREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_SET_VALUE | KEY_QUERY_VALUE,
                        &Key
                        );

                if(d == NO_ERROR) {
                    d = RegDeleteValue(Key,ValueName);
                    RegCloseKey(Key);
                }

            } else {
                //
                // if we get here, we're only deleting the key
                //
                d = pSetupRegistryDelnodeEx(RootKey,SubKeyName,DelFlags);
            }

            if (CloseKey) {
                RegCloseKey( RootKey );
            }

        } else {
            d = ERROR_BADKEY;
        }
    } else {
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_DELREG_PARAMS,
            NULL);
        return d;
    }

clean0:
    if (CloseKey) {
        RegCloseKey( RootKey );
    }

    if (d != NO_ERROR && d != ERROR_FILE_NOT_FOUND) {
        //
        // Log that an error occurred.
        //
        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            (NonFatal?SETUP_LOG_INFO:SETUP_LOG_ERROR),
            d);
        if (NonFatal) {
            d = NO_ERROR;
        }
    } else if (d != NO_ERROR) {
        //
        // verbose case, not full error, indicate what we did
        //
        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_VERBOSE,
            d);
        d = NO_ERROR;

    } else {

        //
        // just flush the buffer
        //
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_VERBOSE,
            0,
            NULL);
    }

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }
    return(d);
}

DWORD_PTR
pSetupProcessAddRegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line in the INF that contains add-registry instructions.
    The line is expected to be in the following form:

    <root-spec>,<subkey>,<value-name>,<flags>,<value>...

    <Root-spec> is one of HKR, HKLM, etc.

    <subkey> specifies the subkey relative to Root-spec.

    <value-name> is optional. If not present the default value is set.

    <flags> is optional and supplies flags, such as to indicate the data type.
        These are the FLG_ADDREG_* flags defined in setupapi.h, and are a
        superset of those defined for Win95 in setupx.h.

    <value> is one or more values used as the data. The format depends
        on the value type. This value is optional. For REG_DWORD, the
        default is 0. For REG_SZ, REG_EXPAND_SZ, the default is the
        empty string. For REG_BINARY the default is a 0-length entry.
        For REG_MULTI_SZ the default is a single empty string.

    note that if <flags> has FLG_ADDREG_DELREG_BIT set, we ignore the line.

Arguments:

    Inf - supplies an INF handle so we can get a LogContext.

    InfLineContext - supplies inf line context for the line containing
        add-registry instructions.

    Context - supplies the address of a registry modification context
        structure used in adding the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                DWORD               Flags;          // indicates what fields are filled in
                HKEY                UserRootKey;    // HKR
                PGUID               ClassGuid;      // INF_PFLAG_CLASSPROP
                HMACHINE            hMachine;       // INF_PFLAG_CLASSPROP
                DWORD               DevInst;        // INF_PFLAG_DEVPROP

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the AddReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is set via a CM API instead of via the registry API
        (which doesn't refer to the same location on Windows NT).
        Flags indicates if DevInst should be used, or if ClassGuid/hMachine pair should be used

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR RootKeySpec,SubKeyName,ValueName;
    PCTSTR ValueTypeSpec;
    DWORD ValueType;
    HKEY RootKey,Key;
    DWORD d = NO_ERROR;
    BOOL b;
    INT IntVal;
    DWORD Size;
    PVOID Data;
    DWORD Disposition;
    UINT Flags = 0;
    PTSTR *Array;
    PREGMOD_CONTEXT RegModContext = (PREGMOD_CONTEXT)Context;
    UINT_PTR CmPropertyCode;
    PVOID ConvertedBuffer;
    DWORD ConvertedBufferSize;
    CONFIGRET cr;
    DWORD slot_regop = 0;
    BOOL CloseKey = FALSE;



    //
    // We shouldn't be doing this against a remote machine.
    //
    MYASSERT(!(RegModContext->hMachine));

    //
    // Get root key spec.  If we can't get the root key spec, we don't do anything and
    // return NO_ERROR.
    //
    if(RootKeySpec = pSetupGetField(InfLineContext,1)) {

        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey, &CloseKey);
        if(!RootKey) {
            WriteLogEntry(
                ((PLOADED_INF) Inf)->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_ADDREG_NOROOT,
                NULL);
            return(ERROR_BADKEY);
        }

        //
        // SubKeyName is optional.
        //
        SubKeyName = pSetupGetField(InfLineContext,2);

        //
        // ValueName is optional. Either NULL or "" are acceptable
        // to pass to RegSetValueEx.
        //
        ValueName = pSetupGetField(InfLineContext,3);



        //
        // If we don't have a value name, the type is REG_SZ to force
        // the right behavior in RegSetValueEx. Otherwise get the data type.
        //

        ValueType = REG_SZ;
        if(ValueName) {
            if(!SetupGetIntField(InfLineContext,4,&Flags)) {
                Flags = 0;
            }


            if (Flags & FLG_ADDREG_DELREG_BIT) {
                d = NO_ERROR;
                //
                // Log that an error occurred
                //
                WriteLogEntry(
                    ((PLOADED_INF) Inf)->LogContext,
                    SETUP_LOG_VERBOSE,
                    MSG_LOG_SKIP_DELREG_KEY,
                    NULL,
                    RootKeySpec,
                    (SubKeyName ? SubKeyName : TEXT("")),
                    (SubKeyName && ValueName
                     && *SubKeyName && *ValueName ? TEXT("\\") : TEXT("")),
                    (ValueName ? ValueName : TEXT("")),
                    Flags);

                goto clean1;
            }
            switch(Flags & FLG_ADDREG_TYPE_MASK) {

                case FLG_ADDREG_TYPE_SZ :
                    ValueType = REG_SZ;
                    break;

                case FLG_ADDREG_TYPE_MULTI_SZ :
                    ValueType = REG_MULTI_SZ;
                    break;

                case FLG_ADDREG_TYPE_EXPAND_SZ :
                    ValueType = REG_EXPAND_SZ;
                    break;

                case FLG_ADDREG_TYPE_BINARY :
                    ValueType = REG_BINARY;
                    break;

                case FLG_ADDREG_TYPE_DWORD :
                    ValueType = REG_DWORD;
                    break;

                case FLG_ADDREG_TYPE_NONE :
                    ValueType = REG_NONE;
                    break;

                default :
                    //
                    // If the FLG_ADDREG_BINVALUETYPE is set, then the highword
                    // can contain just about any random reg data type ordinal value.
                    //
                    if(Flags & FLG_ADDREG_BINVALUETYPE) {
                        //
                        // Disallow the following reg data types:
                        //
                        //    REG_NONE, REG_SZ, REG_EXPAND_SZ, REG_MULTI_SZ
                        //
                        ValueType = (DWORD)HIWORD(Flags);

                        if((ValueType < REG_BINARY) || (ValueType == REG_MULTI_SZ)) {
                            d = ERROR_INVALID_DATA;
                            goto clean1;
                        }

                    } else {
                        d = ERROR_INVALID_DATA;
                        goto clean1;
                    }
            }
            //
            // Presently, the append behavior flag is only supported for
            // REG_MULTI_SZ values.
            //
            if((Flags & FLG_ADDREG_APPEND) && (ValueType != REG_MULTI_SZ)) {
                d = ERROR_INVALID_DATA;
                goto clean1;
            }
        }

        //
        // On Win9x setting the unnamed value to REG_EXPAND_SZ doesn't
        // work. So we convert to REG_SZ, assuming that anyone on Win9x trying
        // to do this has done the appropriate substitutions. This is a fix
        // for the IE guys, apparently advpack.dll does the right thing to
        // make the fix below viable.
        //
        if((OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
        && (!ValueName || (*ValueName == 0))
        && (ValueType == REG_EXPAND_SZ)) {

            ValueType = REG_SZ;
        }

        //
        // Get the data based on type.
        //
        switch(ValueType) {

        case REG_MULTI_SZ:
            if(Flags & FLG_ADDREG_APPEND) {
                //
                // This is MULTI_SZ_APPEND, which means to append the string value to
                // an existing multi_sz if it's not already there.
                //
                if(SetupGetStringField(InfLineContext,5,NULL,0,&Size)) {
                    Data = MyMalloc(Size*sizeof(TCHAR));
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean1;
                    }
                    if(SetupGetStringField(InfLineContext,5,Data,Size,NULL)) {
                        REGMOD_CONTEXT NewContext = *RegModContext;
                        if(NewContext.UserRootKey != RootKey) {
                            NewContext.Flags = 0;               // if new root, clear context flags
                            NewContext.UserRootKey = RootKey;
                        }

                        d = _AppendStringToMultiSz(
                                SubKeyName,
                                ValueName,
                                (PCTSTR)Data,
                                FALSE,           // don't allow duplicates.
                                &NewContext,
                                Flags
                                );
                    } else {
                        d = GetLastError();
                    }
                    MyFree(Data);
                } else {
                    d = ERROR_INVALID_DATA;
                }
                goto clean1;

            } else {

                if(SetupGetMultiSzField(InfLineContext, 5, NULL, 0, &Size)) {
                    Data = MyMalloc(Size*sizeof(TCHAR));
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean1;
                    }
                    if(!SetupGetMultiSzField(InfLineContext, 5, Data, Size, NULL)) {
                        d = GetLastError();
                        MyFree(Data);
                        goto clean1;
                    }
                    Size *= sizeof(TCHAR);
                } else {
                    Size = sizeof(TCHAR);
                    Data = MyMalloc(Size);
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean1;
                    }
                    *((PTCHAR)Data) = TEXT('\0');
                }
                break;
            }

        case REG_DWORD:
            //
            // Since the old SetupX APIs only allowed REG_BINARY, INFs had to specify REG_DWORD
            // by listing all 4 bytes separately.  Support the old format here, by checking to
            // see whether the line has 4 bytes, and if so, combine those to form the DWORD.
            //
            Size = sizeof(DWORD);
            Data = MyMalloc(sizeof(DWORD));
            if(!Data) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto clean1;
            }

            if(SetupGetFieldCount(InfLineContext) == 8) {
                //
                // Then the DWORD is specified as a list of its constituent bytes.
                //
                if(!SetupGetBinaryField(InfLineContext,5,Data,Size,NULL)) {
                    d = GetLastError();
                    MyFree(Data);
                    goto clean1;
                }
            } else {
                if(!SetupGetIntField(InfLineContext,5,(PINT)Data)) {
                    *(PINT)Data = 0;
                }
            }
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
            if(SetupGetStringField(InfLineContext,5,NULL,0,&Size)) {
                Data = MyMalloc(Size*sizeof(TCHAR));
                if(!Data) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
                if(!SetupGetStringField(InfLineContext,5,Data,Size,NULL)) {
                    d = GetLastError();
                    MyFree(Data);
                    goto clean1;
                }
                Size *= sizeof(TCHAR);
            } else {
                Size = sizeof(TCHAR);
                Data = DuplicateString(TEXT(""));
                if(!Data) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
            }
            break;

        case REG_BINARY:
        default:
            //
            // All other values are specified in REG_BINARY form (i.e., one byte per field).
            //
            if(SetupGetBinaryField(InfLineContext, 5, NULL, 0, &Size)) {
                Data = MyMalloc(Size);
                if(!Data) {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean1;
                }
                if(!SetupGetBinaryField(InfLineContext, 5, Data, Size, NULL)) {
                    d = GetLastError();
                    MyFree(Data);
                    goto clean1;
                }
            } else {
                //
                // error occurred
                //
                d = GetLastError();
                goto clean1;
            }
            break;
        }

        //
        // Set this variable to TRUE only if this value should not be set later on in a call to
        // RegSetValueEx (e.g., if this value is a DevReg Property).
        //
        b = FALSE;

        //
        // Open/create the key.
        //
        if(SubKeyName && *SubKeyName) {
#ifdef UNICODE
            //
            // Warning--extreme hack ahead!!!
            //
            // If we're running in non-interactive mode, we cannot allow
            // RunOnce processing to happen in that context (typically, in TCB)
            // because we have no control over what stuff gets registered for
            // RunOnce.  Also, we can't kick off RunOnce in the context of a
            // logged-on user, because if it's a non-administrator, some of
            // the operations may fail, and be lost forever (SWENUM is a prime
            // example of this).
            //
            // Therefore, when we're in non-interactive mode, we "swallow" any
            // AddReg directives for RunOnce entries that use rundll32, and
            // squirrel them away in a global list.  The caller (i.e.,
            // umpnpmgr) can retrieve this list and do the job of rundll32
            // manually for these entries.  If we encounter any other kinds of
            // runonce entries, we bail.
            //
            if((GlobalSetupFlags & PSPGF_NONINTERACTIVE) &&
               (RootKey == HKEY_LOCAL_MACHINE) &&
               !lstrcmpi(SubKeyName, pszPathRunOnce) &&
               ((ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ))) {

                TCHAR szBuffer[MAX_PATH];
                PTSTR p, q, DontCare;
                DWORD DllPathSize;
                PTSTR DllFullPath, DllParams;
                PSTR  DllEntryPointName;
                PPSP_RUNONCE_NODE CurNode, NewNode;
                BOOL NodeAlreadyInList;
                PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

                //
                // We're looking at a RunOnce entry--see if it's rundll32-based.
                //
                p = _tcschr((PTSTR)Data, TEXT(' '));

                if(p) {

                    *p = TEXT('\0'); // separate 1st part of string for comparison

                    if(!lstrcmpi((PTSTR)Data, TEXT("rundll32.exe")) ||
                       !lstrcmpi((PTSTR)Data, TEXT("rundll32"))) {
                        //
                        // We have ourselves a rundll32 entry!  The next
                        // component (up until we hit a comma) is the name of
                        // the DLL we're supposed to load/run.
                        //
                        // NOTE--we don't deal with the (highly unlikely) case
                        // where the path has an embedded comma in it,
                        // surrounded by quotes.  Oh well.
                        //
                        p++;

                        q = _tcschr(p, TEXT(','));

                        if(q) {

                            *(q++) = TEXT('\0'); // separate 2nd part of string

                            if(ValueType == REG_EXPAND_SZ) {
                                ExpandEnvironmentStrings(p, szBuffer, SIZECHARS(szBuffer));
                            } else {
                                lstrcpyn(szBuffer, p, (size_t)(q - p));
                            }

                            p = (PTSTR)pSetupGetFileTitle(szBuffer);
                            if(!_tcschr(p, TEXT('.'))) {
                                //
                                // The file doesn't have an extension--assume
                                // it's a DLL.
                                //
                                _tcscat(p, TEXT(".dll"));
                            }

                            p = DuplicateString(szBuffer);
                            if(!p) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                goto clean0;
                            }

                            if(p == pSetupGetFileTitle(p)) {
                                //
                                // The filename is a simple filename--assume it
                                // exists in %windir%\system32.
                                //
                                lstrcpyn(szBuffer, SystemDirectory,SIZECHARS(szBuffer));
                                pSetupConcatenatePaths(szBuffer, p, SIZECHARS(szBuffer), NULL);

                            } else {
                                //
                                // The filename contains path information--get
                                // the fully-qualified path.
                                //
                                DllPathSize = GetFullPathName(
                                                  p,
                                                  SIZECHARS(szBuffer),
                                                  szBuffer,
                                                  &DontCare
                                                 );

                                if(!DllPathSize || (DllPathSize >= SIZECHARS(szBuffer))) {
                                    //
                                    // If we start failing because MAX_PATH
                                    // isn't big enough anymore, we wanna know
                                    // about it!
                                    //
                                    MYASSERT(DllPathSize < SIZECHARS(szBuffer));
                                    MyFree(p);
                                    d = GetLastError();
                                    goto clean0;
                                }
                            }

                            //
                            // No longer need temp string copy.
                            //
                            MyFree(p);

                            DllFullPath = DuplicateString(szBuffer);
                            if(!DllFullPath) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                goto clean0;
                            }

                            //
                            // OK, now that we have the full path of the DLL,
                            // verify its digital signature.
                            //
                            IsInfForDeviceInstall(((PLOADED_INF)Inf)->LogContext,
                                                  NULL,
                                                  (PLOADED_INF)Inf,
                                                  NULL,
                                                  &ValidationPlatform,
                                                  NULL,
                                                  NULL
                                                 );



                            d = _VerifyFile(((PLOADED_INF)Inf)->LogContext,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            0,
                                            pSetupGetFileTitle(DllFullPath),
                                            DllFullPath,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            ValidationPlatform,
                                            (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL
                                           );

                            //
                            // Free validation platform info struct, if we had
                            // one allocated above as a result of calling
                            // IsInfForDeviceInstall().
                            //
                            if(ValidationPlatform) {
                                MyFree(ValidationPlatform);
                            }

                            if(d != NO_ERROR) {
                                MyFree(DllFullPath);
                                goto clean0;
                            }

                            //
                            // The DLL seems acceptable to be loaded/run in the
                            // context of the caller.  Retrieve the entrypoint
                            // name (in ANSI), as well as the argument string
                            // to be passed to the DLL.
                            //
                            p = _tcschr(q, TEXT(' '));
                            if(p) {
                                *(p++) = TEXT('\0');
                                DllParams = DuplicateString(p);
                            } else {
                                DllParams = DuplicateString(TEXT(""));
                            }

                            if(!DllParams) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                MyFree(DllFullPath);
                                goto clean0;
                            }

                            DllEntryPointName = pSetupUnicodeToAnsi(q);

                            if(!DllEntryPointName) {
                                d = ERROR_NOT_ENOUGH_MEMORY;
                                MyFree(DllFullPath);
                                MyFree(DllParams);
                                goto clean0;
                            }

                            //
                            // If we get to this point, we have the full DLL
                            // path, the DLL entrypoint (always in ANSI, since
                            // that's what GetProcAddress wants), and the DLL
                            // argument string.  Before we create a new node
                            // to add to our global list, scan the list to see
                            // if the node is already in there (if so, we don't
                            // need to add it again).
                            //
                            NodeAlreadyInList = FALSE;

                            if(RunOnceListHead) {

                                CurNode = NULL;

                                do {
                                    if(CurNode) {
                                        CurNode = CurNode->Next;
                                    } else {
                                        CurNode = RunOnceListHead;
                                    }

                                    if(!lstrcmpi(DllFullPath, CurNode->DllFullPath) &&
                                       !lstrcmpiA(DllEntryPointName, CurNode->DllEntryPointName) &&
                                       !lstrcmpi(DllParams, CurNode->DllParams)) {
                                        //
                                        // We have a duplicate--no need to do
                                        // the same RunOnce operation twice.
                                        //
                                        NodeAlreadyInList = TRUE;
                                        break;
                                    }

                                } while(CurNode->Next);
                            }

                            //
                            // Now create a new rundll32 node and stick it in
                            // our global list (unless it's already in there).
                            //
                            if(NodeAlreadyInList) {
                                NewNode = NULL;
                            } else {
                                NewNode = MyMalloc(sizeof(PSP_RUNONCE_NODE));
                                if(!NewNode) {
                                    d = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }

                            if(NewNode) {

                                NewNode->Next = NULL;
                                NewNode->DllFullPath = DllFullPath;
                                NewNode->DllEntryPointName = DllEntryPointName;
                                NewNode->DllParams = DllParams;

                                //
                                // Add our new node to the end of the list (we
                                // already found the end of the list above when
                                // doing our duplicate search.
                                //
                                if(RunOnceListHead) {
                                    CurNode->Next = NewNode;
                                } else {
                                    RunOnceListHead = NewNode;
                                }

                            } else {
                                //
                                // Either we couldn't allocate a new node entry
                                // (i.e., due to out-of-memory), or we didn't
                                // need to (because the node was already in the
                                // list.
                                //
                                MyFree(DllFullPath);
                                MyFree(DllEntryPointName);
                                MyFree(DllParams);
                            }

                            goto clean0;

                        } else {
                            //
                            // Improperly-formatted rundll32 entry.
                            //
                            d = ERROR_INVALID_DATA;
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't know how to deal with anything else--abort!
                        //
                        d = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
                        goto clean0;
                    }

                } else {
                    //
                    // We don't know how to deal with anything else--abort!
                    //
                    d = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
                    goto clean0;
                }
            }
#endif // UNICODE

            if(Flags & FLG_ADDREG_OVERWRITEONLY) {

                d = RegOpenKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
#ifdef _WIN64
                        (( Flags & FLG_ADDREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( Flags & FLG_ADDREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &Key
                        );

                Disposition = REG_OPENED_EXISTING_KEY;

            } else {
                d = RegCreateKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
#ifdef _WIN64
                        (( Flags & FLG_ADDREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( Flags & FLG_ADDREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        NULL,
                        &Key,
                        &Disposition
                        );
            }

            if(d == NO_ERROR) {

                if(Disposition == REG_OPENED_EXISTING_KEY) {

                    //
                    // Work around hacked nonsense on Win95 where the unnamed value
                    // behaves differently.
                    //
                    if((Flags & FLG_ADDREG_NOCLOBBER)
                    && ((ValueName == NULL) || (*ValueName == 0))
                    && (OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)) {

                        d = 0;
                        if(RegQueryValueEx(Key,TEXT(""),NULL,NULL,(BYTE *)&Disposition,&d) == NO_ERROR) {
                            //
                            // The unnamed value entry is not set.
                            //
                            Flags &= ~FLG_ADDREG_NOCLOBBER;
                        }

                        d = NO_ERROR;
                    }

                    if(Flags & FLG_ADDREG_DELVAL) {
                        //
                        // Added for compatibility with Setupx (lonnym):
                        //     If this flag is present, then the data for this value is ignored, and
                        //     the value entry is deleted.
                        //
                        b = TRUE;
                        RegDeleteValue(Key, ValueName);
                    }
                } else {
                    //
                    // Win9x gets confused and thinks the nonamed value is there
                    // so we never overwrite if noclobber is set. Turn it off here.
                    //
                    Flags &= ~FLG_ADDREG_NOCLOBBER;
                }
            }

        } else {

            d = NO_ERROR;

            //
            // If the key being used is HKR with no subkey specified, and if we
            // are doing the AddReg for a hardware key or for a ClassInstall32
            // entry, then we need to check to see whether the value entry we
            // have is the name of a device or class registry property.
            //
            if((RegModContext->Flags & INF_PFLAG_CLASSPROP) != 0 && ValueName && *ValueName &&
                LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode)) {

                ULONG ExistingPropDataSize = 0;

                b = TRUE;   // we're handling this name here

                //
                // This value is a class registry property--if noclobber flag
                // is set, we must verify that the property doesn't currently
                // exist.
                //

                if((!(Flags & FLG_ADDREG_NOCLOBBER)) ||
                   (CM_Get_Class_Registry_Property(RegModContext->ClassGuid,
                                                     (ULONG)CmPropertyCode,
                                                     NULL,
                                                     NULL,
                                                     &ExistingPropDataSize,
                                                     0,
                                                      RegModContext->hMachine) == CR_NO_SUCH_VALUE)) {
                    //
                    // Next, make sure the data is valid (doing conversion if
                    // necessary and possible).
                    //
                    if((d = pSetupValidateClassRegProp((ULONG)CmPropertyCode,
                                                     ValueType,
                                                     Data,
                                                     Size,
                                                     &ConvertedBuffer,
                                                     &ConvertedBufferSize)) == NO_ERROR) {

                        if((cr = CM_Set_Class_Registry_Property(RegModContext->ClassGuid,
                                                                  (ULONG)CmPropertyCode,
                                                                  ConvertedBuffer ? ConvertedBuffer
                                                                                  : Data,
                                                                  ConvertedBuffer ? ConvertedBufferSize
                                                                                  : Size,
                                                                  0,
                                                                  RegModContext->hMachine)) != CR_SUCCESS) {

                            d = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                                           : ERROR_INVALID_DATA;
                        }

                        if(ConvertedBuffer) {
                            MyFree(ConvertedBuffer);
                        }
                    }
                }

            } else if((RegModContext->Flags & INF_PFLAG_DEVPROP) != 0 && ValueName && *ValueName &&
               LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode)) {

                ULONG ExistingPropDataSize = 0;

                b = TRUE;   // we're handling this name here

                //
                // This value is a device registry property--if noclobber flag
                // is set, we must verify that the property doesn't currently
                // exist.
                //
                if((!(Flags & FLG_ADDREG_NOCLOBBER)) ||
                   (CM_Get_DevInst_Registry_Property(RegModContext->DevInst,
                                                     (ULONG)CmPropertyCode,
                                                     NULL,
                                                     NULL,
                                                     &ExistingPropDataSize,
                                                     0) == CR_NO_SUCH_VALUE)) {
                    //
                    // Next, make sure the data is valid (doing conversion if
                    // necessary and possible).
                    //
                    if((d = pSetupValidateDevRegProp((ULONG)CmPropertyCode,
                                                     ValueType,
                                                     Data,
                                                     Size,
                                                     &ConvertedBuffer,
                                                     &ConvertedBufferSize)) == NO_ERROR) {

                        if((cr = CM_Set_DevInst_Registry_Property(RegModContext->DevInst,
                                                                  (ULONG)CmPropertyCode,
                                                                  ConvertedBuffer ? ConvertedBuffer
                                                                                  : Data,
                                                                  ConvertedBuffer ? ConvertedBufferSize
                                                                                  : Size,
                                                                  0)) != CR_SUCCESS) {

                            d = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                                           : ERROR_INVALID_DATA;
                        }

                        if(ConvertedBuffer) {
                            MyFree(ConvertedBuffer);
                        }
                    }
                }
            }

            //
            // Regardless of whether this value is a devinst registry property,
            // we need to set the Key equal to the RootKey (So we won't think
            // it's a newly-opened key and try to close it later.
            //
            Key = RootKey;
        }

        if(d == NO_ERROR) {

            if(!b) {
                //
                // If noclobber flag is set, then make sure that the value entry doesn't already exist.
                // Also respect the keyonly flag.
                //
                if(!(Flags & (FLG_ADDREG_KEYONLY | FLG_ADDREG_KEYONLY_COMMON))) {

                    if(Flags & FLG_ADDREG_NOCLOBBER) {
                        b = (RegQueryValueEx(Key,ValueName,NULL,NULL,NULL,NULL) != NO_ERROR);
                    } else {
                        if(Flags & FLG_ADDREG_OVERWRITEONLY) {
                            b = (RegQueryValueEx(Key,ValueName,NULL,NULL,NULL,NULL) == NO_ERROR);
                        } else {
                            b = TRUE;
                        }
                    }

                    //
                    // Set the value. Note that at this point d is NO_ERROR.
                    //
                    if(b) {
                        d = RegSetValueEx(Key,ValueName,0,ValueType,Data,Size);
                    }
                }
            }

            if(Key != RootKey) {
                RegCloseKey(Key);
            }
        } else {
            if(Flags & FLG_ADDREG_OVERWRITEONLY) {
                d = NO_ERROR;
            }
        }

#ifdef UNICODE

clean0:

#endif

        MyFree(Data);
    }

clean1:

    if(d != NO_ERROR) {
        //
        // Log that an error occurred
        //
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_SETTING_REG_KEY,
            NULL,
            RootKeySpec,
            (SubKeyName ? SubKeyName : TEXT("")),
            (SubKeyName && ValueName
             && *SubKeyName && *ValueName ? TEXT("\\") : TEXT("")),
            (ValueName ? ValueName : TEXT("")));

        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            d);
    }

    if (CloseKey) {
        RegCloseKey( RootKey );
    }

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }

    return d;
}

DWORD_PTR
pSetupProcessBitRegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )

/*++

Routine Description:

    Process a line in the registry that contains bit-registry instructions.
    The line is expected to be in the following form:

    <root-spec>,<subkey>,<value-name>,<flags>,<byte-mask>,<byte-to-modify>


    <Root-spec> is one of HKR, HKLM, etc.

    <subkey> specifies the subkey relative to Root-spec.

    <value-name> is optional. If not present the default value is set.

    <flags> is optional and supplies flags, such as whether to set bits or clear
        bits.  Value    Meaning
               0        (Default) Clear bits.   (FLG_BITREG_CLEARBITS)
               1        Set bits.                   (FLG_BITREG_SETBITS)

        These are the FLG_BITREG_* flags defined in setupapi.h, and are a
        superset of those defined for Win95 in setupx.h.

    <byte-mask> is a 1-byte hexadecimal value specifying which bits to operate on.

    <byte-to-modify> is the zero based index of the byte number to modify


Arguments:

    InfLineContext - supplies inf line context for the line containing
        add-registry instructions.

    Context - supplies the address of a registry modification context
        structure used in adding the registry value.  The structure is
        defined as:

            typedef struct _REGMOD_CONTEXT {

                HKEY UserRootKey;

                DEVINST DevInst;

            } REGMOD_CONTEXT, *PREGMOD_CONTEXT;

        where UserRootKey is a handle to the open inf key to be used as
        the root when HKR is specified as the root for the operation, and
        DevInst is the optional device instance handle that is supplied when
        the BitReg section is for a hardware key (i.e., under the Enum branch).
        If this handle is supplied, then the value is checked to see whether it
        is the name of a Plug&Play device registry property, and if so, the
        registry property is set via a CM API instead of via the registry API
        (which doesn't refer to the same location on Windows NT).

Return Value:

    Win32 error code indicating outcome.

--*/

{
    PCTSTR RootKeySpec,SubKeyName,ValueName;
    PCTSTR ValueTypeSpec;
    DWORD ValueType;
    HKEY RootKey,Key;
    DWORD d = NO_ERROR;
    DWORD cb;
    BOOL b;
    INT IntVal;
    DWORD Size;
    PBYTE Data = NULL;
    BYTE Mask;
    DWORD Disposition;
    UINT Flags = 0, BitMask = 0, ByteNumber = 0;
    PREGMOD_CONTEXT RegModContext = (PREGMOD_CONTEXT)Context;
    BOOL DevOrClassProp = FALSE;
    CONFIGRET cr;
    UINT_PTR CmPropertyCode;
    BOOL CloseKey;


    //
    // We shouldn't be doing this against a remote machine.
    //
    MYASSERT(!(RegModContext->hMachine));

    //
    // Get root key spec.  If we can't get the root key spec, we don't do anything and
    // return NO_ERROR.
    //
    if(RootKeySpec = pSetupGetField(InfLineContext,1)) {

        RootKey = pSetupInfRegSpecToKeyHandle(RootKeySpec, RegModContext->UserRootKey, &CloseKey);
        if(!RootKey) {
            return(ERROR_BADKEY);
        }

        //
        // SubKeyName is optional.
        //
        SubKeyName = pSetupGetField(InfLineContext,2);

        //
        // ValueName is optional. Either NULL or "" are acceptable
        // to pass to RegSetValueEx.
        //
        ValueName = pSetupGetField(InfLineContext,3);

        //
        // get the flags
        //
        SetupGetIntField(InfLineContext,4,&Flags);

        //
        // get the bitmask
        //
        SetupGetIntField(InfLineContext,5,&BitMask);
        if (BitMask > 0xFF) {
            d = ERROR_INVALID_DATA;
            goto exit;
        }

        //
        // get the byte number to modify
        //
        SetupGetIntField(InfLineContext,6,&ByteNumber);


        //
        // Open the key.
        //
        if(SubKeyName && *SubKeyName) {

            d = RegOpenKeyEx(
                        RootKey,
                        SubKeyName,
                        0,
#ifdef _WIN64
                        (( Flags & FLG_BITREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                        (( Flags & FLG_BITREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &Key
                        );


            if(d == NO_ERROR) {

                //
                // Work around hacked nonsense on Win95 where the unnamed value
                // behaves differently.
                //
                if( ((ValueName == NULL) || (*ValueName == 0))
                    && (OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)) {

                    d = 0;
                    if(RegQueryValueEx(Key,TEXT(""),NULL,&ValueType,(BYTE *)&Disposition,&d) == NO_ERROR) {
                        //
                        // The unnamed value entry is not set.
                        //
                        d = ERROR_INVALID_DATA;
                    }

                }

            }
        } else {
            //
            // If the key being used is HKR with no subkey specified, and if we
            // are doing the BitReg for a hardware key or for a ClassInstall32
            // entry, then we need to check to see whether the value entry we
            // have is the name of a device or class registry property.
            //
            if((RegModContext->Flags & INF_PFLAG_CLASSPROP) && ValueName && *ValueName &&
                LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode)) {
                //
                // Retrieve the existing class property.
                //
                cb = 0;
                cr = CM_Get_Class_Registry_Property(RegModContext->ClassGuid,
                                                    (ULONG)CmPropertyCode,
                                                    &ValueType,
                                                    NULL,
                                                    &cb,
                                                    0,
                                                    RegModContext->hMachine
                                                   );

                if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {
                    //
                    // cb contains the required size for the buffer, in bytes.
                    //
                    if(cb) {
                        Data = (PBYTE)MyMalloc(cb) ;
                        if(!Data) {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if(d == NO_ERROR) {

                            cr = CM_Get_Class_Registry_Property(RegModContext->ClassGuid,
                                                                (ULONG)CmPropertyCode,
                                                                &ValueType,
                                                                Data,
                                                                &cb,
                                                                0,
                                                                RegModContext->hMachine
                                                               );

                            if(cr == CR_SUCCESS) {
                                DevOrClassProp = TRUE;
                            } else {
                                d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                                MyFree(Data);
                                Data = NULL;
                            }
                        }

                    } else {
                        d = ERROR_INVALID_DATA;
                    }

                } else {
                    //
                    // We can't access the property (probably because it doesn't
                    // exist.  We return ERROR_INVALID_DATA for consistency with
                    // the return code used by SetupDiGetDeviceRegistryProperty.
                    //
                    d = ERROR_INVALID_DATA;
                }

            } else if((RegModContext->Flags & INF_PFLAG_DEVPROP) && ValueName && *ValueName &&
               (b = LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode))) {
                //
                // Retrieve the existing device property.
                //
                cb = 0;
                cr = CM_Get_DevInst_Registry_Property(RegModContext->DevInst,
                                                      (ULONG)CmPropertyCode,
                                                      &ValueType,
                                                      NULL,
                                                      &cb,
                                                      0
                                                     );

                if(cr == CR_BUFFER_SMALL) {
                    //
                    // cb contains the required size for the buffer, in bytes.
                    //
                    MYASSERT(cb);

                    Data = (PBYTE)MyMalloc(cb) ;
                    if(!Data) {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                    }

                    if(d == NO_ERROR) {

                        cr = CM_Get_DevInst_Registry_Property(RegModContext->DevInst,
                                                              (ULONG)CmPropertyCode,
                                                              &ValueType,
                                                              Data,
                                                              &cb,
                                                              0
                                                             );
                        if(cr == CR_SUCCESS) {
                            DevOrClassProp = TRUE;
                        } else {
                            d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                            MyFree(Data);
                            Data = NULL;
                        }
                    }

                } else {
                    //
                    // We can't access the property (probably because it doesn't
                    // exist.  We return ERROR_INVALID_DATA for consistency with
                    // the return code used by SetupDiGetDeviceRegistryProperty.
                    //
                    d = ERROR_INVALID_DATA;
                }
            }

            //
            // Regardless of whether this value is a device or class registry
            // property, we need to set the Key equal to the RootKey (So we
            // won't think it's a newly-opened key and try to close it later.
            //
            Key = RootKey;
        }

        if(d == NO_ERROR) {

            if(!DevOrClassProp) {

                d = RegQueryValueEx(Key,ValueName,NULL,&ValueType,NULL,&cb);
                if (d == NO_ERROR) {
                    if (cb != 0 ) {
                        Data = (PBYTE) MyMalloc( cb ) ;
                        if (!Data) {
                            d  = ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if (d == NO_ERROR) {
                            d = RegQueryValueEx(Key,ValueName,NULL,&ValueType,(PBYTE)Data,&cb);
                        }
                    } else {
                        d = ERROR_INVALID_DATA;
                    }
                }
            }

            //
            // byte number is zero-based where-as "cb" isn't
            //
            if(d == NO_ERROR) {
                switch (ValueType) {
                    case REG_BINARY:
                        if (ByteNumber > (cb-1)) {
                            d = ERROR_INVALID_DATA;
                        }
                        break;
                    case REG_DWORD:
                        if (ByteNumber > 3) {
                            d = ERROR_INVALID_DATA;
                        }
                        break;

                    default:
                        d = ERROR_INVALID_DATA;
                };
            }

            if (d == NO_ERROR) {
                //
                // set the target byte based on input flags
                //
                if (Flags == FLG_BITREG_SETBITS) {
                    Data[ByteNumber] |= BitMask;
                } else {
                    Data[ByteNumber] &= ~(BitMask);
                }

                if(DevOrClassProp) {

                    if(RegModContext->Flags & INF_PFLAG_CLASSPROP) {

                        cr = CM_Set_Class_Registry_Property(RegModContext->ClassGuid,
                                                            (ULONG)CmPropertyCode,
                                                            Data,
                                                            cb,
                                                            0,
                                                            RegModContext->hMachine
                                                           );
                        if(cr != CR_SUCCESS) {
                            d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        }

                    } else {

                        MYASSERT(RegModContext->Flags & INF_PFLAG_DEVPROP);

                        cr = CM_Set_DevInst_Registry_Property(RegModContext->DevInst,
                                                              (ULONG)CmPropertyCode,
                                                              Data,
                                                              cb,
                                                              0
                                                             );
                        if(cr != CR_SUCCESS) {
                            d = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        }
                    }

                } else {
                    d = RegSetValueEx(Key,ValueName,0,ValueType,Data,cb);
                }
            }

            if (Data) {
                MyFree(Data);
            }
        }

        if(Key != RootKey) {
            RegCloseKey(Key);
        }
exit:
        if (CloseKey) {
            RegCloseKey(RootKey);
        }
    }

    return d;
}



DWORD_PTR
pSetupProcessIni2RegLine(
    IN PVOID       Inf,
    IN PINFCONTEXT InfLineContext,
    IN PVOID       Context
    )
{
    PCTSTR Filename,Section;
    PCTSTR Key,RegRootSpec,SubkeyPath;
    PTCHAR key,value;
    HKEY UserRootKey,RootKey,hKey;
    DWORD Disposition;
    PTCHAR Line;
    PTCHAR Buffer;
    DWORD d;
    TCHAR val[512];
    #define BUF_SIZE (sizeof(val)/sizeof(TCHAR))
    UINT Flags;
    DWORD slot_regop = 0;
    DWORD slot_subop = 0;
    BOOL CloseKey;


    UserRootKey = (HKEY)Context;

    //
    // Get filename and section name of ini file.
    //
    Filename = pSetupGetField(InfLineContext,1);
    Section = pSetupGetField(InfLineContext,2);
    if(!Filename || !Section) {
        return(ERROR_INVALID_DATA);
    }

    //
    // Get the ini file key. If not specified,
    // use the whole section.
    //
    Key = pSetupGetField(InfLineContext,3);

    //
    // Get the reg root spec and the subkey path.
    //
    RegRootSpec = pSetupGetField(InfLineContext,4);
    SubkeyPath = pSetupGetField(InfLineContext,5);
    if(SubkeyPath && (*SubkeyPath == 0)) {
        SubkeyPath = NULL;
    }

    //
    // Translate the root key spec into an hkey
    //
    RootKey = pSetupInfRegSpecToKeyHandle(RegRootSpec,UserRootKey, &CloseKey);
    if(!RootKey) {
        return(ERROR_BADKEY);
    }

    //
    // Get the flags value.
    //
    if(!SetupGetIntField(InfLineContext,6,&Flags)) {
        Flags = 0;
    }

    //
    // Get the relevent line or section in the ini file.
    //
    if(Key = pSetupGetField(InfLineContext,3)) {

        Buffer = MyMalloc(
                    (  lstrlen(Key)
                     + GetPrivateProfileString(Section,Key,TEXT(""),val,BUF_SIZE,Filename)
                     + 3)
                     * sizeof(TCHAR)
                    );

        if(!Buffer) {
            if (CloseKey) {
               RegCloseKey( RootKey );
            }
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        Buffer[wsprintf((PTSTR)Buffer,TEXT("%s=%s"),Key,val)+1] = 0;

    } else {
        Buffer = MyMalloc(32768);
        if(!Buffer) {
            if (CloseKey) {
               RegCloseKey( RootKey );
            }
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        if(!GetPrivateProfileSection(Section,Buffer,32768,Filename)) {
            *Buffer = 0;
        }
    }

    //
    // Open/create the relevent key.
    //
    d = NO_ERROR;
    //
    // Make an information log entry saying we are adding values.
    // Note that we must allow for the fact that the subkey
    // name may be missing.
    //
    if (slot_regop == 0) {
        slot_regop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);
    }
    WriteLogEntry(
        ((PLOADED_INF) Inf)->LogContext,
        slot_regop,
        MSG_LOG_SETTING_VALUES_IN_KEY,
        NULL,
        RegRootSpec,
        (SubkeyPath ? TEXT("\\") : TEXT("")),
        (SubkeyPath ? SubkeyPath : TEXT("")));

    if(SubkeyPath) {
        d = RegCreateKeyEx(
                RootKey,
                SubkeyPath,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
#ifdef _WIN64
                (( Flags & FLG_INI2REG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                (( Flags & FLG_INI2REG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_SET_VALUE,
                NULL,
                &hKey,
                &Disposition
                );
    } else {
        hKey = RootKey;
    }

    if (slot_subop == 0) {
        slot_subop = AllocLogInfoSlot(((PLOADED_INF) Inf)->LogContext,FALSE);
    }
    for(Line=Buffer; (d==NO_ERROR) && *Line; Line+=lstrlen(Line)+1) {

        //
        // Line points to the key=value pair.
        //
        key = Line;
        if(value = _tcschr(key,TEXT('='))) {
            *value++ = 0;
        } else {
            key = TEXT("");
            value = Line;
        }

        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            slot_subop,
            MSG_LOG_SETTING_REG_VALUE,
            NULL,
            key,
            value);

        //
        // Now key points to the value name and value to the value.
        //
        d = RegSetValueEx(
                hKey,
                key,
                0,
                REG_SZ,
                (CONST BYTE *)value,
                (lstrlen(value)+1)*sizeof(TCHAR)
                );
    }

    if (d != NO_ERROR) {
        //
        // Log that an error occurred, but I don't think that it
        // matters if it was from create or set.
        //
        WriteLogError(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            d);
    }

    if(hKey != RootKey) {
        RegCloseKey(hKey);
    }

    MyFree(Buffer);

    if (slot_regop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_regop);
    }
    if (slot_subop) {
        ReleaseLogInfoSlot(((PLOADED_INF) Inf)->LogContext,slot_subop);
    }

    if (CloseKey) {
        RegCloseKey( RootKey );
    }

    return(d);
    #undef BUF_SIZE
}


DWORD
pSetupInstallUpdateIniFiles(
    IN HINF   Inf,
    IN PCTSTR SectionName
    )

/*++

Routine Description:

    Locate the UpdateInis= and UpdateIniField= lines in an install section
    and process each section listed therein.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d,x;
    INISECTIONCACHE IniSectionCache;

    ZeroMemory(&IniSectionCache,sizeof(INISECTIONCACHE));

    d = pSetupEnumInstallationSections(
            Inf,
            SectionName,
            pszUpdateInis,
            pSetupProcessUpdateInisLine,
            &IniSectionCache
            );

    if(d == NO_ERROR) {

        d = pSetupEnumInstallationSections(
                Inf,
                SectionName,
                pszUpdateIniFields,
                pSetupProcessUpdateIniFieldsLine,
                &IniSectionCache
                );
    }

    x = pSetupUnloadIniFileSections(&IniSectionCache,(d == NO_ERROR));

    return((d == NO_ERROR) ? x : d);
}


DWORD
pSetupInstallRegistry(
    IN HINF            Inf,
    IN PCTSTR          SectionName,
    IN PREGMOD_CONTEXT RegContext
    )

/*++

Routine Description:

    Look for AddReg= and DelReg= directives within an inf section
    and parse them.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    RegContext - supplies context passed into AddReg and DelReg callbacks.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d;

    d = pSetupEnumInstallationSections(Inf,
                                       SectionName,
                                       pszDelReg,
                                       pSetupProcessDelRegLine,
                                       RegContext
                                      );

    if(d == NO_ERROR) {

        d = pSetupEnumInstallationSections(Inf,
                                           SectionName,
                                           pszAddReg,
                                           pSetupProcessAddRegLine,
                                           RegContext
                                          );

        //
        //Set Security on Keys that were created
        //Ignore errors as per security folks
        // pSetupSetSecurityForAddRegSection will log any security errors
        //
#ifdef UNICODE
        if(d == NO_ERROR) {
            pSetupSetSecurityForAddRegSection(Inf, SectionName, RegContext);
        }
#endif
    }

    return d;
}


DWORD
pSetupInstallBitReg(
    IN HINF            Inf,
    IN PCTSTR          SectionName,
    IN PREGMOD_CONTEXT RegContext
    )

/*++

Routine Description:

    Look for BitReg= directives within an inf section and parse them.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    RegContext - supplies context passed into AddReg and DelReg callbacks.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    return pSetupEnumInstallationSections(Inf,
                                          SectionName,
                                          pszBitReg,
                                          pSetupProcessBitRegLine,
                                          RegContext
                                         );
}


DWORD
pSetupInstallIni2Reg(
    IN HINF   Inf,
    IN PCTSTR SectionName,
    IN HKEY   UserRootKey
    )

/*++

Routine Description:


Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

Return Value:

    Win32 error code indicatinh outcome.

--*/

{
    DWORD d;

    d = pSetupEnumInstallationSections(
            Inf,
            SectionName,
            pszIni2Reg,
            pSetupProcessIni2RegLine,
            (PVOID)UserRootKey
            );

    return(d);
}

DWORD
pSetupRegisterDllInstall(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllInstall" entrypoint for the specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered

    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives updated SPREG_* flag indicating outcome


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *InstallRoutine) (BOOL bInstall, LPCTSTR pszCmdLine);
    HRESULT InstallStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        *ExtendedStatus = SPREG_UNKNOWN;
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get function pointer to "DllInstall" entrypoint
    //
    InstallRoutine = NULL; // shut up preFast
    try {
        (FARPROC)InstallRoutine = GetProcAddress(
            ControlDll, DLLINSTALL );
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {
        //
        // something went wrong...record an error
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL, TEXT("SETUP: ...exception in GetProcAddress handled\n"));

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(InstallRoutine) {
        //
        // now call the function
        //
        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: installing...\n"));

        *ExtendedStatus = SPREG_DLLINSTALL;
        try {

            InstallStatus = InstallRoutine(OleControlData->Register, OleControlData->Argument);

            if(FAILED(InstallStatus)) {

                d = InstallStatus;

                WriteLogEntry(
                    OleControlData->LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_OLE_CONTROL_API_FAILED,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL)
                    );
                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);

            } else if(InstallStatus) {
                WriteLogEntry(OleControlData->LogContext,
                                SETUP_LOG_WARNING,
                                MSG_LOG_OLE_CONTROL_API_WARN,
                                NULL,
                                OleControlData->FullPath,
                                TEXT(DLLINSTALL),
                                InstallStatus
                                );
            } else {
                WriteLogEntry(
                                OleControlData->LogContext,
                                SETUP_LOG_VERBOSE,
                                MSG_LOG_OLE_CONTROL_API_OK,
                                NULL,
                                OleControlData->FullPath,
                                TEXT(DLLINSTALL)
                                );
            }

        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                TEXT(DLLINSTALL)
                );

            DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in DllInstall handled\n"));

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...installed\n"));
    } else {
        *ExtendedStatus = SPREG_GETPROCADDR;
    }

    return d;

}

DWORD
pSetupRegisterDllRegister(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllRegisterServer" or "DllUnregisterServer" entrypoint for the
    specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered
    This is a copy of OleControlData from calling thread
    Inf specified is locked, but not native to this thread

    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives an extended status depending on the outcome of
                     this operation


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *RegisterRoutine) (VOID);
    HRESULT RegisterStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get the function pointer to the actual routine we want to call
    //
    RegisterRoutine = NULL; // shut up preFast
    try {
        (FARPROC)RegisterRoutine = GetProcAddress(
            ControlDll, OleControlData->Register ? DLLREGISTER : DLLUNREGISTER);
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {

        //
        // something went wrong, horribly wrong
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in GetProcAddress handled\n"));

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(RegisterRoutine) {

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: registering...\n"));
        *ExtendedStatus = SPREG_REGSVR;
        try {

            RegisterStatus = RegisterRoutine();

            if(FAILED(RegisterStatus)) {

                d = RegisterStatus;

                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_OLE_CONTROL_API_FAILED,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );

                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);
            } else if(RegisterStatus) {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_OLE_CONTROL_API_WARN,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER),
                              RegisterStatus
                              );
            } else {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_VERBOSE,
                              MSG_LOG_OLE_CONTROL_API_OK,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );
            }

        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                );

            DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in DllRegisterServer handled\n"));

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...registered\n"));

    } else {

        d = GetLastError();

        WriteLogEntry(OleControlData->LogContext,
                      SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                      MSG_LOG_OLE_CONTROL_NOT_REGISTERED_GETPROC_FAILED,
                      NULL,
                      OleControlData->FullPath,
                      OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                      );

        WriteLogError(OleControlData->LogContext,
                      SETUP_LOG_ERROR,
                      d);


        *ExtendedStatus = SPREG_GETPROCADDR;

    }

    return d;
}

DWORD
pSetupRegisterLoadDll(
    IN  POLE_CONTROL_DATA OleControlData,
    OUT HMODULE *ControlDll
    )
/*++

Routine Description:

    get the module handle to the specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered

    ControlDll - module handle for the dll


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    DWORD d = NO_ERROR;

    DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: loading dll...\n"));

    try {

        *ControlDll = LoadLibrary(OleControlData->FullPath);

    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...exception in LoadLibrary handled\n"));
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

    } else if (!*ControlDll) {
        d = GetLastError();

        //
        // LoadLibrary failed.
        // File not found is not an error. We want to know about
        // other errors though.
        //

        d = GetLastError();

        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...dll not loaded (%u)\n"),d);

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_FAILED,
            NULL,
            OleControlData->FullPath
            );
        WriteLogError(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            d
            );

    } else {
        DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: ...dll loaded\n"));
    }

    return d;

}

HANDLE
pSetupRegisterExe(
    POLE_CONTROL_DATA OleControlData,
    PDWORD ExtendedStatus OPTIONAL
    )
/*++

Routine Description:

    register an exe by passing it the specified cmdline

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered
    ExtendedStatus - Win32 error code indicating outcome.

Return Value:

    if success, a handle for the process which the caller may wait on.
    if failure, return NULL;

--*/
{
    TCHAR CmdLine[MAX_PATH *2];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    BOOL fallback = FALSE;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!OleControlData) {
        if (ExtendedStatus) {
            *ExtendedStatus =  ERROR_INVALID_DATA;
        }
        return NULL;
    }

    //
    // get the cmdline for the executable
    //
    wsprintf( CmdLine, TEXT("%s %s"),
              OleControlData->FullPath,
              (OleControlData->Argument
                ? OleControlData->Argument
                : (OleControlData->Register
                    ? EXEREGSVR
                    : EXEUNREGSVR)) );

    //
    // no UI
    //
    GetStartupInfo(&StartupInfo);
    StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_HIDE;

    //
    // we first try to create the process specifying FullPath
    // as given as the image name
    // this is to try to circumvent any security hole as outlined
    // in Raid#415625.
    //
    // if that fails, then the INF entry is strange
    // so we have to fall back on old method
    //
    if (! CreateProcess(OleControlData->FullPath,
                        CmdLine,
                        NULL,
                        NULL,
                        FALSE,
                        DETACHED_PROCESS|NORMAL_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &StartupInfo,
                        &ProcessInformation)) {
        fallback = TRUE;
        if (! CreateProcess(NULL,
                            CmdLine,
                            NULL,
                            NULL,
                            FALSE,
                            DETACHED_PROCESS|NORMAL_PRIORITY_CLASS,
                            NULL,
                            NULL,
                            &StartupInfo,
                            &ProcessInformation)) {

            d = GetLastError() ;
        }
    }

    if (d != NO_ERROR) {

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
            MSG_LOG_OLE_CONTROL_CREATEPROCESS_FAILED,
            NULL,
            OleControlData->FullPath,
            (OleControlData->Argument
                ? OleControlData->Argument
                : (OleControlData->Register
                    ? EXEREGSVR
                    : EXEUNREGSVR))
            );
        WriteLogError(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            d
            );

        ProcessInformation.hProcess = NULL;


    } else {

        CloseHandle( ProcessInformation.hThread );

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_VERBOSE,
            MSG_LOG_OLE_CONTROL_CREATEPROCESS_OK,
            NULL,
            OleControlData->FullPath,
            (OleControlData->Argument
                ? OleControlData->Argument
                : (OleControlData->Register
                    ? EXEREGSVR
                    : EXEUNREGSVR))
            );

    }

    if (*ExtendedStatus) {
        *ExtendedStatus = d;
    }

    return ProcessInformation.hProcess;

}



DWORD
__stdcall
pSetupRegisterUnregisterDll(
    VOID *Param
    )
/*++

Routine Description:

    main registration routine for registering exe's and dlls.

Arguments:

    Param - pointer to OLE_CONTROL_DATA structure indicating file to
            be processed

Return Value:

    Win32 error code indicating outcome.

--*/
{
    POLE_CONTROL_DATA OleControlData = (POLE_CONTROL_DATA) Param;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HMODULE ControlDll = NULL;
    PTSTR Extension;
    DWORD d = NO_ERROR;
    DWORD Count;
    SPFUSIONINSTANCE spFusionInstance;

    if(!OleControlData) {
        return ERROR_INVALID_PARAMETER;
    }

    spFusionEnterContext(NULL,&spFusionInstance);

    d = (DWORD)OleInitialize(NULL);
    if (d!= NO_ERROR) {
        OleControlData->Status->ExtendedStatus = SPREG_UNKNOWN;
        goto clean0;
    }

    try {
        //
        // protect everything in TRY-EXCEPT, we're calling unknown code (DLL's)
        //
        d = pSetupRegisterLoadDll( OleControlData, &ControlDll );

        if (d == NO_ERROR) {

            //
            // We successfully loaded it.  Now call the appropriate routines.
            //
            //
            // On register, do DLLREGISTER, then DLLINSTALL
            // On unregister, do DLLINSTALL, then DLLREGISTER
            //
            if (OleControlData->Register) {

                if (OleControlData->RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllRegister(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );

                }

                if (OleControlData->RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllInstall(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );
                }

            } else {

                if (OleControlData->RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllInstall(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );
                }

                if (OleControlData->RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                    d = pSetupRegisterDllRegister(
                                        OleControlData,
                                        ControlDll,
                                        &OleControlData->Status->ExtendedStatus );

                }


            }

        } else {
            ControlDll = NULL;
            OleControlData->Status->ExtendedStatus = SPREG_LOADLIBRARY;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
        // an inpage error dealing with a mapped-in file.
        //
        d = ERROR_INVALID_DATA;
        OleControlData->Status->ExtendedStatus = SPREG_UNKNOWN;
    }

    if (ControlDll) {
        FreeLibrary(ControlDll);
    }

//clean1:
    OleUninitialize();

clean0:

    spFusionLeaveContext(&spFusionInstance);

    if (d == NO_ERROR) {
        OleControlData->Status->ExtendedStatus = SPREG_SUCCESS;
    }

    //
    // we don't need OleControlData anymore so deallocate it here.
    //
    pSetupFreeOleControlData(OleControlData);

    return d;

}

#ifdef CHILDREGISTRATION
BOOL
IsThisANonNativeDll(
    PCTSTR FullPath
    )
/*++

Routine Description:

    determines if a dll is a supported non-native os dll (and must therefore be registered
    in a child process).  Uses the imagehlp APIs to figure this out

Arguments:

    FullPath - Fully qualified path to the dll to be processed


Return Value:

    TRUE indicates that the file is non-native and should therefore be
    registered in a different process.

--*/
{
    LOADED_IMAGE LoadedImage;
    BOOL RetVal = FALSE;
    PSTR FullPathCopy;
    BOOL locked = FALSE;

#ifndef _WIN64
    if(!IsWow64) {
        //
        // we don't support proxying on 32
        //
        return FALSE;
    }
#endif

    //
    // imagehlp takes an ANSI string, so convert it or make a non-const copy.
    //
    FullPathCopy = pSetupUnicodeToMultiByte(FullPath, CP_ACP);

    if (!FullPathCopy) {
        return(FALSE);
    }

    RtlZeroMemory(
        &LoadedImage,
        sizeof(LoadedImage) );

    //
    // get the image headers
    //
    try {
        EnterCriticalSection(&ImageHlpMutex);
        locked = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        MyFree(FullPathCopy);
        return FALSE;
    }
    try {
        if (MapAndLoad(
                FullPathCopy,
                NULL,
                &LoadedImage,
                TRUE, // assume it's a dll if there isn't any file extension
                TRUE /* read only */ )) {

            //
            // let's not bother to do alot of validation on the file, we'll just
            // see if it meets our search requirement of being a non-native dll.
            //
            if (LoadedImage.FileHeader->Signature == IMAGE_NT_SIGNATURE) {

    #if defined(_X86_)
                //
                // this will need to work better for AMD64
                //
                if (LoadedImage.FileHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64) {
                    RetVal = TRUE;
                }
    #elif defined(_IA64_) || defined(_AMD64_)
                if (LoadedImage.FileHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) {
                    RetVal = TRUE;
                }
    #else
    #error Unknown platform
    #endif
            }

            //
            // we do not support 16 bit images
            //
            if (LoadedImage.fDOSImage) {
                RetVal = FALSE;
            }

            UnMapAndLoad(&LoadedImage);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        MYASSERT(FALSE && "exception in Map/Unmap");
    }
    LeaveCriticalSection(&ImageHlpMutex);

    MyFree(FullPathCopy);

    return(RetVal);
}

BOOL
BuildSecureSD(
    OUT PSECURITY_DESCRIPTOR *SDIn
    )
/*++

Routine Description:

    builds a secure security descriptor to be used in securing a globally
    named object. Our "secure" SD's DACL consists of the following permissions:

    Authenticated users get "generic read" access.
    Administrators get "generic all" access.

Arguments:

    SDIn    - pointer to the PSECURITY_DESCRIPTOR to be created.

Return Value:

    TRUE    - Success, the SECURITY_DESCRIPTOR was created successfully.
              The caller is responsible for freeing the SECURITY_DESCRIPTOR

--*/
{
    SID_IDENTIFIER_AUTHORITY NtAuthority         = SECURITY_NT_AUTHORITY;
    PSID                    AuthenticatedUsers;
    PSID                    BuiltInAdministrators;
    PSECURITY_DESCRIPTOR    Sd = NULL;
    ACL                     *Acl;
    ULONG                   AclSize;
    BOOL                    RetVal = TRUE;

    *SDIn = NULL;

    //
    // Allocate and initialize the required SIDs
    //
    if (!AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &BuiltInAdministrators)) {
        return(FALSE);
    }

    if (!AllocateAndInitializeSid(
            &NtAuthority,
            1,
            SECURITY_AUTHENTICATED_USER_RID,
            0,0,0,0,0,0,0,
            &AuthenticatedUsers)) {
        RetVal = FALSE;
        goto e0;
    }




    //
    // "- sizeof (ULONG)" represents the SidStart field of the
    // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
    // SID, this field is counted twice.
    //

    AclSize = sizeof (ACL) +
        (2 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
        GetLengthSid(AuthenticatedUsers) +
        GetLengthSid(BuiltInAdministrators);

    Sd = MyMalloc(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

    if (!Sd) {

        RetVal = FALSE;
        goto e1;

    }



    Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (!InitializeAcl(Acl,
                       AclSize,
                       ACL_REVISION)) {
        RetVal = FALSE;
        goto e2;

    } else if (!AddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    SYNCHRONIZE | GENERIC_READ,
                                    AuthenticatedUsers)) {

        // Failed to build the ACE granting "Authenticated users"
        // (SYNCHRONIZE | GENERIC_READ) access.
        RetVal = FALSE;
        goto e2;

    } else if (!AddAccessAllowedAce(Acl,
                                    ACL_REVISION,
                                    GENERIC_ALL,
                                    BuiltInAdministrators)) {

        // Failed to build the ACE granting "Built-in Administrators"
        // GENERIC_ALL access.
        RetVal = FALSE;
        goto e2;

    } else if (!InitializeSecurityDescriptor(Sd,
                                             SECURITY_DESCRIPTOR_REVISION)) {
        RetVal = FALSE;
        goto e2;

    } else if (!SetSecurityDescriptorDacl(Sd,
                                          TRUE,
                                          Acl,
                                          FALSE)) {

        // error
        RetVal = FALSE;
        goto e2;
    }

    if (!IsValidSecurityDescriptor(Sd)) {
        RetVal = FALSE;
        goto e2;
    }

    //
    // success
    //
    *SDIn = Sd;
    goto e1;

e2:
    MyFree(Sd);
e1:
    FreeSid(AuthenticatedUsers);
e0:
    FreeSid(BuiltInAdministrators);

    return(RetVal);
}

BOOL
pSetupCleanupWowIpcStream(
    IN OUT PWOWSURRAGATE_IPC WowIpcData
    )
/*++

Routine Description:

    This procedure will cleanup the structure that is used for creating
    a child process for registering components.

Arguments:

    WowIpcData - pointer to a WOWSURRAGATE_IPC structure which is cleaned up.

Return Value:

    Returns TRUE if the structure is successfully signalled.

--*/
{
    //
    // if any items are allocated, free them and zero things out
    //
    if (WowIpcData->MemoryRegion) {
        UnmapViewOfFile( WowIpcData->MemoryRegion );
    }

    if (WowIpcData->hFileMap) {
        CloseHandle(WowIpcData->hFileMap);
    }

    if (WowIpcData->SignalReadyToRegister) {
        CloseHandle(WowIpcData->SignalReadyToRegister);
    }

    if (WowIpcData->SignalRegistrationComplete) {
        CloseHandle(WowIpcData->SignalRegistrationComplete);
    }

    if (WowIpcData->hProcess) {
        CloseHandle(WowIpcData->hProcess);
    }

    RtlZeroMemory(WowIpcData,sizeof(WOWSURRAGATE_IPC));

    return(TRUE);

}

BOOL
InitializeWowIpcStream(
    OUT PWOWSURRAGATE_IPC WowIpcData
    )
/*++

Routine Description:

    This procedure will setup the structure that is used for creating
    a child process for registering components.

Arguments:

    WowIpcData - pointer to a WOWSURRAGATE_IPC structure which is filled in
                 with tbe information telling us what the process parameters
                 shall be and how to signal the process.

Return Value:

    Returns TRUE if the structure is successfully signalled.

--*/
{
    BOOL RetVal;
    SECURITY_ATTRIBUTES wowsa,signalreadysa,signalcompletesa;
    PSECURITY_DESCRIPTOR wowsd,signalreadysd,signalcompletesd;
    TCHAR MemoryRegionNameString[GUID_STRING_LEN];
    TCHAR SignalReadyToRegisterNameString[GUID_STRING_LEN];
    TCHAR SignalRegistrationCompleteNameString[GUID_STRING_LEN];


    //
    // clean this thing up just in case there's something left over
    //
    pSetupCleanupWowIpcStream(WowIpcData);

    //
    // create the names of our events and shared memory region
    //
    CoCreateGuid( &WowIpcData->MemoryRegionName );
    CoCreateGuid( &WowIpcData->SignalReadyToRegisterName );
    CoCreateGuid( &WowIpcData->SignalRegistrationCompleteName );

    pSetupStringFromGuid(&WowIpcData->MemoryRegionName,MemoryRegionNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalReadyToRegisterName,SignalReadyToRegisterNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalRegistrationCompleteName,SignalRegistrationCompleteNameString,GUID_STRING_LEN);

    //
    // now create the region and our named events
    //

    //
    // we need to created a named memory region, and this must be properly
    // secured, so we build a security descriptor
    //
    if (!BuildSecureSD(&wowsd)) {
        RetVal = FALSE;
        goto e0;
    }

    wowsa.nLength = sizeof(SECURITY_ATTRIBUTES);
    wowsa.bInheritHandle = TRUE;
    wowsa.lpSecurityDescriptor = wowsd;

    //
    // we need to created a named event, and this must be properly
    // secured, so we build a security descriptor
    //
    if (!BuildSecureSD(&signalreadysd)) {
        RetVal = FALSE;
        goto e1;
    }

    signalreadysa.nLength = sizeof(SECURITY_ATTRIBUTES);
    signalreadysa.bInheritHandle = TRUE;
    signalreadysa.lpSecurityDescriptor = signalreadysd;

    //
    // we need to created a named event, and this must be properly
    // secured, so we build a security descriptor
    //
    if (!BuildSecureSD(&signalcompletesd)) {
        RetVal = FALSE;
        goto e2;
    }

    signalcompletesa.nLength = sizeof(SECURITY_ATTRIBUTES);
    signalcompletesa.bInheritHandle = TRUE;
    signalcompletesa.lpSecurityDescriptor = signalcompletesd;

    WowIpcData->hFileMap = CreateFileMappingW(
                                INVALID_HANDLE_VALUE,
                                &wowsa,
                                PAGE_READWRITE | SEC_COMMIT,
                                0,
                                WOW_IPC_REGION_SIZE,
                                MemoryRegionNameString
                                );
    if (!WowIpcData->hFileMap) {
        RetVal = FALSE;
        goto e2;
        return(FALSE);
    }

    WowIpcData->MemoryRegion = MapViewOfFile(
                                        WowIpcData->hFileMap,
                                        FILE_MAP_WRITE,
                                        0,
                                        0,
                                        0
                                        );
    if (!WowIpcData->MemoryRegion) {
        RetVal = FALSE;
        goto e2;
    }

    WowIpcData->SignalReadyToRegister = CreateEventW(
                                                &signalreadysa,
                                                TRUE,
                                                FALSE,
                                                SignalReadyToRegisterNameString );

    WowIpcData->SignalRegistrationComplete = CreateEventW(
                                                    &signalcompletesa,
                                                    TRUE,
                                                    FALSE,
                                                    SignalRegistrationCompleteNameString );


    if (!WowIpcData->SignalReadyToRegister ||
        !WowIpcData->SignalRegistrationComplete) {
        RetVal = FALSE;
        goto e2;
    }

    RetVal = TRUE;

    //
    // pSetupCleanupWowIpcStream cleans up most of the resources allocated in this routine.
    //
e2:
    MyFree(signalcompletesd);
e1:
    MyFree(signalreadysd);
e0:
    MyFree(wowsd);

    if (!RetVal) {
        pSetupCleanupWowIpcStream(WowIpcData);
    }

    return(RetVal);
}


BOOL
SignalSurragateProcess(
    IN OUT PWOWSURRAGATE_IPC WowIpcData
    )
/*++

Routine Description:

    This procedure will signal our child process if it exists.
    If the process is not running, we will create a new process.

Arguments:

    WowIpcData - pointer to a WOWSURRAGATE_IPC structure which
                 tells us what the process parameters are and how
                 to signal the process

Return Value:

    Returns TRUE if the process is successfully signalled.

--*/
{
    BOOL RetVal;
    WCHAR CmdLine[MAX_PATH];
    WCHAR ProcessName[MAX_PATH];
    PROCESS_INFORMATION ProcessInformation;
    STARTUPINFO StartupInfo;
    TCHAR MemoryRegionNameString[GUID_STRING_LEN];
    TCHAR SignalReadyToRegisterNameString[GUID_STRING_LEN];
    TCHAR SignalRegistrationCompleteNameString[GUID_STRING_LEN];

    BOOL NeedToCreateProcess = FALSE;

    //
    // get the string version of our GUIDs, since we'll need these later
    // on.
    //
    pSetupStringFromGuid(&WowIpcData->MemoryRegionName,MemoryRegionNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalReadyToRegisterName,SignalReadyToRegisterNameString,GUID_STRING_LEN);
    pSetupStringFromGuid(&WowIpcData->SignalRegistrationCompleteName,SignalRegistrationCompleteNameString,GUID_STRING_LEN);

    //
    // put together the cmdline for the child process just in case we need
    // to launch it in a little bit.
    //
    ExpandEnvironmentStrings(
                SURRAGATE_PROCESSNAME,
                ProcessName,
                sizeof(ProcessName)/sizeof(TCHAR) );

    wsprintfW(CmdLine,
              TEXT("%s %s %s %s %s %s %s"),
              ProcessName,
              SURRAGATE_REGIONNAME_SWITCH,
              MemoryRegionNameString,
              SURRAGATE_SIGNALREADY_SWITCH,
              SignalReadyToRegisterNameString,
              SURRAGATE_SIGNALCOMPLETE_SWITCH,
              SignalRegistrationCompleteNameString );

    //
    // no UI
    //
    GetStartupInfo(&StartupInfo);
    StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_HIDE;

    //
    // do we need to create a new process or is our process still running?
    //
    // note that there is a fine race condition here where the child
    // process could go away before we signal our event.
    //
    // I need to see how reachable that race condition is and if this needs
    // to be addressed
    //
    if (!WowIpcData->hProcess) {
        NeedToCreateProcess = TRUE;
    } else if (WaitForSingleObject(WowIpcData->hProcess, 0) == WAIT_OBJECT_0) {
        CloseHandle(WowIpcData->hProcess);
        WowIpcData->hProcess = NULL;
        NeedToCreateProcess = TRUE;
    }

    if (NeedToCreateProcess) {
        //
        // note that we just use the events we were already given, even
        // if we had a process and it's gone away.  Since we use GUIDs,
        // we don't have to worry about any process conflicting with our
        // named events, etc.
        //
#ifndef _WIN64
        if (IsWow64) {
            //
            // allow us to access 64-bit wowreg32 directly
            //
            Wow64DisableFilesystemRedirector(ProcessName);
        }
#endif
        if (! CreateProcessW(NULL,
                             CmdLine,
                             NULL,
                             NULL,
                             FALSE,
                             DETACHED_PROCESS|NORMAL_PRIORITY_CLASS,
                             NULL,
                             NULL,
                             &StartupInfo,
                             &ProcessInformation)) {
           RetVal = FALSE;
           goto e0;
        }
#ifndef _WIN64
        if (IsWow64) {
            //
            // re-enable redirection
            //
            Wow64EnableFilesystemRedirector();
        }
#endif

        //
        // keep ahold of the child process handle so we can wait on it later
        // on.
        //
        WowIpcData->hProcess = ProcessInformation.hProcess;
        CloseHandle(ProcessInformation.hThread);

    }

    //
    // we are completely initialized at this point, so fire off the surragate
    // process with the appropriate parameters.  It will wait until we signal
    // our event before proceeding with reading the shared memory region
    //
    SetEvent(WowIpcData->SignalReadyToRegister);

    RetVal = TRUE;

e0:

    //
    // if we failed to create the process, etc., then clean things up so that
    // things may work better the next time around.
    //
    if (!RetVal) {
        pSetupCleanupWowIpcStream(WowIpcData);
    }

    return(RetVal);

}


HANDLE
pSetupCallChildProcessForRegistration(
    IN POLE_CONTROL_DATA OleControlData,
    OUT PDWORD ExtendedStatus
    )
/*++

Routine Description:

    Procedure asks a child process to register the specified dll.  If the
    child process doesn't exist, it will be created.

Arguments:

    OleControlData - pointer to a OLE_CONTROL_DATA structure which specifes
                     how the file is to be registered.

    ExtendedStatus - receives a win32 error code with extended information
                      (if an error occurs)

Return Value:

    Returns a waitable handle on success which will be signalled when
    registration completes. If the registration cannot be started, the
    return value is NULL.

--*/
{
    PWOW_IPC_REGION_TOSURRAGATE IpcMemRegion;
    PWSTR p;
    //
    // if the ipc mechanism isn't already initialized, then initialze it.
    //
    if (!OleControlData->WowIpcData->MemoryRegion) {
        if (!InitializeWowIpcStream(OleControlData->WowIpcData)) {
            *ExtendedStatus = GetLastError();
            return NULL;
        }
    }

    MYASSERT( OleControlData->WowIpcData->SignalReadyToRegister != NULL );
    MYASSERT( OleControlData->WowIpcData->SignalRegistrationComplete != NULL );

    //
    // the region is initialized, so let's fill it in with the registration
    // data
    //
    IpcMemRegion = (PWOW_IPC_REGION_TOSURRAGATE)OleControlData->WowIpcData->MemoryRegion;

    wcscpy(IpcMemRegion->FullPath,OleControlData->FullPath);

    if (OleControlData->Argument) {
        wcscpy(IpcMemRegion->Argument,OleControlData->Argument);
    } else {
        IpcMemRegion->Argument[0] = UNICODE_NULL;
    }

    IpcMemRegion->RegType = OleControlData->RegType;
    IpcMemRegion->Register = OleControlData->Register;

    //
    // the region is filled in, so now signal the event to tell
    // the surragate to process the data
    //
    if (!SignalSurragateProcess(OleControlData->WowIpcData)) {
        *ExtendedStatus = GetLastError();
        return(NULL);
    }

    //
    // surragate will signal below event when it completes registration
    //
    return(OleControlData->WowIpcData->SignalRegistrationComplete);
}

#endif

VOID
pSetupFreeOleControlData(
    IN POLE_CONTROL_DATA OleControlData
    )
/*++

Routine Description:

    Frees the memory associated with OLE_CONTROL_DATA structure.

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA to be deallocated.

Return Value:

    NONE.

--*/

{
    DWORD Count;

    MYASSERT(OleControlData != NULL);

    if (OleControlData->Argument) {
        MyFree(OleControlData->Argument);
    }

    if (OleControlData->FullPath) {
        MyFree(OleControlData->FullPath);
    }

    if (OleControlData->LogContext) {
        DeleteLogContext(OleControlData->LogContext);
    }

    //
    // watch out here.  this is ref-counted and we only free when the count
    // reaches zero
    //
    if (OleControlData->Status) {
        Count = InterlockedDecrement(&OleControlData->Status->RefCount);
        if (Count == 0) {
            MyFree(OleControlData->Status);
        }
    }

    MyFree(OleControlData);

}


HANDLE
pSetupSpawnRegistration(
    IN POLE_CONTROL_DATA OleControlData,
    OUT PDWORD pHowToGetStatusLaterOn,
    OUT PDWORD pExtendedStatus OPTIONAL
    )
/*++

Routine Description:

    This procedure determines what is the appropriate mechanism for the
    specified file and kicks off registration of that file.

Arguments:

    OleControlData - pointer to a OLE_CONTROL_DATA structure which specifes
                     how the file is to be registered.

    pHowToGetStatusLaterOn - receives a DWORD constant SP_GETSTATUS_* value
                             which indicates how the file was registered so
                             that the caller can get back the appropriate
                             status information later on.

    pExtendedStatus - receives a win32 error code with extended information
                      (if an error occurs)

Return Value:

    Returns a waitable handle on success which will be signalled when
    registration completes. If the registration cannot be started, the
    return value is NULL.

--*/
{
    intptr_t Thread;
    DWORD ThreadId;
    PCTSTR p;
    BOOL ItsAnEXE;
    HANDLE WaitableHandle;
    DWORD ExtendedStatus;
    PREF_STATUS RefStatus = OleControlData->Status;

    MYASSERT(OleControlData != NULL &&
             OleControlData->FullPath != NULL);


    WaitableHandle = NULL;
    ExtendedStatus = ERROR_SUCCESS;
    if (pExtendedStatus) {
        *pExtendedStatus = ERROR_SUCCESS;
    }

    //
    // we keep a refcount on this status, and we increment it
    // now to make sure that the data isn't freed prematurely
    //
    InterlockedIncrement(&OleControlData->Status->RefCount);

    p = _tcsrchr(OleControlData->FullPath, TEXT('.'));
    if (p) {
        p +=1;
    } else {
        ExtendedStatus = ERROR_INVALID_DATA;
        goto e0;
    }

    //
    // let's determine what type of file we're dealing with
    //
    if (0 == _tcsicmp(p,TEXT("exe"))) {
        ItsAnEXE = TRUE;
    } else {
        //
        // let's (gulp!) assume that this is a dll,ocx, or something
        // similar with some wierd extension. in any case, let's
        // just put all of these in the same bucket for now.  If
        // it's really something bogus, then the worst that should
        // happen is that the loadlibrary (in our other thread!) will
        // fall over
        //
        ItsAnEXE = FALSE;
    }

    //
    // if it's an exe, let's just create the process and wait on
    // that handle.
    //
    if (ItsAnEXE) {
        WaitableHandle = pSetupRegisterExe(
                                OleControlData,
                                &ExtendedStatus);

        //
        // we don't need OleControlData anymore, just free it here
        //
        pSetupFreeOleControlData(OleControlData);
        *pHowToGetStatusLaterOn = SP_GETSTATUS_FROMPROCESS;
    } else {
        //
        // we have a dll
        //

        //
        // if we're on 64 bits, then we need to look if this dll is a
        // 32 bit dll.  If it is, then we need use a child process
        // to register the dll.  otherwise we can just treat the dll
        // like "normal"
        //
#ifdef CHILDREGISTRATION
        if (IsThisANonNativeDll(OleControlData->FullPath)) {
            WaitableHandle = pSetupCallChildProcessForRegistration(
                                                OleControlData,
                                                &ExtendedStatus
                                                );
            //
            // we don't need OleControlData anymore, just free it here
            //
            pSetupFreeOleControlData(OleControlData);
            *pHowToGetStatusLaterOn = SP_GETSTATUS_FROMSURRAGATE;
        }
        else
#endif
        //
        // we have a native dll.
        // we handle these in another thread in case it hangs
        //
        {
            Thread = _beginthreadex(
                           NULL,
                           0,
                           pSetupRegisterUnregisterDll,
                           OleControlData,
                           0,
                           &ThreadId
                           );
            if (!Thread) {
                //
                // assume out of memory
                //
                ExtendedStatus = ERROR_NOT_ENOUGH_MEMORY;

                //
                // we don't need OleControlData anymore, just free it here
                //
                pSetupFreeOleControlData(OleControlData);
            } else {
#if PRERELEASE
                RefStatus->ThreadId = ThreadId;
#endif
            }

            WaitableHandle = (HANDLE) Thread;
            *pHowToGetStatusLaterOn = SP_GETSTATUS_FROMDLL;

        }

    }
e0:
    if (pExtendedStatus) {
        *pExtendedStatus = ExtendedStatus;
    }

    return WaitableHandle;

}


DWORD
pSetupProcessRegSvrSection(
    IN HINF   Inf,
    IN PCTSTR Section,
    IN BOOL   Register,
    IN HWND   hWndParent,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth,
    IN BOOL   RegistrationCallbackAware
    )
/*++

Routine Description:

    process all of the registration directives in the specefied RegisterDlls
    section

    each line is expected to be in the following format:

    <dirid>,<subdir>,<filename>,<registration flags>,<optional timeout>,<arguments>

    <dirid> supplies the base directory id of the file.

    <subdir> if specified, specifies the subdir from the base directory
             where the file resides

    <filename> specifies the name of the file to be registered

    <registration flags> specifies the registration action to be taken

        FLG_REGSVR_DLLREGISTER      ( 0x00000001 )
        FLG_REGSVR_DLLINSTALL       ( 0x00000002 )

    <optional timeout> specifies how long to wait for the registration to
                       complete.  if not specified, use the default timeout

    <arguments>  if specified, contains the cmdline to pass to an executable
                 if we're not handling an EXE, this argument is ignored

Arguments:

    Inf        - Inf handle for the section to be processed
    Section    - name of the section to be processed
    Register   - if TRUE, we are registering items, if FALSE, we are
                 unregistering.  this allows the inf to share one section
                 for install and uninstall
    hWndParent - parent window handle we use for a messagebox
    MsgHandler - pointer to callback routine if we're dealing with a
                "registration aware" callback
    Context    - context pointer for callback routine
    IsMsgHandlerNativeCharWidth - indicates if message pieces need translation
    RegistrationCallbackAware - indicates if the callback routine is aware of
                                registration callbacks

Return Value:

    Win32 error code indicating outcome.

--*/
{
    DWORD dircount,d = NO_ERROR;
    DWORD FailureCode,Count;
    INFCONTEXT InfLine;
    PCTSTR DirId,Subdir,FileName, Args;
    UINT RegType, Timeout;
    PCTSTR FullPathTemp;
    TCHAR FullPath[MAX_PATH];
    TCHAR pwd[MAX_PATH];
    POLE_CONTROL_DATA pOleControlData;
    intptr_t Thread;
    unsigned ThreadId;
    DWORD WaitResult;
    HANDLE SignifyRegistration;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD log_slot = 0;
    DWORD HowToGetStatus;
    UINT u;
    PREF_STATUS RefStatus;
    PLOADED_INF pLoadedInf = NULL;
#ifdef CHILDREGISTRATION
    WOWSURRAGATE_IPC WowIpcData;
#endif
#ifdef PRERELEASE
    BOOL LastTimeHadTimeout = FALSE;
    TCHAR LastTimeoutFileName[MAX_PATH];
    DWORD DebugTraceInfo = 0; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif

    //
    // save the current directory so we can restore it later on
    //
    dircount = GetCurrentDirectory(MAX_PATH,pwd);
    if(!dircount || (dircount >= MAX_PATH)) {
        pwd[0] = 0;
    }

#ifdef CHILDREGISTRATION
    ZeroMemory(&WowIpcData,sizeof(WowIpcData));
#endif

    try {
        if(Inf == NULL || Inf == (HINF)INVALID_HANDLE_VALUE || !LockInf((PLOADED_INF)Inf)) {
            d = ERROR_INVALID_PARAMETER;
            leave;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }
    if (d!=NO_ERROR) {
        MYASSERT(d==NO_ERROR);
        goto clean0;
    }
    pLoadedInf = (PLOADED_INF)Inf; // Inf is locked
    d = InheritLogContext(pLoadedInf->LogContext,&LogContext);
    if(d!=NO_ERROR) {
        goto clean0;
    }
    log_slot = AllocLogInfoSlot(LogContext,FALSE);

    //
    // retrieve the items from section and process them one at a time
    //

    if(SetupFindFirstLine(Inf,Section,NULL,&InfLine)) {

        do {
            //
            // retrieve pointers to the parameters for this file
            //

            DirId = pSetupGetField(&InfLine,1);
            Subdir = pSetupGetField(&InfLine,2);
            FileName = pSetupGetField(&InfLine,3);
            RegType = 0;
            SetupGetIntField(&InfLine,4,&RegType);
            Timeout = 0;
            SetupGetIntField(&InfLine,5,&Timeout);
            Args = pSetupGetField(&InfLine,6);

            pOleControlData = MyMalloc(sizeof(OLE_CONTROL_DATA));
            if (!pOleControlData) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
            ZeroMemory(pOleControlData,sizeof(OLE_CONTROL_DATA));

            RefStatus = pOleControlData->Status = MyMalloc(sizeof(REF_STATUS));
            if (!pOleControlData->Status) {
                d = ERROR_NOT_ENOUGH_MEMORY;
                pSetupFreeOleControlData(pOleControlData);
                goto clean0;
            }


            ZeroMemory(pOleControlData->Status,sizeof(REF_STATUS));
            InterlockedIncrement(&pOleControlData->Status->RefCount);

            if (!Timeout) {
                Timeout = REGISTER_WAIT_TIMEOUT_DEFAULT;
            }

            //
            // timeout is specified in seconds, we need to convert to millseconds
            //
            Timeout = Timeout * TIME_SCALAR;

            if(DirId && FileName) {

                if(Subdir && (*Subdir == 0)) {
                    Subdir = NULL;
                }

                DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: filename for file to register is %ws\n"),FileName);

                WriteLogEntry(
                            LogContext,
                            log_slot,
                            MSG_LOG_REGISTER_PARAMS,
                            NULL,
                            Section,
                            DirId,
                            Subdir ? Subdir : TEXT(""),
                            Subdir ? TEXT("\\") : TEXT(""),
                            FileName,
                            RegType,
                            Timeout/TIME_SCALAR);

                try {
#ifdef PRERELEASE
                    DebugTraceInfo |= 2; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                    //
                    // Get full path to the file
                    //
                    if(FullPathTemp = pGetPathFromDirId(DirId,Subdir,pLoadedInf)) {

#ifdef PRERELEASE
                        DebugTraceInfo |= 4; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                        lstrcpyn(FullPath,FullPathTemp,MAX_PATH);
                        SetCurrentDirectory(FullPath);
                        pSetupConcatenatePaths(FullPath,FileName,MAX_PATH,NULL);

#ifdef PRERELEASE
                        DebugTraceInfo |= 8; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                        //
                        // We key off the global "don't verify INFs" flag to
                        // indicate whether crypto support is available yet.  We
                        // don't want to complain about registering unsigned DLLs
                        // when those DLLs are the ones necessary to enable crypto
                        // (e.g., rsaenh.dll, rsaaes.dll, dssenh.dll, initpki.dll)
                        //
                        if(!(GlobalSetupFlags & PSPGF_NO_VERIFY_INF)) {

                            PSP_ALTPLATFORM_INFO_V2 ValidationPlatform = NULL;
                            PTSTR LocalDeviceDesc = NULL;

#ifdef PRERELEASE
                            DebugTraceInfo |= 8; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            //
                            // Verify the digital signature for the file we're
                            // about to register/unregister.  We use a policy of
                            // "Ignore" so that unsigned files will silently be
                            // processed (with logging) except for the case when
                            // we're in non-interactive mode.
                            //
                            // (First, retrieve validation information relevant to
                            // this device setup class.)
                            //
                            IsInfForDeviceInstall(LogContext,
                                                  NULL,
                                                  pLoadedInf,
                                                  &LocalDeviceDesc,
                                                  &ValidationPlatform,
                                                  NULL,
                                                  NULL
                                                 );

                            d = _VerifyFile(LogContext,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            0,
                                            pSetupGetFileTitle(FullPath),
                                            FullPath,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            ValidationPlatform,
                                            (VERIFY_FILE_USE_OEM_CATALOGS | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL
                                           );

                            if(d != NO_ERROR) {

                                if(pSetupHandleFailedVerification(
                                       hWndParent,
                                       SetupapiVerifyRegSvrFileProblem,
                                       FullPath,
                                       LocalDeviceDesc,
                                       DRIVERSIGN_NONE,
                                       TRUE,
                                       d,
                                       LogContext,
                                       NULL,
                                       NULL)) {
                                    //
                                    // We can continue on registering the file, even
                                    // though it's unsigned.
                                    //
                                    d = NO_ERROR;

                                }
                            }

#ifdef PRERELEASE
                            DebugTraceInfo |= 0x10; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            //
                            // Free buffers we may have retrieved when calling
                            // IsInfForDeviceInstall().
                            //
                            if(LocalDeviceDesc) {
                                MyFree(LocalDeviceDesc);
                            }

                            if(ValidationPlatform) {
                                MyFree(ValidationPlatform);
                            }

                            if(d != NO_ERROR) {
                                //
                                // We need to abort the registration...
                                //
                                MyFree(FullPathTemp);
                                pSetupFreeOleControlData(pOleControlData);
                                leave;
                            }
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x20; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif

                        } else {
                            //
                            // Our global flag indicates crypto support isn't
                            // available yet.  Log an entry indicating we skipped
                            // digital signature verification for this file.
                            //
                            WriteLogEntry(LogContext,
                                          SETUP_LOG_WARNING,
                                          (Register
                                            ? MSG_LOG_REGSVR_FILE_VERIFICATION_SKIPPED
                                            : MSG_LOG_UNREGSVR_FILE_VERIFICATION_SKIPPED),
                                          NULL,
                                          FullPath
                                         );
                        }

                        pOleControlData->Register = Register;
                        pOleControlData->FullPath = DuplicateString(FullPath);

#ifdef PRERELEASE
                        DebugTraceInfo |= 0x40; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                        if (!pOleControlData->FullPath) {
                            MyFree(FullPathTemp);
                            d = ERROR_NOT_ENOUGH_MEMORY;
                            pSetupFreeOleControlData(pOleControlData);
                            leave;
                        }
    #ifdef CHILDREGISTRATION
                        pOleControlData->WowIpcData = &WowIpcData;
    #endif
                        pOleControlData->RegType = RegType;
                        pOleControlData->Argument = Args
                                      ? DuplicateString(Args)
                                      : NULL;
                        if (Args && !pOleControlData->Argument) {
                            MyFree(FullPathTemp);
                            d = ERROR_NOT_ENOUGH_MEMORY;
                            pSetupFreeOleControlData(pOleControlData);
                            goto clean0;
                        }
                        InheritLogContext(LogContext,&pOleControlData->LogContext);

                        if (RegistrationCallbackAware && MsgHandler) {
                            //
                            // Inform the callback that we are about to start
                            // a registration operation, giving it the chance
                            // to abort if it wants to.
                            //
                            SP_REGISTER_CONTROL_STATUS ControlStatus;

                            ZeroMemory(
                                &ControlStatus,
                                sizeof(SP_REGISTER_CONTROL_STATUS));
                            ControlStatus.cbSize = sizeof(SP_REGISTER_CONTROL_STATUS);
                            ControlStatus.FileName = FullPath;

                            u = pSetupCallMsgHandler(
                                           LogContext,
                                           MsgHandler,
                                           IsMsgHandlerNativeCharWidth,
                                           Context,
                                           SPFILENOTIFY_STARTREGISTRATION,
                                           (UINT_PTR)&ControlStatus,
                                           Register
                                           );
                        } else {
                            //
                            // not registration aware, assume a default
                            //
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x80; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            u = FILEOP_DOIT;
                        }

                        if(u == FILEOP_ABORT) {
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x100; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            d = GetLastError();
                            if (d==NO_ERROR) {
                                d = ERROR_OPERATION_ABORTED;
                            }
                            WriteLogEntry(
                                        LogContext,
                                        SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                                        MSG_LOG_STARTREGISTRATION_ABORT,
                                        NULL);
                            WriteLogError(
                                        LogContext,
                                        SETUP_LOG_ERROR,
                                        d
                                        );

                            pSetupFreeOleControlData(pOleControlData);

                            MyFree(FullPathTemp);

                            goto clean0;
                        } else if (u == FILEOP_SKIP) {
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x200; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            WriteLogEntry(
                                        LogContext,
                                        SETUP_LOG_WARNING,
                                        MSG_LOG_STARTREGISTRATION_SKIP,
                                        NULL
                                        );
                            pSetupFreeOleControlData(pOleControlData);
                            //
                            // set to NULL so we don't try to free it later
                            //
                            RefStatus = NULL;
                        } else if(u == FILEOP_DOIT) {
                            //
                            // Attempt the registration and inform the callback,
                            //
                            DWORD ExtendedError;
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x200; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
#ifdef PRERELEASE
                            ASSERT_HEAP_IS_VALID();
#endif

                            SignifyRegistration = pSetupSpawnRegistration(
                                                            pOleControlData,
                                                            &HowToGetStatus,
                                                            &ExtendedError );


#ifdef PRERELEASE
                            DebugTraceInfo |= 0x1000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            if(SignifyRegistration) {

                                HANDLE hEvents[1];
                                int CurEvent = 0;

                                //
                                // wait until thread has done a minimal amount of work
                                // when this work is done, we can re-use or trash this structure
                                // and we know timeout for this thread
                                //

                                hEvents[0] = (HANDLE)SignifyRegistration;

                                do {
                                    WaitResult = MyMsgWaitForMultipleObjectsEx(
                                        1,
                                        &hEvents[0],
                                        Timeout,
                                        QS_ALLINPUT,
                                        MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
#ifdef PRERELEASE
                                    DebugTraceInfo |= 0x2000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                    if (WaitResult == WAIT_OBJECT_0 + 1) {
                                        MSG msg;

                                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                                            TranslateMessage(&msg);
                                            DispatchMessage(&msg);
                                        }
                                    }
                                } while(WaitResult != WAIT_TIMEOUT &&
                                        WaitResult != WAIT_OBJECT_0 &&
                                        WaitResult != WAIT_FAILED);

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x4000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                if (WaitResult == WAIT_TIMEOUT) {
#ifdef PRERELEASE
                                    if (HowToGetStatus == SP_GETSTATUS_FROMDLL) {
                                        int __pass;

                                        for(__pass = 0;__pass < 2;__pass ++) {

                                            //
                                            // All stop so this can get debugged
                                            //
                                            DebugPrintEx(
                                                DPFLTR_ERROR_LEVEL,

                                                TEXT("Windows has detected that\n")
                                                TEXT("Registration of \"%s\" appears to have hung\n")
                                                TEXT("Contact owner of the hung DLL to diagnose\n")
                                                TEXT("Timeout for DLL was set to %u seconds\n")
                                                TEXT("ThreadID of hung DLL is %u (0x%x)\n%s"),
                                                FullPath,
                                                Timeout/TIME_SCALAR,
                                                RefStatus->ThreadId,RefStatus->ThreadId,
                                                ((__pass==0) ? TEXT("Hitting 'g' will display this again\n") : TEXT(""))
                                                );
                                                DebugBreak();
                                        }
                                    }
#endif
                                    //
                                    //  the ole registration is hung
                                    //  log an error
                                    //
                                    WriteLogEntry(
                                        LogContext,
                                        SETUP_LOG_ERROR,
                                        MSG_LOG_OLE_REGISTRATION_HUNG,
                                        NULL,
                                        FullPath
                                        );

                                    d = WAIT_TIMEOUT;
                                    FailureCode = SPREG_TIMEOUT;


#ifdef PRERELEASE
                                    //
                                    // This is to catch setup errors
                                    // and does not indicate an error
                                    // in SetupAPI
                                    //
                                    if (LastTimeHadTimeout) {
#ifdef CHILDREGISTRATION
                                            if (HowToGetStatus == SP_GETSTATUS_FROMSURRAGATE) {
                                                DebugPrintEx(
                                                    DPFLTR_ERROR_LEVEL,
#ifdef _WIN64
                                                    TEXT("Windows has detected that ")
                                                    TEXT("32-bit WOWREG32 has timed out while registering \"%s\". ")
                                                    TEXT("Prior to this, \"%s\" timed out. ")
                                                    TEXT("This may indicate a persistent error. ")
                                                    TEXT("To diagnose, try to ")
                                                    TEXT("register them by hand or contact ")
                                                    TEXT("the owners of these files ")
                                                    TEXT("to determine why they are timing out. ")
                                                    TEXT("also try running other 32-bit executables.\n"),
#else
                                                    TEXT("Windows has detected that ")
                                                    TEXT("64-bit WOWREG32 has timed out while registering \"%s\". ")
                                                    TEXT("Prior to this, \"%s\" timed out. ")
                                                    TEXT("This may indicate a persistent error. ")
                                                    TEXT("To diagnose, try to ")
                                                    TEXT("register them by hand or contact ")
                                                    TEXT("the owners of these files ")
                                                    TEXT("to determine why they are timing out. ")
                                                    TEXT("also try running other 64-bit executables.\n"),
#endif
                                                    FileName,
                                                    LastTimeoutFileName
                                                    );

                                            } else {
#endif
                                                DebugPrintEx(
                                                    DPFLTR_ERROR_LEVEL,
                                                    TEXT("Windows has detected that ")
                                                    TEXT("the registration of \"%s\" timed out. ")
                                                    TEXT("Prior to this, \"%s\" timed out. ")
                                                    TEXT("This may indicate a persistent error. ")
                                                    TEXT("To diagnose, try to ")
                                                    TEXT("register them by hand or contact ")
                                                    TEXT("the owners of these files ")
                                                    TEXT("to determine why they are timing out.\n"),
                                                    FileName,
                                                    LastTimeoutFileName
                                                    );
#ifdef CHILDREGISTRATION
                                            }
#endif
                                            DebugBreak();
                                    }
                                    LastTimeHadTimeout = TRUE;
                                    lstrcpyn(LastTimeoutFileName,FileName,MAX_PATH);
#endif

#ifdef CHILDREGISTRATION
                                    if (HowToGetStatus == SP_GETSTATUS_FROMSURRAGATE) {
                                        //
                                        // we have no choice but to abandon the process
                                        //
                                        pSetupCleanupWowIpcStream(&WowIpcData);

                                        //
                                        // set our handle to NULL so we don't
                                        // accidentally close it
                                        //
                                        SignifyRegistration = NULL;
                                    }
#endif

                                } else {

#ifdef PRERELEASE
                                    LastTimeHadTimeout = FALSE;
#endif

                                    switch(HowToGetStatus) {
                                        case SP_GETSTATUS_FROMDLL:
#ifdef PRERELEASE
                                            DebugTraceInfo |= 0x10000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                            GetExitCodeThread(SignifyRegistration,&d);
                                            FailureCode = RefStatus->ExtendedStatus;
                                            break;
#ifdef CHILDREGISTRATION
                                        case SP_GETSTATUS_FROMSURRAGATE:

#ifdef PRERELEASE
                                            DebugTraceInfo |= 0x20000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                            //
                                            // get the status code from the shared
                                            // memory region
                                            //
                                            MYASSERT(WowIpcData.MemoryRegion != NULL);
                                            d = ((PWOW_IPC_REGION_FROMSURRAGATE)WowIpcData.MemoryRegion)->Win32Error;
                                            FailureCode = ((PWOW_IPC_REGION_FROMSURRAGATE)WowIpcData.MemoryRegion)->FailureCode;
                                            //
                                            // reset the "it's complete" event so
                                            // we don't loop on it.
                                            //
                                            ResetEvent(WowIpcData.SignalRegistrationComplete);

                                            //
                                            // set the handle to NULL so we don't
                                            // accidentally close it
                                            //
                                            SignifyRegistration = NULL;
                                            break;
#endif
                                        case SP_GETSTATUS_FROMPROCESS:
#ifdef PRERELEASE
                                            DebugTraceInfo |= 0x40000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                            GetExitCodeProcess(SignifyRegistration,&d);
                                            FailureCode = SPREG_SUCCESS;
                                            d = NO_ERROR;

                                            break;
                                        default:
                                            MYASSERT(FALSE);
                                    }

                                }

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x80000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                if (SignifyRegistration) {
                                    CloseHandle( SignifyRegistration );
                                }
#ifdef PRERELEASE
                                DebugTraceInfo |= 0x100000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif

                            } else {
                                //
                                // the dll spawning failed.
                                // let's go onto the next one
                                //
                                d = ExtendedError;
                                FailureCode = SPREG_UNKNOWN;
                            }

#ifdef PRERELEASE
                            DebugTraceInfo |= 0x200000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            // make sure the dll, etc., didn't corrupt the heap
                            ASSERT_HEAP_IS_VALID();

                            if(d) {
                                WriteLogEntry(
                                            LogContext,
                                            SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                            MSG_LOG_REGISTRATION_FAILED,
                                            NULL,
                                            FullPath
                                            );
                                WriteLogError(
                                            LogContext,
                                            SETUP_LOG_ERROR,
                                            d
                                            );
                            }

                            if (RegistrationCallbackAware && MsgHandler) {
                                SP_REGISTER_CONTROL_STATUS ControlStatus;

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x400000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                ZeroMemory(
                                    &ControlStatus,
                                    sizeof(SP_REGISTER_CONTROL_STATUS));
                                ControlStatus.cbSize = sizeof(SP_REGISTER_CONTROL_STATUS);
                                ControlStatus.FileName = FullPath;
                                ControlStatus.Win32Error = d;
                                ControlStatus.FailureCode = FailureCode;

                                u = pSetupCallMsgHandler(
                                               LogContext,
                                               MsgHandler,
                                               IsMsgHandlerNativeCharWidth,
                                               Context,
                                               SPFILENOTIFY_ENDREGISTRATION,
                                               (UINT_PTR)&ControlStatus,
                                               Register );

#ifdef PRERELEASE
                                DebugTraceInfo |= 0x800000; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                                if (u == FILEOP_ABORT) {
                                    d = GetLastError();
                                    if (d==NO_ERROR) {
                                        d = ERROR_OPERATION_ABORTED;
                                    }
                                    WriteLogEntry(
                                                LogContext,
                                                SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                                                MSG_LOG_ENDREGISTRATION_ABORT,
                                                NULL);
                                    WriteLogError(
                                                LogContext,
                                                SETUP_LOG_ERROR,
                                                d
                                                );
                                    //
                                    // need a refcount on this cause we will free this if the
                                    // child thread has timed out (or if we never had a thread
                                    // this will just be deallocated).
                                    //
                                    Count = InterlockedDecrement(&RefStatus->RefCount);
                                    if (!Count) {
                                        MyFree(RefStatus);
                                    }

                                    MyFree(FullPathTemp);
                                    goto clean0;
                                } else {
                                    //
                                    // the callback indicated that it saw any error
                                    // which occurred and it wants to continue, so
                                    // reset the error code to "none" so that we
                                    // continue processing items in this section.
                                    //
                                    d = NO_ERROR;
                                }



                            }
                        } else {
#ifdef PRERELEASE
                            DebugTraceInfo |= 0x400; // ISSUE-JamieHun-2001/01/29 attempt to catch a strange stress break
#endif
                            pSetupFreeOleControlData(pOleControlData);
                            //
                            // set to NULL so we don't try to free it later
                            //
                            RefStatus = NULL;
                        }

                        //
                        // need a refcount on this cause we will free this if the
                        // child thread has timed out (or if we never had a thread
                        // this will just be deallocated).
                        //
                        if (RefStatus) {
                            Count = InterlockedDecrement(&RefStatus->RefCount);
                            if (!Count) {
                                MyFree(RefStatus);
                            }
                        }
                        MyFree(FullPathTemp);
                    }
#ifdef PRERELEASE
                    DebugTraceInfo = 1; // attempt to catch a strange stress break
#endif
                    d = NO_ERROR;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    MYASSERT(FALSE && "Exception taken during register/unregister");
                    d = ERROR_INVALID_DATA;
                }

            } else {
                DebugPrintEx(DPFLTR_TRACE_LEVEL,TEXT("SETUP: dll skipped, bad dirid\n"));
                WriteLogEntry(
                    LogContext,
                    SETUP_LOG_ERROR,
                    MSG_LOG_CANT_OLE_CONTROL_DIRID,
                    NULL,
                    FileName,
                    DirId
                    );

                d = ERROR_INVALID_DATA;

            }

        } while(SetupFindNextLine(&InfLine,&InfLine)  && d == NO_ERROR);
    } else {

        WriteLogEntry(
            LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_NOSECTION_MIN,
            NULL,
            Section,
            ((PLOADED_INF) Inf)->OriginalInfName
            );

        d = ERROR_INVALID_DATA;
    }

    //
    // cleanup
    //

clean0:
#ifdef CHILDREGISTRATION
    pSetupCleanupWowIpcStream(&WowIpcData);
#endif

    if(log_slot) {
        ReleaseLogInfoSlot(LogContext,log_slot);
    }
    if(LogContext) {
        DeleteLogContext(LogContext); // this is ref-counted
    }
    if(pLoadedInf) {
        UnlockInf(pLoadedInf);
    }

    //
    // put back the current working directory
    //
    if (pwd && pwd[0]) {
        SetCurrentDirectory(pwd);
    }

    return d;

}


DWORD
pSetupInstallRegisterUnregisterDlls(
    IN HINF   Inf,
    IN PCTSTR SectionName,
    IN BOOL   Register,
    IN HWND   hWndParent,
    IN PSP_FILE_CALLBACK Callback,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth,
    IN BOOL   RegistrationCallbackAware
    )

/*++

Routine Description:

    Locate the RegisterDlls= lines in an install section
    and process each section listed therein.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    Register - TRUE if register, FALSE if unregister

    hWndParent - parent window handle

    Callback - pointer to queue callback routine

    Context - context pointer for callback routine

    IsMsgHandlerNativeCharWidth - indicates if message pieces need translation

    RegistrationCallbackAware - indicates if callback routine wants to receive
                                registration callback notifications

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d = NO_ERROR;
    INFCONTEXT LineContext;
    DWORD Field, FieldCount;
    PCTSTR SectionSpec;

    //
    // Find the RegisterDlls line in the given install section.
    // If not present then we're done with this operation.
    //


    if(!SetupFindFirstLine(  Inf
                           , SectionName
                           , Register? pszRegSvr : pszUnRegSvr
                           , &LineContext )) {

        DWORD rc = GetLastError();
        if((rc != NO_ERROR) && (rc != ERROR_SECTION_NOT_FOUND) && (rc != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionName,MSG_LOG_INSTALLSECT_ERROR,rc,NULL);
        }
        SetLastError(NO_ERROR); // for compatibility with older versions of SetupAPI
        return NO_ERROR;
    }

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; d == NO_ERROR && (Field<=FieldCount); Field++) {

            if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                if(SetupGetLineCount(Inf,SectionSpec) > 0) {
                    //
                    // The section exists and is not empty.
                    // So process it.
                    //
                    d = pSetupProcessRegSvrSection(
                                        Inf,
                                        SectionSpec,
                                        Register,
                                        hWndParent,
                                        Callback,
                                        Context,
                                        IsMsgHandlerNativeCharWidth,
                                        RegistrationCallbackAware);
                    if(d!=NO_ERROR) {
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionSpec,MSG_LOG_SECT_ERROR,d,Register? pszRegSvr : pszUnRegSvr);
                    }
                }

            }
        }
    } while(SetupFindNextMatchLine(  &LineContext
                                   , Register? pszRegSvr : pszUnRegSvr
                                   , &LineContext));

    SetLastError(d);

    return d;

}

#ifndef ANSI_SETUPAPI

BOOL
pSetupProcessProfileSection(
    IN HINF   Inf,
    IN PCTSTR Section
    )
/*

Routine Description :

    process all the directives specified in this single ProfileItems section . This section can have the following
    directives in the listed format

    [SectionX]
    Name = <Name> (as appears in Start Menu), <Flags>, <CSIDL>
    SubDir = <subdir>
    CmdLine = <dirid>,<subdirectory>,<filename>, <args>
    IconPath = <dirid>,<subdirectory>,<filename>
    IconIndex = <index>
    WorkingDir = <dirid>,<subdirectory>
    HotKey = <hotkey>
    InfoTip = <infotip>
    DisplayResource = <dllname>,<resid>

     Comments on the various parameters -

        By default all links are created under Start Menu\Programs. This can be over-ridden by using CSIDLs.

        Flags  - can be specified by ORing the necessary flags - OPTIONAL
                     FLG_PROFITEM_CURRENTUSER ( 0x00000001 ) - Operates on item in the current user's profile (Default is All User)
                     FLG_PROFITEM_DELETE      ( 0x00000002 ) - Operation is to delete the item (Default is to add)
                     FLG_PROFITEM_GROUP       ( 0x00000004 ) - Operation is on a group (Default is on a item)
                     FLG_PROFITEM_CSIDL       ( 0x00000008 ) - Don't default to Start Menu and use CSIDL specified - default CSIDL is 0

        CSIDL  - Used with FLG_PROFITEM_CSIDL and should be in decimal. OPTIONAL
                 Note: Will not work with FLG_PROFITEM_CURRENTUSER or FLG_PROFITEM_GROUP.
        subdir - Specify a subdirectory relative to the CSIDL group (default CSIDL group is Programs/StartMenu. OPTIONAL
        CmdLine - Required in the case of add operations but not for delete.
            dirid  - supplies the base directory id of the file. (Required if CmdLine exists)
            subdir - if specified, is the sub directory off the base directory where the file resides (Optional)
            filename - specifies the name of the binary that we are creating a link for. (Required if CmdLine exists)
            args     - If we need to specif a binary that contains spaces in its name then this can be used for args. (Optional)
        IconPath - Optional. If not specified will default to NULL
            dirid  - supplies the base directory id of the file that contains the icon. (Required if IconPath exists)
            subdir - if specified, is the sub directory off the base directory where the file resides (Optional)
            filename - specifies the name of the binary that contains the icon. (Required if IconPath exists)
        IconIndex - Optional, defaults to 0
            index - index of the icon in the executable.  Default is 0. (Optional)
        WorkingDir - Optional
            dirid  - supplies the base directory id of the working directory as needed by the shell. (Required if WorkingDir exists)
            subdir - if specified, is the sub directory off the base working directory (Optional)
        HotKey - Optional
            hotkey - hotkey code (optional)
        InfoTip - Optional
            infotip - String that contains description of the link
        DisplayResource - Optional
            filename - File, DLL/Executable where resource id resides
            resid - Identifier of resource, integer

*/
{
    PCTSTR Keys[9] = { TEXT("Name"), TEXT("SubDir"), TEXT("CmdLine"), TEXT("IconPath"), \
                        TEXT("IconIndex"), TEXT("WorkingDir"),TEXT("HotKey"), \
                        TEXT("InfoTip"), TEXT("DisplayResource") };
    INFCONTEXT InfLine;
    UINT Flags, Opt_csidl, i, j, Apply_csidl;
    TCHAR CmdLine[MAX_PATH+2], IconPath[MAX_PATH+2];
    PCTSTR Name = NULL, SubDir=NULL;
    PCTSTR WorkingDir=NULL, InfoTip=NULL, Temp_Args=NULL, BadInf;
    PCTSTR Temp_DirId = NULL, Temp_Subdir = NULL, Temp_Filename = NULL, FullPathTemp = NULL;
    UINT IconIndex = 0, t=0;
    DWORD HotKey = 0;
    DWORD DisplayResource = 0;
    BOOL ret, space;
    DWORD LineCount,Err;
    PTSTR ptr;
    PCTSTR OldFileName;
    PCTSTR DisplayResourceFile = NULL;
    PLOADED_INF pLoadedInf = NULL;

    CmdLine[0]=0;
    IconPath[0]=0;

    try {
        if(Inf == NULL || Inf == (HINF)INVALID_HANDLE_VALUE || !LockInf((PLOADED_INF)Inf)) {
            ret = FALSE;
            leave;
        }
        ret = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = FALSE;
    }
    if (!ret) {
        Err = ERROR_INVALID_PARAMETER;
        MYASSERT(Err == NO_ERROR);
        goto clean0;
    }
    pLoadedInf = (PLOADED_INF)Inf; // Inf is locked

    //
    // Get the correct name of the inf to use while logging
    //
    BadInf = pLoadedInf->OriginalInfName ? pLoadedInf->OriginalInfName :
               pLoadedInf->VersionBlock.Filename;

    if(SetupFindFirstLine(Inf,Section,NULL,&InfLine)) {

        LineCount = SetupGetLineCount(Inf, Section);
        //
        // caller should make sure we have a non-empty section
        //
        MYASSERT( LineCount > 0 );

        ret = FALSE;

        for( i=0; LineCount && (i < 9 ); i++ ){

            if( !SetupFindFirstLine( Inf, Section, Keys[i], &InfLine ) )
                continue;

            switch( i ){
                                                                 // Name
                case 0:
                    Name = pSetupGetField( &InfLine, 1 );
                    Flags = 0x0;
                    SetupGetIntField( &InfLine, 2, &Flags );
                    Opt_csidl = 0x0;
                    if(Flags & FLG_PROFITEM_CSIDL)
                        SetupGetIntField( &InfLine, 3, &Opt_csidl );
                    break;

                case 1:                                         // SubDir
                    SubDir = pSetupGetField( &InfLine, 1 );
                    break;
                                                                // CmdLine
                case 2:
                    Temp_DirId = pSetupGetField( &InfLine, 1 );
                    Temp_Subdir = pSetupGetField( &InfLine, 2 );
                    Temp_Filename = pSetupGetField( &InfLine, 3 );
                    OldFileName = NULL;
                    Temp_Args = pSetupGetField( &InfLine, 4 );    //Not published - useful in the case of spaces in filename itself
                    if( Temp_DirId && Temp_Filename ){
                        if( Temp_Subdir && (*Temp_Subdir == 0))
                            Temp_Subdir = NULL;
                    }
                    else
                        break;

                    // Do the "quote or not to quote" to make shell happy in the different cases

                    FullPathTemp = pGetPathFromDirId(Temp_DirId,Temp_Subdir,pLoadedInf);


                    if( FullPathTemp && Temp_Filename ){
                        space = FALSE;
                        if(_tcschr(FullPathTemp, TEXT(' ')) || Temp_Args )    //Check for space in path or if args specified as seperate parameter
                           space = TRUE;

                        if( space ){
                            CmdLine[0] = TEXT('\"');
                            t = 1;
                        }
                        else
                            t = 0;
                        lstrcpyn(CmdLine+t, FullPathTemp, MAX_PATH);
                        if( space ){
                            if( Temp_Args )
                                ptr = (PTSTR)Temp_Args;
                            else{
                                ptr = NULL;
                                //
                                // Temp_Filename is a constant string.  we
                                // make a copy of it so we can manipulate it
                                //
                                //
                                OldFileName = Temp_Filename;
                                Temp_Filename = DuplicateString( OldFileName );
                                if( ptr = _tcschr(Temp_Filename, TEXT(' ')) ){   //in case of space in path look for the filename part (not argument)
                                    *ptr = 0;
                                    ptr++;
                                }
                            }
                        }
                        pSetupConcatenatePaths(CmdLine,Temp_Filename,MAX_PATH,NULL);

                        if( space ){
                            lstrcat( CmdLine, TEXT("\""));      //put the last quote
                            if( ptr ){                          //If there is an argument concatenate it
                                lstrcat( CmdLine, TEXT(" ") );
                                lstrcat( CmdLine, ptr );
                            }

                        }
                        MyFree( FullPathTemp );
                        if (OldFileName) {
                            MyFree( Temp_Filename );
                            Temp_Filename = OldFileName;
                        }
                    }
                    break;
                                                               //Icon Path
                case 3:
                    Temp_DirId = pSetupGetField( &InfLine, 1 );
                    Temp_Subdir = pSetupGetField( &InfLine, 2 );
                    Temp_Filename = pSetupGetField( &InfLine, 3 );
                    if( Temp_DirId && Temp_Filename ){
                        if( Temp_Subdir && (*Temp_Subdir == 0))
                            Temp_Subdir = NULL;
                    }
                    else
                        break;
                    FullPathTemp = pGetPathFromDirId(Temp_DirId,Temp_Subdir,pLoadedInf);
                    if( FullPathTemp && Temp_Filename ){
                        lstrcpyn(IconPath, FullPathTemp, MAX_PATH);
                        pSetupConcatenatePaths(IconPath,Temp_Filename,MAX_PATH,NULL);
                        MyFree( FullPathTemp );
                    }
                    break;


                case 4:                                        //Icon Index
                    SetupGetIntField( &InfLine, 1, &IconIndex );
                    break;

                case 5:                                        // Working Dir
                    Temp_DirId = pSetupGetField( &InfLine, 1 );
                    Temp_Subdir = pSetupGetField( &InfLine, 2 );
                    if( Temp_DirId ){
                        if( Temp_Subdir && (*Temp_Subdir == 0))
                            Temp_Subdir = NULL ;
                    }
                    else
                        break;
                    WorkingDir = pGetPathFromDirId(Temp_DirId,Temp_Subdir,pLoadedInf);
                    break;

                case 6:                                       // Hot Key
                    HotKey = 0;
                    SetupGetIntField( &InfLine, 1, &HotKey );
                    break;

                case 7:                                      // Info Tip
                    InfoTip = pSetupGetField( &InfLine, 1 );
                    break;

                case 8:                                     // Display Resource
                    DisplayResourceFile = pSetupGetField( &InfLine, 1);
                    DisplayResource = 0;
                    SetupGetIntField( &InfLine, 2, &DisplayResource );
                    break;

            }//switch

        }//for


        if( Name && (*Name != 0) ){

            if( Flags & FLG_PROFITEM_GROUP ){

                if( Flags & FLG_PROFITEM_DELETE ){
                    ret = DeleteGroup( Name, ((Flags & FLG_PROFITEM_CURRENTUSER) ? FALSE : TRUE) );
                    if( !ret && ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
                                  (GetLastError() == ERROR_PATH_NOT_FOUND) )){
                        ret = TRUE;
                        SetLastError( NO_ERROR );
                    }
                }else {
                    ret = CreateGroupEx( Name,
                                         ((Flags & FLG_PROFITEM_CURRENTUSER) ? FALSE : TRUE),
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                                         (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0);
                }
            }
            else{

                if( Flags & FLG_PROFITEM_CSIDL )
                    Apply_csidl = Opt_csidl;
                else
                    Apply_csidl = (Flags & FLG_PROFITEM_CURRENTUSER) ? CSIDL_PROGRAMS : CSIDL_COMMON_PROGRAMS;



                if( SubDir && (*SubDir == 0 ))
                    SubDir = NULL;

                if( Flags & FLG_PROFITEM_DELETE ){

                    ret = DeleteLinkFile(
                            Apply_csidl,
                            SubDir,
                            Name,
                            TRUE
                            );

                    if( !ret && ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
                                  (GetLastError() == ERROR_PATH_NOT_FOUND) )){
                        ret = TRUE;
                        SetLastError( NO_ERROR );
                    }


                }
                else{

                     if( CmdLine && (*CmdLine != 0)){

                         ret = CreateLinkFileEx(
                                    Apply_csidl,
                                    SubDir,
                                    Name,
                                    CmdLine,
                                    IconPath,
                                    IconIndex,
                                    WorkingDir,
                                    (WORD)HotKey,
                                    SW_SHOWNORMAL,
                                    InfoTip,
                                    (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResourceFile : NULL,
                                    (DisplayResourceFile && DisplayResourceFile[0]) ? DisplayResource : 0
                                    );
                     }else{
                        WriteLogEntry(
                            ((PLOADED_INF) Inf)->LogContext,
                            SETUP_LOG_ERROR,
                            MSG_LOG_PROFILE_BAD_CMDLINE,
                            NULL,
                            Section,
                            BadInf
                            );


                        ret = FALSE;
                        SetLastError(ERROR_INVALID_DATA);


                     }
                }





            }

            if( !ret ){

                Err = GetLastError();
                WriteLogEntry(
                    ((PLOADED_INF) Inf)->LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_PROFILE_OPERATION_ERROR,
                    NULL,
                    Section,
                    BadInf
                    );
                WriteLogError(
                    ((PLOADED_INF) Inf)->LogContext,
                    SETUP_LOG_ERROR,
                    Err);


            }



        }else{
            WriteLogEntry(
                ((PLOADED_INF) Inf)->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_PROFILE_BAD_NAME,
                NULL,
                Section,
                BadInf
                );


            ret = FALSE;
            Err = ERROR_INVALID_DATA;
        }


    }else{
        ret = FALSE;
        Err = GetLastError();
        WriteLogEntry(
            ((PLOADED_INF) Inf)->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_PROFILE_LINE_ERROR,
            NULL,
            Section,
            BadInf
            );


    }

clean0:
    if( WorkingDir ) {
        MyFree( WorkingDir );
    }

    if(pLoadedInf) {
        UnlockInf(pLoadedInf);
    }

    if(ret) {
        SetLastError( NO_ERROR );
    } else {
        SetLastError( Err );
    }

    return ret;
}


DWORD
pSetupInstallProfileItems(
    IN HINF   Inf,
    IN PCTSTR SectionName
    )

/*++

Routine Description:

    Locate the ProfileItems= lines in an install section
    and process each section listed therein. Each section specified here
    will point to a section that lists the needed directives for a single
    profile item.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.


Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD d = NO_ERROR;
    INFCONTEXT LineContext;
    DWORD Field, FieldCount;
    PCTSTR SectionSpec;

    //
    // Find the ProfileItems line in the given install section.
    // If not present then we're done with this operation.
    //


    if(!SetupFindFirstLine(  Inf,
                             SectionName,
                             pszProfileItems,
                             &LineContext )) {
        DWORD rc = GetLastError();
        if((rc != NO_ERROR) && (rc != ERROR_SECTION_NOT_FOUND) && (rc != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionName,MSG_LOG_INSTALLSECT_ERROR,rc,NULL);
        }
        SetLastError(NO_ERROR); // for compatibility with older versions of SetupAPI
        return NO_ERROR;
    }

    do {
        //
        // Each value on the line in the given install section
        // is the name of another section.
        //
        FieldCount = SetupGetFieldCount(&LineContext);
        for(Field=1; d == NO_ERROR && (Field<=FieldCount); Field++) {

            if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                if(SetupGetLineCount(Inf,SectionSpec) > 0) {
                    //
                    // The section exists and is not empty.
                    // So process it.
                    //
                    if(!pSetupProcessProfileSection(Inf,SectionSpec )) {
                        d = GetLastError();
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionSpec,MSG_LOG_SECT_ERROR,d,pszProfileItems);
                    }
                }

            }
        }
    } while(SetupFindNextMatchLine(  &LineContext,
                                     pszProfileItems,
                                     &LineContext));

    SetLastError( d );

    return d;

}
#endif

DWORD
pSetupInstallFiles(
    IN HINF              Inf,
    IN HINF              LayoutInf,         OPTIONAL
    IN PCTSTR            SectionName,
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN PSP_FILE_CALLBACK MsgHandler,        OPTIONAL
    IN PVOID             Context,           OPTIONAL
    IN UINT              CopyStyle,
    IN HWND              Owner,             OPTIONAL
    IN HSPFILEQ          UserFileQ,         OPTIONAL
    IN BOOL              IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Look for file operation lines in an install section and process them.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    LayoutInf - optionally, supplies a separate INF handle containing source
        media information about the files to be installed.  If this value is
        NULL or INVALID_HANDLE_VALUE, then it is assumed that this information
        is in the INF(s) whose handle was passed to us in the Inf parameter.

    SectionName - supplies name of install section.

    MsgHandler - supplies a callback to be used when the file queue is
        committed. Not used if UserFileQ is specified.

    Context - supplies context for callback function. Not used if UserFileQ
        is specified.

    Owner - supplies the window handle of a window to be the parent/owner
        of any dialogs that are created. Not used if UserFileQ is specified.

    UserFileQ - if specified, then this routine neither created nor commits the
        file queue. File operations are queued on this queue and it is up to the
        caller to flush the queue when it so desired. If this parameter is not
        specified then this routine creates a file queue and commits it
        before returning.

    IsMsgHandlerNativeCharWidth - indicates whether any message handler callback
        expects native char width args (or ansi ones, in the unicode build
        of this dll).

Return Value:

    Win32 error code indicating outcome.

--*/

{
    DWORD Field;
    unsigned i;
    PCTSTR Operations[3] = { TEXT("Copyfiles"),TEXT("Renfiles"),TEXT("Delfiles") };
    BOOL b;
    INFCONTEXT LineContext;
    DWORD FieldCount;
    PCTSTR SectionSpec;
    INFCONTEXT SectionLineContext;
    HSPFILEQ FileQueue;
    DWORD rc = NO_ERROR;
    BOOL FreeSourceRoot;
    DWORD InfSourceMediaType;

    //
    // see if install section exists for diagnostics (this will also check Inf)
    //
    if (!SetupFindFirstLine(Inf,SectionName,NULL,&LineContext)) {
        DWORD x = GetLastError();
        if((x != NO_ERROR) && (x != ERROR_SECTION_NOT_FOUND) && (x != ERROR_LINE_NOT_FOUND)) {
            pSetupLogSectionError(Inf,NULL,NULL,UserFileQ,SectionName,MSG_LOG_INSTALLSECT_ERROR,x,NULL);
            return x;
        }
    }

    if(!LayoutInf || (LayoutInf == INVALID_HANDLE_VALUE)) {
        LayoutInf = Inf;
    }

    //
    // Create a file queue.
    //
    if(UserFileQ) {
        FileQueue = UserFileQ;
    } else {
        FileQueue = SetupOpenFileQueue();
        if(FileQueue == INVALID_HANDLE_VALUE) {
            return(GetLastError());
        }
    }
    ShareLogContext(&((PLOADED_INF)LayoutInf)->LogContext,&((PSP_FILE_QUEUE)FileQueue)->LogContext);

    //
    // The following code is broken because it implies one default source root path per INF
    // file.  While this is correct for an OEM install, it's broken for os based installs
    //
    FreeSourceRoot = FALSE;
    if(!SourceRootPath) {
        if(SourceRootPath = pSetupGetDefaultSourcePath(Inf, 0, &InfSourceMediaType)) {
            //
            // For now, if the INF is from the internet, just use
            // the default OEM source path (A:\) instead.
            //
            if(InfSourceMediaType == SPOST_URL) {
                MyFree(SourceRootPath);
            //
            // Fall back to default OEM source path.
            //
            SourceRootPath = pszOemInfDefaultPath;
            } else {
                FreeSourceRoot = TRUE;
            }
        } else {
            //
            // lock this!
            //
            if (LockInf((PLOADED_INF)Inf)) {

                if (pSetupInfIsFromOemLocation(((PLOADED_INF)Inf)->VersionBlock.Filename, TRUE)) {
                    SourceRootPath = DuplicateString(((PLOADED_INF)Inf)->VersionBlock.Filename);
                    if (SourceRootPath) {
                        PTSTR p;
                        p = _tcsrchr( SourceRootPath, TEXT('\\') );
                        if (p) *p = TEXT('\0');
                        FreeSourceRoot = TRUE;
                    }
                }

                UnlockInf((PLOADED_INF)Inf);
            }

        }
    }

    b = TRUE;
    for(i=0; b && (i<3); i++) {

        //
        // Find the relevent line in the given install section.
        // If not present then we're done with this operation.
        //
        if(!SetupFindFirstLine(Inf,SectionName,Operations[i],&LineContext)) {
            continue;
        }

        do {
            //
            // Each value on the line in the given install section
            // is the name of another section.
            //
            FieldCount = SetupGetFieldCount(&LineContext);
            for(Field=1; b && (Field<=FieldCount); Field++) {

                if(SectionSpec = pSetupGetField(&LineContext,Field)) {

                    //
                    // Handle single-file copy specially.
                    //
                    if((i == 0) && (*SectionSpec == TEXT('@'))) {

                        b = SetupQueueDefaultCopy(
                                FileQueue,
                                LayoutInf,
                                SourceRootPath,
                                SectionSpec + 1,
                                SectionSpec + 1,
                                CopyStyle
                                );
                        if (!b) {
                            rc = GetLastError();
                            pSetupLogSectionError(Inf,NULL,NULL,FileQueue,SectionSpec+1,MSG_LOG_COPYSECT_ERROR,rc,Operations[i]);
                        }

                    } else if(SetupGetLineCount(Inf,SectionSpec) > 0) {
                        //
                        // The section exists and is not empty.
                        // Add it to the copy/delete/rename queue.
                        //
                        switch(i) {
                        case 0:
                            b = SetupQueueCopySection(
                                    FileQueue,
                                    SourceRootPath,
                                    LayoutInf,
                                    Inf,
                                    SectionSpec,
                                    CopyStyle
                                    );
                            break;

                        case 1:
                            b = SetupQueueRenameSection(FileQueue,Inf,NULL,SectionSpec);
                            break;

                        case 2:
                            b = SetupQueueDeleteSection(FileQueue,Inf,NULL,SectionSpec);
                            break;
                        }
                        if (!b) {
                            rc = GetLastError();
                            pSetupLogSectionError(Inf,NULL,NULL,FileQueue,SectionSpec,MSG_LOG_SECT_ERROR,rc,Operations[i]);
                        }
                    }
                }
            }
        } while(SetupFindNextMatchLine(&LineContext,Operations[i],&LineContext));
    }

    if(b && (FileQueue != UserFileQ)) {
        //
        // Perform the file operations.
        //
        b = _SetupCommitFileQueue(
                Owner,
                FileQueue,
                MsgHandler,
                Context,
                IsMsgHandlerNativeCharWidth
                );
        rc = b ? NO_ERROR : GetLastError();
    }

    if(FileQueue != UserFileQ) {
        SetupCloseFileQueue(FileQueue);
    }

    if(FreeSourceRoot) {
        MyFree(SourceRootPath);
    }

    return(rc);
}


BOOL
_SetupInstallFromInfSection(
    IN HWND             Owner,              OPTIONAL
    IN HINF             InfHandle,
    IN PCTSTR           SectionName,
    IN UINT             Flags,
    IN HKEY             RelativeKeyRoot,    OPTIONAL
    IN PCTSTR           SourceRootPath,     OPTIONAL
    IN UINT             CopyFlags,
    IN PVOID            MsgHandler,
    IN PVOID            Context,            OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN BOOL             IsMsgHandlerNativeCharWidth,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem;
    DWORD d = NO_ERROR;
    BOOL CloseRelativeKeyRoot;
    REGMOD_CONTEXT DefRegContext;


    //
    // Validate the flags passed in.
    //
    if(Flags & ~(SPINST_ALL | SPINST_SINGLESECTION |
                 SPINST_LOGCONFIG_IS_FORCED | SPINST_LOGCONFIGS_ARE_OVERRIDES |
                 SPINST_REGISTERCALLBACKAWARE)) {
        d = ERROR_INVALID_FLAGS;
        goto clean1;
    }


    //
    // If the caller wants us to run a specific section, then they'd better
    // have told us what kind of section it is (i.e., one and only one of
    // the install action types must be specified).
    //
    // Presently, only LogConfig sections are allowed, since the other
    // flags flags encompass multiple actions (e.g., AddReg _and_ DelReg).
    //
    if((Flags & SPINST_SINGLESECTION) && ((Flags & SPINST_ALL) != SPINST_LOGCONFIG)) {
        d = ERROR_INVALID_FLAGS;
        goto clean1;
    }


    //
    // You can (optionally) specify SPINST_LOGCONFIG_IS_FORCED or SPINST_LOGCONFIGS_ARE_OVERRIDES,
    // but not both.
    //
    if((Flags & (SPINST_LOGCONFIG_IS_FORCED | SPINST_LOGCONFIGS_ARE_OVERRIDES)) ==
       (SPINST_LOGCONFIG_IS_FORCED | SPINST_LOGCONFIGS_ARE_OVERRIDES)) {

        d = ERROR_INVALID_FLAGS;
        goto clean1;
    }


    //
    // We only want to acquire the HDEVINFO lock if we're supposed to do some install
    // actions against a device instance.
    //
    if((Flags & (SPINST_REGISTRY | SPINST_BITREG | SPINST_INI2REG | SPINST_LOGCONFIG)) &&
       DeviceInfoSet && (DeviceInfoSet != INVALID_HANDLE_VALUE) && DeviceInfoData) {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            d = ERROR_INVALID_HANDLE;
            goto clean1;
        }

    } else {
        //This is ok in the remote case, since to call pSetupInstallLogConfig
        //We won't really get here (we'll take the if case)
        pDeviceInfoSet = NULL;
    }


    d = NO_ERROR;
    DevInfoElem = NULL;
    CloseRelativeKeyRoot = FALSE;

    try {
        //
        // Get a pointer to the element for the specified device
        // instance.
        //

        if(pDeviceInfoSet) {

            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                d = ERROR_INVALID_PARAMETER;
                goto RegModsDone;
            }
        }

        if((Flags & (SPINST_REGISTRY | SPINST_BITREG | SPINST_INI2REG)) && DevInfoElem) {
            //
            // If the caller supplied a device information set and element, then this is
            // a device installation, and the registry modifications should be made to the
            // device instance's hardware registry key.
            //
            if((RelativeKeyRoot = SetupDiCreateDevRegKey(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         DICS_FLAG_GLOBAL,
                                                         0,
                                                         DIREG_DEV,
                                                         NULL,
                                                         NULL)) == INVALID_HANDLE_VALUE) {
                d = GetLastError();
                goto RegModsDone;
            }

            CloseRelativeKeyRoot = TRUE;
        }

        if((Flags & SPINST_LOGCONFIG) && DevInfoElem) {

            d = pSetupInstallLogConfig(InfHandle,
                                       SectionName,
                                       DevInfoElem->DevInst,
                                       Flags,
                                       pDeviceInfoSet->hMachine);
            if(d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_INIFILES) {
            d = pSetupInstallUpdateIniFiles(InfHandle,SectionName);
            if(d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & (SPINST_REGISTRY | SPINST_BITREG)) {

            if(!RegContext) {

                ZeroMemory(&DefRegContext, sizeof(DefRegContext));

                if(DevInfoElem) {
                    DefRegContext.Flags = INF_PFLAG_DEVPROP;
                    DefRegContext.DevInst = DevInfoElem->DevInst;
                }
                RegContext = &DefRegContext;
            }

            //
            // We check for the INF_PFLAG_HKR flag in case the caller supplied
            // us with a context that included a UserRootKey they wanted us to
            // use (i.e., instead of the RelativeKeyRoot)...
            //
            if(!(RegContext->Flags & INF_PFLAG_HKR)) {
                RegContext->UserRootKey = RelativeKeyRoot;
            }

            if(Flags & SPINST_REGISTRY) {
                d = pSetupInstallRegistry(InfHandle,
                                          SectionName,
                                          RegContext
                                         );
            }

            if((d == NO_ERROR) && (Flags & SPINST_BITREG)) {
                d = pSetupInstallBitReg(InfHandle,
                                        SectionName,
                                        RegContext
                                       );
            }

            if(d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_INI2REG) {
            d = pSetupInstallIni2Reg(InfHandle,SectionName,RelativeKeyRoot);
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_REGSVR) {
            d = pSetupInstallRegisterUnregisterDlls(
                                        InfHandle,
                                        SectionName,
                                        TRUE,
                                        Owner,
                                        MsgHandler,
                                        Context,
                                        IsMsgHandlerNativeCharWidth,
                                        (Flags & SPINST_REGISTERCALLBACKAWARE) != 0 );
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

        if(Flags & SPINST_UNREGSVR) {
            d = pSetupInstallRegisterUnregisterDlls(
                                        InfHandle,
                                        SectionName,
                                        FALSE,
                                        Owner,
                                        MsgHandler,
                                        Context,
                                        IsMsgHandlerNativeCharWidth,
                                        (Flags & SPINST_REGISTERCALLBACKAWARE) != 0 );
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

#ifndef ANSI_SETUPAPI

        if(Flags & SPINST_PROFILEITEMS) {
            d = pSetupInstallProfileItems(InfHandle,SectionName);
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }
#endif

        if(Flags & SPINST_COPYINF) {
            d = pSetupCopyRelatedInfs(InfHandle,
                                      NULL,
                                      SectionName,
                                      SPOST_PATH,
                                      NULL);
            if (d != NO_ERROR) {
                goto RegModsDone;
            }
        }

RegModsDone:

        ;       // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
        //
        // Access the following variable, so that the compiler will respect statement
        // ordering w.r.t. its assignment.
        //
        CloseRelativeKeyRoot = CloseRelativeKeyRoot;
    }


    if(CloseRelativeKeyRoot) {
        RegCloseKey(RelativeKeyRoot);
    }

    if(d == NO_ERROR) {

        if(Flags & SPINST_FILES) {

            d = pSetupInstallFiles(
                    InfHandle,
                    NULL,
                    SectionName,
                    SourceRootPath,
                    MsgHandler,
                    Context,
                    CopyFlags,
                    Owner,
                    NULL,
                    IsMsgHandlerNativeCharWidth
                    );
        }
    }

clean1:

    pSetupLogSectionError(InfHandle,DeviceInfoSet,DeviceInfoData,NULL,SectionName,MSG_LOG_INSTALLSECT_ERROR,d,NULL);

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(d);
    return(d==NO_ERROR);
}

DWORD
pSetupLogSection(
    IN DWORD            SetupLogLevel,
    IN DWORD            DriverLogLevel,
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
)
/*++

Routine Description:

    Log error with section context
    error will be logged at SETUP_LOG_ERROR or DRIVER_LOG_ERROR depending if DeviceInfoSet/Data given
    error will contain inf name & section name used (%2 & %1 respectively)

Arguments:

    SetupLogLevel - log level apropriate for regular setup related log

    DriverLogLevel - log level apropriate for driver related log

    InfHandle - supplies inf handle for inf containing the section indicated
        by SectionName.

    DeviceInfoSet, DeviceInfoData - supplies driver install context

    SectionName - supplies name of install section.

    Queue - supplies file queue

    MsgID - supplies ID of message string to display

    Err - supplies error

    KeyName - passed as 3rd parameter

Return Value:

    Err.

--*/

{
    DWORD d = NO_ERROR;
    BOOL inf_locked = FALSE;
    DWORD level = SetupLogLevel;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    PCTSTR szInfName = NULL;

    if (Err == NO_ERROR) {
        return Err;
    }

    //
    // determine LogContext/Level
    //
    try {

        //
        // first attempt to get the context from DeviceInfoSet/DeviceInfoData
        //
        if (DeviceInfoSet != NULL && DeviceInfoSet != INVALID_HANDLE_VALUE) {
            if((pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))!=NULL) {
                level = DriverLogLevel;
                LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;
                if (DeviceInfoData) {
                    if((DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                                 DeviceInfoData,
                                                                 NULL))!=NULL) {
                        LogContext = DevInfoElem->InstallParamBlock.LogContext;
                    }
                }
            }
        }
        //
        // if that fails, see if we can get it from a file queue
        //
        if(LogContext == NULL && Queue != NULL && Queue != INVALID_HANDLE_VALUE && Queue->Signature == SP_FILE_QUEUE_SIG) {
            LogContext = Queue->LogContext;
        }

        //
        // if no InfHandle was provided, we're done
        //
        if(InfHandle == NULL || InfHandle == INVALID_HANDLE_VALUE || !LockInf((PLOADED_INF)InfHandle)) {
            leave;
        }
        inf_locked = TRUE;
        //
        // if we still don't have logging context, use the inf's
        //
        if (LogContext == NULL) {
            LogContext = ((PLOADED_INF)InfHandle)->LogContext;
        }
        //
        // ideally we want the inf file name
        //
        szInfName = ((PLOADED_INF)InfHandle)->VersionBlock.Filename;

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if (LogContext) {
        //
        // indicate install failed, display error
        //
        WriteLogEntry(
            LogContext,
            level | SETUP_LOG_BUFFER,
            MsgID,
            NULL,
            SectionName?SectionName:TEXT("-"),
            szInfName?szInfName:TEXT("-"),
            KeyName
            );
        WriteLogError(
            LogContext,
            level,
            Err
            );
    }
    if (inf_locked) {
        UnlockInf((PLOADED_INF)InfHandle);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return Err;
}

DWORD
pSetupLogSectionError(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
)
/*++

Routine Description:

    See pSetupLogSection
    Log at ERROR level

Arguments:

    See pSetupLogSection

Return Value:

    Err.

--*/
{
    return pSetupLogSection(SETUP_LOG_ERROR,DRIVER_LOG_ERROR,
                            InfHandle,DeviceInfoSet,DeviceInfoData,
                            Queue,SectionName,MsgID,Err,KeyName);
}


DWORD
pSetupLogSectionWarning(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
)
/*++

Routine Description:

    See pSetupLogSection
    Log at ERROR level

Arguments:

    See pSetupLogSection

Return Value:

    Err.

--*/
{
    return pSetupLogSection(SETUP_LOG_WARNING,DRIVER_LOG_WARNING,
                            InfHandle,DeviceInfoSet,DeviceInfoData,
                            Queue,SectionName,MsgID,Err,KeyName);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFromInfSectionA(
    IN HWND                Owner,             OPTIONAL
    IN HINF                InfHandle,
    IN PCSTR               SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCSTR               SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_A MsgHandler,
    IN PVOID               Context,           OPTIONAL
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    )
{
    PCWSTR sectionName;
    PCWSTR sourceRootPath;
    BOOL b;
    DWORD d;

    sectionName = NULL;
    sourceRootPath = NULL;
    d = NO_ERROR;

    if(SectionName) {
        d = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    }
    if((d == NO_ERROR) && SourceRootPath) {
        d = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourceRootPath);
    }

    if(d == NO_ERROR) {

        b = _SetupInstallFromInfSection(
                Owner,
                InfHandle,
                sectionName,
                Flags,
                RelativeKeyRoot,
                sourceRootPath,
                CopyFlags,
                MsgHandler,
                Context,
                DeviceInfoSet,
                DeviceInfoData,
                FALSE,
                NULL
                );

        d = GetLastError();
    } else {
        b = FALSE;
    }

    if(sectionName) {
        MyFree(sectionName);
    }
    if(sourceRootPath) {
        MyFree(sourceRootPath);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFromInfSectionW(
    IN HWND                Owner,             OPTIONAL
    IN HINF                InfHandle,
    IN PCWSTR              SectionName,
    IN UINT                Flags,
    IN HKEY                RelativeKeyRoot,   OPTIONAL
    IN PCWSTR              SourceRootPath,    OPTIONAL
    IN UINT                CopyFlags,
    IN PSP_FILE_CALLBACK_W MsgHandler,
    IN PVOID               Context,           OPTIONAL
    IN HDEVINFO            DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA    DeviceInfoData     OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Owner);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(RelativeKeyRoot);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(CopyFlags);
    UNREFERENCED_PARAMETER(MsgHandler);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupInstallFromInfSection(
    IN HWND              Owner,             OPTIONAL
    IN HINF              InfHandle,
    IN PCTSTR            SectionName,
    IN UINT              Flags,
    IN HKEY              RelativeKeyRoot,   OPTIONAL
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context,           OPTIONAL
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
{
    BOOL b;

    b = _SetupInstallFromInfSection(
            Owner,
            InfHandle,
            SectionName,
            Flags,
            RelativeKeyRoot,
            SourceRootPath,
            CopyFlags,
            MsgHandler,
            Context,
            DeviceInfoSet,
            DeviceInfoData,
            TRUE,
            NULL
            );

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFilesFromInfSectionA(
    IN HINF              InfHandle,
    IN HINF              LayoutInfHandle,   OPTIONAL
    IN HSPFILEQ          FileQueue,
    IN PCSTR             SectionName,
    IN PCSTR             SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags
    )
{
    PCWSTR sectionName;
    PCWSTR sourceRootPath;
    BOOL b;
    DWORD d;


    d = pSetupCaptureAndConvertAnsiArg(SectionName,&sectionName);
    if((d == NO_ERROR) && SourceRootPath) {
        d = pSetupCaptureAndConvertAnsiArg(SourceRootPath,&sourceRootPath);
    } else {
        sourceRootPath = NULL;
    }

    if(d == NO_ERROR) {

        b = SetupInstallFilesFromInfSectionW(
                InfHandle,
                LayoutInfHandle,
                FileQueue,
                sectionName,
                sourceRootPath,
                CopyFlags
                );

        d = GetLastError();

    } else {
        b = FALSE;
    }

    if(sectionName) {
        MyFree(sectionName);
    }
    if(sourceRootPath) {
        MyFree(sourceRootPath);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFilesFromInfSectionW(
    IN HINF              InfHandle,
    IN HINF              LayoutInfHandle,   OPTIONAL
    IN HSPFILEQ          FileQueue,
    IN PCWSTR            SectionName,
    IN PCWSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(LayoutInfHandle);
    UNREFERENCED_PARAMETER(FileQueue);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(SourceRootPath);
    UNREFERENCED_PARAMETER(CopyFlags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupInstallFilesFromInfSection(
    IN HINF     InfHandle,
    IN HINF     LayoutInfHandle,    OPTIONAL
    IN HSPFILEQ FileQueue,
    IN PCTSTR   SectionName,
    IN PCTSTR   SourceRootPath,     OPTIONAL
    IN UINT     CopyFlags
    )
{
    DWORD d;

    d = pSetupInstallFiles(
            InfHandle,
            LayoutInfHandle,
            SectionName,
            SourceRootPath,
            NULL,
            NULL,
            CopyFlags,
            NULL,
            FileQueue,
            TRUE        // not used by pSetupInstallFiles with this combo of args
            );

    SetLastError(d);
    return(d == NO_ERROR);
}


HKEY
pSetupInfRegSpecToKeyHandle(
    IN PCTSTR InfRegSpec,
    IN HKEY   UserRootKey,
    OUT PBOOL NeedToCloseKey
    )
{
    BOOL b;

    // make sure the whole handle is NULL as LookUpStringTable only
    // returns 32 bits

    UINT_PTR v;
    HKEY h = NULL;
    DWORD d;

    *NeedToCloseKey = FALSE;

    if (LookUpStringInTable(InfRegSpecTohKey, InfRegSpec, &v)) {
        if (v) {
            h = (HKEY)v;
        } else {
            h = UserRootKey;
        }
    } else {
        h = NULL;
    }

    return h;
}


//////////////////////////////////////////////////////////////////////////////
//
// Ini file support stuff.
//
// In Win95, the UpdateIni stuff is supported by a set of TpXXX routines.
// Those routines directly manipulate the ini file, which is bad news for us
// because inis can be mapped into the registry.
//
// Thus we want to use the profile APIs. However the profile APIs make it hard
// to manipulate lines without keys, so we have to manipulate whole sections
// at a time.
//
//      [Section]
//      a
//
// There is no way to get at the line "a" with the profile APIs. But the
// profile section APIs do let us get at it.
//
//////////////////////////////////////////////////////////////////////////////

PINIFILESECTION
pSetupLoadIniFileSection(
    IN     PCTSTR           FileName,
    IN     PCTSTR           SectionName,
    IN OUT PINISECTIONCACHE SectionList
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD d;
    PTSTR SectionData;
    PVOID p;
    DWORD BufferSize;
    PINIFILESECTION Desc;
    #define BUF_GROW 4096

    //
    // See if this section is already loaded.
    //
    for(Desc=SectionList->Sections; Desc; Desc=Desc->Next) {
        if(!lstrcmpi(Desc->IniFileName,FileName) && !lstrcmpi(Desc->SectionName,SectionName)) {
            return(Desc);
        }
    }

    BufferSize = 0;
    SectionData = NULL;

    //
    // Read the entire section. We don't know how big it is
    // so keep growing the buffer until we succeed.
    //
    do {
        BufferSize += BUF_GROW;
        if(SectionData) {
            p = MyRealloc(SectionData,BufferSize*sizeof(TCHAR));
        } else {
            p = MyMalloc(BufferSize*sizeof(TCHAR));
        }
        if(p) {
            SectionData = p;
        } else {
            if(SectionData) {
                MyFree(SectionData);
            }
            return(NULL);
        }

        //
        // Attempt to get the entire section.
        //
        d = GetPrivateProfileSection(SectionName,SectionData,BufferSize,FileName);

    } while(d == (BufferSize-2));

    if(Desc = MyMalloc(sizeof(INIFILESECTION))) {
        if(Desc->IniFileName = DuplicateString(FileName)) {
            if(Desc->SectionName = DuplicateString(SectionName)) {
                Desc->SectionData = SectionData;
                Desc->BufferSize = BufferSize;
                Desc->BufferUsed = d + 1;

                Desc->Next = SectionList->Sections;
                SectionList->Sections = Desc;
            } else {
                MyFree(SectionData);
                MyFree(Desc->IniFileName);
                MyFree(Desc);
                Desc = NULL;
            }
        } else {
            MyFree(SectionData);
            MyFree(Desc);
            Desc = NULL;
        }
    } else {
        MyFree(SectionData);
    }

    return(Desc);
}


PTSTR
pSetupFindLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,      OPTIONAL
    IN PCTSTR          RightHandSide OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PTSTR p,q,r;
    BOOL b1,b2;

    if(!KeyName && !RightHandSide) {
        return(NULL);
    }

    for(p=Section->SectionData; *p; p+=lstrlen(p)+1) {

        //
        // Locate key separator if present.
        //
        q = _tcschr(p,TEXT('='));

        //
        // If we need to match by key, attempt that here.
        // If the line has no key then it can't match.
        //
        if(KeyName) {
            if(q) {
                *q = 0;
                b1 = (lstrcmpi(KeyName,p) == 0);
                *q = TEXT('=');
            } else {
                b1 = FALSE;
            }
        } else {
            b1 = TRUE;
        }

        //
        // If we need to match by right hand side, attempt
        // that here.
        //
        if(RightHandSide) {
            //
            // If we have a key, then the right hand side is everything
            // after. If we have no key, then the right hand side is
            // the entire line.
            //
            if(q) {
                r = q + 1;
            } else {
                r = p;
            }
            b2 = (lstrcmpi(r,RightHandSide) == 0);
        } else {
            b2 = TRUE;
        }

        if(b1 && b2) {
            //
            // Return pointer to beginning of line.
            //
            return(p);
        }
    }

    return(NULL);
}


BOOL
pSetupReplaceOrAddLineInSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide,   OPTIONAL
    IN BOOL            MatchRHS
    )
{
    PTSTR LineInBuffer,NextLine;
    int CurrentCharsInBuffer;
    int ExistingLineLength,NewLineLength,BufferUsedDelta;
    PVOID p;

    //
    // Locate the line.
    //
    LineInBuffer = pSetupFindLineInSection(
                        Section,
                        KeyName,
                        MatchRHS ? RightHandSide : NULL
                        );

    if(LineInBuffer) {

        //
        // Line is in the section. Replace.
        //

        CurrentCharsInBuffer = Section->BufferUsed;

        ExistingLineLength = lstrlen(LineInBuffer)+1;

        NewLineLength = (KeyName ? (lstrlen(KeyName) + 1) : 0)         // key=
                      + (RightHandSide ? lstrlen(RightHandSide) : 0)   // RHS
                      + 1;                                             // terminating nul

        //
        // Empty lines not allowed but not error either.
        //
        if(NewLineLength == 1) {
            return(TRUE);
        }

        //
        // Figure out whether we need to grow the buffer.
        //
        BufferUsedDelta = NewLineLength - ExistingLineLength;
        if((BufferUsedDelta > 0) && ((Section->BufferSize - Section->BufferUsed) < BufferUsedDelta)) {

            p = MyRealloc(
                    Section->SectionData,
                    (Section->BufferUsed + BufferUsedDelta)*sizeof(TCHAR)
                    );

            if(p) {
                (PUCHAR)LineInBuffer += (PUCHAR)p - (PUCHAR)Section->SectionData;

                Section->SectionData = p;
                Section->BufferSize = Section->BufferUsed + BufferUsedDelta;
            } else {
                return(FALSE);
            }
        }

        NextLine = LineInBuffer + lstrlen(LineInBuffer) + 1;
        Section->BufferUsed += BufferUsedDelta;

        MoveMemory(

            //
            // Leave exactly enough space for the new line. Since the new line
            // will start at the same place the existing line is at now, the
            // target for the move is simply the first char past what will be
            // copied in later as the new line.
            //
            LineInBuffer + NewLineLength,

            //
            // The rest of the buffer past the line as it exists now must be
            // preserved. Thus the source for the move is the first char of
            // the next line as it is now.
            //
            NextLine,

            //
            // Subtract out the chars in the line as it exists now, since we're
            // going to overwrite it and are making room for the line in its
            // new form. Also subtract out the chars in the buffer that are
            // before the start of the line we're operating on.
            //
            ((CurrentCharsInBuffer - ExistingLineLength) - (LineInBuffer - Section->SectionData))*sizeof(TCHAR)

            );

        if(KeyName) {
            lstrcpy(LineInBuffer,KeyName);
            lstrcat(LineInBuffer,TEXT("="));
        }
        if(RightHandSide) {
            if(KeyName) {
                lstrcat(LineInBuffer,RightHandSide);
            } else {
                lstrcpy(LineInBuffer,RightHandSide);
            }
        }

        return(TRUE);

    } else {
        //
        // Line is not already in the section. Add it to the end.
        //
        return(pSetupAppendLineToSection(Section,KeyName,RightHandSide));
    }
}


BOOL
pSetupAppendLineToSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    )
{
    int LineLength;
    PVOID p;
    int EndOffset;

    LineLength = (KeyName ? (lstrlen(KeyName) + 1) : 0)         // Key=
               + (RightHandSide ? lstrlen(RightHandSide) : 0)   // RHS
               + 1;                                             // terminating nul

    //
    // Empty lines not allowed but not error either.
    //
    if(LineLength == 1) {
        return(TRUE);
    }

    if((Section->BufferSize - Section->BufferUsed) < LineLength) {

        p = MyRealloc(
                Section->SectionData,
                (Section->BufferUsed + LineLength) * sizeof(WCHAR)
                );

        if(p) {
            Section->SectionData = p;
            Section->BufferSize = Section->BufferUsed + LineLength;
        } else {
            return(FALSE);
        }
    }

    //
    // Put new text at end of section, remembering that the section
    // is termianted with an extra nul character.
    //
    if(KeyName) {
        lstrcpy(Section->SectionData + Section->BufferUsed - 1,KeyName);
        lstrcat(Section->SectionData + Section->BufferUsed - 1,TEXT("="));
    }
    if(RightHandSide) {
        if(KeyName) {
            lstrcat(Section->SectionData + Section->BufferUsed - 1,RightHandSide);
        } else {
            lstrcpy(Section->SectionData + Section->BufferUsed - 1,RightHandSide);
        }
    }

    Section->BufferUsed += LineLength;
    Section->SectionData[Section->BufferUsed-1] = 0;

    return(TRUE);
}


BOOL
pSetupDeleteLineFromSection(
    IN PINIFILESECTION Section,
    IN PCTSTR          KeyName,         OPTIONAL
    IN PCTSTR          RightHandSide    OPTIONAL
    )
{
    int LineLength;
    PTSTR Line;

    if(!KeyName && !RightHandSide) {
        return(TRUE);
    }

    //
    // Locate the line.
    //
    if(Line = pSetupFindLineInSection(Section,KeyName,RightHandSide)) {

        LineLength = lstrlen(Line) + 1;

        MoveMemory(
            Line,
            Line + LineLength,
            ((Section->SectionData + Section->BufferUsed) - (Line + LineLength))*sizeof(TCHAR)
            );

        Section->BufferUsed -= LineLength;
    }

    return(TRUE);
}


DWORD
pSetupUnloadIniFileSections(
    IN PINISECTIONCACHE SectionList,
    IN BOOL             WriteToFile
    )
{
    DWORD d;
    BOOL b;
    PINIFILESECTION Section,Temp;

    d = NO_ERROR;
    for(Section=SectionList->Sections; Section; Section=Temp) {

        Temp = Section->Next;

        if(WriteToFile) {

            //
            // Delete the existing section first and then recreate it.
            //
            b = WritePrivateProfileString(
                    Section->SectionName,
                    NULL,
                    NULL,
                    Section->IniFileName
                    );

            if(b) {
                b = WritePrivateProfileSection(
                        Section->SectionName,
                        Section->SectionData,
                        Section->IniFileName
                        );
            }

            if(!b && (d == NO_ERROR)) {
                d = GetLastError();
                //
                // Allow invalid param because sometime we have problems
                // when ini files are mapped into the registry.
                //
                if(d == ERROR_INVALID_PARAMETER) {
                    d = NO_ERROR;
                }
            }
        }

        MyFree(Section->SectionData);
        MyFree(Section->SectionName);
        MyFree(Section->IniFileName);
        MyFree(Section);
    }

    return(d);
}


DWORD
pSetupValidateDevRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    )
/*++

Routine Description:

    This routine validates the data buffer passed in with respect to the
    specified device registry property code.  If the code is not of the correct
    form, but can be converted (e.g., REG_EXPAND_SZ -> REG_SZ), then the
    conversion is done and placed into a new buffer, that is returned to the
    caller.

Arguments:

    CmPropertyCode - Specifies the CM_DRP code indentifying the device registry property
        with which this data buffer is associated.

    ValueType - Specifies the registry data type for the supplied buffer.

    Data - Supplies the address of the data buffer.

    DataSize - Supplies the size, in bytes, of the data buffer.

    ConvertedBuffer - Supplies the address of a variable that receives a newly-allocated
        buffer containing a converted form of the supplied data.  If the data needs no
        conversion, this parameter will be set to NULL on return.

    ConvertedBufferSize - Supplies the address of a variable that receives the size, in
        bytes, of the converted buffer, or 0 if no conversion was required.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is an ERROR_* code.

--*/
{
    //
    // Initialize ConvertedBuffer output params to indicate that no conversion was necessary.
    //
    *ConvertedBuffer = NULL;
    *ConvertedBufferSize = 0;

    //
    // Group all properties expecting the same data type together.
    //
    switch(CmPropertyCode) {
        //
        // REG_SZ properties. No other data type is supported.
        //
        case CM_DRP_DEVICEDESC :
        case CM_DRP_SERVICE :
        case CM_DRP_CLASS :
        case CM_DRP_CLASSGUID :
        case CM_DRP_DRIVER :
        case CM_DRP_MFG :
        case CM_DRP_FRIENDLYNAME :
        case CM_DRP_LOCATION_INFORMATION :
        case CM_DRP_SECURITY_SDS :
        case CM_DRP_UI_NUMBER_DESC_FORMAT:

            if(ValueType != REG_SZ) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // REG_MULTI_SZ properties.  Allow REG_SZ as well, by simply double-terminating
        // the string (i.e., make it a REG_MULTI_SZ with only one string).
        //
        case CM_DRP_HARDWAREID :
        case CM_DRP_COMPATIBLEIDS :
        case CM_DRP_UPPERFILTERS:
        case CM_DRP_LOWERFILTERS:

            if(ValueType == REG_SZ) {

                if(*ConvertedBuffer = MyMalloc(*ConvertedBufferSize = DataSize + sizeof(TCHAR))) {
                    CopyMemory(*ConvertedBuffer, Data, DataSize);
                    *((PTSTR)((PBYTE)(*ConvertedBuffer) + DataSize)) = TEXT('\0');
                } else {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

            } else if(ValueType != REG_MULTI_SZ) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // REG_DWORD properties.  Also allow REG_BINARY, as long as the size is right.
        //
        case CM_DRP_CONFIGFLAGS :
        case CM_DRP_CAPABILITIES :
        case CM_DRP_UI_NUMBER :
        case CM_DRP_DEVTYPE :
        case CM_DRP_EXCLUSIVE :
        case CM_DRP_CHARACTERISTICS :
        case CM_DRP_ADDRESS:
        case CM_DRP_REMOVAL_POLICY_OVERRIDE:

            if(((ValueType != REG_DWORD) && (ValueType != REG_BINARY)) || (DataSize != sizeof(DWORD))) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // No other properties are supported.  Save the trouble of calling a CM API and
        // return failure now.
        //
        default :

            return ERROR_INVALID_REG_PROPERTY;
    }

    return NO_ERROR;
}

DWORD
pSetupValidateClassRegProp(
    IN  ULONG   CmPropertyCode,
    IN  DWORD   ValueType,
    IN  PCVOID  Data,
    IN  DWORD   DataSize,
    OUT PVOID  *ConvertedBuffer,
    OUT PDWORD  ConvertedBufferSize
    )
/*++

Routine Description:

    This routine validates the data buffer passed in with respect to the specified
    class registry property code.

Arguments:

    CmPropertyCode - Specifies the CM_CRP code indentifying the device registry property
        with which this data buffer is associated.

    ValueType - Specifies the registry data type for the supplied buffer.

    Data - Supplies the address of the data buffer.

    DataSize - Supplies the size, in bytes, of the data buffer.

    ConvertedBuffer - Supplies the address of a variable that receives a newly-allocated
        buffer containing a converted form of the supplied data.  If the data needs no
        conversion, this parameter will be set to NULL on return.

    ConvertedBufferSize - Supplies the address of a variable that receives the size, in
        bytes, of the converted buffer, or 0 if no conversion was required.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is an ERROR_* code.

--*/
{
    //
    // Initialize ConvertedBuffer output params to indicate that no conversion was necessary.
    //
    *ConvertedBuffer = NULL;
    *ConvertedBufferSize = 0;

    //
    // Group all properties expecting the same data type together.
    //
    switch(CmPropertyCode) {
        //
        // REG_SZ properties. No other data type is supported.
        //
        case CM_CRP_SECURITY_SDS :

            if(ValueType != REG_SZ) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // REG_DWORD properties.  Also allow REG_BINARY, as long as the size is right.
        //
        case CM_CRP_DEVTYPE :
        case CM_CRP_EXCLUSIVE :
        case CM_CRP_CHARACTERISTICS :

            if(((ValueType != REG_DWORD) && (ValueType != REG_BINARY)) || (DataSize != sizeof(DWORD))) {
                return ERROR_INVALID_REG_PROPERTY;
            }

            break;

        //
        // No other properties are supported.  Save the trouble of calling a CM API and
        // return failure now.
        //
        default :

            return ERROR_INVALID_REG_PROPERTY;
    }

    return NO_ERROR;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionA(
    IN HINF   InfHandle,
    IN PCSTR  SectionName,
    IN DWORD  Flags
    )
{
    PCWSTR UnicodeSectionName;
    BOOL b;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(SectionName, &UnicodeSectionName)) == NO_ERROR) {

        b = SetupInstallServicesFromInfSectionExW(InfHandle,
                                                  UnicodeSectionName,
                                                  Flags,
                                                  INVALID_HANDLE_VALUE,
                                                  NULL,
                                                  NULL,
                                                  NULL
                                                 );

        d = GetLastError();

        MyFree(UnicodeSectionName);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionW(
    IN HINF   InfHandle,
    IN PCWSTR SectionName,
    IN DWORD  Flags
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Flags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
WINAPI
SetupInstallServicesFromInfSection(
    IN HINF   InfHandle,
    IN PCTSTR SectionName,
    IN DWORD  Flags
    )
/*++

Routine Description:

    This API performs service installation/deletion operations specified in a service
    install section.  Refer to devinstd.c!InstallNtService() for details on the format
    of this section.

Arguments:

    InfHandle - Supplies the handle of the INF containing the service install section

    SectionName - Supplies the name of the service install section to run.

    Flags - Supplies flags controlling the installation.  May be a combination of the
        following values:

        SPSVCINST_TAGTOFRONT - For every kernel or filesystem driver installed (that has
            an associated LoadOrderGroup), always move this service's tag to the front
            of the ordering list.

        SPSVCINST_DELETEEVENTLOGENTRY - For every service specified in a DelService entry,
            delete the associated event log entry (if there is one).

        SPSVCINST_NOCLOBBER_DISPLAYNAME - If this flag is specified, then we will
            not overwrite the service's display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE - If this flag is specified, then we will
            not overwrite the service's start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL - If this flag is specified, then we
            will not overwrite the service's error control value if the service
            already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP - If this flag is specified, then we
            will not overwrite the service's load order group if it already
            exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES - If this flag is specified, then we
            will not overwrite the service's dependencies list if it already
            exists.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    return SetupInstallServicesFromInfSectionEx(InfHandle,
                                                SectionName,
                                                Flags,
                                                INVALID_HANDLE_VALUE,
                                                NULL,
                                                NULL,
                                                NULL
                                               );
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionExA(
    IN HINF             InfHandle,
    IN PCSTR            SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    )
{
    PCWSTR UnicodeSectionName;
    BOOL b;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(SectionName, &UnicodeSectionName)) == NO_ERROR) {

        b = SetupInstallServicesFromInfSectionExW(InfHandle,
                                                  UnicodeSectionName,
                                                  Flags,
                                                  DeviceInfoSet,
                                                  DeviceInfoData,
                                                  Reserved1,
                                                  Reserved2
                                                 );

        d = GetLastError();

        MyFree(UnicodeSectionName);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupInstallServicesFromInfSectionExW(
    IN HINF             InfHandle,
    IN PCWSTR           SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SectionName);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(DeviceInfoSet);
    UNREFERENCED_PARAMETER(DeviceInfoData);
    UNREFERENCED_PARAMETER(Reserved1);
    UNREFERENCED_PARAMETER(Reserved2);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
WINAPI
SetupInstallServicesFromInfSectionEx(
    IN HINF             InfHandle,
    IN PCTSTR           SectionName,
    IN DWORD            Flags,
    IN HDEVINFO         DeviceInfoSet,  OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN PVOID            Reserved1,
    IN PVOID            Reserved2
    )
/*++

Routine Description:

    This API performs service installation/deletion operations specified in a service
    install section.  Refer to devinstd.c!InstallNtService() for details on the format
    of this section.

Arguments:

    InfHandle - Supplies the handle of the INF containing the service install section

    SectionName - Supplies the name of the service install section to run.

    Flags - Supplies flags controlling the installation.  May be a combination of the
        following values:

        SPSVCINST_TAGTOFRONT - For every kernel or filesystem driver installed (that has
            an associated LoadOrderGroup), always move this service's tag to the front
            of the ordering list.

        SPSVCINST_ASSOCSERVICE - This flag may only be specified if a device information
            set and a device information element are specified.  If set, this flag
            specifies that the service being installed is the owning service (i.e.,
            function driver) for this device instance.  If the service install section
            contains more than AddService entry, then this flag is ignored (only 1
            service can be the function driver for a device instance).

        SPSVCINST_DELETEEVENTLOGENTRY - For every service specified in a DelService entry,
            delete the associated event log entry (if there is one).

        SPSVCINST_NOCLOBBER_DISPLAYNAME - If this flag is specified, then we will
            not overwrite the service's display name, if it already exists.

        SPSVCINST_NOCLOBBER_STARTTYPE - If this flag is specified, then we will
            not overwrite the service's start type if the service already exists.

        SPSVCINST_NOCLOBBER_ERRORCONTROL - If this flag is specified, then we
            will not overwrite the service's error control value if the service
            already exists.

        SPSVCINST_NOCLOBBER_LOADORDERGROUP - If this flag is specified, then we
            will not overwrite the service's load order group if it already
            exists.

        SPSVCINST_NOCLOBBER_DEPENDENCIES - If this flag is specified, then we
            will not overwrite the service's dependencies list if it already
            exists.

    DeviceInfoSet - Optionally, supplies a handle to the device information set containing
        an element that is to be associated with the service being installed.  If this
        parameter is not specified, then DeviceInfoData is ignored.

    DeviceInfoData - Optionally, specifies the device information element that is to be
        associated with the service being installed.  If DeviceInfoSet is specified, then
        this parameter must be specified.

    Reserved1, Reserved2 - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    INFCONTEXT InfContext;
    DWORD d;
    BOOL DontCare;
    BOOL NeedReboot = FALSE;

    //
    // Validate the flags passed in.
    //
    if(Flags & SPSVCINST_ILLEGAL_FLAGS) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    //
    // Make sure that a device information set and element were specified if the
    // SPSVCINST_ASSOCSERVICE flag is set.
    //
    if(Flags & SPSVCINST_ASSOCSERVICE) {

        if(!DeviceInfoSet ||
           (DeviceInfoSet == INVALID_HANDLE_VALUE) ||
           !DeviceInfoData) {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    //
    // Make sure the caller didn't pass us anything in the Reserved parameters.
    //
    if(Reserved1 || Reserved2) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure we were given a section name.
    //
    if(!SectionName) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Lock down the device information set for the duration of this call.
    //
    if(Flags & SPSVCINST_ASSOCSERVICE) {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            SetLastError(ERROR_INVALID_HANDLE);
            return FALSE;
        }

    } else {
        pDeviceInfoSet = NULL;
    }

    d = NO_ERROR;
    DevInfoElem = NULL;

    try {

        if(pDeviceInfoSet) {

            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                d = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // We don't do any validation that the section exists in the worker routine--make
        // sure that it does exist.
        //
        if(SetupFindFirstLine(InfHandle, SectionName, NULL, &InfContext)) {
            //
            // If SPSVCINST_ASSOCSERVICE is specified, then ensure that there is exactly
            // one AddService entry in this service install section.  If not, then clear
            // this flag.
            //
            if((Flags & SPSVCINST_ASSOCSERVICE) &&
               SetupFindFirstLine(InfHandle, SectionName, pszAddService, &InfContext) &&
               SetupFindNextMatchLine(&InfContext, pszAddService, &InfContext))
            {
                Flags &= ~SPSVCINST_ASSOCSERVICE;
            }

            d = InstallNtService(DevInfoElem,
                                 InfHandle,
                                 NULL,
                                 SectionName,
                                 NULL,
                                 Flags | SPSVCINST_NO_DEVINST_CHECK,
                                 &DontCare
                                );

            if ((d == NO_ERROR) && GetLastError() == ERROR_SUCCESS_REBOOT_REQUIRED) {
                NeedReboot = TRUE;
            }

        } else {
            d = GetLastError();
            pSetupLogSectionWarning(InfHandle,DeviceInfoSet,DeviceInfoData,NULL,SectionName,MSG_LOG_NOSECTION_SERVICE,d,NULL);
            //
            // some callers expect this specific error
            //
            d = ERROR_SECTION_NOT_FOUND;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    if (!NeedReboot) {
        SetLastError(d);
    } else {
        MYASSERT( d == NO_ERROR );
    }
    return (d == NO_ERROR);
}


//
// Taken from Win95 sxgen.c. These are flags used when
// we are installing an inf such as when a user right-clicks
// on one and selects the 'install' action.
//
#define HOW_NEVER_REBOOT         0
#define HOW_ALWAYS_SILENT_REBOOT 1
#define HOW_ALWAYS_PROMPT_REBOOT 2
#define HOW_SILENT_REBOOT        3
#define HOW_PROMPT_REBOOT        4


#ifdef UNICODE
//
// ANSI version
//
VOID
WINAPI
InstallHinfSectionA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    )
#else
//
// Unicode version
//
VOID
WINAPI
InstallHinfSectionW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR    CommandLine,
    IN INT       ShowCommand
    )
#endif
{
    UNREFERENCED_PARAMETER(Window);
    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(CommandLine);
    UNREFERENCED_PARAMETER(ShowCommand);
}

VOID
WINAPI
InstallHinfSection(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCTSTR    CommandLine,
    IN INT       ShowCommand
    )

/*++

Routine Description:

    This is the entry point that performs the INSTALL action when
    a user right-clicks an inf file. It is called by the shell via rundll32.

    The command line is expected to be of the following form:

        <section name> <flags> <file name>

    The section is expected to be a general format install section, and
    may also have an include= line and a needs= line. Infs listed on the
    include= line are append-loaded to the inf on the command line prior to
    any installation. Sections on the needs= line are installed after the
    section listed on the command line.

    After the specified section has been installed, a section of the form:

        [<section name>.Services]

    is used in a call to SetupInstallServicesFromInfSection.

Arguments:

    Flags - supplies flags for operation.

        1 - reboot the machine in all cases
        2 - ask the user if he wants to reboot
        3 - reboot the machine without asking the user, if we think it is necessary
        4 - if we think reboot is necessary, ask the user if he wants to reboot

        0x80 - set the default file source path for file installation to
               the path where the inf is located.  (NOTE: this is hardly ever
               necessary for the Setup APIs, since we intelligently determine what
               the source path should be.  The only case where this would still be
               useful is if there were a directory that contained INFs that was in
               our INF search path list, but that also contained the files to be
               copied by this INF install action.  In that case, this flag would
               still need to be set, or we would look for the files in the location
               from which the OS was installed.

Return Value:

    None.

--*/

{
    TCHAR SourcePathBuffer[MAX_PATH];
    PTSTR SourcePath;
    TCHAR szCmd[MAX_PATH];
    PTCHAR p;
    PTCHAR szHow;
    PTSTR szInfFile, szSectionName;
    INT   iHow, NeedRebootFlags;
    HINF  InfHandle;
    TCHAR InfSearchPath[MAX_PATH];
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    BOOL b, Error;
    TCHAR ActualSection[MAX_SECT_NAME_LEN];
    DWORD ActualSectionLength;
    DWORD Win32ErrorCode;
    INFCONTEXT InfContext;
    BOOL DontCare;
    DWORD RequiredSize;
    DWORD slot_section = 0;
    BOOL NoProgressUI;
    BOOL reboot = FALSE;

    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(ShowCommand);

    //
    // Initialize variables that will later contain resource requiring clean-up.
    //
    InfHandle = INVALID_HANDLE_VALUE;
    FileQueue = INVALID_HANDLE_VALUE;
    QueueContext = NULL;

    Error = TRUE;   // assume failure.

    try {
        //
        // Take a copy of the command line then get pointers to the fields.
        //
        lstrcpyn(szCmd, CommandLine, SIZECHARS(szCmd));

        szSectionName = szCmd;
        szHow = _tcschr(szSectionName, TEXT(' '));
        if(!szHow) {
            goto c0;
        }
        *szHow++ = TEXT('\0');
        szInfFile = _tcschr(szHow, TEXT(' '));
        if(!szInfFile) {
            goto c0;
        }
        *szInfFile++ = TEXT('\0');

        iHow = _tcstol(szHow, NULL, 10);

        //
        // Get the full path to the INF, so that the path may be used as a
        // first-pass attempt at locating any associated INFs.
        //
        RequiredSize = GetFullPathName(szInfFile,
                                       SIZECHARS(InfSearchPath),
                                       InfSearchPath,
                                       &p
                                      );

        if(!RequiredSize || (RequiredSize >= SIZECHARS(InfSearchPath))) {
            //
            // If we start failing because MAX_PATH isn't big enough anymore, we
            // wanna know about it!
            //
            MYASSERT(RequiredSize < SIZECHARS(InfSearchPath));
            goto c0;
        }

        //
        // If flag is set (and INF filename includes a path), set up so DIRID_SRCPATH is
        // path where INF is located (i.e., override our default SourcePath determination).
        //
        if((iHow & 0x80) && (pSetupGetFileTitle(szInfFile) != szInfFile)) {
            SourcePath = lstrcpyn(SourcePathBuffer, InfSearchPath, (int)(p - InfSearchPath) + 1);
        } else {
            SourcePath = NULL;
        }

        iHow &= 0x7f;

        //
        // If we're non-interactive, then we don't want to allow any possibility
        // of a reboot prompt happening.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {

            switch(iHow) {

                case HOW_NEVER_REBOOT:
                case HOW_ALWAYS_SILENT_REBOOT:
                case HOW_SILENT_REBOOT:
                    //
                    // These cases are OK--they're all silent.
                    //
                    break;

                default:
                    //
                    // Anything else is disallowed in non-interactive mode.
                    //
                    goto c0;
            }
        }

        //
        // Load the inf file that was passed on the command line.
        //
        InfHandle = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL);
        if(InfHandle == INVALID_HANDLE_VALUE) {
            goto c0;
        }

        //
        // See if there is an nt-specific section
        //
        if(!SetupDiGetActualSectionToInstall(InfHandle,
                                             szSectionName,
                                             ActualSection,
                                             SIZECHARS(ActualSection),
                                             &ActualSectionLength,
                                             NULL
                                             )) {
            goto c0;
        }

        //
        // Check to see if the install section has a "Reboot" line.
        //
        if(SetupFindFirstLine(InfHandle, ActualSection, pszReboot, &InfContext)) {
            reboot = TRUE;
        }

        //
        // Assume there is only one layout file and load it.
        //
        SetupOpenAppendInfFile(NULL, InfHandle, NULL);

        //
        // Append-load any included INFs specified in an "include=" line in our
        // install section.
        //
        AppendLoadIncludedInfs(InfHandle, InfSearchPath, ActualSection, TRUE);

        //
        // Create a setup file queue and initialize the default queue callback.
        //
        FileQueue = SetupOpenFileQueue();
        if(FileQueue == INVALID_HANDLE_VALUE) {
            goto c1;
        }

        //
        // Replace the file queue's log context with the Inf's
        //
        ShareLogContext(&((PLOADED_INF)InfHandle)->LogContext,&((PSP_FILE_QUEUE)FileQueue)->LogContext);

        NoProgressUI = (GuiSetupInProgress || (GlobalSetupFlags & PSPGF_NONINTERACTIVE));

        QueueContext = SetupInitDefaultQueueCallbackEx(
                           Window,
                           (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                           0,
                           0,
                           0
                          );

        if(!QueueContext) {
            goto c2;
        }

        if (slot_section == 0) {
            slot_section = AllocLogInfoSlot(((PSP_FILE_QUEUE) FileQueue)->LogContext,FALSE);
        }
        WriteLogEntry(((PSP_FILE_QUEUE) FileQueue)->LogContext,
            slot_section,
            MSG_LOG_INSTALLING_SECTION_FROM,
            NULL,
            ActualSection,
            szInfFile);

        b = (NO_ERROR == InstallFromInfSectionAndNeededSections(NULL,
                                                                InfHandle,
                                                                ActualSection,
                                                                SPINST_FILES,
                                                                NULL,
                                                                SourcePath,
                                                                SP_COPY_NEWER | SP_COPY_LANGUAGEAWARE,
                                                                NULL,
                                                                NULL,
                                                                INVALID_HANDLE_VALUE,
                                                                NULL,
                                                                FileQueue
                                                               ));

        //
        // Commit file queue.
        //
        if(!SetupCommitFileQueue(Window, FileQueue, SetupDefaultQueueCallback, QueueContext)) {
            goto c3;
        }

        //
        // Note, if the INF contains a (non-NULL) ClassGUID, then it will have
        // been installed into %windir%\Inf during the above queue committal.
        // We make no effort to subsequently uninstall it (and its associated
        // PNF and CAT) if something fails below.
        //

        //
        // Perform non-file operations for the section passed on the cmd line.
        //
        b = (NO_ERROR == InstallFromInfSectionAndNeededSections(Window,
                                                                InfHandle,
                                                                ActualSection,
                                                                SPINST_ALL ^ SPINST_FILES,
                                                                NULL,
                                                                NULL,
                                                                0,
                                                                NULL,
                                                                NULL,
                                                                INVALID_HANDLE_VALUE,
                                                                NULL,
                                                                NULL
                                                               ));

        //
        // Now run the corresponding ".Services" section (if there is one), and
        // then finish up the install.
        //
        CopyMemory(&(ActualSection[ActualSectionLength - 1]),
                   pszServicesSectionSuffix,
                   sizeof(pszServicesSectionSuffix)
                  );

        //
        // We don't do any validation that the section exists in the worker
        // routine--make sure that it does exist.
        //
        if(SetupFindFirstLine(InfHandle, ActualSection, NULL, &InfContext)) {

            Win32ErrorCode = InstallNtService(NULL,
                                              InfHandle,
                                              InfSearchPath,
                                              ActualSection,
                                              NULL,
                                              SPSVCINST_NO_DEVINST_CHECK,
                                              &DontCare
                                             );

            if(Win32ErrorCode != NO_ERROR) {
                SetLastError(Win32ErrorCode);
                goto c3;
            } else if(GetLastError()==ERROR_SUCCESS_REBOOT_REQUIRED) {
                reboot = TRUE;
            }

        }

        if(reboot) {
            //
            // we've been asked to reboot either by reboot keyword or because of boot-start service
            //
            if(iHow == HOW_SILENT_REBOOT) {
                //
                // We were supposed to only do a silent reboot if necessary.
                // Change this to _always_ do a silent reboot.
                //
                iHow = HOW_ALWAYS_SILENT_REBOOT;

            } else if(iHow != HOW_ALWAYS_SILENT_REBOOT) {

                if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
                    //
                    // In the non-interactive case, we have a problem.  The
                    // caller said to never reboot, but the INF wants us to ask
                    // the user.  We obviously cannot ask the user.
                    //
                    // In this case, we assert (we should never be running INFs
                    // non-interactively that require a reboot unless we've
                    // specified one of the silent reboot flags).  We then
                    // ignore the reboot flag, since the caller obviously
                    // doesn't want it/isn't prepared to deal with it.
                    //
                    MYASSERT(0);

                } else {
                    //
                    // In the interactive case, we want to force the (non-
                    // silent) reboot prompt (i.e., the INF flag overrides the
                    // caller).
                    //
                    iHow = HOW_ALWAYS_PROMPT_REBOOT;
                }
            }
        }

        if(NO_ERROR != (Win32ErrorCode = pSetupInstallStopEx(TRUE, 0, ((PSP_FILE_QUEUE)FileQueue)->LogContext))) {
            SetLastError(Win32ErrorCode);
            goto c3;
        }

        //
        // Refresh the desktop.
        //
        SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_FLUSHNOWAIT,0,0);

        switch(iHow) {

        case HOW_NEVER_REBOOT:
            break;

        case HOW_ALWAYS_PROMPT_REBOOT:
            RestartDialogEx(Window, NULL, EWX_REBOOT,REASON_PLANNED_FLAG);
            break;

        case HOW_PROMPT_REBOOT:
            SetupPromptReboot(FileQueue, Window, FALSE);
            break;

        case HOW_SILENT_REBOOT:
            if(!(NeedRebootFlags = SetupPromptReboot(FileQueue, Window, TRUE))) {
                break;
            } else if(NeedRebootFlags == -1) {
                //
                // An error occurred--this should never happen.
                //
                goto c3;
            }
            //
            // Let fall through to same code that handles 'always silent reboot'
            // case.
            //

        case HOW_ALWAYS_SILENT_REBOOT:
            //
            // Assumption that user has reboot privs
            //
            if(pSetupEnablePrivilege(SE_SHUTDOWN_NAME, TRUE)) {
                ExitWindowsEx(EWX_REBOOT, 0);
            }
            break;
        }

        //
        // If we get to here, then this routine has been successful.
        //
        Error = FALSE;

c3:
        if(Error && (GetLastError() == ERROR_CANCELLED)) {
            //
            // If the error was because the user cancelled, then we don't want
            // to consider that as an error (i.e., we don't want to give an
            // error popup later).
            //
            Error = FALSE;
        }

        SetupTermDefaultQueueCallback(QueueContext);
        QueueContext = NULL;
c2:
        if (slot_section) {
            ReleaseLogInfoSlot(((PSP_FILE_QUEUE) FileQueue)->LogContext,slot_section);
            slot_section = 0;
        }
        SetupCloseFileQueue(FileQueue);
        FileQueue = INVALID_HANDLE_VALUE;
c1:
        SetupCloseInfFile(InfHandle);
        InfHandle = INVALID_HANDLE_VALUE;

c0:     ; // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(QueueContext) {
            SetupTermDefaultQueueCallback(QueueContext);
        }
        if(FileQueue != INVALID_HANDLE_VALUE) {
            if (slot_section) {
                ReleaseLogInfoSlot(((PSP_FILE_QUEUE) FileQueue)->LogContext,slot_section);
                slot_section = 0;
            }
            SetupCloseFileQueue(FileQueue);
        }
        if(InfHandle != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile(InfHandle);
        }
    }

    if(Error) {

        if(!(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {
             //
             // Re-use 'ActualSection' buffer to hold error dialog title.
             //
             if(!LoadString(MyDllModuleHandle,
                            IDS_ERROR,
                            ActualSection,
                            SIZECHARS(ActualSection))) {
                 *ActualSection = TEXT('\0');
             }

             FormatMessageBox(MyDllModuleHandle,
                              Window,
                              MSG_INF_FAILED,
                              ActualSection,
                              MB_OK | MB_ICONSTOP
                             );
        }
    }
}


PTSTR
GetMultiSzFromInf(
    IN  HINF    InfHandle,
    IN  PCTSTR  SectionName,
    IN  PCTSTR  Key,
    OUT PBOOL   pSetupOutOfMemory
    )
/*++

Routine Description:

    This routine returns a newly-allocated buffer filled with the multi-sz list contained
    in the specified INF line.  The caller must free this buffer via MyFree().

Arguments:

    InfHandle - Supplies a handle to the INF containing the line

    SectionName - Specifies which section within the INF contains the line

    Key - Specifies the line whose fields are to be retrieved as a multi-sz list

    pSetupOutOfMemory - Supplies the address of a boolean variable that is set upon return
        to indicate whether or not a failure occurred because of an out-of-memory condition.
        (Failure for any other reason is assumed to be OK.)

Return Value:

    If successful, the return value is the address of a newly-allocated buffer containing
    the multi-sz list, otherwise, it is NULL.

--*/
{
    INFCONTEXT InfContext;
    PTSTR MultiSz;
    DWORD Size;

    //
    // Initialize out-of-memory indicator to FALSE.
    //
    *pSetupOutOfMemory = FALSE;

    if(!SetupFindFirstLine(InfHandle, SectionName, Key, &InfContext) ||
       !SetupGetMultiSzField(&InfContext, 1, NULL, 0, &Size) || (Size < 3)) {

        return NULL;
    }

    if(MultiSz = MyMalloc(Size * sizeof(TCHAR))) {
        if(SetupGetMultiSzField(&InfContext, 1, MultiSz, Size, &Size)) {
            return MultiSz;
        }
        MyFree(MultiSz);
    } else {
        *pSetupOutOfMemory = TRUE;
    }

    return NULL;
}


DWORD
pSetupInstallStopEx(
    IN BOOL DoRunOnce,
    IN DWORD Flags,
    IN PVOID Reserved OPTIONAL
    )
/*++

Routine Description:

    This routine sets up runonce/grpconv to run after a successful INF installation.

Arguments:

    DoRunOnce - If TRUE, then invoke (via WinExec) the runonce utility to perform the
        runonce actions.  If this flag is FALSE, then this routine simply sets the
        runonce registry values and returns.

        NOTE:  The return code from WinExec is not currently being checked, so the return
        value of InstallStop only reflects whether the registry values were set up
        successfully--_not_ whether 'runonce -r' was successfully run.

    Flags - Supplies flags that modify the behavior of this routine.  May be a
        combination of the following values:

        INSTALLSTOP_NO_UI       - Don't display any UI
        INSTALLSTOP_NO_GRPCONV  - Don't do GrpConv

    Reserved - Reserved for internal use--external callers must pass NULL.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is the Win32 error code
    indicating the error that was encountered.

--*/
{
    HKEY  hKey, hSetupKey;
    DWORD Error = NO_ERROR;
    LONG l;
    DWORD nValues = 0;
    PSETUP_LOG_CONTEXT lc = (PSETUP_LOG_CONTEXT)Reserved;

    //
    // If we're batching up RunOnce operations for server-side processing, then
    // return immediately without doing a thing.
    //
    if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
        return NO_ERROR;
    }

    //
    // First, open the key "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce"
    //
    if((l = RegOpenKeyEx(HKEY_LOCAL_MACHINE,pszPathRunOnce,0,KEY_WRITE|KEY_READ,&hKey)) != ERROR_SUCCESS) {
        return (DWORD)l;
    }

    if(!(Flags & INSTALLSTOP_NO_GRPCONV)) {
        //
        // If we need to run the runonce exe for the setup key...
        //
        MYASSERT(*pszKeySetup == TEXT('\\'));
        if(RegOpenKeyEx(hKey,
                        pszKeySetup + 1,    // skip the preceding '\'
                        0,
                        KEY_READ,
                        &hSetupKey) == ERROR_SUCCESS) {
            //
            // We don't need the key--we just needed to check its existence.
            //
            RegCloseKey(hSetupKey);

            //
            // Add the runonce value.
            //
            Error = (DWORD)RegSetValueEx(hKey,
                                         REGSTR_VAL_WRAPPER,
                                         0,
                                         REG_SZ,
                                         (PBYTE)pszRunOnceExe,
                                         sizeof(pszRunOnceExe)
                                        );
        } else {
            //
            // We're OK so far.
            //
            Error = NO_ERROR;
        }

        //
        // GroupConv is always run.
        //
        if(Flags & INSTALLSTOP_NO_UI) {
            l = RegSetValueEx(hKey,
                TEXT("GrpConv"),
                0,
                REG_SZ,
                (PBYTE)pszGrpConvNoUi,
                sizeof(pszGrpConvNoUi));
        } else {
            l = RegSetValueEx(hKey,
                TEXT("GrpConv"),
                0,
                REG_SZ,
                (PBYTE)pszGrpConv,
                sizeof(pszGrpConv));
        }
    }

    if( l != ERROR_SUCCESS ) {
        //
        // Since GrpConv is always run, consider it a more serious error than any error
        // encountered when setting 'runonce'.  (This decision is rather arbitrary, but
        // in practice, it should never make any difference.  Once we get the registry key
        // opened, there's no reason either of these calls to RegSetValueEx should fail.)
        //
        Error = (DWORD)l;
    }

    if (DoRunOnce && (GlobalSetupFlags & PSPGF_NO_RUNONCE)==0) {

        STARTUPINFO StartupInfo;
        PROCESS_INFORMATION ProcessInformation;
        BOOL started;
        TCHAR cmdline[MAX_PATH];

        //
        // we want to know how many items we'll be executing in RunOnce to estimate a timeout
        //
        // This is black-art, we'll allow 5 mins + 1 min per item we
        // find in RunOnce key, but we don't know if there are any other (new) RunOnce keys
        //
        l = RegQueryInfoKey(hKey,NULL,NULL,NULL,
                                    NULL,NULL,NULL,
                                    &nValues,
                                    NULL, NULL, NULL, NULL);
        if ( l != ERROR_SUCCESS ) {
            nValues = 5;
        } else {
            nValues += 5;
        }

        RegCloseKey(hKey);

        ZeroMemory(&StartupInfo,sizeof(StartupInfo));
        ZeroMemory(&ProcessInformation,sizeof(ProcessInformation));

        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = SW_SHOWNORMAL; // runonce -r ignores this anyway
        lstrcpy(cmdline,TEXT("runonce -r"));

        if (lc) {
            //
            // log this information only if we have a context, else don't waste space
            //
            WriteLogEntry(lc,
                  SETUP_LOG_INFO,
                  MSG_LOG_RUNONCE_CALL,
                  NULL,
                  nValues
                 );
        }

        started = CreateProcess(NULL,       // use application name below
                      cmdline,              // command to execute
                      NULL,                 // default process security
                      NULL,                 // default thread security
                      FALSE,                // don't inherit handles
                      0,                    // default flags
                      NULL,                 // inherit environment
                      NULL,                 // inherit current directory
                      &StartupInfo,
                      &ProcessInformation);

        if(started) {

            DWORD WaitProcStatus;
            DWORD Timeout;
            BOOL KeepWaiting = TRUE;


            if (nValues > RUNONCE_THRESHOLD) {
                Timeout = RUNONCE_TIMEOUT * RUNONCE_THRESHOLD;
            } else if (nValues > 0) {
                Timeout = RUNONCE_TIMEOUT * nValues;
            } else {
                //
                // assume something strange - shouldn't occur
                //
                Timeout = RUNONCE_TIMEOUT * RUNONCE_THRESHOLD;
            }

            while (KeepWaiting) {
                WaitProcStatus = MyMsgWaitForMultipleObjectsEx(
                    1,
                    &ProcessInformation.hProcess,
                    Timeout,
                    QS_ALLINPUT,
                    MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
                switch (WaitProcStatus) {
                case WAIT_OBJECT_0 + 1: { // Process gui messages
                    MSG msg;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }

                    // fall through ...
                }
                case WAIT_IO_COMPLETION:
                    break;

                case WAIT_OBJECT_0:
                case WAIT_TIMEOUT:
                default:
                    KeepWaiting = FALSE;
                    break;
                }
            }

            if (WaitProcStatus == WAIT_TIMEOUT) {
                //
                // We won't consider this a critical failure--the runonce task
                // will continue. We do want to log an error about this.
                //
                WriteLogEntry(lc,
                              SETUP_LOG_ERROR,
                              MSG_LOG_RUNONCE_TIMEOUT,
                              NULL
                             );
            }

            CloseHandle(ProcessInformation.hThread);
            CloseHandle(ProcessInformation.hProcess);

        } else {

            DWORD CreateProcError;

            //
            // We won't consider this a critical failure--the runonce task
            // should get picked up later by someone else (e.g., at next
            // login).  We do want to log an error about this, however.
            //
            CreateProcError = GetLastError();

            WriteLogEntry(lc,
                          SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                          MSG_LOG_RUNONCE_FAILED,
                          NULL
                         );

            WriteLogError(lc,
                          SETUP_LOG_ERROR,
                          CreateProcError
                         );
        }
    } else {

        RegCloseKey(hKey);
    }

    return Error;
}

PPSP_RUNONCE_NODE
pSetupAccessRunOnceNodeList(
    VOID
    )
/*++

Routine Description:

    This routine returns a pointer to the head of the global RunOnce node list.
    The caller may traverse the list (via the Next pointer), but does not own
    the list, and may not modify it in any way.

    To cause the list to be freed, use pSetupDestroyRunOnceNodeList.

Arguments:

    None

Return Value:

    Pointer to the first item in the list, or NULL if the list is empty.

Remarks:

    THIS ROUTINE IS NOT THREAD SAFE, AND IS FOR USE SOLELY BY THE SINGLE THREAD
    IN UMPNPMGR THAT DOES DEVICE INSTALLATIONS.

--*/
{
    return RunOnceListHead;
}


VOID
pSetupDestroyRunOnceNodeList(
    VOID
    )
/*++

Routine Description:

    This routine frees the global list of RunOnce nodes, setting it back to an
    empty list.

Arguments:

    None

Return Value:

    None

Remarks:

    THIS ROUTINE IS NOT THREAD SAFE, AND IS FOR USE SOLELY BY THE SINGLE THREAD
    IN UMPNPMGR THAT DOES DEVICE INSTALLATIONS.

--*/
{
    PPSP_RUNONCE_NODE NextNode;

    while(RunOnceListHead) {
        NextNode = RunOnceListHead->Next;
        MyFree(RunOnceListHead->DllFullPath);
        MyFree(RunOnceListHead->DllEntryPointName);
        MyFree(RunOnceListHead->DllParams);
        MyFree(RunOnceListHead);
        RunOnceListHead = NextNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infopenv.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infopenv.c

Abstract:

    Externally exposed INF routines for INF opening, closing,
    and versioning.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
pSetupVersionNodeFromInfInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PINF_VERSION_NODE   VersionNode,
    OUT PTSTR               OriginalFilename OPTIONAL
    );


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetInfInformationA(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    PCWSTR infspec;
    BOOL b;
    DWORD rc;

    //
    // For this API, the return buffer does not have to be translated
    // from Unicode to ANSI. This makes things much easier since the
    // required size is the same for the ANSI and Unicode versions.
    //
    if((SearchControl == INFINFO_INF_NAME_IS_ABSOLUTE)
    || (SearchControl == INFINFO_DEFAULT_SEARCH)
    || (SearchControl == INFINFO_REVERSE_DEFAULT_SEARCH)
    || (SearchControl == INFINFO_INF_PATH_LIST_SEARCH)) {

        rc = pSetupCaptureAndConvertAnsiArg(InfSpec,&infspec);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

    } else {
        //
        // Not a pointer to a string, just pass it on.
        //
        infspec = InfSpec;
    }

    //
    // Note that the data returned from this API is in an
    // internal format, and thus we don't need any less space
    // for the ANSI API, and can just use the buffer and sizes
    // passed in by the caller.
    //
    b = SetupGetInfInformationW(
            infspec,
            SearchControl,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
            );

    rc = GetLastError();

    if(infspec != InfSpec) {
        MyFree(infspec);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetInfInformationW(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfSpec);
    UNREFERENCED_PARAMETER(SearchControl);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetInfInformation(
    IN  LPCVOID             InfSpec,
    IN  DWORD               SearchControl,
    OUT PSP_INF_INFORMATION ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    BOOL UnloadInf;
    PLOADED_INF Inf, CurInf;
    UINT InfCount;
    PUCHAR Out;
    DWORD TotalSpaceRequired;
    DWORD d;
    DWORD ErrorLineNumber;
    TCHAR Path[MAX_PATH];
    PINF_VERSION_NODE VersionNode;
    INF_VERSION_BLOCK UNALIGNED *Prev;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    PTSTR DontCare;
    UINT OriginalFilenameSize;

    //
    // Set up some state based on the SearchSpec parameter.
    //
    Inf = NULL;
    switch(SearchControl) {

    case INFINFO_INF_SPEC_IS_HINF:

        Inf = (PLOADED_INF)InfSpec;
        d = NO_ERROR;
        try {
            if (!LockInf(Inf)) {
                d = ERROR_INVALID_HANDLE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_HANDLE;
        }
        if (d != NO_ERROR) {
            SetLastError(d);
            return FALSE;
        }
        break;

    case INFINFO_INF_NAME_IS_ABSOLUTE:
        //
        // Make sure we have a fully-qualified path.
        //
        d = GetFullPathName((PCTSTR)InfSpec,
                            SIZECHARS(Path),
                            Path,
                            &DontCare
                           );
        if(!d) {
            //
            // LastError has already been set
            // (unless InfSpec was NULL or "")
            //
            if (GetLastError()==NO_ERROR) {
                SetLastError(ERROR_FILE_NOT_FOUND);
            }
            return FALSE;
        } else if(d >= SIZECHARS(Path)) {
            MYASSERT(0);
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }

        if(FileExists(Path, &FindData)) {
            InfSourcePathFromFileName(Path, NULL, &TryPnf);
            break;
        } else {
            //
            // LastError has already been set.
            //
            return FALSE;
        }

    case INFINFO_DEFAULT_SEARCH:
    case INFINFO_REVERSE_DEFAULT_SEARCH:
    case INFINFO_INF_PATH_LIST_SEARCH:

        try {
            d = SearchForInfFile((PCTSTR)InfSpec,
                                 &FindData,
                                 SearchControl,
                                 Path,
                                 SIZECHARS(Path),
                                 NULL
                                );
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
        if(d == NO_ERROR) {
            TryPnf = TRUE;
            break;
        } else {
            SetLastError(d);
            return FALSE;
        }

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // Load the inf if necessary.
    //
    if(Inf) {
        UnloadInf = FALSE;
    } else {

        d = LoadInfFile(Path,
                        &FindData,
                        INF_STYLE_ALL,
                        TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL, // LogContext
                        &Inf,
                        &ErrorLineNumber,
                        NULL
                       );

        if(d != NO_ERROR) {
            SetLastError(d);
            return(FALSE);
        }

        UnloadInf = TRUE;
    }

    //
    // Determine the number of infs associated with this handle,
    // and calculate the amount of space that will be needed to
    // store version information about them.
    //
    // For each inf we will need space for the version block,
    // as well as an offset in the SP_INF_INFORMATION structure
    // to indicate where that inf's version block is located
    // in the output buffer.
    //
    TotalSpaceRequired = offsetof(SP_INF_INFORMATION, VersionData);
    for(InfCount = 0, CurInf = Inf;
        CurInf;
        InfCount++, CurInf = CurInf->Next)
    {
        OriginalFilenameSize = CurInf->OriginalInfName
                             ? (lstrlen(CurInf->OriginalInfName) + 1) * sizeof(TCHAR)
                             : 0;

        TotalSpaceRequired += (offsetof(INF_VERSION_BLOCK, Filename) +
                               CurInf->VersionBlock.FilenameSize +
                               CurInf->VersionBlock.DataSize +
                               OriginalFilenameSize
                              );
    }

    if(RequiredSize) {
        *RequiredSize = TotalSpaceRequired;
    }

    //
    // See if we have a large enough output buffer.
    // If we have a large enough buffer then set up some
    // initial values in it.
    //
    if(ReturnBufferSize < TotalSpaceRequired) {
        if(UnloadInf) {
            FreeInfFile(Inf);
        } else {
            UnlockInf(Inf);
        }
        if(ReturnBuffer) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    d = NO_ERROR;

    try {
        ReturnBuffer->InfStyle = Inf->Style;
        ReturnBuffer->InfCount = InfCount;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(UnloadInf) {
            FreeInfFile(Inf);
        } else {
            UnlockInf(Inf);
        }
        SetLastError(d = ERROR_INVALID_PARAMETER);
    }

    if(d != NO_ERROR) {
        return FALSE;
    }

    Out = (PUCHAR)ReturnBuffer + offsetof(SP_INF_INFORMATION, VersionData);

    //
    // Traverse all infs associated with this inf handle and copy
    // version data into the caller's buffer. Guard with SEH to ensure
    // that the caller passed a valid buffer.
    //
    try {
        Prev = NULL;
        for(CurInf = Inf; CurInf; CurInf = CurInf->Next) {
            //
            // Store offset into
            //
            if(Prev) {
                Prev->NextOffset = (UINT)((UINT_PTR)Out - (UINT_PTR)ReturnBuffer);
            }
            Prev = (PVOID)Out;

            OriginalFilenameSize = CurInf->OriginalInfName
                                 ? (lstrlen(CurInf->OriginalInfName) + 1) * sizeof(TCHAR)
                                 : 0;

            Prev->LastWriteTime = CurInf->VersionBlock.LastWriteTime;
            Prev->DatumCount    = CurInf->VersionBlock.DatumCount;
            Prev->OffsetToData  = CurInf->VersionBlock.FilenameSize + OriginalFilenameSize;
            Prev->DataSize      = CurInf->VersionBlock.DataSize;
            Prev->TotalSize     = offsetof(INF_VERSION_BLOCK, Filename) +
                                      CurInf->VersionBlock.FilenameSize +
                                      OriginalFilenameSize +
                                      CurInf->VersionBlock.DataSize;

            Out += offsetof(INF_VERSION_BLOCK, Filename);

            //
            // Now copy the filename, (optionally) original filename, and
            // version data into the output buffer.
            //
            CopyMemory(Out, CurInf->VersionBlock.Filename, CurInf->VersionBlock.FilenameSize);
            Out += CurInf->VersionBlock.FilenameSize;

            if(CurInf->OriginalInfName) {
                CopyMemory(Out, CurInf->OriginalInfName, OriginalFilenameSize);
                Out += OriginalFilenameSize;
            }

            CopyMemory(Out, CurInf->VersionBlock.DataBlock, CurInf->VersionBlock.DataSize);
            Out += CurInf->VersionBlock.DataSize;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(UnloadInf) {
            FreeInfFile(Inf);
        } else {
            UnlockInf(Inf);
        }
        SetLastError(d = ERROR_INVALID_PARAMETER);
    }

    if(d != NO_ERROR) {
        return FALSE;
    }

    Prev->NextOffset = 0;

    //
    // Unload the inf if necessary
    //
    if(UnloadInf) {
        FreeInfFile(Inf);
    } else {
        UnlockInf(Inf);
    }

    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueryInfFileInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    WCHAR returnbuffer[MAX_PATH];
    DWORD requiredsize;
    DWORD rc;
    PSTR ansi;
    BOOL b;

    b = SetupQueryInfFileInformationW(
            InfInformation,
            InfIndex,
            returnbuffer,
            MAX_PATH,
            &requiredsize
            );

    rc = GetLastError();

    if(b) {
        if(ansi = pSetupUnicodeToAnsi(returnbuffer)) {

            rc = NO_ERROR;
            requiredsize = lstrlenA(ansi);

            if(RequiredSize) {
                try {
                    *RequiredSize = requiredsize;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    rc = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

            if(b) {
                if(ReturnBuffer) {
                    if(ReturnBufferSize >= requiredsize) {
                        //
                        // lstrcpy returns NULL if it faults
                        //
                        if(!lstrcpyA(ReturnBuffer,ansi)) {
                            rc = ERROR_INVALID_PARAMETER;
                            b = FALSE;
                        }
                    } else {
                        b = FALSE;
                        rc = ERROR_INSUFFICIENT_BUFFER;
                    }
                }
            }

            MyFree(ansi);
        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQueryInfFileInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfInformation);
    UNREFERENCED_PARAMETER(InfIndex);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueryInfFileInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PTSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    UINT FilenameLength;
    INF_VERSION_NODE VersionNode;
    DWORD rc;

    //
    // See whether the index is in range and
    // retrieve the version descriptor for this inf.
    //
    rc = NO_ERROR;
    try {
        if(!pSetupVersionNodeFromInfInformation(InfInformation,InfIndex,&VersionNode,NULL)) {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    FilenameLength = VersionNode.FilenameSize / sizeof(TCHAR);

    if(RequiredSize) {
        try {
            *RequiredSize = FilenameLength;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    //
    // Check length of user's buffer.
    //
    if(FilenameLength > ReturnBufferSize) {
        if(ReturnBuffer) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    //
    // Copy the data into user's buffer.
    //
    try {
        CopyMemory(ReturnBuffer,VersionNode.Filename,VersionNode.FilenameSize);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupQueryInfOriginalFileInformationA(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO_V2  AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO_A OriginalFileInfo
    )
{
    SP_ORIGINAL_FILE_INFO_W UnicodeOriginalFileInfo;
    DWORD rc;
    int i;
    BOOL b;

    rc = NO_ERROR;

    //
    // Do an initial check on user-supplied output buffer to see if it seems
    // to be valid.
    //
    try {
        if(OriginalFileInfo->cbSize != sizeof(SP_ORIGINAL_FILE_INFO_A)) {
            rc = ERROR_INVALID_USER_BUFFER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }

    UnicodeOriginalFileInfo.cbSize = sizeof(SP_ORIGINAL_FILE_INFO_W);

    b = SetupQueryInfOriginalFileInformationW(
            InfInformation,
            InfIndex,
            AlternatePlatformInfo,
            &UnicodeOriginalFileInfo
           );

    rc = GetLastError();

    if(b) {
        //
        // Convert the Unicode fields of the original file info structure into
        // ANSI, and store the information in the caller-supplied ANSI
        // structure.
        //
        try {
            //
            // First, translate/store the original INF name...
            //
            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    UnicodeOriginalFileInfo.OriginalInfName,
                    -1,
                    OriginalFileInfo->OriginalInfName,
                    sizeof(OriginalFileInfo->OriginalInfName),
                    NULL,
                    NULL
                    );

            //
            // ...and if that succeeded, then translate/store the original
            // catalog filename.
            //
            if(i) {
                //
                // Note that the original catalog filename may be the empty
                // string (i.e., the INF didn't specify an associated catalog
                // file).  We don't need to special-case this, since
                // WideCharToMultiByte can handle empty strings just fine.
                //
                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        UnicodeOriginalFileInfo.OriginalCatalogName,
                        -1,
                        OriginalFileInfo->OriginalCatalogName,
                        sizeof(OriginalFileInfo->OriginalCatalogName),
                        NULL,
                        NULL
                        );
            }

            if(!i) {
                b = FALSE;
                rc = GetLastError();
                //
                // If we start seeing cases where our Unicode->ANSI expansion
                // blows our buffersize, we need to know about it...
                //
                MYASSERT((rc != NO_ERROR) && (rc != ERROR_INSUFFICIENT_BUFFER));
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
            b = FALSE;
        }
    }

    SetLastError(rc);

    return b;
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupQueryInfOriginalFileInformationW(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO_V2  AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO_W OriginalFileInfo
    )
{
    UNREFERENCED_PARAMETER(InfInformation);
    UNREFERENCED_PARAMETER(InfIndex);
    UNREFERENCED_PARAMETER(AlternatePlatformInfo);
    UNREFERENCED_PARAMETER(OriginalFileInfo);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupQueryInfOriginalFileInformation(
    IN  PSP_INF_INFORMATION      InfInformation,
    IN  UINT                     InfIndex,
    IN  PSP_ALTPLATFORM_INFO_V2  AlternatePlatformInfo, OPTIONAL
    OUT PSP_ORIGINAL_FILE_INFO   OriginalFileInfo
    )

/*++

Routine Description:

    This routine returns an INF's original name (which will be different from
    its current name if the INF was installed into %windir%\Inf, for example).
    If the INF's original name is the same as its current name, the current
    name is returned.

    It also returns the original filename of the catalog file specified by the
    INF via a (potentially decorated) CatalogFile= entry in the INF's [version]
    section.  The OS/architecture-specific decoration may be overridden from
    the default (i.e., current platform) by passing in an optional alternate
    platform information structure.  If the INF doesn't specify any catalog
    file, then this field in the output OriginalFileInfo structure will be set
    to an empty string.

    Both filenames returned in the OriginalFileInfo are simple filenames, i.e.,
    there is no path information included.

Arguments:

    InfInformation - supplies context from which we retrieve information about
        the INF whose index is specified by InfIndex.

    InfIndex - supplies the zero-based index of the INF within the
        InfInformation context buffer that we're retrieving original file
        information for.

    AlternatePlatformInfo - optionally, supplies alternate platform information
        used when searching for the appropriately decorated CatalogFile= entry
        within the INF's [version] section.

        (NOTE: caller may actually pass in a V1 struct instead--we detect this
        case and convert the V1 struct into a V2 one.)

    OriginalFileInfo - supplies the address of an original file information
        buffer that upon success receives information about the original
        (simple) filenames of files associated with this INF.  This structure
        must have its cbSize field set to sizeof(SP_ORIGINAL_FILE_INFO) upon
        entry to this routine or the call will fail with GetLastError()
        returning ERROR_INVALID_USER_BUFFER.

        The fields of this structure are set upon successful return as follows:

        OriginalInfName - receives the INF's original filename, which may be
            different than its current filename in the case where the INF was
            an OEM in that was installed into the %windir%\Inf directory (e.g.,
            via SetupCopyOEMInf).

        OriginalCatalogName - receives the platform-appropriate CatalogFile=
            entry in the INF's [version] section (where the platform is the
            default native one unless AlternatePlatformInfo is supplied).  If
            there is no applicable CatalogFile= entry, this field will be set
            to the empty string.

Return Value:

    If successful, the return value is non-zero.
    If unsuccessful, the return value is FALSE, and GetLastError() may be
    called to determine the cause of failure.

--*/

{
    INF_VERSION_NODE VersionNode;
    DWORD rc;
    SP_ALTPLATFORM_INFO_V2 AltPlatformInfoV2;

    rc = NO_ERROR;
    //
    // See whether the index is in range and retrieve the version descriptor
    // and original filename for this inf.
    //
    try {
        //
        // Do an initial check on user-supplied output buffer to see if it
        // seems to be valid.
        //
        if(OriginalFileInfo->cbSize != sizeof(SP_ORIGINAL_FILE_INFO)) {
            rc = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        //
        // Now validate the AlternatePlatformInfo parameter.
        //
        if(AlternatePlatformInfo) {

            if(AlternatePlatformInfo->cbSize != sizeof(SP_ALTPLATFORM_INFO_V2)) {
                //
                // The caller may have passed us in a Version 1 struct, or they
                // may have passed us in bad data...
                //
                if(AlternatePlatformInfo->cbSize == sizeof(SP_ALTPLATFORM_INFO_V1)) {
                    //
                    // Flags/Reserved field is reserved in V1
                    //
                    if(AlternatePlatformInfo->Reserved) {
                        rc = ERROR_INVALID_PARAMETER;
                        goto clean0;
                    }
                    //
                    // Convert the caller-supplied data into Version 2 format.
                    //
                    ZeroMemory(&AltPlatformInfoV2, sizeof(AltPlatformInfoV2));

                    AltPlatformInfoV2.cbSize                = sizeof(SP_ALTPLATFORM_INFO_V2);
                    AltPlatformInfoV2.Platform              = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->Platform;
                    AltPlatformInfoV2.MajorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MajorVersion;
                    AltPlatformInfoV2.MinorVersion          = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->MinorVersion;
                    AltPlatformInfoV2.ProcessorArchitecture = ((PSP_ALTPLATFORM_INFO_V1)AlternatePlatformInfo)->ProcessorArchitecture;
                    AltPlatformInfoV2.Flags                 = 0;
                    AlternatePlatformInfo = &AltPlatformInfoV2;

                } else {
                    rc = ERROR_INVALID_USER_BUFFER;
                    goto clean0;
                }
            }

            //
            // Gotta be either Windows or Windows NT
            //
            if((AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_WINDOWS) &&
               (AlternatePlatformInfo->Platform != VER_PLATFORM_WIN32_NT)) {

                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // Processor had better be either i386, alpha, ia64, or amd64
            //
            if((AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_ALPHA) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_IA64) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_ALPHA64) &&
               (AlternatePlatformInfo->ProcessorArchitecture != PROCESSOR_ARCHITECTURE_AMD64)) {

                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // MajorVersion field must be non-zero (MinorVersion field can be
            // anything)
            //
            if(!AlternatePlatformInfo->MajorVersion) {
                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // Validate structure parameter flags (bits indicating what
            // parts of the structure are valid).
            //
            if((AlternatePlatformInfo->Flags & ~ (SP_ALTPLATFORM_FLAGS_VERSION_RANGE)) != 0) {
                rc = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            //
            // fill in version validation range if none supplied by caller
            //
            if((AlternatePlatformInfo->Flags & SP_ALTPLATFORM_FLAGS_VERSION_RANGE) == 0) {
                //
                // If caller does not know about FirstValidate*Version,
                // version upper and lower bounds are equal.
                //
                AlternatePlatformInfo->FirstValidatedMajorVersion = AlternatePlatformInfo->MajorVersion;
                AlternatePlatformInfo->FirstValidatedMinorVersion = AlternatePlatformInfo->MinorVersion;
                AlternatePlatformInfo->Flags |= SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
            }


        }

        //
        // OK, now retrieve the INF's original filename...
        //
        if(!pSetupVersionNodeFromInfInformation(InfInformation,
                                                InfIndex,
                                                &VersionNode,
                                                OriginalFileInfo->OriginalInfName)) {
            rc = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // ...and retrieve the (platform-appropriate) catalog file associated
        // with this INF (if there is one).
        //
        if(!pSetupGetCatalogFileValue(&VersionNode,
                                      OriginalFileInfo->OriginalCatalogName,
                                      SIZECHARS(OriginalFileInfo->OriginalCatalogName),
                                      AlternatePlatformInfo)) {
            //
            // No applicable CatalogFile= entry found--set field to empty
            // string.
            //
            *(OriginalFileInfo->OriginalCatalogName) = TEXT('\0');
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQueryInfVersionInformationA(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCSTR               Key,              OPTIONAL
    OUT PSTR                ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    INF_VERSION_NODE VersionNode;
    PCWSTR Data;
    DWORD rc;
    PSTR ansidata;
    UINT ansilength;
    PCWSTR key;

    //
    // See whether the index is in range and
    // get pointer to version descriptor for this inf.
    //
    try {
        if(pSetupVersionNodeFromInfInformation(InfInformation,InfIndex,&VersionNode,NULL)) {
            //
            // See whether we want a specific value.
            //
            if(Key) {

                rc = pSetupCaptureAndConvertAnsiArg(Key,&key);
                if(rc == NO_ERROR) {

                    if(Data = pSetupGetVersionDatum(&VersionNode,key)) {

                        if(ansidata = pSetupUnicodeToAnsi(Data)) {

                            ansilength = lstrlenA(ansidata) + 1;
                            if(RequiredSize) {
                                *RequiredSize = ansilength;
                            }

                            if(ReturnBuffer) {
                                if(ReturnBufferSize >= ansilength) {
                                    CopyMemory(ReturnBuffer,ansidata,ansilength);
                                    rc = NO_ERROR;
                                } else {
                                    rc = ERROR_INSUFFICIENT_BUFFER;
                                }
                            } else {
                                rc = NO_ERROR;
                            }

                            MyFree(ansidata);
                        } else {
                            rc = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    } else {
                        rc = ERROR_INVALID_DATA;
                    }

                    MyFree(key);
                }
            } else {
                //
                // Caller wants all values. Copy whole data block to caller's buffer,
                // plus a terminating NUL character.
                //
                // Maximum size the data could be in ansi is the exact same
                // size it is in unicode, if every char is a double-byte char.
                //
                if(ansidata = MyMalloc(VersionNode.DataSize)) {

                    ansilength = WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    (PWSTR)VersionNode.DataBlock,
                                    VersionNode.DataSize / sizeof(WCHAR),
                                    ansidata,
                                    VersionNode.DataSize,
                                    NULL,
                                    NULL
                                    );

                    if(RequiredSize) {
                        //
                        // account for terminating nul
                        //
                        *RequiredSize = ansilength+1;
                    }

                    if(ReturnBuffer) {
                        if(ReturnBufferSize >= *RequiredSize) {
                            CopyMemory(ReturnBuffer,ansidata,ansilength);
                            ReturnBuffer[ansilength] = 0;
                            rc = NO_ERROR;
                        } else {
                            rc = ERROR_INSUFFICIENT_BUFFER;
                        }
                    } else {
                        rc = NO_ERROR;
                    }

                    MyFree(ansidata);
                } else {
                    rc = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        } else {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
SetupQueryInfVersionInformationW(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCWSTR              Key,              OPTIONAL
    OUT PWSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfInformation);
    UNREFERENCED_PARAMETER(InfIndex);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQueryInfVersionInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    IN  PCTSTR              Key,              OPTIONAL
    OUT PTSTR               ReturnBuffer,     OPTIONAL
    IN  DWORD               ReturnBufferSize,
    OUT PDWORD              RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    INF_VERSION_NODE VersionNode;
    PCTSTR Data;
    UINT DataLength;
    DWORD rc;

    //
    // See whether the index is in range and
    // get pointer to version descriptor for this inf.
    //
    try {
        if(pSetupVersionNodeFromInfInformation(InfInformation,InfIndex,&VersionNode,NULL)) {
            //
            // See whether we want a specific value.
            //
            if(Key) {
                if(Data = pSetupGetVersionDatum(&VersionNode,Key)) {

                    DataLength = lstrlen(Data) + 1;
                    if(RequiredSize) {
                        *RequiredSize = DataLength;
                    }

                    if(ReturnBuffer) {
                        if(ReturnBufferSize >= DataLength) {
                            CopyMemory(ReturnBuffer,Data,DataLength * sizeof(TCHAR));
                            rc = NO_ERROR;
                        } else {
                            rc = ERROR_INSUFFICIENT_BUFFER;
                        }
                    } else {
                        rc = NO_ERROR;
                    }
                } else {
                    rc = ERROR_INVALID_DATA;
                }
            } else {
                //
                // Caller wants all values. Copy whole data block to caller's buffer,
                // plus a terminating NUL character.
                //
                DataLength = (VersionNode.DataSize / sizeof(TCHAR)) + 1;
                if(RequiredSize) {
                    *RequiredSize = DataLength;
                }

                if(ReturnBuffer) {
                    if(ReturnBufferSize >= DataLength) {
                        CopyMemory(ReturnBuffer,VersionNode.DataBlock,VersionNode.DataSize);
                        ReturnBuffer[VersionNode.DataSize/sizeof(TCHAR)] = 0;
                        rc = NO_ERROR;
                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                    }
                } else {
                    rc = NO_ERROR;
                }
            }
        } else {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}



BOOL
_SetupGetInfFileList(
    IN  PCTSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PVOID  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
#ifdef UNICODE
    IN ,BOOL   ConvertToAnsi
#endif
    )
{
    TCHAR SearchSpec[MAX_PATH];
    PTCHAR FilenameStart;
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;
    DWORD Style;
    UINT FileNameLength;
    DWORD RemainingSpaceInBuffer;
    DWORD CurrentOffsetInBuffer;
    DWORD TotalSpaceNeededInBuffer;
    BOOL InsufficientBuffer;
    DWORD d;
    PTSTR DontCare;
#ifdef UNICODE
    CHAR ansi[MAX_PATH];
#endif

    //
    // Set up the search directory
    //
    if(DirectoryPath) {
        //
        // Make sure this directory path is fully-qualified.
        //
        d = GetFullPathName(DirectoryPath,
                            SIZECHARS(SearchSpec),
                            SearchSpec,
                            &DontCare
                           );

        if(!d) {
            //
            // LastError has already been set.
            //
            return FALSE;
        } else if(d >= SIZECHARS(SearchSpec)) {
            MYASSERT(0);
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }

    } else {
        lstrcpyn(SearchSpec, InfDirectory,SIZECHARS(SearchSpec));
    }

    pSetupConcatenatePaths(SearchSpec, pszInfWildcard, SIZECHARS(SearchSpec), NULL);
    FilenameStart = (PTSTR)pSetupGetFileTitle(SearchSpec);

    FindHandle = FindFirstFile(SearchSpec,&FindData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        d = GetLastError();
        if((d == ERROR_NO_MORE_FILES) || (d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
            if(RequiredSize) {
                d = NO_ERROR;
                try {
                    *RequiredSize = 1;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    d = ERROR_INVALID_PARAMETER;
                }
                if(d != NO_ERROR) {
                    SetLastError(d);
                    return(FALSE);
                }
            }
            if(ReturnBuffer) {
                if(ReturnBufferSize) {
                    d = NO_ERROR;
                    try {
#ifdef UNICODE
                        if(ConvertToAnsi) {
                            *(PCHAR)ReturnBuffer = 0;
                        } else
#endif
                        *(PTCHAR)ReturnBuffer = 0;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        d = ERROR_INVALID_PARAMETER;
                    }
                    SetLastError(d);
                    return(d == NO_ERROR);
                } else {
                    SetLastError(ERROR_INSUFFICIENT_BUFFER);
                    return FALSE;
                }
            } else {
                return TRUE;
            }
        }
        SetLastError(d);
        return(FALSE);
    }

    //
    // Leave space for the extra terminating nul char.
    //
    RemainingSpaceInBuffer = ReturnBufferSize;
    if(RemainingSpaceInBuffer) {
        RemainingSpaceInBuffer--;
    }

    TotalSpaceNeededInBuffer = 1;
    CurrentOffsetInBuffer = 0;

    InsufficientBuffer = FALSE;
    d = NO_ERROR;

    do {
        //
        // Skip directories
        //
        if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            continue;
        }

        //
        // Form full pathname of file in SearchSpec.
        //
        lstrcpy(FilenameStart,FindData.cFileName);

        //
        // Determine the inf type and see whether the caller
        // wants to know about infs of this type.
        //
        Style = DetermineInfStyle(SearchSpec, &FindData);
        if((Style == INF_STYLE_NONE) || !(Style & InfStyle)) {
            continue;
        }

        //
        // Got a legit inf file.
        //
#ifdef UNICODE
        if(ConvertToAnsi) {
            //
            // The nul is included because it's converted
            // so no need to add 1
            //
            FileNameLength = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                FindData.cFileName,
                                -1,
                                ansi,
                                MAX_PATH,
                                NULL,
                                NULL
                                );
        } else
#endif
        FileNameLength = lstrlen(FindData.cFileName) + 1;

        TotalSpaceNeededInBuffer += FileNameLength;

        if(ReturnBuffer) {

            if(RemainingSpaceInBuffer >= FileNameLength ) {

                RemainingSpaceInBuffer -= FileNameLength;

                //
                // lstrcpy will return NULL if it faults
                //
#ifdef UNICODE
                if(ConvertToAnsi) {
                    DontCare = (PVOID)lstrcpyA((PCHAR)ReturnBuffer+CurrentOffsetInBuffer,ansi);
                } else
#endif
                DontCare = lstrcpy((PTCHAR)ReturnBuffer+CurrentOffsetInBuffer,FindData.cFileName);

                if(!DontCare) {

                    d = ERROR_INVALID_PARAMETER;

                } else {

                    CurrentOffsetInBuffer += FileNameLength;

                    try {
#ifdef UNICODE
                        if(ConvertToAnsi) {
                            ((PCHAR)ReturnBuffer)[CurrentOffsetInBuffer] = 0;
                        } else
#endif
                        ((PTCHAR)ReturnBuffer)[CurrentOffsetInBuffer] = 0;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        d = ERROR_INVALID_PARAMETER;
                    }
                }
            } else {
                InsufficientBuffer = TRUE;
            }
        }

    } while((d == NO_ERROR) && FindNextFile(FindHandle,&FindData));

    FindClose(FindHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
    }

    if(GetLastError() == ERROR_NO_MORE_FILES) {

        d = NO_ERROR;

        try {
            if(RequiredSize) {
                *RequiredSize = TotalSpaceNeededInBuffer;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }

        if(d == NO_ERROR) {
            if(InsufficientBuffer) {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return FALSE;
            }
            return(TRUE);
        } else {
            SetLastError(d);
        }
    }

    //
    // Last error already set
    //
    return(FALSE);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetInfFileListA(
    IN  PCSTR  DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    PWSTR dirpath;
    DWORD rc;
    BOOL b;

    if(DirectoryPath) {
        rc = pSetupCaptureAndConvertAnsiArg(DirectoryPath,&dirpath);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        dirpath = NULL;
    }


    b = _SetupGetInfFileList(dirpath,InfStyle,ReturnBuffer,ReturnBufferSize,RequiredSize,TRUE);
    rc = GetLastError();

    if(dirpath) {
        MyFree(dirpath);
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetInfFileListW(
    IN  PCWSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(DirectoryPath);
    UNREFERENCED_PARAMETER(InfStyle);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetInfFileList(
    IN  PCTSTR DirectoryPath,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PTSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PTSTR dirpath;
    DWORD rc;
    BOOL b;

    if(DirectoryPath) {
        rc = CaptureStringArg(DirectoryPath,&dirpath);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    } else {
        dirpath = NULL;
    }


    b = _SetupGetInfFileList(
            dirpath,
            InfStyle,
            ReturnBuffer,
            ReturnBufferSize,
            RequiredSize
#ifdef UNICODE
           ,FALSE
#endif
            );

    rc = GetLastError();

    if(dirpath) {
        MyFree(dirpath);
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
HINF
SetupOpenInfFileA(
    IN  PCSTR FileName,
    IN  PCSTR InfType,     OPTIONAL
    IN  DWORD InfStyle,
    OUT PUINT ErrorLine    OPTIONAL
    )
{
    PCTSTR fileName,infType;
    DWORD err;
    HINF h;

    err = NO_ERROR;
    fileName = NULL;
    infType = NULL;

    //
    // Set error line to 0 since ansi arg conversion could fail
    // and we need to indicate that there's no error in the inf itself.
    //
    if(ErrorLine) {
        try {
            *ErrorLine = 0;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            err = ERROR_INVALID_PARAMETER;
        }
    }

    if(err == NO_ERROR) {
        err = pSetupCaptureAndConvertAnsiArg(FileName,&fileName);
        if((err == NO_ERROR) && InfType) {
            err = pSetupCaptureAndConvertAnsiArg(InfType,&infType);
        }
    }

    if(err == NO_ERROR) {
        h = SetupOpenInfFileW(fileName,infType,InfStyle,ErrorLine);
        err = GetLastError();
    } else {
        h = INVALID_HANDLE_VALUE;
    }

    if(fileName) {
        MyFree(fileName);
    }
    if(infType) {
        MyFree(infType);
    }

    SetLastError(err);
    return(h);
}
#else
//
// Unicode stub
//
HINF
SetupOpenInfFileW(
    IN  PCWSTR FileName,
    IN  PCWSTR InfType,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine   OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(InfType);
    UNREFERENCED_PARAMETER(InfStyle);
    UNREFERENCED_PARAMETER(ErrorLine);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(INVALID_HANDLE_VALUE);
}
#endif


HINF
SetupOpenInfFile(
    IN  PCTSTR FileName,
    IN  PCTSTR InfClass,    OPTIONAL
    IN  DWORD  InfStyle,
    OUT PUINT  ErrorLine    OPTIONAL
    )

/*++

Routine Description:

    This routine opens an INF file and returns a handle to it.

Arguments:

    FileName - Supplies the address of a NULL-terminated string containing
        the name (and optionally, the path) of the INF file to be opened.  If
        the filename contains no path separator characters, it is searched for
        first in the %windir%\inf directory, and then in the %windir%\system32
        directory.  Otherwise, the name is assumed to be a full path
        specification, and no is opened as-is.

    InfClass - Optionally, supplies the address of a NULL-terminated string
        containing the class of the INF file desired.  For old-style (i.e.,
        Windows NT 3.x script-base) INF files, this string must match the type
        specified in the OptionType value of the [Identification] section of the
        INF (e.g., OptionType=NetAdapter).  For Windows 95-compatibile INF
        files, this string must match the class of the specified INF.  If the
        INF has a Class value in its [version] section, then this value is used
        for the comparison.  If no Class value is present, but a ClassGUID value
        is present in the [version] section, then the corresponding class name
        for that GUID is retrieved, and comparison is done based on that name.

    InfStyle - Specifies the style of the INF to open.  May be a combination of
        the following flags:

            INF_STYLE_OLDNT - Windows NT 3.x script-based INF files.

            INF_STYLE_WIN4 - Windows 95-compatible INF files.

            INF_STYLE_CACHE_ENABLE - always cache INF, even outside of
                %windir%\Inf.

            INF_STYLE_CACHE_DISABLE - delete INF from cache, if outside of
                %windir%\Inf.

    ErrorLine - If an error occurs loading the file, this parameter receives the
        (1-based) line number where the error occurred.  This value is generally
        reliable only if GetLastError does not return ERROR_NOT_ENOUGH_MEMORY.
        If out-of-memory does occur, the ErrorLine may be 0.

Return Value:

    If the function succeeds, the return value is a handle to the opened INF
    file.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

Remarks:

    If the load fails because the INF class does not match InfClass, the
    function returns FALSE, and GetLastError returns ERROR_CLASS_MISMATCH.

    The SetupCloseInfFile function is used to close a handle returned by
    SetupOpenInfFile.

    If multiple INF styles are specified, the style of the INF file opened may
    be ascertained by calling SetupGetInfInformation.

    Since there may be multiple class GUIDs all having the same class name,
    callers interested in only INFs of a particular class (i.e., a particular
    class GUID) should retrieve the ClassGuid value from the INF to verify that
    the class matches exactly.

    If both the INF_STYLE_CACHE_ENABLE and INF_STYLE_CACHE_DISABLE InfStyle
    flags are specified, then the existing cached information that is maintained
    about the INF (e.g., original source location) is discarded, and the INF is
    re-added to the cache without this old information.

    (Internal:  Presently, the INF_STYLE_CACHE_ENABLE and
    INF_STYLE_CACHE_DISABLE flags cause us to create or delete PNFs outside of
    %windir%\Inf.  Their rather vague-sounding names were chosen to reflect the
    possibility of modifying the caching/indexing scheme in the future.)

--*/

{
    UINT errorLine;
    DWORD d;
    PLOADED_INF Inf;
    PCTSTR Class;
    TCHAR TempString[MAX_PATH];
    GUID ClassGuid;
    HRESULT hr;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    PTSTR DontCare;
    PTSTR TempCharPtr = NULL;

    //
    // Determine whether just the filename (no path) was specified.  If so,
    // look for it in the DevicePath directory search path.  Otherwise,
    // use the path as-is.
    //
    try {
        if(FileName == pSetupGetFileTitle(FileName)) {
            //
            // The specified INF name is a simple filename.  Search for it in
            // the INF directories using the default search order.
            //
            d = SearchForInfFile(
                    FileName,
                    &FindData,
                    INFINFO_DEFAULT_SEARCH,
                    TempString,
                    SIZECHARS(TempString),
                    NULL
                    );

            if(d == NO_ERROR) {
                TryPnf = TRUE;
            }
        } else {
            //
            // The specified INF filename contains more than just a filename.
            // Assume it's an absolute path.  (We need to make sure it's
            // fully-qualified, because that's what LoadInfFile expects.)
            //
            d = GetFullPathName(FileName,
                                SIZECHARS(TempString),
                                TempString,
                                &DontCare
                               );
            if(!d) {
                d = GetLastError();
            } else if(d >= SIZECHARS(TempString)) {
                MYASSERT(0);
                d = ERROR_BUFFER_OVERFLOW;
            } else {
                //
                // We successfully retrieved the full pathname, now see if the
                // file exists.
                //
                if(FileExists(TempString, &FindData)) {
                    //
                    // We have everything we need to load this INF.
                    //
                    InfSourcePathFromFileName(TempString, &TempCharPtr, &TryPnf);
                    d = NO_ERROR;
                } else {
                    d = GetLastError();
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume FileName was invalid and thus pSetupGetFileTitle fell over.
        //
        d = ERROR_INVALID_PARAMETER;
        TempCharPtr = TempCharPtr;
    }

    if(d != NO_ERROR) {
        goto PrepareForReturn;
    }

    if(InfStyle & INF_STYLE_CACHE_DISABLE) {
        //
        // Delete the existing PNF for this INF (if any).
        //
        TCHAR PnfFullPath[MAX_PATH];
        PTSTR PnfFileName, PnfFileExt;

        lstrcpy(PnfFullPath, TempString);

        //
        // Find the start of the filename component of the path, and then find
        // the last period (if one exists) in that filename.
        //
        PnfFileName = (PTSTR)pSetupGetFileTitle(PnfFullPath);
        if(!(PnfFileExt = _tcsrchr(PnfFileName, TEXT('.')))) {
            PnfFileExt = PnfFullPath + lstrlen(PnfFullPath);
        }

        //
        // Now create a corresponding filename with the extension '.PNF'
        //
        lstrcpyn(PnfFileExt, pszPnfSuffix, SIZECHARS(PnfFullPath) - (int)(PnfFileExt - PnfFullPath));

        SetFileAttributes(PnfFullPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(PnfFullPath);
    }

    if(InfStyle & INF_STYLE_CACHE_ENABLE) {
        //
        // The caller has requested that this INF be cached (even though it may
        // be outside of our INF search path).
        //
        TryPnf = TRUE;
    }

    try {
        d = LoadInfFile(
                TempString,
                &FindData,
                InfStyle,
                TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0,
                NULL,
                TempCharPtr,
                NULL,
                NULL,
                NULL, // LogContext
                &Inf,
                &errorLine,
                NULL
                );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    if(d == NO_ERROR) {

        if(InfClass) {

            d = ERROR_CLASS_MISMATCH;   // assume mismatch

            //
            // Match based on class of inf. The following check works for
            // both new and old style infs, because old-style infs use
            // [Identification].OptionType as the class (see oldinf.c
            // function ProcessOldInfVersionBlock()).
            //
            if(Class = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClass)) {
                try {
                    if(!lstrcmpi(Class,InfClass)) {
                        d = NO_ERROR;
                    }
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    d = ERROR_INVALID_PARAMETER;
                }
            } else {
                //
                // No Class entry--check for ClassGUID entry.
                //
                if(Class = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClassGuid)) {
                    //
                    // Get the class name associated with this GUID, and see if it
                    // matches the caller-supplied class name.
                    //
                    // (We have to cast away the CONST-ness of the Class string, because
                    // the prototype for CLSIDFromString doesn't specify this parameter
                    // as constant.)
                    //
                    if((hr = pSetupGuidFromString((PTSTR)Class, &ClassGuid)) == S_OK) {

                        if(SetupDiClassNameFromGuid(&ClassGuid,
                                                    TempString,
                                                    SIZECHARS(TempString),
                                                    NULL)) {

                            try {
                                if(!lstrcmpi(TempString,InfClass)) {
                                    d = NO_ERROR;
                                }
                            } except(EXCEPTION_EXECUTE_HANDLER) {
                                d = ERROR_INVALID_PARAMETER;
                            }
                        }
                    } else {
                        if(hr == E_OUTOFMEMORY) {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                }
            }

            if(d != NO_ERROR) {
                FreeInfFile(Inf);
            }
        }

    } else {
        if(ErrorLine) {
            try {
                *ErrorLine = errorLine;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                d = ERROR_INVALID_PARAMETER;
            }
        }
    }

PrepareForReturn:

    if(TempCharPtr) {
        MyFree(TempCharPtr);
    }

    SetLastError(d);

    return((d == NO_ERROR) ? (HINF)Inf : (HINF)INVALID_HANDLE_VALUE);
}


HINF
SetupOpenMasterInf(
    VOID
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    TCHAR FileName[MAX_PATH];

    lstrcpyn(FileName,InfDirectory,SIZECHARS(FileName)-11);
    lstrcat(FileName,TEXT("\\LAYOUT.INF"));

    return(SetupOpenInfFile(FileName,NULL,INF_STYLE_WIN4,NULL));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupOpenAppendInfFileA(
    IN  PCSTR  FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    PCWSTR fileName = NULL;
    DWORD d;
    BOOL b;

    //
    // Set error line to 0 since ansi arg conversion could fail
    // and we need to indicate that there's no error in the inf itself.
    //
    d = NO_ERROR;
    if(ErrorLine) {
        try {
            *ErrorLine = 0;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    }

    if(d == NO_ERROR) {
        if(FileName) {
            d = pSetupCaptureAndConvertAnsiArg(FileName,&fileName);
        } else {
            fileName = NULL;
        }
    }

    if(d == NO_ERROR) {
        b = SetupOpenAppendInfFileW(fileName,InfHandle,ErrorLine);
        d = GetLastError();
    } else {
        b = FALSE;
    }

    if(fileName) {
        MyFree(fileName);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupOpenAppendInfFileW(
    IN  PCWSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(ErrorLine);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupOpenAppendInfFile(
    IN  PCTSTR FileName,    OPTIONAL
    IN  HINF   InfHandle,
    OUT PUINT  ErrorLine    OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF ExistingInf = NULL, CurInf = NULL;
    DWORD d = NO_ERROR;
    TCHAR Filename[2][MAX_PATH];
    UINT FilenameCount, i, Field;
    UINT errorLine = 0;
    BOOL LookInInfDirAlso;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    PTSTR TempCharPtr = NULL;
    PTSTR DontCare;
    PINF_SECTION InfSection;
    UINT LineNumber;
    PINF_LINE InfLine = NULL;

    try {

        if(LockInf((PLOADED_INF)InfHandle)) {
            ExistingInf = (PLOADED_INF)InfHandle;
        } else {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // Check INF Signature field as a further validation on the InfHandle.
        //
        if(ExistingInf->Signature != LOADED_INF_SIG) {
            d = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // Only allow this for win95-style infs.
        //
        if(ExistingInf->Style != INF_STYLE_WIN4) {
            d = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // If there is no filename, search through the list of existing INFs, looking
        // for a layout entry in their version blocks.  We begin at the end of the list,
        // and search backward, using the first layout file we encounter.  This allows
        // for the possibility of append-loading several INFs together (e.g., as done by the
        // optional components dialog), and calling SetupOpenAppendInfFile with no filename
        // for each.  Each INF could specify its own layout file, and everything works great.
        // (NOTE: In the above example, if all the INFs specified the same layout file, it
        // would only get loaded once, as expected.)
        //
        // We also can now handle 'LayoutFile' entries that specify multiple layout files.  E.g.,
        //
        //     LayoutFile = pluslay.inf, layout.inf
        //
        // In the above example, we would append-load 'pluslay.inf', followed by 'layout.inf'.
        // Because of the way we store INFs, any duplicate entries in both INFs would resolve in
        // favor of pluslay.inf, since it was loaded first (unless, of course, layout.inf was
        // already in our list of loaded INFs).
        //
        if(!FileName) {
            //
            // First, find the end of the list.
            //
            for(CurInf = ExistingInf; CurInf->Next; CurInf = CurInf->Next);

            //
            // Now, search the list, back-to-front, looking for a layout file in each INF's
            // [version] section.
            //
            for(; CurInf; CurInf = CurInf->Prev) {
                //
                // Locate the [Version] section.
                //
                if(InfSection = InfLocateSection(CurInf, pszVersion, NULL)) {
                    //
                    // Now look for a LayoutFile line.
                    //
                    LineNumber = 0;
                    if(InfLocateLine(CurInf, InfSection, pszLayoutFile, &LineNumber, &InfLine)) {
                        //
                        // We've found the line containing the INFs to be append-
                        // loaded.  Get the first field on the line to start off
                        // our loop below.
                        //
                        FileName = InfGetField(CurInf, InfLine, 1, NULL);
                        break;
                    } else {
                        //
                        // Make sure InfLine is still NULL, so we won't try to use it.
                        //
                        InfLine = NULL;
                    }
                }
            }

            if(!FileName) {
                //
                // Then we didn't find any INFs that specify a layout file.
                //
                d = ERROR_INVALID_DATA;
                goto clean0;
            }
        }

        //
        // Now append-load the INF (or the possibly multiple INFs, if we're
        // using a LayoutFile line).
        //
        for(Field = 1;
            FileName;
            FileName = InfLine ? InfGetField(CurInf, InfLine, ++Field, NULL) : NULL) {

            FilenameCount = 0;
            LookInInfDirAlso = TRUE;
            TryPnf = FALSE;

            //
            // Determine whether just the filename (no path) was specified.
            //
            if(FileName == pSetupGetFileTitle(FileName)) {
                //
                // If we retrieved this filename from an INF's [version] section,
                // then we first attempt to open up the layout file from the
                // directory where we found the INF.  If we don't find it in that
                // directory, and that directory wasn't the Inf directory, then
                // we try to open it up in %windir%\Inf as well.
                //
                if(CurInf) {
                    //
                    // Copy the path without the ending backslash character,
                    // because that's how the 'InfDirectory' string is formatted.
                    //
                    lstrcpyn(Filename[0],
                             CurInf->VersionBlock.Filename,
                             (int)(pSetupGetFileTitle(CurInf->VersionBlock.Filename) - CurInf->VersionBlock.Filename)
                            );

                    //
                    // Compare this path against the InfDirectory path, to see
                    // if they're the same.
                    //
                    if(!lstrcmpi(Filename[0], InfDirectory)) {
                        TryPnf = TRUE;
                        LookInInfDirAlso = FALSE;
                    }

                    //
                    // Now concatenate the layout filename onto the path.
                    //
                    pSetupConcatenatePaths(Filename[0], FileName, MAX_PATH, NULL);
                    FilenameCount = 1;

                    //
                    // If 'TryPnf' is still FALSE, then that means that the INF
                    // wasn't in the INF directory.  Now find out if it's in a
                    // location that requires a non-NULL SourcePath (i.e.,
                    // something other than the default).
                    //
                    if(!TryPnf) {
                        InfSourcePathFromFileName(Filename[0], &TempCharPtr, &TryPnf);
                    }
                }

                if(LookInInfDirAlso) {
                    lstrcpy(Filename[FilenameCount], InfDirectory);
                    pSetupConcatenatePaths(Filename[FilenameCount], FileName, MAX_PATH, NULL);

                    if(!FilenameCount) {
                        TryPnf = TRUE;
                    }

                    FilenameCount++;
                }

            } else {
                //
                // The INF filename contains more than just a filename.  Assume
                // it's an absolute path.  (We need to make sure it's fully-
                // qualified, because that's what LoadInfFile expects.)
                //
                d = GetFullPathName(FileName,
                                    SIZECHARS(Filename[0]),
                                    Filename[0],
                                    &DontCare
                                   );
                if(!d) {
                    d = GetLastError();
                    goto clean0;
                } else if(d >= SIZECHARS(Filename[0])) {
                    MYASSERT(0);
                    d = ERROR_BUFFER_OVERFLOW;
                    goto clean0;
                }

                InfSourcePathFromFileName(Filename[0], &TempCharPtr, &TryPnf);
                FilenameCount = 1;
                //
                // (Since we're setting FilenameCount to 1, we know we'll go
                // through the loop below at least once, thus d will get set to
                // the proper error, so we don't have to re-initialize it to
                // NO_ERROR here.)
                //
            }

            for(i = 0; i < FilenameCount; i++) {
                //
                // Load the inf
                //
                if(FileExists(Filename[i], &FindData)) {

                    if((d = LoadInfFile(Filename[i],
                                        &FindData,
                                        INF_STYLE_WIN4,
                                        (i | TryPnf) ? LDINF_FLAG_ALWAYS_TRY_PNF : 0,
                                        NULL,
                                        (i | TryPnf) ? NULL : TempCharPtr,
                                        NULL,
                                        ExistingInf,
                                        ExistingInf->LogContext,
                                        &ExistingInf,
                                        &errorLine,
                                        NULL)) == NO_ERROR) {
                        break;
                    }
                } else {
                    d = GetLastError();
                }
            }

            //
            // We no longer need the INF source path--free it if necessary.
            //
            if(TempCharPtr) {
                MyFree(TempCharPtr);
                TempCharPtr = NULL;
            }

            if(d != NO_ERROR) {
                break;
            }
        }

clean0:
        //
        // If the caller requested it, give them the line number at which any error occurred.
        // (This may be zero on non-parse errors.)
        //
        if(ErrorLine) {
            *ErrorLine = errorLine;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we hit an AV, then use invalid parameter error, otherwise, assume an inpage error when dealing
        // with a mapped-in file.
        //
        d = (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ? ERROR_INVALID_PARAMETER : ERROR_READ_FAULT;

        if(TempCharPtr) {
            MyFree(TempCharPtr);
        }

        //
        // Access the 'ExistingInf' variable, so that the compiler will respect our statement
        // ordering w.r.t. this variable.  Otherwise, we may not always know whether or not
        // we should be unlocking this INF.
        //
        ExistingInf = ExistingInf;
    }

    if(ExistingInf) {
        UnlockInf(ExistingInf);
    }

    SetLastError(d);

    return(d == NO_ERROR);
}


VOID
SetupCloseInfFile(
    IN HINF InfHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf, NextInf;

    try {
        //
        // Make sure we can lock the head of the INF list before
        // we start deleting!
        //
        if(LockInf((PLOADED_INF)InfHandle)) {
            //
            // Also check INF Signature field as a further validation.
            //
            if(((PLOADED_INF)InfHandle)->Signature == LOADED_INF_SIG) {

                CurInf = ((PLOADED_INF)InfHandle)->Next;

                DestroySynchronizedAccess(&(((PLOADED_INF)InfHandle)->Lock));
                FreeLoadedInfDescriptor((PLOADED_INF)InfHandle);

                for(; CurInf; CurInf = NextInf) {
                    NextInf = CurInf->Next;
                    FreeInfFile(CurInf);
                }

            } else {
                UnlockInf((PLOADED_INF)InfHandle);
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupVerifyInfFileA(
    IN  PCSTR                   InfName,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                OPTIONAL
    OUT PSP_INF_SIGNER_INFO_A   InfSignerInfo
    )
{
    DWORD Err = NO_ERROR;
    SP_INF_SIGNER_INFO_W InfSignerInfoW;
    int i;
    PWSTR InfNameUnicode = NULL;

    try {

        if (!InfName) {
            SetLastError(ERROR_INVALID_PARAMETER);
            leave;
        }

        if (!InfSignerInfo || (InfSignerInfo->cbSize != sizeof(SP_INF_SIGNER_INFO_A))) {
            SetLastError(ERROR_INVALID_PARAMETER);
            leave;      // exit try block
        }


        Err = pSetupCaptureAndConvertAnsiArg(InfName, &InfNameUnicode);

        if (Err != NO_ERROR) {
            leave;      // exit try block
        }

        InfSignerInfoW.cbSize = sizeof(InfSignerInfoW);

        Err = SetupVerifyInfFile(InfNameUnicode,
                                 AltPlatformInfo,
                                 &InfSignerInfoW
                                 );

        if (Err == NO_ERROR) {

            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    InfSignerInfoW.CatalogFile,
                    -1,
                    InfSignerInfo->CatalogFile,
                    sizeof(InfSignerInfo->CatalogFile),
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                Err = GetLastError();
                leave;              // exit try block
            }

            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    InfSignerInfoW.DigitalSigner,
                    -1,
                    InfSignerInfo->DigitalSigner,
                    sizeof(InfSignerInfo->DigitalSigner),
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                Err = GetLastError();
                leave;              // exit try block
            }

            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    InfSignerInfoW.DigitalSignerVersion,
                    -1,
                    InfSignerInfo->DigitalSignerVersion,
                    sizeof(InfSignerInfo->DigitalSignerVersion),
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                Err = GetLastError();
                leave;              // exit try block
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if (InfNameUnicode) {
        MyFree(InfNameUnicode);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupVerifyInfFileW(
    IN  PCWSTR                  InfName,
    IN  PSP_ALTPLATFORM_INFO    AltPlatformInfo,                OPTIONAL
    OUT PSP_INF_SIGNER_INFO_W   InfSignerInfo
    )
{
    UNREFERENCED_PARAMETER(InfName);
    UNREFERENCED_PARAMETER(AltPlatformInfo);
    UNREFERENCED_PARAMETER(InfSignerInfo);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
WINAPI
SetupVerifyInfFile(
    IN  LPCTSTR                 InfName,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                OPTIONAL
    OUT PSP_INF_SIGNER_INFO     InfSignerInfo
    )
/*++

Routine Description:


Arguments:

    InfName - Supplies the name of the INF file for which to retrieve class information.
        This name may include a path.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = NO_ERROR;
    TCHAR PathBuffer[MAX_PATH];
    PLOADED_INF Inf = NULL;
    BOOL PnfWasUsed;
    UINT ErrorLineNumber;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    DWORD TempRequiredSize;
    PTSTR DontCare;

    try {

        if (!InfName) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if (!InfSignerInfo || (InfSignerInfo->cbSize != sizeof(SP_INF_SIGNER_INFO))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(InfName == pSetupGetFileTitle(InfName)) {
            //
            // The specified INF name is a simple filename.  Search for it in
            // the DevicePath search path list.
            //
            Err = SearchForInfFile(InfName,
                                   &FindData,
                                   INFINFO_INF_PATH_LIST_SEARCH,
                                   PathBuffer,
                                   SIZECHARS(PathBuffer),
                                   NULL
                                  );
            if(Err == NO_ERROR) {
                TryPnf = TRUE;
            } else {
                leave;
            }

        } else {
            //
            // The specified INF filename contains more than just a filename.
            // Assume it's an absolute path.  (We need to make sure it's
            // fully-qualified, because that's what LoadInfFile expects.)
            //
            TempRequiredSize = GetFullPathName(InfName,
                                               SIZECHARS(PathBuffer),
                                               PathBuffer,
                                               &DontCare
                                              );
            if(!TempRequiredSize) {
                Err = GetLastError();
                leave;
            } else if(TempRequiredSize >= SIZECHARS(PathBuffer)) {
                MYASSERT(0);
                Err = ERROR_BUFFER_OVERFLOW;
                leave;
            }

            if(FileExists(PathBuffer, &FindData)) {
                //
                // We have a valid file path, and we're ready to load this INF.
                //
                InfSourcePathFromFileName(PathBuffer, NULL, &TryPnf);
            } else {
                Err = GetLastError();
                leave;
            }
        }

        //
        // Load the INF.
        //
        Err = LoadInfFile(PathBuffer,
                          &FindData,
                          INF_STYLE_WIN4,
                          LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0),
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL, // LogContext
                          &Inf,
                          &ErrorLineNumber,
                          NULL
                         );
        if(Err != NO_ERROR) {
            leave;
        }

        InfSignerInfo->CatalogFile[0] = TEXT('\0');
        InfSignerInfo->DigitalSigner[0] = TEXT('\0');
        InfSignerInfo->DigitalSignerVersion[0] = TEXT('\0');

        if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
            //
            // We can't call the VerifyDeviceInfFile internal routine, because
            // it doesn't expect to be asked for the signer info (it doesn't
            // make any sense to talk about the signer info, because we have
            // no idea who signed the INF, or even if it was signed).
            //
            Err = NO_ERROR;

        } else {

            if (VerifyDeviceInfFile(NULL,
                                    NULL,
                                    PathBuffer,
                                    Inf,
                                    AltPlatformInfo,
                                    InfSignerInfo->CatalogFile,
                                    InfSignerInfo->DigitalSigner,
                                    InfSignerInfo->DigitalSignerVersion
                                    )) {
                Err = NO_ERROR;
            } else {
                Err = GetLastError();
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_DATA;
    }

    if (Inf) {
        FreeInfFile(Inf);
        Inf = NULL;
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}



/////////////////////////////////////////////////////////////////
//
// Internal routines
//
/////////////////////////////////////////////////////////////////

BOOL
pSetupVersionNodeFromInfInformation(
    IN  PSP_INF_INFORMATION InfInformation,
    IN  UINT                InfIndex,
    OUT PINF_VERSION_NODE   VersionNode,
    OUT PTSTR               OriginalFilename OPTIONAL
    )

/*++

Routine Description:

    Fills in a caller-supplied INF_VERSION_NODE buffer for an INF file
    from the SP_INF_INFORMATION structure.

Arguments:

    InfInformation - supplies the inf information descriptor

    InfIndex - supplies the 0-based index of the inf whose version block
        is requested. If this value is not inrange an error is returned.

    VersionNode - supplies the address of a buffer that receives the version
        node structure.

    OriginalFilename - optionally, supplies the address of a character buffer
        (that must be at least MAX_PATH characters large) that receives the
        INF's original filename (which may be the same as its current filename
        if the INF isn't an OEM INF.

Return Value:

    If successful, the return value is TRUE, otherwise, it is FALSE.

--*/

{
    PINF_VERSION_BLOCK First;
    INF_VERSION_BLOCK UNALIGNED *Ver;
    PUCHAR Base;
    UINT ord;
    INF_VERSION_BLOCK TempVersionBlock;
    UINT FilenameSize;

    //
    // Get pointer to first version block.
    //
    Base = (PUCHAR)InfInformation;
    First = (PINF_VERSION_BLOCK)(Base+offsetof(SP_INF_INFORMATION,VersionData));

    //
    // Find relevant version block
    //
    ord = 0;
    for(Ver=First; Ver; Ver=(INF_VERSION_BLOCK UNALIGNED *)(Base+Ver->NextOffset)) {

        if(ord++ == InfIndex) {
            break;
        }
    }

    if(!Ver) {
        return FALSE;
    }

    //
    // Now fill in the version node based on the information contained in the version block.
    //
    VersionNode->LastWriteTime = Ver->LastWriteTime;
    VersionNode->DataBlock     = (CONST TCHAR *)((PBYTE)(Ver->Filename) + Ver->OffsetToData);
    VersionNode->DataSize      = Ver->DataSize;
    VersionNode->DatumCount    = Ver->DatumCount;

    //
    // The 'filename' character buffer may actually contain two strings--the
    // first being the INF's current filename (with path), and the second being
    // the INF's original filename (this won't be present if the INF's name
    // hasn't changed from its original name).
    //
    // Copy the first MAX_PATH characters of this buffer (or the entire buffer,
    // whichever is smaller) into the VersionNode's Filename buffer, then after
    // we've computed the string length of that string, we can ascertain whether
    // or not there's another string following it containing the INF's original
    // name.
    //
    FilenameSize = (Ver->OffsetToData < SIZECHARS(VersionNode->Filename))
                 ? Ver->OffsetToData : SIZECHARS(VersionNode->Filename);

    CopyMemory(VersionNode->Filename, Ver->Filename, FilenameSize);
    VersionNode->FilenameSize = (lstrlen(VersionNode->Filename) + 1) * sizeof(TCHAR);

    MYASSERT(Ver->OffsetToData >= VersionNode->FilenameSize);

    if(OriginalFilename) {

        if(Ver->OffsetToData > VersionNode->FilenameSize) {
            //
            // Then there's more data in the Filename buffer, namely the INF's
            // original name--fill this filename into the caller-supplied buffer.
            //
            FilenameSize = Ver->OffsetToData - VersionNode->FilenameSize;
            MYASSERT(((UINT)(FilenameSize / sizeof(TCHAR)) * sizeof(TCHAR)) == FilenameSize);
            MYASSERT(FilenameSize > sizeof(TCHAR));

            CopyMemory(OriginalFilename,
                       (PBYTE)Ver->Filename + VersionNode->FilenameSize,
                       FilenameSize
                      );

            MYASSERT(((lstrlen(OriginalFilename) + 1) * sizeof(TCHAR)) == FilenameSize);

        } else {
            //
            // No original name info stored--must be same as current name.
            //
            lstrcpy(OriginalFilename, pSetupGetFileTitle(VersionNode->Filename));
        }
    }

    return TRUE;
}


PCTSTR
pSetupGetVersionDatum(
    IN PINF_VERSION_NODE VersionNode,
    IN PCTSTR            DatumName
    )

/*++

Routine Description:

    Look up a piece of version data in an version data node.

Arguments:

    VersionNode - supplies a pointer to the version node to
        be searched for the datum.

    DatumName - supplies the name of the datum to be retreived.

Return Value:

    NULL if the datum does not exist in the data block.
    Otherwise a pointer to the datum value is returned. The caller
        must not free or write into this memory.

--*/

{
    WORD Datum;
    UINT StringLength;
    PCTSTR Data = VersionNode->DataBlock;

    for(Datum=0; Datum < VersionNode->DatumCount; Datum++) {

        StringLength = lstrlen(Data) + 1;

        //
        // Go through the version block looking for a matching datum name.
        //
        if(lstrcmpi(Data, DatumName)) {

            //
            // Point to the next one.
            //
            Data += StringLength;
            Data += lstrlen(Data) + 1;

        } else {

            //
            // Found it. Return datum value to caller.
            //
            return (Data + StringLength);
        }
    }

    return(NULL);
}


BOOL
pSetupGetCatalogFileValue(
    IN  PINF_VERSION_NODE       InfVersionNode,
    OUT LPTSTR                  Buffer,
    IN  DWORD                   BufferSize,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo OPTIONAL
    )

/*++

Routine Description:

    This routine fetches the (potentially decorated) CatalogFile= value from the
    specified inf version section.

Arguments:

    InfVersionNode - points to the INF version node from which we're attempting
        to retrieve the associated catalog file.

    Buffer - if the routine returns TRUE, receives the value for CatalogFile=
        in the [Version] section of the inf.

    BufferSize - supplies the size in bytes (ansi) or chars (unicode) of
        the buffer pointed to by Buffer.

    AltPlatformInfo - optionally, supplies the address of a structure describing
        the platform parameters that should be used in formulating the decorated
        CatalogFile= entry to be used when searching for the INF's associated
        catalog file.

Return Value:

    Boolean value indicating whether a value was found and copied to the
    caller-supplied Buffer.

--*/

{
    TCHAR CatFileWithExt[64];
    LPCTSTR p, NtPlatformSuffixToUse;
    DWORD PlatformId;

    MYASSERT(BufferSize >= MAX_PATH);

    p = NULL;

    CopyMemory(CatFileWithExt, pszCatalogFile, sizeof(pszCatalogFile) - sizeof(TCHAR));

    //
    // Set up some variables based on the native platform or upon the non-native
    // platform specified in the AltPlatformInfo parameter.
    //
    if(AltPlatformInfo) {
        PlatformId = AltPlatformInfo->Platform;
        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL:
                NtPlatformSuffixToUse = pszNtX86Suffix;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA:
                NtPlatformSuffixToUse = pszNtAlphaSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_IA64:
                NtPlatformSuffixToUse = pszNtIA64Suffix;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA64:
                NtPlatformSuffixToUse = pszNtAXP64Suffix;
                break;

            case PROCESSOR_ARCHITECTURE_AMD64:
                NtPlatformSuffixToUse = pszNtAMD64Suffix;
                break;

            default:
                return FALSE;
        }
    } else {
        PlatformId = OSVersionInfo.dwPlatformId;
        NtPlatformSuffixToUse = pszNtPlatformSuffix;
    }

    if(PlatformId == VER_PLATFORM_WIN32_NT) {
        //
        // We're running on NT, so first try the NT architecture-specific
        // extension, then the generic NT extension.
        //
        lstrcpyn((PTSTR)((PBYTE)CatFileWithExt + (sizeof(pszCatalogFile) - sizeof(TCHAR))),
                 NtPlatformSuffixToUse,
                 SIZECHARS(CatFileWithExt) - (sizeof(pszCatalogFile) - sizeof(TCHAR))
                );

        p = pSetupGetVersionDatum(InfVersionNode, CatFileWithExt);

        if(!p) {
            //
            // We didn't find an NT architecture-specific CatalogFile= entry, so
            // fall back to looking for just an NT-specific one.
            //
            CopyMemory((PBYTE)CatFileWithExt + (sizeof(pszCatalogFile) - sizeof(TCHAR)),
                       pszNtSuffix,
                       sizeof(pszNtSuffix)
                      );

            p = pSetupGetVersionDatum(InfVersionNode, CatFileWithExt);
        }

    } else {
        //
        // We're running on Windows 95, so try the Windows-specific extension
        //
        CopyMemory((PBYTE)CatFileWithExt + (sizeof(pszCatalogFile) - sizeof(TCHAR)),
                   pszWinSuffix,
                   sizeof(pszWinSuffix)
                  );

        p = pSetupGetVersionDatum(InfVersionNode, CatFileWithExt);
    }

    //
    // If we didn't find an OS/architecture-specific CatalogFile= entry above,
    // then look for an undecorated entry.
    //
    if(!p) {
        p = pSetupGetVersionDatum(InfVersionNode, pszCatalogFile);
    }

    //
    // If we got back an empty string, then treat this as if there was no
    // CatalogFile= entry (this might be used, for example, so that a system-
    // supplied INF that supports both NT and Win98 could specify an undecorated
    // CatalogFile= entry for Win98, yet supply an NT-specific CatalogFile=
    // entry that's an empty string, so that we'd do global verification on NT).
    //
    if(p && lstrlen(p)) {
        lstrcpyn(Buffer, p, BufferSize);
        return TRUE;
    } else {
        return FALSE;
    }
}


VOID
pSetupGetPhysicalInfFilepath(
    IN  PINFCONTEXT LineContext,
    OUT LPTSTR      Buffer,
    IN  DWORD       BufferSize
    )
{
    lstrcpyn(
        Buffer,
        ((PLOADED_INF)LineContext->CurrentInf)->VersionBlock.Filename,
        BufferSize
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\inflogcf.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    inflogcf.c

Abstract:

    Routines to parse logical configuration sections in
    win95-style INF files, and place the output in the registry.

Author:

    Ted Miller (tedm) 8-Mar-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


PCTSTR pszHexDigits = TEXT("0123456789ABCDEF");

#define INFCHAR_SIZE_SEP            TEXT('@')
#define INFCHAR_RANGE_SEP           TEXT('-')
#define INFCHAR_ALIGN_SEP           TEXT('%')
#define INFCHAR_ATTR_START          TEXT('(')
#define INFCHAR_ATTR_END            TEXT(')')
#define INFCHAR_MEMATTR_READ        TEXT('R')
#define INFCHAR_MEMATTR_WRITE       TEXT('W')
#define INFCHAR_MEMATTR_PREFETCH    TEXT('F')
#define INFCHAR_MEMATTR_COMBINEDWRITE TEXT('C')
#define INFCHAR_MEMATTR_CACHEABLE   TEXT('H')
#define INFCHAR_MEMATTR_DWORD       TEXT('D')
#define INFCHAR_MEMATTR_ATTRIBUTE   TEXT('A')
#define INFCHAR_DECODE_START        TEXT('(')
#define INFCHAR_DECODE_END          TEXT(')')
#define INFCHAR_DECODE_SEP          TEXT(':')
#define INFCHAR_IRQATTR_SEP         TEXT(':')
#define INFCHAR_IRQATTR_SHARE       TEXT('S')
#define INFCHAR_IRQATTR_LEVEL       TEXT('L')
#define INFCHAR_DMAWIDTH_NARROW     TEXT('N')   // i.e., 8-bit
#define INFCHAR_DMAWIDTH_WORD       TEXT('W')   // i.e., 16-bit
#define INFCHAR_DMAWIDTH_DWORD      TEXT('D')   // i.e., 32-bit
#define INFCHAR_DMA_BUSMASTER       TEXT('M')
#define INFCHAR_DMATYPE_A           TEXT('A')
#define INFCHAR_DMATYPE_B           TEXT('B')
#define INFCHAR_DMATYPE_F           TEXT('F')
#define INFCHAR_IOATTR_MEMORY       TEXT('M')
#define INFCHAR_PCCARD_IOATTR_WORD  TEXT('W')
#define INFCHAR_PCCARD_IOATTR_BYTE  TEXT('B')
#define INFCHAR_PCCARD_IOATTR_SRC   TEXT('S')
#define INFCHAR_PCCARD_IOATTR_Z8    TEXT('Z')
#define INFCHAR_PCCARD_ATTR_WAIT    TEXT('X')
#define INFCHAR_PCCARD_ATTR_WAITI   TEXT('I')
#define INFCHAR_PCCARD_ATTR_WAITM   TEXT('M')
#define INFCHAR_PCCARD_MEMATTR_WORD TEXT('M')
#define INFCHAR_PCCARD_MEM_ISATTR   TEXT('A')
#define INFCHAR_PCCARD_MEM_ISCOMMON TEXT('C')
#define INFCHAR_PCCARD_SEP          TEXT(':')
#define INFCHAR_PCCARD_ATTR_SEP     TEXT(' ')
#define INFCHAR_MFCARD_AUDIO_ATTR   TEXT('A')

#define INFLOGCONF_IOPORT_10BIT_DECODE    0x000003ff
#define INFLOGCONF_IOPORT_12BIT_DECODE    0x00000fff
#define INFLOGCONF_IOPORT_16BIT_DECODE    0x0000ffff
#define INFLOGCONF_IOPORT_POSITIVE_DECODE 0x00000000

#define DEFAULT_IOPORT_DECODE             INFLOGCONF_IOPORT_10BIT_DECODE

#define DEFAULT_MEMORY_ALIGNMENT    0xfffffffffffff000  // 4K-aligned (a'la Win9x)
#define DEFAULT_IOPORT_ALIGNMENT    0xffffffffffffffff  // byte-aligned
#define DEFAULT_IRQ_AFFINITY        0xffffffff          // use any processor


//
// Mapping between registry key specs in an inf file
// and predefined registry handles.
//
STRING_TO_DATA InfPrioritySpecToPriority[] = {  INFSTR_CFGPRI_HARDWIRED   , LCPRI_HARDWIRED,
                                                INFSTR_CFGPRI_DESIRED     , LCPRI_DESIRED,
                                                INFSTR_CFGPRI_NORMAL      , LCPRI_NORMAL,
                                                INFSTR_CFGPRI_SUBOPTIMAL  , LCPRI_SUBOPTIMAL,
                                                INFSTR_CFGPRI_DISABLED    , LCPRI_DISABLED,
                                                INFSTR_CFGPRI_RESTART     , LCPRI_RESTART,
                                                INFSTR_CFGPRI_REBOOT      , LCPRI_REBOOT,
                                                INFSTR_CFGPRI_POWEROFF    , LCPRI_POWEROFF,
                                                INFSTR_CFGPRI_HARDRECONFIG, LCPRI_HARDRECONFIG,
                                                INFSTR_CFGPRI_FORCECONFIG , LCPRI_FORCECONFIG,
                                                NULL                      , 0
                                             };


STRING_TO_DATA InfConfigSpecToConfig[] = {  INFSTR_CFGTYPE_BASIC   , BASIC_LOG_CONF,
                                            INFSTR_CFGTYPE_FORCED  , FORCED_LOG_CONF,
                                            INFSTR_CFGTYPE_OVERRIDE, OVERRIDE_LOG_CONF,
                                            NULL                   , 0
                                         };

//
// Declare strings used in processing INF LogConfigs.
//
// These strings are defined in infstr.h:
//
CONST TCHAR pszMemConfig[]      = INFSTR_KEY_MEMCONFIG,
            pszIOConfig[]       = INFSTR_KEY_IOCONFIG,
            pszIRQConfig[]      = INFSTR_KEY_IRQCONFIG,
            pszDMAConfig[]      = INFSTR_KEY_DMACONFIG,
            pszPcCardConfig[]   = INFSTR_KEY_PCCARDCONFIG,
            pszMfCardConfig[]   = INFSTR_KEY_MFCARDCONFIG,
            pszConfigPriority[] = INFSTR_KEY_CONFIGPRIORITY,
            pszDriverVer[]      = INFSTR_DRIVERVERSION_SECTION;


BOOL
pHexToScalar(
    IN  PCTSTR     FieldStart,
    IN  PCTSTR     FieldEnd,
    OUT PDWORDLONG Value,
    IN  BOOL       Want64Bits
    )
{
    UINT DigitCount;
    UINT i;
    DWORDLONG Accum;
    WORD Types[16];

    //
    // Make sure the number is in range by checking the number
    // of hex digits.
    //
    DigitCount = (UINT)(FieldEnd - FieldStart);
    if((DigitCount == 0)
    || (DigitCount > (UINT)(Want64Bits ? 16 : 8))
    || !GetStringTypeEx(LOCALE_SYSTEM_DEFAULT,CT_CTYPE1,FieldStart,DigitCount,Types)) {
        return(FALSE);
    }

    Accum = 0;
    for(i=0; i<DigitCount; i++) {
        if(!(Types[i] & C1_XDIGIT)) {
            return(FALSE);
        }
        Accum *= 16;
        Accum += _tcschr(pszHexDigits,(TCHAR)CharUpper((PTSTR)FieldStart[i])) - pszHexDigits;
    }

    *Value = Accum;
    return(TRUE);
}


BOOL
pHexToUlong(
    IN  PCTSTR FieldStart,
    IN  PCTSTR FieldEnd,
    OUT PDWORD Value
    )

/*++

Routine Description:

    Convert a sequence of unicode hex digits into an
    unsigned 32-bit number. Digits are validated.

Arguments:

    FieldStart - supplies pointer to unicode digit sequence.

    FieldEnd - supplies pointer to first character beyond the
        digit sequence.

    Value - receives 32-bit number

Return Value:

    TRUE if the number is in range and valid. FALSE otherwise.

--*/

{
    DWORDLONG x;
    BOOL b;

    if(b = pHexToScalar(FieldStart,FieldEnd,&x,FALSE)) {
        *Value = (DWORD)x;
    }
    return(b);
}


BOOL
pHexToUlonglong(
    IN  PCTSTR     FieldStart,
    IN  PCTSTR     FieldEnd,
    OUT PDWORDLONG Value
    )

/*++

Routine Description:

    Convert a sequence of unicode hex digits into an
    unsigned 64-bit number. Digits are validated.

Arguments:

    FieldStart - supplies pointer to unicode digit sequence.

    FieldEnd - supplies pointer to first character beyond the
        digit sequence.

    Value - receives 64-bit number

Return Value:

    TRUE if the number is in range and valid. FALSE otherwise.

--*/

{
    return(pHexToScalar(FieldStart,FieldEnd,Value,TRUE));
}


BOOL
pDecimalToUlong(
    IN  PCTSTR Field,
    OUT PDWORD Value
    )

/*++

Routine Description:

    Convert a nul-terminated sequence of unicode decimal digits into an
    unsigned 32-bit number. Digits are validated.

Arguments:

    Field - supplies pointer to unicode digit sequence.

    Value - receives DWORD number

Return Value:

    TRUE if the number is in range and valid. FALSE otherwise.

--*/

{
    UINT DigitCount;
    UINT i;
    DWORDLONG Accum;
    WORD Types[10];

    DigitCount = lstrlen(Field);
    if((DigitCount == 0) || (DigitCount > 10)
    || !GetStringTypeEx(LOCALE_SYSTEM_DEFAULT,CT_CTYPE1,Field,DigitCount,Types)) {
        return(FALSE);
    }

    Accum = 0;
    for(i=0; i<DigitCount; i++) {
        if(!(Types[i] & C1_DIGIT)) {
            return(FALSE);
        }
        Accum *= 10;
        Accum += _tcschr(pszHexDigits,(TCHAR)CharUpper((PTSTR)Field[i])) - pszHexDigits;

        //
        // Check overflow
        //
        if(Accum > 0xffffffff) {
            return(FALSE);
        }
    }

    *Value = (DWORD)Accum;
    return(TRUE);
}


DWORD
pSetupProcessMemConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE        hMachine
    )

/*++

Routine Description:

    Process a MemConfig line in a Win95 INF. Such lines specify
    memory requirements for a device. Each line is expected to be
    in the form

    MemConfig = <start>-<end>[(<attr>)],<start>-<end>[(<attr>)],...

    <start> is the start of a memory range (64-bit hex)
    <end>   is the end of a memory range   (64-bit hex)
    <attr>  if present is a string of 0 or more chars from
            C - memory is combined-write
            D - memory is 32-bit, otherwise 24-bit.
            F - memory is prefetchable
            H - memory is cacheable
            R - memory is read-only
            W - memory is write-only
                (If R and W are specified or neither is specified the memory
                is read/write)

    or

    MemConfig = <size>@<min>-<max>[%align][(<attr>)],...

    <size>  is the size of a memory range (32-bit hex)
    <min>   is the minimum address where the memory range can be (64-bit hex)
    <max>   is the maximum address where the memory range can be (64-bit hex)
    <align> (if specified) is the alignment mask for the addresses (32-bit hex)
    <attr>  as above.

    ie, 8000@C0000-D7FFF%F0000 says the device needs a 32K memory window
    starting at any 64K-aligned address between C0000 and D7FFF.

    The default memory alignment is 4K (FFFFF000).

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    PTCHAR p;
    INT u;
    UINT Attributes;
    DWORD RangeSize;
    ULARGE_INTEGER Align;
    DWORDLONG Start,End;
    PMEM_RESOURCE MemRes;
    PMEM_RANGE MemRange;
    RES_DES ResDes;
    PVOID q;
    BOOL bReadFlag = FALSE, bWriteFlag = FALSE;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(MemRes = MyMalloc(offsetof(MEM_RESOURCE,MEM_Data))) {

        ZeroMemory(MemRes,offsetof(MEM_RESOURCE,MEM_Data));
        MemRes->MEM_Header.MD_Type = MType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        Attributes = 0;
        RangeSize = 0;
        Align.QuadPart = DEFAULT_MEMORY_ALIGNMENT;

        //
        // See if this is in the start-end or size@min-max format.
        // If we have a size, use it.
        //
        if(p = _tcschr(Field,INFCHAR_SIZE_SEP)) {
            if(pHexToUlong(Field,p,&RangeSize)) {
                Field = ++p;
            } else {
                d = ERROR_INVALID_INF_LOGCONFIG;
            }
        }

        //
        // We should now have a x-y which is either start/end or min/max.
        //
        if((d == NO_ERROR)                              // no err so far
        && (p = _tcschr(Field,INFCHAR_RANGE_SEP))       // Field: start of min; p: end of min
        && pHexToUlonglong(Field,p,&Start)              // get min
        && (Field = p+1)                                // Field: start of max
        && (   (p = _tcschr(Field,INFCHAR_ALIGN_SEP))
            || (p = _tcschr(Field,INFCHAR_ATTR_START))
            || (p = _tcschr(Field,0)))                  // p: end of max
        && pHexToUlonglong(Field,p,&End)) {             // get max
            //
            // If we get here Field is pointing either at the end of the field,
            // at the % that starts the alignment mask spec, or at the
            // ( that starts the attributes spec.
            //
            Field = p;
            if(*Field == INFCHAR_ALIGN_SEP) {
                Field++;
                p = _tcschr(Field,INFCHAR_ATTR_START);
                if(!p) {
                    p = _tcschr(Field,0);
                }
                if(pHexToUlonglong(Field, p, &(Align.QuadPart))) {
                    //
                    // NOTE:  Since these mask values are actually stored in a WDM
                    // resource list (i.e., IO_RESOURCE_REQUIREMENTS_LIST), there's
                    // no way to specify an alignment greater than 32 bits.  However,
                    // since the alignment value was implemented as a mask (for
                    // compatibility with Win9x), we must specify it as a 64-bit
                    // quantity, since it is applied to a 64-bit value.  We will check
                    // below to ensure that the most significant DWORD is all ones.
                    //
                    // Also, we must handle alignment values such as 000F0000, 00FF0000,
                    // 0FFF0000, and FFFF0000.  These all specify 64K alignment (depending
                    // on the min and max addresses, the INF writer might not need to
                    // specify all the 1 bits in the 32-bit value).
                    // Thus we perform an ersatz sign extension of sorts -- we
                    // find the highest 1 bit and replicate it into all the
                    // more significant bits in the value.
                    //
                    for(u=31; u>=0; u--) {
                        if(Align.HighPart & (1 << u)) {
                            break;
                        }
                        Align.HighPart |= (1 << u);
                    }
                    //
                    // Make sure that all the bits in the most-significant DWORD are set,
                    // because we can't express this alignment otherwise (as discussed
                    // above).  Also, make sure that if we encountered a '1' in the high
                    // dword, then the high bit of the low dword is '1' as well.
                    //
                    if((Align.HighPart ^ 0xffffffff) ||
                       ((u >= 0) && !(Align.LowPart & 0x80000000))) {

                        d = ERROR_INVALID_INF_LOGCONFIG;

                    } else {
                        //
                        // Do the sign extension for the low dword.
                        //
                        for(u=31; u>=0; u--) {
                            if(Align.LowPart & (1 << u)) {
                                break;
                            }
                            Align.LowPart |= (1 << u);
                        }
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
            }

            //
            // See if we have attributes.
            //
            if((d == NO_ERROR) && (*p == INFCHAR_ATTR_START)) {
                Field = ++p;
                if(p = _tcschr(Field,INFCHAR_ATTR_END)) {
                    //
                    // C for combined-write
                    // D for 32-bit memory
                    // F for prefetchable
                    // H for cacheable
                    // R for readable
                    // W for writeable
                    // RW (or neither) means read/write
                    //
                    while((d == NO_ERROR) && (Field < p)) {

                        switch((TCHAR)CharUpper((PTSTR)(*Field))) {
                        case INFCHAR_MEMATTR_READ:
                            bReadFlag = TRUE;
                            break;
                        case INFCHAR_MEMATTR_WRITE:
                            bWriteFlag = TRUE;
                            break;
                        case INFCHAR_MEMATTR_PREFETCH:
                            Attributes |= fMD_PrefetchAllowed;
                            break;
                        case INFCHAR_MEMATTR_COMBINEDWRITE:
                            Attributes |= fMD_CombinedWriteAllowed;
                            break;
                        case INFCHAR_MEMATTR_DWORD:
                            Attributes |= fMD_32;
                            break;
                        case INFCHAR_MEMATTR_CACHEABLE:
                            Attributes |= fMD_Cacheable;
                            break;
                        default:
                            d = ERROR_INVALID_INF_LOGCONFIG;
                            break;
                        }

                        Field++;
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
            }
        } else {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }

        if(d == NO_ERROR) {
            //
            // If no range size was specified, then calculate it from
            // the given start and end addresses. Since this happens
            // when the memory requirement was an absolute start/end,
            // there is no alignment requirement.
            //
            if(RangeSize == 0) {
                RangeSize = (DWORD)(End-Start)+1;
                Align.QuadPart = DEFAULT_MEMORY_ALIGNMENT;
            }

            //
            // Slam values into the header part of the memory descriptor.
            // These will be ignored unless we're setting a forced config.
            // Note that the inf had better have specified forced mem configs
            // in a 'simple' form, since we throw away alignment, etc.
            //
            if (bWriteFlag && bReadFlag) {
                Attributes |=  fMD_ReadAllowed | fMD_RAM;       // read-write
            } else if (bWriteFlag && !bReadFlag) {
                Attributes |= fMD_ReadDisallowed | fMD_RAM;     // write only
            } else if (!bWriteFlag && bReadFlag) {
                Attributes |= fMD_ReadAllowed | fMD_ROM;        // read-only
            } else {
                Attributes |=  fMD_ReadAllowed | fMD_RAM;       // read-write
            }

            MemRes->MEM_Header.MD_Alloc_Base = Start;
            MemRes->MEM_Header.MD_Alloc_End = Start + RangeSize - 1;
            MemRes->MEM_Header.MD_Flags = Attributes;

            //
            // Add this guy into the descriptor we're building up.
            //
            q = MyRealloc(
                    MemRes,
                      offsetof(MEM_RESOURCE,MEM_Data)
                    + (sizeof(MEM_RANGE)*(MemRes->MEM_Header.MD_Count+1))
                    );

            if(q) {
                MemRes = q;
                MemRange = &MemRes->MEM_Data[MemRes->MEM_Header.MD_Count++];

                MemRange->MR_Align = Align.QuadPart;
                MemRange->MR_nBytes = RangeSize;
                MemRange->MR_Min = Start;
                MemRange->MR_Max = End;
                MemRange->MR_Flags = Attributes;
                MemRange->MR_Reserved = 0;

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if((d == NO_ERROR) && MemRes->MEM_Header.MD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_Mem,
                MemRes,
                offsetof(MEM_RESOURCE,MEM_Data) + (sizeof(MEM_RANGE) * MemRes->MEM_Header.MD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(MemRes) {
        MyFree(MemRes);
    }

    return(d);
}


DWORD
pSetupProcessIoConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE        hMachine
    )

/*++

Routine Description:

    Process an IOConfig line in a Win95 INF. Such lines specify
    IO port requirements for a device. Each line is expected to be
    in the form

    IOConfig = <start>-<end>[(<decodemask>:<aliasoffset>:<attr>)],...

    <start> is the start of a port range (64-bit hex)

    <end> is the end of a port range (64-bit hex)

    <decodemask> defines the alias type, and may be one of the following combinations:

        3ff    10-bit decode,   IOR_Alias is 0x04
        fff    12-bit decode,   IOR_Alias is 0x10
        ffff   16-bit decode,   IOR_Alias is 0x00
        0      positive decode, IOR_Alias is 0xFF

    <aliasoffset> is ignored.

    <attr> if 'M', specifies port is a memory address, otherwise port is an IO address.

    or

    IOConfig = <size>@<min>-<max>[%align][(<decodemask>:<aliasoffset>:<attr>)],...

    <size>  is the size of a port range (32-bit hex)
    <min>   is the minimum port where the memory range can be (64-bit hex)
    <max>   is the maximum port where the memory range can be (64-bit hex)
    <align> (if specified) is the alignment mask for the ports (32-bit hex)
    <decodemask>, <aliasoffset>,<attr> as above

    ie, IOConfig = 1F8-1FF(3FF::),2F8-2FF(3FF::),3F8-3FF(3FF::)
        IOConfig = 8@300-32F%FF8(3FF::)
        IOConfig = 2E8-2E8(3FF:8000:)

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    PTCHAR p;
    INT u;
    DWORD RangeSize;
    ULARGE_INTEGER Align;
    DWORDLONG Decode;
    DWORDLONG Start,End;
    BOOL GotSize;
    PIO_RESOURCE IoRes;
    PIO_RANGE IoRange;
    RES_DES ResDes;
    PVOID q;
    UINT Attributes = 0;
    PTCHAR Attr;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(IoRes = MyMalloc(offsetof(IO_RESOURCE,IO_Data))) {

        ZeroMemory(IoRes,offsetof(IO_RESOURCE,IO_Data));
        IoRes->IO_Header.IOD_Type = IOType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        Attributes = fIOD_IO;
        Decode = DEFAULT_IOPORT_DECODE;
        RangeSize = 0;
        Align.QuadPart = DEFAULT_IOPORT_ALIGNMENT;

        //
        // See if this is in the start-end or size@min-max format.
        // If we have a size, use it.
        //
        if(p = _tcschr(Field,INFCHAR_SIZE_SEP)) {
            if(pHexToUlong(Field,p,&RangeSize)) {
                Field = ++p;
            } else {
                d = ERROR_INVALID_INF_LOGCONFIG;
            }
        }

        //
        // We should now have a x-y which is either start/end or min/max.
        //
        if((d == NO_ERROR)                              // no err so far
        && (p = _tcschr(Field,INFCHAR_RANGE_SEP))       // Field: start of min; p: end of min
        && pHexToUlonglong(Field,p,&Start)              // get min
        && (Field = p+1)                                // Field: start of max
        && (   (p = _tcschr(Field,INFCHAR_ALIGN_SEP))
            || (p = _tcschr(Field,INFCHAR_DECODE_START))
            || (p = _tcschr(Field,0)))                  // p: end of max
        && pHexToUlonglong(Field,p,&End)) {             // get max
            //
            // If we get here Field is pointing either at the end of the field,
            // or at the % that starts the alignment mask spec,
            // or at the ( that starts the decode stuff.
            //
            Field = p;
            switch(*Field) {
            case INFCHAR_ALIGN_SEP:
                Field++;


                p = _tcschr(Field,INFCHAR_ATTR_START);
                if(!p) {
                    p = _tcschr(Field,0);
                }
                if(pHexToUlonglong(Field, p, &(Align.QuadPart))) {
                    //
                    // NOTE:  Since these mask values are actually stored in a WDM
                    // resource list (i.e., IO_RESOURCE_REQUIREMENTS_LIST), there's
                    // no way to specify an alignment greater than 32 bits.  However,
                    // since the alignment value was implemented as a mask (for
                    // compatibility with Win9x), we must specify it as a 64-bit
                    // quantity, since it is applied to a 64-bit value.  We will check
                    // below to ensure that the most significant DWORD is all ones.
                    //
                    // Also, we must handle alignment values such as 000F0000, 00FF0000,
                    // 0FFF0000, and FFFF0000.  These all specify 64K alignment (depending
                    // on the min and max addresses, the INF writer might not need to
                    // specify all the 1 bits in the 32-bit value).
                    // Thus we perform an ersatz sign extension of sorts -- we
                    // find the highest 1 bit and replicate it into all the
                    // more significant bits in the value.
                    //
                    for(u=31; u>=0; u--) {
                        if(Align.HighPart & (1 << u)) {
                            break;
                        }
                        Align.HighPart |= (1 << u);
                    }
                    //
                    // Make sure that all the bits in the most-significant DWORD are set,
                    // because we can't express this alignment otherwise (as discussed
                    // above).  Also, make sure that if we encountered a '1' in the high
                    // dword, then the high bit of the low dword is '1' as well.
                    //
                    if((Align.HighPart ^ 0xffffffff) ||
                       ((u >= 0) && !(Align.LowPart & 0x80000000))) {

                        d = ERROR_INVALID_INF_LOGCONFIG;

                    } else {
                        //
                        // Do the sign extension for the low dword.
                        //
                        for(u=31; u>=0; u--) {
                            if(Align.LowPart & (1 << u)) {
                                break;
                            }
                            Align.LowPart |= (1 << u);
                        }
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
                break;

            case INFCHAR_DECODE_START:
                //
                // Get decode value (this determines the IOR_Alias that gets filled
                // in for the resdes.
                //
                Field++;
                p = _tcschr(Field,INFCHAR_DECODE_SEP);
                if (p) {
                    if (Field != p) {
                        pHexToUlonglong(Field,p,&Decode);     // got decode value
                    }
                    Field = p+1;
                    p = _tcschr(Field,INFCHAR_DECODE_SEP);
                    if (p) {
                        //
                        // Ignore alias field.
                        //
                        Field = p+1;
                        p = _tcschr(Field,INFCHAR_DECODE_END);
                        if (p) {
                            if (Field != p) {
                                if (*Field == INFCHAR_IOATTR_MEMORY) {
                                    Attributes = fIOD_Memory; // got attribute value
                                }
                            }
                        } else {
                            d = ERROR_INVALID_INF_LOGCONFIG;
                        }
                    } else {
                        d = ERROR_INVALID_INF_LOGCONFIG;
                    }
                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
                break;
            }
        } else {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }

        if(d == NO_ERROR) {
            //
            // If no range size was specified, then calculate it from
            // the given start and end addresses. Since this happens
            // when the port requirement was an absolute start/end,
            // there is no alignment requirement (i.e., the default
            // byte-alignment should be specified).
            //
            if(RangeSize == 0) {
                RangeSize = (DWORD)(End-Start)+1;
                Align.QuadPart = DEFAULT_IOPORT_ALIGNMENT;
            }

            //
            // Create an alternate decode flag
            //
            switch(Decode) {

                case INFLOGCONF_IOPORT_10BIT_DECODE:
                    Attributes |= fIOD_10_BIT_DECODE;
                    break;

                case INFLOGCONF_IOPORT_12BIT_DECODE:
                    Attributes |= fIOD_12_BIT_DECODE;
                    break;

                case INFLOGCONF_IOPORT_16BIT_DECODE:
                    Attributes |= fIOD_16_BIT_DECODE;
                    break;

                case INFLOGCONF_IOPORT_POSITIVE_DECODE:
                    Attributes |= fIOD_POSITIVE_DECODE;
                    break;
            }
            //
            // Slam values into the header part of the i/o descriptor.
            // These will be ignored unless we're setting a forced config.
            // Note that the inf had better have specified forced i/o configs
            // in a 'simple' form, since we throw away alignment, etc.
            //
            IoRes->IO_Header.IOD_Alloc_Base = Start;
            IoRes->IO_Header.IOD_Alloc_End = Start + RangeSize - 1;
            IoRes->IO_Header.IOD_DesFlags = Attributes;

            //
            // Add this guy into the descriptor we're building up.
            //
            q = MyRealloc(
                    IoRes,
                      offsetof(IO_RESOURCE,IO_Data)
                    + (sizeof(IO_RANGE)*(IoRes->IO_Header.IOD_Count+1))
                    );

            if(q) {
                IoRes = q;
                IoRange = &IoRes->IO_Data[IoRes->IO_Header.IOD_Count++];

                IoRange->IOR_Align = Align.QuadPart;
                IoRange->IOR_nPorts = RangeSize;
                IoRange->IOR_Min = Start;
                IoRange->IOR_Max = End;
                IoRange->IOR_RangeFlags = Attributes;

                switch(Decode) {

                    case INFLOGCONF_IOPORT_10BIT_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_10_BIT_DECODE;
                        break;

                    case INFLOGCONF_IOPORT_12BIT_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_12_BIT_DECODE;
                        break;

                    case INFLOGCONF_IOPORT_16BIT_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_16_BIT_DECODE;
                        break;

                    case INFLOGCONF_IOPORT_POSITIVE_DECODE:
                        IoRange->IOR_Alias = IO_ALIAS_POSITIVE_DECODE;
                        break;

                    default:
                        d = ERROR_INVALID_INF_LOGCONFIG;
                        break;
                }

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if((d == NO_ERROR) && IoRes->IO_Header.IOD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_IO,
                IoRes,
                offsetof(IO_RESOURCE,IO_Data) + (sizeof(IO_RANGE) * IoRes->IO_Header.IOD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(IoRes) {
        MyFree(IoRes);
    }

    return(d);
}


DWORD
pSetupProcessIrqConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process an IRQConfig line in a Win95 INF. Such lines specify
    IRQ requirements for a device. Each line is expected to be
    in the form

    IRQConfig = [[S][L]:]<IRQNum>,...

    S: if present indicates that the interrupt is shareable
    L: if present indicates that the interrupt is Level sensitive,
       otherwise it is assumed to be edge sensitive.
    IRQNum is the IRQ number in decimal.

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    BOOL Shareable;
    BOOL Level;
    DWORD Irq;
    PIRQ_RESOURCE IrqRes;
    PIRQ_RANGE IrqRange;
    RES_DES ResDes;
    PVOID q;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(IrqRes = MyMalloc(offsetof(IRQ_RESOURCE,IRQ_Data))) {

        ZeroMemory(IrqRes,offsetof(IRQ_RESOURCE,IRQ_Data));
        IrqRes->IRQ_Header.IRQD_Type = IRQType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    Shareable = FALSE;
    Level = FALSE;
    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        //
        // For first field, see if we have S: by itself...
        //
        if((i == 1)
        &&((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_SHARE)
        && (Field[1] == INFCHAR_IRQATTR_SEP)) {

            Shareable = TRUE;
            Field+=2;
        }

        //
        // ... see if we have an L: by itself...
        //
        if((i == 1)
        &&((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_LEVEL)
        && (Field[1] == INFCHAR_IRQATTR_SEP)) {

            Level = TRUE;
            Field+=2;
        }

        //
        // ... see if we have both attributes.
        //
        if((i == 1)
        && (Field[2] == INFCHAR_IRQATTR_SEP)) {

            if (((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_SHARE)
            ||   (TCHAR)CharUpper((PTSTR)Field[1]) == INFCHAR_IRQATTR_SHARE) {

                Shareable = TRUE;
            }

            if (((TCHAR)CharUpper((PTSTR)Field[0]) == INFCHAR_IRQATTR_LEVEL)
            ||   (TCHAR)CharUpper((PTSTR)Field[1]) == INFCHAR_IRQATTR_LEVEL) {

                Level = TRUE;
            }
            Field+=3;
        }

        if(pDecimalToUlong(Field,&Irq)) {

            //
            // Slam values into the header part of the irq descriptor.
            // These will be ignored unless we're setting a forced config.
            //
            IrqRes->IRQ_Header.IRQD_Flags = Shareable ? fIRQD_Share : fIRQD_Exclusive;
            IrqRes->IRQ_Header.IRQD_Flags |= Level ? fIRQD_Level : fIRQD_Edge;
            IrqRes->IRQ_Header.IRQD_Alloc_Num = Irq;
            IrqRes->IRQ_Header.IRQD_Affinity = DEFAULT_IRQ_AFFINITY;

            //
            // Add this guy into the descriptor we're building up.
            //
            q = MyRealloc(
                    IrqRes,
                      offsetof(IRQ_RESOURCE,IRQ_Data)
                    + (sizeof(IRQ_RANGE)*(IrqRes->IRQ_Header.IRQD_Count+1))
                    );

            if(q) {
                IrqRes = q;
                IrqRange = &IrqRes->IRQ_Data[IrqRes->IRQ_Header.IRQD_Count++];

                IrqRange->IRQR_Min = Irq;
                IrqRange->IRQR_Max = Irq;
                IrqRange->IRQR_Flags = Shareable ? fIRQD_Share : fIRQD_Exclusive;
                IrqRange->IRQR_Flags |= Level ? fIRQD_Level : fIRQD_Edge;

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }

    if((d == NO_ERROR) && IrqRes->IRQ_Header.IRQD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_IRQ,
                IrqRes,
                offsetof(IRQ_RESOURCE,IRQ_Data) + (sizeof(IRQ_RANGE) * IrqRes->IRQ_Header.IRQD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(IrqRes) {
        MyFree(IrqRes);
    }

    return(d);
}


DWORD
pSetupProcessDmaConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process a DMAConfig line in a Win95 INF. Such lines specify
    DMA requirements for a device. Each line is expected to be
    in the form

    DMAConfig = [<attrs>:]<DMANum>,...

    if <attrs> is present it can be
        D - 32-bit DMA channel
        W - 16-bit DMA channel
        N - 8-bit DMA channel (default).  Specify both W and N if 8- and 16-bit DMA is supported.
        M - Bus Mastering
        A - Type-A DMA channel
        B - Type-B DMA channel
        F - Type-F DMA channel
        (If none of A, B, or F are specified, then standard DMA is assumed)

    DMANum is the DMA channel number in decimal.

Arguments:

Return Value:

--*/

{
    UINT FieldCount,i;
    PCTSTR Field;
    DWORD d;
    DWORD Dma;
    INT ChannelSize;       // fDD_ xxx flags for channel width
    INT DmaType;           // fDD_ xxx flags for DMA type
    PDMA_RESOURCE DmaRes;
    PDMA_RANGE DmaRange;
    RES_DES ResDes;
    PVOID q;
    PTCHAR p;
    BOOL BusMaster;
    ULONG DmaFlags;

    ChannelSize = -1;
    BusMaster = FALSE;
    DmaType = -1;

    FieldCount = SetupGetFieldCount(InfLine);
    if (!FieldCount && GetLastError() != NO_ERROR) {
        return GetLastError();
    }

    if(DmaRes = MyMalloc(offsetof(DMA_RESOURCE,DMA_Data))) {

        ZeroMemory(DmaRes,offsetof(DMA_RESOURCE,DMA_Data));
        DmaRes->DMA_Header.DD_Type = DType_Range;

        d = NO_ERROR;

    } else {
        d = ERROR_NOT_ENOUGH_MEMORY;
    }

    for(i=1; (d==NO_ERROR) && (i<=FieldCount); i++) {

        Field = pSetupGetField(InfLine,i);

        //
        // For first field, see if we have attribute spec.
        //
        if(i == 1) {

            if(p = _tcschr(Field, INFCHAR_IRQATTR_SEP)) {

                for( ;((d == NO_ERROR) && (Field < p)); Field++) {

                    switch((TCHAR)CharUpper((PTSTR)(*Field))) {

                        //
                        // Channel size can be both 8 and 16 (i.e., both 'W' and 'N'), but
                        // you can't mix these with 'D'.
                        //
                        case INFCHAR_DMAWIDTH_WORD:
                            if(ChannelSize == fDD_DWORD) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else if(ChannelSize == fDD_BYTE) {
                                ChannelSize = fDD_BYTE_AND_WORD;
                            } else {
                                ChannelSize = fDD_WORD;
                            }
                            break;

                        case INFCHAR_DMAWIDTH_DWORD:
                            if((ChannelSize != -1) && (ChannelSize != fDD_DWORD)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                ChannelSize = fDD_DWORD;
                            }
                            break;

                        case INFCHAR_DMAWIDTH_NARROW:
                            if(ChannelSize == fDD_DWORD) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else if(ChannelSize == fDD_WORD) {
                                ChannelSize = fDD_BYTE_AND_WORD;
                            } else {
                                ChannelSize = fDD_BYTE;
                            }
                            break;

                        case INFCHAR_DMA_BUSMASTER:
                            BusMaster = TRUE;
                            break;

                        //
                        // The DMA types are mutually exclusive...
                        //
                        case INFCHAR_DMATYPE_A:
                            if((DmaType != -1) && (DmaType != fDD_TypeA)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                DmaType = fDD_TypeA;
                            }
                            break;

                        case INFCHAR_DMATYPE_B:
                            if((DmaType != -1) && (DmaType != fDD_TypeB)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                DmaType = fDD_TypeB;
                            }
                            break;

                        case INFCHAR_DMATYPE_F:
                            if((DmaType != -1) && (DmaType != fDD_TypeF)) {
                                d = ERROR_INVALID_INF_LOGCONFIG;
                            } else {
                                DmaType = fDD_TypeF;
                            }
                            break;

                        default:
                            d = ERROR_INVALID_INF_LOGCONFIG;
                            break;
                    }
                }

                Field++;    // skip over separator character
            }

            if(ChannelSize == -1) {
                DmaFlags = fDD_BYTE; // default is 8-bit DMA
            } else {
                DmaFlags = (ULONG)ChannelSize;
            }

            if(BusMaster) {
                DmaFlags |= fDD_BusMaster;
            }

            if(DmaType != -1) {
                DmaFlags |= DmaType;
            }
        }

        if(d == NO_ERROR) {
            if(pDecimalToUlong(Field,&Dma)) {

                //
                // Slam values into the header part of the dma descriptor.
                // These will be ignored unless we're setting a forced config.
                //
                DmaRes->DMA_Header.DD_Flags = DmaFlags;
                DmaRes->DMA_Header.DD_Alloc_Chan = Dma;

                //
                // Add this guy into the descriptor we're building up.
                //
                q = MyRealloc(
                        DmaRes,
                          offsetof(DMA_RESOURCE,DMA_Data)
                        + (sizeof(DMA_RANGE)*(DmaRes->DMA_Header.DD_Count+1))
                        );

                if(q) {
                    DmaRes = q;
                    DmaRange = &DmaRes->DMA_Data[DmaRes->DMA_Header.DD_Count++];

                    DmaRange->DR_Min = Dma;
                    DmaRange->DR_Max = Dma;
                    DmaRange->DR_Flags = DmaFlags;

                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                d = ERROR_INVALID_INF_LOGCONFIG;
            }
        }
    }

    if((d == NO_ERROR) && DmaRes->DMA_Header.DD_Count) {

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_DMA,
                DmaRes,
                offsetof(DMA_RESOURCE,DMA_Data) + (sizeof(DMA_RANGE) * DmaRes->DMA_Header.DD_Count),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }

    if(DmaRes) {
        MyFree(DmaRes);
    }

    return(d);
}


DWORD
pSetupProcessPcCardConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process a PcCardConfig line in a Win95 INF.  Such lines specify
    PC Card (PCMCIA) configuration information necessary for a device.
    Each line is expected to be in the form

    PcCardConfig = <ConfigIndex>[:[<MemoryCardBase1>][:<MemoryCardBase2>]][(<attrs>)]

    where

        <ConfigIndex> is the 8-bit PCMCIA configuration index

        <MemoryCardBase1> is the (optional) 32-bit 1st memory base address

        <MemoryCardBase2> is the (optional) 32-bit 2nd memory base address

        <attrs> is a combination of attribute specifiers optionally separated by
                spaces. The attribute string is processed from left to right,
                and an invalid attribute specifier aborts the entire PcCardConfig
                directive. Attributes may be specified in any order except for the
                positional attributes 'A' and 'C', which are described below.

                Accepted attribute specifiers are as follows:

                W   - 16-bit I/O data path (default: 16-bit)
                B   - 8-bit I/O data path (default: 16-bit)

                Sn  - ~IOCS16 source. If n is zero, ~IOCS16 is based on the value of
                      the datasize bit. If n is one, ~IOCS16 is based on the ~IOIS16
                      signal from the device. (default: 1)

                Zn  - I/O 8-bit zero wait state. If n is one, 8-bit I/O accesses occur
                      with zero additional wait states. If n is zero, access will
                      occur with additional wait states. This flag has no meaning for
                      16-bit I/O. (default: 0)

                XIn - I/O wait states. If n is one, 16-bit system accesses occur with
                      1 additional wait state. (default: 1)

                M   - 16-bit Memory (default: 8-bit)
                M8  - 8-bit Memory (default: 8-bit)

                XMn - Memory wait states, where n can be 0, 1, 2 or 3. This value
                      determines the number of additional wait states for 16-bit
                      accesses to a memory window. (default: 3)

                    NOTE: The following two attributes relate positionally to memory
                    windows resources. That is, the first 'A' or 'C' specified in the
                    attribute string (reading from left to right) corresponds to the
                    first memory resource in the device's resource list. The next
                    'A' or 'C' corresponds to the second memory resource. Subsequent
                    attribute/common memory specifiers are ignored.

                A - Memory range to be mapped as Attribute memory
                C - Memory range to be mapped as Common Memory (default)

                Example:
                (W CA M XM1 XI0) translates to:
                    I/O 16bit
                    1st memory window is common
                    2nd memory window is attribute
                    Memory 16 bit
                    one wait state on memory windows
                    zero wait states on i/o windows

    All numeric values are assumed to be in hexadecimal format.

Arguments:

Return Value:

--*/

{
    PCCARD_RESOURCE PcCardResource;
    PCTSTR Field, p;
    DWORD ConfigIndex, i, d;

    DWORD MemoryCardBase[PCD_MAX_MEMORY] = {0};
    DWORD Flags;

    UINT memAttrIndex = 0, memWaitIndex = 0, memWidthIndex = 0;
    UINT ioSourceIndex = 0, ioZeroWait8Index = 0, ioWaitState16Index = 0, ioWidthIndex = 0;
    UINT index;
    RES_DES ResDes;

    //
    // Assume failure
    //
    d = ERROR_INVALID_INF_LOGCONFIG;

    //
    // We should have one field (not counting the line's key)
    //
    if(SetupGetFieldCount(InfLine) != 1) {
        goto clean0;
    } else {
        Field = pSetupGetField(InfLine, 1);
    }

    //
    // Retrieve the ConfigIndex.  It may be terminated by either a colon ':',
    // an open paren '(', or eol.
    //
    if(!(p = _tcschr(Field, INFCHAR_PCCARD_SEP)) && !(p = _tcschr(Field, INFCHAR_ATTR_START))) {
        p = Field + lstrlen(Field);
    }

    if(!pHexToUlong(Field, p, &ConfigIndex) || (ConfigIndex > 255)) {
        goto clean0;
    }

    //
    // Process the (optional) memory card base addresses
    //
    for(i = 0; i < PCD_MAX_MEMORY; i++) {

        if(*p == INFCHAR_PCCARD_SEP) {

            Field = p + 1;
            if(!(p = _tcschr(Field, INFCHAR_PCCARD_SEP)) && !(p = _tcschr(Field, INFCHAR_ATTR_START))) {
                p = Field + lstrlen(Field);
            }

            //
            // Allow an empty field.
            //
            if(Field == p) {
                MemoryCardBase[i] = 0;
            } else if(!pHexToUlong(Field, p, &(MemoryCardBase[i]))) {
                goto clean0;
            }

        } else {
            MemoryCardBase[i] = 0;
        }
    }

    //
    // Initialize the flags
    //

    Flags = fPCD_ATTRIBUTES_PER_WINDOW |
            fPCD_MEM1_WS_THREE | fPCD_MEM2_WS_THREE |
            fPCD_IO1_SRC_16 | fPCD_IO2_SRC_16 |
            fPCD_IO1_WS_16 | fPCD_IO2_WS_16;

    if(*p && (*p == INFCHAR_ATTR_START)) {

        //
        // Read the attributes.
        //  W   - 16-bit I/O data path
        //  B   - 8-bit I/O data path
        //  Sn  - ~IOCS16 source.
        //  Zn  - I/O 8-bit zero wait state.
        //  XIn - I/O wait states.
        //  M   - 16-bit Memory
        //  M8  - 8-bit Memory
        //  XMn - Memory wait states
        //  A   - Attribute Memory
        //  C   - Common Memory
        //

        Field = ++p;
        if(!(p = _tcschr(Field,INFCHAR_ATTR_END))) {
            goto clean0;
        }

        while(Field < p) {

            switch((TCHAR)CharUpper((PTSTR)(*Field))) {

            case INFCHAR_PCCARD_IOATTR_WORD:
                if (ioWidthIndex >= PCD_MAX_IO) {
                    goto clean0;
                }
                Flags |= (ioWidthIndex++ ? fPCD_IO2_16
                                         : (fPCD_IO1_16 | fPCD_IO2_16));
                break;

            case INFCHAR_PCCARD_IOATTR_BYTE:
                if (ioWidthIndex >= PCD_MAX_IO) {
                    goto clean0;
                }
                Flags &= (ioWidthIndex++ ? ~fPCD_IO2_16
                                         : ~(fPCD_IO1_16 | fPCD_IO2_16));
                break;

            case INFCHAR_PCCARD_MEMATTR_WORD:
                if (memWidthIndex >= PCD_MAX_MEMORY) {
                    goto clean0;
                }
                if (++Field < p) {
                    if (*Field == TEXT('8')) {
                        Flags &= (memWidthIndex++ ? ~fPCD_MEM2_16
                                                  : ~(fPCD_MEM1_16 | fPCD_MEM2_16));
                        break;
                    }
                    // not an 8, back up 1
                    --Field;
                }
                Flags |= (memWidthIndex++ ? fPCD_MEM2_16
                                          : (fPCD_MEM1_16 | fPCD_MEM2_16));
                break;

            case INFCHAR_PCCARD_MEM_ISATTR:
                if (memAttrIndex >= PCD_MAX_MEMORY) {
                    goto clean0;
                }
                Flags |= (memAttrIndex++ ? fPCD_MEM2_A
                                         : (fPCD_MEM1_A | fPCD_MEM2_A));
                break;

            case INFCHAR_PCCARD_MEM_ISCOMMON:
                if (memAttrIndex >= PCD_MAX_MEMORY) {
                    goto clean0;
                }
                Flags &= (memAttrIndex++ ? ~fPCD_MEM2_A
                                         : ~(fPCD_MEM1_A | fPCD_MEM2_A));
                break;

            case INFCHAR_PCCARD_IOATTR_SRC:
                if (ioSourceIndex >= PCD_MAX_IO) {
                    goto clean0;
                }
                if (++Field < p) {
                    if (*Field == TEXT('0')) {
                        Flags &= (ioSourceIndex++ ? ~fPCD_IO2_SRC_16
                                                  : ~(fPCD_IO1_SRC_16 | fPCD_IO2_SRC_16));
                    } else if (*Field == TEXT('1')) {
                        Flags |= (ioSourceIndex++ ? fPCD_IO2_SRC_16
                                                  : (fPCD_IO1_SRC_16 | fPCD_IO2_SRC_16));
                    } else {
                        goto clean0;
                    }
                }
                break;

            case INFCHAR_PCCARD_IOATTR_Z8:
                if (ioZeroWait8Index >= PCD_MAX_IO) {
                    goto clean0;
                }
                if (++Field < p) {
                    if (*Field == TEXT('0')) {
                        Flags &= (ioZeroWait8Index++ ? ~fPCD_IO2_ZW_8
                                                     : ~(fPCD_IO1_ZW_8 | fPCD_IO2_ZW_8));
                    } else if (*Field == TEXT('1')) {
                        Flags |= (ioZeroWait8Index++ ? fPCD_IO2_ZW_8
                                                     : (fPCD_IO1_ZW_8 | fPCD_IO2_ZW_8));
                    } else {
                        goto clean0;
                    }
                }
                break;

            case INFCHAR_PCCARD_ATTR_WAIT:
                if (++Field < p) {

                    switch((TCHAR)CharUpper((PTSTR)(*Field))) {

                    case INFCHAR_PCCARD_ATTR_WAITI:
                        if (ioWaitState16Index >= PCD_MAX_IO) {
                            goto clean0;
                        }
                        if (++Field < p) {
                            if (*Field == TEXT('0')) {
                                Flags &= (ioWaitState16Index++ ? ~fPCD_IO2_WS_16
                                                               : ~(fPCD_IO1_WS_16 | fPCD_IO2_WS_16));
                            } else if (*Field == TEXT('1')) {
                                Flags |= (ioWaitState16Index++ ? fPCD_IO2_WS_16
                                                               : (fPCD_IO1_WS_16 | fPCD_IO2_WS_16));
                            } else {
                                goto clean0;
                            }
                        }
                        break;

                    case INFCHAR_PCCARD_ATTR_WAITM:
                        if (memWaitIndex >= PCD_MAX_MEMORY) {
                            goto clean0;
                        }
                        if (++Field < p) {

                            Flags &= (memWaitIndex ? ~mPCD_MEM2_WS
                                                   : ~(mPCD_MEM1_WS | mPCD_MEM2_WS));

                            if (*Field == TEXT('0')) {
                                memWaitIndex++;
                            } else if (*Field == TEXT('1')) {
                                Flags |= (memWaitIndex++ ? fPCD_MEM2_WS_ONE
                                                         : (fPCD_MEM1_WS_ONE | fPCD_MEM2_WS_ONE));
                            } else if (*Field == TEXT('2')) {
                                Flags |= (memWaitIndex++ ? fPCD_MEM2_WS_TWO
                                                         : (fPCD_MEM1_WS_TWO | fPCD_MEM2_WS_TWO));
                            } else if (*Field == TEXT('3')) {
                                Flags |= (memWaitIndex++ ? fPCD_MEM2_WS_THREE
                                                         : (fPCD_MEM1_WS_THREE | fPCD_MEM2_WS_THREE));
                            } else {
                                goto clean0;
                            }

                        }
                        break;

                    default:
                        goto clean0;
                    }
                }
                break;

            case INFCHAR_PCCARD_ATTR_SEP:
                break;

            default:
                // unknown character
                goto clean0;
            }
            if (Field < p) {
                Field++;
            }
        }
    }

    //
    // If we get to here, then we've successfully retrieved all the necessary information
    // needed to initialize the PC Card configuration resource descriptor.
    //
    ZeroMemory(&PcCardResource, sizeof(PcCardResource));

    PcCardResource.PcCard_Header.PCD_Count = 1;
    PcCardResource.PcCard_Header.PCD_Flags = Flags;
    PcCardResource.PcCard_Header.PCD_ConfigIndex = (BYTE)ConfigIndex;
    PcCardResource.PcCard_Header.PCD_MemoryCardBase1 = MemoryCardBase[0];
    PcCardResource.PcCard_Header.PCD_MemoryCardBase2 = MemoryCardBase[1];

    d = CM_Add_Res_Des_Ex(
            &ResDes,
            LogConfig,
            ResType_PcCardConfig,
            &PcCardResource,
            sizeof(PcCardResource),
            0,
            hMachine);

    d = MapCrToSpError(d, ERROR_INVALID_DATA);

    if(d == NO_ERROR) {
        CM_Free_Res_Des_Handle(ResDes);
    }

clean0:
    return d;
}


DWORD
pSetupProcessMfCardConfig(
    IN LOG_CONF    LogConfig,
    IN PINFCONTEXT InfLine,
    IN HMACHINE    hMachine
    )

/*++

Routine Description:

    Process a MfCardConfig line in a Win95 INF.  Such lines specify
    PCMCIA Multifunction card configuration information necessary for a device.
    There should normally be one MfCardConfig line per function. Each line is expected
    to be in the form:

    MfCardConfig = <ConfigRegBase>:<ConfigOptions>[:<IoResourceIndex>][(<attrs>)]

    where

        <ConfigRegBase> is the attribute offset of this function's
                        configuration registers

        <ConfigOptions> is the 8-bit PCMCIA configuration option register

        <IoResourceIndex> is the (optional) index to the Port Io resource descriptor
                          which will be used to program the configuration I/O base
                          and limit registers

        <attrs> is the optional set of attribute flags which can consist of:

                A - Audio enable should be set on in the configuration and status register

    All numeric values are assumed to be in hexadecimal format.

Arguments:

Return Value:

--*/

{
    MFCARD_RESOURCE MfCardResource;
    PCTSTR Field, p;
    DWORD ConfigOptions, i;
    DWORD ConfigRegisterBase, IoResourceIndex;
    DWORD Flags = 0;
    DWORD d = NO_ERROR;
    RES_DES ResDes;


    //
    // We should have one field (not counting the line's key)
    //
    if(SetupGetFieldCount(InfLine) != 1) {
        d = ERROR_INVALID_INF_LOGCONFIG;
    }

    if (d == NO_ERROR) {
        //
        // Retrieve the ConfigRegisterBase. It must be terminated by a colon.
        //
        Field = pSetupGetField(InfLine, 1);

        p = _tcschr(Field, INFCHAR_PCCARD_SEP);

        if(!p || !pHexToUlong(Field, p, &ConfigRegisterBase)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }

    if (d == NO_ERROR) {
        //
        // Retrieve the ConfigOptions.  It may be terminated by either a colon ':',
        // an open paren '(', or eol.
        //
        Field = p + 1;

        if(!(p = _tcschr(Field, INFCHAR_PCCARD_SEP)) && !(p = _tcschr(Field, INFCHAR_ATTR_START))) {
            p = Field + lstrlen(Field);
        }

        if(!pHexToUlong(Field, p, &ConfigOptions) || (ConfigOptions > 255)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }

    if ((d == NO_ERROR) && (*p == INFCHAR_PCCARD_SEP)) {
        //
        // Retrieve the IoResourceIndex. It may be terminated by either
        // an open paren '(', or eol.
        //

        Field = p + 1;
        if(!(p = _tcschr(Field, INFCHAR_ATTR_START))) {
            p = Field + lstrlen(Field);
        }
        if(!pHexToUlong(Field, p, &IoResourceIndex) || (IoResourceIndex > 255)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        }
    }


    if ((d == NO_ERROR) && (*p == INFCHAR_ATTR_START)) {
        //
        // Retrieve the attributes.
        //
        while (TRUE) {
            p++;

            if (!*p) {
                // Didn't find a close paren
                d = ERROR_INVALID_INF_LOGCONFIG;
                break;
            }

            if (*p == INFCHAR_ATTR_END) {
                if (*(p+1)) {
                    // found garbage after the close paren
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
                break;
            }

            if ((TCHAR)CharUpper((PTSTR)*p) == INFCHAR_MFCARD_AUDIO_ATTR) {
                Flags |= fPMF_AUDIO_ENABLE;
            } else {
                // bad flag
                d = ERROR_INVALID_INF_LOGCONFIG;
                break;
            }
        }
    }

    if(d == NO_ERROR) {
        //
        // If we get to here, then we've successfully retrieved all the necessary information
        // needed to initialize the multifunction PC Card configuration resource descriptor.
        //
        ZeroMemory(&MfCardResource, sizeof(MfCardResource));

        MfCardResource.MfCard_Header.PMF_Count = 1;
        MfCardResource.MfCard_Header.PMF_Flags = Flags;
        MfCardResource.MfCard_Header.PMF_ConfigOptions = (BYTE)ConfigOptions;
        MfCardResource.MfCard_Header.PMF_IoResourceIndex = (BYTE)IoResourceIndex;
        MfCardResource.MfCard_Header.PMF_ConfigRegisterBase = ConfigRegisterBase;

        d = CM_Add_Res_Des_Ex(
                &ResDes,
                LogConfig,
                ResType_MfCardConfig,
                &MfCardResource,
                sizeof(MfCardResource),
                0,
                hMachine);

        d = MapCrToSpError(d, ERROR_INVALID_DATA);

        if(d == NO_ERROR) {
            CM_Free_Res_Des_Handle(ResDes);
        }
    }
    return d;
}

#if 0
DWORD
pSetupProcessLogConfigLines(
    IN PVOID    Inf,
    IN PCTSTR   SectionName,
    IN PCTSTR   KeyName,
    IN DWORD    (*CallbackFunc)(LOG_CONFIG,PINFCONTEXT,HMACHINE),
    IN LOG_CONF LogConfig,
    IN HMACHINE hMachine
    )
{
    BOOL b;
    DWORD d;
    INFCONTEXT InfLine;

    b = SetupFindFirstLine(Inf,SectionName,KeyName,&InfLine);
    d = NO_ERROR;
    //
    // Process each line with a key that matches.
    //
    while(b && (d == NO_ERROR)) {

        d = CallbackFunc(LogConfig,&InfLine, hMachine);

        if(d == NO_ERROR) {
            b = SetupFindNextMatchLine(&InfLine,KeyName,&InfLine);
        }
    }

    return(d);
}

#endif

DWORD
pSetupProcessConfigPriority(
    IN  PVOID     Inf,
    IN  PCTSTR    SectionName,
    IN  LOG_CONF  LogConfig,
    OUT PRIORITY *PriorityValue,
    OUT DWORD    *ConfigType,
    IN  DWORD     Flags
    )
{
    INFCONTEXT InfLine;
    PCTSTR PrioritySpec;
    PCTSTR ConfigSpec;
    DWORD d = NO_ERROR;
    INT_PTR v;

    //
    // We only need to fetch one of these lines and look at the
    // first value on it.
    //
    if(SetupFindFirstLine(Inf,SectionName,pszConfigPriority,&InfLine)
       && (PrioritySpec = pSetupGetField(&InfLine,1))) {

        if(!LookUpStringInTable(InfPrioritySpecToPriority,PrioritySpec,&v)) {
            d = ERROR_INVALID_INF_LOGCONFIG;
        } else {
            *PriorityValue = (PRIORITY)v;
            //
            // The second value is optional and specifies whether the config is forced,
            // standard (i.e., basic), or override. If the value isn't specified then
            // assume basic, unless the Flags tell us otherwise.
            //
            ConfigSpec = pSetupGetField(&InfLine,2);
            if(!ConfigSpec || !*ConfigSpec) {

                if(Flags & SPINST_LOGCONFIG_IS_FORCED) {
                    *ConfigType = FORCED_LOG_CONF;
                } else if(Flags & SPINST_LOGCONFIGS_ARE_OVERRIDES) {
                    *ConfigType = OVERRIDE_LOG_CONF;
                } else {
                    *ConfigType = BASIC_LOG_CONF;
                }

            } else {

                if(LookUpStringInTable(InfConfigSpecToConfig, ConfigSpec, &v)) {
                    *ConfigType = (DWORD)v;
                    //
                    // A valid ConfigType was specified.  Let's make sure it doesn't disagree
                    // with any flags that were passed in to this routine.
                    //
                    if(Flags & SPINST_LOGCONFIG_IS_FORCED) {
                        if(*ConfigType != FORCED_LOG_CONF) {
                            d = ERROR_INVALID_INF_LOGCONFIG;
                        }
                    } else if(Flags & SPINST_LOGCONFIGS_ARE_OVERRIDES) {
                        if(*ConfigType != OVERRIDE_LOG_CONF) {
                            d = ERROR_INVALID_INF_LOGCONFIG;
                        }
                    }

                } else {
                    d = ERROR_INVALID_INF_LOGCONFIG;
                }
            }
        }

        //
        // If we successfully determined the LogConfig type as FORCED_LOG_CONF, then
        // set the priority to LCPRI_FORCECONFIG.
        //
        if((d == NO_ERROR) && (*ConfigType == FORCED_LOG_CONF)) {
            *PriorityValue = LCPRI_FORCECONFIG;
        }


    } else {

        *PriorityValue = (Flags & SPINST_LOGCONFIG_IS_FORCED) ? LCPRI_FORCECONFIG : LCPRI_NORMAL;

        if(Flags & SPINST_LOGCONFIG_IS_FORCED) {
            *ConfigType = FORCED_LOG_CONF;
        } else if(Flags & SPINST_LOGCONFIGS_ARE_OVERRIDES) {
            *ConfigType = OVERRIDE_LOG_CONF;
        } else {
            *ConfigType = BASIC_LOG_CONF;
        }
    }

    return d;
}


DWORD
pSetupProcessLogConfigSection(
    IN PVOID   Inf,
    IN PCTSTR  SectionName,
    IN DEVINST DevInst,
    IN DWORD   Flags,
    IN HMACHINE hMachine
    )
{
    DWORD d;
    LOG_CONF LogConfig;
    PRIORITY Priority;
    DWORD ConfigType;
    CONFIGRET cr;

    DWORD LineIndex = 0;
    INFCONTEXT InfLine;
    TCHAR Key[MAX_LOGCONFKEYSTR_LEN];

    //
    // Process config priority values.
    //

    //
    // LogConfig is used before initialized in following call.
    // It doesn't matter to function being called, but 6.0 compiler
    // doesn't like it, so init to 0.
    //

    LogConfig = 0;

    d = pSetupProcessConfigPriority(Inf,SectionName,LogConfig,&Priority,&ConfigType,Flags);
    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Now that we know the priority we can create an empty log config.
    //
    d = MapCrToSpError(CM_Add_Empty_Log_Conf_Ex(&LogConfig,DevInst,Priority,ConfigType,hMachine),
                       ERROR_INVALID_DATA
                      );

    if(d != NO_ERROR) {
        goto c0;
    }

    //
    // Iterate over the lines in the section adding entries to the log config in
    // the same order as they are found.
    //

    if (SetupFindFirstLine(Inf,SectionName,NULL,&InfLine)) {

        do {

            //
            // Get the key.
            //

            if (!SetupGetStringField(&InfLine,
                                     0, // Index 0 is the key field
                                     Key,
                                     MAX_LOGCONFKEYSTR_LEN,
                                     NULL
                                     )) {
                //
                // Either we didn't have a key or its longer than the longest
                // valid key - either way its invalid
                //

                d = ERROR_INVALID_INF_LOGCONFIG;
                goto c1;
            }

            if (!lstrcmpi(Key, pszMemConfig)) {

                //
                // Process MemConfig lines
                //

                d = pSetupProcessMemConfig(LogConfig, &InfLine, hMachine);

            } else if (!lstrcmpi(Key, pszIOConfig)) {

                //
                // Process IoConfig lines
                //

                d = pSetupProcessIoConfig(LogConfig, &InfLine, hMachine);

            } else if (!lstrcmpi(Key, pszIRQConfig)) {

                //
                // Process IRQConfig lines
                //

                d = pSetupProcessIrqConfig(LogConfig, &InfLine, hMachine);

            } else if (!lstrcmpi(Key, pszDMAConfig)) {

                //
                // Process DMAConfig lines
                //

                d = pSetupProcessDmaConfig(LogConfig, &InfLine, hMachine);

            } else if (!lstrcmpi(Key, pszPcCardConfig)) {

                //
                // Process PcCardConfig lines
                //

                d = pSetupProcessPcCardConfig(LogConfig, &InfLine, hMachine);

            } else if (!lstrcmpi(Key, pszMfCardConfig)) {

                //
                // Process MfCardConfig lines
                //

                d = pSetupProcessMfCardConfig(LogConfig, &InfLine, hMachine);

            } else {

                //
                // If we don't understand the line skip it
                //

                d = NO_ERROR;
            }

        } while (d == NO_ERROR && SetupFindNextMatchLine(&InfLine,NULL,&InfLine));
    }

#if 0
    //
    // Process MemConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszMemConfig,
            pSetupProcessMemConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process IOConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszIOConfig,
            pSetupProcessIoConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process IRQConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszIRQConfig,
            pSetupProcessIrqConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process DMAConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszDMAConfig,
            pSetupProcessDmaConfig,
            LogConfig,
            hMachine
            );

    if(d != NO_ERROR) {
        goto c1;
    }

    //
    // Process PcCardConfig lines
    //
    d = pSetupProcessLogConfigLines(
            Inf,
            SectionName,
            pszPcCardConfig,
            pSetupProcessPcCardConfig,
            LogConfig,
            hMachine
            );
#endif

c1:
    if(d != NO_ERROR) {
        CM_Free_Log_Conf(LogConfig,0);
    }
    CM_Free_Log_Conf_Handle(LogConfig);
c0:
    return(d);
}


DWORD
pSetupInstallLogConfig(
    IN HINF    Inf,
    IN PCTSTR  SectionName,
    IN DEVINST DevInst,
    IN DWORD   Flags,
    IN HMACHINE hMachine
    )

/*++

Routine Description:

    Look for logical configuration directives within an inf section
    and parse them. Each value on the LogConf= line is taken to be
    the name of a logical config section.

Arguments:

    Inf - supplies inf handle for inf containing the section indicated
        by SectionName.

    SectionName - supplies name of install section.

    DevInst - device instance handle for log configs.

    Flags - supplies flags that modify the behavior of this routine.  The
        following flags are payed attention to, everything else is ignored:

        SPINST_SINGLESECTION - if this bit is set, then the specified section
                               is a LogConf section, instead of an install
                               section containing LogConf entries.

        SPINST_LOGCONFIG_IS_FORCED - if this bit is set, then the LogConfigs
                                     to be written out are forced configs.
                                     If the ConfigType field of the ConfigPriority
                                     entry is present, and specifies something
                                     other than FORCED, this routine will fail
                                     with ERROR_INVALID_INF_LOGCONFIG.

        SPINST_LOGCONFIGS_ARE_OVERRIDES - if this bit is set, then the LogConfigs
                                          to be written out are override configs.
                                          If the ConfigType field of the ConfigPriority
                                          entry is present, and specifies something
                                          other than OVERRIDE, this routine will fail
                                          with ERROR_INVALID_INF_LOGCONFIG.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    INFCONTEXT LineContext;
    DWORD rc = NO_ERROR;
    DWORD FieldCount;
    DWORD Field;
    PCTSTR SectionSpec;

    if(Flags & SPINST_SINGLESECTION) {
        //
        // Process the specific LogConf section the caller specified.
        //
        if(SetupGetLineCount(Inf, SectionName) == -1) {
            rc = ERROR_SECTION_NOT_FOUND;
        } else {
            rc = pSetupProcessLogConfigSection(Inf, SectionName, DevInst, Flags,hMachine);
        }
    } else {
        //
        // Find the relevant line in the given install section.
        // If not present then we're done with this operation.
        //
        if(SetupFindFirstLine(Inf,SectionName,SZ_KEY_LOGCONFIG,&LineContext)) {

            do {
                //
                // Each value on the line in the given install section
                // is the name of a logical config section.
                //
                FieldCount = SetupGetFieldCount(&LineContext);
                for(Field=1; (rc==NO_ERROR) && (Field<=FieldCount); Field++) {

                    if((SectionSpec = pSetupGetField(&LineContext,Field))
                    && (SetupGetLineCount(Inf,SectionSpec) > 0)) {

                        rc = pSetupProcessLogConfigSection(Inf,SectionSpec,DevInst,Flags,hMachine);
                    } else {
                        rc = ERROR_SECTION_NOT_FOUND;
                    }
                    if (rc != NO_ERROR) {
                        pSetupLogSectionError(Inf,NULL,NULL,NULL,SectionSpec,MSG_LOG_SECT_ERROR,rc,SZ_KEY_LOGCONFIG);
                    }
                }

            } while((rc == NO_ERROR) && SetupFindNextMatchLine(&LineContext,SZ_KEY_LOGCONFIG,&LineContext));
        }
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infold.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    infold.c

Abstract:

    Routines to load an old-style inf file.
    Based on prsinf\spinf.c

Author:

    Ted Miller (tedm) 19-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Internal temporary representation of the inf file.
// The win95 representation is built from these structures
// which are then throw away.
//
typedef struct _X_VALUE {
    struct _X_VALUE *Next;
    PTCHAR Name;
} X_VALUE, *PX_VALUE;

typedef struct _X_LINE {
    struct _X_LINE *Next;
    PTCHAR Name;
    PX_VALUE Value;
    UINT ValueCount;
} X_LINE, *PX_LINE;

typedef struct _X_SECTION {
    struct _X_SECTION *Next;
    PTCHAR Name;
    PX_LINE Line;
    UINT LineCount;
} X_SECTION, *PX_SECTION;

typedef struct _X_INF {
    PX_SECTION Section;
    UINT SectionCount;
    UINT TotalLineCount;
    UINT TotalValueCount;
} X_INF, *PX_INF;


//
// Global parse context.
//
typedef struct _PARSE_CONTEXT {
    PX_INF Inf;
    PX_SECTION Section;
    PX_LINE Line;
    PX_VALUE Value;
} PARSE_CONTEXT, *PPARSE_CONTEXT;

//
// Token parser values.
//
typedef enum _X_TOKENTYPE {
    TOK_EOF,
    TOK_EOL,
    TOK_LBRACE,
    TOK_RBRACE,
    TOK_STRING,
    TOK_EQUAL,
    TOK_COMMA,
    TOK_ERRPARSE,
    TOK_ERRNOMEM
} X_TOKENTYPE, *PX_TOKENTTYPE;

//
// Token parser data type
//
typedef struct _X_TOKEN {
    X_TOKENTYPE Type;
    PTCHAR pValue;
} X_TOKEN, *PX_TOKEN;


//
// string terminators are the whitespace characters (isspace: space, tab,
// linefeed, formfeed, vertical tab, carriage return) or the chars given below
//
// quoted string terminators allow some of the regular terminators to
// appear as characters
//
PTCHAR szStrTerms    = TEXT("[]=,\" \t\n\f\v\r");
PTCHAR szBrcStrTerms = TEXT("[]=,\"\t\n\f\v\r");
PTCHAR szQStrTerms   = TEXT("\"\n\f\v\r");
PTCHAR szCBrStrTerms = TEXT("}\n\f\v\r");

#define IsStringTerminator(terminators,ch)   (_tcschr((terminators),(ch)) != NULL)


VOID
SpFreeTemporaryParseStructures(
   IN PX_INF Inf
   )

/*++

Routine Description:

    Free the structures built by the old-style-inf parser.

Arguments:

    Inf - supplies pointer to inf descriptor structure.

Return Value:

    None.

--*/

{
    PX_SECTION Section,NextSection;
    PX_LINE Line,NextLine;
    PX_VALUE Value,NextValue;

    for(Section=Inf->Section; Section; Section=NextSection) {

        for(Line=Section->Line; Line; Line=NextLine) {

            for(Value=Line->Value; Value; Value=NextValue) {

                NextValue = Value->Next;
                if(Value->Name) {
                    MyFree(Value->Name);
                }
                MyFree(Value);
            }

            NextLine = Line->Next;
            if(Line->Name) {
                MyFree(Line->Name);
            }
            MyFree(Line);
        }

        NextSection = Section->Next;
        MyFree(Section->Name);
        MyFree(Section);
    }

    MyFree(Inf);
}


BOOL
SpAppendSection(
    IN PPARSE_CONTEXT Context,
    IN PTCHAR         SectionName
    )

/*++

Routine Description:

    This appends a new section to the section list in the current INF.
    All further lines and values pertain to this new section, so it resets
    the line list and value lists too.

Arguments:

    Context - supplies the parse context

    SectionName - Name of the new section. ( [SectionName] )

Return Value:

    BOOL - FALSE if failure (out of memory)

--*/

{
    PX_SECTION NewSection;

    MYASSERT(Context->Inf);

    //
    // Allocate memory for the new section
    //
    if((NewSection = MyMalloc(sizeof(X_SECTION))) == NULL) {
        return(FALSE);
    }

    //
    // initialize the new section
    //
    ZeroMemory(NewSection,sizeof(X_SECTION));
    NewSection->Name = SectionName;

    //
    // Link it in
    //
    if(Context->Section) {
        Context->Section->Next = NewSection;
    } else {
        Context->Inf->Section = NewSection;
    }

    Context->Section = NewSection;

    //
    // reset the current line record and current value record field
    //
    Context->Line = NULL;
    Context->Value = NULL;

    Context->Inf->SectionCount++;

    return(TRUE);
}


BOOL
SpAppendLine(
    IN PPARSE_CONTEXT Context,
    IN PTCHAR         LineKey
    )

/*++

Routine Description:

    This appends a new line to the line list in the current section.
    All further values pertain to this new line, so it resets
    the value list too.

Arguments:

    Context - supplies the parse context.

    LineKey - Key to be used for the current line, this could be NULL.

Return Value:

    BOOL - FALSE if failure (out of memory)

--*/


{
    PX_LINE NewLine;

    MYASSERT(Context->Section);

    //
    // Allocate memory for the new Line
    //
    if((NewLine = MyMalloc(sizeof(X_LINE))) == NULL) {
        return(FALSE);
    }

    ZeroMemory(NewLine,sizeof(X_LINE));

    NewLine->Name = LineKey;

    //
    // Link it in
    //
    if(Context->Line) {
        Context->Line->Next = NewLine;
    } else {
        Context->Section->Line = NewLine;
    }

    Context->Line = NewLine;

    //
    // Reset the current value record
    //
    Context->Value = NULL;

    //
    // Adjust counts.
    //
    Context->Inf->TotalLineCount++;
    Context->Section->LineCount++;
    if(LineKey) {
        Context->Inf->TotalValueCount++;
        NewLine->ValueCount = 1;
    }

    return(TRUE);
}


BOOL
SpAppendValue(
    IN PPARSE_CONTEXT Context,
    IN PTCHAR         ValueString
    )

/*++

Routine Description:

    This appends a new value to the value list in the current line.

Arguments:

    Context - supplies the parse context.

    ValueString - The value string to be added.

Return Value:

    BOOL - FALSE if failure (out of memory)

--*/

{
    PX_VALUE NewValue;

    MYASSERT(Context->Line);

    //
    // Allocate memory for the new value record
    //
    if((NewValue = MyMalloc(sizeof(X_VALUE))) == NULL) {
        return(FALSE);
    }

    ZeroMemory(NewValue,sizeof(X_VALUE));

    NewValue->Name = ValueString;

    //
    // Link it in.
    //
    if(Context->Value) {
        Context->Value->Next = NewValue;
    } else {
        Context->Line->Value = NewValue;
    }

    //
    // Adjust counts
    //
    Context->Value = NewValue;
    Context->Inf->TotalValueCount++;
    Context->Line->ValueCount++;

    return(TRUE);
}



X_TOKEN
SpGetToken(
    IN OUT PCTSTR *Stream,
    IN     PCTSTR  StreamEnd,
    IN     PTCHAR  pszStrTerms,
    IN     PTCHAR  pszQStrTerms,
    IN     PTCHAR  pszCBrStrTerms
    )

/*++

Routine Description:

    This function returns the Next token from the configuration stream.

Arguments:

    Stream - Supplies the address of the configuration stream.  Returns
        the address of where to start looking for tokens within the
        stream.

    StreamEnd - Supplies the memory address immediately following the
        character stream.

Return Value:

    The next token

--*/

{

    PCTSTR pch, pchStart;
    PTCHAR pchNew;
    DWORD Length, i;
    X_TOKEN Token;

    //
    // Skip whitespace (except for eol)
    //
    pch = *Stream;

    while(pch < StreamEnd) {

        SkipWhitespace(&pch, StreamEnd);

        if((pch < StreamEnd) && !(*pch)) {
            //
            // We hit a NULL char--skip it
            // and keep looking for a token.
            //
            pch++;

        } else {
            break;
        }
    }

    //
    // Check for comments and remove them
    //
    if((pch < StreamEnd) &&
       ((*pch == TEXT(';')) || (*pch == TEXT('#')) ||
        ((*pch == TEXT('/')) && (*(pch+1) == TEXT('/')))))
    {
        do {
            pch++;
        } while((pch < StreamEnd) && (*pch != TEXT('\n')));
    }

    if(pch == StreamEnd) {
        *Stream = pch;
        Token.Type = TOK_EOF;
        Token.pValue = NULL;
        return(Token);
    }

    switch (*pch) {

    case TEXT('['):
        pch++;
        Token.Type = TOK_LBRACE;
        Token.pValue = NULL;
        break;

    case TEXT(']'):
        pch++;
        Token.Type = TOK_RBRACE;
        Token.pValue = NULL;
        break;

    case TEXT('='):
        pch++;
        Token.Type = TOK_EQUAL;
        Token.pValue = NULL;
        break;

    case TEXT(','):
        pch++;
        Token.Type = TOK_COMMA;
        Token.pValue = NULL;
        break;

    case TEXT('\n'):
        pch++;
        Token.Type = TOK_EOL;
        Token.pValue = NULL;
        break;

    case TEXT('\"'):
        pch++;
        //
        // determine quoted string
        //
        pchStart = pch;
        while((pch < StreamEnd) && !IsStringTerminator(pszQStrTerms,*pch)) {
            pch++;
        }

        //
        //
        // Only valid terminator is double quote
        //
        if((pch == StreamEnd) || (*pch != TEXT('\"'))) {
            Token.Type = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {

            //
            // Got a valid string. Allocate space for it and save.
            //
            Length = (DWORD)(pch - pchStart);
            if((pchNew = MyMalloc((Length+1)*sizeof(TCHAR))) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                //
                // We can't use string copy here, since there may be
                // NULL chars in the string (which we convert to
                // spaces during the copy).
                //
                // lstrcpyn(pchNew,pchStart,Length+1);
                //
                for(i = 0; i < Length; i++) {
                    if(!(pchNew[i] = pchStart[i])) {
                        pchNew[i] = TEXT(' ');
                    }
                }
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
            pch++;   // advance past the quote
        }
        break;

    case TEXT('{'):
        //
        // determine quoted string
        //
        pchStart = pch;
        while((pch < StreamEnd) && !IsStringTerminator(pszCBrStrTerms,*pch)) {
            pch++;
        }

        //
        // Only valid terminator is curly brace
        if((pch == StreamEnd) || (*pch != TEXT('}'))) {
            Token.Type = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {

            //
            // Got a valid string. Allocate space for it and save.
            //
            Length = (DWORD)(pch - pchStart) + 1;
            if((pchNew = MyMalloc((Length+1)*sizeof(TCHAR))) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                //
                // We can't use string copy here, since there may be
                // NULL chars in the string (which we convert to
                // spaces during the copy).
                //
                // lstrcpyn(pchNew,pchStart,Length+1);
                //
                for(i = 0; i < Length; i++) {
                    if(!(pchNew[i] = pchStart[i])) {
                        pchNew[i] = TEXT(' ');
                    }
                }
                pchNew[Length] = TEXT('\0');
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
            pch++;   // advance past the brace
        }
        break;

    default:
        //
        // determine regular string
        //
        pchStart = pch;
        while((pch < StreamEnd) && !IsStringTerminator(pszStrTerms,*pch)) {
            pch++;
        }

        //
        // Disallow empty strings here
        //
        if(pch == pchStart) {
            pch++;
            Token.Type = TOK_ERRPARSE;
            Token.pValue = NULL;
        } else {

            Length = (DWORD)(pch - pchStart);
            if((pchNew = MyMalloc((Length+1)*sizeof(TCHAR))) == NULL) {
                Token.Type = TOK_ERRNOMEM;
                Token.pValue = NULL;
            } else {
                //
                // We can't use string copy here, since there may be
                // NULL chars in the string (which we convert to
                // spaces during the copy).
                //
                // lstrcpyn(pchNew,pchStart,Length+1);
                //
                for(i = 0; i < Length; i++) {
                    if(!(pchNew[i] = pchStart[i])) {
                        pchNew[i] = TEXT(' ');
                    }
                }
                pchNew[Length] = 0;
                Token.Type = TOK_STRING;
                Token.pValue = pchNew;
            }
        }
        break;
    }

    *Stream = pch;
    return(Token);
}


DWORD
ParseInfBuffer(
    IN  PCTSTR  Buffer,
    IN  DWORD   BufferSize,
    OUT PX_INF *Inf,
    OUT UINT   *ErrorLineNumber
    )

/*++

Routine Description:

    Given a character buffer containing the INF file, this routine parses
    the INF into an internal form with Section records, Line records and
    Value records.

Arguments:

    Buffer - contains to ptr to a buffer containing the INF file

    BufferSize - contains the size of Buffer, in characters.

    Inf - if the return value is NO_ERROR, receives a pointer to the
        inf descriptor for the parsed inf.

    ErrorLineNumber - receives the line number where a syntax/oom error
        was encountered, if the return value is not NO_ERROR.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

    If NO_ERROR, Inf is filled in.
    If not NO_ERROR, ErrorLineNumber is filled in.

--*/

{
    PCTSTR Stream, StreamEnd;
    PTCHAR pchSectionName, pchValue, pchEmptyString;
    DWORD State, InfLine;
    DWORD LastState;
    X_TOKEN Token;
    BOOL Done;
    PTCHAR pszStrTermsCur    = szStrTerms;
    PTCHAR pszQStrTermsCur   = szQStrTerms;
    PTCHAR pszCBrStrTermsCur = szCBrStrTerms;
    DWORD ErrorCode;
    PARSE_CONTEXT Context;

    //
    // Initialize the globals and create an inf record structure.
    //
    ZeroMemory(&Context,sizeof(PARSE_CONTEXT));
    if((Context.Inf = MyMalloc(sizeof(X_INF))) == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    ZeroMemory(Context.Inf,sizeof(X_INF));

    //
    // Set initial state
    //
    State     = 1;
    LastState = State;
    InfLine   = 1;
    StreamEnd = (Stream = Buffer) + BufferSize;
    Done      = FALSE;
    ErrorCode = NO_ERROR;

    //
    // Initialize the token type, so we'll know not to free any
    // memory for it if we hit an exception right off the bat.
    //
    Token.Type = TOK_ERRPARSE;

    pchSectionName = NULL;
    pchValue       = NULL;
    pchEmptyString = NULL;

    //
    // Guard token processing loop with try/except in case we
    // get an inpage error.
    //
    try {

        while(!Done) {

            Token = SpGetToken(&Stream,
                               StreamEnd,
                               pszStrTermsCur,
                               pszQStrTermsCur,
                               pszCBrStrTermsCur
                              );

            //
            // If you need to debug the parser, uncomment the following:
#if 0
             DebugPrintEx(DPFLTR_ERROR_LEVEL, TEXT("STATE: %u TOKEN: %u (%s) LAST: %u\r\n"),
                        State, Token.Type,
                        Token.pValue ? Token.pValue : TEXT("NULL"),
                        LastState);
#endif

            if(Token.Type == TOK_ERRNOMEM) {
                 Done = TRUE;
                 ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                switch (State) {
                //
                // STATE1: Start of file, this state remains till first
                //         section is found
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_LBRACE
                //
                case 1:
                    switch (Token.Type) {

                    case TOK_EOL:
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_LBRACE:
                        pszStrTermsCur = szBrcStrTerms;
                        State = 2;
                        break;

                    default:
                        Done = TRUE;
                        ErrorCode = ERROR_EXPECTED_SECTION_NAME;
                        break;
                    }
                    break;

                //
                // STATE 2: Section LBRACE has been received, expecting STRING
                //
                // Valid Tokens: TOK_STRING
                //
                case 2:
                    //
                    // allow spaces in section names
                    //
                    switch (Token.Type) {

                    case TOK_STRING:
                        State = 3;
                        //
                        // restore term. string with space
                        //
                        pszStrTermsCur = szStrTerms;
                        pchSectionName = Token.pValue;
                        break;

                    default:
                        Done = TRUE;
                        ErrorCode = ERROR_BAD_SECTION_NAME_LINE;
                        break;
                    }
                    break;

                //
                // STATE 3: Section Name received, expecting RBRACE
                //
                // Valid Tokens: TOK_RBRACE
                //
                case 3:
                    switch (Token.Type) {

                    case TOK_RBRACE:
                        State = 4;
                        break;

                    default:
                        Done = TRUE;
                        ErrorCode = ERROR_BAD_SECTION_NAME_LINE;
                        break;
                    }
                    break;

                //
                // STATE 4: Section Definition Complete, expecting EOL
                //
                // Valid Tokens: TOK_EOL, TOK_EOF
                //
                case 4:
                    switch (Token.Type) {

                    case TOK_EOL:
                        if(SpAppendSection(&Context,pchSectionName)) {
                            pchSectionName = NULL;
                            State = 5;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            Done = TRUE;
                        }
                        break;

                    case TOK_EOF:
                        if(SpAppendSection(&Context,pchSectionName)) {
                            pchSectionName = NULL;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Done = TRUE;
                        break;

                    default:
                        ErrorCode = ERROR_BAD_SECTION_NAME_LINE;
                        Done = TRUE;
                        break;
                    }
                    break;

                //
                // STATE 5: Expecting Section Lines
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_STRING, TOK_LBRACE
                //
                case 5:
                    switch (Token.Type) {

                    case TOK_EOL:
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_STRING:
                        pchValue = Token.pValue;
                        //
                        // Set token's pValue pointer to NULL, so we won't
                        // try to free the same memory twice if we hit an
                        // exception
                        //
                        Token.pValue = NULL;
                        State = 6;
                        break;

                    case TOK_LBRACE:
                        pszStrTermsCur = szBrcStrTerms;
                        State = 2;
                        break;

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 5;
                        break;
                    }
                    break;

                //
                // STATE 6: String returned, not sure whether it is key or value
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA, TOK_EQUAL
                //
                case 6:
                    switch (Token.Type) {

                    case TOK_EOL:
                        if(SpAppendLine(&Context,NULL) && SpAppendValue(&Context,pchValue)) {
                            pchValue = NULL;
                            State = 5;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            Done = TRUE;
                        }
                        break;

                    case TOK_EOF:
                        if(SpAppendLine(&Context,NULL) && SpAppendValue(&Context,pchValue)) {
                            pchValue = NULL;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Done = TRUE;
                        break;

                    case TOK_COMMA:
                        if(SpAppendLine(&Context,NULL) && SpAppendValue(&Context,pchValue)) {
                            pchValue = NULL;
                            State = 7;
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        break;

                    case TOK_EQUAL:
                        if(SpAppendLine(&Context,pchValue)) {
                            pchValue = NULL;
                            State = 8;
                        } else {
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            Done = TRUE;
                        }
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        //
                        if(pchValue) {
                            MyFree(pchValue);
                            pchValue = NULL;
                        }
                        State = 20;
                        LastState = 5;
                        break;
                    }
                    break;

                //
                // STATE 7: Comma received, Expecting another string
                //
                // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 7:
                    switch (Token.Type) {

                    case TOK_STRING:
                        if(SpAppendValue(&Context,Token.pValue)) {
                            State = 9;
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        break;

                    case TOK_COMMA:
                    case TOK_EOL:
                    case TOK_EOF:
                        //
                        // If we hit end-of-line or end-of-file, then add an
                        // empty-string value.
                        //
                        if(pchEmptyString = MyMalloc(sizeof(TCHAR))) {
                            *pchEmptyString = TEXT('\0');
                            if(SpAppendValue(&Context, pchEmptyString)) {
                                if(Token.Type == TOK_EOL) {
                                    State = 5;
                                } else if (Token.Type == TOK_COMMA) {
                                    State = 7;
                                } else {
                                    Done = TRUE;
                                }
                            } else {
                                MyFree(pchEmptyString);
                                pchEmptyString = NULL;
                                Done = TRUE;
                                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        pchEmptyString = NULL;
                        break;

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 7;
                        break;
                    }
                    break;

                //
                // STATE 8: Equal received, Expecting another string
                //
                // Valid Tokens: TOK_STRING, TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 8:
                    switch (Token.Type) {

                    case TOK_STRING:
                        if(SpAppendValue(&Context,Token.pValue)) {
                            State = 9;
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        break;

                    case TOK_COMMA:
                    case TOK_EOL:
                    case TOK_EOF:
                        //
                        // If we hit end-of-line or end-of-file, then add an
                        // empty-string value.
                        //
                        if(pchEmptyString = MyMalloc(sizeof(TCHAR))) {
                            *pchEmptyString = TEXT('\0');
                            if(SpAppendValue(&Context, pchEmptyString)) {
                                if(Token.Type == TOK_EOL) {
                                    State = 5;
                                } else if (Token.Type == TOK_COMMA) {
                                    State = 7;
                                } else {
                                    Done = TRUE;
                                }
                            } else {
                                MyFree(pchEmptyString);
                                pchEmptyString = NULL;
                                Done = TRUE;
                                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {
                            Done = TRUE;
                            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        pchEmptyString = NULL;
                        break;

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 8;
                        break;
                    }
                    break;

                //
                // STATE 9: String received after equal, value string
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 9:
                    switch (Token.Type) {

                    case TOK_EOL:
                        State = 5;
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_COMMA:
                        State = 7;
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 5;
                        break;
                    }
                    break;

                //
                // STATE 10: Value string definitely received
                //
                // Valid Tokens: TOK_EOL, TOK_EOF, TOK_COMMA
                //
                case 10:
                    switch (Token.Type) {

                    case TOK_EOL:
                      State =5;
                      break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_COMMA:
                        State = 7;
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        // Done = TRUE;
                        // ErrorCode = ERROR_GENERAL_SYNTAX;
                        State = 20;
                        LastState = 10;
                        break;
                    }
                    break;

                //
                // STATE 20: Eat a line of INF
                //
                // Valid Tokens: TOK_EOL, TOK_EOF
                //
                case 20:
                    switch (Token.Type) {

                    case TOK_EOL:
                        State = LastState;
                        break;

                    case TOK_EOF:
                        Done = TRUE;
                        break;

                    case TOK_STRING:
                        MyFree(Token.pValue);
                        Token.pValue = NULL;
                        // fall through

                    default:
                        break;
                    }
                    break;

                default:

                    Done = TRUE;
                    ErrorCode = ERROR_GENERAL_SYNTAX;
                    break;

                } // end switch(State)

            } // end else

            if(ErrorCode == NO_ERROR) {

                //
                // Keep track of line numbers
                //
                if(Token.Type == TOK_EOL) {
                    InfLine++;
                }

            }

        } // End while

    } except(EXCEPTION_EXECUTE_HANDLER) {

        ErrorCode = ERROR_READ_FAULT;

        //
        // Reference the following string pointers here in the except clause so that
        // the compiler won't re-order the code in such a way that we don't know whether
        // or not to free the corresponding buffers.
        //
        Token.pValue   = Token.pValue;
        pchEmptyString = pchEmptyString;
        pchSectionName = pchSectionName;
        pchValue       = pchValue;
    }

    if(ErrorCode != NO_ERROR) {

        if((Token.Type == TOK_STRING) && Token.pValue) {
             MyFree(Token.pValue);
        }

        if(pchEmptyString) {
            MyFree(pchEmptyString);
        }

        if(pchSectionName) {
            MyFree(pchSectionName);
        }

        if(pchValue) {
            MyFree(pchValue);
        }

        SpFreeTemporaryParseStructures(Context.Inf);
        Context.Inf = NULL;

        *ErrorLineNumber = InfLine;
    }

    *Inf = Context.Inf;
    return(ErrorCode);
}


DWORD
ParseOldInf(
    IN  PCTSTR       FileImage,
    IN  DWORD        FileImageSize,
    IN  PSETUP_LOG_CONTEXT LogContext, OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT UINT        *ErrorLineNumber
    )

/*++

Routine Description:

    Top-level routine to parse an old-style inf file.

    The file is first parsed using the old parser, into data structures
    understood by that parser. Following that those structures are converted
    into the universal internal inf format.

Arguments:

    FileImage - supplies a pointer to the in-memory image of the file.
        The image is assumed to be terminated by a nul character.

    FileImageSize - supplies the number of wide chars in the FileImage.

    LogContext - supplies optional logging context

    Inf - receives a pointer to the inf descriptor for the file.

    ErrorLineNumber - receives the line number of a syntx error if one is
        detected in the inf file.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

    If NO_ERROR, Inf is filled in.
    If not NO_ERROR, ErrorLineNumber is filled in.

--*/

{
    PLOADED_INF inf;
    PX_INF X_Inf;
    DWORD rc;
    PX_SECTION X_Section;
    PX_LINE X_Line;
    PX_VALUE X_Value;
    LONG StringId, StringId2;
    BOOL b;
    UINT LineNumber;
    UINT ValueNumber;
    PLONG TempValueBlock;
    PTSTR SearchString;

    //
    // First go off and parse the file into the temporary (old-style)
    // inf structures.
    //
    rc = ParseInfBuffer(FileImage,FileImageSize,&X_Inf,ErrorLineNumber);
    if(rc != NO_ERROR) {
        return(rc);
    }

    //
    // Allocate a new-style inf descriptor.  (Note that we allocate an additional
    // <TotalLineCount> number of values, since each line may have a key, which
    // requires two values each.  We'll trim this down later on.)
    //
    inf = AllocateLoadedInfDescriptor(X_Inf->SectionCount,
                                      X_Inf->TotalLineCount,
                                      X_Inf->TotalValueCount + X_Inf->TotalLineCount,
                                      LogContext
                                     );

    if(!inf) {
        SpFreeTemporaryParseStructures(X_Inf);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    inf->Style = INF_STYLE_OLDNT;

    //
    // Now, parse the old-style inf structures into new-style inf structures.
    //
    b = TRUE;
    LineNumber = 0;
    ValueNumber = 0;
    for(X_Section=X_Inf->Section; b && X_Section; X_Section=X_Section->Next) {

        //
        // Add the section to the section block.
        //
        StringId = pStringTableAddString(inf->StringTable,
                                         X_Section->Name,
                                         STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                         NULL,0
                                        );
        if(StringId == -1) {
            b = FALSE;
        } else {
            inf->SectionBlock[inf->SectionCount].SectionName = StringId;
            inf->SectionBlock[inf->SectionCount].LineCount = X_Section->LineCount;
            inf->SectionBlock[inf->SectionCount].Lines = LineNumber;

            inf->SectionCount++;
        }

        for(X_Line=X_Section->Line; b && X_Line; X_Line=X_Line->Next) {

            //
            // Add the line to the line block.
            //
            inf->LineBlock[LineNumber].ValueCount = (WORD)X_Line->ValueCount;

            if(X_Line->Name) {
                inf->LineBlock[LineNumber].Flags = INF_LINE_HASKEY | INF_LINE_SEARCHABLE;
                inf->LineBlock[LineNumber].ValueCount++;
            } else if(X_Line->ValueCount == 1) {
                //
                // If the line only has a single value, then it's searchable, even if it
                // doesn't have a key.
                //
                inf->LineBlock[LineNumber].Flags = INF_LINE_SEARCHABLE;
                inf->LineBlock[LineNumber].ValueCount++;
            } else {
                inf->LineBlock[LineNumber].Flags = 0;
            }

            if(b) {

                inf->LineBlock[LineNumber].Values = ValueNumber;
                X_Value = X_Line->Value;

                //
                // If the line is searchable (i.e., has a key xor a single value), then add the
                // search value twice--once case insensitively and once case-sensitively.
                //
                if(ISSEARCHABLE(&(inf->LineBlock[LineNumber]))) {

                    if(X_Line->Name) {
                        SearchString = X_Line->Name;
                    } else {
                        SearchString = X_Value->Name;
                        X_Value = X_Value->Next;
                    }

                    //
                    // First get the case-sensitive string id...
                    //
                    StringId = pStringTableAddString(
                                    inf->StringTable,
                                    SearchString,
                                    STRTAB_CASE_SENSITIVE,
                                    NULL,0
                                    );
                    //
                    // And now get the case-insensitive string id...
                    //
                    StringId2 = pStringTableAddString(inf->StringTable,
                                                      SearchString,
                                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                      NULL,0
                                                     );

                    if((StringId == -1) || (StringId2 == -1)) {
                        b = FALSE;
                    } else {
                        inf->ValueBlock[ValueNumber++] = StringId2;  // Add the searchable string...
                        inf->ValueBlock[ValueNumber++] = StringId;   // and then the displayable one.
                    }
                }

                for( ; b && X_Value; X_Value=X_Value->Next) {

                    //
                    // Add the value to the value block.
                    //
                    StringId = pStringTableAddString(inf->StringTable,
                                                     X_Value->Name,
                                                     STRTAB_CASE_SENSITIVE,
                                                     NULL,0
                                                    );
                    if(StringId == -1) {
                        b = FALSE;
                    } else {
                        inf->ValueBlock[ValueNumber++] = StringId;
                    }
                }

                LineNumber++;
            }
        }
    }

    //
    // Record the sizes of the INF data blocks.
    //
    inf->SectionBlockSizeBytes = X_Inf->SectionCount * sizeof(INF_SECTION);
    inf->LineBlockSizeBytes    = X_Inf->TotalLineCount * sizeof(INF_LINE);

    //
    // We don't need the temporary inf descriptors any more.
    //
    SpFreeTemporaryParseStructures(X_Inf);

    //
    // Attempt to trim the value block down to exact size necessary.  Since this buffer is
    // either shrinking or staying the same, the realloc shouldn't fail, but if it does, we'll
    // just continue to use the original block.
    //
    inf->ValueBlockSizeBytes = ValueNumber * sizeof(LONG);
    if(TempValueBlock = MyRealloc(inf->ValueBlock, ValueNumber * sizeof(LONG))) {
        inf->ValueBlock = TempValueBlock;
    }

    //
    // If an error has occured, free the inf descriptor we've
    // been building. Otherwise we want to pass that descriptor
    // back to the caller.
    //
    if(b) {
        *Inf = inf;
    } else {
        *ErrorLineNumber = 0;
        FreeLoadedInfDescriptor(inf);
    }

    return(b ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY);
}


DWORD
ProcessOldInfVersionBlock(
    IN PLOADED_INF Inf
    )

/*++

Routine Description:

    Set up a version node for an old-style inf file. The version node is
    simulated in that there is no [Version] section; we look for other stuff
    in the file to simulate version information.

    Class is determined from [Identification].OptionType.
    Signature is determined from [Signature].FileType.
    If the signature is MICROSOFT_FILE then we set the Provider to the localized
    version of "Microsoft."

Arguments:

    Inf - supplies a pointer to the inf descriptor for the file.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

--*/

{
    TCHAR StrBuf[128];
    PTSTR String;

    //
    // Class
    //
    if(String = InfGetKeyOrValue(Inf, TEXT("Identification"), TEXT("OptionType"), 0, 1, NULL)) {
        if(!AddDatumToVersionBlock(&(Inf->VersionBlock), pszClass, String)) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Signature
    //
    if(String = InfGetKeyOrValue(Inf, pszSignature, TEXT("FileType"), 0, 1, NULL)) {
        if(!AddDatumToVersionBlock(&(Inf->VersionBlock), pszSignature, String)) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Provider
    //
    if(String && !lstrcmpi(String, TEXT("MICROSOFT_FILE"))) {

        LoadString(MyDllModuleHandle, IDS_MICROSOFT, StrBuf, sizeof(StrBuf)/sizeof(TCHAR));

        if(!AddDatumToVersionBlock(&(Inf->VersionBlock), pszProvider, StrBuf)) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infline.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    infline.c

Abstract:

    Externally exposed INF routines for INF line retreival and information.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupFindFirstLineA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  PCSTR       Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )
{
    PCTSTR section,key;
    BOOL b;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(Section,&section)) != NO_ERROR) {
        //
        // Invalid arg.
        //
        SetLastError(d);
        return(FALSE);
    }

    if(Key) {
        if((d = pSetupCaptureAndConvertAnsiArg(Key,&key)) != NO_ERROR) {
            //
            // Invalid arg.
            //
            MyFree(section);
            SetLastError(d);
            return(FALSE);
        }
    } else {
        key = NULL;
    }

    b = SetupFindFirstLine(InfHandle,section,key,Context);
    //
    // We're safe in calling this here regardless of success or failure, since
    // we are ensured that SetupFindFirstLine will always call SetLastError().
    //
    d = GetLastError();

    if(key) {
        MyFree(key);
    }
    MyFree(section);

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupFindFirstLineW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  PCWSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupFindFirstLine(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  PCTSTR      Key,          OPTIONAL
    OUT PINFCONTEXT Context
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    PINF_SECTION InfSection;
    PINF_LINE InfLine;
    UINT LineNumber;
    UINT SectionNumber;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        d = ERROR_INVALID_HANDLE;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    //
    // Traverse the linked list of loaded INFs, looking for the specified
    // section.
    //
    try {
        for(CurInf = (PLOADED_INF)InfHandle; CurInf; CurInf = CurInf->Next) {
            //
            // Locate the section.
            //
            if(!(InfSection = InfLocateSection(CurInf, Section, &SectionNumber))) {
                continue;
            }

            //
            // Attempt to locate the line within this section.
            //
            LineNumber = 0;
            if(InfLocateLine(CurInf, InfSection, Key, &LineNumber, &InfLine)) {
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)InfHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    if(CurInf) {
        //
        // Then we found the specified line.
        //
        MYASSERT(Key || !LineNumber);
        try {
            Context->Inf = (PVOID)InfHandle;
            Context->CurrentInf = (PVOID)CurInf;
            Context->Section = SectionNumber;
            Context->Line = LineNumber;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    } else {
        d = ERROR_LINE_NOT_FOUND;
    }

    SetLastError(d);
    return(d == NO_ERROR);
}


BOOL
SetupFindNextLine(
    IN  PINFCONTEXT ContextIn,
    OUT PINFCONTEXT ContextOut
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    return(SetupFindNextMatchLine(ContextIn,NULL,ContextOut));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupFindNextMatchLineA(
    IN  PINFCONTEXT ContextIn,
    IN  PCSTR       Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )
{
    PWSTR key;
    BOOL b;
    DWORD d;

    if(!Key) {
        key = NULL;
        d = NO_ERROR;
    } else {
        d = pSetupCaptureAndConvertAnsiArg(Key,&key);
    }

    if (d == NO_ERROR) {


        b = SetupFindNextMatchLineW(ContextIn,key,ContextOut);
        d = GetLastError();

        if (key) {
            MyFree(key);
        }

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupFindNextMatchLineW(
    IN  PINFCONTEXT ContextIn,
    IN  PCWSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )
{
    UNREFERENCED_PARAMETER(ContextIn);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(ContextOut);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupFindNextMatchLine(
    IN  PINFCONTEXT ContextIn,
    IN  PCTSTR      Key,        OPTIONAL
    OUT PINFCONTEXT ContextOut
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    UINT LineNumber;
    UINT SectionNumber;
    PINF_LINE Line;
    PINF_SECTION Section;
    PCTSTR SectionName;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)ContextIn->Inf)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // ContextIn is a bad pointer
        //
        d = ERROR_INVALID_PARAMETER;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    //
    // Fetch values from context
    //
    try {
        CurInf = ContextIn->CurrentInf;
        SectionNumber = ContextIn->Section;
        Section = &CurInf->SectionBlock[SectionNumber];
        SectionName = pStringTableStringFromId(CurInf->StringTable, Section->SectionName);
        MYASSERT(SectionName);

        //
        // Either want next line, or to start searching for key on next line
        //
        LineNumber = ContextIn->Line+1;

        do {
            if(Section) {
                if(InfLocateLine(CurInf, Section, Key, &LineNumber, &Line)) {
                    break;
                }
            }
            if(CurInf = CurInf->Next) {
                Section = InfLocateSection(CurInf, SectionName, &SectionNumber);
                LineNumber = 0;
            }
        } while(CurInf);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)ContextIn->Inf);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }


    if(CurInf) {
        //
        // Then we found the next line.
        //
        try {
            ContextOut->Inf = ContextIn->Inf;
            ContextOut->CurrentInf = CurInf;
            ContextOut->Section = SectionNumber;
            ContextOut->Line = LineNumber;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    } else {
        d = ERROR_LINE_NOT_FOUND;
    }

    SetLastError(d);
    return(d == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetLineByIndexA(
    IN  HINF        InfHandle,
    IN  PCSTR       Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )
{
    PCWSTR section;
    DWORD d;
    BOOL b;

    if((d = pSetupCaptureAndConvertAnsiArg(Section,&section)) == NO_ERROR) {

        b = SetupGetLineByIndexW(InfHandle,section,Index,Context);
        d = GetLastError();

        MyFree(section);

    } else {
        b = FALSE;
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetLineByIndexW(
    IN  HINF        InfHandle,
    IN  PCWSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetLineByIndex(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN  DWORD       Index,
    OUT PINFCONTEXT Context
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    PINF_SECTION InfSection;
    PINF_LINE InfLine;
    UINT LineNumber, CurLineNumberUB;
    UINT SectionNumber;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            d =  ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_HANDLE;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    try {
        //
        // Traverse the list of loaded INFs.  For each INF that contains
        // the specified section, we check to see if the line number we're
        // looking for lies within its (adjusted) range of line numbers.
        //
        CurLineNumberUB = 0;
        for(CurInf = (PLOADED_INF)InfHandle; CurInf; CurInf = CurInf->Next) {
            //
            // Locate the section.
            //
            if(!(InfSection = InfLocateSection(CurInf, Section, &SectionNumber))) {
                continue;
            }

            //
            // See if the line number lies in this INF section's range.
            //
            MYASSERT(Index >= CurLineNumberUB);
            LineNumber = Index - CurLineNumberUB;
            if(InfLocateLine(CurInf, InfSection, NULL, &LineNumber, &InfLine)) {
                break;
            } else {
                //
                // Subtract the number of lines this INF contributes to the section's
                // total line count, and continue with the next one.
                //
                CurLineNumberUB += InfSection->LineCount;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)InfHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(FALSE);
    }

    if(CurInf) {
        //
        // Then we found the specified line.
        //
        try {
            Context->Inf = (PVOID)InfHandle;
            Context->CurrentInf = (PVOID)CurInf;
            Context->Section = SectionNumber;
            Context->Line = LineNumber;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    } else {
        d = ERROR_LINE_NOT_FOUND;
    }

    SetLastError(d);
    return(d == NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
LONG
SetupGetLineCountA(
    IN HINF  InfHandle,
    IN PCSTR Section
    )
{
    PCWSTR section;
    LONG l;
    DWORD d;

    if((d = pSetupCaptureAndConvertAnsiArg(Section,&section)) == NO_ERROR) {

        l = SetupGetLineCountW(InfHandle,section);
        d = GetLastError();

        MyFree(section);

    } else {

        l = -1;
    }

    SetLastError(d);
    return(l);
}
#else
//
// Unicode stub
//
LONG
SetupGetLineCountW(
    IN HINF   InfHandle,
    IN PCWSTR Section
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(-1);
}
#endif

LONG
SetupGetLineCount(
    IN HINF   InfHandle,
    IN PCTSTR Section
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PLOADED_INF CurInf;
    PINF_SECTION InfSection;
    LONG LineCount;
    DWORD d;

    d = NO_ERROR;
    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            d = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_HANDLE;
    }
    if(d != NO_ERROR) {
        SetLastError(d);
        return(-1);
    }

    try {
        //
        // Traverse the linked list of loaded INFs, and sum up the section line
        // counts for each INF containing the specified section.
        //
        LineCount = -1;
        for(CurInf = (PLOADED_INF)InfHandle; CurInf; CurInf = CurInf->Next) {
            if(InfSection = InfLocateSection(CurInf, Section, NULL)) {
                if(LineCount == -1) {
                    LineCount = InfSection->LineCount;
                } else {
                    LineCount += InfSection->LineCount;
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    UnlockInf((PLOADED_INF)InfHandle);

    if(d != NO_ERROR) {
        SetLastError(d);
        return(-1);
    }

    if(LineCount == -1) {
        SetLastError(ERROR_SECTION_NOT_FOUND);
    } else {
        SetLastError(NO_ERROR);
    }

    return LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infload.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    infload.c

Abstract:

    Routines to load and parse INF files, and manipulate data in them.

Author:

    Ted Miller (tedm) 13-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntverp.h>

//
// Values used when initializing and growing the section, line, and value blocks.
//
#define INITIAL_SECTION_BLOCK_SIZE  50
#define INITIAL_LINE_BLOCK_SIZE     350
#define INITIAL_VALUE_BLOCK_SIZE    1000

#define SECTION_BLOCK_GROWTH    10
#define LINE_BLOCK_GROWTH       100
#define VALUE_BLOCK_GROWTH      500

//
// Define unresolved substitution values for return by ParseValueString and
// ProcessForSubstitutions
//
#define UNRESOLVED_SUBST_NONE                  (0)
#define UNRESOLVED_SUBST_USER_DIRID            (1)
#define UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID (2)


//
// Macros used to quadword-align PNF blocks.
//
#define PNF_ALIGNMENT      ((DWORD)8)
#define PNF_ALIGN_MASK     (~(DWORD)(PNF_ALIGNMENT - 1))

#define PNF_ALIGN_BLOCK(x) ((x & PNF_ALIGN_MASK) + ((x & ~PNF_ALIGN_MASK) ? PNF_ALIGNMENT : 0))

//
// Structure containing parameters relating to a [strings] section of an INF
// file (used during parsing).
//
typedef struct _STRINGSEC_PARAMS {
    PCTSTR Start;
    PCTSTR End;
    UINT   StartLineNumber;
    UINT   EndLineNumber;
} STRINGSEC_PARAMS, *PSTRINGSEC_PARAMS;


//
// Parse context, used by inf load/parse routines to pass
// state around.
//
typedef struct _PARSE_CONTEXT {

    //
    // Pointer to the end of the buffer.
    //
    PCTSTR BufferEnd;

    //
    // Current line number in the file
    //
    UINT CurrentLineNumber;

    //
    // section, line, and value block buffer sizes and current locations.
    //
    UINT LineBlockUseCount;
    UINT ValueBlockUseCount;
    UINT SectionBlockSize;
    UINT LineBlockSize;
    UINT ValueBlockSize;

    //
    // Value indicating whether we are within a section.
    // We always within a section unless the first non-comment line
    // of the inf is not section line, and that is an error case.
    //
    BOOL GotOneSection;

    //
    // Pointer to the actual inf descriptor
    //
    PLOADED_INF Inf;

    //
    // The following field is used solely for the purposes of calling
    // ProcessForSubstitutions() after an INF has already been loaded.  This is
    // necessary when applying user-defined or volatile system DIRIDs to
    // unresolved string substitutions.  If this flag is TRUE, then the
    // aforementioned routine will call pSetupVolatileDirIdToPath for %<x>%
    // substrings, instead of its normal (i.e., load-time) processing.
    //
    BOOL DoVolatileDirIds;

    //
    // Specifies the directory where this INF is located (if it's an OEM location).
    //
    PCTSTR InfSourcePath;   // may be NULL.

    //
    // Specifies the drive/directory where the OsLoader is located.
    //
    PCTSTR OsLoaderPath;

    //
    // Buffer used during parsing.
    //
    TCHAR TemporaryString[MAX_INF_STRING_LENGTH+1];

} PARSE_CONTEXT, *PPARSE_CONTEXT;

//
// Declare global string variables used throughout the inf loaders.
//
// These strings are defined in infstr.h:
//
CONST TCHAR pszSignature[]          = INFSTR_KEY_SIGNATURE,
            pszVersion[]            = INFSTR_SECT_VERSION,
            pszClass[]              = INFSTR_KEY_HARDWARE_CLASS,
            pszClassGuid[]          = INFSTR_KEY_HARDWARE_CLASSGUID,
            pszProvider[]           = INFSTR_KEY_PROVIDER,
            pszStrings[]            = SZ_KEY_STRINGS,
            pszLayoutFile[]         = SZ_KEY_LAYOUT_FILE,
            pszManufacturer[]       = INFSTR_SECT_MFG,
            pszControlFlags[]       = INFSTR_CONTROLFLAGS_SECTION,
            pszReboot[]             = INFSTR_REBOOT,
            pszRestart[]            = INFSTR_RESTART,
            pszClassInstall32[]     = INFSTR_SECT_CLASS_INSTALL_32,
            pszAddInterface[]       = SZ_KEY_ADDINTERFACE,
            pszInterfaceInstall32[] = INFSTR_SECT_INTERFACE_INSTALL_32,
            pszAddService[]         = SZ_KEY_ADDSERVICE,
            pszDelService[]         = SZ_KEY_DELSERVICE,
            pszCatalogFile[]        = INFSTR_KEY_CATALOGFILE;


//
// Other misc. global strings:
//
// Be sure to keep these strings in sync with the strings used
// in inf.h to compute the array size.  This is done so that
// we can determine string length by doing a sizeof() instead
// of having to do lstrlen().
//
CONST TCHAR pszDrvDescFormat[]                  = DISTR_INF_DRVDESCFMT,
            pszHwSectionFormat[]                = DISTR_INF_HWSECTIONFMT,
            pszChicagoSig[]                     = DISTR_INF_CHICAGOSIG,
            pszWindowsNTSig[]                   = DISTR_INF_WINNTSIG,
            pszWindows95Sig[]                   = DISTR_INF_WIN95SIG,
            pszWinSuffix[]                      = DISTR_INF_WIN_SUFFIX,
            pszNtSuffix[]                       = DISTR_INF_NT_SUFFIX,
            pszNtAlphaSuffix[]                  = DISTR_INF_NTALPHA_SUFFIX,
            pszNtX86Suffix[]                    = DISTR_INF_NTX86_SUFFIX,
            pszNtIA64Suffix[]                   = DISTR_INF_NTIA64_SUFFIX,
            pszNtAXP64Suffix[]                  = DISTR_INF_NTAXP64_SUFFIX,
            pszNtAMD64Suffix[]                  = DISTR_INF_NTAMD64_SUFFIX,
            pszPnfSuffix[]                      = DISTR_INF_PNF_SUFFIX,
            pszInfSuffix[]                      = DISTR_INF_INF_SUFFIX,
            pszCatSuffix[]                      = DISTR_INF_CAT_SUFFIX,
            pszServicesSectionSuffix[]          = DISTR_INF_SERVICES_SUFFIX,
            pszInterfacesSectionSuffix[]        = DISTR_INF_INTERFACES_SUFFIX,
            pszCoInstallersSectionSuffix[]      = DISTR_INF_COINSTALLERS_SUFFIX,
            pszLogConfigOverrideSectionSuffix[] = DISTR_INF_LOGCONFIGOVERRIDE_SUFFIX,
            pszAlphaSrcDiskSuffix[]             = DISTR_INF_SRCDISK_SUFFIX_ALPHA,
            pszX86SrcDiskSuffix[]               = DISTR_INF_SRCDISK_SUFFIX_X86,
            pszIa64SrcDiskSuffix[]              = DISTR_INF_SRCDISK_SUFFIX_IA64,
            pszAxp64SrcDiskSuffix[]             = DISTR_INF_SRCDISK_SUFFIX_AXP64,
            pszAmd64SrcDiskSuffix[]             = DISTR_INF_SRCDISK_SUFFIX_AMD64;


DWORD
CreateInfVersionNode(
    IN PLOADED_INF Inf,
    IN PCTSTR      Filename,
    IN PFILETIME   LastWriteTime
    );

BOOL
LoadPrecompiledInf(
    IN  PCTSTR       Filename,
    IN  PFILETIME    LastWriteTime,
    IN  PCTSTR       OsLoaderPath,                    OPTIONAL
    IN  DWORD        LanguageId,
    IN  DWORD        Flags,
    IN  PSETUP_LOG_CONTEXT LogContext,                OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT PTSTR       *InfSourcePathToMigrate,          OPTIONAL
    OUT PDWORD       InfSourcePathToMigrateMediaType, OPTIONAL
    OUT PTSTR       *InfOriginalNameToMigrate         OPTIONAL
    );

DWORD
SavePnf(
    IN PCTSTR      Filename,
    IN PLOADED_INF Inf
    );

PLOADED_INF
DuplicateLoadedInfDescriptor(
    IN PLOADED_INF Inf
    );

BOOL
AddUnresolvedSubstToList(
    IN PLOADED_INF Inf,
    IN UINT        ValueOffset,
    IN BOOL        CaseSensitive
    );

BOOL
AlignForNextBlock(
    IN HANDLE hFile,
    IN DWORD  ByteCount
    );


BOOL
IsWhitespace(
    IN PCTSTR pc
    )

/*++

Routine Description:

    Determine whether a character is whitespace. Whitespace refers to the ctype
    definition.

Arguments:

    pc - points to character to be examined.

Return Value:

    TRUE if the character is whitespace. FALSE if not.

    Note that the nul chracter is not whitespace.

--*/

{
    WORD Type;

    return(GetStringTypeEx(LOCALE_SYSTEM_DEFAULT,CT_CTYPE1,pc,1,&Type) && (Type & C1_SPACE));
}


VOID
SkipWhitespace(
    IN OUT PCTSTR *Location,
    IN     PCTSTR  BufferEnd
    )

/*++

Routine Description:

    Skip whitespace characters in the input stream. For the purposes of this
    routine, newline characters are NOT considered whitespace.

    Note that the end-of-stream marker ('\0') IS considered whitespace.

Arguments:

    Location - on input, supplies the current location in the input stream.
        On output, receives the location in the input stream of the first
        non-whitespace character. Note that this may be equal to BufferEnd,
        if no whitespace was found, in which case the pointer may be
        invalid.

    BufferEnd - specifies the address of the end of the buffer (i.e., the
        memory address immediately following the buffer's memory range).

Return Value:

    None.

--*/

{
    while((*Location < BufferEnd) &&
          (**Location != TEXT('\n')) &&
          (!(**Location) || IsWhitespace(*Location))) {

        (*Location)++;
    }
}


VOID
SkipLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location
    )

/*++

Routine Description:

    Skip all remaining characters in the current line, and positions the
    input pointer to the first character on the next line.

    No whitespace is skipped automatically -- the input pointer may
    very well point to whitespace or the end-of-stream marker on exit.

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        On output, receives the location in the input stream of the first
        character on the next line.

Return Value:

    None.

--*/

{
    PCTSTR BufferEnd = Context->BufferEnd;

    while((*Location < BufferEnd) && (**Location != TEXT('\n'))) {
        (*Location)++;
    }

    //
    // *Location points at either the newline or end-of-buffer.
    // Skip the newline if necessary.
    //
    if(*Location < BufferEnd) {
        Context->CurrentLineNumber++;
        (*Location)++;
    }
}


BOOL
MergeDuplicateSection(
    IN PPARSE_CONTEXT Context
    )
{
    PLOADED_INF Inf;
    PINF_SECTION NewestSection;
    PINF_SECTION Section;
    UINT Size;
    UINT MoveSize;
    PVOID TempBuffer;

    Inf = Context->Inf;

    //
    // Nothing to merge if only one section
    //
    if(Inf->SectionCount < 2) {
        return(TRUE);
    }

    NewestSection = Inf->SectionBlock + Inf->SectionCount - 1;

    //
    // See whether the final section duplicates any existing sections.
    //
    for(Section=Inf->SectionBlock; Section<NewestSection; Section++) {
        if(Section->SectionName == NewestSection->SectionName) {
            break;
        }
    }

    if(Section == NewestSection) {
        //
        // No duplication; return success
        //
        return(TRUE);
    }

    //
    // Got a duplicate.
    //

    //
    // We need to move the new section's lines (at the end of the line block)
    // to be just after the existing section's lines.
    //
    // First, we'll save off the new section's lines in a temporary buffer.
    //
    Size = NewestSection->LineCount * sizeof(INF_LINE);
    TempBuffer = MyMalloc(Size);
    if(!TempBuffer) {
        return(FALSE);
    }
    CopyMemory(TempBuffer,&Inf->LineBlock[NewestSection->Lines],Size);

    //
    // Next, we'll move up the affected existing lines, to make room for
    // the section's new lines
    //
    MoveSize = Context->LineBlockUseCount - (Section->Lines + Section->LineCount);
    MoveSize *= sizeof(INF_LINE);
    MoveSize -= Size;

    MoveMemory(
        &Inf->LineBlock[Section->Lines + Section->LineCount + NewestSection->LineCount],
        &Inf->LineBlock[Section->Lines + Section->LineCount],
        MoveSize
        );

    //
    // Now put the new lines in the hole we just opened up
    //
    CopyMemory(
        &Inf->LineBlock[Section->Lines + Section->LineCount],
        TempBuffer,
        Size
        );

    MyFree(TempBuffer);

    //
    // Adjust the existing section's limits to account for the new lines.
    //
    Section->LineCount += NewestSection->LineCount;

    //
    // Adjust all subsequent sections' starting line value
    //
    for(Section=Section+1; Section<NewestSection; Section++) {
        Section->Lines += NewestSection->LineCount;
    }

    //
    // Remove the newest section.
    //
    Inf->SectionCount--;

    return(TRUE);
}


PTCHAR
LocateStringSubstitute(
    IN  PPARSE_CONTEXT Context,
    IN  PTSTR          String
    )
/*++

Routine Description:

    This routine attempts to find a string substitution in an INF's
    [strings] section for the specified key.

    THIS ROUTINE OPERATES UNDER THE ASSUMPTION THAT IT IS ONLY INVOKED FROM
    WITHIN LOADINF.  IT DOESN'T HANDLE MULTIPLE INFS, NOR DOES IT DO ANY
    INF LOCKING.

Arguments:

    Context - current INF parse context

    String - string to be substituted

Return Value:

    If substitution is a success, the function returns a pointer to the string,
    either in the string table or in the workspace.  If failure, NULL is returned.

--*/
{
    UINT Zero = 0;
    PINF_LINE Line;

    MYASSERT(Context->Inf->SectionCount > 1);
    MYASSERT(Context->Inf->HasStrings);

    //
    // The strings section is always first to be parsed.
    // (See PreprocessInf()).
    //
    // Look for a line in [strings] with key of String.
    //
    if(InfLocateLine(Context->Inf,
                     Context->Inf->SectionBlock,
                     String,
                     &Zero,
                     &Line)) {
        //
        // Get and return value #1.
        //
        return(InfGetField(Context->Inf,Line,1,NULL));
    }

    //
    // No valid substitution exists.
    //
    return NULL;
}


VOID
ProcessForSubstitutions(
    IN OUT PPARSE_CONTEXT Context,
    IN     PCTSTR         String,
    OUT    PDWORD         UnresolvedSubst
    )
{
    PCTSTR In, q;
    PTCHAR Out, p;
    TCHAR Str[MAX_STRING_LENGTH];
    ULONG Len, i;
    PTCHAR End;
    TCHAR DirId[MAX_PATH];
    BOOL HasStrings = Context->Inf->HasStrings;
    UINT DirIdUsed;
    BOOL HasVolatileSysDirId;

    In = String;
    Out = Context->TemporaryString;
    End = Out + SIZECHARS(Context->TemporaryString);

    *UnresolvedSubst = UNRESOLVED_SUBST_NONE;

    while(*In) {

        if(*In == TEXT('%')) {
            //
            // Double % in input ==> single % in output
            //
            if(*(++In) == TEXT('%')) {
                if(Out < End) {
                    *Out++ = TEXT('%');
                }
                In++;
            } else {
                //
                // Look for terminating %.
                //
                if(p = _tcschr(In,TEXT('%'))) {

                    HasVolatileSysDirId = FALSE;

                    //
                    // Get value to substitute. If we can't find the value,
                    // put the whole string like %abc% in there.
                    //
                    Len = (ULONG)(p - In);
                    if(Len > CSTRLEN(Str)) {
                        //
                        // We can't handle substitutions for tokens this long.
                        // We'll just bail in this case, and copy over the token as-is.
                        //
                        q = NULL;
                    } else {
                        lstrcpyn(Str,In,Len+1);
                        if(Context->DoVolatileDirIds) {
                            if(q = pSetupVolatileDirIdToPath(Str, 0, NULL, Context->Inf)) {

                                lstrcpyn(DirId, q, SIZECHARS(DirId));
                                MyFree(q);
                                q = DirId;

                                //
                                // If the next character following this string substitution
                                // is a backslash, then we need to make sure that the path we
                                // just retrieved doesn't have a backslash (i.e., we want to
                                // make sure we have a well-formed path).
                                //
                                if(*(p + 1) == TEXT('\\')) {
                                    i = lstrlen(DirId);
                                    if(i > 0 && (*CharPrev(DirId,DirId+i) == TEXT('\\'))) {
                                        DirId[i-1] = TEXT('\0');
                                    }
                                }
                            }
                        } else {
                            if(HasStrings) {
                                q = LocateStringSubstitute(Context, Str);
                            } else {
                                q = NULL;
                            }
                            if(!q) {
                                //
                                // Maybe we have a standard DIRID here...
                                //
                                if(q = pSetupDirectoryIdToPathEx(Str,
                                                                 &DirIdUsed,
                                                                 NULL,
                                                                 Context->InfSourcePath,
                                                                 &(Context->OsLoaderPath),
                                                                 &HasVolatileSysDirId)) {

                                    lstrcpyn(DirId, q, SIZECHARS(DirId));
                                    MyFree(q);
                                    q = DirId;

                                    //
                                    // If the next character following this string substitution
                                    // is a backslash, then we need to make sure that the path we
                                    // just retrieved doesn't have a backslash (i.e., we want to
                                    // make sure we have a well-formed path).
                                    //
                                    if(*(p + 1) == TEXT('\\')) {
                                        i = lstrlen(DirId);
                                        if(i > 0 && (*CharPrev(DirId,DirId+i) == TEXT('\\'))) {
                                            DirId[i-1] = TEXT('\0');
                                        }
                                    }

                                    if((DirIdUsed == DIRID_BOOT) || (DirIdUsed == DIRID_LOADER)) {
                                        //
                                        // Then this INF contains string substititutions that
                                        // reference system partition DIRIDs.  Store the OsLoaderPath
                                        // contained in the parse context structure in the INF itself.
                                        //
                                        Context->Inf->OsLoaderPath = Context->OsLoaderPath;
                                    }
                                }
                            }
                        }
                    }
                    if(q) {
                        Len = lstrlen(q);
                        for(i=0; i<Len; i++) {
                            if(Out < End) {
                                *Out++ = q[i];
                            }
                        }
                        In = p+1;
                    } else {
                        //
                        // Len is the length of the internal part (the abc in %abc%).
                        //
                        if(Out < End) {
                            *Out++ = TEXT('%');
                        }
                        for(i=0; i<=Len; i++, In++) {
                            if(Out < End) {
                                *Out++ = *In;
                            }
                        }

                        //
                        // When we encounter a substitution for which there is
                        // no corresponding string, we set the UnresolvedSubst
                        // output parameter so that the caller knows to track
                        // this value for later resolution (e.g., for volatile
                        // and user-defined DIRIDs).
                        //
                        // (NOTE: Don't set this if we bailed because the token
                        // was too long!)
                        //
                        if(Len <= CSTRLEN(Str)) {

                            *UnresolvedSubst = HasVolatileSysDirId
                                             ? UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID
                                             : UNRESOLVED_SUBST_USER_DIRID;
                        }
                    }

                } else {
                    //
                    // No terminating %. So we have something like %abc.
                    // Want to put %abc in the output. Put the % in here
                    // manually and then just let subsequent passes
                    // through the loop copy the rest of the chars.
                    //
                    if(Out < End) {
                        *Out++ = TEXT('%');
                    }
                }
            }
        } else {
            //
            // Plain char.
            //
            if(Out < End) {
                *Out++ = *In;
            }
            In++;
        }
    }

    *Out = 0;
}


VOID
ParseValueString(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location,
    IN     BOOL            ForKey,
    OUT    PDWORD          UnresolvedSubst
    )

/*++

Routine Description:

    Extract a string starting at the current location in the input stream.
    The string starts at the current location, and is terminated by
    comma, newline, comment, or end-of-buffer. If the string is potentially
    a line key, it may also terminate with an =.

    The string may also be continued across multiple lines by using a
    continuation character "\".  The pieces are appended together to form
    a single string that is returned to the caller.  E.g.,

    "this is a "\
    "string used to" \
    " test line continuation"

    becomes:

    "this is a string used to test line continuation"

Arguments:

    Context - supplies parse context.

    Location - on input, supplies a pointer to the current location in the
        input stream. On outut, recevies a pointer to the location in the
        input stream of the character that terminated the string (may be
        a pointer to the end of the buffer, in which case the pointer must
        not be dereferenced!)

    ForKey - indicates whether = is a valid string terminator. If this value
        is FALSE, = is just another character with no special semantics.

    UnresolvedSubst - receives a value indicating whether or not this value
        contained any unresolved string substitutions (and as such, should be
        tracked for user-defined DIRID replacement, etc.).  May be one of the
        following 3 values:

            UNRESOLVED_SUBST_NONE                  (0)
            UNRESOLVED_SUBST_USER_DIRID            (1)
            UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID (2)

Return Value:

    None.

--*/

{
    DWORD Count;
    PTCHAR Out;
    BOOL InQuotes;
    BOOL Done;
    PCTSTR location = *Location;
    PCTSTR BufferEnd = Context->BufferEnd;
    TCHAR TempString[MAX_STRING_LENGTH+1];
    PTSTR LastBackslashChar, LastNonWhitespaceChar;

    //
    // Prepare to get the string
    //
    Count = 0;
    Out = TempString;
    Done = FALSE;
    InQuotes = FALSE;
    LastBackslashChar = NULL;
    //
    // Set the last non-whitespace pointer to be the character immediately preceding
    // the output buffer.  We always reference the value of this pointer + 1, so there's
    // no danger of a bad memory reference.
    //
    LastNonWhitespaceChar = Out - 1;

    //
    // The first string can terminate with an =
    // as well as the usual comma, newline, comment, or end-of-input.
    //
    while(!Done && (location < BufferEnd)) {

        switch(*location) {

        case TEXT('\r'):
            //
            // Ignore these.
            //
            location++;
            break;

        case TEXT('\\'):
            //
            // If we're not inside quotes, this could be a continuation character.
            //
            if(!InQuotes) {
                LastBackslashChar = Out;
            }

            //
            // We always store this character, we just may have to remove it later if
            // it turns out to be the continuation character.
            //
            goto store;

        case TEXT('\"'):

            location++;

            if(InQuotes) {

                if((location < BufferEnd) && *location == TEXT('\"')) {
                    goto store;
                } else {
                    InQuotes = FALSE;
                }
            } else {
                InQuotes = TRUE;
            }
            break;

        case TEXT(','):

            if(InQuotes) {
                goto store;
            } else {
                Done = TRUE;
                break;
            }

        case TEXT(';'):

            if(InQuotes) {
                goto store;
            }
            //
            // This character terminates the value, so let fall through to processing
            // of end-of-line.  (We treat ';' and '\n' differently than ',' because the
            // former chars can possibly require a line continuation.)
            //

        case TEXT('\n'):
            //
            // OK, we've hit the end of the data on the line.  If we found a backslash
            // character, and its value is greater than that of the last non-whitespace
            // character we encountered, then that means that we need to continue this
            // value on the next line.
            //
            if(LastBackslashChar && (LastBackslashChar > LastNonWhitespaceChar)) {
                //
                // Trim any trailing whitespace from our current string (this includes
                // getting rid of the backslash character itself).
                //
                Out = LastNonWhitespaceChar + 1;

                //
                // Skip to the beginning of the next line.
                //
                SkipLine(Context, &location);

                //
                // Skip any preceding whitespace on this new line.
                //
                SkipWhitespace(&location, BufferEnd);

                //
                // Clear the last-backslash pointer--we're on a new line now.
                //
                LastBackslashChar = NULL;

                break;
            }

            Done = TRUE;
            break;

        case TEXT('='):

            if(InQuotes) {
                goto store;
            }

            if(ForKey) {
                //
                // We've got a key.
                //
                Done = TRUE;
                break;
            }

            //
            // Else just fall through for default handling.
            //

        default:
        store:

            //
            // Strings longer then the maximum length are silently truncated.
            // NULL characters are converted to spaces.
            //
            if(Count < CSTRLEN(TempString)) {
                *Out = *location ? *location : TEXT(' ');

                if(InQuotes || ((*Out != TEXT('\\')) && !IsWhitespace(Out))) {
                    //
                    // Update our pointer that keeps track of the last non-whitespace
                    // character we've encountered.
                    //
                    LastNonWhitespaceChar = Out;
                }

                Out++;
                Count++;
            }
            location++;
            break;
        }
    }

    //
    // Terminate the string in the buffer after the last non-whitespace character encountered.
    //
    *(LastNonWhitespaceChar + 1) = TEXT('\0');

    //
    // Store the new current buffer location in the caller's variable.
    //
    *Location = location;

    //
    // Substitute localized strings from the strings section.
    // The strings section (if it exists) is always first
    // (see PreprocessInf()).
    //
    // (tedm) Ignore whether or not the value was in quotes.
    // Win95 infs do stuff like "%Description%\foo" and expect the
    // substitution to work.
    //
    // (lonnym) We have to do this regardless of whether the INF has
    // a [strings] section, since this routine tells us whether we have
    // unresolved substitutions (e.g., for later replacement by user-defined
    // DIRIDs).
    //
    if((Context->Inf->SectionCount > 1) || !(Context->Inf->HasStrings)) {
        ProcessForSubstitutions(Context, TempString, UnresolvedSubst);
    } else {
        //
        // Don't process values in the [strings] section for substitution!
        //
        lstrcpy(Context->TemporaryString, TempString);
        *UnresolvedSubst = UNRESOLVED_SUBST_NONE;
    }
}


DWORD
ParseValuesLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location
    )

/*++

Routine Description:

    Parse a line of input that is not a section name and not a line
    with only a comment on it.

    Such lines are in the format

    [<key> = ] <value>,<value>,<value>,...

    The key is optional. Unquoted whitespace between non-whitespace characters
    within a value is significant and considered part of the value.

    Thus

        a,  b cd  ef ,ghi

    is the 3 values "a" "b cd  ef" and "ghi"

    Unquoted commas separate values. Two double quotes in a row within a quoted
    string result in a single double quote character in the resulting string.

    A logical line may be extended across several physical lines by use of the line
    continuation character "\".  E.g.,

        a = b, c, \
        d, e

        becomes "a = b, c, d, e"

    If it is desired to have a string that ends with a backslash at the end of a line,
    the string must be enclosed in quotes. E.g.,

        a = "C:\"

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        This must point to the left bracket.
        On output, receives the location in the input stream of the first
        character on the next line. This may be the end of input marker.

Return Value:

    Result indicating outcome.

--*/

{
    BOOL HaveKey = FALSE, RepeatSingleVal = FALSE;
    BOOL Done;
    DWORD Size;
    PVOID p;
    LONG StringId;
    PCTSTR BufferEnd = Context->BufferEnd;
    PWORD pValueCount;
    DWORD UnresolvedSubst;
    BOOL CaseSensitive;

    //
    // Parse out the first string.
    // The first string can terminate with an = or whitespace
    // as well as the usual comma, newline, comment, or end-of-buffer
    // (or line continuation character "\").
    //
    ParseValueString(Context, Location, TRUE, &UnresolvedSubst);

    //
    // If it terminated with an = then it's a key.
    //
    if(*Location < BufferEnd) {
        HaveKey = (**Location == TEXT('='));
    }

    //
    // Set up the current line
    //
    MYASSERT(Context->Inf->SectionCount);
    Context->Inf->SectionBlock[Context->Inf->SectionCount-1].LineCount++;

    if(Context->LineBlockUseCount == Context->LineBlockSize) {

        Size = (Context->LineBlockSize + LINE_BLOCK_GROWTH) * sizeof(INF_LINE);

        p = MyRealloc(Context->Inf->LineBlock,Size);
        if(p) {
            Context->Inf->LineBlock = p;
            Context->LineBlockSize += LINE_BLOCK_GROWTH;
        } else {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    Context->Inf->LineBlock[Context->LineBlockUseCount].Values = Context->ValueBlockUseCount;
    *(pValueCount = &(Context->Inf->LineBlock[Context->LineBlockUseCount].ValueCount)) = 0;
    Context->Inf->LineBlock[Context->LineBlockUseCount].Flags = HaveKey
                                                                ? (INF_LINE_HASKEY | INF_LINE_SEARCHABLE)
                                                                : 0;

    for(Done=FALSE; !Done; ) {
        //
        // Save away the value in the value block. If it's a key, then
        // store it twice--once case-insensitively for lookup, and a second
        // time case-sensitively for display.  Store everything else
        // case-sensitively.
        //
        // We also want to treat a single value with no key as if it were a key (i.e., store
        // it twice).  This is for Win95 compatibility.
        //
        do {

            do {
                //
                // To keep from having to allocate a buffer for the case-insensitive key addition (which
                // must be value 0), we do the case-sensitive addition first, then insert the case-
                // insensitive version in front of it on the second pass of this inner loop.
                //
                CaseSensitive = ((*pValueCount != 1) || !HaveKey);
                StringId = pStringTableAddString(Context->Inf->StringTable,
                                                 Context->TemporaryString,
                                                 STRTAB_BUFFER_WRITEABLE | (CaseSensitive ? STRTAB_CASE_SENSITIVE
                                                                                          : STRTAB_CASE_INSENSITIVE),
                                                 NULL,0
                                                );

                if(StringId == -1) {
                    return(ERROR_NOT_ENOUGH_MEMORY);
                }

                if(Context->ValueBlockUseCount == Context->ValueBlockSize) {

                    Size = (Context->ValueBlockSize + VALUE_BLOCK_GROWTH) * sizeof(LONG);

                    p = MyRealloc(Context->Inf->ValueBlock,Size);
                    if(p) {
                        Context->Inf->ValueBlock = p;
                        Context->ValueBlockSize += VALUE_BLOCK_GROWTH;
                    } else {
                        return(ERROR_NOT_ENOUGH_MEMORY);
                    }
                }

                if((*pValueCount == 1) && HaveKey) {
                    //
                    // Shift over the case-sensitive version, and insert the case-insensitive one.
                    //
                    Context->Inf->ValueBlock[Context->ValueBlockUseCount] =
                        Context->Inf->ValueBlock[Context->ValueBlockUseCount - 1];

                    Context->Inf->ValueBlock[Context->ValueBlockUseCount - 1] = StringId;

                    if(UnresolvedSubst) {

                        if(!AddUnresolvedSubstToList(Context->Inf,
                                                     Context->ValueBlockUseCount - 1,
                                                     CaseSensitive)) {

                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if(UnresolvedSubst == UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID) {
                            Context->Inf->Flags |= LIF_HAS_VOLATILE_DIRIDS;
                        }
                    }

                    //
                    // Reset the 'RepeatSingleVal' flag, in case we were faking the key behavior.
                    //
                    RepeatSingleVal = FALSE;

                } else {
                    Context->Inf->ValueBlock[Context->ValueBlockUseCount] = StringId;

                    if(UnresolvedSubst) {

                        if(!AddUnresolvedSubstToList(Context->Inf,
                                                     Context->ValueBlockUseCount,
                                                     CaseSensitive)) {

                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        if(UnresolvedSubst == UNRESOLVED_SUBST_SYSTEM_VOLATILE_DIRID) {
                            Context->Inf->Flags |= LIF_HAS_VOLATILE_DIRIDS;
                        }
                    }
                }

                Context->ValueBlockUseCount++;
                (*pValueCount)++;

            } while(HaveKey && (*pValueCount < 2));

            //
            // Check to see if this was the last value on the line.
            //
            if((*Location == BufferEnd) ||
               (**Location == TEXT('\n')) ||
               (**Location == TEXT(';'))) {

                Done = TRUE;
                //
                // If this was the _only_ value on the line (i.e., no key), then treat this value
                // as a key, and add it in again, case-insensitively.
                //
                if(*pValueCount == 1) {

                    MYASSERT(!HaveKey);

                    HaveKey = TRUE;
                    Context->Inf->LineBlock[Context->LineBlockUseCount].Flags = INF_LINE_SEARCHABLE;
                    RepeatSingleVal = TRUE;
                }
            }

        } while (RepeatSingleVal);

        if(!Done) {
            //
            // Skip terminator and whitespace.
            //
            (*Location)++;
            SkipWhitespace(Location, BufferEnd);

            //
            // Get the next string.
            //
            ParseValueString(Context, Location, FALSE, &UnresolvedSubst);
        }
    }

    Context->LineBlockUseCount++;

    //
    // Skip to next line
    //
    SkipLine(Context,Location);

    return(NO_ERROR);
}


DWORD
ParseSectionLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location
    )

/*++

Routine Description:

    Parse a line of input that is known to be a section name line.
    Such lines are in the format

    '[' <arbitrary chars> ']'

    All charcters between the brackets are considered part of the section
    name, with no special casing of quotes, whitespace, etc. The remainder
    of the line is ignored.

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        This must point to the left bracket.
        On output, receives the location in the input stream of the first
        character on the next line. This may be the end of input marker.

Return Value:

    Result indicating outcome.

--*/

{
    DWORD Count;
    PTCHAR Out;
    BOOL Done;
    DWORD Result;
    PVOID p;
    DWORD Size;
    DWORD Index;
    LONG SectionNameId;
    PCTSTR BufferEnd = Context->BufferEnd;

    //
    // Skip the left bracket.
    //
    MYASSERT(**Location == TEXT('['));
    (*Location)++;

    //
    // Prepare for section name
    //
    Out = Context->TemporaryString;
    Count = 0;

    //
    // This is implemeted according to the win95 code in setup\setupx\inf2.c.
    // All characters between the 2 brackets are considered part of the
    // section name with no further processing (like for double quotes, etc).
    //
    // Win95 also seems to allow [] as a section name.
    //

    for(Done=FALSE,Result=NO_ERROR; !Done; (*Location)++) {

        if((*Location == BufferEnd) || (**Location == TEXT('\n'))) {
            //
            // Syntax error
            //
            Result = ERROR_BAD_SECTION_NAME_LINE;
            Done = TRUE;

        } else {

            switch(**Location) {

            case TEXT(']'):
                Done = TRUE;
                *Out = 0;
                break;

            default:
                if(Count < MAX_SECT_NAME_LEN) {
                    //
                    // Convert NULL characters to spaces.
                    //
                    *Out++ = **Location ? **Location : TEXT(' ');
                    Count++;
                } else {
                    Result = ERROR_SECTION_NAME_TOO_LONG;
                    Done = TRUE;
                }
                break;
            }
        }
    }

    Index = Context->Inf->SectionCount;

    if(Result == NO_ERROR) {

        //
        // Ignore the rest of the line
        //
        SkipLine(Context,Location);

        //
        // See if we have enough room in the section block
        // for this section. If not, grow the block.
        //
        if(Index == Context->SectionBlockSize) {

            //
            // Calculate the new section block size.
            //
            Size = (Index + SECTION_BLOCK_GROWTH) * sizeof(INF_SECTION);

            if(p = MyRealloc(Context->Inf->SectionBlock,Size)) {
                Context->SectionBlockSize += SECTION_BLOCK_GROWTH;
                Context->Inf->SectionBlock = p;
            } else {
                Result = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    if(Result == NO_ERROR) {

        Context->Inf->SectionBlock[Index].LineCount = 0;
        Context->Inf->SectionBlock[Index].Lines = Context->LineBlockUseCount;

        SectionNameId = pStringTableAddString(Context->Inf->StringTable,
                                              Context->TemporaryString,
                                              STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                              NULL,0
                                             );

        if(SectionNameId == -1) {
            Result = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            Context->Inf->SectionBlock[Index].SectionName = SectionNameId;
            Context->Inf->SectionCount++;
            Context->GotOneSection = TRUE;
        }
    }

    return(Result);
}


DWORD
ParseGenericLine(
    IN OUT PPARSE_CONTEXT  Context,
    IN OUT PCTSTR         *Location,
    OUT    PBOOL           Done
    )

/*++

Routine Description:

    Parse a single line of input. The line may be a comment line, a section name,
    or a values line.

    Handling is passed off to line-specific parsing routines depending on the
    line type.

Arguments:

    Context - supplies the parse context

    Location - on input, supplies the current location in the input stream.
        On output, receives the location in the input stream of the first
        character on the next line.

    Done - receives boolean value indicating whether we are done
        parsing the buffer. If this is TRUE on output the caller can stop
        calling this routine.

Return Value:

    Result indicating outcome.

--*/

{
    DWORD ParseResult;

    *Done = FALSE;

    //
    // Skip over leading whitespace on the line.
    //
    SkipWhitespace(Location, Context->BufferEnd);

    //
    // Further processing depends on the first important character on the line.
    //
    if(*Location == Context->BufferEnd) {
        //
        // End of input, empty line. Terminate current section.
        //
        *Done = TRUE;
        ParseResult = MergeDuplicateSection(Context) ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;

    } else {

        switch(**Location) {

        case TEXT('\n'):

            //
            // Empty line.
            //
            SkipLine(Context,Location);
            ParseResult = NO_ERROR;
            break;

        case TEXT('['):

            //
            // Potentially got a new section.
            // First terminate the current section.
            //
            if(MergeDuplicateSection(Context)) {
                ParseResult = ParseSectionLine(Context,Location);
            } else {
                ParseResult = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;

        case TEXT(';'):

            //
            // Comment line; ignore it.
            //
            SkipLine(Context,Location);
            ParseResult = NO_ERROR;
            break;

        default:

            //
            // Ordinary values line. Disallow unless we are within a section.
            //
            ParseResult = Context->GotOneSection
                        ? ParseValuesLine(Context,Location)
                        : ERROR_EXPECTED_SECTION_NAME;
            break;
        }
    }

    return(ParseResult);
}


PLOADED_INF
AllocateLoadedInfDescriptor(
    IN DWORD SectionBlockSize,
    IN DWORD LineBlockSize,
    IN DWORD ValueBlockSize,
    IN  PSETUP_LOG_CONTEXT LogContext OPTIONAL
    )
{
    PLOADED_INF p;

    if(p = MyTaggedMalloc(sizeof(LOADED_INF),MEMTAG_INF)) {

        ZeroMemory(p,sizeof(LOADED_INF));

        if(p->SectionBlock = MyMalloc(SectionBlockSize*sizeof(INF_SECTION))) {

            if(p->LineBlock = MyMalloc(LineBlockSize*sizeof(INF_LINE))) {

                if(p->ValueBlock = MyMalloc(ValueBlockSize*sizeof(LONG))) {

                    if(p->StringTable = pStringTableInitialize(0)) {
                        p->LogContext = NULL;
                        if(InheritLogContext(LogContext, &p->LogContext) == NO_ERROR) {
                            //
                            // success
                            //
                            if(InitializeSynchronizedAccess(&p->Lock)) {

                                p->Signature = LOADED_INF_SIG;
                                p->FileHandle = p->MappingHandle = INVALID_HANDLE_VALUE;
                                return(p);
                            }
                            DeleteLogContext(p->LogContext);
                        }
                        pStringTableDestroy(p->StringTable);
                    }
                    MyFree(p->ValueBlock);
                }
                MyFree(p->LineBlock);
            }
            MyFree(p->SectionBlock);
        }
        MyTaggedFree(p,MEMTAG_INF);
    }

    return(NULL);
}


PLOADED_INF
DuplicateLoadedInfDescriptor(
    IN PLOADED_INF Inf
    )
/*++

Routine Description:

    This routine duplicates an existing INF descriptor.  The duplicate returned
    is a totally independent copy, except that it has the lock handles (MYLOCK
    array) and Prev and Next pointers of the original.  This is useful for
    transferring a memory-mapped PNF into read-write memory if modification is
    required.

    THIS ROUTINE DOESN'T DO LOCKING OF ANY FORM ON THE INF--THE CALLER MUST
    HANDLE IT.

Arguments:

    Inf - supplies the address of the INF descriptor to be duplicated.  This
        pointer refers to a single LOADED_INF structure, so any additional INFs
        linked up via the 'Next' pointer are ignored.

Return Value:

    If successful, the return value is the address of the newly-created duplicate.
    If out-of-memory or inpage error, the return value is NULL.

--*/
{
    PLOADED_INF NewInf;
    BOOL Success;

    if(NewInf = MyTaggedMalloc(sizeof(LOADED_INF),MEMTAG_INF)) {
        CopyMemory(NewInf, Inf, sizeof(LOADED_INF));
        NewInf->Signature = 0;
        NewInf->SectionBlock = NULL;
        NewInf->LineBlock = NULL;
        NewInf->ValueBlock = NULL;
        NewInf->StringTable = NULL;
        NewInf->VersionBlock.DataBlock = NULL;
        NewInf->UserDirIdList.UserDirIds = NULL;
        NewInf->SubstValueList = NULL;
        NewInf->OsLoaderPath = NULL;
        NewInf->InfSourcePath = NULL;
        NewInf->OriginalInfName = NULL;
    } else {
        return NULL;
    }

    Success = FALSE;

    try {

        NewInf->SectionBlock = MyMalloc(Inf->SectionBlockSizeBytes);
        if(NewInf->SectionBlock) {

            CopyMemory(NewInf->SectionBlock, Inf->SectionBlock, Inf->SectionBlockSizeBytes);

            NewInf->LineBlock = MyMalloc(Inf->LineBlockSizeBytes);
            if(NewInf->LineBlock) {

                CopyMemory(NewInf->LineBlock, Inf->LineBlock, Inf->LineBlockSizeBytes);

                NewInf->ValueBlock = MyMalloc(Inf->ValueBlockSizeBytes);
                if(NewInf->ValueBlock) {

                    CopyMemory(NewInf->ValueBlock, Inf->ValueBlock, Inf->ValueBlockSizeBytes);

                    NewInf->StringTable = pStringTableDuplicate(Inf->StringTable);
                    if(NewInf->StringTable) {

                        NewInf->VersionBlock.DataBlock = MyTaggedMalloc(Inf->VersionBlock.DataSize,MEMTAG_VBDATA);
                        if(NewInf->VersionBlock.DataBlock) {

                            CopyMemory((PVOID)(NewInf->VersionBlock.DataBlock),
                                       Inf->VersionBlock.DataBlock,
                                       Inf->VersionBlock.DataSize
                                      );

                            if(Inf->SubstValueCount) {
                                NewInf->SubstValueList =
                                    MyMalloc(Inf->SubstValueCount * sizeof(STRINGSUBST_NODE));
                                if(!(NewInf->SubstValueList)) {
                                    goto clean0;
                                }
                                CopyMemory((PVOID)NewInf->SubstValueList,
                                           Inf->SubstValueList,
                                           Inf->SubstValueCount * sizeof(STRINGSUBST_NODE)
                                          );
                            }

                            if(Inf->UserDirIdList.UserDirIdCount) {
                                NewInf->UserDirIdList.UserDirIds =
                                    MyMalloc(Inf->UserDirIdList.UserDirIdCount * sizeof(USERDIRID));
                                if(!(NewInf->UserDirIdList.UserDirIds)) {
                                    goto clean0;
                                }
                                CopyMemory((PVOID)NewInf->UserDirIdList.UserDirIds,
                                           Inf->UserDirIdList.UserDirIds,
                                           Inf->UserDirIdList.UserDirIdCount * sizeof(USERDIRID)
                                          );
                            }

                            if(Inf->OsLoaderPath) {

                                NewInf->OsLoaderPath = DuplicateString(Inf->OsLoaderPath);

                                if(!NewInf->OsLoaderPath) {
                                    goto clean0;
                                }
                            }

                            if(Inf->InfSourcePath) {

                                NewInf->InfSourcePath = DuplicateString(Inf->InfSourcePath);

                                if(!NewInf->InfSourcePath) {
                                    goto clean0;
                                }
                            }

                            if(Inf->OriginalInfName) {

                                NewInf->OriginalInfName = DuplicateString(Inf->OriginalInfName);

                                if(!NewInf->OriginalInfName) {
                                    goto clean0;
                                }
                            }

                            //
                            // Reset the PNF fields because this backed-up INF is completely
                            // in-memory.
                            //
                            NewInf->FileHandle = NewInf->MappingHandle = INVALID_HANDLE_VALUE;
                            NewInf->ViewAddress = NULL;

                            NewInf->Signature = LOADED_INF_SIG;

                            Success = TRUE;
                        }
                    }
                }
            }
        }

clean0: ; // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Access the following variables here in the except clause, so that the compiler will respect
        // our statement ordering w.r.t. these variables.
        //
        Success = FALSE;
        NewInf->OriginalInfName = NewInf->OriginalInfName;
        NewInf->InfSourcePath = NewInf->InfSourcePath;
        NewInf->OsLoaderPath = NewInf->OsLoaderPath;
        NewInf->SubstValueList = NewInf->SubstValueList;
        NewInf->UserDirIdList.UserDirIds = NewInf->UserDirIdList.UserDirIds;
        NewInf->VersionBlock.DataBlock = NewInf->VersionBlock.DataBlock;
        NewInf->StringTable = NewInf->StringTable;
        NewInf->ValueBlock = NewInf->ValueBlock;
        NewInf->LineBlock = NewInf->LineBlock;
        NewInf->SectionBlock = NewInf->SectionBlock;
    }

    if(!Success) {
        //
        // Either we ran out of memory, or we got an inpage error trying to copy data
        // from a memory-mapped PNF image.  Free any memory we allocated above.
        //
        if(NewInf->OriginalInfName) {
            MyFree(NewInf->OriginalInfName);
        }

        if(NewInf->InfSourcePath) {
            MyFree(NewInf->InfSourcePath);
        }

        if(NewInf->OsLoaderPath) {
            MyFree(NewInf->OsLoaderPath);
        }

        if(NewInf->SubstValueList) {
            MyFree(NewInf->SubstValueList);
        }

        if(NewInf->UserDirIdList.UserDirIds) {
            MyFree(NewInf->UserDirIdList.UserDirIds);
        }

        if(NewInf->VersionBlock.DataBlock) {
            MyTaggedFree(NewInf->VersionBlock.DataBlock,MEMTAG_VBDATA);
        }

        if(NewInf->StringTable) {
            pStringTableDestroy(NewInf->StringTable);
        }

        if(NewInf->ValueBlock) {
            MyFree(NewInf->ValueBlock);
        }

        if(NewInf->LineBlock) {
            MyFree(NewInf->LineBlock);
        }

        if(NewInf->SectionBlock) {
            MyFree(NewInf->SectionBlock);
        }

        MyTaggedFree(NewInf,MEMTAG_INF);
        NewInf = NULL;
    } else {
        //
        // The copy was successful, but it made a copy of the pointer to the
        // log context, so we must addref if
        //
        RefLogContext(NewInf->LogContext);
    }

    return NewInf;
}


VOID
ReplaceLoadedInfDescriptor(
    IN PLOADED_INF InfToReplace,
    IN PLOADED_INF NewInf
    )

/*++

Routine Description:

    Replace the specified INF with a new INF descriptor.
    Note that this routine also frees the NewInf descriptor, when done.

Arguments:

    InfToReplace - supplies a pointer to the inf descriptor to be replaced.

    NewInf - supplies a pointer to the new INF descriptor that is to replace
        the existing one.

Return Value:

    None.

--*/

{
    FreeInfOrPnfStructures(InfToReplace);

    //
    // Copy backup to inf
    //
    CopyMemory(InfToReplace, NewInf, sizeof(LOADED_INF));

    //
    // Just free the NewInf descriptor itself.
    //
    MyTaggedFree(NewInf,MEMTAG_INF);
}


VOID
FreeInfOrPnfStructures(
    IN PLOADED_INF Inf
    )
/*++

Routine Description:

    If the specified INF was loaded from a textfile (non-PNF), then this routine
    frees the memory associated with the various blocks it contains.  If, instead,
    the Inf is a PNF, then the PNF file is unmapped from memory and the handle is
    closed.

    THIS ROUTINE DOES NOT FREE THE LOADED_INF STRUCTURE ITSELF!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

Return Value:

    None.

--*/
{
    //
    // If this INF has a vald FileHandle, then we must unmap and close its PNF,
    // otherwise, we simply need to free the associated memory blocks.
    //
    if(Inf->FileHandle != INVALID_HANDLE_VALUE) {

        pSetupUnmapAndCloseFile(Inf->FileHandle, Inf->MappingHandle, Inf->ViewAddress);

        pStringTableDestroy(Inf->StringTable);

    } else {

        MyFree(Inf->ValueBlock);
        MyFree(Inf->LineBlock);
        MyFree(Inf->SectionBlock);

        pStringTableDestroy(Inf->StringTable);

        if(Inf->VersionBlock.DataBlock) {
            MyTaggedFree(Inf->VersionBlock.DataBlock,MEMTAG_VBDATA);
        }

        if(Inf->SubstValueList) {
            MyFree(Inf->SubstValueList);
            Inf->SubstValueList = NULL;
        }

        if(Inf->OsLoaderPath) {
            MyFree(Inf->OsLoaderPath);
        }

        if(Inf->InfSourcePath) {
            MyFree(Inf->InfSourcePath);
        }

        if(Inf->OriginalInfName) {
            MyFree(Inf->OriginalInfName);
        }
    }

    //
    // For both INFs and PNFs, we must free the user-defined DIRID list (if there is one).
    //
    if(Inf->UserDirIdList.UserDirIds) {
        MyFree(Inf->UserDirIdList.UserDirIds);
    }

    //
    // Delete the log context if there is one
    //
    DeleteLogContext(Inf->LogContext);
    Inf->LogContext = NULL;

    //
    // Finally, mark the INF as no longer valid.
    //
    Inf->Signature = 0;
}


DWORD
ParseNewInf(
    IN  PCTSTR             FileImage,
    IN  DWORD              FileImageSize,
    IN  PCTSTR             InfSourcePath,       OPTIONAL
    IN  PCTSTR             OsLoaderPath,        OPTIONAL
    IN  PSETUP_LOG_CONTEXT LogContext,          OPTIONAL
    OUT PLOADED_INF       *Inf,
    OUT UINT              *ErrorLineNumber,
    IN  PSTRINGSEC_PARAMS  StringsSectionParams
    )

/*++

Routine Description:

    Parse an inf file from an in-memory image.

Arguments:

    FileImage - supplies a pointer to the unicode in-memory image
        of the file.

    FileImageSize - supplies the size of the in memory image.

    InfSourcePath - optionally, supplies the directory path from which
        the Inf is being loaded.

    OsLoaderPath - optionally, supplies the full path to the OsLoader
        (e.g., "C:\os\winnt40").  If it is discovered that this INF
        references system partition DIRIDs, then a copy of this string
        will be stored in the LOADED_INF structure.  If this parameter
        is not specified, then it will be retrieved from the registry,
        if needed.

    LogContext - optionally supplies the log context we should inherit from

    Inf - receives a pointer to the descriptor for the inf we loaded.

    ErrorLineNumber - receives the line number of a syntax error,
        if parsing was not successful for other than an out of memory
        condition.

    StringsSectionParams - Supplies information about the location of a
        [strings] section (if there is one) in this INF.

Return Value:

    Result indicating outcome. If the result is not ERROR_ERROR,
    ErrorLineNumber is filled in.

--*/

{
    PPARSE_CONTEXT ParseContext;
    PCTSTR Location;
    DWORD Result, OsLoaderPathLength;
    PVOID p;
    BOOL Done;
    PINF_SECTION DestDirsSection;
    PINF_LINE DestDirsLine;
    PCTSTR DirId;
    PTCHAR End;
    PCTSTR FileImageEnd;
    UINT NumPieces, i, DirIdInt;
    PCTSTR PieceList[3][2];    // 3 pieces, each with a start & end address
    UINT   StartLineNumber[3]; // keep track of the starting line number for
                               // each piece.

    *ErrorLineNumber = 0;
    ParseContext = MyMalloc(sizeof(PARSE_CONTEXT));
    if(!ParseContext) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(ParseContext,sizeof(PARSE_CONTEXT));

    ParseContext->Inf = AllocateLoadedInfDescriptor(
                            INITIAL_SECTION_BLOCK_SIZE,
                            INITIAL_LINE_BLOCK_SIZE,
                            INITIAL_VALUE_BLOCK_SIZE,
                            LogContext
                            );

    if(ParseContext->Inf) {
        ParseContext->SectionBlockSize = INITIAL_SECTION_BLOCK_SIZE;
        ParseContext->LineBlockSize = INITIAL_LINE_BLOCK_SIZE;
        ParseContext->ValueBlockSize = INITIAL_VALUE_BLOCK_SIZE;
        ParseContext->Inf->HasStrings = (StringsSectionParams->Start != NULL);
        ParseContext->InfSourcePath = InfSourcePath;
        if(OsLoaderPath) {
            if(!(ParseContext->OsLoaderPath = DuplicateString(OsLoaderPath))) {
                FreeLoadedInfDescriptor(ParseContext->Inf);
                ParseContext->Inf = NULL;
            }
        }
    }

    if(ParseContext->Inf) {

        ParseContext->Inf->Style = INF_STYLE_WIN4;

        //
        // We want to process the [strings] section first, if present,
        // so we split the file up into (up to) 3 pieces--string section,
        // what comes before it, and what comes after it.
        //
        FileImageEnd = FileImage + FileImageSize;

        if(StringsSectionParams->Start) {
            //
            // Figure out whether we have 1, 2, or 3 pieces.
            //
            PieceList[0][0] = StringsSectionParams->Start;
            PieceList[0][1] = StringsSectionParams->End;
            StartLineNumber[0] = StringsSectionParams->StartLineNumber;
            NumPieces = 1;

            if(StringsSectionParams->Start > FileImage) {
                PieceList[1][0] = FileImage;
                PieceList[1][1] = StringsSectionParams->Start;
                StartLineNumber[1] = 1;
                NumPieces++;
            }

            if(StringsSectionParams->End < FileImageEnd) {
                PieceList[NumPieces][0] = StringsSectionParams->End;
                PieceList[NumPieces][1] = FileImageEnd;
                StartLineNumber[NumPieces] = StringsSectionParams->EndLineNumber;
                NumPieces++;
            }

        } else {
            //
            // No [strings] section, just one big piece.
            //
            PieceList[0][0] = FileImage;
            PieceList[0][1] = FileImageEnd;
            StartLineNumber[0] = 1;
            NumPieces = 1;
        }

        //
        // Surround the parsing loop with try/except in case we get an inpage error.
        //
        Result = NO_ERROR;
        try {

            for(i = 0; ((Result == NO_ERROR) && (i < NumPieces)); i++) {
                //
                // Parse every line in this piece.
                //
                Location = PieceList[i][0];
                ParseContext->BufferEnd = PieceList[i][1];
                ParseContext->CurrentLineNumber = StartLineNumber[i];

                do {
                    Result = ParseGenericLine(ParseContext,&Location,&Done);
                    if(Result != NO_ERROR) {
                        break;
                    }
                } while(!Done);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Result = ERROR_READ_FAULT;
        }

        if(Result != NO_ERROR) {
            *ErrorLineNumber = ParseContext->CurrentLineNumber;
            FreeLoadedInfDescriptor(ParseContext->Inf);
            MyFree(ParseContext);
            return(Result);
        }

        //
        // We've successfully loaded the file. Trim down the section,
        // line, and value blocks. Since these guys are shrinking or
        // staying the same size the reallocs really ought not to fail.
        // If a realloc fails we'll just continue to use the original block.
        //
        ParseContext->Inf->SectionBlockSizeBytes = ParseContext->Inf->SectionCount * sizeof(INF_SECTION);
        p = MyRealloc(
                ParseContext->Inf->SectionBlock,
                ParseContext->Inf->SectionBlockSizeBytes
                );
        if(p) {
            ParseContext->Inf->SectionBlock = p;
        }

        ParseContext->Inf->LineBlockSizeBytes = ParseContext->LineBlockUseCount * sizeof(INF_LINE);
        p = MyRealloc(
                ParseContext->Inf->LineBlock,
                ParseContext->LineBlockUseCount * sizeof(INF_LINE)
                );
        if(p) {
            ParseContext->Inf->LineBlock = p;
        }

        ParseContext->Inf->ValueBlockSizeBytes = ParseContext->ValueBlockUseCount * sizeof(LONG);
        p = MyRealloc(
                ParseContext->Inf->ValueBlock,
                ParseContext->ValueBlockUseCount * sizeof(LONG)
                );
        if(p) {
            ParseContext->Inf->ValueBlock = p;
        }

        pStringTableTrim(ParseContext->Inf->StringTable);

        //
        // Even if we didn't find any string substitutions referencing system partition DIRIDs,
        // we still might have a reference in a [DestinationDirs] section--check for that now.
        // this will allow us to have these values ready for if/when they are referenced
        //
        if(!ParseContext->Inf->OsLoaderPath &&
           (DestDirsSection = InfLocateSection(ParseContext->Inf, pszDestinationDirs, NULL))) {

            for(i = 0;
                InfLocateLine(ParseContext->Inf, DestDirsSection, NULL, &i, &DestDirsLine);
                i++) {

                if(DirId = InfGetField(ParseContext->Inf, DestDirsLine, 1, NULL)) {

                    DirIdInt = _tcstoul(DirId, &End, 10);

                    if((DirIdInt == DIRID_BOOT) || (DirIdInt == DIRID_LOADER)) {
                        //
                        // We've found a reference to a system partition DIRID.  Store a copy
                        // of the system partition path we're using into the INF, and abort the
                        // search.
                        //
                        if(!ParseContext->OsLoaderPath) {
                            //
                            // We haven't yet retrieved the OsLoaderPath--do so now.
                            // (Re-use the parse context's TemporaryString buffer to get this.)
                            //
                            Result = pSetupGetOsLoaderDriveAndPath(FALSE,
                                                                   ParseContext->TemporaryString,
                                                                   SIZECHARS(ParseContext->TemporaryString),
                                                                   &OsLoaderPathLength
                                                                   );
                            if(Result) {
                                FreeLoadedInfDescriptor(ParseContext->Inf);
                                MyFree(ParseContext);
                                return Result;
                            }

                            OsLoaderPathLength *= sizeof(TCHAR); // want # bytes--not chars

                            if(!(ParseContext->OsLoaderPath = MyMalloc(OsLoaderPathLength))) {
                                FreeLoadedInfDescriptor(ParseContext->Inf);
                                MyFree(ParseContext);
                                return ERROR_NOT_ENOUGH_MEMORY;
                            }

                            CopyMemory((PVOID)ParseContext->OsLoaderPath,
                                       ParseContext->TemporaryString,
                                       OsLoaderPathLength
                                      );
                        }
                        ParseContext->Inf->OsLoaderPath = ParseContext->OsLoaderPath;
                        break;
                    }
                }
            }
        }

        //
        // If there is no OsLoaderPath stored in the INF, then that means that it contains no
        // references to system partition DIRIDs.  We can free the OsLoaderPath character buffer
        // contained in the parse context structure.
        //
        if(!ParseContext->Inf->OsLoaderPath && ParseContext->OsLoaderPath) {
            MyFree(ParseContext->OsLoaderPath);
        }

        *Inf = ParseContext->Inf;

        MyFree(ParseContext);
        return(NO_ERROR);
    }

    MyFree(ParseContext);
    return(ERROR_NOT_ENOUGH_MEMORY);
}


DWORD
PreprocessInf(
    IN     PCTSTR            FileImage,
    IN OUT PDWORD            FileImageSize,
    IN     BOOL              MatchClassGuid,
    IN     PCTSTR            ClassGuidString,     OPTIONAL
    IN     DWORD             LanguageId,          OPTIONAL
    IN     PSETUP_LOG_CONTEXT LogContext,         OPTIONAL
    IN     PCTSTR            FileName,            OPTIONAL
    OUT    PBOOL             Win95Inf,
    OUT    PSTRINGSEC_PARAMS StringsSectionParams OPTIONAL
    )
{
    PCTSTR FileImageEnd;
    PCTSTR VerAndStringsCheckUB, DecoratedStringsCheckUB, SigAndClassGuidCheckUB;
    PCTSTR p;
    PTSTR endp;
    UINT CurLineNumber, InStringsSection;
    PCTSTR StrSecStart[5], StrSecEnd[5];          // 1-based, 0th entry unused.
    UINT   StrSecStartLine[5], StrSecEndLine[5];  // ""
    BOOL InVersionSection;
    BOOL IsWin95Inf;
    DWORD rc = NO_ERROR;
    DWORD StrSecLangId, PrimaryLanguageId, NearLanguageId;
    BOOL LocalizedInf = FALSE;

    //
    // We make some assumptions about the relative lengths of certain
    // strings during the preprocessing phase for optimization reasons.
    // The following asserts verify that our assumptions remain correct.
    //
    MYASSERT(CSTRLEN(pszVersion) == CSTRLEN(pszStrings));
    MYASSERT(CSTRLEN(pszClassGuid) == CSTRLEN(pszSignature));
    MYASSERT(CSTRLEN(pszChicagoSig) <= CSTRLEN(pszWindowsNTSig));
    MYASSERT(CSTRLEN(pszWindowsNTSig) == CSTRLEN(pszWindows95Sig));

    FileImageEnd = FileImage + *FileImageSize;
    SigAndClassGuidCheckUB = FileImageEnd;

    //
    // I have to cast these two arrays to silence a bogus compiler warning about
    // different 'const' qualifiers.
    //
    ZeroMemory((PVOID)StrSecStart, sizeof(StrSecStart));
    ZeroMemory((PVOID)StrSecEnd, sizeof(StrSecEnd));
    InStringsSection = 0;

    PrimaryLanguageId = (DWORD)PRIMARYLANGID(LanguageId);
    NearLanguageId = 0;

    InVersionSection = IsWin95Inf = FALSE;
    CurLineNumber = 1;

    //
    // Pre-compute upper-bound for section name string comparison that we
    // make multiple times, so that we don't have to compute it each
    // time.
    //
    VerAndStringsCheckUB = FileImageEnd - CSTRLEN(pszVersion);
    DecoratedStringsCheckUB = VerAndStringsCheckUB - 5;         // "strings" + ".xxxx"

    //
    // Define a macro that lets us know we're at the end of the file
    // if either:
    // (a) we reach the end of the image, or
    // (b) we hit a CTL-Z
    //
    #define AT_EOF ((p >= FileImageEnd) || (*p == (TCHAR)26))

    //
    // Guard the pre-processing pass through the file with a try/except, in
    // case we get an inpage error.
    //
    try {

        for(p=FileImage; !AT_EOF; ) {

            //
            // Skip whitespace and newlines.
            //
            while(TRUE) {
                if(*p == TEXT('\n')) {
                    CurLineNumber++;
                } else if(!IsWhitespace(p)) {
                    break;
                }
                p++;
                if(AT_EOF) {
                    break;
                }
            }

            if(AT_EOF) {
                //
                // We're through processing the buffer.
                //
                break;
            }

            //
            // See if it's a section title.
            //
            if(*p == TEXT('[')) {

                //
                // If the section we were just in was a [Strings] section, then
                // remember where the strings section ended.
                //
                if(InStringsSection) {
                    StrSecEnd[InStringsSection] = p;
                    StrSecEndLine[InStringsSection] = CurLineNumber;
                    InStringsSection = 0;
                }

                p++;
                InVersionSection = FALSE;

                //
                // See if it's one of the ones we care about.
                //
                // (Be careful here--we check the closing bracket position
                // _before_ the string compare as an optimization.  It just
                // so happens that both strings are the same length, so this
                // acts as a quick filter to eliminate string compares.)
                //
                if((p < VerAndStringsCheckUB) &&
                   (*(p + CSTRLEN(pszVersion)) == TEXT(']'))) {
                    //
                    // Then we may have either a [Version] or a [Strings] section.
                    // Check for these in turn.
                    //
                    if(!_tcsnicmp(p, pszVersion, CSTRLEN(pszVersion))) {
                        InVersionSection = TRUE;
                        p += (CSTRLEN(pszVersion) + 1);
                        //
                        // Pre-compute an upper bound to speed up string comparisons
                        // when checking for signature and class GUID entries.
                        //
                        SigAndClassGuidCheckUB = FileImageEnd - CSTRLEN(pszSignature);

                    } else {
                        if(!StrSecStart[4] && !_tcsnicmp(p, pszStrings, CSTRLEN(pszStrings))) {
                            //
                            // We matched on the undecorated string section--this is the lowest
                            // priority match.
                            //
                            InStringsSection = 4;
                            StrSecStart[4] = p-1;
                            StrSecStartLine[4] = CurLineNumber;
                            p += (CSTRLEN(pszStrings) + 1);
                        }
                    }

                } else if(LanguageId && !StrSecStart[1]) {
                    //
                    // We don't have a [strings] nor a [version] section.  However, we need to
                    // check to see if we have a language-specific strings section, for example,
                    //
                    //     [strings.0409]
                    //
                    if((p < DecoratedStringsCheckUB) &&
                       (*(p + CSTRLEN(pszVersion) + 5) == TEXT(']'))) {
                        //
                        // The section name is of the right length.  Now verify that the name
                        // begins with "strings."
                        //
                        if((*(p + CSTRLEN(pszVersion)) == TEXT('.')) &&
                           !_tcsnicmp(p, pszStrings, CSTRLEN(pszStrings))) {
                            //
                            // OK, we've found a language-specific strings section--retrieve
                            // the 4-digit (hex) language ID.
                            //
                            StrSecLangId = _tcstoul((p + CSTRLEN(pszVersion) + 1), &endp, 16);

                            if(endp == (p + CSTRLEN(pszVersion) + 5)) {
                                //
                                // The language ID was of the proper form - this
                                // is a localized INF
                                //
                                LocalizedInf = TRUE;
                                //
                                // now see if it matches the language we're
                                // supposed to be using when loading this INF.
                                //
                                if(StrSecLangId == LanguageId) {
                                    //
                                    // we have an exact match
                                    //
                                    InStringsSection = 1;
                                    NearLanguageId = LanguageId;

                                } else if(StrSecLangId == PrimaryLanguageId) {
                                    //
                                    // we have a match on primary language (sublanguage is not
                                    // included in the strings section's name--thus permitting
                                    // a 'wildcard' match).
                                    //
                                    if(!StrSecStart[2]) {
                                        InStringsSection = 2;
                                    }
                                    if(!StrSecStart[1]) {
                                        NearLanguageId = PrimaryLanguageId;
                                    }

                                } else if((DWORD)PRIMARYLANGID(StrSecLangId) == PrimaryLanguageId) {
                                    //
                                    // we have a match on primary language (sublanguage is a
                                    // mismatch, but it's better than falling back to the default).
                                    //
                                    if(!StrSecStart[3]) {
                                        InStringsSection = 3;
                                        if(!StrSecStart[1] && !StrSecStart[2]) {
                                            NearLanguageId = StrSecLangId;
                                        }
                                    }
                                }

                                if(InStringsSection) {
                                    StrSecStart[InStringsSection] = p-1;
                                    StrSecStartLine[InStringsSection] = CurLineNumber;
                                }
                                p += (CSTRLEN(pszStrings) + 6);
                            }
                        }
                    }
                }

            } else {

                if(InVersionSection && (p < SigAndClassGuidCheckUB)) {
                    //
                    // See if this is the signature line indicating a Win95-style
                    // Device INF. (signature=$Chicago$ or "$Windows NT$")
                    //
                    if(!IsWin95Inf && !_tcsnicmp(p, pszSignature, CSTRLEN(pszSignature))) {

                        PCTSTR ChicagoCheckUB = FileImageEnd - CSTRLEN(pszChicagoSig);

                        //
                        // Skip over Signature, and look for "$Chicago$" or
                        // "$Windows NT$" anywhere on the rest of the line
                        //
                        p += CSTRLEN(pszSignature);

                        while((p <= ChicagoCheckUB) &&
                              (*p != (TCHAR)26) && (*p != TEXT('\n'))) {

                            if(*(p++) == TEXT('$')) {
                                //
                                // Check for signatures (check in order of
                                // increasing signature length, so that we can
                                // eliminate checks if we happen to be near the
                                // end of the file).
                                //
                                // Check for "$Chicago$"
                                //
                                if(!_tcsnicmp(p,
                                              pszChicagoSig + 1,
                                              CSTRLEN(pszChicagoSig) - 1)) {

                                    IsWin95Inf = TRUE;
                                    p += (CSTRLEN(pszChicagoSig) - 1);

                                } else if((p + (CSTRLEN(pszWindowsNTSig) - 1)) <= FileImageEnd) {
                                    //
                                    // Check for "Windows NT$" and "Windows 95$" (we already checked
                                    // for the preceding '$').
                                    //
                                    if(!_tcsnicmp(p, pszWindowsNTSig + 1, CSTRLEN(pszWindowsNTSig) - 1) ||
                                       !_tcsnicmp(p, pszWindows95Sig + 1, CSTRLEN(pszWindows95Sig) - 1)) {

                                        IsWin95Inf = TRUE;
                                        p += (CSTRLEN(pszWindowsNTSig) - 1);
                                    }
                                }
                                break;
                            }
                        }

                    } else if(MatchClassGuid && !_tcsnicmp(p, pszClassGuid, CSTRLEN(pszClassGuid))) {

                        PCTSTR GuidStringCheckUB = FileImageEnd - (GUID_STRING_LEN - 1);

                        //
                        // We have found a ClassGUID line--see if it matches the
                        // class GUID specified by the caller.
                        //
                        p += CSTRLEN(pszClassGuid);

                        //
                        // If a class GUID string wasn't specified, then use GUID_NULL.
                        //
                        if(!ClassGuidString) {
                            ClassGuidString = pszGuidNull;
                        }

                        while((p <= GuidStringCheckUB) &&
                              (*p != (TCHAR)26) && (*p != TEXT('\n'))) {

                            if(*(p++) == TEXT('{')) {

                                if((*(p + (GUID_STRING_LEN - 3)) != TEXT('}')) ||
                                   _tcsnicmp(p, ClassGuidString + 1, GUID_STRING_LEN - 3)) {
                                    //
                                    // The GUIDs don't match.  If ClassGuid was NULL, then
                                    // this means we should continue, because we were matching
                                    // against GUID_NULL, which we want to disallow.
                                    //
                                    if(ClassGuidString == pszGuidNull) {
                                        //
                                        // We don't need to keep looking for ClassGUIDs.
                                        //
                                        MatchClassGuid = FALSE;
                                    }
                                } else {
                                    //
                                    // The GUIDs match.  If ClassGuid was not NULL, then this
                                    // means that we should continue.
                                    //
                                    if(ClassGuidString != pszGuidNull) {
                                        //
                                        // We don't need to keep looking for ClassGUIDs.
                                        //
                                        MatchClassGuid = FALSE;
                                    }
                                }
                                //
                                // Skip over the GUID string.
                                //
                                p += (GUID_STRING_LEN - 2);

                                break;
                            }
                        }

                        //
                        // If we get here, and MatchClassGuid hasn't been reset,
                        // then we know that this ClassGUID entry didn't match.
                        //
                        if(MatchClassGuid) {
                            rc = ERROR_CLASS_MISMATCH;
                            goto clean0;
                        }
                    }
                }
            }

            //
            // Skip to the newline or end of file.
            //
            while(!AT_EOF && (*p != TEXT('\n'))) {
                p++;
            }
        }

clean0: ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_READ_FAULT;
    }

    if(rc == NO_ERROR) {

        MYASSERT(p <= FileImageEnd);

        if(p < FileImageEnd) {
            //
            // Then we hit a CTL-Z during processing, so update the
            // FileImageSize output parameter with the new size.
            //
            *FileImageSize = (DWORD)(p - FileImage);
        }

        if(StringsSectionParams) {
            //
            // If a strings section happens to be the last section in the INF,
            // then we need to remember the end of the INF as being the end of
            // the string section also.
            //
            if(InStringsSection) {
                StrSecEnd[InStringsSection] = p;
                StrSecEndLine[InStringsSection] = CurLineNumber;
            }

            //
            // Now search through our array of strings sections (highest priority to lowest),
            // looking for the best match.
            //
            for(InStringsSection = 1; InStringsSection < 5; InStringsSection++) {
                if(StrSecStart[InStringsSection]) {
                    break;
                }
            }
            //
            // if the INF appears to be partially localized, and we didn't
            // pick an apropriate localized string section
            // log it
            //
            if(LogContext && IsWin95Inf) {
                if(InStringsSection >= 5) {
                    //
                    // it's quite valid to have an INF with no strings section
                    // so log it verbose here, we'll catch it later
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_VERBOSE,
                                  MSG_LOG_NO_STRINGS,
                                  NULL,
                                  LanguageId,
                                  PrimaryLanguageId,
                                  NearLanguageId,
                                  FileName
                                  );
                } else if(LocalizedInf && InStringsSection > 2) {
                    //
                    // INF has localized string sections
                    // but none were reasonable match for locale
                    //
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_WARNING,
                                  (InStringsSection> 3 ? MSG_LOG_DEF_STRINGS :
                                                         MSG_LOG_NEAR_STRINGS),
                                  NULL,
                                  LanguageId,
                                  PrimaryLanguageId,
                                  NearLanguageId,
                                  FileName
                                  );
                }
            }

            if(IsWin95Inf && (InStringsSection < 5)) {
                //
                // If we found a [strings] section in a Win95-style INF,
                // then store the beginning and ending positions, and the
                // beginning and ending line numbers, in the output parameter
                // structure
                //
                StringsSectionParams->Start = StrSecStart[InStringsSection];
                StringsSectionParams->End = StrSecEnd[InStringsSection];
                StringsSectionParams->StartLineNumber = StrSecStartLine[InStringsSection];
                StringsSectionParams->EndLineNumber = StrSecEndLine[InStringsSection];

            } else {
                ZeroMemory(StringsSectionParams, sizeof(STRINGSEC_PARAMS));
            }
        }

        *Win95Inf = IsWin95Inf;
    }

    return rc;
}


DWORD
DetermineInfStyle(
    IN PCTSTR            Filename,
    IN LPWIN32_FIND_DATA FindData
    )

/*++

Routine Description:

    Open an inf file, determine its style, and close the file, without
    keeping it around.

Arguments:

    Filename - supplies the fully-qualified pathname of the inf file to be checked

Return Value:

    INF_STYLE_NONE - style could not be determined
    INF_STYLE_WIN4 - win95-style inf file
    INF_STYLE_OLDNT - winnt3.5-style inf file

--*/

{
    HANDLE TextFileHandle;
    TEXTFILE_READ_BUFFER ReadBuffer;
    DWORD Style;
    BOOL Win95Inf;
    PLOADED_INF Pnf;

    //
    // First, determine whether a precompiled form of this INF exists, and if so, then
    // use it to determine the INF's style.
    //
    if(LoadPrecompiledInf(Filename,
                          &(FindData->ftLastWriteTime),
                          NULL,
                          0,
                          LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | LDINF_FLAG_IGNORE_LANGUAGE,
                          NULL,
                          &Pnf,
                          NULL,
                          NULL,
                          NULL)) {
        //
        // Now we can simply access the Style field of the INF.
        //
        try {
            Style = (DWORD)Pnf->Style;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Style = INF_STYLE_NONE;
        }

        //
        // Now close the PNF.
        //
        FreeInfFile(Pnf);

    } else {
        //
        // No PNF--Open and preprocess the text version of the INF to find out its style.
        //
        if((TextFileHandle = CreateFile(Filename,
                                        GENERIC_READ,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        0,
                                        NULL)) == INVALID_HANDLE_VALUE) {
            return INF_STYLE_NONE;

        } else {
            //
            // We're ready to make the determination--initially assume 'no-style'
            //
            Style = INF_STYLE_NONE;
        }

        if(ReadAsciiOrUnicodeTextFile(TextFileHandle, &ReadBuffer,NULL) == NO_ERROR) {

            if(PreprocessInf(ReadBuffer.TextBuffer,
                             &(ReadBuffer.TextBufferSize),
                             FALSE,
                             NULL,
                             0,
                             NULL,
                             NULL,
                             &Win95Inf,
                             NULL) == NO_ERROR) {

                Style = Win95Inf ? INF_STYLE_WIN4 : INF_STYLE_OLDNT;
            }
            DestroyTextFileReadBuffer(&ReadBuffer);
        }
        //
        // No need to close the textfile handle--it's taken care of in the above routines.
        //
    }

    return Style;
}


DWORD
LoadInfFile(
    IN  PCTSTR            Filename,
    IN  LPWIN32_FIND_DATA FileData,
    IN  DWORD             Style,
    IN  DWORD             Flags,
    IN  PCTSTR            ClassGuidString, OPTIONAL
    IN  PCTSTR            InfSourcePath,   OPTIONAL
    IN  PCTSTR            OriginalInfName, OPTIONAL
    IN  PLOADED_INF       AppendInf,       OPTIONAL
    IN  PSETUP_LOG_CONTEXT pLogContext,     OPTIONAL
    OUT PLOADED_INF      *LoadedInf,
    OUT UINT             *ErrorLineNumber,
    OUT BOOL             *PnfWasUsed       OPTIONAL
    )

/*++

Routine Description:

    Top level routine to load an inf file. Both win95-style and winnt3.x-style
    device infs are supported.

Arguments:


    Filename - supplies the fully-qualified pathname of the inf file to be loaded

    FileData - supplies data returned from FindFirstFile/FindNextFile for this INF.

    Style - supplies a type of inf file to be loaded. May be a combination of

        INF_STYLE_WIN4 - fail to load the given inf file if it is not a win95
            inf file.

        INF_STYLE_OLDNT - fail to load the given inf file if it is not an old
            style inf file.

        If a load fails because of the type, the return code is
        ERROR_WRONG_INF_STYLE.

    Flags - Specifies certain behaviors to use when loading the INF.  May be a
        combination of the following values:

        LDINF_FLAG_MATCH_CLASS_GUID - Check the INF to make sure it matches the GUID
            specified by the ClassGuid parameter (see discussion below).

        LDINF_FLAG_ALWAYS_TRY_PNF - If specified, then we will always attempt to
            generate a PNF file, if a valid one does not exist.

        LDINF_FLAG_IGNORE_VOLATILE_DIRIDS - If specified, then no validation
            will be done on the stored OsLoaderPath present in the PNF.  Since
            dynamically retrieving the current path is time consuming, this
            flag should be specified as an optimization if it is known that the
            relevant DIRIDs are not going to be needed (e.g., driver searching).

            This flag also suppresses substitution of volatile system DIRIDs.

            (Note: this flag should not be specified when append-loading an INF)

        LDINF_FLAG_REGENERATE_PNF - If specified, then the existing PNF (if
            present) is considered invalid, and is not even checked for.  This
            flag causes us to always generate a new PNF, and if we're unable to
            do so, the routine will fail.  This flag must always be specified in
            conjunction with LDINF_FLAG_ALWAYS_TRY_PNF.

        LDINF_FLAG_SRCPATH_IS_URL - If specified, then the InfSourcePath passed in is
            not a file path, but rather a URL.  If this flag is specified, InfSourcePath
            may still be NULL, which indicates that the origin of this INF was the default
            Code Download Manager site.

    ClassGuidString - Optionally, supplies the address of a class GUID string that
        the INF should match in order to be opened.  If the LDINF_FLAG_MATCH_CLASS_GUID
        bit is set in the Flags parameter, this GUID is matched against the ClassGUID
        entry in the [version] section of the INF.  If the two GUIDs are different, the
        load will fail with ERROR_CLASS_MISMATCH.  If the INF has no ClassGUID entry,
        then this check is not made, and the file is always opened.  If ClassGUID matching
        is requested, but ClassGuidString is NULL, then the INF load will succeed for all
        INFs except those with a ClassGUID of GUID_NULL.

    InfSourcePath - Optionally, supplies a path to be used as the INF's source path.  If
        LDINF_FLAG_SRCPATH_IS_URL is specified, this is a URL (see above), otherwise, this
        is a directory path.  This information is stored in the PNF file if this INF gets
        precompiled.

        If LDINF_FLAG_SRCPATH_IS_URL is specified, then "A:\" is used as the directory string
        substitution for DIRID_SRCPATH.

    OriginalInfName - Optionally, supplies the original name of the INF (no path)
        to be stored in the PNF, if generated.  If this parameter is not supplied,
        then the INF's present name is assumed to be its original name.

    AppendInf - if supplied, specifies an already-loaded inf to which
        the inf is to be load-appended.  THIS INF MUST HAVE BEEN ALREADY LOCKED BY THE
        CALLER!!!

    pLogContext - if supplied, specifies a LogContext that should be inherited
        as opposed to creating one

    LoadedInf - If AppendInf is not specified, receives a pointer to
        the descriptor for the inf. If AppendInf is specified, receives AppendInf.

    ErrorLineNumber - receives the line number of the error if there is
        a syntax error in the file (see below)

    PnfWasUsed - optionally, receives a boolean value upon successful return
        indicating whether or not a precompiled INF was used/generated in
        loading this INF.  NOTE, this flag should not be specified if an
        append-load is requested.

Return Value:

    Win32 error code (with inf extensions) for result.
    If result is not NO_ERROR, ErrorLineNumber is filled in.

--*/

{
    TEXTFILE_READ_BUFFER ReadBuffer;
    DWORD rc;
    PLOADED_INF Inf, InfListTail;
    BOOL Win95Inf;
    STRINGSEC_PARAMS StringsSectionParams;
    HANDLE TextFileHandle;
    PCTSTR OsLoaderPath = NULL;
    DWORD LanguageId;
    PTSTR InfSourcePathToMigrate, InfOriginalNameToMigrate;
    DWORD InfSourcePathToMigrateMediaType = SPOST_NONE;
    BOOL PnfUsed = FALSE;   // this allows us to log the flag if PnfWasUsed=NULL
    BOOL PnfSaved = FALSE;  // allows us to log the fact that we saved PNF
    PSETUP_LOG_CONTEXT LogContext = NULL;

    MYASSERT(!(AppendInf && PnfWasUsed));

    MYASSERT(!(AppendInf && (Flags & LDINF_FLAG_IGNORE_VOLATILE_DIRIDS)));

    *ErrorLineNumber = 0;

    if(PnfWasUsed) {
        *PnfWasUsed = FALSE;
    }

    //
    // Since we're now storing zero-length INF files in %windir%\Inf as
    // placeholders for the corresponding catalog files, add a quick check to
    // make sure we haven't been handed a zero-length INF.  If so, we can return
    // immediately and short ciruit some code.  (While we're at it, also make
    // sure that the high DWORD doesn't have any bits set, as we can't handle
    // files greater than 2^32).
    //
    if(FileData->nFileSizeHigh || !FileData->nFileSizeLow) {
        return ERROR_GENERAL_SYNTAX;
    }

    //
    // If append-loading, then traverse the existing list of loaded INFs, to see
    // if we've already loaded this one.
    //
    if(AppendInf) {
        //
        // Only allow appending with win95 infs
        //
        if(AppendInf->Style & INF_STYLE_OLDNT) {
            return ERROR_WRONG_INF_STYLE;
        }

        for(Inf = AppendInf; Inf; Inf = Inf->Next) {
            if(!lstrcmpi(Inf->VersionBlock.Filename, Filename)) {
                //
                // We've already loaded this INF--we can return success.
                //
                *LoadedInf = AppendInf;
                return NO_ERROR;
            }

            //
            // Check to see if the INF we're currently examining references the
            // system partition/OsLoader path.  If so, then remember this path
            // so that we will use the same one later when append-loading our
            // new INF.
            //
            if(Inf->OsLoaderPath) {
                if(OsLoaderPath) {
                    //
                    // We'd better be using the same value for OsLoadPath for
                    // all our append-loaded INFs!
                    //
                    MYASSERT(!lstrcmpi(Inf->OsLoaderPath, OsLoaderPath));
                } else {
                    OsLoaderPath = Inf->OsLoaderPath;
                }
            }

            //
            // Remember this node, in case it's the tail.  We do this so we don't
            // have to hunt for the tail again later.
            //
            InfListTail = Inf;
        }

        //
        // We want to append-load the INF based on the locale of the already-
        // loaded INF(s)
        //
        LanguageId = AppendInf->LanguageId;

    } else {
        //
        // We want to load the INF based on the current locale set for this thread.
        //
        LanguageId = (DWORD)LANGIDFROMLCID(GetThreadLocale());
    }

    InheritLogContext(pLogContext,&LogContext);

    //
    // Now determine whether a precompiled form of this INF exists, and if so,
    // then use it instead.
    //
    if(!(Flags & LDINF_FLAG_REGENERATE_PNF)) {
        if (!InfSourcePath && !(Flags & LDINF_FLAG_SRCPATH_IS_URL)) {
            //
            // if no source information provided, then always use that provided in the PNF
            // even if it might be wrong
            // typically when we're replacing such an INF, we'll explicitly say
            // not to load existing PNF
            //
            Flags |= LDINF_FLAG_ALWAYS_GET_SRCPATH;
        }
        if (LoadPrecompiledInf(Filename,
                          &(FileData->ftLastWriteTime),
                          OsLoaderPath,
                          LanguageId,
                          Flags,
                          LogContext,
                          &Inf,
                          &InfSourcePathToMigrate,
                          &InfSourcePathToMigrateMediaType,
                          &InfOriginalNameToMigrate)) {
            //
            // Make sure that the PNF is of the specified style.
            //
            if(!(Style & (DWORD)Inf->Style)) {
                FreeInfFile(Inf);
                DeleteLogContext(LogContext);
                return ERROR_WRONG_INF_STYLE;
            }

            if(AppendInf) {
                Inf->Prev = InfListTail;
                InfListTail->Next = Inf;
            }

            PnfUsed = TRUE;
            if(PnfWasUsed) {
                *PnfWasUsed = TRUE;
            }

            rc = NO_ERROR;
            goto clean0;
        }
    }

    //
    // If we tried to load the PNF and it failed, then check to see if we were
    // returned any INF source path information to migrate to the new PNF.  If
    // so, then this overrides the InfSourcePath information passed into this
    // routine.
    //
    if(InfSourcePathToMigrateMediaType != SPOST_NONE) {
        //
        // Discard the arguments the caller passed in and use what we retrieved
        // from the old PNF instead.
        //
        InfSourcePath = InfSourcePathToMigrate;
        if(InfSourcePathToMigrateMediaType == SPOST_PATH) {
            //
            // Make sure the "sourcepath is URL" bit is not set.
            //
            Flags &= ~LDINF_FLAG_SRCPATH_IS_URL;
        } else {
            //
            // This is a URL path--make sure the "sourcepath is URL" bit is set.
            //
            Flags |= LDINF_FLAG_SRCPATH_IS_URL;
        }

        //
        // If we're migrating source path information from the PNF, then we need
        // to use the PNF-specified original INF name, as well, instead of what
        // the caller may have specified.
        //
        OriginalInfName = InfOriginalNameToMigrate;
    }

    //
    // We can't use a precompiled INF, so resort to reading in the textfile INF.
    //
    if((TextFileHandle = CreateFile(Filename,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    0,
                                    NULL)) == INVALID_HANDLE_VALUE) {

        if(InfSourcePathToMigrateMediaType != SPOST_NONE) {
            if(InfSourcePathToMigrate) {
                MyFree(InfSourcePathToMigrate);
            }
            if(InfOriginalNameToMigrate) {
                MyFree(InfOriginalNameToMigrate);
            }
        }
        DeleteLogContext(LogContext);
        return GetLastError();
    }

    //
    // Note: We don't have to worry about closing TextFileHandle from this point
    // on, because the following routine will either close it for us, or copy it
    // into the ReadBuffer structure, to be later closed via DestroyTextFileReadBuffer().
    //
    if((rc = ReadAsciiOrUnicodeTextFile(TextFileHandle, &ReadBuffer,LogContext)) == NO_ERROR) {
        //
        // Make sure the style (and class) matched what the caller is asking
        // for and go parse the inf file in a style-specific manner.
        //
        Inf = NULL;
        if((rc = PreprocessInf(ReadBuffer.TextBuffer,
                               &(ReadBuffer.TextBufferSize),
                               (Flags & LDINF_FLAG_MATCH_CLASS_GUID),
                               ClassGuidString,
                               LanguageId,
                               LogContext,
                               Filename,
                               &Win95Inf,
                               &StringsSectionParams)) == NO_ERROR) {

            rc = ERROR_WRONG_INF_STYLE;
            if(Win95Inf) {
                if(Style & INF_STYLE_WIN4) {
                    //
                    // If we're dealing with a URL, then we don't have a real
                    // directory that we can do substitions on for DIRID_SRCPATH.
                    // "A:\" is about the best we can do.
                    //
                    rc = ParseNewInf(ReadBuffer.TextBuffer,
                                     ReadBuffer.TextBufferSize,
                                     (Flags & LDINF_FLAG_SRCPATH_IS_URL) ? pszOemInfDefaultPath
                                                                         : InfSourcePath,
                                     OsLoaderPath,
                                     LogContext,
                                     &Inf,
                                     ErrorLineNumber,
                                     &StringsSectionParams
                                    );
                }
            } else {
                //
                // Can't append old-style file.
                //
                if(!AppendInf && (Style & INF_STYLE_OLDNT)) {
                    rc = ParseOldInf(ReadBuffer.TextBuffer,
                                     ReadBuffer.TextBufferSize,
                                     LogContext,
                                     &Inf,
                                     ErrorLineNumber
                                    );
                }
            }
        }

        //
        // Free the in-memory image of the file.
        //
        DestroyTextFileReadBuffer(&ReadBuffer);

        if(rc == NO_ERROR) {
            //
            // If we get here then we've parsed the file successfully.
            // Set up version block for this file.
            //
            *ErrorLineNumber = 0;
            rc = CreateInfVersionNode(Inf, Filename, &(FileData->ftLastWriteTime));

            if(rc == NO_ERROR) {

                Inf->InfSourceMediaType = (Flags & LDINF_FLAG_SRCPATH_IS_URL) ? SPOST_URL
                                                                              : SPOST_PATH;

                if(InfSourcePath) {
                    //
                    // If the caller specified a source path (or we're migrating
                    // one from a previously-existing PNF), then duplicate the
                    // string, and store a pointer to it in our INF structure.
                    //
                    if(!(Inf->InfSourcePath = DuplicateString(InfSourcePath))) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if((rc == NO_ERROR) && OriginalInfName) {
                    //
                    // If the caller specified the INF's original filename (or
                    // we're migrating one from a previously-existing PNF), then
                    // duplicate the string, and store a pointer to it in our
                    // INF structure.
                    //
                    // We shouldn't be storing this name if it's the same as the
                    // INF's present name.
                    //
                    MYASSERT(lstrcmpi(OriginalInfName, pSetupGetFileTitle(Filename)));

                    if(!(Inf->OriginalInfName = DuplicateString(OriginalInfName))) {
                        rc = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }

            if(rc == NO_ERROR) {
                //
                // Store the language ID used to load this INF into the LOADED_INF structure.
                //
                Inf->LanguageId = LanguageId;

                if (Flags & LDINF_FLAG_OEM_F6_INF) {
                    Inf->Flags = LIF_OEM_F6_INF;
                }

                //
                // If we get here then we've parsed the file successfully and
                // successfully created the version block.  If we're allowed
                // to write out a PNF file for this loaded INF, then do that
                // now.
                //
                if(Flags & LDINF_FLAG_ALWAYS_TRY_PNF) {

                    rc = SavePnf(Filename, Inf);

                    if(rc == NO_ERROR) {
                        PnfSaved = TRUE;
                        if(PnfWasUsed) {
                            *PnfWasUsed = TRUE;
                        }
                    } else if(((rc == ERROR_SHARING_VIOLATION)
                               || ((rc == ERROR_LOCK_VIOLATION)))
                              && (Flags & LDINF_FLAG_ALLOW_PNF_SHARING_LOCK)) {
                        //
                        // A sharing-type error occurred
                        // so a PNF exists and is in USE
                        // and we are flagged to indicate that it's non-fatal.
                        //
                        rc = NO_ERROR;
                    } else if(!(Flags & LDINF_FLAG_REGENERATE_PNF)) {
                        //
                        // We weren't explicitly asked to generate a PNF, thus
                        // our failure to do so shouldn't be considered fatal.
                        //
                        rc = NO_ERROR;
                    }
                }
            }

            if(rc == NO_ERROR) {
                if(AppendInf) {
                    Inf->Prev = InfListTail;
                    InfListTail->Next = Inf;
                }
            } else {
                FreeInfFile(Inf);
            }
        }
    }

clean0:

    if(AppendInf) {
        //
        // If the newly-loaded INF has any volatile system DIRIDs, or if the
        // INF we're appending to has any user-defined DIRIDs, then apply those
        // to the newly-appended INF now.
        //
        if((rc == NO_ERROR) &&
           (AppendInf->UserDirIdList.UserDirIdCount || Inf->Flags & LIF_HAS_VOLATILE_DIRIDS)) {

            if((rc = ApplyNewVolatileDirIdsToInfs(AppendInf, Inf)) != NO_ERROR) {
                //
                // So near, and yet, so far!  Yank the new INF out of the linked
                // list, and free it.
                //
                MYASSERT(Inf->Prev);
                Inf->Prev->Next = Inf->Next;
                FreeInfFile(Inf);
            }
        }
        if(rc == NO_ERROR) {
            *LoadedInf = AppendInf;
        }
    } else if(rc == NO_ERROR) {
        //
        // We're not append-loading the INF, thus there's no user-defined
        // DIRID substitutions to worry about.  However, if the INF has volatile
        // system DIRIDs, then we still need to apply paths to those DIRIDs now
        // (unless the caller said to skip it).
        //
        if((Inf->Flags & LIF_HAS_VOLATILE_DIRIDS) &&
           !(Flags & LDINF_FLAG_IGNORE_VOLATILE_DIRIDS)) {

            rc = ApplyNewVolatileDirIdsToInfs(Inf, NULL);
        }
        if(rc == NO_ERROR) {
            *LoadedInf = Inf;
        } else {
            FreeInfFile(Inf);
        }
    }

    if (rc == NO_ERROR) {
        //
        // log that the INF was loaded
        //
        WriteLogEntry(
            LogContext,
            SETUP_LOG_VVERBOSE,
            (PnfUsed ? MSG_LOG_OPENED_PNF
                     : (PnfSaved ? MSG_LOG_SAVED_PNF : MSG_LOG_OPENED_INF)),
            NULL,
            Filename,
            LanguageId);
    }

    if(InfSourcePathToMigrateMediaType != SPOST_NONE) {
        if(InfSourcePathToMigrate) {
            MyFree(InfSourcePathToMigrate);
        }
        if(InfOriginalNameToMigrate) {
            MyFree(InfOriginalNameToMigrate);
        }
    }
    DeleteLogContext(LogContext);

    return rc;
}


VOID
FreeInfFile(
    IN PLOADED_INF LoadedInf
    )

/*++

Routine Description:

    Unload an inf file, freeing all resources used by its internal
    representation.

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

Return Value:

    None.

--*/

{
    if(LockInf(LoadedInf)) {
        DestroySynchronizedAccess(&LoadedInf->Lock);
        FreeLoadedInfDescriptor(LoadedInf);
    }
}


BOOL
AddDatumToVersionBlock(
    IN OUT PINF_VERSION_NODE VersionNode,
    IN     PCTSTR            DatumName,
    IN     PCTSTR            DatumValue
    )

/*++

Routine Description:

    Append an inf version datum to the version node.

Arguments:

    VersionNode - supplies pointer to the version node.

    DatumName - supplies name of the datum.

    DatumValue - supplies datum's value.

Return Value:

    FALSE if OOM.
    TRUE if datum added successfully. Various fields in the VersionNode
        will have been updated.

--*/

{
    UINT RequiredSpace;
    UINT NameLength, ValueLength;
    PTSTR NewDataBlock;

    NameLength = lstrlen(DatumName) + 1;
    ValueLength = lstrlen(DatumValue) + 1;

    //
    // The space needed to store the datum is the existing space plus
    // the length of the 2 strings and their nul bytes.
    //
    RequiredSpace = VersionNode->DataSize + ((NameLength + ValueLength) * sizeof(TCHAR));

    if(VersionNode->DataBlock) {
        NewDataBlock = MyTaggedRealloc((PVOID)(VersionNode->DataBlock), RequiredSpace, MEMTAG_VBDATA);
    } else {
        NewDataBlock = MyTaggedMalloc(RequiredSpace, MEMTAG_VBDATA);
    }

    if(!NewDataBlock) {
        return FALSE;
    }

    //
    // Place the datum name in the version block.
    //
    lstrcpy((PTSTR)((PUCHAR)NewDataBlock + VersionNode->DataSize), DatumName);
    VersionNode->DataSize += NameLength * sizeof(TCHAR);

    //
    // Place the datum value in the version block.
    //
    lstrcpy((PTSTR)((PUCHAR)NewDataBlock + VersionNode->DataSize), DatumValue);
    VersionNode->DataSize += ValueLength * sizeof(TCHAR);

    VersionNode->DatumCount++;

    VersionNode->DataBlock = NewDataBlock;

    return TRUE;
}


DWORD
ProcessNewInfVersionBlock(
    IN PLOADED_INF Inf
    )

/*++

Routine Description:

    Set up a version node for a new-style inf file. The version node is
    simply a mirror of the [Version] section in the file.

    Since this routine is only called at INF load time, no locking is done.
    Also, since we are guaranteed that this will operate on a single INF
    only, we don't have to worry about traversing a linked list of INFs.

Arguments:

    Inf - supplies a pointer to the inf descriptor for the file.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

--*/

{
    PINF_SECTION Section;
    PINF_LINE Line;
    UINT u;
    BOOL b;

    //
    // Locate the [Version] section.
    //
    if(Section = InfLocateSection(Inf, pszVersion, NULL)) {
        //
        // Iterate each line in the section. If the line has a key and at least one
        // other value, then it counts as a version datum. Otherwise ignore it.
        //
        for(u = 0, Line = &Inf->LineBlock[Section->Lines];
            u < Section->LineCount;
            u++, Line++)
        {
            if(HASKEY(Line)) {

                MYASSERT(Line->ValueCount > 2);

                //
                // Use the case-sensitive key name.
                //
                b = AddDatumToVersionBlock(
                        &(Inf->VersionBlock),
                        pStringTableStringFromId(Inf->StringTable, Inf->ValueBlock[Line->Values+1]),
                        pStringTableStringFromId(Inf->StringTable, Inf->ValueBlock[Line->Values+2])
                        );

                if(!b) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
    }
    return NO_ERROR;
}


DWORD
CreateInfVersionNode(
    IN PLOADED_INF Inf,
    IN PCTSTR      Filename,
    IN PFILETIME   LastWriteTime
    )

/*++

Routine Description:

    Set up a version node for an inf file, and link it into the list of INFs for
    the specified LOADED_INF structure.
    THIS ROUTINE ASSUMES THAT THE VERSION BLOCK STRUCTURE IN THE INF HAS BEEN
    ZEROED OUT.

Arguments:

    Inf - supplies pointer to descriptor for loaded inf file.

    Filename - supplies (fully-qualified) filename used to load inf file.

    LastWriteTime - supplies a pointer to a FILETIME structure specifying
        the time that the INF was last written to.

Return Value:

    Win32 error code (with inf extensions) indicating outcome.

--*/

{
    MYASSERT(!(Inf->VersionBlock.DataBlock));
    MYASSERT(!(Inf->VersionBlock.DataSize));
    MYASSERT(!(Inf->VersionBlock.DatumCount));

    //
    // Fill in the filename and other fields in the version descriptor.
    //
    Inf->VersionBlock.LastWriteTime = *LastWriteTime;

    Inf->VersionBlock.FilenameSize = (lstrlen(Filename) + 1) * sizeof(TCHAR);

    CopyMemory(Inf->VersionBlock.Filename, Filename, Inf->VersionBlock.FilenameSize);

    //
    // Style-specific processing.
    //
    return((Inf->Style == INF_STYLE_WIN4) ? ProcessNewInfVersionBlock(Inf)
                                          : ProcessOldInfVersionBlock(Inf));
}


/////////////////////////////////////////////
//
// Inf data access functions
//
/////////////////////////////////////////////

#ifdef UNICODE

BOOL
WINAPI
SetupEnumInfSectionsA (
    IN  HINF        InfHandle,
    IN  UINT        Index,
    OUT PSTR        Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )
/*++

Routine Description:
    See SetupEnumInfSections
    Ansi Wrapper

--*/
{
    UINT UniSize;
    UINT AnsiSize;
    BOOL f;
    PWSTR UniBuffer;
    PSTR AnsiBuffer;
    DWORD rc;

    f = SetupEnumInfSectionsW(InfHandle,Index,NULL,0,&UniSize);
    if(!f) {
        return FALSE;
    }
    UniBuffer = (PWSTR)MyMalloc(UniSize*sizeof(WCHAR));
    if(!UniBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    f = SetupEnumInfSectionsW(InfHandle,Index,UniBuffer,UniSize,NULL);
    if(!f) {
        rc = GetLastError();
        MYASSERT(f);
        MyFree(UniBuffer);
        SetLastError(rc);
        return FALSE;
    }
    AnsiBuffer = pSetupUnicodeToAnsi(UniBuffer);
    MyFree(UniBuffer);
    if(!AnsiBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    AnsiSize = strlen(AnsiBuffer)+1;
    try {
        if(SizeNeeded) {
            *SizeNeeded = AnsiSize;
        }
        if (Buffer) {
            if(Size<AnsiSize) {
                rc = ERROR_INSUFFICIENT_BUFFER;
            } else {
                strcpy(Buffer,AnsiBuffer);
                rc = NO_ERROR;
            }
        } else if(Size) {
            rc = ERROR_INVALID_USER_BUFFER;
        } else {
            rc = NO_ERROR;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_DATA;
    }
    MyFree(AnsiBuffer);
    SetLastError(rc);
    return (rc == NO_ERROR);
}

#else

BOOL
WINAPI
SetupEnumInfSectionsW (
    IN  HINF        InfHandle,
    IN  UINT        Index,
    OUT PWSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )
/*++

Routine Description:
    See SetupEnumInfSections
    Unicode Stub for ANSI SetupAPI

--*/
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(Size);
    UNREFERENCED_PARAMETER(SizeNeeded);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif

BOOL
WINAPI
SetupEnumInfSections (
    IN  HINF        InfHandle,
    IN  UINT        Index,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )
/*++

Routine Description:

    Enumerate Sections of a single INF (ignoring any attached INF's)
    Start with Index==0 and keep incrementing Index until ERROR_NO_MORE_ITEMS
    is returned.

    section name is copied into Buffer.

Arguments:

    InfHandle - Specifies the handle to an open INF file

    Index - enumeration index, not related to order sections are in INF

    Buffer - Receives a single section name

    Size - Specifies the size of Buffer, in characters

    SizeNeeded - Receives the size of Buffer needed, in characters

Return Value:

    TRUE if the function succeeds, or FALSE if not.

--*/
{
    DWORD rc = NO_ERROR;
    LPTSTR section;
    UINT actsz;
    PLOADED_INF pInf = (PLOADED_INF)InfHandle;

    try {
        if(!LockInf(pInf)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_HANDLE;
    }

    if (rc != NO_ERROR) {
        SetLastError (rc);
        return FALSE;
    }

    try {
        if(Index >= pInf->SectionCount) {
            rc = ERROR_NO_MORE_ITEMS;
            leave;
        }
        section = pStringTableStringFromId(pInf->StringTable, pInf->SectionBlock[Index].SectionName);
        if(section == NULL) {
            MYASSERT(section);
            rc = ERROR_INVALID_DATA;
            leave;
        }
        actsz = lstrlen(section)+1;
        if(SizeNeeded) {
            *SizeNeeded = actsz;
        }
        if (Buffer) {
            if(Size<actsz) {
                rc = ERROR_INSUFFICIENT_BUFFER;
            } else {
                _tcscpy(Buffer,section);
                rc = NO_ERROR;
            }
        } else if(Size) {
            rc = ERROR_INVALID_USER_BUFFER;
        } else {
            rc = NO_ERROR;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_DATA;
    }
    UnlockInf(pInf);
    SetLastError(rc);
    return (rc == NO_ERROR);
}


//
// NTRAID#207847-JamieHun-2000/10/19 Fix users of (p)SetupGetInfSections
//
// pSectionEnumWorker and pSetupGetInfSections are busted implementations
// of obtaining a list of INF sections
//
// we have to leave them in until all internal tools get updated
//
VOID
pSectionEnumWorker (
    IN      PCTSTR String,
    IN OUT  PSECTION_ENUM_PARAMS Params
    )

/*++

Routine Description:

    Callback that receives each section name.  It copies the string
    to a supplied buffer (if available), and also keeps track of the
    total size regardless if a buffer was supplied.

Arguments:

    String - Specifies the section name

    Params - Specifies a pointer to a SECTION_ENUM_PARAMS structure.
             Receives the section appended to the supplied buffer (if
             necessary) and an updated total buffer size.

Return Value:

    Always TRUE.

--*/

{
    UINT Size;

    if (!String) {
        MYASSERT(FALSE);
        return;
    }

    Size = (UINT)((PBYTE) _tcschr (String, 0) - (PBYTE) String) + sizeof(TCHAR);

    Params->SizeNeeded += Size;
    if (Params->Size > Params->SizeNeeded) {
        if (Params->Buffer) {
            _tcscpy (Params->End, String);
            Params->End = _tcschr (Params->End, 0);
            Params->End++;
        }
    }
}

BOOL
pSetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    )

/*++

Routine Description:

    Make a multi-sz list of section names by enumerating the section
    string table and copying them into a caller-supplied buffer.
    Caller can also request the size needed without supplying a
    buffer.

    This function was implemented for the Win9x upgrade and is NOT
    exposed as a public API nor an ANSI version.

Arguments:

    Inf - Specifies the handle to an open INF file

    Buffer - Receives a multi-sz list of section names

    Size - Specifies the size of Buffer, in bytes

    SizeNeeded - Receives the size of Buffer needed, in bytes

Return Value:

    TRUE if the function succeeds, or FALSE if not.

--*/

{
    PLOADED_INF Inf;
    DWORD rc = NO_ERROR;
    SECTION_ENUM_PARAMS Params;
    PBYTE p;
    PINF_SECTION Section;
    UINT u;

    //
    // Init the enum worker params
    //

    Params.Buffer = Buffer;
    Params.Size = Buffer ? Size : 0;
    Params.SizeNeeded = 0;
    Params.End = Buffer;

    //
    // Validate buffer arg
    //

    try {
        if (Buffer) {
            p = (PBYTE) Buffer;
            p[0] = 0;
            p[Size - 1] = 0;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if (rc != NO_ERROR) {
        SetLastError (rc);
        return FALSE;
    }

    //
    // Lock the INF
    //

    try {
        if(!LockInf((PLOADED_INF)InfHandle)) {
            rc = ERROR_INVALID_HANDLE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Assume InfHandle was bad pointer
        //
        rc = ERROR_INVALID_HANDLE;
    }

    if (rc != NO_ERROR) {
        SetLastError (rc);
        return FALSE;
    }

    //
    // Traverse the linked list of loaded INFs, enumerating each INF's
    // sections.
    //
    try {
        for(Inf = (PLOADED_INF)InfHandle; Inf; Inf = Inf->Next) {
            //
            // Enumerate the sections
            //

            for(u=0,Section=Inf->SectionBlock; u<Inf->SectionCount; u++,Section++) {
                pSectionEnumWorker (
                    pStringTableStringFromId (Inf->StringTable, Section->SectionName),
                    &Params
                    );
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    //
    // Update the structure and OUT params for the last time
    //

    try {
        if (rc == NO_ERROR) {
            Params.SizeNeeded += sizeof(TCHAR);

            if (SizeNeeded) {
                *SizeNeeded = Params.SizeNeeded;
            }

            if (Params.Buffer && Params.Size >= Params.SizeNeeded) {
                *Params.End = 0;
            } else if (Params.Buffer) {
                rc = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    //
    // Unlock the INF
    //

    UnlockInf((PLOADED_INF)InfHandle);

    return rc == NO_ERROR;
}


PINF_SECTION
InfLocateSection(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    OUT PUINT       SectionNumber   OPTIONAL
    )

/*++

Routine Description:

    Locate a section within an inf file.  This routine DOES NOT traverse a
    linked list of INFs, looking for the section in each.

    THIS ROUTINE DOES NOT LOCK THE INF--THE CALLER MUST HANDLE IT!!!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    SectionName - Supplies the name of the section to be located.

    SectionNumber - if specified, receives the ordinal number of
        the section.

Return Value:

    Pointer to the section descriptor, or NULL if the section
    does not exist.

--*/

{
    LONG StringId;
    PINF_SECTION Section;
    UINT u;
    DWORD StringLength;
    TCHAR TempString[MAX_SECT_NAME_LEN];

    //
    // Make a copy of the SectionName into a modifiable buffer to speed
    // the lookup.
    //
    lstrcpyn(TempString, SectionName, SIZECHARS(TempString));

    //
    // Start from the beginning.
    //
    StringId = pStringTableLookUpString(Inf->StringTable,
                                        TempString,
                                        &StringLength,
                                        NULL,
                                        NULL,
                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                        NULL,0
                                       );
    if(StringId == -1) {
        return(NULL);
    }

    for(u=0,Section=Inf->SectionBlock; u<Inf->SectionCount; u++,Section++) {
        if(Section->SectionName == StringId) {
            if(SectionNumber) {
                *SectionNumber = u;
            }
            return(Section);
        }
    }

    return(NULL);
}


BOOL
InfLocateLine(
    IN     PLOADED_INF   Inf,
    IN     PINF_SECTION  Section,
    IN     PCTSTR        Key,        OPTIONAL
    IN OUT PUINT         LineNumber,
    OUT    PINF_LINE    *Line
    )

/*++

Routine Description:

    Locate a line within a section.  This routine DOES NOT traverse a
    linked list of INFs, looking for the section in each.

    THIS ROUTINE DOES NOT LOCK THE INF--THE CALLER MUST HANDLE IT!!!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    SectionName - Supplies a pointer to the section descriptor for the section
        to be searched.

    Key - if specified, supplies the key of the line to look for.

    LineNumber - on input, supplies the line number of the line where the
        search is to begin. On output, receives the line number of the
        line where the match was found

    Line - receives a pointer to the line descriptor for the line
        where the match was found.

Return Value:

    TRUE if line is found, FALSE otherwise.

--*/

{
    PINF_LINE line;
    UINT u;
    LONG StringId;
    DWORD StringLength;
    TCHAR TempString[MAX_STRING_LENGTH];

    if(Key) {
        //
        // Copy the key name into a modifiable buffer to speed up the string table API.
        //
        lstrcpyn(TempString, Key, SIZECHARS(TempString));
        StringId = pStringTableLookUpString(Inf->StringTable,
                                            TempString,
                                            &StringLength,
                                            NULL,
                                            NULL,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                            NULL,0
                                           );
        if(StringId == -1) {
            return FALSE;
        }

        for(u = *LineNumber, line = &Inf->LineBlock[Section->Lines + (*LineNumber)];
            u < Section->LineCount;
            u++, line++)
        {
            if(ISSEARCHABLE(line) && (Inf->ValueBlock[line->Values] == StringId)) {
                *Line = line;
                *LineNumber = u;
                return TRUE;
            }
        }
    } else {
        if(*LineNumber < Section->LineCount) {
            *Line = &Inf->LineBlock[Section->Lines + (*LineNumber)];
            return TRUE;
        }
    }

    return FALSE;
}


PTSTR
InfGetField(
    IN  PLOADED_INF Inf,
    IN  PINF_LINE   InfLine,
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    )

/*++

Routine Description:

    Retrieve the key or a value from a specified line in an inf file.

    THIS ROUTINE DOES NOT DO LOCKING!!!

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    InfLine - supplies a pointer to the line descriptor for the line
        from which the value is to be fetched.  THIS LINE MUST BE CONTAINED
        WITHIN THE SPECIFIED INF!!

    ValueNumber - supplies the index for the value to retreive. If a line has a key,
        the key is value #0 and other values start at 1. If a line does not have a
        key, values start at 1.  For Win95 INF compatibility, if there's only a single
        value on the line (i.e., no '=' to denote it as a key), we'll consider it to
        be both a key and the first value (either 0 or 1 will work).

    StringId - if specified, receives the string table id of the value.

Return Value:

    Pointer to the value, or NULL if not found. The caller must not write into
    or otherwise alter this string.

--*/

{
    LONG stringId;
    PTSTR ret = NULL;

    //
    // Adjust the value number.
    //
    if(HASKEY(InfLine)) {
        //
        // All field references are shifted up by one, to account for the two
        // copies of the key (first is case insensative)
        //
        ValueNumber++;
        if(ValueNumber==0) {
            //
            // wrap
            //
            return NULL;
        }

    } else {

        if(ISSEARCHABLE(InfLine)) {
            //
            // lines that consist of one value "VaLue" are treated like "value=VaLue"
            // this is such a line, and is recognized because HASKEY is FALSE but
            // ISSEARCHABLE is TRUE
            //
            // We want to return the second of the two, since it's the one that was
            // stored case-sensitively.
            //
            if(ValueNumber > 1) {
                return NULL;
            } else {
                ValueNumber = 1;
            }

        } else {
            //
            // This line is not searchable, so asking for value #0 is an error.
            //
            if(ValueNumber) {
                ValueNumber--;
            } else {
                return NULL;
            }
        }
    }

    //
    // Get the value.
    //
    if(ValueNumber < InfLine->ValueCount) {

        stringId = Inf->ValueBlock[InfLine->Values+ValueNumber];

        if(StringId) {
            *StringId = stringId;
        }

        return pStringTableStringFromId(Inf->StringTable, stringId);
    }

    return NULL;
}


PTSTR
InfGetKeyOrValue(
    IN  PLOADED_INF Inf,
    IN  PCTSTR      SectionName,
    IN  PCTSTR      LineKey,     OPTIONAL
    IN  UINT        LineNumber,  OPTIONAL
    IN  UINT        ValueNumber,
    OUT PLONG       StringId     OPTIONAL
    )

/*++

Routine Description:

    Retrieve the key or a value from a specified line in an inf file.

Arguments:

    Inf - supplies a pointer to the inf descriptor for the loaded inf file.

    SectionName - supplies the name of the section where the value is located.

    LineKey - if specified, supplies the key name for the line where the
        value is located. If not specified, LineNumber is used instead.

    LineNumber - if LineKey is not specified, supplies the 0-based line number
        within the section where the value is located.

    ValueNumber - supplies the index for the value to retreive. If a line has a key,
        the key is value #0 and other values start at 1. If a line does not have a
        key, values start at 1.

    StringId - if specified, receives the string table id of the value.

Return Value:

    Pointer to the value, or NULL if not found. The caller must not write into
    or otherwise alter this string.

--*/

{
    INFCONTEXT InfContext;
    PINF_LINE Line;
    PTSTR String;

    if(LineKey) {
        if(!SetupFindFirstLine((HINF)Inf, SectionName, LineKey, &InfContext)) {
            return NULL;
        }
    } else {
        if(!SetupGetLineByIndex((HINF)Inf, SectionName, LineNumber, &InfContext)) {
            return NULL;
        }
    }

    Line = InfLineFromContext(&InfContext);

    //
    // The above routines do their own locking.  The following routine, however, does
    // not, so we must lock the INF before preceding.
    //
    if(LockInf(Inf)) {
        String = InfGetField(Inf, Line, ValueNumber, StringId);
        UnlockInf(Inf);
    } else {
        String = NULL;
    }

    return String;
}

PVOID
InitializeStringTableFromPNF(
    IN PPNF_HEADER PnfHeader,
    IN LCID        Locale
    )
{
    PVOID StringTable = NULL;

    try {

        StringTable = InitializeStringTableFromMemoryMappedFile(
                            (PUCHAR)PnfHeader + PnfHeader->StringTableBlockOffset,
                            PnfHeader->StringTableBlockSize,
                            Locale,
                            0
                            );

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    return StringTable;
}

BOOL
LoadPrecompiledInf(
    IN  PCTSTR       Filename,
    IN  PFILETIME    LastWriteTime,
    IN  PCTSTR       OsLoaderPath,                    OPTIONAL
    IN  DWORD        LanguageId,
    IN  DWORD        Flags,
    IN  PSETUP_LOG_CONTEXT LogContext,                OPTIONAL
    OUT PLOADED_INF *Inf,
    OUT PTSTR       *InfSourcePathToMigrate,          OPTIONAL
    OUT PDWORD       InfSourcePathToMigrateMediaType, OPTIONAL
    OUT PTSTR       *InfOriginalNameToMigrate         OPTIONAL
    )
/*++

Routine Description:

    This routine attempts to find a .PNF (Precompiled iNF) file corresponding to
    the specified .INF name.  If located, the .PNF is mapped into memory as a
    LOADED_INF.  To ensure that the INF hasn't changed since being compiled, the
    INF's LastWriteTime, as stored in the .PNF's version block, is checked against
    the LastWriteTime passed into this routine.  If the two are different, then the
    .PNF is out-of-sync, and is discarded from memory and deleted from the disk.

Arguments:

    Filename - supplies the name of the INF file whose precompiled form is to be loaded.
        This should be a fully qualified path (i.e., as returned by GetFullPathName).

    LastWriteTime - supplies the last-write time for the INF.

    OsLoaderPath - optionally, supplies path of the current OsLoader directory
        (e.g., "C:\os\winnt40").  If the specified PNF contains references to
        the system partition, then its stored OsLoaderPath must match this path
        in order for the PNF to be valid.  If this parameter is not specified,
        the OsLoader path is dynamically retrieved for comparison (unless the
        LDINF_FLAG_IGNORE_VOLATILE_DIRIDS flag is specified).

    LanguageId - supplies the language ID that must match the language ID stored in the
        PNF in order for the PNF to be used (ignored if LDINF_FLAG_IGNORE_LANGUAGE is
        specified).

    Flags - supplies flags that modify the behavior of this routine.  The following
        flags are currently recognized:

        LDINF_FLAG_IGNORE_VOLATILE_DIRIDS - If specified, then no validation
            will be done on the stored OsLoaderPath present in the PNF.  Since
            dynamically retrieving the current path is time consuming, this
            flag should be specified as an optimization if it is known that the
            relevant DIRIDs are not going to be needed.

        LDINF_FLAG_IGNORE_LANGUAGE - If specified, then no validation will be done on
            the language ID stored in the PNF.  This flag should only be used if no data
            is to be retrieved from the INF (e.g., if we're just interested in finding
            out if this is an old- or new-style INF).

    LogContext - if supplied, is a log context to be inherited

    Inf - supplies the address of the variable that receives the LOADED_INF pointer,
        if a valid .PNF is located.

    InfSourcePathToMigrate - Optionally, supplies the address of a string pointer
        that receives the address of a newly-allocated string buffer containing
        the source path associated with the INF's PNF that, while valid, was
        discarded because of a change in one of the stored system parameters
        (e.g., OS loader path, windir path, language ID).  This parameter will
        only be filled in upon unsuccessful return.  The type of path returned
        is dependent upon the value received by the InfSourcePathToMigrateMediaType
        argument, described below.  ** THE CALLER MUST FREE THIS STRING **

    InfSourcePathToMigrateMediaType - Optionally, supplies the address of a
        variable that will be set whenever InfSourcePathToMigrate is returned.
        This value indicates the type of source path we're talking about.  It
        can be one of the following values:

        SPOST_PATH - InfSourcePathToMigrate is a pointer to a standard file path

        SPOST_URL - If InfSourcePathToMigrate is NULL, then this INF came from
            the Windows Update (aka, Code Download Manager) website.  Otherwise,
            InfSourcePathToMigrate indicates the URL where the INF came from.

    InfOriginalNameToMigrate - Optionally, supplies the address of a string pointer
        that receives the address of a newly-allocated string buffer containing
        the original name of the associated INF (sans path).  Like  the
        InfSourcePathToMigrate and InfSourcePathToMigrateMediaType arguments
        described above, this argument is only filled in upon unsuccessful return
        for a PNF that, while structurally sound, was invalid because of a system
        parameter mismatch.  ** THE CALLER MUST FREE THIS STRING **

Return Value:

    If the PNF was successfully loaded, the return value is TRUE, otherwise, it
    is FALSE.

--*/
{
    TCHAR CharBuffer[MAX_PATH];
    PTSTR PnfFileName, PnfFileExt;
    DWORD FileSize;
    HANDLE FileHandle, MappingHandle;
    PVOID BaseAddress;
    BOOL IsPnfFile = FALSE;
    BOOL TimeDateMatch = FALSE;
    PPNF_HEADER PnfHeader;
    PLOADED_INF NewInf;
    BOOL NeedToDestroyLock, MinorVer1FieldsAvailable;
    PBYTE PnfImageEnd;
    DWORD TempStringLen;
    DWORD err;

    //
    // Either InfSourcePathToMigrate, InfSourcePathToMigrateMediaType, and
    // InfOriginalNameToMigrate must all be specified, or none of them may be
    // specified.
    //
    MYASSERT((InfSourcePathToMigrate && InfSourcePathToMigrateMediaType && InfOriginalNameToMigrate) ||
             !(InfSourcePathToMigrate || InfSourcePathToMigrateMediaType || InfOriginalNameToMigrate));

    if(InfSourcePathToMigrate) {
        *InfSourcePathToMigrate = NULL;
        *InfSourcePathToMigrateMediaType = SPOST_NONE;
        *InfOriginalNameToMigrate = NULL;
    }

    lstrcpyn(CharBuffer, Filename, SIZECHARS(CharBuffer));

    //
    // Find the start of the filename component of the path, and then find the last
    // period (if one exists) in that filename.
    //
    PnfFileName = (PTSTR)pSetupGetFileTitle(CharBuffer);
    if(!(PnfFileExt = _tcsrchr(PnfFileName, TEXT('.')))) {
        PnfFileExt = CharBuffer + lstrlen(CharBuffer);
    }

    //
    // Now create a corresponding filename with the extension '.PNF'
    //
    lstrcpyn(PnfFileExt, pszPnfSuffix, SIZECHARS(CharBuffer) - (int)(PnfFileExt - CharBuffer));

    //
    // Attempt to open and map the file into memory.
    //
    if(pSetupOpenAndMapFileForRead(CharBuffer,
                             &FileSize,
                             &FileHandle,
                             &MappingHandle,
                             &BaseAddress) != NO_ERROR) {
        //
        // Couldn't open a .PNF file--bail now.
        //
        return FALSE;
    }

    NewInf = NULL;
    NeedToDestroyLock = FALSE;
    MinorVer1FieldsAvailable = TRUE;
    PnfImageEnd = (PBYTE)BaseAddress + FileSize;

    try {
        //
        // Now verify that this really is a precompiled INF (and that it's one we can use).
        // Then see if the LastWriteTime field in its version block agrees with the filetime
        // we were passed in.
        //
        PnfHeader = (PPNF_HEADER)BaseAddress;

        //
        // If we ever rev the major version, the logic below will need to change,
        // as we'll need to migrate the INF source path information over, thus
        // we can't bail so quickly.
        //
        MYASSERT(PNF_MAJOR_VERSION == 1);

        if(HIBYTE(PnfHeader->Version) != PNF_MAJOR_VERSION) {
            //
            // A major version mismatch means the PNF is unusable (see note above
            // about the need to migrate INF source path info in the future).
            //
            if(LogContext) {
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_VERSION_MAJOR_MISMATCH,
                              NULL,
                              PnfFileName,
                              PNF_MAJOR_VERSION,
                              HIBYTE(PnfHeader->Version)
                              );
            }
            goto clean0;
        }

        if(LOBYTE(PnfHeader->Version) != PNF_MINOR_VERSION) {

            if(LogContext) {
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_VERSION_MINOR_MISMATCH,
                              NULL,
                              PnfFileName,
                              PNF_MINOR_VERSION,
                              LOBYTE(PnfHeader->Version)
                              );
            }
            if(LOBYTE(PnfHeader->Version) < PNF_MINOR_VERSION) {
                //
                // We're currently at minor version 1.  PNFs having a minor
                // version of 1 differ from those having a minor version of 0
                // in the following ways:
                //
                // 1.  Minor version 1 PNFs store the LanguageId in which the
                //     INF was precompiled.  For Minor version 0 INFs, this field
                //     was initialized to zero.  This will cause our check for
                //     LanguageId match to fail, thus we'll consider the PNF
                //     invalid.
                //
                // 2.  Minor version 1 PNFs contain additional fields for
                //     InfSourcePathOffset and OriginalInfNameOffset.  This means
                //     that the PNF_HEADER struct got longer, thus we can only
                //     use these fields for minor version 1 or greater PNFs.
                //
                MinorVer1FieldsAvailable = FALSE;
            }

            //
            // (If the minor version of the PNF we're looking at is _greater_ than
            // the version we currently support, then we should attempt to use
            // this PNF, since all the fields that we care about should be right
            // where we expect them to be.)
            //
        }

        //
        // The version information checks out--now check the last-write times.
        // note that if we add any other consistancy checks to determine that this PNF
        // is associated with the INF
        // we must also modify simular tests for INF cache
        //
        TimeDateMatch = CompareFileTime(LastWriteTime, &(PnfHeader->InfVersionLastWriteTime))?FALSE:TRUE;

        if (!TimeDateMatch && !(Flags&LDINF_FLAG_ALWAYS_GET_SRCPATH)) {
            //
            // Time&Date don't match, and we're not interested in always getting source path
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_TIMEDATE_MISMATCH,
                          NULL,
                          PnfFileName
                          );
            goto clean0;
        }

#ifdef UNICODE
        if(!(PnfHeader->Flags & PNF_FLAG_IS_UNICODE))
#else
        if(PnfHeader->Flags & PNF_FLAG_IS_UNICODE)
#endif
        {
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_NATIVE,
                          NULL,
                          PnfFileName
                          );
            //
            // The APIs are Unicode while the PNF is ANSI, or vice versa.  We
            // still want to migrate the source path and original filename
            // information, if present, so that we preserve this information
            // across an upgrade from Win9x to NT, for example.
            //
            if(MinorVer1FieldsAvailable && InfSourcePathToMigrate) {
                //
                // First, retrieve the original INF name
                //
                if(PnfHeader->OriginalInfNameOffset) {
                    //
                    // Use strlen/wcslen so if an exception occurs it won't get
                    // swallowed...
                    //
#ifdef UNICODE
                    TempStringLen = strlen((PCSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset)) + 1;
                    TempStringLen *= sizeof(CHAR);
#else
                    TempStringLen = wcslen((PCWSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset)) + 1;
                    TempStringLen *= sizeof(WCHAR);
#endif
                    if(PnfImageEnd <
                           ((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset + TempStringLen))
                    {
                        goto clean0;
                    }

                    //
                    // Looks like we have a good original INF name string.  Now
                    // convert it to the native character width.
                    //
#ifdef UNICODE
                    *InfOriginalNameToMigrate =
                        pSetupMultiByteToUnicode((PCSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset),
                                           CP_ACP
                                          );
#else
                    *InfOriginalNameToMigrate =
                        pSetupUnicodeToMultiByte((PCWSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset),
                                           CP_ACP
                                          );
#endif
                    if(!*InfOriginalNameToMigrate) {
                        goto clean0;
                    }
                }

                //
                // Next, retrieve the source path information
                //
                if(PnfHeader->InfSourcePathOffset) {
#ifdef UNICODE
                    TempStringLen = strlen((PCSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset)) + 1;
                    TempStringLen *= sizeof(CHAR);
#else
                    TempStringLen = wcslen((PCWSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset)) + 1;
                    TempStringLen *= sizeof(WCHAR);
#endif
                    if(PnfImageEnd <
                           ((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset + TempStringLen))
                    {
                        goto clean0;
                    }

                    //
                    // Looks like we have a good source path string.  Now convert
                    // it to the native character width.
                    //
#ifdef UNICODE
                    *InfSourcePathToMigrate =
                        pSetupMultiByteToUnicode((PCSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset),
                                           CP_ACP
                                          );
#else
                    *InfSourcePathToMigrate =
                        pSetupUnicodeToMultiByte((PCWSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset),
                                           CP_ACP
                                          );
#endif
                    if(!*InfSourcePathToMigrate) {
                        goto clean0;
                    }

                    if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                        *InfSourcePathToMigrateMediaType = SPOST_URL;
                    } else {
                        *InfSourcePathToMigrateMediaType = SPOST_PATH;
                    }

                } else if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                    //
                    // No source path stored in the PNF, but the flag says it's
                    // a URL, thus it came from Windows Update.
                    //
                    *InfSourcePathToMigrateMediaType = SPOST_URL;
                }
            }

            goto clean0;
        }

        //
        // Make sure that the last data block is still within the file.  This
        // prevents us from opening up a corrupted (truncated) PNF, and thinking
        // it's valid until later when we actually try to access data at an
        // offset that's past the end of the file's mapped image.
        //
        if(PnfHeader->InfSubstValueCount) {

            if(PnfImageEnd <
                   ((PBYTE)BaseAddress + PnfHeader->InfSubstValueListOffset + (PnfHeader->InfSubstValueCount * sizeof(STRINGSUBST_NODE))))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }

        } else if(MinorVer1FieldsAvailable && (PnfHeader->OriginalInfNameOffset)) {
            //
            // Use _tcslen so if an exception occurs it won't get swallowed...
            //
            TempStringLen = _tcslen((PCTSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset)) + 1;

            if(PnfImageEnd <
                   ((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset + (TempStringLen * sizeof(TCHAR))))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }

        } else if(MinorVer1FieldsAvailable && (PnfHeader->InfSourcePathOffset)) {
            //
            // Use _tcslen so if an exception occurs it won't get swallowed...
            //
            TempStringLen = _tcslen((PCTSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset)) + 1;

            if(PnfImageEnd <
                   ((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset + (TempStringLen * sizeof(TCHAR))))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }

        } else {
            //
            // Well, we didn't have a substitution block or a source path block,
            // so the last block in the PNF is the value block.
            //
            if(PnfImageEnd <
                ((PBYTE)BaseAddress + PnfHeader->InfValueBlockOffset + PnfHeader->InfValueBlockSize))
            {
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_PNF_CORRUPTED,
                              NULL,
                              PnfFileName
                              );
                goto clean0;
            }
        }

        //
        // From this point forward, we appear to have a structurally sound PNF
        // of the appropriate version and character width.  Any failures
        // encountered should cause us to return the INF source path information
        // to the caller (if requested).
        //

        if (!TimeDateMatch) {
            MYASSERT(Flags&LDINF_FLAG_ALWAYS_GET_SRCPATH);
            //
            // Time&Date don't match, but we've recovered old media
            // we have to do this since on FAT/FAT32 the UT reported for a file
            // will change every time system TZ is changed.
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_INFO,
                          MSG_LOG_PNF_REBUILD_TIMEDATE_MISMATCH,
                          NULL,
                          PnfFileName
                          );
            goto clean1;
        }

        //
        // Make sure that the language ID that this PNF was compiled for matches
        // that of the current thread.
        //
        if(!(Flags & LDINF_FLAG_IGNORE_LANGUAGE) && ((DWORD)(PnfHeader->LanguageId) != LanguageId)) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_LANGUAGE_MISMATCH,
                          NULL,
                          PnfFileName,
                          LanguageId,
                          PnfHeader->LanguageId
                          );
            goto clean1;
        }

        //
        // Now verify that the Windows (and, optionally, OsLoader) directories
        // for this PNF match the current state of the world.
        //
        if(lstrcmpi((PCTSTR)((PBYTE)BaseAddress + PnfHeader->WinDirPathOffset), WindowsDirectory)) {
            //
            // This PNF doesn't match the current WindowsDirectory path, so don't
            // use it.
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_WINDIR_MISMATCH,
                          NULL,
                          PnfFileName,
                          WindowsDirectory,
                          (PCTSTR)((PBYTE)BaseAddress + PnfHeader->WinDirPathOffset)
                          );
            goto clean1;
        }
        if((PnfHeader->OsLoaderPathOffset) && !(Flags & LDINF_FLAG_IGNORE_VOLATILE_DIRIDS)) {
            //
            // This INF contains references to the system partition.  Verify that the path
            // used during precompilation is the one we're currently using.
            //
            if(!OsLoaderPath) {
                //
                // The caller didn't specify an OsLoaderPath, so we must dynamically retrieve this
                // value from the registry.
                //
                err = pSetupGetOsLoaderDriveAndPath(FALSE, CharBuffer, SIZECHARS(CharBuffer), NULL);
                if(err) {
                    WriteLogEntry(LogContext,
                                  SETUP_LOG_WARNING,
                                  MSG_LOG_PNF_REBUILD_OSLOADER_MISMATCH,
                                  NULL,
                                  PnfFileName,
                                  TEXT("?"),
                                  (PCTSTR)((PBYTE)BaseAddress + PnfHeader->OsLoaderPathOffset)
                                  );
                    goto clean1;
                }
                OsLoaderPath = CharBuffer;
            }

            if(lstrcmpi((PCTSTR)((PBYTE)BaseAddress + PnfHeader->OsLoaderPathOffset), OsLoaderPath)) {
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_REBUILD_OSLOADER_MISMATCH,
                              NULL,
                              PnfFileName,
                              OsLoaderPath,
                              (PCTSTR)((PBYTE)BaseAddress + PnfHeader->OsLoaderPathOffset)
                              );
                goto clean1;
            }
        }

        //
        // Make sure that we have verified whether this INF is digitally signed or not
        //
        if (!(PnfHeader->Flags & PNF_FLAG_INF_VERIFIED)) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_INFO,
                          MSG_LOG_PNF_REBUILD_UNVERIFIED,
                          NULL,
                          PnfFileName
                          );
            goto clean1;
        }
        //
        // Verify that the product suite flags match
        // this causes us to refresh the PNF's if there's any change in product
        // suite
        // if on NT, PNF_FLAG_16BIT_SUITE must be set and upper 16 bits contains
        // product suite
        // if not on NT, PNF_FLAG_16BIT_SUITE must NOT be set.
        //
        if(((OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) &&
                    (PnfHeader->Flags & PNF_FLAG_16BIT_SUITE)) ||
                   ((OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
                    (((PnfHeader->Flags & PNF_FLAG_16BIT_SUITE) == 0) ||
                    (((PnfHeader->Flags >> 16) & 0xffff) != OSVersionInfo.wSuiteMask)))) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_INFO,
                          MSG_LOG_PNF_REBUILD_SUITE,
                          NULL,
                          PnfFileName
                          );
            goto clean1;
        }

        //
        // One final check--make sure that the number of hash buckets used when precompiling
        // this INF matches what we expect.  (This wasn't rolled into the version check, since
        // this is something that is subject to lots of modification, and we didn't want to
        // rev the major version number each time.)
        //
        if(PnfHeader->StringTableHashBucketCount != HASH_BUCKET_COUNT) {
            WriteLogEntry(LogContext,
                          SETUP_LOG_WARNING,
                          MSG_LOG_PNF_REBUILD_HASH_MISMATCH,
                          NULL,
                          PnfFileName,
                          HASH_BUCKET_COUNT,
                          PnfHeader->StringTableHashBucketCount
                          );
            goto clean1;
        }

        //
        // We can use the file--now set up our top level structures.
        //
        if(NewInf = MyTaggedMalloc(sizeof(LOADED_INF),MEMTAG_INF)) {

            ZeroMemory(NewInf, sizeof(LOADED_INF));

            if(NewInf->StringTable = InitializeStringTableFromPNF(PnfHeader, (LCID)LanguageId)) {
                NewInf->LogContext = NULL;

                if(InheritLogContext(LogContext, &(NewInf->LogContext)) == NO_ERROR) {

                    if(InitializeSynchronizedAccess(&(NewInf->Lock))) {

                        NeedToDestroyLock = TRUE;

                        //
                        // All necessary resources were successfully allocated--now
                        // fill in the LOADED_INF fields
                        //
                        NewInf->Signature = LOADED_INF_SIG;

                        NewInf->FileHandle = FileHandle;
                        NewInf->MappingHandle = MappingHandle;
                        NewInf->ViewAddress = BaseAddress;

                        NewInf->SectionCount = PnfHeader->InfSectionCount;

                        NewInf->SectionBlockSizeBytes = PnfHeader->InfSectionBlockSize;
                        NewInf->SectionBlock = (PINF_SECTION)((PBYTE)BaseAddress +
                                                              PnfHeader->InfSectionBlockOffset);

                        NewInf->LineBlockSizeBytes = PnfHeader->InfLineBlockSize;
                        NewInf->LineBlock = (PINF_LINE)((PBYTE)BaseAddress +
                                                        PnfHeader->InfLineBlockOffset);

                        NewInf->ValueBlockSizeBytes = PnfHeader->InfValueBlockSize;
                        NewInf->ValueBlock = (PLONG)((PBYTE)BaseAddress +
                                                     PnfHeader->InfValueBlockOffset);

                        NewInf->Style = PnfHeader->InfStyle;

                        NewInf->HasStrings = (PnfHeader->Flags & PNF_FLAG_HAS_STRINGS);

                        if(PnfHeader->Flags & PNF_FLAG_HAS_VOLATILE_DIRIDS) {
                            NewInf->Flags |= LIF_HAS_VOLATILE_DIRIDS;
                        }

                        if (PnfHeader->Flags & PNF_FLAG_INF_DIGITALLY_SIGNED) {
                            NewInf->Flags |= LIF_INF_DIGITALLY_SIGNED;
                        }

                        if (PnfHeader->Flags & PNF_FLAG_OEM_F6_INF) {
                            NewInf->Flags |= LIF_OEM_F6_INF;
                        }

                        NewInf->LanguageId = (DWORD)(PnfHeader->LanguageId);

                        //
                        // Next, fill in the VersionBlock fields.
                        //
                        NewInf->VersionBlock.LastWriteTime = *LastWriteTime;
                        NewInf->VersionBlock.DatumCount = PnfHeader->InfVersionDatumCount;
                        NewInf->VersionBlock.DataSize = PnfHeader->InfVersionDataSize;
                        NewInf->VersionBlock.DataBlock = (PCTSTR)((PBYTE)BaseAddress +
                                                                  PnfHeader->InfVersionDataOffset);

                        NewInf->VersionBlock.FilenameSize = (lstrlen(Filename) + 1) * sizeof(TCHAR);
                        CopyMemory(NewInf->VersionBlock.Filename,
                                   Filename,
                                   NewInf->VersionBlock.FilenameSize
                                  );

                        //
                        // Fill in the OsLoaderPath field, if present in the PNF.
                        //
                        if(PnfHeader->OsLoaderPathOffset) {
                            NewInf->OsLoaderPath = (PCTSTR)((PBYTE)BaseAddress +
                                                             PnfHeader->OsLoaderPathOffset);
                        }

                        //
                        // If the INF's SourcePath is available, then use it (default
                        // to assuming local (i.e., non-internet) source location).
                        //
                        // At this point, we should only be dealing with minor version
                        // 1 or later PNFs.
                        //
                        MYASSERT(MinorVer1FieldsAvailable);

                        NewInf->InfSourceMediaType = SPOST_PATH;

                        if(PnfHeader->InfSourcePathOffset) {
                            NewInf->InfSourcePath = (PCTSTR)((PBYTE)BaseAddress +
                                                             PnfHeader->InfSourcePathOffset);
                        }

                        if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                            NewInf->InfSourceMediaType = SPOST_URL;
                        }

                        //
                        // Now retrieve the INF's original filename, if present.  If
                        // this field isn't present, then the INF's current filename
                        // is assumed to be the same as its original filename (e.g.,
                        // a system-supplied INF).
                        //
                        if(PnfHeader->OriginalInfNameOffset) {
                            NewInf->OriginalInfName = (PCTSTR)((PBYTE)BaseAddress +
                                                             PnfHeader->OriginalInfNameOffset);
                        }

                        //
                        // Finally, fill in the string substitution list (if there is one).
                        //
                        if(PnfHeader->InfSubstValueCount) {
                            NewInf->SubstValueCount = PnfHeader->InfSubstValueCount;
                            NewInf->SubstValueList  = (PSTRINGSUBST_NODE)((PBYTE)BaseAddress +
                                                                PnfHeader->InfSubstValueListOffset);
                        }

                        //
                        // We have successfully loaded the PNF.
                        //
                        IsPnfFile = TRUE;
                    }
                }
            }
        }

clean1:
        if(!IsPnfFile && InfSourcePathToMigrate && MinorVer1FieldsAvailable) {
            //
            // Actually, this is a good PNF, just one that we can't use.  The
            // caller has requested that we return the original INF source path
            // location and original INF filename, so that this information can
            // be migrated to the new PNF  that will be built to replace this
            // one.
            //
#ifndef ANSI_SETUPAPI
#ifdef _X86_
            MYASSERT(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
            if((Flags&LDINF_FLAG_ALWAYS_GET_SRCPATH) &&
               ((PnfHeader->Flags & PNF_FLAG_16BIT_SUITE) == 0) &&
               (PnfHeader->OriginalInfNameOffset == 0) &&
               (PnfHeader->InfSourcePathOffset == 0) &&
               !pSetupInfIsFromOemLocation(Filename,TRUE)) {
                PCTSTR title;
                PCTSTR p;
                PTSTR catname = NULL;
                PSP_ALTPLATFORM_INFO_V2 pPlatform = NULL;
                DWORD FixErr;
                //
                // if we're here
                // we may need to work around a Win2k-Gold bug
                //
                // the bug is that if the timezone is changed
                // Win2k looses OriginalInfNameOffset/InfSourcePathOffset
                // which causes the INF to appear as unsigned
                // when it's really signed
                //

                //
                // get file title, of form:
                // xxxx.INF
                //
                title = pSetupGetFileTitle(Filename);

                //
                // see if it's of form OEMxxxx.INF
                //
                p = title;
                if(_wcsnicmp(p,TEXT("OEM"),3)!=0) {
                    goto clean0;
                }
                p+=3;
                if(p[0] == TEXT('.')) {
                    //
                    // OEM.xxx (we're expecting a number before '.')
                    //
                    goto clean0;
                }
                while(p[0]>=TEXT('0')&&p[0]<=TEXT('9')) {
                    p++;
                }
                if((p-title) > 7) {
                    //
                    // we're expecting no more than 4 digits
                    //
                    goto clean0;
                }
                if(_wcsicmp(p,TEXT(".INF"))!=0) {
                    //
                    // not OEMnnnn.INF
                    //
                    goto clean0;
                }
                //
                // see if there's a catalog that shadows this INF
                //
                WriteLogEntry(LogContext,
                              SETUP_LOG_INFO,
                              MSG_LOG_PNF_WIN2KBUG,
                              NULL,
                              PnfFileName
                              );

                //
                // see if the INF has a catalog that validates it
                //
                if(!pSetupApplyExtension(title,pszCatSuffix,&catname)) {
                    //
                    // validate against any catalog
                    // this is safe since the INF will get checked
                    // again when saving as PNF
                    //
                    catname = NULL;
                }
                pPlatform = MyMalloc(sizeof(SP_ALTPLATFORM_INFO_V2));
                //
                // if pPlatform is NULL, we'll probably fail the other bits
                // too so bail.
                //
                if(!pPlatform) {
                    goto clean0;
                }
                ZeroMemory(pPlatform, sizeof(SP_ALTPLATFORM_INFO_V2));
                pPlatform->cbSize = sizeof(SP_ALTPLATFORM_INFO_V2);
                pPlatform->Platform = VER_PLATFORM_WIN32_NT;
                pPlatform->Flags = SP_ALTPLATFORM_FLAGS_VERSION_RANGE;
                pPlatform->MajorVersion = VER_PRODUCTMAJORVERSION;
                pPlatform->MinorVersion = VER_PRODUCTMINORVERSION;
                pPlatform->ProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
                pPlatform->FirstValidatedMajorVersion = 0;
                pPlatform->FirstValidatedMinorVersion = 0;
                FixErr = _VerifyFile(
                             LogContext,
                             NULL,           // no hCatAdmin to pass in
                             NULL,           // no hSDBDrvMain to pass in
                             catname,        // eg "OEMx.CAT"
                             NULL,0,         // we're not verifying against another catalog image
                             title,          // eg "mydisk.inf"
                             Filename,       // eg "....\OEMx.INF"
                             NULL,           // return: problem info
                             NULL,           // return: problem file
                             FALSE,          // has to be FALSE because we don't have full path
                             pPlatform,      // alt platform info
                             (VERIFY_FILE_IGNORE_SELFSIGNED
                              | VERIFY_FILE_USE_OEM_CATALOGS
                              | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                             NULL,           // return: catalog file, full path
                             NULL,           // return: number of catalogs considered
                             NULL,
                             NULL
                            );
                if(catname) {
                    MyFree(catname);
                }
                if(pPlatform) {
                    MyFree(pPlatform);
                }
                if(FixErr != NO_ERROR) {
                    //
                    // failed, don't fake any information
                    //
                    goto clean0;
                }

                //
                // at this point, pretend original name was "OEM.INF"
                // and that files are located in A:\
                // we'll see at the time the inf is parsed
                // if it's signed or not
                //
                *InfSourcePathToMigrate = DuplicateString(TEXT("A:\\"));
                if(!*InfSourcePathToMigrate) {
                    goto clean0;
                }
                *InfOriginalNameToMigrate = DuplicateString(TEXT("OEM.INF"));
                if(!*InfOriginalNameToMigrate) {
                    MyFree(*InfSourcePathToMigrate);
                    *InfSourcePathToMigrate = NULL;
                    goto clean0;
                }
                *InfSourcePathToMigrateMediaType = SPOST_PATH;
                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_PNF_WIN2KBUGFIX,
                              NULL,
                              PnfFileName
                              );

                goto clean0;
            }
#endif
#endif
            if(PnfHeader->OriginalInfNameOffset) {
                *InfOriginalNameToMigrate =
                    DuplicateString((PCTSTR)((PBYTE)BaseAddress + PnfHeader->OriginalInfNameOffset));

                if(!*InfOriginalNameToMigrate) {
                    goto clean0;
                }
            }

            if(PnfHeader->InfSourcePathOffset) {

                *InfSourcePathToMigrate =
                    DuplicateString((PCTSTR)((PBYTE)BaseAddress + PnfHeader->InfSourcePathOffset));

                if(!*InfSourcePathToMigrate) {
                    goto clean0;
                }

                if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                    *InfSourcePathToMigrateMediaType = SPOST_URL;
                } else {
                    *InfSourcePathToMigrateMediaType = SPOST_PATH;
                }

            } else if(PnfHeader->Flags & PNF_FLAG_SRCPATH_IS_URL) {
                //
                // No source path stored in the PNF, but the flag says it's
                // a URL, thus it came from Windows Update.
                //
                *InfSourcePathToMigrateMediaType = SPOST_URL;
            }
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Reference the NeedToDestroyLock flag here in the except clause, so that the
        // compiler won't try to re-order the code in such a way that the flag is unreliable.
        //
        NeedToDestroyLock = NeedToDestroyLock;
    }

    if(IsPnfFile) {
        *Inf = NewInf;
    } else {

        if(NewInf) {

            if(NeedToDestroyLock && LockInf(NewInf)) {
                DestroySynchronizedAccess(&(NewInf->Lock));
            }

            if(NewInf->StringTable) {
                pStringTableDestroy(NewInf->StringTable);
            }
            if(NewInf->LogContext) {
                DeleteLogContext(NewInf->LogContext);
            }

            MyTaggedFree(NewInf,MEMTAG_INF);
        }

        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
    }

    return IsPnfFile;
}


DWORD
SavePnf(
    IN PCTSTR      Filename,
    IN PLOADED_INF Inf
    )
/*++

Routine Description:

    This routine attempts to write to disk a precompiled form (.PNF file) of the
    specified loaded INF descriptor (from a .INF file).

Arguments:

    Filename - specifies the fully-qualified path to the .INF textfile from which
        this INF descriptor was loaded.  A corresponding file with a .PNF extension
        will be created to store the precompiled INF into.

    Inf - supplies the address of the loaded INF descriptor to be written to disk
        as a precompiled INF file.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the reason for
    failure.

--*/
{
    TCHAR PnfFilePath[MAX_PATH];
    PTSTR PnfFileName, PnfFileExt;
    HANDLE hFile;
    PNF_HEADER PnfHeader;
    DWORD Offset, BytesWritten, WinDirPathLen, SourcePathLen, OsLoaderPathLen;
    DWORD OriginalInfNameLen;
    PVOID StringTableDataBlock;
    DWORD Err;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform;

    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        //
        // To minimize our footprint in certain embedded scenarios, we refrain
        // from generating PNFs.  We also assume the INF is valid...
        //
        Inf->Flags |= LIF_INF_DIGITALLY_SIGNED;

        return NO_ERROR;
    }

    lstrcpyn(PnfFilePath, Filename,SIZECHARS(PnfFilePath));

    //
    // Find the start of the filename component of the path, and then find the last
    // period (if one exists) in that filename.
    //
    PnfFileName = (PTSTR)pSetupGetFileTitle(PnfFilePath);
    if(!(PnfFileExt = _tcsrchr(PnfFileName, TEXT('.')))) {
        PnfFileExt = PnfFilePath + lstrlen(PnfFilePath);
    }

    //
    // Now create a corresponding filename with the extension '.PNF'
    //
    lstrcpyn(PnfFileExt, pszPnfSuffix, SIZECHARS(PnfFilePath) - (int)(PnfFileExt - PnfFilePath));

    //
    // NOTE: If there's already a PNF for this INF, we're going to blow it away.
    // If we encounter a failure after successfully creating the file, we're going
    // to delete the partial PNF, and there'll be no rollback to restore the old
    // PNF.  This is OK because if CreateFile succeeds, then we know we're going
    // to be able to write out the PNF barring out-of-disk-space problems.  For
    // out-of-disk-space problems, there could be one of two causes:
    //
    // 1.  The INF associated with the old PNF has gotten bigger, hence the PNF
    //     has gotten bigger.  In this case, it's desirable that we blow away
    //     the old PNF because it's invalid for the INF anyway.
    //
    // 2.  The INF is the same, but something else has changed that caused us to
    //     need to regenerate the PNF (e.g., code page changed).  Given the
    //     present information stored in PNFs, such a change would not result in
    //     a significant size difference between the old and new PNFs.  Thus, if
    //     the old PNF fit in the available disk space, then so would the new
    //     one.  If this changes in the future (e.g., storing out a new PNF can
    //     result in substantially increasing its size), then we'll need to be
    //     careful about backing up the old PNF before attempting to write out
    //     the new one, in case we need to rollback.
    //

    hFile = CreateFile(PnfFilePath,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL
                      );

    if(hFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    //
    // Enclose the rest of the function in try/except, in case we hit an error while
    // writing to the file.
    //
    Err = NO_ERROR;
    ValidationPlatform = NULL;

    try {
        //
        // Initialize a PNF header structure to be written to the beginning of the file.
        //
        ZeroMemory(&PnfHeader, sizeof(PNF_HEADER));

        PnfHeader.InfStyle = Inf->Style;

#ifdef UNICODE
        PnfHeader.Flags = PNF_FLAG_IS_UNICODE;
#else
        PnfHeader.Flags = 0;
#endif
        if(Inf->HasStrings) {
            PnfHeader.Flags |= PNF_FLAG_HAS_STRINGS;
        }

        if(Inf->InfSourceMediaType == SPOST_URL) {
            PnfHeader.Flags |= PNF_FLAG_SRCPATH_IS_URL;
        }

        if(Inf->Flags & LIF_HAS_VOLATILE_DIRIDS) {
            PnfHeader.Flags |= PNF_FLAG_HAS_VOLATILE_DIRIDS;
        }

        if (Inf->Flags & LIF_OEM_F6_INF) {
            PnfHeader.Flags |= PNF_FLAG_OEM_F6_INF;
        }

        //
        // if this is NT, save product suite
        // this helps us, eg, catch migration from PER to PRO
        // so that we can refresh PNF's
        //
        if(OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
            PnfHeader.Flags |= (((DWORD)OSVersionInfo.wSuiteMask)<<16) | PNF_FLAG_16BIT_SUITE;
        }

        //
        // We can only verify the digital signature of an INF file
        // after the crypto DLLs have been registered.
        //
        if(!(GlobalSetupFlags & PSPGF_NO_VERIFY_INF)) {

            TCHAR CatalogName[MAX_PATH];
            TCHAR FullCatalogPath[MAX_PATH];
            PTSTR p;

            FullCatalogPath[0] = TEXT('\0');

            //
            // If this INF does not live in %windir%\inf, or specifies a
            // CatalogFile= entry, then we don't want to do global validataion.
            // In these cases, we want to validate against the CatalogFile=
            // catalog.
            //
            // Note that if there is no CatalogFile= then FullCatalogPath[0]
            // will still be set to TEXT('\0') which will cause us to do global
            // validataion.
            //
            if(pSetupGetCatalogFileValue(&(Inf->VersionBlock),
                                         CatalogName,
                                         SIZECHARS(CatalogName),
                                         NULL) &&
               (CatalogName[0] != TEXT('\0'))) {

                //
                // The INF specified a CatalogFile= entry.  If the INF is in
                // a 3rd-party location (i.e., not in %windir%\Inf, then we'll
                // use the full path to the catalog (it must be located in the
                // same directory as the INF).  If the INF is in %windir%\Inf,
                // then we will look for an installed catalog having the same
                // primary filename as the INF, with an extension of ".CAT".
                //
                if(pSetupInfIsFromOemLocation(Filename, TRUE)) {
                    //
                    // Construct full path to the catalog based on the location
                    // of the INF.
                    //
                    lstrcpyn(FullCatalogPath, Filename, SIZECHARS(FullCatalogPath));

                    p = (PTSTR)pSetupGetFileTitle(FullCatalogPath);

                    lstrcpyn(p,
                             CatalogName,
                             (int)(SIZECHARS(FullCatalogPath) - (p - FullCatalogPath))
                            );

                } else {
                    //
                    // Construct simple filename of catalog based on INF's name
                    // (with .CAT extension)
                    //
                    lstrcpyn(FullCatalogPath,
                             pSetupGetFileTitle(Filename),
                             SIZECHARS(FullCatalogPath)
                            );

                    p = _tcsrchr(FullCatalogPath, TEXT('.'));
                    if(!p) {
                        //
                        // Should never happen, but if our INF file has no
                        // extension, simply append ".CAT".
                        //
                        p = FullCatalogPath + lstrlen(FullCatalogPath);
                    }

                    lstrcpyn(p,
                             pszCatSuffix,
                             (int)(SIZECHARS(FullCatalogPath) - (p - FullCatalogPath))
                            );
                }
            }

            //
            // Check if the INF digitally signed
            //
            IsInfForDeviceInstall(NULL,
                                  NULL,
                                  Inf,
                                  NULL,
                                  &ValidationPlatform,
                                  NULL,
                                  NULL
                                 );

            if(NO_ERROR == _VerifyFile(
                               NULL,
                               NULL,
                               NULL,
                               (*FullCatalogPath ? FullCatalogPath : NULL),
                               NULL,
                               0,
                               (Inf->OriginalInfName
                                   ? Inf->OriginalInfName
                                   : pSetupGetFileTitle(Filename)),
                               Filename,
                               NULL,
                               NULL,
                               FALSE,
                               ValidationPlatform,
                               (VERIFY_FILE_IGNORE_SELFSIGNED
                                | VERIFY_FILE_USE_OEM_CATALOGS
                                | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                               NULL,
                               NULL,
                               NULL,
                               NULL)) {

                PnfHeader.Flags |= PNF_FLAG_INF_DIGITALLY_SIGNED;
                Inf->Flags |= LIF_INF_DIGITALLY_SIGNED;
            }

            PnfHeader.Flags |= PNF_FLAG_INF_VERIFIED;
        }

        PnfHeader.Version = MAKEWORD(PNF_MINOR_VERSION, PNF_MAJOR_VERSION);

        PnfHeader.StringTableHashBucketCount = HASH_BUCKET_COUNT;

        PnfHeader.LanguageId = (WORD)(Inf->LanguageId);

        //
        // The Windows directory path is the first data block after the header.
        //
        Offset = PNF_ALIGN_BLOCK(sizeof(PNF_HEADER));
        PnfHeader.WinDirPathOffset = Offset;
        WinDirPathLen = (lstrlen(WindowsDirectory) + 1) * sizeof(TCHAR);

        //
        // The (optional) OsLoader directory path is the second data block.
        //
        Offset += PNF_ALIGN_BLOCK(WinDirPathLen);
        if(Inf->OsLoaderPath) {
            PnfHeader.OsLoaderPathOffset = Offset;
            OsLoaderPathLen = (lstrlen(Inf->OsLoaderPath) + 1) * sizeof(TCHAR);
        } else {
            OsLoaderPathLen = 0;
        }

        //
        // The string table is the third data block...
        //
        Offset += PNF_ALIGN_BLOCK(OsLoaderPathLen);
        PnfHeader.StringTableBlockOffset = Offset;
        PnfHeader.StringTableBlockSize   = pStringTableGetDataBlock(Inf->StringTable, &StringTableDataBlock);

        //
        // Next comes the version block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.StringTableBlockSize);
        PnfHeader.InfVersionDataOffset    = Offset;
        PnfHeader.InfVersionDatumCount    = Inf->VersionBlock.DatumCount;
        PnfHeader.InfVersionDataSize      = Inf->VersionBlock.DataSize;
        PnfHeader.InfVersionLastWriteTime = Inf->VersionBlock.LastWriteTime;

        //
        // then, the section block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfVersionDataSize);
        PnfHeader.InfSectionBlockOffset = Offset;
        PnfHeader.InfSectionCount = Inf->SectionCount;
        PnfHeader.InfSectionBlockSize = Inf->SectionBlockSizeBytes;

        //
        // followed by the line block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfSectionBlockSize);
        PnfHeader.InfLineBlockOffset = Offset;
        PnfHeader.InfLineBlockSize = Inf->LineBlockSizeBytes;

        //
        // and the value block...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfLineBlockSize);
        PnfHeader.InfValueBlockOffset = Offset;
        PnfHeader.InfValueBlockSize = Inf->ValueBlockSizeBytes;

        //
        // then the INF source path (if there is one)...
        //
        Offset += PNF_ALIGN_BLOCK(PnfHeader.InfValueBlockSize);
        if(Inf->InfSourcePath) {
            PnfHeader.InfSourcePathOffset = Offset;
            SourcePathLen = (lstrlen(Inf->InfSourcePath) + 1) * sizeof(TCHAR);
            Offset += PNF_ALIGN_BLOCK(SourcePathLen);
        } else {
            PnfHeader.InfSourcePathOffset = 0;
        }

        //
        // followed by the original INF's filename (if supplied, this indicates
        // the INF originally had a different name prior to being copied into
        // the current location)...
        //
        if(Inf->OriginalInfName) {
            PnfHeader.OriginalInfNameOffset = Offset;
            OriginalInfNameLen = (lstrlen(Inf->OriginalInfName) + 1) * sizeof(TCHAR);
            Offset += PNF_ALIGN_BLOCK(OriginalInfNameLen);
        } else {
            PnfHeader.OriginalInfNameOffset = 0;
        }

        //
        // and finally, the string substitution block (if there is one).
        //
        if(PnfHeader.InfSubstValueCount = Inf->SubstValueCount) {
            PnfHeader.InfSubstValueListOffset = Offset;
        } else {
            PnfHeader.InfSubstValueListOffset = 0;
        }

        //
        // Now write out all the blocks.
        //
        Offset = 0;

        if(!WriteFile(hFile, &PnfHeader, sizeof(PnfHeader), &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == sizeof(PnfHeader));
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.WinDirPathOffset - Offset)) {
            Offset = PnfHeader.WinDirPathOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, WindowsDirectory, WinDirPathLen, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == WinDirPathLen);
        Offset += BytesWritten;

        if(Inf->OsLoaderPath) {

            if(AlignForNextBlock(hFile, PnfHeader.OsLoaderPathOffset - Offset)) {
                Offset = PnfHeader.OsLoaderPathOffset;
            } else {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile, Inf->OsLoaderPath, OsLoaderPathLen, &BytesWritten, NULL)) {
                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == OsLoaderPathLen);
            Offset += BytesWritten;
        }

        if(AlignForNextBlock(hFile, PnfHeader.StringTableBlockOffset - Offset)) {
            Offset = PnfHeader.StringTableBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, StringTableDataBlock, PnfHeader.StringTableBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.StringTableBlockSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfVersionDataOffset - Offset)) {
            Offset = PnfHeader.InfVersionDataOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->VersionBlock.DataBlock, PnfHeader.InfVersionDataSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfVersionDataSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfSectionBlockOffset - Offset)) {
            Offset = PnfHeader.InfSectionBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->SectionBlock, PnfHeader.InfSectionBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfSectionBlockSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfLineBlockOffset - Offset)) {
            Offset = PnfHeader.InfLineBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->LineBlock, PnfHeader.InfLineBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfLineBlockSize);
        Offset += BytesWritten;

        if(AlignForNextBlock(hFile, PnfHeader.InfValueBlockOffset - Offset)) {
            Offset = PnfHeader.InfValueBlockOffset;
        } else {
            Err = GetLastError();
            goto clean0;
        }

        if(!WriteFile(hFile, Inf->ValueBlock, PnfHeader.InfValueBlockSize, &BytesWritten, NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        MYASSERT(BytesWritten == PnfHeader.InfValueBlockSize);
        Offset += BytesWritten;

        if(Inf->InfSourcePath) {

            if(AlignForNextBlock(hFile, PnfHeader.InfSourcePathOffset - Offset)) {
                Offset = PnfHeader.InfSourcePathOffset;
            } else {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile, Inf->InfSourcePath, SourcePathLen, &BytesWritten, NULL)) {
                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == SourcePathLen);
            Offset += BytesWritten;
        }

        if(Inf->OriginalInfName) {

            if(AlignForNextBlock(hFile, PnfHeader.OriginalInfNameOffset - Offset)) {
                Offset = PnfHeader.OriginalInfNameOffset;
            } else {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile, Inf->OriginalInfName, OriginalInfNameLen, &BytesWritten, NULL)) {
                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == OriginalInfNameLen);
            Offset += BytesWritten;
        }

        if(PnfHeader.InfSubstValueCount) {

            if(!AlignForNextBlock(hFile, PnfHeader.InfSubstValueListOffset - Offset)) {
                Err = GetLastError();
                goto clean0;
            }

            if(!WriteFile(hFile,
                          Inf->SubstValueList,
                          PnfHeader.InfSubstValueCount * sizeof(STRINGSUBST_NODE),
                          &BytesWritten,
                          NULL)) {

                Err = GetLastError();
                goto clean0;
            }

            MYASSERT(BytesWritten == PnfHeader.InfSubstValueCount * sizeof(STRINGSUBST_NODE));
        }

clean0: ; // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_DATA;
    }

    CloseHandle(hFile);

    if(ValidationPlatform) {
        MyFree(ValidationPlatform);
    }

    if(Err != NO_ERROR) {
        //
        // Something went wrong--get rid of the file.
        //
        DeleteFile(PnfFilePath);
    }

    return Err;
}


BOOL
AddUnresolvedSubstToList(
    IN PLOADED_INF Inf,
    IN UINT        ValueOffset,
    IN BOOL        CaseSensitive
    )
/*++

Routine Description:

    This routine adds a new STRINGSUBST_NODE to the array stored in the specified INF.
    The entries in this array are used later to quickly locate all values that have
    unresolved string substitutions in them (i.e., for subsequent user-defined DIRID
    replacement).

Arguments:

    Inf - Specifies the INF containing the string value to be added to the unresolved
        substitutions list.

    ValueOffset - Specifies the offset within the INF's value block of the unresolved
        string value.

Return Value:

    If the new element was successfully added to the array, the return value is TRUE.
    If the routine failed (due to an out-of-memory error), the return value is FALSE.

--*/
{
    PSTRINGSUBST_NODE p;

    //
    // Grow the array to accommodate the new element.
    //
    if(Inf->SubstValueList) {
        p = MyRealloc(Inf->SubstValueList, (Inf->SubstValueCount + 1) * sizeof(STRINGSUBST_NODE));
    } else {
        MYASSERT(!(Inf->SubstValueCount));
        p = MyMalloc(sizeof(STRINGSUBST_NODE));
    }

    if(!p) {
        return FALSE;
    }

    //
    // Now, we must check to see if the ValueOffset currently being inserted is the same
    // as the entry on the end of the list.  This will be the case if we're dealing with
    // a line key, or a single-value line, since we first add the value case-sensitively,
    // then add the value again case-insensitively for look-up, and insert it in front
    // of the case-sensitive form.
    //
    if(Inf->SubstValueCount &&
       (ValueOffset == p[Inf->SubstValueCount - 1].ValueOffset)) {
        //
        // The value offsets are the same.  Increment the value offset for the value
        // currently at the end of the list, before adding the new value.
        //
        p[Inf->SubstValueCount - 1].ValueOffset++;
    }

    p[Inf->SubstValueCount].ValueOffset = ValueOffset;
    p[Inf->SubstValueCount].TemplateStringId = Inf->ValueBlock[ValueOffset];
    p[Inf->SubstValueCount].CaseSensitive = CaseSensitive;

    //
    // Store the new array size and pointer back in the INF, and return success.
    //
    Inf->SubstValueList = p;
    Inf->SubstValueCount++;

    return TRUE;
}


DWORD
ApplyNewVolatileDirIdsToInfs(
    IN PLOADED_INF MasterInf,
    IN PLOADED_INF Inf        OPTIONAL
    )
/*++

Routine Description:

    This routine processes either a single INF, or each loaded INF in the
    linked list, applying volatile system or user-defined DIRID mappings to each
    value containing unresolved string substitutions.

    THIS ROUTINE DOES NOT DO INF LOCKING--CALLER MUST DO IT!

Arguments:

    MasterInf - Supplies a pointer to the head of a linked list of loaded inf
        structures.  This 'master' node contains the user-defined DIRID
        mappings for this set of INFs.  If the 'Inf' parameter is not specified,
        then each INF in this linked list is processed.

    Inf - Optionally, supplies a pointer to a single INF within the MasterInf list
        to be processed.  If this parameter is not specified, then all INFs in
        the list are processed.

Return Value:

    If success, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code.

--*/
{
    PLOADED_INF CurInf, WriteableInf;
    UINT UserDirIdCount;
    PUSERDIRID UserDirIds;
    DWORD i;
    PCTSTR TemplateString;
    PPARSE_CONTEXT ParseContext = NULL;
    DWORD UnresolvedSubst;
    LONG NewStringId;

    UserDirIdCount = MasterInf->UserDirIdList.UserDirIdCount;
    UserDirIds     = MasterInf->UserDirIdList.UserDirIds;

    for(CurInf = Inf ? Inf : MasterInf;
        CurInf;
        CurInf = Inf ? NULL : CurInf->Next) {
        //
        // Nothing to do if there are no unresolved string substitutions.
        //
        if(!(CurInf->SubstValueCount)) {
            continue;
        }

        //
        // If this is a PNF, then we must move it into writeable memory before
        // we do the string substitutions.
        //
        if(CurInf->FileHandle != INVALID_HANDLE_VALUE) {

            if(!(WriteableInf = DuplicateLoadedInfDescriptor(CurInf))) {
                if(ParseContext) {
                    MyFree(ParseContext);
                }
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Replace the contents of the PNF in the linked list with that of our
            // new writeable INF.
            //
            ReplaceLoadedInfDescriptor(CurInf, WriteableInf);
        }

        //
        // There are one or more unresolved string substitutions in this INF.
        // Process each one.
        //
        for(i = 0; i < CurInf->SubstValueCount; i++) {
            //
            // Retrieve the original (template) string for this value.
            //
            TemplateString = pStringTableStringFromId(CurInf->StringTable,
                                                      CurInf->SubstValueList[i].TemplateStringId
                                                     );
            MYASSERT(TemplateString);

            //
            // Build a partial parse context structure to pass into ProcessForSubstitutions().
            //
            if(!ParseContext) {
                ParseContext = MyMalloc(sizeof(PARSE_CONTEXT));
                if(!ParseContext) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                ZeroMemory(ParseContext,sizeof(PARSE_CONTEXT));
            }

            ParseContext->DoVolatileDirIds = TRUE;
            ParseContext->Inf = MasterInf;
            //
            // None of the other fields are used in this case--don't bother initializing them.
            //
            ProcessForSubstitutions(ParseContext, TemplateString, &UnresolvedSubst);

            NewStringId = pStringTableAddString(CurInf->StringTable,
                                                ParseContext->TemporaryString,
                                                STRTAB_BUFFER_WRITEABLE | (CurInf->SubstValueList[i].CaseSensitive
                                                                                ? STRTAB_CASE_SENSITIVE
                                                                                : STRTAB_CASE_INSENSITIVE),
                                                NULL,0
                                               );
            if(NewStringId == -1) {
                //
                // We failed because of an out-of-memory condition.  Aborting now means that the
                // INF may have some of its unresolved strings fixed up, while others haven't yet
                // been processed.  Oh well...
                //
                MyFree(ParseContext);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Replace the string ID at the value offset with the new one we just computed.
            //
            CurInf->ValueBlock[CurInf->SubstValueList[i].ValueOffset] = NewStringId;
        }
    }
    if(ParseContext) {
        MyFree(ParseContext);
    }

    return NO_ERROR;
}


BOOL
AlignForNextBlock(
    IN HANDLE hFile,
    IN DWORD  ByteCount
    )
/*++

Routine Description:

    This routine writes out the requested number of zero bytes into the specified
    file.

Arguments:

    hFile - Supplies a handle to the file where the zero-valued bytes are to be
        written.

    ByteCount - Specifies the number of zero-valued bytes to write to the file.

Return Value:

    If success, the return value is TRUE.
    If failure, the return value is FALSE.  Call GetLastError() to retrieve a
    Win32 error code indicating the cause of the failure.

--*/
{
    DWORD i, BytesWritten;
    BYTE byte = 0;

    MYASSERT(ByteCount < PNF_ALIGNMENT);

    for(i = 0; i < ByteCount; i++) {
        if(!WriteFile(hFile, &byte, sizeof(byte), &BytesWritten, NULL)) {
            //
            // LastError already set.
            //
            return FALSE;
        }
        MYASSERT(BytesWritten == sizeof(byte));
    }

    return TRUE;
}


DWORD
pSetupGetOsLoaderDriveAndPath(
    IN  BOOL   RootOnly,
    OUT PTSTR  CallerBuffer,
    IN  DWORD  CallerBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the current path for the system partition root/OsLoader directory
    (from the registry).

Arguments:

    RootOnly - if TRUE, then only the system partition root is returned (e.g., "C:\")

    CallerBuffer - supplies a character buffer that receives the requested path

    CallerBufferSize - supplies the size, in characters of the CallerBuffer

    RequiredSize - optionally, supplies the address of a variable that receives the
        number of characters required to store the requested path string (including
        terminating NULL).

Return Value:

    If success, the return value is NO_ERROR.
    If failure, the return value is ERROR_INSUFFICIENT_BUFFER.

--*/
{
    HKEY hKey;
    TCHAR CharBuffer[MAX_PATH];
    PTSTR Buffer = NULL;
    DWORD DataLen;
    DWORD Type;
    LONG Err;


    CopyMemory(CharBuffer,
               pszPathSetup,
               sizeof(pszPathSetup) - sizeof(TCHAR)
              );
    CopyMemory((PBYTE)CharBuffer + (sizeof(pszPathSetup) - sizeof(TCHAR)),
               pszKeySetup,
               sizeof(pszKeySetup)
              );

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           CharBuffer,
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        Err = QueryRegistryValue(hKey,pszBootDir,&Buffer,&Type,&DataLen);
        if(Err == NO_ERROR) {
            lstrcpyn(CharBuffer,Buffer,SIZECHARS(CharBuffer));
            MyFree(Buffer);
        }
        RegCloseKey(hKey);
    }

    if(Err != ERROR_SUCCESS) {
#ifdef UNICODE
        //
        // If we couldn't retrieve the 'BootDir' value, resort to using the
        // OsSystemPartitionRoot
        //
        // root path is \\?\GLOBALROOT\<SystemPartition> not <BootDir>
        // can't make assumption about BootDir
        // so fail if we don't have that information
        //
        if(!OsSystemPartitionRoot) {
            //
            // if this is NULL at this point, we can't support this call
            // most likely due to out of memory condition, so report as such
            //
            return ERROR_OUTOFMEMORY;
        }
        lstrcpyn(CharBuffer,OsSystemPartitionRoot,SIZECHARS(CharBuffer));
#else
        //
        // If we couldn't retrieve the 'BootDir' value, drop back to default of "C:\".
        //
        lstrcpyn(CharBuffer,pszDefaultSystemPartition,SIZECHARS(CharBuffer));
#endif
        Err = NO_ERROR;
    }

    //
    // If there is an OsLoader relative path, then concatenate it to our root path.
    //
    if(!RootOnly && OsLoaderRelativePath) {
        pSetupConcatenatePaths(CharBuffer, OsLoaderRelativePath, SIZECHARS(CharBuffer), &DataLen);
    } else {
        DataLen = lstrlen(CharBuffer)+1;
    }

    if(RequiredSize) {
        *RequiredSize = DataLen;
    }

    if(CallerBufferSize < DataLen) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    CopyMemory(CallerBuffer, CharBuffer, DataLen * sizeof(TCHAR));

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infsdisk.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    infsdisk.c

Abstract:

    Externally exposed INF routines for source disk descriptor manipulation.

Author:

    Ted Miller (tedm) 9-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Locations of various fields in the [SourceDisksNames] section
// of an inf
//
#define DISKNAMESECT_DESCRIPTION    1
#define DISKNAMESECT_TAGFILE        2       // cabinet name in win95
#define DISKNAMESECT_OEM            3       // unused, indicates oem disk in win95
#define DISKNAMESECT_PATH           4
#define DISKNAMESECT_FLAGS          5       // indicates extra tags
#define DISKNAMESECT_TAGFILE2       6       // real tagfile if DISKNAMESECT_TAGFILE is really a cabfile

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetSourceInfoA(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PSTR   ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    DWORD rc;
    BOOL b;
    PWCHAR buffer;
    DWORD requiredsize;
    PCSTR ansi;

    buffer = MyMalloc(MAX_INF_STRING_LENGTH);
    if (buffer) {

        b = pSetupGetSourceInfo(
                InfHandle,
                NULL,
                SourceId,
                NULL,
                InfoDesired,
                buffer,
                MAX_INF_STRING_LENGTH,
                &requiredsize
                );

        rc = GetLastError();

        if(b) {

            rc = NO_ERROR;

            if(ansi = pSetupUnicodeToAnsi(buffer)) {

                requiredsize = lstrlenA(ansi)+1;

                if(RequiredSize) {
                    try {
                        *RequiredSize = requiredsize;
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                }

                if((rc == NO_ERROR) && ReturnBuffer) {

                    if(!lstrcpynA(ReturnBuffer,ansi,ReturnBufferSize)) {
                        //
                        // ReturnBuffer invalid
                        //
                        rc = ERROR_INVALID_PARAMETER;
                        b = FALSE;
                    }
                }

                MyFree(ansi);
            } else {
                rc = ERROR_NOT_ENOUGH_MEMORY;
                b = FALSE;
            }
        }

        MyFree(buffer);
    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupGetSourceInfoW(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PWSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(SourceId);
    UNREFERENCED_PARAMETER(InfoDesired);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetSourceInfo(
    IN  HINF   InfHandle,
    IN  UINT   SourceId,
    IN  UINT   InfoDesired,
    OUT PTSTR  ReturnBuffer,     OPTIONAL
    IN  DWORD  ReturnBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
//
// Native version
//
{
    return pSetupGetSourceInfo(InfHandle,
                               NULL,
                               SourceId,
                               NULL,
                               InfoDesired,
                               ReturnBuffer,
                               ReturnBufferSize,
                               RequiredSize
                              );
}

BOOL
pSetupGetSourceInfo(
    IN  HINF                    InfHandle,         OPTIONAL
    IN  PINFCONTEXT             LayoutLineContext, OPTIONAL
    IN  UINT                    SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,   OPTIONAL
    IN  UINT                    InfoDesired,
    OUT PTSTR                   ReturnBuffer,      OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize       OPTIONAL
    )
/*++

Routine Description:

    Get information from SourceDisksNames

    If InfHandle specified instead of LayoutLineContext
    and the ID is specified in more than one INF
    then the wrong information *MAY* be returned.
    This effects callers of SetupGetSourceInfo
    we need a SetupGetSourceInfoEx post 5.0

Arguments:

    InfHandle - required if LayoutLineContext is not provided, else specifies a layout inf

    SourceId  - numerical source ID, used as search key in SourceDisksNames section

    AltPlatformInfo - optionally, supplies alternate platform information used
        in decorating the [SourceDisksNames] section.

    InfoDesired -
        SRCINFO_PATH
        SRCINFO_TAGFILE
        SRCINFO_DESCRIPTION
        SRCINFO_FLAGS

    ReturnBuffer - buffer for returned string
    ReturnBufferSize - size of buffer
    RequiredSize - size buffer needs to be if ReturnBufferSize too small
    LayoutLineContext - if specified, used to determine correct INF to use if SourceID's conflict

Return Value:

    Boolean value indicating outcome. If FALSE, GetLastError() returns
    extended error information.
    ReturnBuffer filled out with string
    RequiredSize filled out with required size of buffer to hold string

--*/
{
    PCTSTR PlatformName;
    UINT ValueIndex;
    BOOL Mandatory;
    BOOL IsPath;
    INFCONTEXT InfContext;
    INFCONTEXT SelectedInfContext;
    int SelectedRank;
    TCHAR SourceIdString[24];
    PCTSTR Value;
    BOOL b;
    UINT Length;
    TCHAR MediaListSectionName[64];
    HINF hInfPreferred = (HINF)(-1);

    try {
        if ((LayoutLineContext != NULL) && (LayoutLineContext != (PINFCONTEXT)(-1))) {
            hInfPreferred = (HINF)LayoutLineContext->CurrentInf;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        hInfPreferred = (HINF)(-1);
    }

    //
    // Determine the index of the value that gives the caller the info he wants.
    //
    switch(InfoDesired) {

    case SRCINFO_PATH:
        ValueIndex = DISKNAMESECT_PATH;
        Mandatory = FALSE;
        IsPath = TRUE;
        break;

    case SRCINFO_TAGFILE:
        ValueIndex = DISKNAMESECT_TAGFILE;
        Mandatory = FALSE;
        IsPath = TRUE;
        break;

    case SRCINFO_DESCRIPTION:
        ValueIndex = DISKNAMESECT_DESCRIPTION;
        Mandatory = TRUE;
        IsPath = FALSE;
        break;

    case SRCINFO_FLAGS:
        ValueIndex = DISKNAMESECT_FLAGS;
        Mandatory = FALSE;
        IsPath = FALSE;
        break;

    case SRCINFO_TAGFILE2:
        ValueIndex = DISKNAMESECT_TAGFILE2;
        Mandatory = FALSE;
        IsPath = TRUE;
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    wsprintf(SourceIdString,TEXT("%d"),SourceId);

    if(AltPlatformInfo) {

        switch(AltPlatformInfo->ProcessorArchitecture) {

            case PROCESSOR_ARCHITECTURE_INTEL :
                PlatformName = pszX86SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA :
                PlatformName = pszAlphaSrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_IA64 :
                PlatformName = pszIa64SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA64 :
                PlatformName = pszAxp64SrcDiskSuffix;
                break;

            case PROCESSOR_ARCHITECTURE_AMD64 :
                PlatformName = pszAmd64SrcDiskSuffix;
                break;

            default :
                //
                // unknown/unsupported processor architecture.
                //
                MYASSERT((AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)  ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA64) ||
                         (AltPlatformInfo->ProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                        );

                SetLastError(ERROR_INVALID_PARAMETER);
                return(FALSE);
        }

    } else {
        PlatformName = pszPlatformSrcDiskSuffix;
    }

    _sntprintf(
        MediaListSectionName,
        sizeof(MediaListSectionName)/sizeof(MediaListSectionName[0]),
        TEXT("%s.%s"),
        pszSourceDisksNames,
        PlatformName
        );

    //
    // we will prefer
    // (1) an entry in hInfPreferred           (Rank 11/12 decorated over undecorated)
    // (2) an entry linked to hInfPreferred    (Rank 21/22 decorated over undecorated)
    // (3) an entry in hInfHandle              (Rank 31/32 decorated over undecorated)
    // (4) an entry linked to InfHandle        (Rank 41/42 decorated over undecorated)
    //

    SelectedRank = 100;       // 11-42 as above

    if ((hInfPreferred != NULL) && (hInfPreferred != (HINF)(-1))) {
        //
        // see if we can find the SourceIdString in the INF that we found the section in
        //
        // rank 11 or 21 (decorated) - always try
        //
        if(SetupFindFirstLine(hInfPreferred,MediaListSectionName,SourceIdString,&InfContext)) {
            if (InfContext.Inf == InfContext.CurrentInf) {
                SelectedRank = 11;
                SelectedInfContext = InfContext;
            } else {
                SelectedRank = 21;
                SelectedInfContext = InfContext;
            }
        }
        if (SelectedRank > 12) {
            //
            // rank 12 or 22 (undecorated) only try if we haven't got anything better than 12
            //
            if(SetupFindFirstLine(hInfPreferred,pszSourceDisksNames,SourceIdString,&InfContext)) {
                if (InfContext.Inf == InfContext.CurrentInf) {
                    SelectedRank = 12;
                    SelectedInfContext = InfContext;
                } else if (SelectedRank > 22) {
                    SelectedRank = 22;
                    SelectedInfContext = InfContext;
                }
            }
        }
    }
    if ((InfHandle != NULL) && (InfHandle != (HINF)(-1)) && (SelectedRank > 31)) {
        //
        // see if we can find the SourceIdString in the supplied INF
        //
        // rank 31 or 41 (decorated) - only try if we haven't got anything better than 31
        //
        if(SetupFindFirstLine(InfHandle,MediaListSectionName,SourceIdString,&InfContext)) {
            if (InfContext.Inf == InfContext.CurrentInf) {
                SelectedRank = 31;
                SelectedInfContext = InfContext;
            } else if (SelectedRank > 41) {
                SelectedRank = 41;
                SelectedInfContext = InfContext;
            }
        }
        if (SelectedRank > 32) {
            //
            // rank 32 or 42 (undecorated) - only try if we haven't got anything better than 32
            //
            if(SetupFindFirstLine(InfHandle,pszSourceDisksNames,SourceIdString,&InfContext)) {
                if (InfContext.Inf == InfContext.CurrentInf) {
                    SelectedRank = 32;
                    SelectedInfContext = InfContext;
                } else if (SelectedRank > 42) {
                    SelectedRank = 42;
                    SelectedInfContext = InfContext;
                }
            }
        }
    }
    if(SelectedRank == 100 || (Value = pSetupGetField(&InfContext,ValueIndex))==NULL) {
        if(Mandatory) {
            SetLastError(ERROR_LINE_NOT_FOUND);
            return(FALSE);
        } else {
            Value = TEXT("");
        }
    }

    //
    // Figure out how many characters are in the output.
    // If the value is a path type value we want to remove
    // the trailing backslash if there is one.
    //
    Length = lstrlen(Value);
    if(IsPath && Length && (*CharPrev(Value,Value+Length) == TEXT('\\'))) {
        Length--;
    }

    //
    // Need to leave space for the trailing nul.
    //
    Length++;
    if(RequiredSize) {
        b = TRUE;
        try {
            *RequiredSize = Length;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            b = FALSE;
        }
        if(!b) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

    b = TRUE;
    if(ReturnBuffer) {
        if(Length <= ReturnBufferSize) {
            //
            // lstrcpyn is a strange API but the below is correct --
            // the size parameter is actually the capacity of the
            // target buffer. So to get it to put the nul in the
            // right place we pass one larger than the number of chars
            // we want copied.
            //
            if(!lstrcpyn(ReturnBuffer,Value,Length)) {
                //
                // ReturnBuffer invalid
                //
                b = FALSE;
                SetLastError(ERROR_INVALID_PARAMETER);
            }
        } else {
            b = FALSE;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\infvalue.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    infvalue.c

Abstract:

    Externally exposed INF routines for INF value retreival and manipulation.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
pAToI(
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    INT Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    INT OverflowCheck;
    BOOL b;

    if(!Field) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*Field == TEXT('-')) {
        Neg = TRUE;
        Field++;
    } else {
        Neg = FALSE;
        if(*Field == TEXT('+')) {
            Field++;
        }
    }

    if((*Field == TEXT('0')) &&
       ((*(Field+1) == TEXT('x')) || (*(Field+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        Field += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *Field; Field++) {

        c = (UINT)*Field;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(INT) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*Field) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *IntegerValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}


DWORD
SetupGetFieldCount(
    IN PINFCONTEXT Context
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PINF_LINE Line = NULL;
    DWORD rc = NO_ERROR;
    DWORD res = 0;

    try {
        if(!LockInf((PLOADED_INF)Context->Inf)) {
            rc = ERROR_INVALID_PARAMETER;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if(rc) {
        SetLastError(rc);
        return(0);
    }

    try {
        Line = InfLineFromContext(Context);
        if(!Line) {
            rc = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(HASKEY(Line)) {
            res = Line->ValueCount - 2;
        } else {
            res = ISSEARCHABLE(Line) ? 1 : Line->ValueCount;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        res = 0;
    }

    try {
        UnlockInf((PLOADED_INF)Context->Inf);
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    SetLastError(rc);
    return res;
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetStringFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    PCWSTR Field;
    PCSTR field;
    UINT Len;
    DWORD rc, TmpRequiredSize;

    //
    // Context could be a bogus pointer -- guard access to it.
    //
    try {
        Field = pSetupGetField(Context, FieldIndex);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(Field) {
        field = pSetupUnicodeToAnsi(Field);
        if(!field) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    } else {
        //
        // (last error already set by pSetupGetField)
        //
        return FALSE;
    }

    Len = lstrlenA(field) + 1;

    //
    // RequiredSize and ReturnBuffer could be bogus pointers;
    // guard access to them.
    //
    rc = NO_ERROR;
    try {
        if(RequiredSize) {
            *RequiredSize = Len;
        }
        if(ReturnBuffer) {
            if(ReturnBufferSize >= Len) {
                lstrcpyA(ReturnBuffer, field);
            } else {
                rc = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    MyFree(field);
    SetLastError(rc);
    return(rc == NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
SetupGetStringFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(FieldIndex);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetStringField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PCTSTR Field;
    UINT Len;
    DWORD rc;

    //
    // Context could be a bogus pointer -- guard access to it.
    //
    try {
        Field = pSetupGetField(Context, FieldIndex);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(!Field) {
        //
        // (last error already set by pSetupGetField)
        //
        return FALSE;
    }

    Len = lstrlen(Field) + 1;

    //
    // RequiredSize and ReturnBuffer could be bogus pointers;
    // guard access to them.
    //
    rc = NO_ERROR;
    try {
        if(RequiredSize) {
            *RequiredSize = Len;
        }
        if(ReturnBuffer) {
            if(ReturnBufferSize >= Len) {
                lstrcpy(ReturnBuffer, Field);
            } else {
                rc = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


BOOL
SetupGetIntField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    PCTSTR Field;

    try {
        Field = pSetupGetField(Context,FieldIndex);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Field = NULL;
    }

    return (pAToI(Field, IntegerValue));
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetLineTextA(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCSTR       Section,          OPTIONAL
    IN  PCSTR       Key,              OPTIONAL
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    INFCONTEXT context;
    BOOL b;
    UINT FieldCount;
    UINT u;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    PCWSTR Field;
    PCSTR field;
    PCWSTR section,key;

    //
    // Set up inf context.
    //
    if(Context) {
        u = NO_ERROR;
        try {
            context = *Context;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    } else {
        if(!InfHandle || !Section || !Key) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if(Section) {
            u = pSetupCaptureAndConvertAnsiArg(Section,&section);
            if(u != NO_ERROR) {
                SetLastError(u);
                return(FALSE);
            }
        } else {
            section = NULL;
        }

        if(Key) {
            u = pSetupCaptureAndConvertAnsiArg(Key,&key);
            if(u != NO_ERROR) {
                if(section) {
                    MyFree(section);
                }
                SetLastError(u);
                return(FALSE);
            }
        } else {
            key = NULL;
        }

        b = SetupFindFirstLine(InfHandle,section,key,&context);
        u = GetLastError();

        if(section) {
            MyFree(section);
        }
        if(key) {
            MyFree(key);
        }

        if(!b) {
            SetLastError(u);
            return FALSE;
        }
    }

    //
    // Figure out how many fields are involved.
    //
    InsufficientBuffer = FALSE;
    if(FieldCount = SetupGetFieldCount(&context)) {
        TmpRequiredSize = 0;

        for(u=0; u<FieldCount; u++) {

            Field = pSetupGetField(&context, u+1);
            MYASSERT(Field);

            field = pSetupUnicodeToAnsi(Field);
            if(!field) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return(FALSE);
            }

            OldSize = TmpRequiredSize;
            TmpRequiredSize += lstrlenA(field)+1;

            if(ReturnBuffer) {
                if(TmpRequiredSize > ReturnBufferSize) {
                    InsufficientBuffer = TRUE;
                } else {
                    //
                    // lstrcpy is safe even with bad pointers
                    // (at least on NT)
                    //
                    lstrcpyA(ReturnBuffer+OldSize,field);
                    ReturnBuffer[TmpRequiredSize - 1] = ',';
                }
            }

            MyFree(field);
        }

        //
        // 0-terminate the buffer by overwriting the final comma.
        //
        if(ReturnBuffer && !InsufficientBuffer) {
            ReturnBuffer[TmpRequiredSize - 1] = 0;
        }
    } else {
        //
        // Special case when no values -- need 1 byte for nul.
        //
        if (GetLastError() != NO_ERROR) {
            //
            // actually, something went wrong reading the data from our context...
            // bail out
            //
            return(FALSE);
        }
        TmpRequiredSize = 1;
        if(ReturnBuffer) {
            if(ReturnBufferSize) {
                *ReturnBuffer = 0;
            } else {
                InsufficientBuffer = TRUE;
            }
        }
    }

    if(RequiredSize) {
        u = NO_ERROR;
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}
#else
//
// Unicode stub
//
BOOL
SetupGetLineTextW(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCWSTR      Section,          OPTIONAL
    IN  PCWSTR      Key,              OPTIONAL
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(Section);
    UNREFERENCED_PARAMETER(Key);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetLineText(
    IN  PINFCONTEXT Context,          OPTIONAL
    IN  HINF        InfHandle,        OPTIONAL
    IN  PCTSTR      Section,          OPTIONAL
    IN  PCTSTR      Key,              OPTIONAL
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT PDWORD      RequiredSize      OPTIONAL
    )

/*++

Routine Description:

    This function returns the contents of a line in a compact format.
    All extraneous whitespace is removed, and multi-line values are converted
    into a single contiguous string.

    For example, consider the following extract from an INF:

    HKLM, , Foo, 1, \
    ; This is a comment
    01, 02, 03

    would be returned as:
    HKLM,,Foo,1,01,02,03

Arguments:

    Context - Supplies context for an inf line whose text is to be retreived.
        If not specified, then InfHandle, Section, and Key must be.

    InfHandle - Supplies handle of the INF file to query.
        Only used if Context is NULL.

    Section - points to a null-terminated string that specifies the section
        containing the key nameof the line whose text is to be retreived.
        (Only used if InfLineHandle is NULL.)

    Key - Points to the null-terminated string containing the key name
        whose associated string is to be retrieved. (Only used if InfLineHandle is NULL.)

    ReturnBuffer - Points to the buffer that receives the retrieved string.

    ReturnBufferSize - Specifies the size, in characters, of the buffer pointed to
        by the ReturnBuffer parameter.

    RequiredSize - Receives the actual number of characters needed for the buffer
        pointed to by the ReturnBuffer parameter. If this value is larger than the
        value specified in the ReturnBufferSize parameter, the function fails and
        the function stores no data in the buffer.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE. To get extended error information,
        call GetLastError.

--*/

{
    INFCONTEXT context;
    BOOL b;
    UINT FieldCount;
    UINT u;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    PCTSTR Field;

    //
    // Set up inf context.
    //
    if(Context) {
        u = NO_ERROR;
        try {
            context = *Context;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    } else {
        if(!InfHandle || !Section || !Key) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        if(!SetupFindFirstLine(InfHandle, Section, Key, &context)) {
            return FALSE;
        }
    }

    //
    // Figure out how many fields are involved.
    //
    InsufficientBuffer = FALSE;
    if(FieldCount = SetupGetFieldCount(&context)) {
        TmpRequiredSize = 0;

        for(u=0; u<FieldCount; u++) {

            Field = pSetupGetField(&context, u+1);
            MYASSERT(Field);

            OldSize = TmpRequiredSize;
            TmpRequiredSize += lstrlen(Field)+1;

            if(ReturnBuffer) {
                if(TmpRequiredSize > ReturnBufferSize) {
                    InsufficientBuffer = TRUE;
                } else {
                    //
                    // lstrcpy is safe even with bad pointers
                    // (at least on NT)
                    //
                    lstrcpy(ReturnBuffer+OldSize, Field);
                    ReturnBuffer[TmpRequiredSize - 1] = TEXT(',');
                }
            }
        }

        //
        // 0-terminate the buffer by overwriting the final comma.
        //
        if(ReturnBuffer && !InsufficientBuffer) {
            ReturnBuffer[TmpRequiredSize - 1] = TEXT('\0');
        }
    } else {
        //
        // Special case when no values -- need 1 byte for nul.
        //
        if (GetLastError() != NO_ERROR) {
            //
            // actually, something went wrong reading the data from our context...
            // bail out
            //
            return(FALSE);
        }
        TmpRequiredSize = 1;
        if(ReturnBuffer) {
            if(ReturnBufferSize) {
                *ReturnBuffer = TEXT('\0');
            } else {
                InsufficientBuffer = TRUE;
            }
        }
    }

    if(RequiredSize) {
        u = NO_ERROR;
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            u = ERROR_INVALID_PARAMETER;
        }
        if(u != NO_ERROR) {
            SetLastError(u);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupGetMultiSzFieldA(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PSTR        ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    PCTSTR Field;
    UINT FieldCount;
    UINT u;
    UINT Len;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    DWORD rc;
    PCSTR field;

    rc = NO_ERROR;

    //
    // Disallow keys
    //
    if(FieldIndex == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Figure out how many fields are involved.
    //
    FieldCount = SetupGetFieldCount(Context);
    if (FieldCount == 0 && GetLastError() != NO_ERROR) {
        return FALSE;
    }
    if(FieldCount > (FieldIndex-1)) {
        FieldCount -= FieldIndex - 1;
    } else {
        FieldCount = 0;
    }

    //
    // Need at least one byte for the terminating nul.
    //
    TmpRequiredSize = 1;
    InsufficientBuffer = FALSE;

    if(ReturnBuffer) {
        if(ReturnBufferSize) {
            try {
                *ReturnBuffer = 0;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
            }
            if(rc != NO_ERROR) {
                SetLastError(rc);
                return(FALSE);
            }
        } else {
            InsufficientBuffer = TRUE;
        }
    }

    for(u=0; u<FieldCount; u++) {

        try {
            Field = pSetupGetField(Context, u+FieldIndex);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

        MYASSERT(Field);

        field = pSetupUnicodeToAnsi(Field);
        if(!field) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }

        if((Len = lstrlenA(field)+1) == 1) {
            //
            // Then we've encountered an empty field.  Since multi-sz lists can't contain
            // an empty string, this terminates our list.
            //
            MyFree(field);
            goto clean0;
        }

        OldSize = TmpRequiredSize;
        TmpRequiredSize += Len;

        if(ReturnBuffer) {
            if(TmpRequiredSize > ReturnBufferSize) {
                InsufficientBuffer = TRUE;
            } else {
                //
                // lstrcpy is safe with bad pointers (at least on NT)
                //
                lstrcpyA(ReturnBuffer+OldSize-1,field);
                ReturnBuffer[TmpRequiredSize - 1] = 0;
            }
        }

        MyFree(field);
    }

clean0:
    if(RequiredSize) {
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}
#else
//
// Unicode stub
//
BOOL
SetupGetMultiSzFieldW(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PWSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(FieldIndex);
    UNREFERENCED_PARAMETER(ReturnBuffer);
    UNREFERENCED_PARAMETER(ReturnBufferSize);
    UNREFERENCED_PARAMETER(RequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupGetMultiSzField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PTSTR       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PCTSTR Field;
    UINT FieldCount;
    UINT u;
    UINT Len;
    BOOL InsufficientBuffer;
    DWORD OldSize, TmpRequiredSize;
    DWORD rc;

    rc = NO_ERROR;

    //
    // Disallow keys
    //
    if(FieldIndex == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Figure out how many fields are involved.
    //
    FieldCount = SetupGetFieldCount(Context);
    if (FieldCount == 0 && GetLastError() != NO_ERROR) {
        return FALSE;
    }
    if(FieldCount > (FieldIndex-1)) {
        FieldCount -= FieldIndex - 1;
    } else {
        FieldCount = 0;
    }

    //
    // Need at least one byte for the terminating nul.
    //
    TmpRequiredSize = 1;
    InsufficientBuffer = FALSE;

    if(ReturnBuffer) {
        if(ReturnBufferSize) {
            try {
                *ReturnBuffer = 0;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
            }
            if(rc != NO_ERROR) {
                SetLastError(rc);
                return(FALSE);
            }
        } else {
            InsufficientBuffer = TRUE;
        }
    }

    for(u=0; u<FieldCount; u++) {

        try {
            Field = pSetupGetField(Context, u+FieldIndex);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

        MYASSERT(Field);

        if((Len = lstrlen(Field)+1) == 1) {
            //
            // Then we've encountered an empty field.  Since multi-sz lists can't contain
            // an empty string, this terminates our list.
            //
            goto clean0;
        }

        OldSize = TmpRequiredSize;
        TmpRequiredSize += Len;

        if(ReturnBuffer) {
            if(TmpRequiredSize > ReturnBufferSize) {
                InsufficientBuffer = TRUE;
            } else {
                //
                // lstrcpy is safe with bad pointers (at least on NT)
                //
                lstrcpy(ReturnBuffer+OldSize-1, Field);
                ReturnBuffer[TmpRequiredSize - 1] = 0;
            }
        }
    }

clean0:
    if(RequiredSize) {
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    if(InsufficientBuffer) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}


BOOL
SetupGetBinaryField(
    IN  PINFCONTEXT Context,
    IN  DWORD       FieldIndex,
    OUT PBYTE       ReturnBuffer,     OPTIONAL
    IN  DWORD       ReturnBufferSize,
    OUT LPDWORD     RequiredSize      OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PCTSTR Field;
    UINT FieldCount;
    UINT u;
    ULONG Value;
    BOOL Store;
    PTCHAR End;
    DWORD TmpRequiredSize;
    DWORD rc;

    rc = NO_ERROR;

    //
    // Disallow keys
    //
    if(FieldIndex == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Figure out how many fields are involved.
    //
    FieldCount = SetupGetFieldCount(Context);
    if (FieldCount == 0 && GetLastError() != NO_ERROR) {
        return FALSE;
    }
    if(FieldCount > (FieldIndex-1)) {
        FieldCount -= FieldIndex - 1;
    } else {
        FieldCount = 0;
    }

    TmpRequiredSize = FieldCount;

    Store = (ReturnBuffer && (TmpRequiredSize <= ReturnBufferSize));

    //
    // Even though we know the required size,
    // go through the loop anyway to validate the data.
    //
    for(u=0; u<FieldCount; u++) {

        try {
            if(!(Field = pSetupGetField(Context,u+FieldIndex))) {
                rc = ERROR_INVALID_HANDLE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }

        Value = _tcstoul(Field, &End, 16);

        //
        // Only the terminating nul should have caused the conversion
        // to stop. In any other case there were non-hex digits in the string.
        // Also disallow the empty string.
        //
        if((End == Field) || *End || (Value > 255)) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        if(Store) {
            try {
                *ReturnBuffer++ = (UCHAR)Value;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
            }
            if(rc != NO_ERROR) {
                SetLastError(rc);
                return(FALSE);
            }
        }
    }

    if(RequiredSize) {
        try {
            *RequiredSize = TmpRequiredSize;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    if(ReturnBuffer && (TmpRequiredSize > ReturnBufferSize)) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    return TRUE;
}


PINF_LINE
InfLineFromContext(
    IN PINFCONTEXT Context
    )

/*++

Routine Description:

    Given an INF context, return a pointer to the inf line structure.

Arguments:

    Context - supplies a pointer to the context structure that was filled
        in by one of the line-related INF APIs.
        No validation is performed on any value in the context structure.

Return Value:

    Pointer to the relevent inf line structure.

--*/

{
    PLOADED_INF Inf;
    PINF_SECTION Section;
    PINF_LINE Line;

    Inf = (PLOADED_INF)Context->CurrentInf;

    if(!LockInf((PLOADED_INF)Context->Inf)) {
        return(NULL);
    }

    Section = &Inf->SectionBlock[Context->Section];
    Line = &Inf->LineBlock[Section->Lines + Context->Line];

    UnlockInf((PLOADED_INF)Context->Inf);
    return(Line);
}

/////////////////////////////////////////////////////////////////
//
// Internal routines
//
/////////////////////////////////////////////////////////////////




BOOL
pSetupGetSecurityInfo(
    IN HINF Inf,
    IN PCTSTR SectionName,
    OUT PCTSTR *SecDesc )
{

    BOOL b;
    PTSTR SecuritySectionName;
    INFCONTEXT LineContext;
    DWORD rc;


    SecuritySectionName = (PTSTR)MyMalloc( ((lstrlen(SectionName) + lstrlen((PCTSTR)L".Security"))*sizeof(TCHAR)) + 3l );
    if( !SecuritySectionName ){
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return( FALSE );
    }

    lstrcpy( SecuritySectionName, SectionName );
    lstrcat( SecuritySectionName, (PCTSTR)(L".Security") );
    b = SetupFindFirstLine(Inf,(PCTSTR)SecuritySectionName,NULL,&LineContext);
    MyFree( SecuritySectionName );
    if(!b)
        return( FALSE );    // Section did not exist or other error


    if( !(*SecDesc = pSetupGetField( &LineContext, 1 )) )
        return( FALSE );            // Error code is present by checking GetLastError() if needed
    else
        return( TRUE );


}




PCTSTR
pSetupGetField(
    IN PINFCONTEXT Context,
    IN DWORD       FieldIndex
    )

/*++

Routine Description:

    Retreive a field from a line.

Arguments:

    Context - supplies inf context. No validation is performed
        on the values contained in this structure.

    FieldIndex - supplies 1-based index of field to retreive.
        An index of 0 retreives the key, if it exists.

Return Value:

    Pointer to string. The caller must not write into this buffer.

    If the field index is not valid, the return value is NULL,
    and SetLastError() will have been called.

--*/

{
    PINF_LINE Line;
    PTSTR p = NULL;
    DWORD Err = NO_ERROR;

    //
    // InfLineFromContext does it's own INF locking, but the later call
    // to InfGetField doesn't, so go ahead and grab the lock up front.
    //
    if(LockInf((PLOADED_INF)Context->Inf)) {

        if(Line = InfLineFromContext(Context)) {

            if((p = InfGetField(Context->CurrentInf,Line,FieldIndex,NULL)) == NULL) {
                Err = ERROR_INVALID_PARAMETER;
            }

        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

        UnlockInf((PLOADED_INF)Context->Inf);

    } else {
        Err = ERROR_INVALID_HANDLE;
    }

    SetLastError(Err);
    return p;
}

BOOL
pSetupGetDriverDate(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN OUT PFILETIME  pFileTime
    )

/*++

Routine Description:

    Retreive the date from a specified Section.

    The Date specified in an INF section has the following format:

    DriverVer=xx/yy/zzzz

        or

    DriverVer=xx-yy-zzzz

    where xx is the month, yy is the day, and zzzz is the for digit year.
    Note that the year MUST be 4 digits.  A year of 98 will be considered
    0098 and not 1998!

    This date should be the date of the Drivers and not for the INF itself.
    So a single INF can have multiple driver install Sections and each can
    have different dates depending on when the driver was last updated.

Arguments:

    InfHandle - Supplies handle of the INF file to query.

    Section - points to a null-terminated string that specifies the section
        of the driver to get the FILETIME infomation.

    pFileTime - points to a FILETIME structure that will receive the Date,
        if it exists.

Return Value:

    BOOL. TRUE if a valid date existed in the specified Section and FALSE otherwise.

--*/

{
    DWORD rc;
    SYSTEMTIME SystemTime;
    INFCONTEXT InfContext;
    TCHAR DriverDate[20];
    PTSTR Convert, Temp;
    DWORD Value;

    rc = NO_ERROR;

    try {

        *DriverDate = 0;
        ZeroMemory(&SystemTime, sizeof(SYSTEMTIME));
        pFileTime->dwLowDateTime = 0;
        pFileTime->dwHighDateTime = 0;

        if(SetupFindFirstLine(InfHandle, Section, pszDriverVer, &InfContext)) {

            if ((SetupGetStringField(&InfContext,
                                1,
                                DriverDate,
                                SIZECHARS(DriverDate),
                                NULL)) &&
                 (*DriverDate)) {

                Convert = DriverDate;

                if (*Convert) {

                    Temp = DriverDate;
                    while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                        Temp++;

                    *Temp = 0;

                    //
                    //Convert the month
                    //
                    pAToI(Convert, (PINT)&Value);
                    SystemTime.wMonth = LOWORD(Value);

                    Convert = Temp+1;

                    if (*Convert) {

                        Temp = Convert;
                        while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                            Temp++;

                        *Temp = 0;

                        //
                        //Convert the day
                        //
                        pAToI(Convert, (PINT)&Value);
                        SystemTime.wDay = LOWORD(Value);

                        Convert = Temp+1;

                        if (*Convert) {

                            //
                            //Convert the year
                            //
                            pAToI(Convert, (PINT)&Value);
                            SystemTime.wYear = LOWORD(Value);

                            //
                            //Convert SYSTEMTIME into FILETIME
                            //
                            SystemTimeToFileTime(&SystemTime, pFileTime);
                        }
                    }
                }
            }

        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        SetLastError(rc);
        return FALSE;
    }

    SetLastError(NO_ERROR);
    return((pFileTime->dwLowDateTime != 0) || (pFileTime->dwHighDateTime != 0));
}



BOOL
pSetupGetDriverVersion(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    OUT DWORDLONG   *Version
    )

/*++

Routine Description:

    Retreive the driver version from a specified Section.

    The driver version specified in an INF section has the following format:

    DriverVer=xx/yy/zzzz, a.b.c.d

        or

    DriverVer=xx-yy-zzzz, a.b.c.d

    a.b.c.d is the version of the driver, where a, b, c, and d are all WORD
    decimal values.

    The version is in the second field in the DriverVer INF value, the driver date
    is in the first field.

Arguments:

    InfHandle - Supplies handle of the INF file to query.

    Section - points to a null-terminated string that specifies the section
        of the driver to get the FILETIME infomation.

    Version - points to a DWORDLONG value that will receive the version,
        if it exists.

Return Value:

    BOOL. TRUE if a valid driver version existed in the specified Section and FALSE otherwise.

--*/

{
    DWORD rc;
    INFCONTEXT InfContext;
    TCHAR DriverVersion[LINE_LEN];
    BOOL bEnd = FALSE;
    INT MajorHiWord, MajorLoWord, MinorHiWord, MinorLoWord;
    PTSTR Convert, Temp;

    rc = NO_ERROR;

    try {

        *DriverVersion = 0;
        *Version = 0;
        MajorHiWord = MajorLoWord = MinorHiWord = MinorLoWord = 0;

        if(SetupFindFirstLine(InfHandle, Section, pszDriverVer, &InfContext)) {

            if ((SetupGetStringField(&InfContext,
                                2,
                                DriverVersion,
                                SIZECHARS(DriverVersion),
                                NULL)) &&
                 (*DriverVersion)) {

                Convert = DriverVersion;

                if (*Convert) {

                    Temp = DriverVersion;
                    while (*Temp && (*Temp != TEXT('.'))) {

                        Temp++;
                    }

                    if (!*Temp) {

                       bEnd = TRUE;
                    }

                    *Temp = 0;

                    //
                    //Convert the HIWORD of the major version
                    //
                    if (pAToI(Convert, (PINT)&MajorHiWord)) {

                        Convert = Temp+1;

                        if (!bEnd && *Convert) {

                            Temp = Convert;
                            while (*Temp && (*Temp != TEXT('.'))) {

                                Temp++;
                            }

                            if (!*Temp) {

                                bEnd = TRUE;
                            }

                            *Temp = 0;

                            //
                            //Convert the LOWORD of the major version
                            //
                            if (pAToI(Convert, (PINT)&MajorLoWord)) {

                                Convert = Temp+1;

                                if (!bEnd && *Convert) {

                                    Temp = Convert;
                                    while (*Temp && (*Temp != TEXT('.'))) {

                                        Temp++;
                                    }

                                    if (!*Temp) {

                                        bEnd = TRUE;
                                    }

                                    *Temp = 0;

                                    //
                                    //Convert the HIWORD of the minor version
                                    //
                                    if (pAToI(Convert, (PINT)&MinorHiWord)) {

                                        Convert = Temp+1;

                                        if (!bEnd && *Convert) {

                                            Temp = Convert;
                                            while (*Temp && (*Temp != TEXT('.'))) {

                                                Temp++;
                                            }

                                            *Temp = 0;

                                            //
                                            //Convert the LOWORD of the minor version
                                            //
                                            pAToI(Convert, (PINT)&MinorLoWord);
                                        }
                                    }
                                }
                            }
                        }
                    }


                    *Version = (((DWORDLONG)MajorHiWord << 48) +
                                 ((DWORDLONG)MajorLoWord << 32) +
                                 ((DWORDLONG)MinorHiWord << 16) +
                                  (DWORDLONG)MinorLoWord);
                }
            }

        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
        *Version = 0;
        SetLastError(rc);
        return FALSE;
    }

    SetLastError(NO_ERROR);
    return(*Version != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\makefile.inc ===
obj\$(TARGET_DIRECTORY)\setupapi.res: ..\setupapi.rc ..\msg.mc ..\prompt.dlg

$(O)\setupapi.def: ..\setupapi.def
        $(C_PREPROCESSOR) ..\setupapi.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\memory.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    memory.h

Abstract:

    Private header file for memory functions within setup api dll.
    
    These headers were moved from setupntp.h into a private header

Author:

    Andrew Ritz (AndrewR) 2-Feb-2000

Revision History:

--*/

//
// Debug memory functions and wrappers to track allocations
//

#if MEM_DBG

VOID
SetTrackFileAndLine (
    PCSTR File,
    UINT Line
    );

VOID
ClrTrackFileAndLine (
    VOID
    );

#define TRACK_ARG_DECLARE       PCSTR __File, UINT __Line
#define TRACK_ARG_COMMA         ,
#define TRACK_ARG_CALL          __FILE__, __LINE__
#define TRACK_PUSH              SetTrackFileAndLine(__File, __Line);
#define TRACK_POP               ClrTrackFileAndLine();

#else

#define TRACK_ARG_DECLARE
#define TRACK_ARG_COMMA
#define TRACK_ARG_CALL
#define TRACK_PUSH
#define TRACK_POP

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\miscutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    miscutil.c

Abstract:

    Miscellaneous utility functions for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#if MEM_DBG

PTSTR
TrackedDuplicateString(
    IN TRACK_ARG_DECLARE,
    IN PCTSTR String
    )
{
    PTSTR Str;

    TRACK_PUSH

    Str = pSetupDuplicateString (String);

    TRACK_POP

    return Str;
}

#endif

DWORD
CaptureStringArg(
    IN  PCTSTR  String,
    OUT PCTSTR *CapturedString
    )

/*++

Routine Description:

    Capture a string whose validity is suspect.
    This operation is completely guarded and thus won't fault,
    leak memory in the error case, etc.

Arguments:

    String - supplies string to be captured.

    CapturedString - if successful, receives pointer to captured equivalent
        of String. Caller must free with MyFree(). If not successful,
        receives NULL. This parameter is NOT validated so be careful.

Return Value:

    Win32 error code indicating outcome.

    NO_ERROR - success, CapturedString filled in.
    ERROR_NOT_ENOUGH_MEMORY - insufficient memory for conversion.
    ERROR_INVALID_PARAMETER - String was invalid.

--*/

{
    DWORD d;

    try {
        //
        // DuplicateString is guaranteed to generate a fault
        // if the string is invalid. Otherwise if it is non-NULL
        // the it succeeded.
        //
        *CapturedString = DuplicateString(String);
        d = (*CapturedString == NULL) ? ERROR_NOT_ENOUGH_MEMORY : NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        d = ERROR_INVALID_PARAMETER;
        *CapturedString = NULL;
    }

    return(d);
}

DWORD
DelimStringToMultiSz(
    IN PTSTR String,
    IN DWORD StringLen,
    IN TCHAR Delim
    )

/*++

Routine Description:

    Converts a string containing a list of items delimited by
    'Delim' into a MultiSz buffer.  The conversion is done in-place.
    Leading and trailing whitespace is removed from each constituent
    string.  Delimiters inside of double-quotes (") are ignored.  The
    quotation marks are removed during processing, and any trailing
    whitespace is trimmed from each string (whether or not the
    whitespace was originally enclosed in quotes.  This is consistent
    with the way LFNs are treated by the file system (i.e., you can
    create a filename with preceding whitespace, but not with trailing
    whitespace.

    NOTE:  The buffer containing the string must be 1 character longer
    than the string itself (including NULL terminator).  An extra
    character is required when there's only 1 string, and no whitespace
    to trim, e.g.:  'ABC\0' (len=4) becomes 'ABC\0\0' (len=5).

Arguments:

    String - Supplies the address of the string to be converted.

    StringLen - Supplies the length, in characters, of the String
        (may include terminating NULL).

    Delim - Specifies the delimiter character.

Return Value:

    This routine returns the number of strings in the resulting multi-sz
    buffer.

--*/

{
    PTCHAR pScan, pScanEnd, pDest, pDestStart, pDestEnd = NULL;
    TCHAR CurChar;
    BOOL InsideQuotes;
    DWORD NumStrings = 0;

    //
    // Truncate any leading whitespace.
    //
    pScanEnd = (pDestStart = String) + StringLen;

    for(pScan = String; pScan < pScanEnd; pScan++) {
        if(!(*pScan)) {
            //
            // We hit a NULL terminator without ever hitting a non-whitespace
            // character.
            //
            goto clean0;

        } else if(!IsWhitespace(pScan)) {
            break;
        }
    }

    for(pDest = pDestStart, InsideQuotes = FALSE; pScan < pScanEnd; pScan++) {

        if((CurChar = *pScan) == TEXT('\"')) {
            InsideQuotes = !InsideQuotes;
        } else if(CurChar && (InsideQuotes || (CurChar != Delim))) {
            if(!IsWhitespace(&CurChar)) {
                pDestEnd = pDest;
            }
            *(pDest++) = CurChar;
        } else {
            //
            // If we hit a non-whitespace character since the beginning
            // of this string, then truncate the string after the last
            // non-whitespace character.
            //
            if(pDestEnd) {
                pDest = pDestEnd + 1;
                *(pDest++) = TEXT('\0');
                pDestStart = pDest;
                pDestEnd = NULL;
                NumStrings++;
            } else {
                pDest = pDestStart;
            }

            if(CurChar) {
                //
                // Then we haven't hit a NULL terminator yet. We need to strip
                // off any leading whitespace from the next string, and keep
                // going.
                //
                for(pScan++; pScan < pScanEnd; pScan++) {
                    if(!(CurChar = *pScan)) {
                        break;
                    } else if(!IsWhitespace(&CurChar)) {
                        //
                        // We need to be at the position immediately preceding
                        // this character.
                        //
                        pScan--;
                        break;
                    }
                }
            }

            if((pScan >= pScanEnd) || !CurChar) {
                //
                // We reached the end of the buffer or hit a NULL terminator.
                //
                break;
            }
        }
    }

clean0:

    if(pDestEnd) {
        //
        // Then we have another string at the end we need to terminate.
        //
        pDestStart = pDestEnd + 1;
        *(pDestStart++) = TEXT('\0');
        NumStrings++;

    } else if(pDestStart == String) {
        //
        // Then no strings were found, so create a single empty string.
        //
        *(pDestStart++) = TEXT('\0');
        NumStrings++;
    }

    //
    // Write out an additional NULL to terminate the string list.
    //
    *pDestStart = TEXT('\0');

    return NumStrings;
}


BOOL
LookUpStringInTable(
    IN  PSTRING_TO_DATA Table,
    IN  PCTSTR          String,
    OUT PUINT_PTR       Data
    )

/*++

Routine Description:

    Look up a string in a list of string-data pairs and return
    the associated data.

Arguments:

    Table - supplies an array of string-data pairs. The list is terminated
        when a String member of this array is NULL.

    String - supplies a string to be looked up in the table.

    Data - receives the assoicated data if the string is founf in the table.

Return Value:

    TRUE if the string was found in the given table, FALSE if not.

--*/

{
    UINT i;

    for(i=0; Table[i].String; i++) {
        if(!lstrcmpi(Table[i].String,String)) {
            *Data = Table[i].Data;
            return(TRUE);
        }
    }

    return(FALSE);
}


#ifdef _X86_
BOOL
IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}
#endif

#ifdef UNICODE  // pSetupCalcMD5Hash not needed in ANSI setupapi
DWORD
pSetupCalcMD5Hash(
    IN  HCRYPTPROV  hCryptProv,
    IN  PBYTE       Buffer,
    IN  DWORD       BufferSize,
    OUT PBYTE      *Hash,
    OUT PDWORD      HashSize
    )
/*++

Routine Description:

    This routine calculates an MD5 cryptographic hash for the specified buffer
    and returns a newly allocated buffer containing that hash.

Arguments:

    hCryptProv - Supplies the handle of a cryptographic service provider (CSP)
        created by a call to CryptAcquireContext.
        
    Buffer - Supplies the address of a buffer to be hashed.
    
    BufferSize - Supplies the size (in bytes) of the buffer to be hashed.
    
    Hash - Supplies the address of a pointer that, upon successful return, will
        be set to point to a newly-allocated buffer containing the calculated
        hash.  The caller is responsible for freeing this memory by calling
        MyFree().  If this call fails, this pointer will be set to NULL.
        
    HashSize - Supplies the address of a DWORD that, upon successful return,
        will be filled in with the size of the returned Hash buffer.

Return Value:

    If successful, the return value is NO_ERROR.
    Otherwise, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    DWORD Err;
    HCRYPTHASH hHash = 0;

    *Hash = NULL;
    *HashSize = 0;

    if(!CryptCreateHash(hCryptProv,
                        CALG_MD5,
                        0,
                        0,
                        &hHash)) {

        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }

        return Err;
    }

    try {
        if(!CryptHashData(hHash,Buffer,BufferSize,0) ||
           !CryptHashData(hHash,(PBYTE)&Seed,sizeof(Seed),0)) {

            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
            goto clean0;
        }

        *HashSize = 16; // MD5 hash is 16 bytes.
        *Hash = MyMalloc(*HashSize);

        if(!*Hash) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            *HashSize = 0;
            goto clean0;
        }

        if(CryptGetHashParam(hHash,
                             HP_HASHVAL,
                             *Hash,
                             HashSize,
                             0)) {
            Err = NO_ERROR;
        } else {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        *Hash = *Hash;  // force compiler to respect ordering
    }

    CryptDestroyHash(hHash);

    if((Err != NO_ERROR) && *Hash) {
        MyFree(*Hash);
        *Hash = NULL;
        *HashSize = 0;
    }

    return Err;
}
#endif  // pSetupCalcMD5Hash not needed in ANSI setupapi

// DO NOT TOUCH THIS ROUTINE.
VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    )
{
    LPCTSTR RegKeyName;
    HKEY hKey;
    DWORD Err;
    DWORD RegData, i, RegDataType, RegDataSize, Amalgam;
    BOOL DataCorrupt = FALSE;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    HCRYPTPROV hCryptProv;
    PBYTE AmalgamHash;
    DWORD AmalgamHashSize;
    TCHAR CharBuffer[CSTRLEN(REGSTR_PATH_SETUP) + SIZECHARS(REGSTR_KEY_SETUP)];
    PBYTE PrivateHash = NULL;
    DWORD PrivateHashSize;
    BYTE RegRestoreVal = 0;
    DWORD Target = 2;

#ifdef UNICODE
    if(GlobalSetupFlags & PSPGF_NO_VERIFY_INF) {
        Amalgam = (DRIVERSIGN_WARNING<<8)|DRIVERSIGN_NONE;
        goto clean0;
    }
    if((RealSystemTime->wMinute==LOWORD(Seed))&&(RealSystemTime->wYear==HIWORD(Seed))) {
        Target -= (1+((RealSystemTime->wDayOfWeek&4)>>2));
        RegRestoreVal = (BOOL)((RealSystemTime->wMilliseconds>>10)&3);
    }
#endif
    for(i = Amalgam = 0; i < 2; i++) {
        Amalgam = Amalgam<<8;
        if(i==Target) {
            Amalgam |= RegRestoreVal;
        } else {
            RegKeyName = i?pszNonDrvSignPath:pszDrvSignPath;
            Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,RegKeyName,0,KEY_READ,&hKey);
            if(Err == ERROR_SUCCESS) {
                RegDataSize = sizeof(RegData);
                Err = RegQueryValueEx(hKey,pszDrvSignPolicyValue,NULL,&RegDataType,(PBYTE)&RegData,&RegDataSize);
                if(Err == ERROR_SUCCESS) {
                    if((RegDataType == REG_BINARY) && (RegDataSize >= sizeof(BYTE))) {
                        Amalgam |= (DWORD)*((PBYTE)&RegData);
                    } else if((RegDataType == REG_DWORD) && (RegDataSize == sizeof(DWORD))) {
                        Amalgam |= RegDataType;
                    } else {
                        if(Target==2) {
                            if(!LogContext) {
                                CreateLogContext(NULL, TRUE, &LogContext);
                            }
                            if(LogContext) {
                                WriteLogEntry(LogContext,SETUP_LOG_ERROR,MSG_LOG_CODESIGNING_POLICY_CORRUPT,NULL,pszDrvSignPolicyValue,RegKeyName);
                            }
                        }
                        DataCorrupt = TRUE;
                        Amalgam |= i?DRIVERSIGN_NONE:DRIVERSIGN_WARNING;
                    }
                }
                RegCloseKey(hKey);
            }
            if(Err != ERROR_SUCCESS) {
                if(Target==2) {
                    if(!LogContext) {
                        CreateLogContext(NULL, TRUE, &LogContext);
                    }
                    if(LogContext) {    
                        WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CODESIGNING_POLICY_MISSING,NULL,pszDrvSignPolicyValue,RegKeyName);
                        WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
                    }
                }
                DataCorrupt = TRUE;
                Amalgam |= i?DRIVERSIGN_NONE:DRIVERSIGN_WARNING;
            }
        }
    }
#ifdef UNICODE
    if(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED) {
        goto clean0;
    }
    if(!CryptAcquireContext(&hCryptProv,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT)) {
        Err = GetLastError();
        if(!LogContext) {
            CreateLogContext(NULL, TRUE, &LogContext);
        }
        if(LogContext) {    
            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CRYPT_ACQUIRE_CONTEXT_FAILED,NULL);
            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
        }
        goto clean0;
    }

    Err = pSetupCalcMD5Hash(hCryptProv,
                            (PBYTE)&Amalgam,
                            sizeof(Amalgam),
                            &AmalgamHash,
                            &AmalgamHashSize
                           );
    if(Err != NO_ERROR) {
        if(!LogContext) {
            CreateLogContext(NULL, TRUE, &LogContext);
        }
        if(LogContext) {    
            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CRYPT_CALC_MD5_HASH_FAILED,NULL);
            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
        }
        goto clean1;
    }

    CopyMemory(CharBuffer,pszPathSetup,sizeof(pszPathSetup)-sizeof(TCHAR));
    CopyMemory((PBYTE)CharBuffer+(sizeof(pszPathSetup)-sizeof(TCHAR)),pszKeySetup,sizeof(pszKeySetup));
    Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,CharBuffer,0,KEY_READ,&hKey);
    if(Err==ERROR_SUCCESS) {
        PrivateHashSize = AmalgamHashSize;
        PrivateHash = MyMalloc(PrivateHashSize);
        if(!PrivateHash) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            Err = RegQueryValueEx(hKey,TEXT("PrivateHash"),NULL,&RegDataType,PrivateHash,&PrivateHashSize);
            if(Err==ERROR_SUCCESS) {
                if((RegDataType!=REG_BINARY)||(PrivateHashSize!=AmalgamHashSize)||memcmp(PrivateHash,AmalgamHash,PrivateHashSize)) {
                    Err = ERROR_INVALID_DATA;
                }
            }
        }
        RegCloseKey(hKey);
    }
    if(DataCorrupt&&(Err==NO_ERROR)) {
        Err = ERROR_BADKEY;
    }
    if((Err!=NO_ERROR)||(Target!=2)) {
        if(Target==2) {
            if(!LogContext) {
                CreateLogContext(NULL, TRUE, &LogContext);
            }
            if(LogContext) {
                WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_PRIVATE_HASH_INVALID,NULL);
                WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
            }
        } else {
            Target ^= 1;
        }
        RegData = Amalgam;
        for(i=0; i<2; i++, RegData=RegData>>8) {
            if(DataCorrupt||(Target==i)||((BYTE)RegData != (i?DRIVERSIGN_WARNING:DRIVERSIGN_NONE))) {
                if(Target!=2) {
                    RegRestoreVal = (BYTE)RegData;
                } else {
                    RegRestoreVal = i?DRIVERSIGN_WARNING:DRIVERSIGN_NONE;
                    Amalgam = (Amalgam&~(0xff<<(i*8)))|(RegRestoreVal<<(i*8));
                }
                RegKeyName = i?pszDrvSignPath:pszNonDrvSignPath;
                Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,RegKeyName,0,KEY_READ|KEY_WRITE,&hKey);
                if(Err == ERROR_SUCCESS) {
                    Err = RegSetValueEx(hKey,pszDrvSignPolicyValue,0,REG_BINARY,&RegRestoreVal,sizeof(RegRestoreVal));
                    RegCloseKey(hKey);
                }
                if(Target==2) {
                    if(Err == ERROR_SUCCESS) {
                        if(LogContext) {    
                            WriteLogEntry(LogContext,SETUP_LOG_WARNING,MSG_LOG_CODESIGNING_POLICY_RESTORED,NULL,(DWORD)RegRestoreVal,pszDrvSignPolicyValue,RegKeyName);
                        }
                    } else {
                        if(LogContext) {    
                            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CODESIGNING_POLICY_RESTORE_FAIL,NULL,(DWORD)RegRestoreVal,pszDrvSignPolicyValue,RegKeyName);
                            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
                        }
                    }
                }
            }
        }
        MyFree(AmalgamHash);
        Err = pSetupCalcMD5Hash(hCryptProv,(PBYTE)&Amalgam,sizeof(Amalgam),&AmalgamHash,&AmalgamHashSize);
        if(Err == NO_ERROR) {
            if((AmalgamHashSize!=PrivateHashSize)||memcmp(PrivateHash,AmalgamHash,PrivateHashSize)) {
                Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,CharBuffer,0,KEY_READ|KEY_WRITE,&hKey);
                if(Err==ERROR_SUCCESS) {
                    Err = RegSetValueEx(hKey,TEXT("PrivateHash"),0,REG_BINARY,AmalgamHash,AmalgamHashSize);
                    RegCloseKey(hKey);
                }
                if(Target==2) {
                    if(Err == ERROR_SUCCESS) {
                        if(LogContext) {    
                            WriteLogEntry(LogContext,SETUP_LOG_WARNING,MSG_LOG_PRIVATE_HASH_RESTORED,NULL);
                        }
                    } else {
                        if(LogContext) {    
                            WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_PRIVATE_HASH_RESTORE_FAIL,NULL);
                            WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
                        }
                    }
                }
            }
        } else {
            if(LogContext) {    
                WriteLogEntry(LogContext,SETUP_LOG_ERROR|SETUP_LOG_BUFFER,MSG_LOG_CRYPT_CALC_MD5_DEFAULT_HASH_FAILED,NULL);
                WriteLogError(LogContext,SETUP_LOG_ERROR,Err);
            }
        }
    }

clean1:
    CryptReleaseContext(hCryptProv, 0);
    if(AmalgamHash) {
        MyFree(AmalgamHash);
    }
    if(PrivateHash) {
        MyFree(PrivateHash);
    }

clean0:
#endif

    if(LogContext) {
        DeleteLogContext(LogContext);
    }

    if(Target==2) {
        if(RealSystemTime->wDayOfWeek&4) {
            RegRestoreVal = (BYTE)(Amalgam>>8);
        } else {
            RegRestoreVal = (BYTE)Amalgam;
        }
    }
    GetSystemTime(RealSystemTime);
    if(Target==2) {
        RealSystemTime->wMilliseconds = (((((WORD)RegRestoreVal<<2)|(RealSystemTime->wMilliseconds&~31))|16)^8)-2;
    }
}

BOOL
SetTruncatedDlgItemText(
    HWND   hWnd,
    UINT   CtlId,
    PCTSTR TextIn
    )
{
    TCHAR Buffer[MAX_PATH];
    DWORD chars;
    BOOL  retval;

    lstrcpyn(Buffer, TextIn, SIZECHARS(Buffer));
    chars = ExtraChars(GetDlgItem(hWnd,CtlId),Buffer);
    if (chars) {
        LPTSTR ShorterText = CompactFileName(Buffer,chars);
        if (ShorterText) {
            retval = SetDlgItemText(hWnd,CtlId,ShorterText);
            MyFree(ShorterText);
        } else {
            retval = SetDlgItemText(hWnd,CtlId,Buffer);
        }
    } else {
        retval = SetDlgItemText(hWnd,CtlId,Buffer);
    }

    return(retval);

}

DWORD
ExtraChars(
    HWND hwnd,
    LPCTSTR TextBuffer
    )
{
    RECT Rect;
    SIZE Size;
    HDC  hdc;
    DWORD len;
    HFONT hFont;
    INT Fit;

    hdc = GetDC( hwnd );
    if(!hdc) {
        //
        // out of resources condition
        //
        return 0;
    }
    GetWindowRect( hwnd, &Rect );
    hFont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0 );
    if (hFont != NULL) {
        SelectObject( hdc, hFont );
    }

    len = lstrlen( TextBuffer );

    if (!GetTextExtentExPoint(
        hdc,
        TextBuffer,
        len,
        Rect.right - Rect.left,
        &Fit,
        NULL,
        &Size
        )) {

        //
        // can't determine the text extents so we return zero
        //

        Fit = len;
    }

    ReleaseDC( hwnd, hdc );

    if (Fit < (INT)len) {
        return len - Fit;
    }

    return 0;
}


LPTSTR
CompactFileName(
    LPCTSTR FileNameIn,
    DWORD CharsToRemove
    )
{
    LPTSTR start;
    LPTSTR FileName;
    DWORD  FileNameLen;
    LPTSTR lastPart;
    DWORD  lastPartLen;
    DWORD  lastPartPos;
    LPTSTR midPart;
    DWORD  midPartPos;

    if (! FileNameIn) {
       return NULL;
    }

    FileName = MyMalloc( (lstrlen( FileNameIn ) + 16) * sizeof(TCHAR) );
    if (! FileName) {
       return NULL;
    }

    lstrcpy( FileName, FileNameIn );

    FileNameLen = lstrlen(FileName);

    if (FileNameLen < CharsToRemove + 3) {
       // nothing to remove
       return FileName;
    }

    lastPart = _tcsrchr(FileName, TEXT('\\') );
    if (! lastPart) {
       // nothing to remove
       return FileName;
    }

    lastPartLen = lstrlen(lastPart);

    // temporary null-terminate FileName
    lastPartPos = (DWORD) (lastPart - FileName);
    FileName[lastPartPos] = TEXT('\0');


    midPart = _tcsrchr(FileName, TEXT('\\') );

    // restore
    FileName[lastPartPos] = TEXT('\\');

    if (!midPart) {
       // nothing to remove
       return FileName;
    }

    midPartPos = (DWORD) (midPart - FileName);


    if ( ((DWORD) (lastPart - midPart) ) >= (CharsToRemove + 3) ) {
       // found
       start = midPart+1;
       start[0] = start[1] = start[2] = TEXT('.');
       start += 3;
       _tcscpy(start, lastPart);
       start[lastPartLen] = TEXT('\0');

       return FileName;
    }



    do {
       FileName[midPartPos] = TEXT('\0');

       midPart = _tcsrchr(FileName, TEXT('\\') );

       // restore
       FileName[midPartPos] = TEXT('\\');

       if (!midPart) {
          // nothing to remove
          return FileName;
       }

       midPartPos = (DWORD) (midPart - FileName);

       if ( (DWORD) ((lastPart - midPart) ) >= (CharsToRemove + 3) ) {
          // found
          start = midPart+1;
          start[0] = start[1] = start[2] = TEXT('.');
          start += 3;
          lstrcpy(start, lastPart);
          start[lastPartLen] = TEXT('\0');

          return FileName;
       }

    } while ( 1 );

}


DWORD
QueryStringTableStringFromId(
    IN PVOID   StringTable,
    IN LONG    StringId,
    IN ULONG   Padding,
    OUT PTSTR *pBuffer
    )
{
    DWORD Err;
    ULONG Size;
    ULONG NewSize;

    Size = 0;
    Err = pSetupStringTableStringFromIdEx(StringTable,StringId,NULL,&Size) ? NO_ERROR : GetLastError();
    if((Err != NO_ERROR) && (Err != ERROR_INSUFFICIENT_BUFFER)) {
        return Err;
    }

    if(!Size) {
        Size = 1;
    }

    *pBuffer = (PTSTR)MyMalloc((Size+Padding)*sizeof(TCHAR));
    if(!*pBuffer) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // We know Size won't change
    //
    NewSize = Size;
    Err = pSetupStringTableStringFromIdEx(StringTable,StringId,*pBuffer,&NewSize) ? NO_ERROR : GetLastError();
    if(Err != NO_ERROR) {
        return Err;
    }
    MYASSERT(Size >= NewSize);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\memory.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Memory handling routines for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (jamiehun) 13-Feb-1998

        Improved this further for debugging
        added linked list,
        alloc tracing,
        memory fills
        and memory leak detection

    jamiehun 30-April-1998

        Added some more consistancy checks
        Put try/except around access

    jimschm 27-Oct-1998

        Wrote fast allocation routines to speed up setupapi.dll on Win9x

--*/


#include "precomp.h"
#pragma hdrstop

//
// String to be used when displaying insufficient memory msg box.
// We load it at process attach time so we can be guaranteed of
// being able to display it.
//
PCTSTR OutOfMemoryString;


#if MEM_DBG

DWORD g_Track = 0;
PCSTR g_TrackFile = NULL;
UINT g_TrackLine = 0;

DWORD g_MemoryFlags = 0; // set this to 1 in the debugger to catch some extra dbg assertions.

DWORD g_DbgAllocNum = -1; // set g_MemoryFlags to 1 and this to the allocation number you want
                          // to catch if the same number allocation leaks every time.

VOID
SetTrackFileAndLine (
    PCSTR File,
    UINT Line
    )
{
    if (!g_Track) {
        g_TrackFile = File;
        g_TrackLine = Line;
    }

    g_Track++;
}


VOID
ClrTrackFileAndLine (
    VOID
    )
{
    if (g_Track) {
        g_Track--;
        if (!g_Track) {
            g_TrackFile = NULL;
            g_TrackLine = 0;
        }
    }
}

PVOID MyDebugMalloc(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line,
    IN DWORD Tag
    )
{
    return pSetupDebugMallocWithTag(Size,
                                    g_TrackFile ? g_TrackFile : Filename,
                                    g_TrackLine ? g_TrackLine : Line,
                                    Tag
                                    );
}

#endif

BOOL
MemoryInitializeEx(
    IN BOOL Attach
    )
{
    if (Attach) {
        OutOfMemoryString = MyLoadString(IDS_OUTOFMEMORY);
        return(OutOfMemoryString != NULL);
    } else {
        MyFree(OutOfMemoryString);

        return(TRUE);
    }
}

VOID
pSetupOutOfMemory(
    IN HWND Owner OPTIONAL
    )
{
    //
    // Don't popup a dialog if we're not running interactively...
    //
    if(!(GlobalSetupFlags & PSPGF_NONINTERACTIVE)) {

        MYASSERT(OutOfMemoryString);

        //
        // Use special combination of flags that guarantee
        // display of the message box regardless of available memory.
        //
        MessageBox(
            Owner,
            OutOfMemoryString,
            NULL,
            MB_ICONHAND | MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\mru.c ===
/*++

Copyright (c) 1993-1998 Microsoft Corporation

Module Name:

    mru.c

Abstract:

    Implementation of source list handling routines.

Author:

    Ted Miller (tedm) 30-Aug-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Location in registry where per-system MRU list is stored
// (relative to HKEY_LOCAL_MACHINE).
//
PCTSTR pszPerSystemKey = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");
PCTSTR pszPerSystemVal = TEXT("Installation Sources");
//
// Location in registry where per-user MRU list is stored.
// (relative to HKEY_CURRENT_USER).
//
PCTSTR pszPerUserKey   = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");
PCTSTR pszPerUserVal   = TEXT("Installation Sources");


typedef PTSTR *APTSTR;

//
// Platform strings we recognize.
//
PCTSTR PlatformPathComponents[] = { TEXT("\\alpha"),
                                    TEXT("\\nec98"), //NEC98
                                    TEXT("\\i386"),
                                    TEXT("\\x86"),
                                    TEXT("\\mips"),
                                    TEXT("\\ppc"),
                                    TEXT("\\axp64"),
                                    TEXT("\\ia64"),
                                    NULL
                                  };


//
// These are guarded by MruCritSect.
//
PTSTR *TemporarySourceList;
UINT TemporarySourceCount;
BOOL MruNoBrowse;

VOID
pSetupStripTrailingPlatformComponent(
    IN OUT PTSTR  *Paths,
    IN OUT PDWORD  NumPaths
    );

BOOL LockMruCritSect()
{
    BOOL locked = FALSE;
    try {
        EnterCriticalSection(&MruCritSect);
        locked = TRUE;
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }
    if(!locked) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return locked;
}

BOOL
_SetupSetSourceList(
    IN DWORD   Flags,
    IN PCTSTR *SourceList,
    IN UINT    SourceCount
    )

/*++

Routine Description:

    This routine allows the caller to set the list of installation
    sources for either the current user or the system (common to
    all users).

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that the list is to become the
            per-system list. The caller must be administrator.

        SRCLIST_USER - specify that the list is to become the per-user
            list.

        SRCLIST_TEMPORARY - specify that the list is to become the
            entire list for the duration of the current process,
            or until this routine is called again to change the behavior.

        Exactly one of SRCLIST_SYSTEM, SRCLIST_USER, and SRCLIST_TEMPORARY
        must be specified.

        SRCLIST_NOBROWSE - specify that the user is not allowed to add
            or change sources when the SetupPromptForDisk API is used.
            Typically used in combination with SRCLIST_TEMPORARY.

    SourceList - supplies array of strings that are to become the
        source list, as described by the Flags parameter.

    SourceCount - specifies number of elements in the SourceList array.

Return Value:

--*/

{
    DWORD flags;
    DWORD d;
    UINT u,v;

    //
    // Check flags. Only one of system, user, or temporary may be set.
    //
    flags = Flags & (SRCLIST_SYSTEM | SRCLIST_USER | SRCLIST_TEMPORARY);
    if((flags != SRCLIST_SYSTEM) && (flags != SRCLIST_USER) && (flags != SRCLIST_TEMPORARY)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // User must be admin for system flag to work.
    //
    if((flags == SRCLIST_SYSTEM) && !pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return(FALSE);
    }

    //
    // Only allow one thread at a time in this process to access
    // the temporary source list.
    //
    if(!LockMruCritSect()) {
        return FALSE;
    }

    if(Flags & SRCLIST_NOBROWSE) {
        MruNoBrowse = TRUE;
    }

    d = NO_ERROR;
    if(flags == SRCLIST_TEMPORARY) {

        if(TemporarySourceList) {
            SetupFreeSourceList(&TemporarySourceList,TemporarySourceCount);
        }

        //
        // Duplicate the list the caller passed in.
        //
        if(TemporarySourceList = MyMalloc(SourceCount  * sizeof(PTSTR))) {

            TemporarySourceCount = SourceCount;
            for(u=0; u<SourceCount; u++) {

                TemporarySourceList[u] = DuplicateString(SourceList[u]);
                if(!TemporarySourceList[u]) {

                    for(v=0; v<u; v++) {
                        MyFree(TemporarySourceList[v]);
                    }
                    MyFree(TemporarySourceList);
                    TemporarySourceList = NULL;
                    TemporarySourceCount = 0;

                    d = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }

        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {

        //
        // User or system.
        //
        d = pSetupSetArrayToMultiSzValue(
                (flags == SRCLIST_SYSTEM) ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                (flags == SRCLIST_SYSTEM) ? pszPerSystemKey : pszPerUserKey,
                (flags == SRCLIST_SYSTEM) ? pszPerSystemVal : pszPerUserVal,
                (PTSTR *)SourceList,
                SourceCount
                );
    }

    //
    // Done with protected resource
    //
    LeaveCriticalSection(&MruCritSect);

    SetLastError(d);
    return(d == NO_ERROR);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupSetSourceListA(
    IN DWORD   Flags,
    IN PCSTR  *SourceList,
    IN UINT    SourceCount
    )
{
    PCWSTR *sourceList;
    UINT u;
    DWORD rc;
    BOOL b;

    sourceList = MyMalloc(SourceCount*sizeof(PCWSTR));
    if(!sourceList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    ZeroMemory((PVOID)sourceList,SourceCount*sizeof(PCWSTR));

    rc = NO_ERROR;
    for(u=0; (rc==NO_ERROR) && (u<SourceCount); u++) {

        //
        // Try/except guards access to SourceList[u] in case
        // SourceList is a bad pointer
        //
        try {
            rc = pSetupCaptureAndConvertAnsiArg(SourceList[u],&sourceList[u]);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(rc == NO_ERROR) {
        b = _SetupSetSourceList(Flags,sourceList,SourceCount);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    for(u=0; u<SourceCount; u++) {
        if(sourceList[u]) {
            MyFree(sourceList[u]);
        }
    }
    MyFree(sourceList);

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupSetSourceListW(
    IN DWORD   Flags,
    IN PCWSTR *SourceList,
    IN UINT    SourceCount
    )
{
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(SourceList);
    UNREFERENCED_PARAMETER(SourceCount);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupSetSourceList(
    IN DWORD   Flags,
    IN PCTSTR *SourceList,
    IN UINT    SourceCount
    )
{
    PCTSTR *sourceList;
    UINT u;
    DWORD rc;
    BOOL b;

    sourceList = MyMalloc(SourceCount*sizeof(PCTSTR));
    if(!sourceList) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    ZeroMemory((PVOID)sourceList,SourceCount*sizeof(PCTSTR));

    rc = NO_ERROR;
    for(u=0; (rc==NO_ERROR) && (u<SourceCount); u++) {

        //
        // Try/except guards access to SourceList[u] in case
        // SourceList is a bad pointer
        //
        try {
            rc = CaptureStringArg(SourceList[u],&sourceList[u]);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(rc == NO_ERROR) {
        b = _SetupSetSourceList(Flags,sourceList,SourceCount);
        rc = GetLastError();
    } else {
        b = FALSE;
    }

    for(u=0; u<SourceCount; u++) {
        if(sourceList[u]) {
            MyFree(sourceList[u]);
        }
    }
    MyFree(sourceList);

    SetLastError(rc);
    return(b);
}


BOOL
SetupCancelTemporarySourceList(
    VOID
    )

/*++

Routine Description:

    This routine cancels any temporary list and no-browse behavior
    and reverts to standard list behavior.

Arguments:

    None.

Return Value:

    TRUE if a temporary list was in effect; FALSE if otherwise.

--*/

{
    BOOL b;

    if(!LockMruCritSect()) {
        return FALSE;
    }

    MruNoBrowse = FALSE;

    if(TemporarySourceList) {
        //
        // SetupFreeSourceList zeros out the pointer for us.
        //
        SetupFreeSourceList(&TemporarySourceList,TemporarySourceCount);
        TemporarySourceCount = 0;
        b = TRUE;
    } else {
        b = FALSE;
    }

    LeaveCriticalSection(&MruCritSect);

    return(b);
}


BOOL
_SetupAddToSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )

/*++

Routine Description:

    This routine allows the caller to append a value to the list
    of installation sources for either the current user or the system.
    If the value already exists it is removed first.

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that the source is to added to the
            per-system list. The caller must be administrator.

        SRCLIST_USER - specify that the list is to be added to the per-user
            list.

        SRCLIST_SYSIFADMIN - specifies that if the caller is administrator,
            then the source is added to the system list; if the caller
            is not administrator then the source is added to the per-user
            list for the current user.

        If a temporary list is currently in use (see SetupSetSourceList),
        these 3 flags are ignored and the source is added to the temporary list.

        SRCLIST_APPEND - specify that the source is to be added to the end
            of the given list. Otherwise it is added to the beginning.

    Source - specifies the source to be added to the list.

Return Value:

--*/

{
    APTSTR Lists[2];
    UINT Counts[2];
    UINT NumberOfLists;
    DWORD d;
    UINT u;
    PTSTR p;
    PVOID pTmp;
    HKEY RootKeys[2];
    PCTSTR SubKeys[2];
    PCTSTR Vals[2];
    BOOL NeedToFree[2];

    if(!LockMruCritSect()) {
        return FALSE;
    }

    //
    // Remove first, if present. This makes things easier for us later.
    // Do this inside the locks to ensure atomicity for the add call as
    // a whole.
    //
    if(!SetupRemoveFromSourceList(Flags,Source)) {
        d = GetLastError();
        LeaveCriticalSection(&MruCritSect);
        SetLastError(d);
        return(FALSE);
    }

    //
    // Check Temporary list first.
    //
    d = NO_ERROR;
    if(TemporarySourceList) {

        Lists[0] = TemporarySourceList;
        Counts[0] = TemporarySourceCount;
        NumberOfLists = 1;
        NeedToFree[0] = FALSE;

    } else {
        //
        // Check sysifadmin flag and turn on appropriate flag.
        //
        if(Flags & SRCLIST_SYSIFADMIN) {
            Flags |= pSetupIsUserAdmin() ? SRCLIST_SYSTEM : SRCLIST_USER;
        }

        NumberOfLists = 0;

        if(Flags & SRCLIST_SYSTEM) {

            if(pSetupIsUserAdmin()) {
                d = pSetupQueryMultiSzValueToArray(
                        HKEY_LOCAL_MACHINE,
                        pszPerSystemKey,
                        pszPerSystemVal,
                        &Lists[0],
                        &Counts[0],
                        FALSE
                        );

                if(d == NO_ERROR) {
                    NumberOfLists = 1;
                    RootKeys[0] = HKEY_LOCAL_MACHINE;
                    SubKeys[0] = pszPerSystemKey;
                    Vals[0] = pszPerSystemVal;
                    NeedToFree[0] = TRUE;
                } else {
                    Lists[0] = NULL;
                }
            } else {
                d = ERROR_ACCESS_DENIED;
            }
        }

        if((Flags & SRCLIST_USER) && (d == NO_ERROR)) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_CURRENT_USER,
                    pszPerSystemKey,
                    pszPerSystemVal,
                    &Lists[NumberOfLists],
                    &Counts[NumberOfLists],
                    FALSE
                    );

            if(d == NO_ERROR) {
                RootKeys[NumberOfLists] = HKEY_CURRENT_USER;
                SubKeys[NumberOfLists] = pszPerUserKey;
                Vals[NumberOfLists] = pszPerUserVal;
                NeedToFree[NumberOfLists] = TRUE;
                NumberOfLists++;
            } else {
                Lists[NumberOfLists] = NULL;
            }
        }
    }

    if(d == NO_ERROR) {
        //
        // Do each list.
        //
        for(u=0; (d==NO_ERROR) && (u<NumberOfLists); u++) {

            if(p = DuplicateString(Source)) {

                if(pTmp = MyRealloc(Lists[u],(Counts[u]+1)*sizeof(PTSTR))) {

                    Lists[u] = pTmp;

                    if(Flags & SRCLIST_APPEND) {

                        Lists[u][Counts[u]] = p;

                    } else {

                        MoveMemory(&Lists[u][1],Lists[u],Counts[u] * sizeof(PTSTR));
                        Lists[u][0] = p;
                    }

                    Counts[u]++;

                    //
                    // Put back in registry if necessary.
                    //
                    if(TemporarySourceList) {

                        TemporarySourceList = Lists[u];
                        TemporarySourceCount = Counts[0];

                    } else {

                        d = pSetupSetArrayToMultiSzValue(
                                RootKeys[u],
                                SubKeys[u],
                                Vals[u],
                                Lists[u],
                                Counts[u]
                                );

                        if(NeedToFree[u]) {
                            SetupFreeSourceList(&Lists[u],Counts[u]);
                        }
                    }
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }

            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    //
    // Done looking at temporary list.
    //
    //
    LeaveCriticalSection(&MruCritSect);

    SetLastError(d);
    return(d == NO_ERROR);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupAddToSourceListA(
    IN DWORD  Flags,
    IN PCSTR  Source
    )
{
    BOOL b;
    DWORD rc;
    PCWSTR source;

    rc = pSetupCaptureAndConvertAnsiArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupAddToSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupAddToSourceListW(
    IN DWORD  Flags,
    IN PCWSTR Source
    )
{
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(Source);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupAddToSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )
{
    BOOL b;
    DWORD rc;
    PCTSTR source;

    rc = CaptureStringArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupAddToSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


BOOL
_SetupRemoveFromSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )

/*++

Routine Description:

    This routine allows the caller to remove a value from the list
    of installation sources for either the current user or the system.
    The system and user lists are merged at run time.

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that the source is to removed from the
            per-system list. The caller must be administrator.

        SRCLIST_USER - specify that the list is to be removed from the
            per-user list.

        SRCLIST_SYSIFADMIN - specifies that if the caller is administrator,
            then the source is removed from the system list; if the caller
            is not administrator then the source is removed from the per-user
            list for the current user.

        Any combination of these flags may be specified on a single call.

        If a temporary list is currently in use (see SetupSetSourceList),
        these 3 flags are ignored and the source is removed from the temporary list.

        SRCLIST_SUBDIRS - specify that all subdirectories of Source are also
            to be removed. The determination of subdirectories is done based on
            a simple prefix scan.

    Source - specifies the source to be removed from the list.

Return Value:

--*/

{
    APTSTR Lists[2];
    UINT Counts[2];
    UINT NumberOfLists;
    DWORD d;
    BOOL NeedToFree;
    UINT u,v;
    PTSTR p;
    BOOL Match;
    UINT Len;
    PVOID pTmp;

    p = DuplicateString(Source);
    if(!p) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    CharUpper(p);
    Len = lstrlen(p);

    if(!LockMruCritSect()) {
        MyFree(p);
        return FALSE;
    }

    //
    // Check Temporary list first.
    //
    d = NO_ERROR;
    if(TemporarySourceList) {

        Lists[0] = TemporarySourceList;
        Counts[0] = TemporarySourceCount;
        NumberOfLists = 1;
        NeedToFree = FALSE;

    } else {
        //
        // Check sysifadmin flag and turn on appropriate flag.
        //
        if(Flags & SRCLIST_SYSIFADMIN) {
            Flags |= pSetupIsUserAdmin() ? SRCLIST_SYSTEM : SRCLIST_USER;
        }

        NeedToFree = TRUE;
        NumberOfLists = 0;

        if(Flags & SRCLIST_SYSTEM) {

            if(pSetupIsUserAdmin()) {
                d = pSetupQueryMultiSzValueToArray(
                        HKEY_LOCAL_MACHINE,
                        pszPerSystemKey,
                        pszPerSystemVal,
                        &Lists[0],
                        &Counts[0],
                        FALSE
                        );

                if(d == NO_ERROR) {
                    NumberOfLists = 1;
                } else {
                    Lists[0] = NULL;
                }
            } else {
                d = ERROR_ACCESS_DENIED;
            }
        }

        if((Flags & SRCLIST_USER) && (d == NO_ERROR)) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_CURRENT_USER,
                    pszPerSystemKey,
                    pszPerSystemVal,
                    &Lists[NumberOfLists],
                    &Counts[NumberOfLists],
                    FALSE
                    );

            if(d == NO_ERROR) {
                NumberOfLists++;
            } else {
                Lists[NumberOfLists] = NULL;
            }
        }
    }

    if(d == NO_ERROR) {
        //
        // Go through each list.
        //
        for(u=0; u<NumberOfLists; u++) {

            //
            // Go though each item in the current list.
            //
            for(v=0; v<Counts[u]; v++) {

                CharUpper(Lists[u][v]);

                //
                // See if this item matches the one being deleted.
                //
                Match = FALSE;
                if(Flags & SRCLIST_SUBDIRS) {
                    //
                    // See if the source the caller passed in is
                    // a prefix of the source in the list.
                    //
                    Match = (_tcsncmp(Lists[u][v],p,Len) == 0);
                } else {
                    Match = (lstrcmp(Lists[u][v],p) == 0);
                }

                if(Match) {
                    //
                    // Need to remove this item.
                    //
                    MyFree(Lists[u][v]);

                    MoveMemory(
                        &Lists[u][v],
                        &Lists[u][v+1],
                        (Counts[u] - (v+1)) * sizeof(PTSTR)
                        );

                    Counts[u]--;
                    v--;
                }
            }
        }

        if(TemporarySourceList) {
            //
            // Shrink temporary source list down to new size.
            // Since we're shrinking we don't expect the realloc to fail
            // but it's not an error if it does.
            //
            if(pTmp = MyRealloc(Lists[0],Counts[0]*sizeof(PTSTR))) {
                TemporarySourceList = pTmp;
            }
            TemporarySourceCount = Counts[0];
         } else {
            //
            // Need to put stuff back in registry.
            //
            u=0;
            if(Flags & SRCLIST_SYSTEM) {

                d = pSetupSetArrayToMultiSzValue(
                        HKEY_LOCAL_MACHINE,
                        pszPerSystemKey,
                        pszPerSystemVal,
                        Lists[0],
                        Counts[0]
                        );

                u++;
            }

            if((d == NO_ERROR) && (Flags & SRCLIST_USER)) {

                d = pSetupSetArrayToMultiSzValue(
                        HKEY_CURRENT_USER,
                        pszPerUserKey,
                        pszPerUserVal,
                        Lists[u],
                        Counts[u]
                        );
                u++;
            }
        }
    }

    //
    // Done looking at temporary list.
    //
    //
    LeaveCriticalSection(&MruCritSect);

    if(NeedToFree) {
        for(u=0; u<NumberOfLists; u++) {
            if(Lists[u]) {
                SetupFreeSourceList(&Lists[u],Counts[u]);
            }
        }
    }

    MyFree(p);
    SetLastError(d);
    return(d == NO_ERROR);
}

#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupRemoveFromSourceListA(
    IN DWORD  Flags,
    IN PCSTR  Source
    )
{
    PCWSTR source;
    BOOL b;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupRemoveFromSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupRemoveFromSourceListW(
    IN DWORD  Flags,
    IN PCWSTR Source
    )
{
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(Source);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupRemoveFromSourceList(
    IN DWORD  Flags,
    IN PCTSTR Source
    )
{
    PCTSTR source;
    BOOL b;
    DWORD rc;

    rc = CaptureStringArg(Source,&source);
    if(rc == NO_ERROR) {
        b = _SetupRemoveFromSourceList(Flags,source);
        rc = GetLastError();
        MyFree(source);
    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupQuerySourceListA(
    IN  DWORD   Flags,
    OUT PCSTR **List,
    OUT PUINT   Count
    )
{
    PCWSTR *list;
    UINT count;
    BOOL b;
    DWORD d;
    PSTR *ansilist;
    UINT i;

    b = SetupQuerySourceListW(Flags,&list,&count);
    d = GetLastError();

    if(b) {

        if(ansilist = MyMalloc(count * sizeof(PCSTR))) {

            ZeroMemory(ansilist,count*sizeof(PCSTR));

            for(i=0; i<count; i++) {

                ansilist[i] = pSetupUnicodeToAnsi(list[i]);
                if(!ansilist[i]) {
                    SetupFreeSourceListA(&ansilist,count);
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    b = FALSE;
                    break;
                }
            }

            if(b) {
                //
                // Everything's ok, set up caller's out params.
                //
                try {
                    *Count = count;
                    *List = ansilist;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    SetupFreeSourceListA(&ansilist,count);
                    d = ERROR_INVALID_PARAMETER;
                    b = FALSE;
                }
            }

        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
        }

        SetupFreeSourceListW(&list,count);
    }

    SetLastError(d);
    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupQuerySourceListW(
    IN  DWORD    Flags,
    OUT PCWSTR **List,
    OUT PUINT    Count
    )
{
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(List);
    UNREFERENCED_PARAMETER(Count);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

BOOL
SetupQuerySourceList(
    IN  DWORD    Flags,
    OUT PCTSTR **List,
    OUT PUINT    Count
    )

/*++

Routine Description:

    This routine allows the caller to query the current list of installation
    sources. The list is built from the system and user-specific lists,
    potentially overridden by a temporary list (see SetupSetSourceList).

Arguments:

    Flags - a combination of the following values:

        SRCLIST_SYSTEM - specify that only the system list is desired.

        SRCLIST_USER - specify that only the per-user list is desired.

        SRCLIST_SYSIFADMIN - Same as SRCLIST_SYSTEM. Accepted only for
            compatibility.

        If none of these flags is specified then the current (merged) list is
        returned in its entirety.

        SRCLIST_NOSTRIPPLATFORM - Normally, all paths are stripped of a platform-
            specific component if that component is the final one. IE, a path
            stored in the registry as f:\mips will come back as f:\. If this flag
            is specified, this behavior is turned off.

    List - receives a pointer to an array of sources. The caller must free this
        with SetupFreeSourceList.

    Count - receives the number of sources.

Return Value:

--*/

{
    DWORD d;
    PTSTR *Values1 = NULL;
    UINT NumVals1 = 0;
    PTSTR *Values2 = NULL;
    UINT NumVals2 = 0;
    UINT TotalVals;
    UINT u,v;
    BOOL Found;
    PTSTR *p;
    BOOL StripPlatform;

    //
    // Either caller wants sysifadmin, or he wants some combination of
    // system and user lists.
    //
    if((Flags & SRCLIST_SYSIFADMIN) && (Flags & (SRCLIST_SYSTEM | SRCLIST_USER))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(!LockMruCritSect()) {
        return FALSE;
    }

    //
    // If sysifadmin, figure out which list to get.
    //
    if(Flags & SRCLIST_SYSIFADMIN) {
        //
        // Changed behavior to basically ignore this flag,
        // since setup doesn't record the system source in the per-user
        // mru list any more since this gets messy for upgrades.
        //
        //Flags = pSetupIsUserAdmin() ? SRCLIST_SYSTEM : SRCLIST_USER;
        Flags = SRCLIST_SYSTEM;

    } else {
        //
        // if no flags are specified, turn on system and user unless
        // there's a temporary list.
        //
        if(!Flags && !TemporarySourceList) {
            Flags = SRCLIST_SYSTEM | SRCLIST_USER;
        }
    }

    StripPlatform = ((Flags & SRCLIST_NOSTRIPPLATFORM) == 0);

    if(!Flags) {
        //
        // Temporary list in use.
        //
        d = NO_ERROR;
        if(Values1 = MyMalloc(TemporarySourceCount * sizeof(PTSTR))) {

            for(u=0; u<TemporarySourceCount; u++) {

                Values1[u] = DuplicateString(TemporarySourceList[u]);
                if(!Values1[u]) {
                    d = ERROR_NOT_ENOUGH_MEMORY;

                    for(v=0; v<u; v++) {
                        MyFree(Values1[v]);
                    }
                    MyFree(Values1);
                    break;
                }
            }

            if(d == NO_ERROR) {

                try {
                    *List = Values1;
                    *Count = TemporarySourceCount;
                } except(EXCEPTION_EXECUTE_HANDLER) {
                    d = ERROR_INVALID_PARAMETER;
                }
            }

        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {
        //
        // Fetch system list if desired.
        //
        if(Flags & SRCLIST_SYSTEM) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_LOCAL_MACHINE,
                    pszPerSystemKey,
                    pszPerSystemVal,
                    &Values1,
                    &NumVals1,
                    FALSE
                    );

            //
            // If we are supposed to, strip out platform-specific
            // trailing components.
            //
            if((d == NO_ERROR) && StripPlatform) {
                pSetupStripTrailingPlatformComponent(Values1,&NumVals1);
            } else if (d != NO_ERROR) {
                //
                // Create dummy array.
                //
                NumVals1 = 0;
                if(Values1 = MyMalloc(0)) {
                    d = NO_ERROR;
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

        } else {
            //
            // Create dummy array.
            //
            NumVals1 = 0;
            if(Values1 = MyMalloc(0)) {
                d = NO_ERROR;
            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Fetch user list if desired.
        //
        if((d == NO_ERROR) && (Flags & SRCLIST_USER)) {

            d = pSetupQueryMultiSzValueToArray(
                    HKEY_CURRENT_USER,
                    pszPerUserKey,
                    pszPerUserVal,
                    &Values2,
                    &NumVals2,
                    FALSE
                    );

            if((d == NO_ERROR) && StripPlatform) {
                pSetupStripTrailingPlatformComponent(Values2,&NumVals2);
            }

        } else if(Values1) {
            //
            // Create dummy array.
            //
            NumVals2 = 0;
            if(Values2 = MyMalloc(0)) {
                d = NO_ERROR;
            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else {
            NumVals2 = 0;
            Values2 = NULL;
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        TotalVals = NumVals1;

        if(d == NO_ERROR) {

            //
            // Merge lists. Favor the system list.
            // We iterate through the user list. For each item in the user list,
            // we look for it in the system list. If not found, we append to the system list.
            // The system list becomes the final list.
            //
            for(u=0; (d == NO_ERROR) && (u<NumVals2); u++) {

                //
                // Look for the current per-user path in the per-system
                // list. If not found, append to end of system list.
                //
                Found = FALSE;
                for(v=0; v<NumVals1; v++) {
                    if(!lstrcmpi(Values1[v],Values2[u])) {
                        Found = TRUE;
                        break;
                    }
                }

                if(!Found) {

                    if(p = MyRealloc(Values1,(TotalVals+1)*sizeof(PTSTR))) {

                        Values1 = p;
                        if(Values1[TotalVals] = DuplicateString(Values2[u])) {
                            TotalVals++;
                        } else {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }

                    } else {
                        d = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }

            if(d == NO_ERROR) {
                //
                // Ensure that there's at least one item in the list.
                //
                if(TotalVals) {
                    try {
                        *List = Values1;
                        *Count = TotalVals;
                        Values1 = NULL; // no longer ours to free
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        d = ERROR_INVALID_PARAMETER;
                    }
                } else {
                    try {
                        if(*List = MyMalloc(sizeof(PTSTR))) {
                            if(**List = DuplicateString(TEXT("A:\\"))) {
                                *Count = 1;
                            } else {
                                MyFree(*List);
                                d = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        } else {
                            d = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        //
                        // Note there is a tiny window for a memory leak here,
                        // if List pointer went bad between the MyMalloc
                        // and the DuplicateString. Oh well.
                        //
                        d = ERROR_INVALID_PARAMETER;
                    }
                }
            }
        }
        if (Values1) {
            for(u=0; u<TotalVals; u++) {
                if(Values1[u]) {
                    MyFree(Values1[u]);
                }
            }
            MyFree(Values1);
        }
        if (Values2) {
            for(u=0; u<NumVals2; u++) {
                MyFree(Values2[u]);
            }
            MyFree(Values2);
        }
    }

    LeaveCriticalSection(&MruCritSect);

    SetLastError(d);
    return(d == NO_ERROR);
}


BOOL
SetupFreeSourceListA(
    IN OUT PCSTR **List,
    IN     UINT    Count
    )
{
    //
    // Not really ansi/unicode specific
    //
    return(SetupFreeSourceListW((PCWSTR **)List,Count));
}

BOOL
SetupFreeSourceListW(
    IN OUT PCWSTR **List,
    IN     UINT     Count
    )

/*++

Routine Description:

    This routine frees a source list as returned by SetupQuerySourceList.

Arguments:

Return Value:

--*/

{
    UINT u;
    BOOL b;
    PCWSTR *list;

    b = TRUE;
    try {
        list = *List;
        for(u=0; u<Count; u++) {
            if(list[u]) {
                MyFree(list[u]);
            }
        }
        MyFree(list);
        *List = NULL;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }

    return(b);
}

DWORD
pSetupGetList(
    IN  DWORD    Flags,
    OUT PCTSTR **List,
    OUT PUINT    Count,
    OUT PBOOL    NoBrowse
    )
{
    DWORD d;

    if(!LockMruCritSect()) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *NoBrowse = MruNoBrowse;

    d = SetupQuerySourceList(Flags,List,Count) ? NO_ERROR : GetLastError();

    LeaveCriticalSection(&MruCritSect);

    return(d);
}


PTSTR
pSetupGetDefaultSourcePath(
    IN  HINF   InfHandle,
    IN  DWORD  Flags,

    OUT PDWORD InfSourceMediaType
    )
/*++

Routine Description:

    This routine returns the default path string to be used for the
    specified INF.  It also returns the type of path, either a normal
    file path or a URL.

    The caller must free the string returned (if any) via MyFree.

Arguments:

    InfHandle - Supplies a handle to the INF whose default source path
        is to be retrieved.

    Flags
        - if SRCPATH_USEINFLOCATION bit is set, then return the directory
        where the INF is located (with a source media type of SPOST_PATH)
        in the case where either (a) the PNF has no source media information,
        or (b) the PNF has SPOST_URL information.
        - if SRCPATH_USEPNFINFORMATION bit is set, then the actual PNF
        information (whether path or URL) is returned, and if the PNF
        has no source media information, then the system source path is
        returned.

    InfSourceMediaType - Supplies the address of a variable that receives
        the type of path returned.  May be one of the following values:

        SPOST_PATH - Standard file path

        SPOST_URL - Internet path

Return Value:

    If InfSourceMediaType is returned as SPOST_PATH, then a path will
    always be returned, unless we're out of memory (or, if
    DefaultPathIsInfLocation is TRUE, another possibility is that we hit an
    exception).  GetLastError() may be used in this case to indicate the cause of
    failure).

    If InfSourceMediaType is returned as SPOST_URL, then the return value
    will be NULL if the default Code Download Manager URL is used (or if we ran
    out of memory), otherwise it will be the specific URL to be used.

    In either case, GetLastError() may be called to determine the cause of
    failure (in the case of SPOST_URL for a NULL InfSourceMediaType,
    GetLastError() will return NO_ERROR if we didn't fail (i.e., we meant to
    return NULL because the INF came from the CDM website).

--*/
{
    PTSTR InfSourcePath = NULL, p;
    DWORD Err;

    *InfSourceMediaType = SPOST_PATH;
    Err = NO_ERROR;

    //
    // Lock the INF, so that we can get it's 'InfSourcePath' value, if present.
    //
    if(LockInf((PLOADED_INF)InfHandle)) {

        try {

            if(((PLOADED_INF)InfHandle)->InfSourcePath) {
                InfSourcePath = DuplicateString(((PLOADED_INF)InfHandle)->InfSourcePath);
                if(!InfSourcePath) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            *InfSourceMediaType = ((PLOADED_INF)InfHandle)->InfSourceMediaType;

            if(Flags & SRCPATH_USEINFLOCATION) {
                //
                // Caller has requested that we default to the INF's source
                // location when there's no SPOST_PATH info.
                //
                if(*InfSourceMediaType != SPOST_PATH) {
                    if(InfSourcePath) {
                        MyFree(InfSourcePath);
                        InfSourcePath = NULL;
                    }
                    *InfSourceMediaType = SPOST_PATH;
                }

                if(!InfSourcePath) {
                    //
                    // Don't have an INF source path--use the INF's present
                    // location.
                    //
                    InfSourcePath = DuplicateString(((PLOADED_INF)InfHandle)->VersionBlock.Filename);

                    if(InfSourcePath) {
                        //
                        // OK, we duplicated the INF's full pathname, now
                        // truncate it to just the path part.
                        //
                        p = (PTSTR)pSetupGetFileTitle(InfSourcePath);
                        *p = TEXT('\0');

                        if(((p - InfSourcePath) != 3) ||
                           lstrcmp(CharNext(InfSourcePath), TEXT(":\\"))) {
                            //
                            // The path is not an "A:\" type path, so truncate
                            //
                            p = CharPrev(InfSourcePath, p);
                            MYASSERT(*p == TEXT('\\'));
                            if(p > InfSourcePath) {
                                *p = TEXT('\0');
                            }
                        }

                    } else {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }
            }

clean0: ; // nothing to do.

        } except(EXCEPTION_EXECUTE_HANDLER) {
            if(InfSourcePath) {
                MyFree(InfSourcePath);
                InfSourcePath = NULL;
            }
            Err = ERROR_INVALID_PARAMETER;
        }

        UnlockInf((PLOADED_INF)InfHandle);
    }

    if((Flags & SRCPATH_USEINFLOCATION) && !InfSourcePath) {
        //
        // We either hit out of memory or an exception--make sure media type
        // specifies SPOST_PATH before returning failure.
        //
        *InfSourceMediaType = SPOST_PATH;
        MYASSERT(Err != NO_ERROR);
        SetLastError(Err);
        return NULL;
    }

    if(!InfSourcePath && (*InfSourceMediaType == SPOST_PATH) && (Flags & SRCPATH_USEPNFINFORMATION)) {
        //
        // There's not an oem location associated with this INF, so use our default
        // source path.
        //
        InfSourcePath = DuplicateString(SystemSourcePath);
        if(!InfSourcePath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SetLastError(Err);
    return InfSourcePath;
}


VOID
pSetupStripTrailingPlatformComponent(
    IN OUT PTSTR  *Paths,
    IN OUT PDWORD  NumPaths
    )
{
    PTSTR Path;
    DWORD PathCount;
    DWORD NewPathCount;
    DWORD PathIndex;
    DWORD DupIndex;
    DWORD FirstIndex;
    DWORD HoleCount;
    PCTSTR Component;
    UINT ComponentLength;
    UINT PathLength;
    int ComponentOffset;
    UINT ComponentIndex;

    //
    // Do this for all paths in the array passed in by the caller.
    //
    PathCount = *NumPaths;
    for(PathIndex=0; PathIndex<PathCount; PathIndex++) {

        Path = Paths[PathIndex];
        if(!Path) {
            //
            // skip holes
            //
            continue;
        }

        //
        // See if the final path component matches one of the ones
        // we care about.
        //
        PathLength = lstrlen(Path);

        for(ComponentIndex=0; PlatformPathComponents[ComponentIndex]; ComponentIndex++) {

            Component = PlatformPathComponents[ComponentIndex];
            ComponentLength = lstrlen(Component);

            ComponentOffset = PathLength - ComponentLength;

            if((ComponentOffset > 0) && (lstrcmpi(Path+ComponentOffset,Component)==0)) {
                //
                // Got a match. Strip off the final component.
                // Leave a trailing backslash if we're dealing with the root.
                //
                Path[ComponentOffset] = TEXT('\0');
                if((Path[1] == TEXT(':')) && !Path[2]) {

                    Path[2] = TEXT('\\');
                    Path[3] = 0;
                }

                //
                // Remove duplicate, preserving the first instance
                //
                for(FirstIndex=0 ; FirstIndex<PathIndex ; FirstIndex++) {

                    if(lstrcmpi(Paths[FirstIndex],Path) == 0) {
                        //
                        // we've found first instance
                        // and it's earlier than PathIndex
                        // so we'll end up deleting entry at PathIndex
                        Path = Paths[FirstIndex];
                        break;
                    }
                }
                for(DupIndex = FirstIndex+1;DupIndex<PathCount;DupIndex++) {
                    if(lstrcmpi(Paths[DupIndex],Path) == 0) {
                        //
                        // eliminate duplicate
                        //
                        MyFree(Paths[DupIndex]);
                        Paths[DupIndex] = NULL; // new hole - handle holes later
                    }
                }
                //
                // only strip one component
                //
                break;
            }
        }
    }
    //
    // now fix up 'holes' preserving order
    //
    HoleCount = 0;
    for(PathIndex=0; PathIndex<PathCount; PathIndex++) {
        if(!Paths[PathIndex]) {
            //
            // count holes
            //
            HoleCount++;
        } else if(HoleCount) {
            //
            // shift down by number of holes found
            //
            Paths[PathIndex-HoleCount] = Paths[PathIndex];
        }
    }
    NewPathCount = PathCount-HoleCount;
    for(PathIndex = PathCount; PathIndex < NewPathCount; PathIndex++) {
        Paths[PathIndex] = NULL;
    }

    *NumPaths = NewPathCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\logapi.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    logapi.c

Abstract:

    Public exposure of an error logging API, based on windows\setup\setuplog.

Author:

    Jim Schmidt (jimschm) 28-Apr-1997

Revision History:

    jimschm     16-Dec-1998     Added UseCountCs (duh!!)

--*/

#include "precomp.h"

#include <setuplog.h>

SETUPLOG_CONTEXT LogContext;
INT UseCount;

#define MAX_STRING_RESOURCE   0x08000



//
// NOTE: Watch the case.  We expose an API named SetupLogError, which is different than
//       the lib-based SetuplogError function.
//


LPSTR
pUnicodeToAnsiForDisplay (
    PCWSTR UnicodeStr
    )
{
    INT Len;
    LPSTR AnsiBuffer;
    CHAR CodePage[32];
    DWORD rc;

    //
    // Allocate buffer to be freed by caller
    //

    Len = (lstrlenW (UnicodeStr) + 1) * sizeof (WCHAR);

    AnsiBuffer = (LPSTR) MyMalloc (Len);
    if (!AnsiBuffer) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    //
    // Convert to UNICODE based on thread's Locale; convert assuming string
    // is for display purposes
    //

    if (!GetLocaleInfoA (GetThreadLocale(), LOCALE_IDEFAULTANSICODEPAGE, CodePage, 32)) {
        MyFree (AnsiBuffer);
        return NULL;
    }

    rc = WideCharToMultiByte (
            atoi (CodePage),
            WC_COMPOSITECHECK|WC_DISCARDNS,
            UnicodeStr,
            -1,
            AnsiBuffer,
            Len,
            NULL,
            NULL
            );

    if (rc == 0) {
        MyFree (AnsiBuffer);
        return NULL;
    }

    return AnsiBuffer;
}


PWSTR
pAnsiToUnicodeForDisplay (
    LPCSTR AnsiStr
    )
{
    INT Len;
    LPWSTR UnicodeBuffer;
    CHAR CodePage[32];
    DWORD rc;

    //
    // Allocate buffer to be freed by caller
    //

    Len = (lstrlenA (AnsiStr) + 1) * sizeof (WCHAR);

    UnicodeBuffer = (LPWSTR) MyMalloc (Len);
    if (!UnicodeBuffer) {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    //
    // Convert to UNICODE based on thread's Locale
    //

    if (!GetLocaleInfoA (GetThreadLocale(), LOCALE_IDEFAULTANSICODEPAGE, CodePage, 32)) {
        MyFree (UnicodeBuffer);
        return NULL;
    }

    rc = MultiByteToWideChar (
            atoi (CodePage),
            MB_USEGLYPHCHARS,
            AnsiStr,
            -1,
            UnicodeBuffer,
            Len
            );

    if (rc == 0) {
        MyFree (UnicodeBuffer);
        return NULL;
    }

    return UnicodeBuffer;
}


PVOID
pOpenFileCallback (
    IN  LPCTSTR  Filename,
    IN  BOOL     WipeLogFile
    )

/*++

Routine Description:

    Opens the log and optionally overwrites an existing copy.

Arguments:

    FileName    - Specifies the name of the file to open or create

    WipeLogFile - TRUE if an existing log should be overwritten, FALSE if
                  it should be appended

Return Value:

    Pointer to the file handle.

--*/


{
    TCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Form the pathname of the logfile. (uses real Windows directory)
    //
    lstrcpyn(CompleteFilename,WindowsDirectory,SIZECHARS(CompleteFilename));
    if (!pSetupConcatenatePaths (CompleteFilename, Filename, SIZECHARS(CompleteFilename), NULL)) {
        return NULL;
    }

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes (CompleteFilename, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile (
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}


static
BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log by converting string to ANSI and
    calling WriteFile.  The message is appended to the log.

Arguments:

    LogFile  - The handle to an open log file
    Buffer   - The UNICODE message to write

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/


{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   DontCare;

    if (0xffffffff == SetFilePointer (LogFile, 0, NULL, FILE_END)) {
        return FALSE;
    }

#ifdef UNICODE

    //
    // Convert to ANSI for file output
    //

    if (AnsiBuffer = pUnicodeToAnsiForDisplay (Buffer)) {
        Status = WriteFile (
                    LogFile,
                    AnsiBuffer,
                    lstrlenA (AnsiBuffer),
                    &DontCare,
                    NULL
                    );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

#else

    Status = WriteFile (
                LogFile,
                Buffer,
                lstrlen (Buffer),
                &DontCare,
                NULL
                );

#endif

    if (Status) {
        FlushFileBuffers (LogFile);
    }

    return Status;

}


static
LPTSTR
pFormatLogMessage (
    IN LPCTSTR   MessageString,
    IN UINT      MessageId,      OPTIONAL
    IN va_list * ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    This routine supports only MessageIds that are Win32 error codes.  It
    does not support messages for string resources.

Arguments:

    MessageString - Supplies the message text.  For logapi.c, this should
                    always be non-NULL.

    MessageId - Supplies a Win32 error code, or 0 if MessageString is to be
                used.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    LPTSTR Buffer;
    LPTSTR Message;
    TCHAR  ModuleName[MAX_PATH];
    TCHAR  ErrorNumber[24];
    LPTSTR Args[2];

    if (MessageString > (LPCTSTR) SETUPLOG_USE_MESSAGEID) {
        d = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                MessageString,
                0,
                0,
                (LPTSTR) &Buffer,
                0,
                ArgumentList
                );
    } else {
        d = FormatMessage (
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    ((MessageId < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE),
                (PVOID) GetModuleHandle (NULL),
                MessageId,
                MAKELANGID (LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (LPTSTR) &Buffer,
                0,
                ArgumentList
                );
    }


    if(!d) {
        //
        // Give up.
        //
        return NULL;
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = DuplicateString (Buffer);

    LocalFree ((HLOCAL) Buffer);

    return Message;
}


static
BOOL
pAcquireMutex (
    IN  PVOID   Mutex
    )

/*++

Routine Description:

    Waits on the log mutex for a max of 1 second, and returns TRUE if the mutex
    was claimed, or FALSE if the claim timed out.

Arguments:

    Mutex - specifies which mutex to acquire.

Return Value:

    TRUE if the mutex was claimed, or FALSE if the claim timed out.

--*/


{
    DWORD rc;

    if (!Mutex) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Wait a max of 1 second for the mutex
    rc = WaitForSingleObject (Mutex, 1000);
    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_EXCL_SEM_ALREADY_OWNED);
        return FALSE;
    }

    return TRUE;
}



BOOL
WINAPI
SetupOpenLog (
    BOOL Erase
    )

/*++

Routine Description:

    Opens the log for processing.  Must be called before SetupLogError is called.
    A use count is maintained so a single process can call SetupOpenLog and
    SetupCloseLog from multiple threads.

Arguments:

    Erase - TRUE to erase an existing log, or FALSE to append to an existing log

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/

{
    BOOL b = TRUE;
    INT i;
    DWORD rc;
    BOOL locked = FALSE;


    __try {
        EnterCriticalSection (&LogUseCountCs);
        locked = TRUE;
        //
        // Perform initialization of log APIs
        //

        if (!UseCount) {
            LogContext.OpenFile  = (PSPLOG_OPENFILE_ROUTINE) pOpenFileCallback;
            LogContext.CloseFile = CloseHandle;
            LogContext.AllocMem  = pSetupMalloc;
            LogContext.FreeMem   = pSetupFree;
            LogContext.Format    = (PSPLOG_FORMAT_ROUTINE) pFormatLogMessage;
            LogContext.Write     = (PSPLOG_WRITE_ROUTINE) pWriteFile;
            LogContext.Lock      = pAcquireMutex;
            LogContext.Unlock    = ReleaseMutex;

            LogContext.Mutex = CreateMutexW(NULL,FALSE,L"SetuplogMutex");

            for (i = 0 ; i < LogSevMaximum ; i++) {
                LogContext.SeverityDescriptions[i] = MyLoadString (IDS_LOGSEVINFORMATION + i);
            }

            //
            // We don't want to allow anyone to erase the existing log, so we just
            // ignore the value of Erase and always append to the log.
            //
            b = SetuplogInitialize (&LogContext, FALSE);
            rc = GetLastError();

        } else {
            rc = ERROR_ALREADY_INITIALIZED;
        }

        UseCount++;
    }
    __finally {
        //
        // Clean up and exit
        //

        if (!b) {
            SetupCloseLog();
        }

        SetLastError (rc);
        if(locked) {
            LeaveCriticalSection (&LogUseCountCs);
        }
    }

    return b;
}


VOID
WINAPI
SetupCloseLog (
    VOID
    )

/*++

Routine Description:

    Cleans up all resources associated with the log

Arguments:

    none

Return Value:

    none

--*/


{
    INT i;
    BOOL locked=FALSE;


    __try {
        EnterCriticalSection (&LogUseCountCs);
        locked = TRUE;
        if (!UseCount) {
            __leave;
        }

        UseCount--;
        if (!UseCount) {
            if(LogContext.Mutex) {
                CloseHandle(LogContext.Mutex);
                LogContext.Mutex = NULL;
            }

            for (i=0; i<LogSevMaximum; i++) {
                if (LogContext.SeverityDescriptions[i]) {
                    MyFree (LogContext.SeverityDescriptions[i]);
                }
            }

            SetuplogTerminate();
        }
    }
    __finally {
        if(locked) {
            LeaveCriticalSection (&LogUseCountCs);
        }
    }
}


BOOL
WINAPI
SetupLogErrorA (
    IN  PCSTR               MessageString,
    IN  LogSeverity         Severity
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log.  If we're being compiled UNICODE,
    we convert the MessageString to UNICODE and call SetupLogErrorW.  If we're
    being compiled ANSI, we call the log API directly.

Arguments:

    MessageString       - Pointer to a buffer containing unformatted message text

    Severity            - Severity of the error:

                          LogSevInformation
                          LogSevWarning
                          LogSevError
                          LogSevFatalError

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/

{
    INT Len;
    PWSTR UnicodeBuffer;
    BOOL b = FALSE;
    CHAR CodePage[32];
    DWORD rc;

    __try {

        if (!UseCount) {
            rc = ERROR_FILE_INVALID;
        } else {

#ifdef UNICODE
            UnicodeBuffer = pAnsiToUnicodeForDisplay (MessageString);

            //
            // Call UNICODE version of the log API, preserve error code
            //

            if (UnicodeBuffer) {
                b = SetupLogErrorW (UnicodeBuffer, Severity);
                rc = GetLastError();
                MyFree (UnicodeBuffer);
            } else {
                rc = GetLastError();
            }

#else
            //
            // ANSI version -- call SetuplogError directly
            //

            b = SetuplogError (Severity, "%1", 0, MessageString, 0, 0);
            rc = GetLastError();

#endif
        }
    }

    __except (TRUE) {
        //
        // If caller passes in bogus pointer, fail with invalid parameter error
        //

        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    SetLastError(rc);
    return b;
}



BOOL
WINAPI
SetupLogErrorW (
    IN  PCWSTR              MessageString,
    IN  LogSeverity         Severity
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log.  If compiled with UNICODE, we call the
    SetuplogError function directly.  If compiled with ANSI, we convert to ANSI
    and call SetupLogErrorA.

Arguments:

    MessageString       - Pointer to a buffer containing unformatted message text

    Severity            - Severity of the error:

                          LogSevInformation
                          LogSevWarning
                          LogSevError
                          LogSevFatalError

Return Value:

    Boolean indicating whether the operation was successful.  Error code is set
    to a Win32 error code if the return value is FALSE.

--*/

{
    BOOL b = FALSE;
    PCSTR AnsiBuffer;
    DWORD rc;

    __try {

        if (!UseCount) {
            rc = ERROR_FILE_INVALID;
        } else {

#ifdef UNICODE
            //
            // UNICODE version: Call SetuplogError directly
            //

            // Log the error -- we always link to a UNICODE SetuplogError, despite the TCHAR header file
            b = SetuplogError (Severity, L"%1", 0, MessageString, 0, 0);
            rc = GetLastError();

#else
            //
            // ANSI version: Convert down to ANSI, then call SetupLogErrorA
            //

            AnsiBuffer = pUnicodeToAnsiForDisplay (MessageString);

            if (AnsiBuffer) {
                b = SetupLogErrorA (AnsiBuffer, Severity);
                rc = GetLastError();
                MyFree (AnsiBuffer);
            } else {
                rc = GetLastError();
            }

#endif
        }
    }
    __except (TRUE) {
        rc = ERROR_INVALID_PARAMETER;
        b = FALSE;
    }

    SetLastError(rc);
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\ntcab.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntcab.c

Abstract:

    NTCab compression support.

Author:

    Ted Miller (tedm) 31-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


BOOL
NtCabNotifyFunction(
    IN PNTCAB_ENUM_DATA EnumData,
    IN PVOID            Cntxt
    )
{
    PNTCABCONTEXT Context = Cntxt;
    BOOL rc;
    DWORD Operation;
    PSTR FileNameA;
    CABINET_INFO CabInfo;
    FILE_IN_CABINET_INFO FileInCab;
    FILETIME FileTime, UtcTime;
    TCHAR NewPath[MAX_PATH];
    PTSTR p;



    rc = ((PSP_NTCAB_CALLBACK)Context->MsgHandler)( EnumData, Context, &Operation );

    if (rc == ERROR_REQUEST_ABORTED) {
        //
        // this means stop making callback
        //
        return(FALSE);
    }
#if 0
    switch(Operation) {

        case FILEOP_SKIP:
            //
            // do nothing
            //
            ;
            break;

        case FILEOP_DOIT:
            ;
            break;

        default:
            //
            // Abort.
            //
            return(FALSE);

            break;
    }
#endif

    return(TRUE);


}

#ifdef UNICODE

DWORD
NtCabProcessCabinet(
    //IN PVOID  InCabHandle, OPTIONAL
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )

/*++

Routine Description:

    Process an ntcab file, iterating through all files
    contained within it and calling the callback function with
    information about each file.

Arguments:

    CabHandle      - supplies a handle to the cab file, if it already exists,
                     otherwise, a new handle is created

    CabinetFile    - supplies name of cabinet file.

    Flags - supplies flags to control behavior of cabinet processing.

    MsgHandler - Supplies a callback routine to be notified
        of various significant events in cabinet processing.

    Context - Supplies a value that is passed to the MsgHandler
        callback function.

Return Value:

    Win32 error code indicating result. If the cabinet was corrupt,
    ERROR_INVALID_DATA is returned.

--*/

{
    BOOL b;
    DWORD rc;
    PWSTR CabCopy, FilePart,PathPart,tmp;
    WCHAR c;
    WCHAR fullcab[MAX_PATH];
    int h;
    PVOID CabHandle;

    NTCABCONTEXT CabContext;

    UNREFERENCED_PARAMETER(Flags);

    //
    // Initialize diamond for this thread if not
    // already initialized.
    //
    //if(!InCabHandle) {
        CabHandle = NtCabInitialize();
        if (!CabHandle) {
            rc = ERROR_INVALID_HANDLE;
            goto c0;
        }
    //} else {
    //    CabHandle = InCabHandle;
    //}

    if (!CabinetFile) {
        rc = ERROR_INVALID_PARAMETER;
        goto c1;
    }

    MYASSERT( CabHandle != NULL );
    MYASSERT( CabinetFile != NULL );

    //
    // make a copy because the input is const
    //
    CabCopy = DuplicateString(CabinetFile);
    if (!CabCopy) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Split the cabinet name into path and name.
    // Make separate copies because we want to remember the
    //
    if(FilePart = wcsrchr(CabCopy, L'\\')) {
        FilePart++;
    } else {
        FilePart = CabCopy;
    }
    c = *FilePart;
    *FilePart = 0;
    PathPart = DuplicateString(CabCopy);
    *FilePart = c;

    if(!PathPart) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c2;
    }
    FilePart = DuplicateString(FilePart);
    if(!FilePart) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto c3;
    }

    MyFree( CabCopy );

    MYASSERT( FilePart != NULL && PathPart != NULL );

    rc = GetFullPathName(CabinetFile,MAX_PATH,fullcab,&tmp);
    if (!rc || rc > MAX_PATH) {
        rc = ERROR_BUFFER_OVERFLOW;
        goto c4;
    } else if (GetFileAttributes(fullcab) == 0xFFFFFFFF) {
        rc = ERROR_FILE_NOT_FOUND;
        goto c4;
    }

    if (!NtCabOpenCabFile(CabHandle,fullcab)) {
        rc = ERROR_INVALID_DATA;
        goto c4;
    }

    CabContext.hCab        = CabHandle;
    CabContext.UserContext = Context;
    CabContext.CabFile     = CabinetFile;
    CabContext.FilePart    = FilePart;
    CabContext.PathPart    = PathPart;
    CabContext.IsMsgHandlerNativeCharWidth = IsMsgHandlerNativeCharWidth;
    CabContext.MsgHandler  = MsgHandler;
    CabContext.LastError   = ERROR_SUCCESS;
    CabContext.CurrentTargetFile = NULL;

    //CabContext.UserPath[0]  = 0;
    //CabContext.SwitchedCabinets = FALSE ;


    //
    // call cab enumeration callback
    //
    b = NtCabEnumerateFiles(
            CabHandle,
            (PNTCABFILEENUM)NtCabNotifyFunction,
            (ULONG_PTR)&CabContext);
    if(b && GetLastError()==ERROR_NO_MORE_FILES) {

        //
        // Everything succeeded so we shouldn't have any partially
        // processed files.
        //
        SetLastError(NO_ERROR);
        MYASSERT(!CabContext.CurrentTargetFile);
        rc = NO_ERROR;

    } else {

        rc = CabContext.LastError;
#if 0
        switch(CabContext.LastError) {

        case :
            break;
        default:
            //
            // Cabinet is corrupt or not actually a cabinet, etc.
            //
            rc = ERROR_INVALID_DATA;
            break;
        }
#endif

        if(CabContext.CurrentTargetFile) {
            //
            // Call the callback function to inform it that the last file
            // was not successfully extracted from the cabinet.
            // Also remove the partially copied file.
            //
            DeleteFile(CabContext.CurrentTargetFile);

            CabContext.CurrentTargetFile = NULL;
        }

    }

c4:
    MyFree(FilePart);
c3:
    MyFree(PathPart);
c2:
    MyFree(CabCopy);
c1:
    //if (CabHandle != InCabHandle) {
        NtCabClose( CabHandle );
    //}

c0:
    return(rc);
}

#else

DWORD
NtCabProcessCabinet(
    //IN PVOID  InCabHandle, OPTIONAL
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    )
{
    //UNREFERENCED_PARAMETER(InCabHandle);
    UNREFERENCED_PARAMETER(CabinetFile);
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(MsgHandler);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(IsMsgHandlerNativeCharWidth);


    return(ERROR_CALL_NOT_IMPLEMENTED);
}

#endif

#ifdef UNICODE

BOOL
NtCabIsCabinet(
    IN PCWSTR CabinetFile
    )

/*++

Routine Description:

    Determine if a file is a diamond cabinet.

Arguments:

    FileName - supplies name of file to be checked.

Return Value:

    TRUE if file is diamond file. FALSE if not;

--*/

{
    DWORD rc;
    PVOID CabHandle;
    WCHAR fullcab[MAX_PATH];
    PWSTR tmp;

    CabHandle = NtCabInitialize();
    if (!CabHandle) {
        rc = ERROR_INVALID_DATA;
        goto c0;
    }

    rc = GetFullPathName(CabinetFile,MAX_PATH,fullcab,&tmp);
    if (!rc || rc > MAX_PATH) {
        rc = ERROR_BUFFER_OVERFLOW;
        goto c1;
    } else if (GetFileAttributes(fullcab) == 0xFFFFFFFF) {
        rc = ERROR_FILE_NOT_FOUND;
        goto c1;
    }

    if (!NtCabOpenCabFile(CabHandle,fullcab)) {
        rc = ERROR_INVALID_DATA;
        goto c1;
    }

    rc = ERROR_SUCCESS;

c1:
    NtCabClose(CabHandle);

c0:
    return(rc == ERROR_SUCCESS);

}

#else

BOOL
NtCabIsCabinet(
    IN PCWSTR FileName
    )
{
    UNREFERENCED_PARAMETER(FileName);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}


#endif


PVOID
NtCabAlloc(
    IN ULONG NumberOfBytes
    )

/*++

Routine Description:

    Callback used by cab callback to allocate memory.

Arguments:

    NumberOfBytes - supplies desired size of block.

Return Value:

    Returns pointer to a block of memory or NULL
    if memory cannot be allocated.

--*/

{
    return(MyMalloc(NumberOfBytes));
}


VOID
NtCabFree(
    IN PVOID Block
    )

/*++

Routine Description:

    Callback used by cab callback to free a memory block.
    The block must have been allocated with NtCabAlloc().

Arguments:

    Block - supplies pointer to block of memory to be freed.

Return Value:

    None.

--*/

{
    MyFree(Block);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\ntcab.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    ntcab.h

Abstract:

    Private header file for ntcab compression support.
    
Author:

    Andrew Ritz (andrewr) 5-Oct-1998

Revision History:

    Andrew Ritz (andrewr) 5-Oct-1998 Created it.

--*/

typedef struct _NTCABCONTEXT {
  PVOID     hCab;
  PVOID     UserContext;
  PVOID     MsgHandler;
  PCWSTR    CabFile;
  PWSTR     FilePart;
  PWSTR     PathPart;
  BOOL      IsMsgHandlerNativeCharWidth;
  DWORD     LastError;
  PWSTR     CurrentTargetFile;
  //WCHAR   UserPath[MAX_PATH];
  //BOOL    SwitchedCabinets
  

} NTCABCONTEXT, *PNTCABCONTEXT;

BOOL
NtCabIsCabinet(
    PCWSTR CabinetName
    );


DWORD
NtCabProcessCabinet(
    //IN PVOID  InCabHandle, OPTIONAL
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsMsgHandlerNativeCharWidth
    );

typedef UINT (CALLBACK* PSP_NTCAB_CALLBACK)(
    IN PNTCAB_ENUM_DATA EnumData,
    IN PNTCABCONTEXT    Context,
    OUT PDWORD          Operation
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\rc_ids.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    rc_ids.h

Abstract:

    Header for resources, see also dialog.h

Author:

--*/

#define     IDS_MICROSOFT         1
#define     IDS_UNKNOWN_PARENS    2
#define     IDS_LOCATEFILE        3
#define     IDS_OUTOFMEMORY       4
#define     IDS_ADDITIONALMODELS  5

//
// Standard class icons
//
#define     ICON_DISPLAY          1
#define     ICON_MOUSE            2
#define     ICON_KEYBOARD         3
#define     ICON_PRINTER          4

#define     ICON_NET              5
#define     ICON_NETTRANS         6
#define     ICON_NETCLIENT        7
#define     ICON_NETSERVICE       8

#define     ICON_CONTROLLER       9

#define     ICON_SCSI            10
#define     ICON_PCCARD          11

#define     ICON_UNKNOWN         18
#define     ICON_DEFAULT         19

#define     ICON_USB             20
#define     ICON_1394            21
#define     ICON_GPS             22
#define     ICON_PORT            23
#define     ICON_HID             24
#define     ICON_SMARTCARDREADER 25
#define     ICON_MULTIPORTSERIAL 26
#define     ICON_SYSTEM          27
#define     ICON_PROCESSOR       28

//
// Other icons
//
#define     IDI_SIGNED          40
#define     IDI_BLANK           41
#define     IDI_WARN            42
#define     IDI_DRIVERBLOCK     43

//
// AVIs
//
#define     IDA_FILECOPY       30
#define     IDA_FILEDEL        31
#define     IDA_ANIMATION      32

//
// Icons for various dialogs.
//
#define     ICON_FLOPPY        50
#define     ICON_CD            51
#define     ICON_NETWORK       52
#define     ICON_HARD          53
#define     ICON_SETUP         54
#define     ICON_EBD          105

//
// Bitmaps.
//
#define     BMP_DRIVERTYPES  1201

//
// Files needed strings in disk prompt/file error dialog
//
#define     IDS_FILESNEEDED     100
#define     IDS_FILESNEEDED2    101
#define     IDS_COPYFROM        102
#define     IDS_COPYFROMOEM     103
#define     IDS_DISKPROMPT1     104
#define     IDS_DISKPROMPT2     105
#define     IDS_DISKPROMPTOEM   106
#define     IDS_PROMPTACTION1   107
#define     IDS_PROMPTACTION2   108
#define     IDS_PROMPTTITLE     109

#define     IDS_COPYERROR       110
#define     IDS_FILEERRCOPY     111

#define     IDS_SURESKIP        112
#define     IDS_SURECANCEL      113

#define     IDS_COPYERROROEM    114
#define     IDS_COPYERROR1      115
#define     IDS_COPYERROR2      116

#define     IDS_WARNING         117

#define     IDS_ERRORDETAILS    120
#define     IDS_ERROR           121

#define     IDS_RENAMEERROR     122
#define     IDS_DELETEERROR     123
#define     IDS_BACKUPERROR     124

#define     IDS_CANCELALL       125
#define     IDS_RETRY           126

#define     IDS_LANG_NEUTRAL    127
#define     IDS_LANG_UNKNOWN    128

//
// Strings used in progress dialog.
//
#define     IDS_FILEOP_BACKUP   142
#define     IDS_FILEOP_FROM     143
#define     IDS_FILEOP_TO       144
#define     IDS_FILEOP_FILE     145

#define     IDS_COPY_CAPTION1   146
#define     IDS_COPY_CAPTION2   147
#define     IDS_RENAME_CAPTION1 148
#define     IDS_RENAME_CAPTION2 149
#define     IDS_DELETE_CAPTION1 150
#define     IDS_DELETE_CAPTION2 151
#define     IDS_BACKUP_CAPTION1 152
#define     IDS_BACKUP_CAPTION2 153
#define     IDS_COPY_INVALID_TARGET 154
#define     IDS_CANCELFILEOPS   155

//
// Strings used in Add New Device Wizard
//
#define IDS_OEMTITLE            309
#define IDS_NDW_PICKDEV1        430
#define IDS_SELECT_DEVICE       704
#define IDS_NDWSEL_MODELSLABEL 2011
#define IDS_NDWSEL_MFGLABEL    2012
#define IDS_DRIVER_IS_SIGNED   2013
#define IDS_DRIVER_NOT_SIGNED  2014

//
// Strings used in Select Device dialog
// (setupx ID + 100 to avoid overlap)
//
#define IDS_INSTALLSTR0             200
#define IDS_INSTALLSTR1             201
#define IDS_INSTALLCLASS            205
#define IDS_INSTALLOEM              206
#define IDS_INSTALLOEM1             212

//
// Other device installer strings
//
#define IDS_DEVICEINSTALLER    4206

//
// String ID used for localized language name used in legacy INFs.
//
#define IDS_LEGACYINFLANG       600

//
// Strings for resource selection dialogs
//
#define IDS_RESOURCETYPE                 1000
#define IDS_RESOURCESETTING              1001
#define IDS_DEVRES_NO_CHANGE_MF          1002
#define IDS_BASICCONFIG                  1003
#define IDS_RESTYPE_FULL                 1004
#define IDS_MEMORY_FULL                  1005
#define IDS_IO_FULL                      1006
#define IDS_DMA_FULL                     1007
#define IDS_IRQ_FULL                     1008
#define IDS_IRQ_FULL_LC                  1009
#define IDS_DMA_FULL_LC                  1010
#define IDS_MEMORY_FULL_LC               1011
#define IDS_IO_FULL_LC                   1012

#define IDS_OVERRIDECONFIG               1014
#define IDS_RESOURCE_BASE                1100
#define IDS_MEMORY                       1101
#define IDS_IO                           1102
#define IDS_DMA                          1103
#define IDS_IRQ                          1104

#define IDS_UNKNOWN                      1107

#define IDS_FORCEDCONFIG_PARTIAL         1020

#define IDS_DEVRES_NOALLOC_DISABLED      1022
#define IDS_DEVRES_NOALLOC_PROBLEM       1023
#define IDS_DEVRES_NORMAL_CONFLICT       1024
#define IDS_DEVRES_NOMATCHINGLC          1025
#define IDS_DEVRES_NOMODIFYTITLE         1026
#define IDS_EDITRES_RANGEINSTR1          1027
#define IDS_EDITRES_RANGEINSTR2          1028
#define IDS_EDITRES_ENTRYERROR           1029
#define IDS_EDITRES_VALIDATEERROR1       1030
#define IDS_EDITRES_VALIDATEERROR2       1031
#define IDS_EDITRES_VALIDATEERROR3       1032
#define IDS_ERROR_BADMEMTEXT             1033
#define IDS_ERROR_BADIOTEXT              1034
#define IDS_ERROR_BADDMATEXT             1035
#define IDS_ERROR_BADIRQTEXT             1036
#define IDS_EDITRES_CONFLICTWARNMSG      1037
#define IDS_EDITRES_CONFLICTWARNTITLE    1038
#define IDS_DEVRES_NOCONFLICTINFO        1049
#define IDS_DEVRES_NOMODIFYALL           1050
#define IDS_DEVRES_NOMODIFYSINGLE        1051
#define IDS_EDITRES_SINGLEINSTR1         1052
#define IDS_EDITRES_SINGLEINSTR2         1053
#define IDS_EDITRES_TITLE                1054
#define IDS_EDITRES_UNKNOWNCONFLICT      1055
#define IDS_EDITRES_UNKNOWNCONFLICTINGDEVS 1056
#define IDS_EDITRES_NOCONFLICT           1057
#define IDS_EDITRES_NOCONFLICTINGDEVS    1058

#define IDS_MAKE_FORCED_TITLE            1060
#define IDS_FORCEDCONFIG_WARN1           1061
#define IDS_FORCEDCONFIG_WARN2           1062
#define IDS_FORCEDCONFIG_WARN3           1063
#define IDS_FORCEDCONFIG_WARN4           1064
#define IDS_EDITRES_DEVCONFLICT          1065
#define IDS_CONFLICT_FMT                 1066
#define IDS_DEVRES_NOCONFLICTDEVS        1067
#define IDS_DEVRES_NO_RESOURCES          1068
#define IDS_DEVRES_NOMODIFYSELECT        1069

#define IDS_CONFLICT_UNAVAILABLE         1071
#define IDS_CONFLICT_GENERALERROR        1072
#define IDS_DEVNAME_UNK                  1073
#define IDS_GENERIC_DEVNAME              1074
#define IDS_EDITRES_RESERVED             1075
#define IDS_EDITRES_RESERVEDRANGE        1076
#define IDS_CURRENTCONFIG                1077

#define IDS_LOGSEVINFORMATION            3001
#define IDS_LOGSEVWARNING                3002
#define IDS_LOGSEVERROR                  3003
#define IDS_LOGSEVFATALERROR             3004

#define IDS_UNKNOWN_DRIVER               5320

#define IDS_DRIVER_UPDATE_TITLE          5330
#define IDS_DRIVER_NOMATCH1              5331

#define IDS_DRIVERCACHE_DESC             5332

#define IDS_NDW_NO_DRIVERS               5333
#define IDS_NDW_RETRIEVING_LIST          5334
#define IDS_NDW_NODRIVERS_WARNING        5335

#define IDS_DRIVER_NOMATCH2              5336
#define IDS_DRIVER_NOMATCH3              5337

#define IDS_NDW_SELECTDEVICE             5340

#define IDS_VERSION                      5342

#define IDS_YES                          5343
#define IDS_NO                           5344
#define IDS_DEVICE_VERIFY_MSG1           5345
#define IDS_DEVICE_VERIFY_MSG2           5346
#define IDS_SOFTWARE_VERIFY_MSG1         5347
#define IDS_SOFTWARE_VERIFY_MSG2         5348


//
// strings with well-known ID's
//
#define IDS_SHELL_INF_DESCRIPTION        2000  // "Setup Information" for INF extension
#define IDS_SHELL_PNF_DESCRIPTION        2001  // "Precompiled Setup Information" for PNF extension

//
// Include dialogs header files also
//
#include "prompt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\prompt.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    prompt.h

Abstract:

    Header for dialogs and dialog controls

Author:

--*/

#include <setupapi.h>

#define DLG_DEVINSTALL                        57
#define IDD_DISKPROMPT1                      100
#define IDT_TITLE1                           101
#define IDT_TEXT1                            104
#define IDT_TEXT2                            105
#define IDC_COMBO1                           107
#define IDI_ICON1                            108
#define IDC_COMBO2                           109
#define IDB_BROWSE                           110
#define IDD_DEVINSLINE                       111
#define IDC_FRAME1                           120
#define IDD_FILEERROR2                       200
#define IDC_PROGRESS                         204
#define IDD_FILEPROGRESS                     300
#define IDD_SIMPLEPROMPT                     350
#define IDD_REPLACE                          400
#define IDT_TEXT3                            401
#define IDT_TEXT4                            402
#define IDT_TEXT5                            403
#define IDT_TEXT6                            404
#define IDT_TEXT7                            405
#define IDT_TEXT8                            406
#define IDB_NOTOALL                          407
#define IDC_CLASSICON                       1003
#define IDC_NDW_PICKDEV_COMPAT              1565
#define IDC_NDW_PICKDEV_WINDOWSUPDATE       1566
#define IDC_NDW_PICKDEV_HAVEDISK            1567
#define IDC_NDW_TEXT                        1570
#define IDC_NDW_PICKDEV_MFGLIST             1580
#define IDC_NDW_PICKDEV_DRVLIST             1581
#define IDC_NDW_PICKDEV_ONEMFG_DRVLIST      1852
#define IDC_NDW_STATUS_TEXT                 1853
#define IDC_NDW_PICKDEV_SIGNED_ICON         1854
#define IDC_NDW_PICKDEV_SIGNED_TEXT         1855
#define IDC_NDW_PICKDEV_SIGNED_LINK         1856

// IDD_DEF_DEVRESOURCE
//#define IDD_DEF_DEVRESOURCE           2000    // not used
#define IDD_DEF_DEVRESOURCE_PROP        2001    // prop page version
#define IDC_DEVRES_ICON                 2002
#define IDC_DEVRES_DEVDESC              2003
#define IDC_DEVRES_SETTINGSTATE         2004
#define IDC_DEVRES_SETTINGSLIST         2005
#define IDC_DEVRES_NOALLOCTEXT          2006
#define IDC_DEVRES_NO_RESOURCES_TEXT    2007
#define IDC_DEVRES_LCTEXT               2008
#define IDC_DEVRES_LOGCONFIGLIST        2009
#define IDC_DEVRES_CHANGE               2010
#define IDC_DEVRES_USESYSSETTINGS       2011
#define IDC_DEVRES_MFPARENT             2012
#define IDC_DEVRES_MFPARENT_DESC        2013
#define IDC_DEVRES_NO_CHANGE_TEXT       2014
#define IDC_DEVRES_MAKEFORCED           2015
//#define IDC_DEVRES_MAKEFORCEDFROMALLOC 2016  // not used
#define IDC_DEVRES_CONFLICTDEVTEXT      2017
#define IDC_DEVRES_CONFLICTINFOLIST     2018

//#define IDI_RESOURCE_IO               2020
//#define IDI_RESOURCE_DMA              2021    // not used
//#define IDI_RESOURCE_MEM              2022    // not used
//#define IDI_RESOURCE_IRQ              2023    // not used


// IDD_EDIT_RESOURCE
#define IDD_EDIT_RESOURCE               2100
#define IDC_EDITRES_INSTRUCTIONS        2101
#define IDC_EDITRES_MFCHILDREN          2102
#define IDC_EDITRES_MFCHILDREN_LIST     2103
#define IDC_EDITRES_VALUE_LABEL         2104
#define IDC_EDITRES_VALUE               2105
#define IDC_EDITRES_SPIN                2106
#define IDC_EDITRES_CONFLICTTEXT        2107
#define IDC_EDITRES_CONFLICTLIST        2108
#define IDC_EDITRES_CONFLICTINFO        2109
#define IDC_EDITRES_CONFLICTDEVTITLE    2110

#define IDD_DEVICE_VERIFY_WARNING       5314
#define IDD_DEVICE_VERIFY_BLOCK         5315
#define IDD_SOFTWARE_VERIFY_WARNING     5316
#define IDD_SOFTWARE_VERIFY_BLOCK       5317

#define IDC_VERIFY_FILENAME             5302
#define IDC_VERIFY_WARN_YES             5303
#define IDC_VERIFY_TESTING_LINK         4304
#define IDC_VERIFY_TESTING_TEXT         4305
#define IDC_VERIFY_WARN_NO              5306
#define IDC_VERIFY_BOLD                 5307
#define IDC_VERIFY_BLOCK_OK             5312
#define IDC_VERIFY_ICON                 5313
#define IDC_VERIFY_SETUP_TEXT           5314

#define IDC_CERTDETAILS_TEXT            5320

#define IDD_DRIVERBLOCK                 5330
#define IDC_DRIVERBLOCK_DETAILS         5331
#define IDC_DRIVERBLOCK_ICON            5332
#define IDC_DRIVERBLOCK_APPNAME         5333
#define IDC_DRIVERBLOCK_SUMMARY         5334

#define IDC_STATIC                        -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sources.inc ===
MAJORCOMP=setup

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=$(O)\setupapi.def
DLLENTRY=_DllMainCRTStartup

!include $(PROJECT_ROOT)\prerelease.inc

!if $(PRERELEASE)
# C_DEFINES=$(C_DEFINES) -DMEM_DBG=1 -DASSERTS_ON=1
C_DEFINES=$(C_DEFINES) -DMEM_DBG=1
!endif

INCLUDES=\
    ..;                  \
    $(DS_INC_PATH);      \
    $(SHELL_INC_PATH);   \
    $(ADMIN_INC_PATH);   \
    $(WINDOWS_INC_PATH); \
    $(ENDUSER_INC_PATH); \
    $(NET_INC_PATH); \
    $(PROJECT_ROOT)\win32\lz32\winlza;

C_DEFINES=$(C_DEFINES) -DDBGHEAP_CHECK

#
# setupapi can be run over the net; this flag forces the file to be copied
# to the local pagefile and protects against inpage i/o errors
#
LINKER_FLAGS=/SWAPRUN:CD /SWAPRUN:NET

SOURCES=\
    ..\backup.c    \
    ..\cntxtlog.c  \
    ..\copy.c      \
    ..\debug.c     \
    ..\decomp.c    \
    ..\devclass.c  \
    ..\devdrv.c    \
    ..\devicon.c   \
    ..\devinfo.c   \
    ..\devinst.c   \
    ..\devinstd.c  \
    ..\devoem.c    \
    ..\devprop.c   \
    ..\devreg.c    \
    ..\devres.c    \
    ..\devres1.c   \
    ..\devres2.c   \
    ..\devwiz.c    \
    ..\diamond.c   \
    ..\diansicv.c  \
    ..\diskspac.c  \
    ..\diutil.c    \
    ..\dll.c       \
    ..\filelog.c   \
    ..\fileq1.c    \
    ..\fileq2.c    \
    ..\fileq3.c    \
    ..\fileq4.c    \
    ..\fileq5.c    \
    ..\fileq6.c    \
    ..\fileqcb.c   \
    ..\fileutil.c  \
    ..\fusion.c    \
    ..\infcache.c  \
    ..\infflist.c  \
    ..\infinst.c   \
    ..\infline.c   \
    ..\infload.c   \
    ..\inflogcf.c  \
    ..\infold.c    \
    ..\infopenv.c  \
    ..\infsdisk.c  \
    ..\infvalue.c  \
    ..\logapi.c    \
    ..\memory.c    \
    ..\miscutil.c  \
    ..\mru.c       \
    ..\oldspapi.c  \
    ..\prompt.c    \
    ..\registry.c  \
    ..\resource.c  \
    ..\setupapi.rc \
    ..\stub.c

UMRES=$(O)\setupapi.res
UMTYPE=windows
UMENTRY=winmain

NTTARGETFILE0=msg.h msg.rc

PRECOMPILED_INCLUDE=precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\setupntp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    setupntp.h

Abstract:

    Private top-level header file for Windows NT Setup
    services Dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (jamiehun) 27-Jan-2000 Added infcache.h
    Jim Schmidt (jimschm)   16-Dec-1998 Log api init
    Jim Schmidt (jimschm)   28-Apr-1997 Added stub.h
    Jamie Hunter (jamiehun) 13-Jan-1997 Added backup.h

--*/


//
// System header files
//

#if DBG
#ifndef MEM_DBG
#define MEM_DBG 1
#endif
#else
#ifndef MEM_DBG
#define MEM_DBG 0
#endif
#endif

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>
#include <spfusion.h>

//
// Make sure we always use version 2 of SP_ALTPLATFORM_INFO structure...
//
#define USE_SP_ALTPLATFORM_INFO_V1 0
#include <setupapi.h>
#include <imagehlp.h>
#include <diamondd.h>
#include <lzexpand.h>
#include <dlgs.h>
#include <regstr.h>
#include <infstr.h>
#include <cfgmgr32.h>
#include <spapip.h>
#include <objbase.h>
#include <devguid.h>
#include <wincrypt.h>
#include <mscat.h>
#include <softpub.h>
#include <wintrust.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <cdm.h>
#include <userenv.h>
#include <userenvp.h>
#include <secedit.h>
#include <scesetup.h>
#include <sfcapip.h>
#include <wow64reg.h>
#include <dbt.h>
#include <shimdb.h>

//
// CRT header files
//
#include <process.h>
#include <malloc.h>
#include <wchar.h>
#include <stddef.h>
#include <stdio.h>
#include <fcntl.h>
#include <tchar.h>
#include <mbstring.h>

//
// these definitions may be used by private header files
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#endif
#define SIZECHARS(x)    ARRAYSIZE(x)
#define CSTRLEN(x)      (SIZECHARS(x)-1)

typedef struct _STRING_TO_DATA {
    PCTSTR     String;
    UINT_PTR   Data;
} STRING_TO_DATA, *PSTRING_TO_DATA;

//
// Private header files
//
#include "sputils/locking.h"
#include "sputils/strtab.h"
#include "memory.h"
#include "cntxtlog.h"
#include "inf.h"
#include "infcache.h"
#include "backup.h"
#include "fileq.h"
#include "devinst.h"
#include "devres.h"
#include "rc_ids.h"
#include "msg.h"
#include "stub.h"
#include "helpids.h"

#ifdef CHILDREGISTRATION
#include "childreg.h"
#ifndef _WIN64
#include <wow64t.h>
#endif // _WIN64
#endif // CHILDREGISTRATION


// NTRAID#489682-2001/11/02-JamieHun These need to move into public headers
//
#define SP_COPY_ALREADYDECOMP       0x0400000   // similar to SP_COPY_NODECOMP

//
//
// Private DNF_ flags (start at 0x10000000)
//
#define PDNF_MASK                   0xF0000000  // Mask for private PDNF_xxx flags
#define PDNF_CLEANUP_SOURCE_PATH    0x10000000  // Delete the source path when we destroy the driver node
                                                // used when drivers are downloaded from the Internet
//
// Thread Local Storage Index
//
extern DWORD TlsIndex;

//
// Module handle for this DLL. Filled in at process attach.
//
extern HANDLE MyDllModuleHandle;

//
// Module handle for security DLL. Initialized to NULL in at process attach. Filled in when SCE APIs have to be called
//
extern HINSTANCE SecurityDllHandle;

//
// OS Version Information structure filled in at process attach.
//
extern OSVERSIONINFOEX OSVersionInfo;

//
// Static strings we retreive once, at process attach.
//
extern PCTSTR WindowsDirectory,InfDirectory,SystemDirectory,ConfigDirectory,DriversDirectory,System16Directory;
extern PCTSTR SystemSourcePath,ServicePackSourcePath,DriverCacheSourcePath;
extern PCTSTR OsLoaderRelativePath;     // may be NULL
extern PCTSTR OsSystemPartitionRoot;    // \\?\GLOBALROOT\Device\Volume
extern PCTSTR WindowsBackupDirectory;   // Directory to write uninstall backups to
extern PCTSTR ProcessFileName;          // Filename of app calling setupapi
extern PCTSTR LastGoodDirectory;        // %windir%\LastGood

//
// are we inside gui setup? determined at process attach
//
extern BOOL GuiSetupInProgress;

//
// various other global flags
//
extern DWORD GlobalSetupFlags;

//
// global window message for cancelling autoplay.
//
extern UINT g_uQueryCancelAutoPlay;

//
// Static multi-sz list of directories to be searched for INFs.
//
extern PCTSTR InfSearchPaths;

//
// Determine at runtime if we're running under WOW64
//
#ifndef _WIN64
extern BOOL IsWow64;
#endif

#ifdef UNICODE
extern DWORD Seed;
#endif

//
// ImageHlp isn't multi-thread safe, so needs a mutex
//
extern CRITICAL_SECTION InitMutex;             // for one-time initializations
extern CRITICAL_SECTION ImageHlpMutex;         // for dealing with IMAGEHLP library
extern CRITICAL_SECTION PlatformPathOverrideCritSect;
extern CRITICAL_SECTION LogUseCountCs;
extern CRITICAL_SECTION MruCritSect;
extern CRITICAL_SECTION NetConnectionListCritSect;


//
// Debug memory functions and wrappers to track allocations
//

DWORD
QueryRegistryValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    );

DWORD
QueryDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    );

DWORD
QueryRegistryDwordValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PDWORD  Value
    );

BOOL
MemoryInitializeEx(
    IN BOOL Attach
    );

#if MEM_DBG

//
// Macros and wrappers are needed for externally exposed functions
//
PVOID MyDebugMalloc(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line,
    IN DWORD Tag
    );

#define MyMalloc(sz)                    MyDebugMalloc(sz,__FILE__,__LINE__,0)
#define MyTaggedMalloc(sz,tag)          MyDebugMalloc(sz,__FILE__,__LINE__,tag)
#define MyTaggedRealloc(ptr,sz,tag)     pSetupReallocWithTag(ptr,sz,tag)
#define MyTaggedFree(ptr,tag)           pSetupFreeWithTag(ptr,tag)

DWORD
TrackedQueryRegistryValue(
    IN          TRACK_ARG_DECLARE,
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    );

#define QueryRegistryValue(a,b,c,d,e)   TrackedQueryRegistryValue(TRACK_ARG_CALL,a,b,c,d,e)

DWORD
TrackedQueryDeviceRegistryProperty(
    IN                   TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    );

#define QueryDeviceRegistryProperty(a,b,c,d,e,f)   TrackedQueryDeviceRegistryProperty(TRACK_ARG_CALL,a,b,c,d,e,f)

PTSTR
TrackedDuplicateString(
    IN TRACK_ARG_DECLARE,
    IN PCTSTR String
    );

#define DuplicateString(x)              TrackedDuplicateString(TRACK_ARG_CALL,x)

#else

#define DuplicateString                 pSetupDuplicateString
#define MyMalloc(sz)                    pSetupMalloc(sz)
#define MyTaggedMalloc(sz,tag)          pSetupMalloc(sz)
#define MyTaggedRealloc(ptr,sz,tag)     pSetupRealloc(ptr,sz)
#define MyTaggedFree(ptr,tag)           pSetupFree(ptr)

#endif

#define MyFree(ptr)                     pSetupFree(ptr)
#define MyRealloc(ptr,sz)               pSetupRealloc(ptr,sz)

//
// memory tags grouped here for easy reference
// see also common.h in sputils
//
//
// Log Context tags
//
#define MEMTAG_LOGCONTEXT               (0x636c434c) // LClc - context structure
#define MEMTAG_LCSECTION                (0x7378434c) // LCxs - section string
#define MEMTAG_LCBUFFER                 (0x6278434c) // LCxb - other strings
#define MEMTAG_LCINFO                   (0x6269434c) // LCib - info (array of buffers)
#define MEMTAG_LCINDEXES                (0x6969434c) // LCii - index
//
// Loaded_Inf tags
//
#define MEMTAG_INF                      (0x666e694c) // Linf - LOADED_INF
#define MEMTAG_VBDATA                   (0x6462764c) // Lvbd - version block data


//
// File functions in fileutil.c
//

typedef struct _TEXTFILE_READ_BUFFER {
    PCTSTR TextBuffer;
    DWORD  TextBufferSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID  ViewAddress;
} TEXTFILE_READ_BUFFER, *PTEXTFILE_READ_BUFFER;

DWORD
ReadAsciiOrUnicodeTextFile(
    IN  HANDLE                FileHandle,
    OUT PTEXTFILE_READ_BUFFER Result,
    IN  PSETUP_LOG_CONTEXT    LogContext OPTIONAL
    );

BOOL
DestroyTextFileReadBuffer(
    IN PTEXTFILE_READ_BUFFER ReadBuffer
    );

DWORD
GetSetFileTimestamp(
    IN  PCTSTR    FileName,
    OUT FILETIME *CreateTime,   OPTIONAL
    OUT FILETIME *AccessTime,   OPTIONAL
    OUT FILETIME *WriteTime,    OPTIONAL
    IN  BOOL      Set
    );

DWORD
RetreiveFileSecurity(
    IN  PCTSTR                FileName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

DWORD
StampFileSecurity(
    IN PCTSTR               FileName,
    IN PSECURITY_DESCRIPTOR SecurityInfo
    );

DWORD
TakeOwnershipOfFile(
    IN PCTSTR Filename
    );

DWORD
SearchForInfFile(
    IN  PCTSTR            InfName,
    OUT LPWIN32_FIND_DATA FindData,
    IN  DWORD             SearchControl,
    OUT PTSTR             FullInfPath,
    IN  UINT              FullInfPathSize,
    OUT PUINT             RequiredSize     OPTIONAL
    );

DWORD
MultiSzFromSearchControl(
    IN  DWORD  SearchControl,
    OUT PTCHAR PathList,
    IN  DWORD  PathListSize,
    OUT PDWORD RequiredSize  OPTIONAL
    );

PSTR
GetAnsiMuiSafePathname(
    IN  PCTSTR      FilePath
    );

PSTR
GetAnsiMuiSafeFilename(
    IN  PCTSTR      FilePath
    );

BOOL
pSetupAppendPath(
    IN  PCTSTR  Path1,
    IN  PCTSTR  Path2,
    OUT PTSTR*  Combined
    );

BOOL
pSetupApplyExtension(
    IN  PCTSTR  Original,
    IN  PCTSTR  Extension,
    OUT PTSTR*  NewName
    );

//
// Resource/string retrieval routines in resource.c
//

VOID
SetDlgText(
    IN HWND hwndDlg,
    IN INT  iControl,
    IN UINT nStartString,
    IN UINT nEndString
    );

#define SDT_MAX_TEXT    1000        // Max SetDlgText() combined text size

PTSTR
MyLoadString(
    IN UINT StringId
    );

PTSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    );

PTSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    );

PTSTR
FormatStringMessageFromString(
    IN PTSTR FormatString,
    ...
    );

PTSTR
FormatStringMessageFromStringV(
    IN PTSTR    FormatString,
    IN va_list *ArgumentList
    );

PTSTR
RetreiveAndFormatMessage(
    IN UINT MessageId,
    ...
    );

PTSTR
RetreiveAndFormatMessageV(
    IN UINT     MessageId,
    IN va_list *ArgumentList
    );

INT
FormatMessageBox(
    IN HANDLE hinst,
    IN HWND   hwndParent,
    IN UINT   TextMessageId,
    IN PCTSTR Title,
    IN UINT   Style,
    ...
    );

//
// This is in shell32.dll and in windows\inc16\shlsemip.h but
// that file cannot be #include'd here as it has macros that clash
// with our own, etc.
//
#ifdef ANSI_SETUPAPI
//
// Win9x - does not have RestartDialogEx
//
#define RestartDialogEx(hwnd,Prompt,Return,ReasonCode) RestartDialog(hwnd,Prompt,Return)
#endif
//
// Decompression/filename manupilation routines in decomp.c.
//
PTSTR
SetupGenerateCompressedName(
    IN PCTSTR Filename
    );

DWORD
SetupInternalGetFileCompressionInfo(
    IN  PCTSTR            SourceFileName,
    OUT PTSTR            *ActualSourceFileName,
    OUT PWIN32_FIND_DATA  SourceFindData,
    OUT PDWORD            TargetFileSize,
    OUT PUINT             CompressionType
    );

DWORD
SetupDetermineSourceFileName(
    IN  PCTSTR            FileName,
    OUT PBOOL             UsedCompressedName,
    OUT PTSTR            *FileNameLocated,
    OUT PWIN32_FIND_DATA  FindData
    );

BOOL
pSetupDoesFileMatch(
    IN  PCTSTR            InputName,
    IN  PCTSTR            CompareName,
    OUT PBOOL             UsedCompressedName,
    OUT PTSTR            *FileNameLocated
    );

//
// Diamond functions. The Process and Thread Attach routines are called
// by the DLL entry point routine and should not be called by anyone else.
//
BOOL
DiamondProcessAttach(
    IN BOOL Attach
    );

BOOL
DiamondTlsInit(
    IN BOOL Init
    );

BOOL
DiamondIsCabinet(
    IN PCTSTR FileName
    );

DWORD
DiamondProcessCabinet(
    IN PCTSTR CabinetFile,
    IN DWORD  Flags,
    IN PVOID  MsgHandler,
    IN PVOID  Context,
    IN BOOL   IsUnicodeMsgHandler
    );

//
// Misc routines
//
VOID
DiskPromptGetDriveType(
    IN  PCTSTR PathToSource,
    OUT PUINT  DriveType,
    OUT PBOOL  IsRemovable
    );

BOOL
SetTruncatedDlgItemText(
    HWND hdlg,
    UINT CtlId,
    PCTSTR TextIn
    );

LPTSTR
CompactFileName(
    LPCTSTR FileNameIn,
    DWORD CharsToRemove
    );

DWORD
ExtraChars(
    HWND hwnd,
    LPCTSTR TextBuffer
    );

VOID
pSetupInitPlatformPathOverrideSupport(
    IN BOOL Init
    );

VOID
pSetupInitSourceListSupport(
    IN BOOL Init
    );

DWORD
pSetupDecompressOrCopyFile(
    IN  PCTSTR SourceFileName,
    IN  PCTSTR TargetFileName,
    IN  PUINT  CompressionType, OPTIONAL
    IN  BOOL   AllowMove,
    OUT PBOOL  Moved            OPTIONAL
    );

BOOL
_SetupInstallFileEx(
    IN  PSP_FILE_QUEUE      Queue,             OPTIONAL
    IN  PSP_FILE_QUEUE_NODE QueueNode,         OPTIONAL
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCTSTR              SourceFile,        OPTIONAL
    IN  PCTSTR              SourcePathRoot,    OPTIONAL
    IN  PCTSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PVOID               CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    OUT PBOOL               SignatureVerifyFailed
    );

//
// Define flags for _SetupCopyOEMInf
//
#define SCOI_NO_UI_ON_SIGFAIL                 0x00000001
#define SCOI_NO_ERRLOG_ON_MISSING_CATALOG     0x00000002
#define SCOI_NO_ERRLOG_IF_INF_ALREADY_PRESENT 0x00000004
#define SCOI_KEEP_INF_AND_CAT_ORIGINAL_NAMES  0x00000008 // for exception INFs
#define SCOI_ABORT_IF_UNSIGNED                0x00000010
#define SCOI_TRY_UPDATE_PNF                   0x00000020 // not fatal if PNF
                                                         // present and in use

BOOL
_SetupCopyOEMInf(
    IN     PCTSTR                  SourceInfFileName,
    IN     PCTSTR                  OEMSourceMediaLocation,          OPTIONAL
    IN     DWORD                   OEMSourceMediaType,
    IN     DWORD                   CopyStyle,
    OUT    PTSTR                   DestinationInfFileName,          OPTIONAL
    IN     DWORD                   DestinationInfFileNameSize,
    OUT    PDWORD                  RequiredSize,                    OPTIONAL
    OUT    PTSTR                  *DestinationInfFileNameComponent, OPTIONAL
    IN     PCTSTR                  SourceInfOriginalName,
    IN     PCTSTR                  SourceInfCatalogName,            OPTIONAL
    IN     HWND                    Owner,
    IN     PCTSTR                  DeviceDesc,                      OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,                  OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,                 OPTIONAL
    OUT    PDWORD                  DriverSigningError,              OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin                        OPTIONAL
    );

DWORD
pSetupUninstallCatalog(
    IN LPCTSTR CatalogFilename
    );

VOID
pSetupUninstallOEMInf(
    IN  LPCTSTR            InfFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,  OPTIONAL
    IN  DWORD              Flags,
    OUT PDWORD             InfDeleteErr OPTIONAL
    );

PTSTR
AllocAndReturnDriverSearchList(
    IN DWORD SearchControl
    );

pSetupGetSecurityInfo(
    IN HINF Inf,
    IN PCTSTR SectionName,
    OUT PCTSTR *SecDesc );

BOOL
pSetupGetDriverDate(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    IN OUT PFILETIME   pFileTime
    );

BOOL
pSetupGetDriverVersion(
    IN  HINF        InfHandle,
    IN  PCTSTR      Section,
    OUT DWORDLONG   *Version
    );

PTSTR
GetMultiSzFromInf(
    IN  HINF    InfHandle,
    IN  PCTSTR  SectionName,
    IN  PCTSTR  Key,
    OUT PBOOL   pSetupOutOfMemory
    );

VOID
pSetupInitNetConnectionList(
    IN BOOL Init
    );

BOOL
_SetupGetSourceFileSize(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,      OPTIONAL
    IN  PCTSTR                  FileName,        OPTIONAL
    IN  PCTSTR                  Section,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo, OPTIONAL
    OUT PDWORD                  FileSize,
    IN  UINT                    RoundingFactor   OPTIONAL
    );

BOOL
_SetupGetSourceFileLocation(
    IN  HINF                    InfHandle,
    IN  PINFCONTEXT             InfContext,       OPTIONAL
    IN  PCTSTR                  FileName,         OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,  OPTIONAL
    OUT PUINT                   SourceId,         OPTIONAL
    OUT PTSTR                   ReturnBuffer,     OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize,     OPTIONAL
    OUT PINFCONTEXT             LineContext       OPTIONAL
    );

DWORD
pSetupLogSectionError(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
);

DWORD
pSetupLogSectionWarning(
    IN HINF             InfHandle,          OPTIONAL
    IN HDEVINFO         DeviceInfoSet,      OPTIONAL
    IN PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN PSP_FILE_QUEUE   Queue,              OPTIONAL
    IN PCTSTR           SectionName,
    IN DWORD            MsgID,
    IN DWORD            Err,
    IN PCTSTR           KeyName             OPTIONAL
);

DWORD
pSetupCopyRelatedInfs(
    IN HINF   hDeviceInf,
    IN PCTSTR InfFileName,                  OPTIONAL
    IN PCTSTR InfSectionName,
    IN DWORD  OEMSourceMediaType,
    IN PSETUP_LOG_CONTEXT LogContext        OPTIONAL
    );

BOOL
pCompareFilesExact(
    IN PCTSTR File1,
    IN PCTSTR File2
    );


//
// Routine to call out to a PSP_FILE_CALLBACK, handles
// Unicode<-->ANSI issues
//
UINT
pSetupCallMsgHandler(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PVOID MsgHandler,
    IN BOOL  MsgHandlerIsNativeCharWidth,
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

UINT
pSetupCallDefaultMsgHandler(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

//
// Internal routine to get MRU list.
//
DWORD
pSetupGetList(
    IN  DWORD    Flags,
    OUT PCTSTR **List,
    OUT PUINT    Count,
    OUT PBOOL    NoBrowse
    );

#define  SRCPATH_USEPNFINFORMATION  0x00000001
#define  SRCPATH_USEINFLOCATION     0x00000002

#define SRC_FLAGS_SVCPACK_SOURCE     (0x0001)


#define PSP_COPY_USE_DRIVERCACHE     0x80000000
#define PSP_COPY_CHK_DRIVERCACHE     0x40000000


PTSTR
pSetupGetDefaultSourcePath(
    IN  HINF   InfHandle,
    IN  DWORD  Flags,
    OUT PDWORD InfSourceMediaType
    );

VOID
InfSourcePathFromFileName(
    IN  PCTSTR  InfFileName,
    OUT PTSTR  *SourcePath,  OPTIONAL
    OUT PBOOL   TryPnf
    );

BOOL
pSetupGetSourceInfo(
    IN  HINF                    InfHandle,         OPTIONAL
    IN  PINFCONTEXT             LayoutLineContext, OPTIONAL
    IN  UINT                    SourceId,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,   OPTIONAL
    IN  UINT                    InfoDesired,
    OUT PTSTR                   ReturnBuffer,      OPTIONAL
    IN  DWORD                   ReturnBufferSize,
    OUT PDWORD                  RequiredSize       OPTIONAL
    );

//
// function to get the apropriate return value for ReturnStatus, for specific callback Notification
//
UINT
pGetCallbackErrorReturn(
    IN UINT Notification,
    IN DWORD ReturnStatus
    );
//
// Routines for creating/destroying global mini-icon list.
//
BOOL
CreateMiniIcons(
    VOID
    );

VOID
DestroyMiniIcons(
    VOID
    );


//
// Global log init/terminate
//

VOID
InitLogApi (
    VOID
    );

VOID
TerminateLogApi (
    VOID
    );



//
// DIRID mapping routines.
//
PCTSTR
pSetupVolatileDirIdToPath(
    IN PCTSTR      DirectoryId,    OPTIONAL
    IN UINT        DirectoryIdInt, OPTIONAL
    IN PCTSTR      SubDirectory,   OPTIONAL
    IN PLOADED_INF Inf
    );

DWORD
ApplyNewVolatileDirIdsToInfs(
    IN PLOADED_INF MasterInf,
    IN PLOADED_INF Inf        OPTIONAL
    );

PCTSTR
pSetupDirectoryIdToPathEx(
    IN     PCTSTR  DirectoryId,        OPTIONAL
    IN OUT PUINT   DirectoryIdInt,     OPTIONAL
    IN     PCTSTR  SubDirectory,       OPTIONAL
    IN     PCTSTR  InfSourcePath,      OPTIONAL
    IN OUT PCTSTR *OsLoaderPath,       OPTIONAL
    OUT    PBOOL   VolatileSystemDirId OPTIONAL
    );

PCTSTR
pGetPathFromDirId(
    IN     PCTSTR      DirectoryId,
    IN     PCTSTR      SubDirectory,   OPTIONAL
    IN     PLOADED_INF pLoadedInf
    );

//
// routines for inter-thread communication
//

#ifndef UNICODE
#define MyMsgWaitForMultipleObjectsEx(nc,ph,dwms,dwwm,dwfl) MsgWaitForMultipleObjects(nc,ph,FALSE,dwms,dwwm)
#else
#define MyMsgWaitForMultipleObjectsEx MsgWaitForMultipleObjectsEx
#endif

//
// Macro to make ansi vs unicode string handling
// a little easier
//
#ifdef UNICODE
#define NewAnsiString(x)        pSetupUnicodeToAnsi(x)
#define NewPortableString(x)    pSetupAnsiToUnicode(x)
#else
#define NewAnsiString(x)        DuplicateString(x)
#define NewPortableString(x)    DuplicateString(x)
#endif

//
// Internal file-handling routines in fileutil.c
//
DWORD
MapFileForRead(
    IN  HANDLE   FileHandle,
    OUT PDWORD   FileSize,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

BOOL
DoMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName
    );

BOOL
DelayedMove(
    IN PCTSTR CurrentName,
    IN PCTSTR NewName       OPTIONAL
    );

extern GUID DriverVerifyGuid;

//
// Flags for VerifySourceFile and _VerifyFile
//
#define VERIFY_FILE_IGNORE_SELFSIGNED         0x00000001
#define VERIFY_FILE_USE_OEM_CATALOGS          0x00000002
#define VERIFY_FILE_FAIL_COPIED_INFS          0x00000004
#define VERIFY_FILE_DRIVERBLOCKED_ONLY        0x00000008
#define VERIFY_FILE_NO_DRIVERBLOCKED_CHECK    0x00000010

DWORD
_VerifyFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin,              OPTIONAL
    IN OUT HSDB                   *hSDBDrvMain,            OPTIONAL
    IN     LPCTSTR                 Catalog,                OPTIONAL
    IN     PVOID                   CatalogBaseAddress,     OPTIONAL
    IN     DWORD                   CatalogImageSize,
    IN     LPCTSTR                 Key,
    IN     LPCTSTR                 FileFullPath,
    OUT    SetupapiVerifyProblem  *Problem,                OPTIONAL
    OUT    LPTSTR                  ProblemFile,            OPTIONAL
    IN     BOOL                    CatalogAlreadyVerified,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    IN     DWORD                   Flags,                  OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    PDWORD                  NumCatalogsConsidered,  OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion           OPTIONAL
    );

DWORD
VerifySourceFile(
    IN  PSETUP_LOG_CONTEXT      LogContext,
    IN  PSP_FILE_QUEUE          Queue,                      OPTIONAL
    IN  PSP_FILE_QUEUE_NODE     QueueNode,                  OPTIONAL
    IN  PCTSTR                  Key,
    IN  PCTSTR                  FileToVerifyFullPath,
    IN  PCTSTR                  OriginalSourceFileFullPath, OPTIONAL
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,            OPTIONAL
    IN  DWORD                   Flags,
    OUT SetupapiVerifyProblem  *Problem,
    OUT LPTSTR                  ProblemFile,
    OUT LPTSTR                  CatalogFileUsed,            OPTIONAL
    OUT LPTSTR                  DigitalSigner,              OPTIONAL
    OUT LPTSTR                  SignerVersion               OPTIONAL
    );

BOOL
VerifyDeviceInfFile(
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT HCATADMIN              *hCatAdmin,              OPTIONAL
    IN     LPCTSTR                 CurrentInfName,
    IN     PLOADED_INF             pInf,
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,        OPTIONAL
    OUT    LPTSTR                  CatalogFileUsed,        OPTIONAL
    OUT    LPTSTR                  DigitalSigner,          OPTIONAL
    OUT    LPTSTR                  SignerVersion           OPTIONAL
    );

BOOL
IsInfForDeviceInstall(
    IN  PSETUP_LOG_CONTEXT       LogContext,           OPTIONAL
    IN  CONST GUID              *DeviceSetupClassGuid, OPTIONAL
    IN  PLOADED_INF              LoadedInf,            OPTIONAL
    OUT PTSTR                   *DeviceDesc,           OPTIONAL
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform,   OPTIONAL
    OUT PDWORD                   PolicyToUse,          OPTIONAL
    OUT PBOOL                    UseOriginalInfName    OPTIONAL
    );

DWORD
GetCodeSigningPolicyForInf(
    IN  PSETUP_LOG_CONTEXT       LogContext,         OPTIONAL
    IN  HINF                     InfHandle,
    OUT PSP_ALTPLATFORM_INFO_V2 *ValidationPlatform, OPTIONAL
    OUT PBOOL                    UseOriginalInfName  OPTIONAL
    );

typedef struct _DRVSIGN_CLASS_LIST_NODE {
    GUID DeviceSetupClassGuid;  // class subject to driver signing policy
    INT MajorVerLB;             // -1 if no validation platform override info
    INT MinorVerLB;             // -1 if no validation platform override info
}  DRVSIGN_CLASS_LIST_NODE, *PDRVSIGN_CLASS_LIST_NODE;

typedef struct _DRVSIGN_POLICY_LIST {
    //
    // Array of device setup class GUIDs for which driver signing policy is
    // applicable, along with validation platform override information (if
    // appropriate).
    //
    PDRVSIGN_CLASS_LIST_NODE Members;

    //
    // Number of elements in above array (initialized to -1).
    //
    INT NumMembers;

    //
    // Synchronization
    //
    MYLOCK Lock;

} DRVSIGN_POLICY_LIST, *PDRVSIGN_POLICY_LIST;

#define LockDrvSignPolicyList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockDrvSignPolicyList(d) EndSynchronizedAccess(&((d)->Lock))

//
// Global "Driver Search In-Progress" list.
//
extern DRVSIGN_POLICY_LIST GlobalDrvSignPolicyList;

BOOL
InitDrvSignPolicyList(
    VOID
    );

VOID
DestroyDrvSignPolicyList(
    VOID
    );


BOOL
IsFileProtected(
    IN  LPCTSTR            FileFullPath,
    IN  PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    OUT PHANDLE            phSfp         OPTIONAL
    );


#define FileExists pSetupFileExists

BOOL
GetVersionInfoFromImage(
    IN  PCTSTR      FileName,
    OUT PDWORDLONG  Version,
    OUT LANGID     *Language
    );

//
// Utils
//

PCTSTR
GetSystemSourcePath(
    TRACK_ARG_DECLARE
    );

PCTSTR
GetServicePackSourcePath(
    TRACK_ARG_DECLARE
    );

DWORD
RegistryDelnode(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName,
    IN  DWORD  ExtraFlags
    );

DWORD
CaptureStringArg(
    IN  PCTSTR  String,
    OUT PCTSTR *CapturedString
    );

DWORD
DelimStringToMultiSz(
    IN PTSTR String,
    IN DWORD StringLen,
    IN TCHAR Delim
    );

BOOL
pAToI(
    IN  PCTSTR Field,
    OUT PINT   IntegerValue
    );

DWORD
pAcquireSCMLock(
    IN  SC_HANDLE  SCMHandle,
    OUT SC_LOCK   *pSCMLock,
    IN  PSETUP_LOG_CONTEXT LogContext
    );

//
// wrapper around pSetupStringTableStringFromIdEx to allocate buffer on fly
//
DWORD
QueryStringTableStringFromId(
    IN PVOID   StringTable,
    IN LONG    StringId,
    IN ULONG   Padding,
    OUT PTSTR *pBuffer
    );



//
// Define flags for DoInstallActionWithParams
//
#define INSTALLACTION_CALL_CI    0x00000001
#define INSTALLACTION_NO_DEFAULT 0x00000002

DWORD
DoInstallActionWithParams(
    IN DI_FUNCTION             InstallFunction,
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN DWORD                   ClassInstallParamsSize,
    IN DWORD                   Flags
    );

BOOL
LookUpStringInTable(
    IN  PSTRING_TO_DATA Table,
    IN  PCTSTR          String,
    OUT PUINT_PTR       Data
    );

//
// Diagnostic/debug functions in debug.c
//

#define DebugPrintEx  pSetupDebugPrintEx

#if DBG

#define MYTRACE(x)  DebugPrintEx x /*(...)*/

#else

#define MYTRACE(x)

#endif

//
// Allow assertion checking to be turned on independently
// of DBG, like by specifying C_DEFINES=-DASSERTS_ON=1 in sources file.
//
#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if ASSERTS_ON

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition,
    IN BOOL NoUI
    );

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x,FALSE); }

#else

#define MYASSERT(x)

#endif


#ifdef _X86_
BOOL
IsNEC98(
    VOID
    );

#endif

//
// Stubs to allow ANSI build to run on Win9x
//

#ifdef DBGHEAP_CHECK

    #ifdef ANSI_SETUPAPI

        #define ASSERT_HEAP_IS_VALID()

    #else

        #define ASSERT_HEAP_IS_VALID()   RtlValidateHeap(pSetupGetHeap(),0,NULL)

    #endif // ANSI_SETUPAPI

#else

    #define ASSERT_HEAP_IS_VALID()

#endif // DBGHEAP_CHECK


//
// TLS data/macro's
//

//
// Diamond TLS data.
//
typedef struct _DIAMOND_THREAD_DATA {

    //
    // Boolean value indicating whether the current thread
    // is inside diamond. Diamond doesn't really providee
    // a full context environment so we declare it non-reentrant.
    //
    BOOL InDiamond;

    //
    // Diamond context data
    //
    HFDI FdiContext;
    ERF FdiError;

    //
    // Last encountered error
    //
    DWORD LastError;

    //
    // Name of cabinet as passed to DiamondProcessCabinet,
    //
    PCTSTR CabinetFile;

    //
    // Notification callback and context parameter
    //
    PVOID MsgHandler;
    PVOID Context;
    BOOL IsMsgHandlerNativeCharWidth;

    //
    // Full path of the current target file being extracted.
    //
    PTSTR CurrentTargetFile;

    //
    // Flag indicating whether diamond asked us to switch cabinets.
    // If we do switch, then we stop copying when the current file
    // is done. This prevents diamond from happily doing each file
    // in the new cabinet, which would ruin the queue commit routine's
    // ability to allow some files to exist outside the cabinet, etc.
    //
    BOOL SwitchedCabinets;

    //
    // If the source path changes as the result of a prompt for a
    // new cabinet (when a file continues across multiple cabinets),
    // we remember the path the user gave us here.
    //
    TCHAR UserPath[MAX_PATH];

} DIAMOND_THREAD_DATA, *PDIAMOND_THREAD_DATA;

typedef struct _SETUP_TLS {
    struct _SETUP_TLS      *Prev;
    struct _SETUP_TLS      *Next;
    //
    // all TLS data used by SetupAPI
    //
    DIAMOND_THREAD_DATA     Diamond;
    SETUP_LOG_TLS           SetupLog;
    DWORD                   PerThreadDoneComponent;
    DWORD                   PerThreadFailedComponent;

} SETUP_TLS, *PSETUP_TLS;

PSETUP_TLS
SetupGetTlsData(
    );


//
// Registration flags.
//
#define SP_GETSTATUS_FROMDLL                0x00000001  // in proc dll registration
#define SP_GETSTATUS_FROMPROCESS            0x00000002  // executable registration
#define SP_GETSTATUS_FROMSURRAGATE          0x00000004  // surragate process dll registration


#if MEM_DBG

//
// these have to be at the bottom to compile
//

#define GetSystemSourcePath()           GetSystemSourcePath(TRACK_ARG_CALL)
#define GetServicePackSourcePath()      GetServicePackSourcePath(TRACK_ARG_CALL)
#define InheritLogContext(a,b)          InheritLogContext(TRACK_ARG_CALL,a,b)

#endif

BOOL
InitComponents(
    DWORD Components
    );

VOID
ComponentCleanup(
    DWORD Components
    );

//#define COMPONENT_OLE                       0x00000001  // need to use OLE
//#define COMPONENT_FUSION                    0x00000002  // need to use Fusion

//
// RetrieveAllDriversForDevice flags
//
#define RADFD_FLAG_FUNCTION_DRIVER          0x00000001
#define RADFD_FLAG_DEVICE_UPPER_FILTERS     0x00000002
#define RADFD_FLAG_DEVICE_LOWER_FILTERS     0x00000004
#define RADFD_FLAG_CLASS_UPPER_FILTERS      0x00000008
#define RADFD_FLAG_CLASS_LOWER_FILTERS      0x00000010

#define RADFD_FLAG_DEVICE_FILTERS           RADFD_FLAG_DEVICE_UPPER_FILTERS | RADFD_FLAG_DEVICE_LOWER_FILTERS
#define RADFD_FLAG_CLASS_FILTERS            RADFD_FLAG_CLASS_UPPER_FILTERS | RADFD_FLAG_CLASS_LOWER_FILTERS
#define RADFD_FLAG_ALL_FILTERS              RADFD_FLAG_DEVICE_FILTERS | RADFD_FLAG_CLASS_FILTERS

BOOL
RetrieveAllDriversForDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *FilterDrivers,
    IN  DWORD          Flags,
    IN  HMACHINE       hMachine
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\resource.c ===
/*++

Copyright (c) 1993-1998 Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Routines that manipulate resources (strings, messages, etc).

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
SetDlgText(
    IN HWND hwndDlg,
    IN INT  iControl,
    IN UINT nStartString,
    IN UINT nEndString
    )
/*++

Routine Description:

    This routine concatenates a number of string resources and does a
    SetWindowText() for a dialog text control.

Arguments:

    hwndDlg - Handle to dialog window

    iControl - Dialog control ID to receive text

    nStartString - ID of first string resource to concatenate

    nEndString - ID of last string resource to concatenate

Return Value:

    None.

Remarks:

    String IDs must be consecutive.

--*/
{
    TCHAR StringBuffer[SDT_MAX_TEXT];
    UINT i;
    INT  Len = 0;

    for(i = nStartString;
        ((i <= nEndString) && (Len < (SDT_MAX_TEXT - 1)));
        i++)
    {
        Len += LoadString(MyDllModuleHandle,
                          i,
                          StringBuffer + Len,
                          SDT_MAX_TEXT - Len
                         );
    }

    if(!Len) {
        StringBuffer[0] = TEXT('\0');
    }

    SetDlgItemText(hwndDlg, iControl, StringBuffer);
}


PTSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Retreive a string from the string resources of this module.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing string. If the string was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    PTSTR Buffer, p;
    int Length, RequiredLength;

    //
    // Start out with a reasonably-sized buffer so that we'll rarely need to
    // grow the buffer and retry (Length is in terms of characters, not bytes).
    //
    Length = LINE_LEN;

    while(TRUE) {

        Buffer = MyMalloc(Length * sizeof(TCHAR));
        if(!Buffer) {
            return NULL;
        }

        RequiredLength = LoadString(MyDllModuleHandle,
                                    StringId,
                                    Buffer,
                                    Length
                                   );
        if(!RequiredLength) {
            *Buffer = TEXT('\0');
            Length = 1;
            break;
        }

        //
        // Because of the way LoadString works, there's no way to
        // tell for sure whether your buffer was big enough in the case where
        // the length returned just fits in the buffer you supplied (the API
        // silently truncates in this case).  Thus, if RequiredLength is exactly
        // the size of our supplied buffer (minus terminating null, which
        // LoadString doesn't count), we increase the buffer size by LINE_LEN
        // characters and try again, to make sure we get the whole string.
        //
        if(RequiredLength < (Length - 1)) {
            //
            // Looks like we got the whole string.  Set the length to be the
            // required length + 1 character, to accommodate the terminating
            // null character.
            //
            Length = RequiredLength + 1;
            break;
        } else {
            MyFree(Buffer);
            Length += LINE_LEN;
        }
    }

    //
    // Resize the buffer to its correct size.  If this fails (which it shouldn't)
    // it's no big deal, it just means we're using a larger buffer for this string
    // than we need to.
    //
    if(p = MyRealloc(Buffer, Length * sizeof(TCHAR))) {
        Buffer = p;
    }

    return Buffer;
}


PTSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Retreive a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

    ArgumentList - supplies list of strings to be substituted in the
        format string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    PTSTR FormatString;
    va_list arglist;
    PTSTR Message;
    PTSTR Return;
    DWORD d;

    //
    // First, load the format string.
    //
    FormatString = MyLoadString(FormatStringId);
    if(!FormatString) {
        return(NULL);
    }

    //
    // Now format the message using the arguements the caller passed.
    //
    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            FormatString,
            0,
            0,
            (PTSTR)&Message,
            0,
            ArgumentList
            );

    MyFree(FormatString);

    if(!d) {
        return(NULL);
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Return = DuplicateString(Message);
    LocalFree((HLOCAL)Message);
    return(Return);
}


PTSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    )

/*++

Routine Description:

    Retreive a string from the string resources of this module and
    format it using FormatMessage.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing formatted message. If the string was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PTSTR p;

    va_start(arglist,FormatStringId);
    p = FormatStringMessageV(FormatStringId,&arglist);
    va_end(arglist);

    return(p);
}


PTSTR
FormatStringMessageFromStringV(
    IN PTSTR    FormatString,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Format the input string using FormatMessage.

Arguments:

    FormatString - supplies the format string.

    ArgumentList - supplies list of strings to be substituted in the
        format string.

Return Value:

    Pointer to buffer containing formatted message. If some error occurred
    formatting the string, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PTSTR Message;
    PTSTR Return;
    DWORD d;

    //
    // Format the message using the arguements the caller passed.
    //
    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            FormatString,
            0,
            0,
            (PTSTR)&Message,
            0,
            ArgumentList
            );

    if(!d) {
        return(NULL);
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Return = DuplicateString(Message);
    LocalFree((HLOCAL)Message);
    return(Return);
}


PTSTR
FormatStringMessageFromString(
    IN PTSTR FormatString,
    ...
    )

/*++

Routine Description:

    Format the input string using FormatMessage.

Arguments:

    FormatString - supplies the format string.

Return Value:

    Pointer to buffer containing formatted message. If some error occurred
    formatting the string, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PTSTR p;

    va_start(arglist,FormatString);
    p = FormatStringMessageFromStringV(FormatString,&arglist);
    va_end(arglist);

    return(p);
}


INT
FormatMessageBox(
    IN HANDLE hinst,
    IN HWND   hwndParent,
    IN UINT   TextMessageId,
    IN PCTSTR Title,
    IN UINT   Style,
    ...
    )
/*++

Routine Description:

    This routine formats two message strings--one containing messagebox text,
    and the other containing a messagebox caption.  The message box is then
    displayed.

    The message ids can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retreived from the system.

Arguments:

    hinst - Supplies the handle of the module containing string resources to
        be used.

    hwndParent - Supplies the handle of window to be the parent of the message box.

    TextMessageId - Supplies message-table identifier or win32 error code
        for the messagebox text.

    TitleMessageId - Supplies message-table identifier or win32 error code
        for the messagebox caption.

    Style - Supplies style flags for the message box.

    ... - Supplies arguments to be inserted in the message text.

Return Value:

    The return value is zero if there is not enough memory to create the message box, or
    if a failure occurred while creating the message box.

    If the function succeeds, the return value is one of the following menu-item values
    returned by the dialog box:

        IDABORT   Abort button was selected.
        IDCANCEL  Cancel button was selected.
        IDIGNORE  Ignore button was selected.
        IDNO      No button was selected.
        IDOK      OK button was selected.
        IDRETRY   Retry button was selected.
        IDYES     Yes button was selected.

    If a message box has a Cancel button, the function returns the IDCANCEL value if
    either the ESC key is pressed or the Cancel button is selected. If the message box
    has no Cancel button, pressing ESC has no effect.

--*/
{
    va_list arglist;
    PTSTR Text = NULL;
    INT ret;

    //
    // We should never be called if we're not interactive.
    //
    MYASSERT(!(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)));

    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        return 0;
    }

    try {

        va_start(arglist, Style);
        Text  = RetreiveAndFormatMessageV(TextMessageId, &arglist);
        va_end(arglist);

        if(Text) {
            //
            // We always beep when we display the message
            //
            MessageBeep(Style & (MB_ICONHAND|MB_ICONEXCLAMATION|MB_ICONQUESTION|MB_ICONASTERISK));
            ret = MessageBox(hwndParent, Text, Title, Style);
        } else {
            ret = 0;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ret = 0;
    }

    if(Text) {
        MyFree(Text);
    }

    return ret;
}


PTSTR
RetreiveAndFormatMessageV(
    IN UINT     MessageId,
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retreived from the system.

Arguments:

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    PTSTR Buffer;
    PTSTR Message;
    TCHAR ModuleName[MAX_PATH];
    TCHAR ErrorNumber[24];
    PTCHAR p;
    PTSTR Args[2];

    d = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
          | ((MessageId < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE),
            (PVOID)MyDllModuleHandle,
            MessageId,
            MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
            (PTSTR)&Buffer,
            0,
            ArgumentList
            );

    if(!d) {
        if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
            return(NULL);
        }

        wsprintf(ErrorNumber,TEXT("%x"),MessageId);
        Args[0] = ErrorNumber;

        Args[1] = ModuleName;

        if(GetModuleFileName(MyDllModuleHandle,ModuleName,MAX_PATH)) {
            if(p = _tcsrchr(ModuleName,TEXT('\\'))) {
                Args[1] = p+1;
            }
        } else {
            ModuleName[0] = 0;
        }

        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                ERROR_MR_MID_NOT_FOUND,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PTSTR)&Buffer,
                0,
                (va_list *)Args
                );

        if(!d) {
            //
            // Give up.
            //
            return(NULL);
        }
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = DuplicateString(Buffer);

    LocalFree((HLOCAL)Buffer);

    return(Message);
}


PTSTR
RetreiveAndFormatMessage(
    IN UINT MessageId,
    ...
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retreived from the system.

Arguments:

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ... - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retreiving it, this buffer will be empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    PTSTR p;

    va_start(arglist,MessageId);
    p = RetreiveAndFormatMessageV(MessageId,&arglist);
    va_end(arglist);

    return(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\oldspapi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oldspapi.c

Abstract:

    Stubs for old (depreciated) private API's

Author:

    Jamie Hunter (jamiehun) June-12-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Memory API's MyMalloc MyFree MyRealloc
//
// these should not be used, however we will support them
// but have them map to LocalXXXX memory API's
//
// This is compatible with SetupGetFileCompressionInfo (argh!)
//

VOID
OldMyFree(
    IN PVOID Block
    )
{
    //
    // superceded by pSetupFree,
    // published externally for freeing memory allocated by SetupGetFileCompressionInfo
    //
    LocalFree(Block);
}

PVOID
OldMyMalloc(
    IN DWORD Size
    )
{
    //
    // superceded by pSetupMalloc
    // we've seen people accidentally or purpously link to this that are also using MyFree
    //
    return (PVOID)LocalAlloc(LPTR,(SIZE_T)Size);
}

PVOID
OldMyRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    )
{
    //
    // superceded by pSetupRealloc
    // we've seen people accidentally or purpously link to this that are also using MyFree
    //
    return (PVOID)LocalReAlloc(Block,(SIZE_T)NewSize,0);
}

//
// Good example of people using undercover API's instead of doing this properly
// anyone (eg SQL-SP2) who uses this will get a no-op effect in Whistler+
//

DWORD
OldInstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,        OPTIONAL
    OUT LPTSTR  NewCatalogFullPath  OPTIONAL
    )
{
    //
    // superceded by pSetupInstallCatalog.  If anyone calls this expecting to
    // be told the catalog full path, they're going to be disappointed...
    //
    if(NewCatalogFullPath) {
        return ERROR_INVALID_PARAMETER;
    } else {
        return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\prompt.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    prompt.c

Abstract:

    Disk/file prompt and file error prompt dialogs.

Author:

    Ted Miller (tedm) 8-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <winnetwk.h>
#include <winnetp.h>
#include <winioctl.h>


//
// Structure used internally to store information
// about the file/disk being prompted for or the copy error
// that has occured. We store a pointer to one of these as
// a window property of the prompt dialog box. This eliminates
// the need for our own dialog class and for global/static variables.
//
typedef struct _PROMPTPARAMS {

    //
    // Reason we are displaying the dialog. One of DLGTYPE_ERROR or
    // DLGTYPE_PROMPT. Used to modify controls and dialog's behavior.
    //
    UINT DialogType;

    //
    // For error dialogs, these values tell us the win32 error code
    // that indicated failure. Used in the details message box.
    //
    UINT Win32Error;

    //
    // Window handle of the prompt/error dialog, and of its owner window,
    // if any.
    //
    HWND hdlg;
    HWND Owner;

    //
    // String to be used as the caption for the prompt/error dialog.
    //
    PCTSTR DialogTitle;

    //
    // Disk tag file. Used when prompting for a disk. We look for
    // this file at the root of the drive to verify presence of the disk.
    //
    PCTSTR TagFile;

    //
    // Desriptive name for the disk where we expect the file to be.
    // This is used even when the source location is non-removable,
    // because the user might elect to furnish the file on disk, etc.
    //
    PCTSTR DiskName;

    //
    // The path to the source file (not including the file name)
    // and the filename part of the source file. This filename is
    // displayed when the user elects to browse and in certain other
    // messages we may display in the dialog box.
    //
    PCTSTR PathToSource;
    PCTSTR FileSought;

    //
    // Full path of the target file, if any. Used for copy errors and rename,
    // so we can tell the user the name of the target file in the details
    // message box.
    //
    PCTSTR TargetFile;

    //
    // IDF_xxx style bits that control behavior of the promt dialog.
    //
    DWORD PromptStyle;

    //
    // Drive type for PathToSource and flag indicating whether
    // it's for removable media.
    //
    UINT DriveType;
    BOOL IsRemovable;

    //
    // List of installation paths, from the registry.
    // Access to that list is not synchronized among processes;
    // oh well.
    //
    PTSTR *PathList;
    UINT PathCount;

    //
    // Flag indicating whether the user has browsed (Browse button)
    // during the lifetime of the dialog invocation.
    //
    BOOL UserBrowsed;

    //
    // Flag indicating whether the user is allowed to type in the combo box
    // edit control.
    //
    BOOL ReadOnlyMru;

    //
    // Identifier of the combo box in use.
    //
    UINT ComboBoxId;

    //
    // Value used to indicate whether or not we're doing a presence check and,
    // if so, whether there's a pending cancel to be processed once we're done
    // (i.e., upon receipt of a WMX_PRESENCE_RESULT message posted from the
    // AuxPromptThread).
    //
    // Possible values are:
    //   == 0 -- not currently doing a presence check--no pending cancels.
    //   == 1 -- currently doing a presence check--no pending cancels.
    //   >= 2 -- currently doing a presence check--one or more pending cancels.
    //
    BOOL PresenceCheckState;

    BOOL BrowseAutoComplete;

#if ASSERTS_ON
    //
    // Make sure that if we fired off a presence check thread, that it has
    // notified us of its completion prior to our processing of WM_DESTROY.
    //
    BOOL PresenceCheckThreadRunning;
    //
    // Keep track of when the dialog's controls are disabled (hence we don't
    // expect to see the OK button pressed).
    //
    BOOL ControlsDisabled;
#endif // ASSERTS_ON

    //
    // Parameters that are passed to the simple message box
    //
    MSGBOXPARAMS MsgBoxParams;

} PROMPTPARAMS, *PPROMPTPARAMS;

//
// PROMPTPARAMS.DialogType
//
#define DLGTYPE_PROMPT  0
#define DLGTYPE_ERROR   1

//
// Define a signature for WMX_PRESENCE_RESULT (contained in lParam) that is
// used to validate the sender as being our own AuxPromptThread.
//
#define PRESENCE_RESULT_SIG  0x52504D53  // "SMPR" (Setupapi Message Presence Result)

//
// Structure used in delete/rename error dialog.
//
typedef struct _FILEERRDLGPARAMS {
    PCTSTR MessageText;
    DWORD Style;
    PCTSTR Caption;
} FILEERRDLGPARAMS, *PFILEERRDLGPARAMS;


//
// Text constants.
//
TCHAR pszDiskPromptPropName[] = TEXT("_diskpromptparams");

//
// Custom window messages
//
#define WMX_PRESENCE_RESULT     (WM_USER+121)
#define WMX_HELLO               (WM_USER+122)
#define WMX_FIXUP_FILENAME      (WM_USER+123)

//
// Linked-list node structure that tracks what temporary connections we
// need to clean up on unload (connections made as a result of user doing
// a "Connect As").
//
typedef struct _TEMP_NET_CONNECTION {

    struct _TEMP_NET_CONNECTION *Next;

    TCHAR NetResourceName[MAX_PATH];

} TEMP_NET_CONNECTION, *PTEMP_NET_CONNECTION;

//
// Global variables that track temporary net connections.
//
PTEMP_NET_CONNECTION NetConnectionList;


//
// global window message for cancelling autoplay.
//
UINT g_uQueryCancelAutoPlay = 0;

//
// Private routine prototypes.
//
BOOL
ConnectToNetShare(
    IN PCTSTR FileName,
    IN HWND   hwndParent
    );


BOOL
IsDriveReallyAHardDrive(
    IN TCHAR DriveLetter
    )
{
    TCHAR DriveNameNt[7];
    HANDLE hDisk;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;
    BOOL b;

#ifdef _X86_
    if(OSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT) {
        //
        // Blow off the win9x case since the win32 support
        // for making this determination is poor at best.
        // A nauseating hack lets this work at least some of
        // the time but PC98 is hosed since the basic assumption that
        // floppies are generally A: and B: is invalid.
        //
        return(!IsNEC98() && (DriveLetter >= TEXT('C')));
    }
#endif

    //
    // NT case allows us to make the determination reliably by opening
    // the drive and reading some attributes.
    //
    wsprintf(DriveNameNt,TEXT("\\\\.\\%c:"),DriveLetter);

    hDisk = CreateFile(
                DriveNameNt,
                FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_GEOMETRY,
            NULL,
            0,
            &MediaInfo,
            sizeof(MediaInfo),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    //
    // It's really a hard disk if the media type is removable.
    //
    return(b && (MediaInfo.MediaType == RemovableMedia));
}


VOID
DiskPromptGetDriveType(
    IN  PCTSTR PathToSource,
    OUT PUINT  DriveType,
    OUT PBOOL  IsRemovable
    )

/*++

Routine Description:

    Determine the drive type of the drive on which a path resides.

    If the path starts with x: we call GetDriveType() on it.
    If GetDriveType fails we assume it's removable.

    If the path starts with \\ we assume it's remote.

    Otherwise we assume it's a relative path on a hard drive.

Arguments:

    PathToSource - pathname of path whose drive type is needed.

    DriveType - receives value indicating drive type. The set of
        possible values is the same as the named constants that can
        be returned by GetDriveType().

    IsRemovable - receives flag indicating whether DriveType
        is a removable media type (floppy, cd-rom).

Return Value:

    None.

--*/

{
    TCHAR DriveRoot[4];
    TCHAR c;

    c = (TCHAR)CharUpper((PTSTR)PathToSource[0]);

    if((c >= TEXT('A')) && (c <= TEXT('Z')) && (PathToSource[1] == TEXT(':'))) {

        DriveRoot[0] = PathToSource[0];
        DriveRoot[1] = PathToSource[1];
        DriveRoot[2] = TEXT('\\');
        DriveRoot[3] = 0;

        *DriveType = GetDriveType(DriveRoot);
        if(*DriveType == DRIVE_NO_ROOT_DIR) {
            //
            // Typically indicates that this drive-letter is invalid
            // we will not get this if drive-letter is valid
            // but media is not inserted.
            //
            *DriveType = DRIVE_UNKNOWN;
        }

        *IsRemovable = ((*DriveType == DRIVE_REMOVABLE) || (*DriveType == DRIVE_CDROM) || (*DriveType == DRIVE_UNKNOWN));

        //
        // If the drive is really a removeable hard drive as opposed to a
        // floppy drive, change the drive type field to indicate a fixed
        // drive, but don't change the removable flag. This allows callers
        // to make this distinction if they need to.
        //
        // If the system is installed on the drive in question, then leave
        // the drive type alone, but indicate that the media is not actually
        // removable.
        //
        if(*DriveType == DRIVE_REMOVABLE) {

            if(IsDriveReallyAHardDrive(c)) {

                *DriveType = DRIVE_FIXED;
            }

            if((WindowsDirectory[0] == PathToSource[0]) && (WindowsDirectory[1] == TEXT(':'))) {

                *IsRemovable = FALSE;
            }
        }
    } else {
        //
        // Not drive letter: so try unc.
        //
        if((PathToSource[0] == TEXT('\\')) && (PathToSource[1] == TEXT('\\'))) {

            *DriveType = DRIVE_REMOTE;
        } else {
            //
            // Not recognized full path spec; assume relative path on HD.
            //
            *DriveType = DRIVE_FIXED;
        }

        *IsRemovable = FALSE;
    }
}


typedef struct _MYOPENPARAMS {
    PCTSTR Filename1;
    PCTSTR Filename2;
    PCTSTR Filename3;
} MYOPENPARAMS, *PMYOPENPARAMS;


UINT_PTR
APIENTRY
BrowseHookProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure used with the OpenFile common dialog
    for file browsing. We use a hook proc so that the user
    is forced to look for only one particular file, and can't
    look at any other file.

Arguments:

    Standard Window Procedure arguments.

Return Value:

    Always FALSE, to indicate that the common dialog should
    process the message.

--*/

{
    HWND hwnd;
    LPOFNOTIFY NotifyParams;
    LPOPENFILENAME OpenParams;
    PMYOPENPARAMS MyOpenParams;
    TCHAR Path[MAX_PATH];
    WIN32_FIND_DATA FindData;
    BOOL b;
    UINT NotifyCode;

    UNREFERENCED_PARAMETER(wParam);

    switch(msg) {

    case WM_INITDIALOG:

        //
        // Save away the OPENFILENAME structure for later.
        //
        SetWindowLongPtr(hdlg,GWLP_USERDATA,lParam);
        break;

    case WMX_FIXUP_FILENAME:
    case WM_NOTIFY:

        if(msg == WM_NOTIFY) {
            NotifyParams = (LPOFNOTIFY)lParam;
            NotifyCode = NotifyParams->hdr.code;
        } else {
            NotifyCode = CDN_FOLDERCHANGE;
        }
        hwnd = GetParent(hdlg);

        switch(NotifyCode) {

        case CDN_INITDONE:
            //
            // Make the "files of type" combo box read-only.
            //
            EnableWindow(GetDlgItem(hwnd,cmb1),FALSE);

            //
            // Post ourselves a message, so that we'll initialize the editbox
            // correctly (we can't do it here, because it's too early).
            //
            PostMessage(hdlg, WMX_FIXUP_FILENAME, 0, 0);
            break;

        case CDN_FOLDERCHANGE:
        case CDN_FILEOK:

            //
            // See if the file actually exists and if so
            // set up the edit control.
            //
            OpenParams = (LPOPENFILENAME)GetWindowLongPtr(hdlg,GWLP_USERDATA);
            MyOpenParams = (PMYOPENPARAMS)OpenParams->lCustData;

            CommDlg_OpenSave_GetFolderPath(hwnd,Path,MAX_PATH);
            pSetupConcatenatePaths(Path,MyOpenParams->Filename1,MAX_PATH,NULL);

            if(FileExists(Path,&FindData)) {

                b = TRUE;

            } else {

                if(MyOpenParams->Filename2) {

                    CommDlg_OpenSave_GetFolderPath(hwnd,Path,MAX_PATH);
                    pSetupConcatenatePaths(Path,MyOpenParams->Filename2,MAX_PATH,NULL);

                    if(FileExists(Path,&FindData)) {

                        b = TRUE;

                    } else {

                        if(MyOpenParams->Filename3) {

                            CommDlg_OpenSave_GetFolderPath(hwnd,Path,MAX_PATH);
                            pSetupConcatenatePaths(Path,MyOpenParams->Filename3,MAX_PATH,NULL);

                            b = FileExists(Path,&FindData);

                        } else {

                            b = FALSE;
                        }
                    }

                } else {

                    b = FALSE;
                }
            }

            if(NotifyCode == CDN_FOLDERCHANGE) {
                if(b) {

                    CommDlg_OpenSave_SetControlText(hwnd, edt1, FindData.cFileName);

                }
            } else {
                if(!b) {
                    MessageBeep(MB_ICONASTERISK);
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,TRUE);
                    return(TRUE);
                }
            }

            break;
        }

        break;
    }

    //
    // Let commdlg process it
    //
    return(FALSE);
}


BOOL
DoBrowse(
    IN HWND          hdlg,
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Allow the user to browse for a file. The user is allowed to look
    only for the file in question -- he is not allowed to change the filter,
    select an alternate file, etc.

Arguments:

    hdlg - supplies the window handle of the window to own the
        browse dialog.

    File - supplies the filename (no path) of the file being looked for.

Return Value:

    TRUE if the user located the file. FALSE otherwise.
    If TRUE, the edit control of the combo box in hdlg has been given the
    final path entered by the user in the browse dialog.

--*/

{
    OPENFILENAME ofn;
    TCHAR Path[MAX_PATH];
    TCHAR Filter[2*MAX_PATH];
    TCHAR InitialDir[MAX_PATH];
    UINT InitialDirDriveType;
    BOOL IsInitialDirOnRemovableDrive, InitialDirMediaPresent;
    PTSTR CompressedFormName;
    BOOL found=FALSE;
    PTSTR p;
    LPCTSTR q;
    PCTSTR File;
    LONG l;
    HKEY hKey1,hKey2;
    DWORD Type;
    DWORD Size;
    BOOL GotDesc;
    MYOPENPARAMS MyParams;

    File = Params->FileSought;

    //
    // Create the compressed-form name of the source file.
    //
    CompressedFormName = (Params->PromptStyle & IDF_NOCOMPRESSED)
                       ? NULL
                       : SetupGenerateCompressedName(File);

    //
    // Build a filter that contains the file we're looking for
    // and its compressed form name, if any. If the file is of
    // the form *.ext then we'll build a more descriptive name.
    //
    GotDesc = FALSE;
    if(!CompressedFormName
    && (File[0] == TEXT('*'))
    && (File[1] == TEXT('.'))
    && File[2]
    && !_tcschr(File+2,TEXT('.'))) {

        l = RegOpenKeyEx(HKEY_CLASSES_ROOT,File+1,0,KEY_QUERY_VALUE,&hKey1);
        if(l == NO_ERROR) {

            Size = sizeof(Filter);
            l = RegQueryValueEx(hKey1,TEXT(""),NULL,&Type,(LPBYTE)Filter,&Size);
            if((l == NO_ERROR) && (Type == REG_SZ)) {

                l = RegOpenKeyEx(HKEY_CLASSES_ROOT,Filter,0,KEY_QUERY_VALUE,&hKey2);
                if(l == NO_ERROR) {

                    Size = sizeof(Filter);
                    l = RegQueryValueEx(hKey2,TEXT(""),NULL,&Type,(LPBYTE)Filter,&Size);
                    if((l == NO_ERROR) && (Type == REG_SZ)) {
                        lstrcat(Filter,TEXT(" ("));
                        lstrcat(Filter,File);
                        lstrcat(Filter,TEXT(")"));

                        p = Filter + lstrlen(Filter) + 1;
                        p += wsprintf(p,File);

                        GotDesc = TRUE;
                    }

                    RegCloseKey(hKey2);
                }
            }

            RegCloseKey(hKey1);
        }
    }

    if(!GotDesc) {
        //
        // Not able to fetch a meaningful description. Use the filenames.
        // The filter has the description and the filespec set to
        // the filename, for both the filename and its compressed form like so:
        // foo.exe;foo.ex_ foo.exe;foo.ex_
        //
        p = Filter + wsprintf(Filter,File);
        if(CompressedFormName) {
            *p++ = TEXT(';');
            p += wsprintf(p,CompressedFormName) + 1;
        } else {
            p++;
        }

        p += wsprintf(p,File);
        if(CompressedFormName) {
            *p++ = TEXT(';');
            p += wsprintf(p,CompressedFormName);
        }
    }

    //
    // Stick the cabinet name in there if we think there is one.
    // We do a dirty hackola to tell the difference between a tag file
    // and a cabinet, namely we look for a .cab extension.
    //
    // Note that at this point p points at the terminating nul
    // of the last filename placed into Filter.
    //
    if(Params->TagFile) {
        l = lstrlen(q = pSetupGetFileTitle(Params->TagFile));

        if((l > 4) && !lstrcmpi((q+l)-4,TEXT(".cab"))) {

            *p++ = TEXT(';');
            p += wsprintf(p,q);
        } else {
            q = NULL;
        }
    } else {
        q = NULL;
    }

    //
    // Add final terminating nul
    //
    *(++p) = 0;

    MyParams.Filename1 = File;
    MyParams.Filename2 = CompressedFormName;
    MyParams.Filename3 = q;

    lstrcpyn(Path,File,MAX_PATH);

    InitialDir[0] = TEXT('\0');
    GetDlgItemText(hdlg,Params->ComboBoxId,InitialDir,MAX_PATH);
    InitialDir[MAX_PATH-1] = TEXT('\0');

    //
    // If the initial directory is on removable media, make sure that the media
    // is present prior to firing off the common dialog.  Otherwise, the user
    // will a popup that the media isn't accessible.
    //
    DiskPromptGetDriveType(InitialDir,
                           &InitialDirDriveType,
                           &IsInitialDirOnRemovableDrive
                          );

    if(IsInitialDirOnRemovableDrive) {
        //
        // We have a removable drive--make sure the media is present.
        // if it's not, we'll probably get ERROR_INVALID_DRIVE
        // if it is, we'll either succeed or get ERROR_FILE_NOT_FOUND
        //
        InitialDirMediaPresent = (FileExists(InitialDir, NULL) ||
                                    GetLastError() == ERROR_FILE_NOT_FOUND);
    } else {
        InitialDirMediaPresent = TRUE;
    }
#ifdef ANSI_SETUPAPI
    ofn.lStructSize = sizeof(OPENFILENAME);
#else
    ofn.lStructSize = GuiSetupInProgress

        ? OPENFILENAME_SIZE_VERSION_400
        : sizeof(OPENFILENAME);
#endif

    ofn.hwndOwner = hdlg;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = Filter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = Path;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = InitialDirMediaPresent ? InitialDir : NULL;
    ofn.lpstrTitle = MyLoadString(IDS_LOCATEFILE);

#ifdef ANSI_SETUPAPI
    ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK | OFN_NOCHANGEDIR
              | OFN_PATHMUSTEXIST | OFN_EXPLORER;
#else
    ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK | OFN_NOCHANGEDIR | OFN_ENABLESIZING
              | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_EXPLORER | OFN_FORCESHOWHIDDEN;
#endif

    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = (LPARAM)&MyParams;
    ofn.lpfnHook = BrowseHookProc;
    ofn.lpTemplateName  = NULL;

    found = GetOpenFileName(&ofn);

    if(ofn.lpstrTitle) {
        MyFree(ofn.lpstrTitle);
    }

    if(CompressedFormName) {
        MyFree(CompressedFormName);
    }

    UpdateWindow(hdlg);

    if(found) {
        //
        // Remove file part, put the resulting directory in the path field
        // This does not cause the string to be added to the combo box list.
        //
        if(ofn.nFileOffset<MAX_PATH) {
            Path[ofn.nFileOffset - 1] = TEXT('\0');
        } else {
            Path[MAX_PATH-1] = TEXT('\0');
        }
        SetDlgItemText(hdlg,Params->ComboBoxId,Path);
        return(TRUE);
    }

    return(FALSE);
}


PTSTR
GetErrorDetails(
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Display a message box with details about a file copy error.

Arguments:

    Params - supplies file error dialog parameters.

Return Value:

    None.

--*/

{
    PTSTR Message;
    TCHAR FullPath[MAX_PATH];
    PTSTR ErrorName;
    PTCHAR p;
    DWORD chars;
    PTSTR ShorterText = NULL;
    TCHAR TargetPath[MAX_PATH];

    //
    // Form full path name.
    //
    lstrcpyn(FullPath,Params->PathToSource,SIZECHARS(FullPath));
    pSetupConcatenatePaths(FullPath,Params->FileSought,MAX_PATH,NULL);

    //
    // try to make the path fit in our dialog
    //
    chars = ExtraChars(GetDlgItem(Params->hdlg,IDT_TEXT2),FullPath);
    if (chars) {
        ShorterText = CompactFileName(FullPath,chars);
        if (ShorterText) {
            lstrcpyn(FullPath, ShorterText,SIZECHARS(FullPath));
            MyFree(ShorterText);
            ShorterText = NULL;
        }
    }

    lstrcpyn(TargetPath, Params->TargetFile,SIZECHARS(TargetPath));
    chars = ExtraChars(GetDlgItem(Params->hdlg,IDT_TEXT2),Params->TargetFile);
    if (chars) {
        ShorterText = CompactFileName(Params->TargetFile,chars);
        if (ShorterText) {
            lstrcpyn(TargetPath, ShorterText,SIZECHARS(TargetPath));
            MyFree(ShorterText);
            ShorterText = NULL;
        }
    }

    //
    // Fetch error description. Remove trailing cr/lf if present.
    //
    ErrorName = RetreiveAndFormatMessage(Params->Win32Error);
    if(ErrorName) {
        p = ErrorName + lstrlen(ErrorName) - 1;
        while((p > ErrorName) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return NULL;
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_DETAILS1,
                    ErrorName,
                    Params->Win32Error,
                    FullPath,
                    TargetPath
                    );

    MyFree(ErrorName);

    return Message;

}


BOOL
DoPresenceCheck(
    IN PPROMPTPARAMS Params,
    IN BOOL          AllowConnectAs
    )

/*++

Routine Description:

    Check for the presence of a source file or source disk.

    If the source path is on removable media and a tag file is
    specified, we attempt to locate the tag file on the root of
    the drive specified by the source path.

    If the source path is not on removable media or a tag file
    is not specified, we look for the file (including compressed-form
    names) in the given path.

Arguments:

    Params - supplies pointer to disk prompt dialog parameters.

    AllowConnectAs - supplies a boolean indicating whether or not this
        routine should give the user a "Connect as:" dialog if they've
        typed in a UNC path that they currently don't have access to.

Return Value:

    TRUE if the disk/file is present and accessible. FALSE if not.

--*/

{
    BOOL b;
    TCHAR FileName[MAX_PATH];
    DWORD d;
    WIN32_FIND_DATA FindData;
    PTSTR p;

    //
    // If there's a tagfile then look for the tag file.
    // Otherwise look for the file in the target path -- note that the
    // file's name could be in compressed form.
    //
    if(Params->TagFile && !Params->UserBrowsed) {

        if(Params->IsRemovable) {
            //
            // Removable media. Look for tag at root.
            // If tag not found at root, look in actual directory.
            //
            MYASSERT(Params->PathToSource[0]);
            MYASSERT(Params->PathToSource[1] == TEXT(':'));

            lstrcpyn(FileName,Params->PathToSource,3);
            pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);

            b = FileExists(FileName,NULL);

            //
            // If we couldn't find the tagfile at the root and the path
            // is not for the root, look for the file in the path also.
            //
            // If we get here, we already know that PathToSource starts
            // with x:. We could have a path of the form x:\foo\bar
            // or x:foo\bar.
            //
            if(!b
            && Params->PathToSource[2]
            && !((Params->PathToSource[2] == TEXT('\\')) && !Params->PathToSource[3])) {

                lstrcpy(FileName,Params->PathToSource);
                pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);
                b = FileExists(FileName,NULL);
            }

            //
            // Additional check for removeable hard drives to allow winnt32
            // to work, because in that case there's no tagfiles!
            //
            if(Params->DriveType == DRIVE_FIXED) {
                goto check1;
            }

        } else {
            //
            // Fixed media. Look for tag in the path where the file
            // is being sought. If it's not found there, look for
            // the file itself. This logic makes cabinets work right.
            //
            lstrcpy(FileName,Params->PathToSource);
            pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);
            b = FileExists(FileName,NULL);

            if(!b && (Params->DriveType == DRIVE_REMOTE)) {

                d = GetLastError();

                if((d == ERROR_ACCESS_DENIED)    || (d == ERROR_WRONG_PASSWORD) ||
                   (d == ERROR_LOGON_FAILURE)    || (d == ERROR_NOT_AUTHENTICATED) ||
                   (d == ERROR_INVALID_PASSWORD) || (d == ERROR_BAD_NETPATH)) {
                    //
                    // If this is a network path, and we got 'access denied'-type of error,
                    // then give the user "Connect As" dialog (if caller specified it's OK).
                    //
                    if(AllowConnectAs && ConnectToNetShare(FileName, Params->hdlg)) {
                        //
                        // We successfully connected to the network share--now try our
                        // file existence check again.
                        //
                        b = FileExists(FileName,NULL);
                    }
                }
            }

            check1:
            if(!b && lstrcmpi(Params->TagFile,Params->FileSought)) {
                //
                // We couldn't find the tagfile and the file we're seeking is
                // not the tagfile. So now we look for the file itself
                // in the path given to us. Note that the name of the file
                // could be the compressed form.
                //
                lstrcpy(FileName,Params->PathToSource);
                pSetupConcatenatePaths(FileName,Params->FileSought,MAX_PATH,NULL);

                d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);

                if(d == NO_ERROR) {
                    MyFree(p);
                    b = TRUE;
                } else {
                    b = FALSE;
                }
            }
        }

    } else {

        lstrcpy(FileName,Params->PathToSource);
        pSetupConcatenatePaths(FileName,Params->FileSought,MAX_PATH,NULL);

        d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);

        if(Params->DriveType == DRIVE_REMOTE) {
            //
            // This is a network path.  If we got an 'access denied'-type of error, then
            // give the user "Connect As" dialog (if caller specified it's OK).
            //
            if((d == ERROR_ACCESS_DENIED)    || (d == ERROR_WRONG_PASSWORD) ||
               (d == ERROR_LOGON_FAILURE)    || (d == ERROR_NOT_AUTHENTICATED) ||
               (d == ERROR_INVALID_PASSWORD) || (d == ERROR_BAD_NETPATH)) {

                if(AllowConnectAs && ConnectToNetShare(FileName, Params->hdlg)) {
                    //
                    // We successfully connected to the network share--now try to find
                    // the source file again.
                    //
                    d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);
                }
            }
        }

        if(d == NO_ERROR) {
            MyFree(p);
            b = TRUE;
        } else {
            //
            // Make cabinet-based browse work by also looking for the tag file.
            // Note sleazy hack that matches a similar sleazy hack in DoBrowse(),
            // namely looking at extension to see if it's .cab.
            //
            b = FALSE;
            if(Params->TagFile) {
                d = lstrlen(Params->TagFile);
                if((d > 4) && !lstrcmpi((Params->TagFile+d)-4,TEXT(".cab"))) {

                    lstrcpy(FileName,Params->PathToSource);
                    pSetupConcatenatePaths(FileName,Params->TagFile,MAX_PATH,NULL);

                    d = SetupDetermineSourceFileName(FileName,&b,&p,&FindData);
                    if(b = (d == NO_ERROR)) {
                        MyFree(p);
                    }
                }
            }
        }
    }

    return(b);
}


void
__cdecl
AuxPromptThread(
    IN void *args
    )

/*++

Routine Description:

    Thread entry point to wrap DoPresenceCheck.
    Calls DoPresenceCheck and then posts a message to the prompt
    dialog indicating the outcome.

Arguments:

    args - supplies file error dialog parameters.

Return Value:

    None.

--*/

{
    PPROMPTPARAMS Params;
    BOOL b;
    HWND hwnd;

    Params = args;

#if ASSERTS_ON
    //
    // Set a flag to indicate that our presence check thread is up and running.
    //
    MYASSERT(!Params->PresenceCheckThreadRunning);
    Params->PresenceCheckThreadRunning = TRUE;
#endif // ASSERTS_ON

    hwnd = Params->hdlg;

    b = DoPresenceCheck(Params, TRUE);

#if ASSERTS_ON
    //
    // The window had better not have gone away!
    //
    MYASSERT(IsWindow(hwnd));
    //
    // Now reset the flag to indicate that our presence check thread is
    // finished.
    //
    Params->PresenceCheckThreadRunning = FALSE;
#endif // ASSERTS_ON

    //
    // Tell the dialog what we found.
    //
    PostMessage(hwnd, WMX_PRESENCE_RESULT, b, PRESENCE_RESULT_SIG);
}


VOID
PresenceCheckSetControls(
    IN PPROMPTPARAMS Params,
    IN BOOL          Starting
    )

/*++

Routine Description:

    Disable or re-enable various controls in the error/prompt dialog
    in preparation for or upon return from a file presence check.
    We do this because the presence check occurs in another thread,
    so the main dialog remains responsive. We don't want the user
    to click OK again while we're checking, etc.

Arguments:

    Params - supplies file error/disk prompt dialog parameters.

    Starting - indicates whether we are preparing for a presence check
        (TRUE) or returning from one (FALSE).

Return Value:

    None.

--*/

{
#if ASSERTS_ON
    if(!Starting) {
        Params->ControlsDisabled = FALSE;
    }
#endif // ASSERTS_ON

    EnableWindow(GetDlgItem(Params->hdlg,IDOK),!Starting);
    EnableWindow(GetDlgItem(Params->hdlg,IDCANCEL),!Starting);
    EnableWindow(GetDlgItem(Params->hdlg,Params->ComboBoxId),!Starting);

    EnableWindow(
        GetDlgItem(Params->hdlg,IDB_BROWSE),
        Starting ? FALSE : !(Params->PromptStyle & IDF_NOBROWSE)
        );

#if ASSERTS_ON
    if(Starting) {
        Params->ControlsDisabled = TRUE;
    }
#endif // ASSERTS_ON
}


BOOL
StartPresenceCheck(
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Perform a presence check, doing the real work asynchronously
    in another thread. See AuxPromptThread().

Arguments:

    Params - supplies file error/disk prompt dialog parameters.

Return Value:

    Boolean value indicating whether the check could be started.
    If FALSE, assume out of memory.

--*/

{
    //
    // need to disable controls so user can't do anything
    // while we're off performing the file presence check.
    //
    PresenceCheckSetControls(Params,TRUE);

    //
    // Make sure we don't already have a presence check going on...
    //
    MYASSERT(Params->PresenceCheckState == 0);

    //
    // Set flag in prompt params to indicate we're doing a presence check.
    //
    Params->PresenceCheckState = 1;

    return(_beginthread(AuxPromptThread,0,Params) != -1);
}


BOOL
InitDiskPromptDialog(
    IN OUT PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Initialize the disk prompt dialog. This involves hiding buttons
    and other control, and setting up static text controls, based on the
    prompt style specified by the caller.

Arguments:

    Params - supplies parameters for the disk prompting

Return Value:

    TRUE if success; FALSE if out of memory.

--*/

{
    int i;
    PTCHAR p,q;
    BOOL b;
    UINT IconId;
    HICON hIcon;
    HWND ComboBox;
    UINT ComboBoxId;
    HWND OtherComboBox;

    //
    // Remember parameter list
    //
    if(!SetProp(Params->hdlg,pszDiskPromptPropName,(HANDLE)Params)) {
        return(FALSE);
    }

    if(!SetWindowText(Params->hdlg,Params->DialogTitle)) {
        return(FALSE);
    }

    //
    // Figure out which combo box to use. This depends on whether
    // we're supposed to have an editable mru.
    //
    ComboBoxId = Params->ReadOnlyMru ? IDC_COMBO2 : IDC_COMBO1;
    ComboBox = GetDlgItem(Params->hdlg,ComboBoxId);
    OtherComboBox = GetDlgItem(Params->hdlg,Params->ReadOnlyMru ? IDC_COMBO1 : IDC_COMBO2);
    Params->ComboBoxId = ComboBoxId;

    ShowWindow(OtherComboBox,SW_HIDE);
    EnableWindow(OtherComboBox,FALSE);

    //
    // Set up combo box title.
    //
    p = MyLoadString((Params->PromptStyle & IDF_OEMDISK) ? IDS_COPYFROMOEM : IDS_COPYFROM);
    if(!p) {
        return(FALSE);
    }
    b = SetDlgItemText(Params->hdlg,IDT_TITLE1,p);
    MyFree(p);
    if(!b) {
        return(FALSE);
    }

    //
    // Set up the combo box.
    //
    for(i=0; i<(int)Params->PathCount; i++) {
        if(SendMessage(ComboBox,CB_ADDSTRING,0,(LPARAM)Params->PathList[i]) < 0) {
            return(FALSE);
        }
    }

    SendMessage(ComboBox,CB_LIMITTEXT,MAX_PATH,0);

    if(Params->ReadOnlyMru) {
        //
        // Select the first string in the list.
        //
        SendMessage(ComboBox,CB_SETCURSEL,0,0);
    } else {
        //
        // Set text of combo box to the path we're searching along.
        // This does not cause the string to be added to the combo box list.
        //
        if(!SetDlgItemText(Params->hdlg,ComboBoxId,Params->PathToSource)) {
            return(FALSE);
        }

#ifdef UNICODE

        if(Params->BrowseAutoComplete) {
            SHAutoComplete(GetWindow(ComboBox, GW_CHILD), SHACF_FILESYS_DIRS);
        }
#endif

    }

    //
    // Hide buttons if necessary.
    //
    if(Params->PromptStyle & IDF_NOBROWSE) {
        ShowWindow(GetDlgItem(Params->hdlg,IDB_BROWSE),SW_HIDE);
        EnableWindow(GetDlgItem(Params->hdlg,IDB_BROWSE),FALSE);
    }

    //
    // Set icon.
    //
    if(Params->DialogType == DLGTYPE_ERROR) {
        hIcon = LoadIcon(NULL,IDI_HAND);
    } else {
        switch(Params->DriveType) {

        case DRIVE_REMOTE:
            IconId = ICON_NETWORK;
            break;

        case DRIVE_CDROM:
            IconId = ICON_CD;
            break;

        case DRIVE_FIXED:
            IconId = ICON_HARD;
            break;

        case DRIVE_REMOVABLE:
        default:
            IconId = ICON_FLOPPY;
            break;
        }

        hIcon = LoadIcon(MyDllModuleHandle,MAKEINTRESOURCE(IconId));
    }

    if(hIcon) {
        SendDlgItemMessage(Params->hdlg,IDI_ICON1,STM_SETICON,(WPARAM)hIcon,0);
    }

    return(TRUE);
}


BOOL
SetDiskPromptDialogText(
    IN OUT PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Set up static text fields that explain to the user what is requested
    and what he has to do to continue. These fields depend on whether we're
    prompting for an oem disk, whether the file is on removable media, and
    whether a tag file has been specified.

Arguments:

    Params - supplies parameters for the disk prompting

Return Value:

    TRUE if success; FALSE if out of memory.

--*/

{
    BOOL b;
    PTSTR p;

    if(Params->DialogType == DLGTYPE_PROMPT) {
        //
        // There are 2 text fields - the explanation and action.
        // What the text looks like depends on the prompt style flags,
        // whether the file is on removable media, etc.
        //
        // First handle the explanation text.
        //
        if (Params->PromptStyle & IDF_USEDISKNAMEASPROMPT) {
            b = SetDlgItemText(Params->hdlg,IDT_TEXT1,Params->DiskName);
        } else {
            if(Params->PromptStyle & IDF_OEMDISK) {
                p = MyLoadString(IDS_DISKPROMPTOEM);
            } else {
                if(Params->IsRemovable && Params->TagFile) {
                    p = FormatStringMessage(IDS_DISKPROMPT1,Params->DiskName);
                } else {
                    p = FormatStringMessage(IDS_DISKPROMPT2,Params->FileSought,Params->DiskName);
                }
            }

            if(!p) {
                return(FALSE);
            }

            b = SetDlgItemText(Params->hdlg,IDT_TEXT1,p);

            MyFree(p);
        }


        if(!b) {
            return(FALSE);
        }

        //
        // Now handle the explanation text. This is hidden for oem disks.
        //
        if(Params->PromptStyle & IDF_OEMDISK) {

            ShowWindow(GetDlgItem(Params->hdlg,IDT_TEXT2),SW_HIDE);
            EnableWindow(GetDlgItem(Params->hdlg,IDT_TEXT2),FALSE);

        } else {
            if(Params->IsRemovable && Params->TagFile) {
                p = FormatStringMessage(IDS_PROMPTACTION1,Params->DiskName);
            } else {
                p = MyLoadString(IDS_PROMPTACTION2);
            }

            if(!p) {
                return(FALSE);
            }

            b = SetDlgItemText(Params->hdlg,IDT_TEXT2,p);

            MyFree(p);
            if(!b) {
                return(FALSE);
            }
        }
    } else {
        if(Params->DialogType != DLGTYPE_ERROR) {
            return(FALSE);
        }

        p = MyLoadString(IDS_RETRY);
        if (!p) {
            return(FALSE);
        }

        b = SetDlgItemText(Params->hdlg,IDOK,p);
        MyFree(p);
        if (!b) {
            return(FALSE);
        }

        //
        // Explanation text -- "An error occurred copying a file" etc.
        //
        p = FormatStringMessage(IDS_FILEERRCOPY,Params->FileSought);
        if(!p) {
            return(FALSE);
        }
        b = SetDlgItemText(Params->hdlg,IDT_TEXT1,p);

        MyFree(p);
        if(!b) {
            return(FALSE);
        }

        //
        // Action text.
        //

        if (Params->Win32Error != ERROR_DIRECTORY &&
            Params->Win32Error != ERROR_DISK_FULL) {
            if(Params->PromptStyle & IDF_OEMDISK) {
                p = MyLoadString(IDS_COPYERROROEM);
            } else {
                if(Params->IsRemovable) {
                    p = FormatStringMessage(IDS_COPYERROR1,Params->DiskName);
                } else {
                    p = FormatStringMessage(IDS_COPYERROR2,Params->DiskName);
                }
            }
        } else {
            p = GetErrorDetails(Params);
        }


        if(!p) {
            return(FALSE);
        }

        b = SetDlgItemText(Params->hdlg,IDT_TEXT2,p);

        MyFree(p);
        if(!b) {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL
WarnSkip(
    IN HWND hwnd,
    IN BOOL Skip
    )

/*++

Routine Description:

    Warn the user that skipping the file or cancelling
    can tank the system.

Arguments:

    hwnd - supplies window handle for window to own the message box
        this routine will display.

    Skip - if TRUE, user is trying to skip the file; FALSE means
        he is trying to cancel.

Return Value:

    TRUE if user wants to skip file/cancel; false otherwise.

--*/

{
    PCTSTR Caption;
    PCTSTR Message;
    BOOL b;

    b = TRUE;
    if(Caption = MyLoadString(IDS_WARNING)) {

        if(Message = MyLoadString(Skip ? IDS_SURESKIP : IDS_SURECANCEL)) {

            b = (MessageBox(hwnd,Message,Caption,MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2) == IDYES);

            MyFree(Message);
        }

        MyFree(Caption);
    }

    return(b);
}


BOOL
CancelAllCopies(
    IN HWND hwnd
    )

/*++

Routine Description:

    ask the user if they want to cancel copying one file or all files

Arguments:

    hwnd - supplies window handle for window to own the message box
        this routine will display.

Return Value:


    TRUE if user wants to cancel just this copy (really the same as skipping a file)
    FALSE if user wants to cancel all copies;

--*/

{
    PCTSTR Caption;
    PCTSTR Message;
    BOOL b;

    b = TRUE;
    if(Caption = MyLoadString(IDS_COPYERROR)) {

        if(Message = MyLoadString(IDS_CANCELALL)) {

            b = (MessageBox(hwnd,Message,Caption,MB_YESNO|MB_ICONWARNING|MB_DEFBUTTON2) == IDYES);

            MyFree(Message);
        }

        MyFree(Caption);
    }

    return(b);
}

INT_PTR
DlgProcSimplePrompt(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for disk prompting dialog.

    The return value for the dialog is

    DPROMPT_CANCEL  - user cancelled
    DPROMPT_SKIPFILE    - user elected to skip file
    DPROMPT_SUCCESS - disk is in the drive/we found the file we're looking for
    DPROMPT_OUTOFMEMORY     - out of memory

Arguments:

    Standard dialog routine parameters.

Return Value:

    TRUE if message processed; FALSE if not.

--*/

{
    BOOL b = FALSE;
    TCHAR Text[MAX_PATH];
    PPROMPTPARAMS PromptParams;
    BOOL WarnIfSkip;
    BOOL ReallyCancel;
    HICON hIcon;
    static DWORD UnitMask = 0xFFFFFFFF;

    switch(msg) {

    case WM_INITDIALOG:

        PromptParams = (PPROMPTPARAMS)lParam;
        MYASSERT(PromptParams != NULL);

        if(!SetProp(hdlg,pszDiskPromptPropName,(HANDLE)&(PromptParams->MsgBoxParams))) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        if(!SetWindowText(hdlg,PromptParams->MsgBoxParams.lpszCaption)) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        if(!SetWindowText(hdlg,PromptParams->MsgBoxParams.lpszCaption)) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        if (!SetDlgItemText(hdlg,IDT_TEXT1,PromptParams->MsgBoxParams.lpszText)) {
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        hIcon = LoadIcon(MyDllModuleHandle,PromptParams->MsgBoxParams.lpszIcon);

        if(hIcon) {
            SendDlgItemMessage(hdlg,IDI_ICON1,STM_SETICON,(WPARAM)hIcon,0);
        }

        pSetupCenterWindowRelativeToParent(hdlg);

        if ((PromptParams->PathToSource[0] != TEXT('\0')) &&
             _istalpha(PromptParams->PathToSource[0])) {
            UnitMask = (1 << (_toupper(PromptParams->PathToSource[0]) - TEXT('A')));
        }

        b = FALSE;
        break;

    case WM_DEVICECHANGE:
        if ((wParam == DBT_DEVICEARRIVAL) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_devicetype == DBT_DEVTYP_VOLUME) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_flags & DBTF_MEDIA) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_unitmask == UnitMask)) {
            //
            // The user inserted a CD or removable media into the source drive,
            // so do an automatic OK so we can check this new media.
            //
            PostMessage(hdlg, WM_COMMAND, MAKELPARAM(IDOK, BN_CLICKED), 0L);
        }
        break;

    case WM_COMMAND:

        if(HIWORD(wParam) == BN_CLICKED) {
            b = TRUE;
            EndDialog(hdlg,LOWORD(wParam));
            break;

        } else {
            b = FALSE;
        }
        break;

    case WM_DESTROY:

        //
        // Nothing to do about this if it fails.
        // Note: the return value is typically a pointer to stack data
        //
        RemoveProp(hdlg,pszDiskPromptPropName);
        //
        // Let default processing take place by indicating that
        // we didn't process this message
        //
        b = FALSE;
        break;

    default:
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == g_uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }


        b = FALSE;
        break;
    }

    return(b);
}



INT_PTR
DlgProcDiskPrompt1(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for disk prompting dialog.

    The return value for the dialog is

    DPROMPT_CANCEL  - user cancelled
    DPROMPT_SKIPFILE    - user elected to skip file
    DPROMPT_SUCCESS - disk is in the drive/we found the file we're looking for
    DPROMPT_OUTOFMEMORY     - out of memory

Arguments:

    Standard dialog routine parameters.

Return Value:

    TRUE if message processed; FALSE if not.

--*/

{
    BOOL b = FALSE;
    PPROMPTPARAMS PromptParams;
    TCHAR Text[MAX_PATH];
    BOOL WarnIfSkip;
    BOOL ReallyCancel;
    static DWORD UnitMask = 0xFFFFFFFF;

    switch(msg) {

    case WM_INITDIALOG:

        PromptParams = (PPROMPTPARAMS)lParam;
        MYASSERT( PromptParams != NULL );
        PromptParams->hdlg = hdlg;

        //
        // Initialize the dialog.
        //
        if(InitDiskPromptDialog(PromptParams) && SetDiskPromptDialogText(PromptParams)) {
            //
            // Set focus to directory combobox and continue.
            //
            SetFocus(GetDlgItem(hdlg, PromptParams->ReadOnlyMru ? IDC_COMBO2 : IDC_COMBO1));
        } else {
            //
            // Out of memory.
            //
            b = TRUE;
            EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
            break;
        }

        //
        // Indicate to windows that we set the focus.
        //
        b = FALSE;

        if(!(PromptParams->PromptStyle & IDF_NOBEEP)) {
            MessageBeep(MB_ICONASTERISK);
        }

        if ((PromptParams->PathToSource[0] != TEXT('\0')) &&
            _istalpha(PromptParams->PathToSource[0])) {
            UnitMask = (1 << (_toupper(PromptParams->PathToSource[0]) - TEXT('A')));
        }

        pSetupCenterWindowRelativeToParent(hdlg);

        PostMessage(hdlg,WMX_HELLO,0,0);
        break;

    case WMX_HELLO:

        b = TRUE;
        PromptParams = (PPROMPTPARAMS)GetProp(hdlg,pszDiskPromptPropName);
        MYASSERT(PromptParams != NULL);

        if(PromptParams && !(PromptParams->PromptStyle & IDF_NOFOREGROUND)) {
            SetForegroundWindow(hdlg);
        }
        break;

    case WM_DEVICECHANGE:
        if ((wParam == DBT_DEVICEARRIVAL) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_devicetype == DBT_DEVTYP_VOLUME) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_flags & DBTF_MEDIA) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_unitmask == UnitMask)) {
            //
            // The user inserted a CD or removable media into the source drive,
            // so do an automatic OK so we can check this new media.
            //
            PostMessage(hdlg, WM_COMMAND, MAKELPARAM(IDOK, BN_CLICKED), 0L);
        }
        break;

    case WM_COMMAND:

        if(HIWORD(wParam) == BN_CLICKED) {

            PromptParams = (PPROMPTPARAMS)GetProp(hdlg,pszDiskPromptPropName);
            MYASSERT(PromptParams != NULL);

            WarnIfSkip = (PromptParams && (PromptParams->PromptStyle & IDF_WARNIFSKIP));

            b = TRUE;
            switch(LOWORD(wParam)) {

            case IDOK:
                //
                // We'd better not get here if controls are disabled!
                //
                MYASSERT(!PromptParams->ControlsDisabled);

                //
                // User might have changed the source path.
                // Get the current path from the combo's edit control
                //
                Text[0] = TEXT('\0'); // default value
                GetDlgItemText(hdlg,PromptParams->ComboBoxId,Text,SIZECHARS(Text));
                Text[SIZECHARS(Text)-1] = TEXT('\0'); // make sure it's terminated.
                MyFree(PromptParams->PathToSource);
                PromptParams->PathToSource = DuplicateString(Text);
                DiskPromptGetDriveType(Text,&PromptParams->DriveType,&PromptParams->IsRemovable);

                //
                // See whether we can get at the file.
                //
                if(!PromptParams->PathToSource || !StartPresenceCheck(PromptParams)) {
                    EndDialog(hdlg,DPROMPT_OUTOFMEMORY);
                }
                break;

            case IDCANCEL:
                //
                // We'd better not get here if controls are disabled!
                //
                MYASSERT(!PromptParams->ControlsDisabled);

                //
                // ask if they want to cancel all copies or just cancel one copy
                //
                if (PromptParams->DialogType != DLGTYPE_ERROR) {
                    ReallyCancel = TRUE;
                } else {
                    if (PromptParams->PromptStyle & IDF_NOSKIP) {
                        ReallyCancel = TRUE;
                    } else {
                        ReallyCancel = !CancelAllCopies(hdlg);
                    }
                }


                if(WarnIfSkip ? WarnSkip(hdlg,!ReallyCancel) : TRUE) {
                    //
                    // If we're currently doing a file presence check, then
                    // just increment our PresenceCheckState value, and defer
                    // the EndDialog until receipt of WMX_PRESENCE_RESULT.
                    //
                    if (ReallyCancel) {
                        if(PromptParams->PresenceCheckState == 0) {
                            EndDialog(hdlg,DPROMPT_CANCEL);
                        } else {
                            (PromptParams->PresenceCheckState)++;
                        }
                    } else {
                        EndDialog(hdlg,DPROMPT_SKIPFILE);
                    }
                }
                break;

            case IDB_BROWSE:
                //
                // We'd better not get here if controls are disabled!
                //
                MYASSERT(!PromptParams->ControlsDisabled);

                if(DoBrowse(hdlg,PromptParams)) {
                    PromptParams->UserBrowsed = TRUE;
                }
                break;

            default:
                b = FALSE;
                break;
            }

        } else {
            b = FALSE;
        }
        break;

    case WM_DESTROY:

#if ASSERTS_ON
        //
        // We'd better not have an outstanding presence check thread running!
        //
        PromptParams = (PPROMPTPARAMS)GetProp(hdlg, pszDiskPromptPropName);
        MYASSERT(PromptParams != NULL);

        if(PromptParams) {
            MYASSERT(!PromptParams->PresenceCheckThreadRunning);
        }

#endif // ASSERTS_ON

        //
        // Nothing to do about this if it fails.
        //
        RemoveProp(hdlg,pszDiskPromptPropName);
        //
        // Let default processing take place by indicating that
        // we didn't process this message
        //
        b = FALSE;
        break;

    case WMX_PRESENCE_RESULT:
        //
        // Make sure this message came from AuxPromptThread--we've seen weird
        // stress failures indicating that someone else was sending us this
        // message from time to time.
        //
        MYASSERT(lParam == PRESENCE_RESULT_SIG);

        //
        // In case the above does happen, just ignore this message...
        //
        if(lParam != PRESENCE_RESULT_SIG) {
            b = FALSE;
            break;
        }

        b = TRUE;
        PromptParams = (PPROMPTPARAMS)GetProp(hdlg,pszDiskPromptPropName);

        //
        // Also, we don't expect to get this message unless we actually had a
        // presence check thread running.
        //
        MYASSERT(PromptParams != NULL);
        MYASSERT(PromptParams->PresenceCheckState);

        //
        // If the user pressed cancel while we were off doing our presence
        // check, then honor that request now.
        //
        if(PromptParams->PresenceCheckState > 1) {
            EndDialog(hdlg, DPROMPT_CANCEL);
        }

        //
        // Aux thread is telling us that it knows whether the file is present.
        // wParam has the boolean.
        // PromptParams->PathToSource is already set.
        //
        if(wParam) {
            EndDialog(hdlg,DPROMPT_SUCCESS);
        } else {

            //
            // File/disk is not accessible. Don't end the dialog.
            //
            if(!(PromptParams->PromptStyle & IDF_NOFOREGROUND)) {
                SetForegroundWindow(hdlg);
            }

            //
            // If we're searching for a directory containing INFs (e.g.,
            // SetupDiSelectOEMDrv), then we want to popup a message informing
            // the user that the location they've specified doesn't contain
            // information about their hardware.  Otherwise, we want to maintain
            // the file prompt behavior of just beeping.
            //
            if(lstrcmpi(PromptParams->FileSought, pszInfWildcard)) {
                if(!(PromptParams->PromptStyle & IDF_NOBEEP)) {
                    MessageBeep(MB_ICONASTERISK);
                }
            } else {
                if(!LoadString(MyDllModuleHandle,
                               IDS_SELECT_DEVICE,
                               Text,
                               SIZECHARS(Text))) {
                    *Text = TEXT('\0');
                }

                FormatMessageBox(MyDllModuleHandle,
                                 NULL,
                                 MSG_NO_DEVICEINFO_ERROR,
                                 Text,
                                 MB_OK | MB_TASKMODAL
                                );
            }

            //
            // Reset value indicating we're no longer doing a presence check.
            //
            PromptParams->PresenceCheckState = 0;

            //
            // Restore controls that were disabled when we started the presence check.
            //
            PresenceCheckSetControls(PromptParams,FALSE);

            SetFocus(GetDlgItem(hdlg,PromptParams->ComboBoxId));
        }
        break;

    default:
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == g_uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }


        b = FALSE;
        break;
    }

    return(b);
}


VOID
ModifyPathList(
    IN PPROMPTPARAMS Params
    )

/*++

Routine Description:

    Modifies a list of installation paths kept in the registry.
    The existing list is scanned for the path the user accepted in the disk
    prompt dialog. That path is added if not already in the list.

Arguments:

    Params - supplies disk prompt dialog parameters.

Return Value:

    None. If any part of the operation, the list simply doesn't get updated
    in the registry.

--*/

{
    //
    // Params->PathToSource will be the final path entered by the user
    // in the combo box. Add to list. If this fails, oh well.
    //
    SetupAddToSourceList(SRCLIST_SYSIFADMIN,Params->PathToSource);
}


UINT
_SetupPromptForDisk(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,      OPTIONAL
    IN  PCTSTR DiskName,         OPTIONAL
    IN  PCTSTR PathToSource,     OPTIONAL
    IN  PCTSTR FileSought,
    IN  PCTSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PTSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    PROMPTPARAMS Params;
    INT_PTR i;
    TCHAR Buffer[256];
    DWORD d;
    DWORD ResultPathLen;
    PTSTR Message;
    HANDLE hDialogEvent = NULL;
    BOOL PromptUser = FALSE;

    //
    // If we're running non-interactive, bail now.  Unless, that is, we've been
    // instructed to check for the presence of the source file _before_ doing
    // any UI, in which case we can hang around until we do our presence check
    // down below.
    //
    if((GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) &&
       !(DiskPromptStyle & IDF_CHECKFIRST)) {

        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    //
    // It is illegal to specify both the IDF_USEDISKNAMEASPROMPT and the
    // IDF_OEMDISK flag.  This is due to the fact that they both cause
    // a different style of UI text to be displayed that would conflict
    // with itself.
    //
    if ((DiskPromptStyle & IDF_USEDISKNAMEASPROMPT) &&
        (DiskPromptStyle & IDF_OEMDISK)) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return DPROMPT_CANCEL;
    }

    ZeroMemory(&Params,sizeof(PROMPTPARAMS));

    //
    // Determine the path to the source. Start by fetching the entire
    // installation locations list for the current user.
    //
    d = pSetupGetList(0,&Params.PathList,&Params.PathCount,&Params.ReadOnlyMru);
    if(d != NO_ERROR) {
        i = DPROMPT_OUTOFMEMORY;
        goto c0;
    }

    if(PathToSource) {
        //
        // Code in dialog box relies on being able to free this
        // so duplicate it here.
        //
        Params.PathToSource = DuplicateString(PathToSource);
    } else {
        if(Params.PathCount) {
            Params.PathToSource = DuplicateString(Params.PathList[0]);
        } else {
            //
            // Nothing in system path lists. Use a reasonable default.
            //
            Params.PathToSource = DuplicateString(pszOemInfDefaultPath);
        }
    }
    if(!Params.PathToSource) {
        i = DPROMPT_OUTOFMEMORY;
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c1;
    }

    //
    // Determine the drive type of the source path.
    //
    DiskPromptGetDriveType(Params.PathToSource,&Params.DriveType,&Params.IsRemovable);

    //
    // If the disk name wasn't specified, fetch a default.
    //
    if(DiskName) {
        Params.DiskName = DiskName;
    } else {
        Params.DiskName = MyLoadString(IDS_UNKNOWN_PARENS);
        if(!Params.DiskName) {
            i = DPROMPT_OUTOFMEMORY;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c2;
        }
    }

    //
    // If a dialog title wasn't specified, try to get text from parent window.
    //
    if(DialogTitle) {
        Params.DialogTitle = DialogTitle;
    } else {

        if(Params.Owner
        && (i = GetWindowTextLength(Params.Owner))
        && GetWindowText(Params.Owner,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {

            Params.DialogTitle = FormatStringMessage(IDS_FILESNEEDED2,Buffer);
        } else {
            Params.DialogTitle = MyLoadString(IDS_FILESNEEDED);
        }

        if(!Params.DialogTitle) {
            i = DPROMPT_OUTOFMEMORY;
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto c3;
        }
    }

    Params.TagFile = TagFile;

    //
    // Validate parent window.
    //
    Params.Owner = IsWindow(hwndParent) ? hwndParent : NULL;

    //
    // Fill in other fields.
    //
    if((Params.FileSought = FileSought) == NULL) {
        i = DPROMPT_CANCEL;
        d = ERROR_INVALID_PARAMETER;
        goto c4;
    }
    Params.Owner = hwndParent;
    Params.PromptStyle = DiskPromptStyle | IDF_NODETAILS;
    Params.hdlg = NULL;
    Params.UserBrowsed = FALSE;
    Params.DialogType = DLGTYPE_PROMPT;
    Params.TargetFile = NULL;

    if(Params.ReadOnlyMru) {
        Params.PromptStyle |= IDF_NOBROWSE;
    }

    if (GuiSetupInProgress) {
        hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
    }

    //
    // If we're supposed to, check for the disk/file first.
    //
    if((DiskPromptStyle & IDF_CHECKFIRST) && DoPresenceCheck(&Params, FALSE)) {

        i = DPROMPT_SUCCESS;
        d = NO_ERROR;

    } else if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {

        i = DPROMPT_CANCEL;
        d = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;

    } else {
        //
        // Before invoking the dialog, we will prompt the user with a simple
        // message box in some cases to avoid the user ever actually seeing
        // a path in the more complicated prompt dialog.
        //
        if(DiskName &&
           !(DiskPromptStyle & IDF_NOREMOVABLEMEDIAPROMPT) &&
           ((Params.DriveType == DRIVE_REMOVABLE) || (Params.DriveType == DRIVE_CDROM))) {

            Message = RetreiveAndFormatMessage(
                        (Params.DriveType == DRIVE_CDROM)
                          ? ( GuiSetupInProgress ? MSG_CDPROMPT_NONETWORK :  MSG_CDPROMPT )
                          : ( GuiSetupInProgress ? MSG_FLOPPYPROMPT_NONETWORK :  MSG_FLOPPYPROMPT ),
                        DiskName,
                        (TCHAR)CharUpper((PTSTR)Params.PathToSource[0])
                        );

            if(Message) {

                LoadString(MyDllModuleHandle,IDS_PROMPTTITLE,Buffer,sizeof(Buffer)/sizeof(TCHAR));
                if(!(DiskPromptStyle & IDF_NOBEEP)) {
                    MessageBeep(MB_ICONASTERISK);
                }

                reprompt:
                Params.MsgBoxParams.cbSize = sizeof(MSGBOXPARAMS);
                Params.MsgBoxParams.hwndOwner = hwndParent;
                Params.MsgBoxParams.hInstance = MyDllModuleHandle;
                Params.MsgBoxParams.lpszText = Message;
                Params.MsgBoxParams.lpszCaption = Buffer;
                Params.MsgBoxParams.dwStyle = MB_USERICON | MB_OKCANCEL;

                Params.MsgBoxParams.lpszIcon = (Params.DriveType == DRIVE_CDROM)
                                      ? MAKEINTRESOURCE(ICON_CD)
                                      : MAKEINTRESOURCE(ICON_FLOPPY);

                Params.MsgBoxParams.lpfnMsgBoxCallback = NULL;
                Params.MsgBoxParams.dwLanguageId = LANG_NEUTRAL;


                if (hDialogEvent) {
                    SetEvent(hDialogEvent);
                }

                switch(DialogBoxParam(
                            MyDllModuleHandle,
                            MAKEINTRESOURCE(IDD_SIMPLEPROMPT),
                            hwndParent,
                            DlgProcSimplePrompt,
                            (LPARAM)&Params
                            )) {

                case DPROMPT_OUTOFMEMORY:
                    i = DPROMPT_OUTOFMEMORY;
                    d = ERROR_NOT_ENOUGH_MEMORY;
                    break;

                case IDOK:
                    if(DoPresenceCheck(&Params, FALSE)) {
                        i = DPROMPT_SUCCESS;
                        d = NO_ERROR;
                    } else {
                        i = DPROMPT_SKIPFILE;
                    }
                    break;

                case IDCANCEL:
                    d = ERROR_CANCELLED;
                    i = DPROMPT_CANCEL;
                    if((DiskPromptStyle & IDF_WARNIFSKIP) && !WarnSkip(hwndParent,FALSE)) {
                        goto reprompt;
                    }
                    break;
                default:
                    MYASSERT( FALSE );
                }

                if (hDialogEvent) {
                    ResetEvent(hDialogEvent);
                }

                MyFree(Message);
            } else {
                i = DPROMPT_OUTOFMEMORY;
                d = ERROR_NOT_ENOUGH_MEMORY;
                goto c4;
            }
        } else {
            i = DPROMPT_SKIPFILE;
        }

        if(i == DPROMPT_SKIPFILE) {

            if (hDialogEvent) {
                SetEvent(hDialogEvent);
            }

            Params.BrowseAutoComplete = FALSE;
            if(!GuiSetupInProgress) {
                d = OleInitialize(NULL);
                if(SUCCEEDED(d)) {
                    Params.BrowseAutoComplete = TRUE;
                }
            }
            i = DialogBoxParam(
                    MyDllModuleHandle,
                    MAKEINTRESOURCE(IDD_DISKPROMPT1),
                    hwndParent,
                    DlgProcDiskPrompt1,
                    (LPARAM)&Params
                    );
            if(!GuiSetupInProgress && (d==NO_ERROR)) {
                OleUninitialize();
            }

            if (hDialogEvent) {
                ResetEvent(hDialogEvent);
            }

            switch(i) {

            case DPROMPT_SUCCESS:
                PromptUser = TRUE;
                d = NO_ERROR;
                break;

            case DPROMPT_SKIPFILE:
                d = NO_ERROR;
                break;

            case DPROMPT_CANCEL:
                d = ERROR_CANCELLED;
                break;

            case DPROMPT_BUFFERTOOSMALL:
                d = ERROR_INSUFFICIENT_BUFFER;
                break;

            default:
                i = DPROMPT_OUTOFMEMORY;
                d = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
    }

    //
    // If success, we want to add the path string to the list of path strings
    // if it's not already in there.
    //
    if(i == DPROMPT_SUCCESS) {

        //
        // Only add the file to the MRU list if we prompted the user and
        // they entered a valid path.
        //
        if (PromptUser) {

            ModifyPathList(&Params);
        }

        //
        // Now determine what to return to the user depending on the
        // buffer and sizes passed in.
        //
        ResultPathLen = lstrlen(Params.PathToSource)+1;
        if(PathRequiredSize) {
            *PathRequiredSize = ResultPathLen;
        }
        if(PathBuffer) {
            if(ResultPathLen > PathBufferSize) {
                i = DPROMPT_BUFFERTOOSMALL;
            } else {
                lstrcpy(PathBuffer,Params.PathToSource);
            }
        }
    }

c4:
    if (hDialogEvent) {
        CloseHandle(hDialogEvent);
    }

    if(!DialogTitle) {
        MyFree(Params.DialogTitle);
    }
c3:
    if(!DiskName) {
        MyFree(Params.DiskName);
    }
c2:
    MyFree(Params.PathToSource);
c1:
    SetupFreeSourceList(&Params.PathList,Params.PathCount);
c0:
    SetLastError(d);
    return((UINT)i);
}

#ifdef UNICODE
//
// ANSI version
//
UINT
SetupPromptForDiskA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  DiskName,         OPTIONAL
    IN  PCSTR  PathToSource,     OPTIONAL
    IN  PCSTR  FileSought,
    IN  PCSTR  TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PSTR   PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    PCWSTR dialogTitle;
    PCWSTR diskName;
    PCWSTR pathToSource;
    PCWSTR fileSought;
    PCWSTR tagFile;
    WCHAR pathBuffer[MAX_PATH];
    CHAR ansiBuffer[MAX_PATH];
    DWORD rc;
    UINT u;
    DWORD Size;

    dialogTitle = NULL;
    diskName = NULL;
    pathToSource = NULL;
    fileSought = NULL;
    tagFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && DiskName) {
        rc = pSetupCaptureAndConvertAnsiArg(DiskName,&diskName);
    }
    if((rc == NO_ERROR) && PathToSource) {
        rc = pSetupCaptureAndConvertAnsiArg(PathToSource,&pathToSource);
    }
    if((rc == NO_ERROR) && FileSought) {
        rc = pSetupCaptureAndConvertAnsiArg(FileSought,&fileSought);
    }
    if((rc == NO_ERROR) && TagFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TagFile,&tagFile);
    }

    if(rc == NO_ERROR) {

        u = _SetupPromptForDisk(
                hwndParent,
                dialogTitle,
                diskName,
                pathToSource,
                fileSought,
                tagFile,
                DiskPromptStyle,
                pathBuffer,
                MAX_PATH,
                &Size
                );

        rc = GetLastError();

        if(u == DPROMPT_SUCCESS) {

            Size = (DWORD)WideCharToMultiByte(
                            CP_ACP,
                            0,
                            pathBuffer,
                            (int)Size,
                            ansiBuffer,
                            MAX_PATH,
                            NULL,
                            NULL
                            );

            if(PathRequiredSize) {
                *PathRequiredSize = Size;
            }

            if(PathBuffer) {
                if(Size > PathBufferSize) {
                    u = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpynA(PathBuffer,ansiBuffer,Size);
                }
            }
        }
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(fileSought) {
        MyFree(fileSought);
    }
    if(tagFile) {
        MyFree(tagFile);
    }

    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupPromptForDiskW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR DiskName,         OPTIONAL
    IN  PCWSTR PathToSource,     OPTIONAL
    IN  PCWSTR FileSought,
    IN  PCWSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PWSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(DiskName);
    UNREFERENCED_PARAMETER(PathToSource);
    UNREFERENCED_PARAMETER(FileSought);
    UNREFERENCED_PARAMETER(TagFile);
    UNREFERENCED_PARAMETER(DiskPromptStyle);
    UNREFERENCED_PARAMETER(PathBuffer);
    UNREFERENCED_PARAMETER(PathBufferSize);
    UNREFERENCED_PARAMETER(PathRequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupPromptForDisk(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,      OPTIONAL
    IN  PCTSTR DiskName,         OPTIONAL
    IN  PCTSTR PathToSource,     OPTIONAL
    IN  PCTSTR FileSought,
    IN  PCTSTR TagFile,          OPTIONAL
    IN  DWORD  DiskPromptStyle,
    OUT PTSTR  PathBuffer,
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize  OPTIONAL
    )
{
    PCTSTR dialogTitle;
    PCTSTR diskName;
    PCTSTR pathToSource;
    PCTSTR fileSought;
    PCTSTR tagFile;
    TCHAR pathBuffer[MAX_PATH];
    DWORD rc;
    UINT u;
    DWORD Size;

    dialogTitle = NULL;
    diskName = NULL;
    pathToSource = NULL;
    fileSought = NULL;
    tagFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = CaptureStringArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && DiskName) {
        rc = CaptureStringArg(DiskName,&diskName);
    }
    if((rc == NO_ERROR) && PathToSource) {
        rc = CaptureStringArg(PathToSource,&pathToSource);
    }
    if((rc == NO_ERROR) && FileSought) {
        rc = CaptureStringArg(FileSought,&fileSought);
    }
    if((rc == NO_ERROR) && TagFile) {
        rc = CaptureStringArg(TagFile,&tagFile);
    }

    if(rc == NO_ERROR) {

        u = _SetupPromptForDisk(
                hwndParent,
                dialogTitle,
                diskName,
                pathToSource,
                fileSought,
                tagFile,
                DiskPromptStyle,
                pathBuffer,
                MAX_PATH,
                &Size
                );

        rc = GetLastError();

        if(u == DPROMPT_SUCCESS) {

            if(PathRequiredSize) {
                *PathRequiredSize = Size;
            }

            if(PathBuffer) {
                if(Size > PathBufferSize) {
                    u = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpyn(PathBuffer,pathBuffer,Size);
                }
            }
        }
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(fileSought) {
        MyFree(fileSought);
    }
    if(tagFile) {
        MyFree(tagFile);
    }

    SetLastError(rc);
    return(u);
}

INT_PTR
DlgProcFileError(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Dialog procedure for delete/rename error dialog.

    The return value for the dialog is

    DPROMPT_CANCEL  - user cancelled
    DPROMPT_SKIPFILE    - user elected to skip file
    DPROMPT_SUCCESS - user said retry
    DPROMPT_OUTOFMEMORY     - out of memory

Arguments:

    Standard dialog routine parameters.

Return Value:

    TRUE if message processed; FALSE if not.

--*/

{
    static PFILEERRDLGPARAMS Params = NULL;
    BOOL b;

    switch(msg) {

    case WM_INITDIALOG:

        Params = (PFILEERRDLGPARAMS)lParam;

        SetDlgItemText(hdlg,IDT_TEXT1,Params->MessageText);
        SetWindowText(hdlg,Params->Caption);

        SendDlgItemMessage(
            hdlg,
            IDI_ICON1,
            STM_SETICON,
            (WPARAM)LoadIcon(NULL,IDI_HAND),
            0
            );

        if(!(Params->Style & IDF_NOBEEP)) {
            MessageBeep(MB_ICONASTERISK);
        }

        if(!(Params->Style & IDF_NOFOREGROUND)) {
            PostMessage(hdlg,WMX_HELLO,0,0);
        }

        pSetupCenterWindowRelativeToParent(hdlg);

        //
        // Set focus to retry button and continue.
        //
        SetFocus(GetDlgItem(hdlg,IDOK));
        b = FALSE;
        break;

    case WMX_HELLO:

        SetForegroundWindow(hdlg);
        b = TRUE;
        break;

    case WM_COMMAND:

        if(HIWORD(wParam) == BN_CLICKED) {

            b = TRUE;
            switch(LOWORD(wParam)) {

            case IDOK:
                EndDialog(hdlg,DPROMPT_SUCCESS);
                break;

            case IDCANCEL:
                if ( (Params->Style & IDF_NOSKIP) || !CancelAllCopies(hdlg)) {
                    EndDialog(hdlg,DPROMPT_CANCEL);
                } else {
                    EndDialog(hdlg,DPROMPT_SKIPFILE);
                }
                break;

            default:
                b = FALSE;
                break;
            }

        } else {
            b = FALSE;
        }
        break;

    default:
        if (!g_uQueryCancelAutoPlay) {
            g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
        }

        if (msg == g_uQueryCancelAutoPlay) {
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 1 );
            return 1;       // cancel auto-play
        }

        b = FALSE;
        break;
    }

    return(b);
}


#ifdef UNICODE
//
// ANSI version
//
UINT
SetupCopyErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,     OPTIONAL
    IN  PCSTR  DiskName,        OPTIONAL
    IN  PCSTR  PathToSource,
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PSTR   PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    )
{
    PCWSTR dialogTitle;
    PCWSTR diskName;
    PCWSTR pathToSource;
    PCWSTR sourceFile;
    PCWSTR targetPathFile;
    WCHAR pathBuffer[MAX_PATH];
    CHAR ansiBuffer[MAX_PATH];
    DWORD rc;
    UINT u;
    DWORD Size;

    dialogTitle = NULL;
    diskName = NULL;
    pathToSource = NULL;
    sourceFile = NULL;
    targetPathFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && DiskName) {
        rc = pSetupCaptureAndConvertAnsiArg(DiskName,&diskName);
    }
    if((rc == NO_ERROR) && PathToSource) {
        rc = pSetupCaptureAndConvertAnsiArg(PathToSource,&pathToSource);
    }
    if((rc == NO_ERROR) && SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && TargetPathFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetPathFile,&targetPathFile);
    }

    if(rc == NO_ERROR) {

        u = SetupCopyErrorW(
                hwndParent,
                dialogTitle,
                diskName,
                pathToSource,
                sourceFile,
                targetPathFile,
                Win32ErrorCode,
                Style,
                pathBuffer,
                MAX_PATH,
                &Size
                );

        rc = GetLastError();

        if(u == DPROMPT_SUCCESS) {

            Size = (DWORD)WideCharToMultiByte(
                            CP_ACP,
                            0,
                            pathBuffer,
                            (int)Size,
                            ansiBuffer,
                            MAX_PATH,
                            NULL,
                            NULL
                            );

            if(PathRequiredSize) {
                *PathRequiredSize = Size;
            }

            if(PathBuffer) {
                if(Size > PathBufferSize) {
                    u = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpynA(PathBuffer,ansiBuffer,Size);
                }
            }
        }
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetPathFile) {
        MyFree(targetPathFile);
    }

    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupCopyErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,     OPTIONAL
    IN  PCWSTR DiskName,        OPTIONAL
    IN  PCWSTR PathToSource,
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PWSTR  PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(DiskName);
    UNREFERENCED_PARAMETER(PathToSource);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(TargetPathFile);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    UNREFERENCED_PARAMETER(PathBuffer);
    UNREFERENCED_PARAMETER(PathBufferSize);
    UNREFERENCED_PARAMETER(PathRequiredSize);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupCopyError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR DiskName,        OPTIONAL
    IN  PCTSTR PathToSource,
    IN  PCTSTR SourceFile,
    IN  PCTSTR TargetPathFile,  OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style,
    OUT PTSTR  PathBuffer,      OPTIONAL
    IN  DWORD  PathBufferSize,
    OUT PDWORD PathRequiredSize OPTIONAL
    )

/*++

Routine Description:

    Inform the user about a file copy error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Copy Error" will be supplied.

    DiskName - if specified, supplies name of the disk from which a source file
        was expected. If not specified a default of "(Unknown)" will be supplied.

    PathToSource - supplies full path part of source file name.

    SourceFile - supplies filename part of the source file name.

    TargetPathFile - if specified supplies the full pathname of the target.

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    INT_PTR i;
    DWORD d = NO_ERROR;
    DWORD TmpRequiredSize;
    HANDLE hDialogEvent = NULL;
    PCTSTR dialogTitle = NULL;
    PCTSTR diskName = NULL;
    PCTSTR pathToSource = NULL;
    PCTSTR sourceFile = NULL;
    PCTSTR targetPathFile = NULL;
    PTSTR  ErrorText = NULL;
    PTSTR  Message = NULL;
    PTSTR p;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    //
    // verify & snap all parameters
    //
    if(DialogTitle) {
        d = CaptureStringArg(DialogTitle,&dialogTitle);
    } else {
        dialogTitle = MyLoadString(IDS_COPYERROR);
        if(!dialogTitle) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if(d == NO_ERROR) {
        if(DiskName) {
            d = CaptureStringArg(DiskName,&diskName);
        } else {
            diskName = MyLoadString(IDS_UNKNOWN_PARENS);
            if(!diskName) {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    if(d == NO_ERROR) {
        if(PathToSource) {
            d = CaptureStringArg(PathToSource,&pathToSource);
        } else {
            d = ERROR_INVALID_PARAMETER;
        }
    }
    if(d == NO_ERROR) {
        if(SourceFile) {
            d = CaptureStringArg(SourceFile,&sourceFile);
        } else {
            d = ERROR_INVALID_PARAMETER;
        }
    }
    if((d == NO_ERROR) && TargetPathFile) {
        d = CaptureStringArg(TargetPathFile,&targetPathFile);
    }
    if(d) {
        if(d == ERROR_NOT_ENOUGH_MEMORY) {
            i = DPROMPT_OUTOFMEMORY;
        } else {
            i = DPROMPT_CANCEL;
        }
        goto clean;
    }

    if(Win32ErrorCode == ERROR_INVALID_TARGET) {
        FILEERRDLGPARAMS FileErrorDlgParams;
        //
        // Fatal copy error not fixed by changing source location
        //
        ErrorText = MyLoadString(IDS_COPY_INVALID_TARGET);
        if(!ErrorText) {
            i = DPROMPT_OUTOFMEMORY;
            goto clean;
        }

        //
        // don't display the error-code in this case
        // just the error text
        //
        Message = RetreiveAndFormatMessage(
                        MSG_FILEERROR_COPY,
                        sourceFile,
                        ErrorText
                        );

        if(!Message) {
            i = DPROMPT_OUTOFMEMORY;
            goto clean;
        }

        FileErrorDlgParams.MessageText = Message;
        FileErrorDlgParams.Style = Style;
        FileErrorDlgParams.Caption = dialogTitle;
        if(!FileErrorDlgParams.Caption) {
            i = DPROMPT_OUTOFMEMORY;
            goto clean;
        }

        if (GuiSetupInProgress) {
            hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
        }

        if ( hDialogEvent ) {
            SetEvent( hDialogEvent );
        }

        d = NO_ERROR;
        i = DialogBoxParam(
                MyDllModuleHandle,
                MAKEINTRESOURCE(IDD_FILEERROR2),
                hwndParent,
                DlgProcFileError,
                (LPARAM)&FileErrorDlgParams
                );

        if ( hDialogEvent ) {
            ResetEvent( hDialogEvent );
            CloseHandle( hDialogEvent );
        }
        if(i == -1) {
            i = DPROMPT_OUTOFMEMORY;
        }

    } else {
        PROMPTPARAMS Params;

        ZeroMemory(&Params,sizeof(PROMPTPARAMS));

        //
        // If the dialog title is not specified fetch a default.
        //
        Params.DialogTitle = dialogTitle;
        Params.DiskName = diskName;
        Params.FileSought = sourceFile;
        Params.PathToSource = pathToSource;
        Params.TargetFile = targetPathFile;
        //
        // assume dialog proc may change any of these
        //
        dialogTitle = NULL;
        diskName = NULL;
        sourceFile = NULL;
        pathToSource = NULL;
        targetPathFile = NULL;
        //
        // There is no tag file usage in the error dialog.
        //
        Params.TagFile = NULL;

        //
        // Determine drive type of source path
        //
        DiskPromptGetDriveType(Params.PathToSource,&Params.DriveType,&Params.IsRemovable);

        //
        // Fetch the installation path list.
        //
        d = pSetupGetList(
                0,
                &Params.PathList,
                &Params.PathCount,
                &Params.ReadOnlyMru
                );

        if(d != NO_ERROR) {
            i = (d == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
            goto clean;
        }

        //
        // Other fields
        //
        Params.Owner = hwndParent;
        Params.PromptStyle = Style;
        Params.UserBrowsed = FALSE;
        Params.DialogType = DLGTYPE_ERROR;
        Params.Win32Error = Win32ErrorCode;

        if(Params.ReadOnlyMru) {
            Params.PromptStyle |= IDF_NOBROWSE;
        }

        if (GuiSetupInProgress) {
            hDialogEvent = CreateEvent(NULL,TRUE,FALSE,SETUP_HAS_OPEN_DIALOG_EVENT);
        }

        if ( hDialogEvent ) {
            SetEvent( hDialogEvent );
        }

        Params.BrowseAutoComplete = FALSE;
        if(!GuiSetupInProgress) {
            d = OleInitialize(NULL);
            if(SUCCEEDED(d)) {
                Params.BrowseAutoComplete = TRUE;
            }
        }
        i = DialogBoxParam(
                MyDllModuleHandle,
                MAKEINTRESOURCE(IDD_DISKPROMPT1),
                hwndParent,
                DlgProcDiskPrompt1,
                (LPARAM)&Params
                );
        if(!GuiSetupInProgress && (d==NO_ERROR)) {
            OleUninitialize();
        }


        if ( hDialogEvent ) {
            ResetEvent( hDialogEvent );
            CloseHandle( hDialogEvent );
        }

        d = GetLastError();
        if(i == DPROMPT_SUCCESS) {
            ModifyPathList(&Params);

            //
            // Now determine what to return to the user depending on the
            // buffer and sizes passed in.
            //
            TmpRequiredSize = lstrlen(Params.PathToSource)+1;
            if(PathRequiredSize) {
                *PathRequiredSize = TmpRequiredSize;
            }

            if(PathBuffer) {
                if(TmpRequiredSize > PathBufferSize) {
                    i = DPROMPT_BUFFERTOOSMALL;
                } else {
                    lstrcpy(PathBuffer,Params.PathToSource);
                }
            }
        }

        SetupFreeSourceList(&Params.PathList,Params.PathCount);
        //
        // release params (either we, or DlgProcDiskPrompt1 allocated the data)
        //
        if (Params.DialogTitle) {
            MyFree(Params.DialogTitle);
        }
        if (Params.DiskName) {
            MyFree(Params.DiskName);
        }
        if (Params.FileSought) {
            MyFree(Params.FileSought);
        }
        if (Params.PathToSource) {
            MyFree(Params.PathToSource);
        }
        if (Params.TargetFile) {
            MyFree(Params.TargetFile);
        }

    }

clean:

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(diskName) {
        MyFree(diskName);
    }
    if(pathToSource) {
        MyFree(pathToSource);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetPathFile) {
        MyFree(targetPathFile);
    }
    if(ErrorText) {
        MyFree(ErrorText);
    }
    if(Message) {
        MyFree(Message);
    }

    SetLastError(d);
    return((UINT)i);
}



#ifdef UNICODE
//
// ANSI version
//
UINT
SetupRenameErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    PCWSTR dialogTitle,sourceFile,targetFile;
    DWORD rc;
    UINT u;

    dialogTitle = NULL;
    sourceFile = NULL;
    targetFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && TargetFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetFile,&targetFile);
    }

    if(rc == NO_ERROR) {
        u = SetupRenameErrorW(
                hwndParent,
                dialogTitle,
                sourceFile,
                targetFile,
                Win32ErrorCode,
                Style
                );
        rc = GetLastError();

    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetFile) {
        MyFree(targetFile);
    }
    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupRenameErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(TargetFile);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupRenameError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR SourceFile,
    IN  PCTSTR TargetFile,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )

/*++

Routine Description:

    Inform the user about a rename error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Rename Error" will be supplied.

    SourceFile - supplies full path and filename of source.

    TargetFile - supplies full path and filename of target.

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    PTSTR ErrorText;
    PTSTR Message;
    PTCHAR p;
    INT_PTR i;
    FILEERRDLGPARAMS FileErrorDlgParams;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    ErrorText = RetreiveAndFormatMessage(Win32ErrorCode);
    if(ErrorText) {
        p = ErrorText + lstrlen(ErrorText) - 1;
        while((p > ErrorText) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return(DPROMPT_OUTOFMEMORY);
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_RENAME,
                    ErrorText,
                    Win32ErrorCode,
                    SourceFile,
                    TargetFile
                    );

    if(!Message) {
        MyFree(ErrorText);
        return(DPROMPT_OUTOFMEMORY);
    }

    FileErrorDlgParams.MessageText = Message;
    FileErrorDlgParams.Style = Style;
    FileErrorDlgParams.Caption = DialogTitle ? DialogTitle : MyLoadString(IDS_RENAMEERROR);
    if(!FileErrorDlgParams.Caption) {
        MyFree(ErrorText);
        MyFree(Message);
        SetLastError(NO_ERROR);
        return(DPROMPT_OUTOFMEMORY);
    }

    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEERROR2),
            hwndParent,
            DlgProcFileError,
            (LPARAM)&FileErrorDlgParams
            );

    MyFree(ErrorText);
    MyFree(Message);
    if(!DialogTitle) {
        MyFree(FileErrorDlgParams.Caption);
    }

    if(i == -1) {
        i = DPROMPT_OUTOFMEMORY;
    }

    SetLastError(NO_ERROR);
    return((UINT)i);
}


#ifdef UNICODE
//
// ANSI version
//
UINT
SetupDeleteErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    PCWSTR dialogTitle,file;
    DWORD rc;
    UINT u;

    dialogTitle = NULL;
    file = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc ==NO_ERROR) && File) {
        rc = pSetupCaptureAndConvertAnsiArg(File,&file);
    }

    if(rc == NO_ERROR) {
        u = SetupDeleteErrorW(hwndParent,dialogTitle,file,Win32ErrorCode,Style);
        rc = GetLastError();
    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(file) {
        MyFree(file);
    }
    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupDeleteErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(File);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupDeleteError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR File,
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )

/*++

Routine Description:

    Inform the user about a rename error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Delete Error" will be supplied.

    File - supplies full path and filename of file being deleted.

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    PTSTR ErrorText;
    PTSTR Message;
    PTCHAR p;
    INT_PTR i;
    FILEERRDLGPARAMS FileErrorDlgParams;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    ErrorText = RetreiveAndFormatMessage(Win32ErrorCode);
    if(ErrorText) {
        p = ErrorText + lstrlen(ErrorText) - 1;
        while((p > ErrorText) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return(DPROMPT_OUTOFMEMORY);
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_DELETE,
                    File,
                    ErrorText,
                    Win32ErrorCode
                    );

    if(!Message) {
        MyFree(ErrorText);
        return(DPROMPT_OUTOFMEMORY);
    }

    FileErrorDlgParams.MessageText = Message;
    FileErrorDlgParams.Style = Style;
    FileErrorDlgParams.Caption = DialogTitle ? DialogTitle : MyLoadString(IDS_DELETEERROR);
    if(!FileErrorDlgParams.Caption) {
        MyFree(ErrorText);
        MyFree(Message);
        return(DPROMPT_OUTOFMEMORY);
    }

    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEERROR2),
            hwndParent,
            DlgProcFileError,
            (LPARAM)&FileErrorDlgParams
            );

    MyFree(ErrorText);
    MyFree(Message);
    if(!DialogTitle) {
        MyFree(FileErrorDlgParams.Caption);
    }

    if(i == -1) {
        i = DPROMPT_OUTOFMEMORY;
    }

    return((UINT)i);
}

#ifdef UNICODE
//
// ANSI version
//
UINT
SetupBackupErrorA(
    IN  HWND   hwndParent,
    IN  PCSTR  DialogTitle,      OPTIONAL
    IN  PCSTR  SourceFile,
    IN  PCSTR  TargetFile,       OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    PCWSTR dialogTitle,sourceFile,targetFile;
    DWORD rc;
    UINT u;

    dialogTitle = NULL;
    sourceFile = NULL;
    targetFile = NULL;
    rc = NO_ERROR;

    if(DialogTitle) {
        rc = pSetupCaptureAndConvertAnsiArg(DialogTitle,&dialogTitle);
    }
    if((rc == NO_ERROR) && SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && TargetFile) {
        rc = pSetupCaptureAndConvertAnsiArg(TargetFile,&targetFile);
    }

    if(rc == NO_ERROR) {
        u = SetupBackupErrorW(
                hwndParent,
                dialogTitle,
                sourceFile,
                targetFile,
                Win32ErrorCode,
                Style
                );
        rc = GetLastError();

    } else {
        u = (rc == ERROR_NOT_ENOUGH_MEMORY) ? DPROMPT_OUTOFMEMORY : DPROMPT_CANCEL;
    }

    if(dialogTitle) {
        MyFree(dialogTitle);
    }
    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(targetFile) {
        MyFree(targetFile);
    }
    SetLastError(rc);
    return(u);
}
#else
//
// Unicode stub
//
UINT
SetupBackupErrorW(
    IN  HWND   hwndParent,
    IN  PCWSTR DialogTitle,      OPTIONAL
    IN  PCWSTR SourceFile,
    IN  PCWSTR TargetFile,       OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(DialogTitle);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(TargetFile);
    UNREFERENCED_PARAMETER(Win32ErrorCode);
    UNREFERENCED_PARAMETER(Style);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(DPROMPT_CANCEL);
}
#endif

UINT
SetupBackupError(
    IN  HWND   hwndParent,
    IN  PCTSTR DialogTitle,     OPTIONAL
    IN  PCTSTR SourceFile,
    IN  PCTSTR TargetFile,      OPTIONAL
    IN  UINT   Win32ErrorCode,
    IN  DWORD  Style
    )

/*++

Routine Description:

    Inform the user about a backup error.

Arguments:

    hwndParent - supplies window handle of window/dialog to own the error dialog
        displayed by this routine.

    DialogTitle - if specified, supplies title for error dialog. If not specified
        a default of "Rename Error" will be supplied.

    SourceFile - supplies full path and filename of file to be backed up

    TargetFile - supplies full path and filename of final name, if known

    Win32ErrorCode - supplies win32 error code of failure.

    Style - supplies flags to control the behavior of the dialog.

Return Value:

    DPROMPT_xxx indicating outcome.

--*/

{
    PTSTR ErrorText;
    PTSTR Message;
    PTCHAR p;
    INT_PTR i;
    FILEERRDLGPARAMS FileErrorDlgParams;

    //
    // If we're running non-interactive, bail now...
    //
    if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
        SetLastError(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION);
        return DPROMPT_CANCEL;
    }

    ErrorText = RetreiveAndFormatMessage(Win32ErrorCode);
    if(ErrorText) {
        p = ErrorText + lstrlen(ErrorText) - 1;
        while((p > ErrorText) && (*p <= TEXT(' '))) {
            *p-- = 0;
        }
    } else {
        return(DPROMPT_OUTOFMEMORY);
    }

    Message = RetreiveAndFormatMessage(
                    MSG_FILEERROR_BACKUP,
                    SourceFile,
                    ErrorText,
                    Win32ErrorCode
                    );

    if(!Message) {
        MyFree(ErrorText);
        return(DPROMPT_OUTOFMEMORY);
    }

    FileErrorDlgParams.MessageText = Message;
    FileErrorDlgParams.Style = Style;
    FileErrorDlgParams.Caption = DialogTitle ? DialogTitle : MyLoadString(IDS_BACKUPERROR);
    if(!FileErrorDlgParams.Caption) {
        MyFree(ErrorText);
        MyFree(Message);
        return(DPROMPT_OUTOFMEMORY);
    }

    i = DialogBoxParam(
            MyDllModuleHandle,
            MAKEINTRESOURCE(IDD_FILEERROR2),
            hwndParent,
            DlgProcFileError,
            (LPARAM)&FileErrorDlgParams
            );

    MyFree(ErrorText);
    MyFree(Message);
    if(!DialogTitle) {
        MyFree(FileErrorDlgParams.Caption);
    }

    if(i == -1) {
        i = DPROMPT_OUTOFMEMORY;
    }

    return((UINT)i);
}


BOOL
ConnectToNetShare(
    IN PCTSTR FileName,
    IN HWND   hwndParent
    )
/*++

Routine Description:

    This routine determines the network share component of the specified file path,
    and give the user a "Connect As" dialog so that they can connect to this share.

Arguments:

    FileName - supplies the path of a file contained in the network share to be
        connected to.

    hwndParent - supplies a handle to the window that should be the parent of the
        "Connect As" dialog.

Return Value:

    If the network share is successfully connected to, the return value is TRUE, otherwise,
    it is FALSE.

--*/
{
    TCHAR TempFileName[MAX_PATH];
    NETRESOURCE NetResourceIn;
    LPNETRESOURCE NetResourceOut = NULL;
    PTSTR TempString;
    DWORD BufferSize, d;
    BOOL Success = FALSE;
    BOOL locked = FALSE;
    PTEMP_NET_CONNECTION NewConnectionNode;


    //
    // Surround this code in try/except, in case we get an exception going out to
    // the network.
    //
    try {
        //
        // Copy the filename into a local (writable) buffer, because the WNet structure
        // doesn't specify its string pointers as CONST, and we don't want to take any chances.
        //
        lstrcpyn(TempFileName, FileName, SIZECHARS(TempFileName));

        ZeroMemory(&NetResourceIn, sizeof(NetResourceIn));

        NetResourceIn.lpRemoteName = TempFileName;
        NetResourceIn.dwType = RESOURCETYPE_DISK;

        //
        // Use a reasonable default buffer size in hopes of avoiding multiple calls to
        // WNetGetResourceInformation.
        //
        BufferSize = sizeof(NETRESOURCE) + (MAX_PATH * sizeof(TCHAR));
        while(TRUE) {

            if(!(NetResourceOut = MyMalloc(BufferSize))) {
                goto clean0;
            }

            d = WNetGetResourceInformation(&NetResourceIn, NetResourceOut, &BufferSize, &TempString);

            if(d == WN_SUCCESS) {
                break;
            } else {
                //
                // Free the buffer currently allocated for the net resource information.
                //
                MyFree(NetResourceOut);
                NetResourceOut = NULL;

                if(d != WN_MORE_DATA) {
                    //
                    // The call failed for some reason other than too small a buffer, so we just
                    // need to bail.
                    //
                    goto clean0;
                }
            }
        }

        //
        // If we get to this point, then we've successfully retrieved network resource information
        // for the caller-supplied path.  Now give the user a chance to connect to that network
        // location.
        //
        if(WNetAddConnection3(hwndParent,
                              NetResourceOut,
                              NULL,
                              NULL,
                              CONNECT_INTERACTIVE | CONNECT_PROMPT) == NO_ERROR) {
            Success = TRUE;

            //
            // Now, add a new node for this connection into our temporary network
            // connections list, so that we can disconnect during DLL unload.
            //
            if(NewConnectionNode = MyMalloc(sizeof(TEMP_NET_CONNECTION))) {
                lstrcpy(NewConnectionNode->NetResourceName, NetResourceOut->lpRemoteName);

                try {
                    EnterCriticalSection(&NetConnectionListCritSect);
                    locked = TRUE;
                    NewConnectionNode->Next = NetConnectionList;
                    NetConnectionList = NewConnectionNode;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                }
                if(locked) {
                    LeaveCriticalSection(&NetConnectionListCritSect);
                }
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Reference the following variable so the compiler will respect our statement
        // ordering for it.
        //
        NetResourceOut = NetResourceOut;
    }

    if(NetResourceOut) {
        MyFree(NetResourceOut);
    }

    return Success;
}


VOID
pSetupInitNetConnectionList(
    IN BOOL Init
    )
/*++

Routine Description:

    This routine initializes/tears down the temporary network connection linked list that is
    used to track what UNC connections the user has made (via "Connect As" dialog) that need
    to be cleaned up on DLL unload.  As the list is being torn down, the network connection
    for each node is deleted.

Arguments:

    Init - specifies whether we're initializing or tearing down this list.

Return Value:

    None.

--*/
{
    PTEMP_NET_CONNECTION CurNode, NextNode;

    if(Init) {
        NetConnectionList = NULL;
    } else {

        for(CurNode = NetConnectionList; CurNode; CurNode = NextNode) {
            //
            // First, attempt to disconnect from this network resource.
            //
            WNetCancelConnection2(CurNode->NetResourceName, 0, FALSE);

            NextNode = CurNode->Next;
            MyFree(CurNode);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\registry.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    registry.c

Abstract:

    Registry interface routines for Windows NT Setup API Dll.

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private function prototypes.
//
DWORD
QueryMultiSzDevRegPropToArray(
    IN  DEVINST  DevInst,
    IN  ULONG    CmPropertyCode,
    OUT PTSTR  **StringArray,
    OUT PUINT    StringCount
    );

DWORD
SetArrayToMultiSzDevRegProp(
    IN DEVINST  DevInst,
    IN ULONG    CmPropertyCode,
    IN PTSTR   *StringArray,
    IN UINT     StringCount
    );


#if MEM_DBG

DWORD
TrackedQueryRegistryValue(
    IN          TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    )
{
    DWORD d;

    TRACK_PUSH

// defined again below
#undef QueryRegistryValue

    d = QueryRegistryValue (
            KeyHandle,
            ValueName,
            Value,
            DataType,
            DataSizeBytes
            );

    TRACK_POP

    return d;
}

#endif


DWORD
QueryRegistryValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    )
{
    LONG l;
    DWORD sz;

    sz = 0;
    l = RegQueryValueEx(KeyHandle,ValueName,NULL,DataType,NULL,&sz);
    *DataSizeBytes = sz;
    if(l != NO_ERROR) {
        return((DWORD)l);
    }

    //
    // If the size of the value entry is 0 bytes, then return success, but with
    // Value set to NULL.
    //
    if(!sz) {
        *Value = NULL;
        return NO_ERROR;
    }

    sz += sizeof(TCHAR)*2; // always pad the buffer with extra zero's

    *Value = MyMalloc(sz);
    if(*Value == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    l = RegQueryValueEx(KeyHandle,ValueName,NULL,DataType,(PVOID)*Value,DataSizeBytes);

    if(l != NO_ERROR) {
        MyFree(*Value);
    } else {
        //
        // write 2 NULL chars to end of buffer
        //
        ZeroMemory(((LPBYTE)*Value)+*DataSizeBytes,sizeof(TCHAR)*2);
    }

    return((DWORD)l);
}

#if MEM_DBG

#define QueryRegistryValue(a,b,c,d,e)   TrackedQueryRegistryValue(TRACK_ARG_CALL,a,b,c,d,e)

#endif

DWORD
QueryRegistryDwordValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PDWORD  Value
    )
{
    DWORD Err;
    DWORD DataType;
    DWORD DataSize;
    PTSTR Data;
    Err = QueryRegistryValue(KeyHandle,ValueName,&Data,&DataType,&DataSize);
    if(Err != NO_ERROR) {
        *Value = 0;
        return Err;
    }
    switch (DataType) {
        case REG_DWORD:
            *Value = *(PDWORD)Data;
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
            *Value = (DWORD)_tcstoul(Data,NULL,0);
            break;

        default:
            *Value = 0;
            break;
    }
    MyFree(Data);
    return NO_ERROR;
}

#if MEM_DBG

DWORD
TrackedQueryDeviceRegistryProperty(
    IN                   TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    )
{
    DWORD d;

    TRACK_PUSH

// defined again below
#undef QueryDeviceRegistryProperty

    d = QueryDeviceRegistryProperty (
            DeviceInfoSet,
            DeviceInfoData,
            Property,
            Value,
            DataType,
            DataSizeBytes
            );

    TRACK_POP

    return d;
}

#endif




DWORD
QueryDeviceRegistryProperty(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            Property,
    OUT PTSTR           *Value,
    OUT PDWORD           DataType,
    OUT PDWORD           DataSizeBytes
    )
{
    DWORD Err;
    DWORD sz;

    sz = 0;
    Err = SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           DataType,
                                           NULL,
                                           0,
                                           &sz)
                                           ? NO_ERROR : GetLastError();

    *DataSizeBytes = sz;
    if((Err != NO_ERROR) && (Err != ERROR_INSUFFICIENT_BUFFER)) {
        return Err;
    }

    //
    // If the size of the value entry is 0 bytes, then return success, but with
    // Value set to NULL.
    //
    if(!sz) {
        *Value = NULL;
        return NO_ERROR;
    }

    sz += sizeof(TCHAR)*2; // always pad the buffer with extra zero's

    *Value = MyMalloc(sz);
    if(*Value == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Err = SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           DataType,
                                           (PVOID)*Value,
                                           *DataSizeBytes,
                                           DataSizeBytes)
                                           ? NO_ERROR : GetLastError();

    if(Err != NO_ERROR) {
        MyFree(*Value);
    } else {
        //
        // write 2 NULL chars to end of buffer
        //
        ZeroMemory(((LPBYTE)*Value)+*DataSizeBytes,sizeof(TCHAR)*2);
    }

    return Err;
}

#if MEM_DBG

#define QueryDeviceRegistryProperty(a,b,c,d,e,f)   TrackedQueryDeviceRegistryProperty(TRACK_ARG_CALL,a,b,c,d,e,f)

#endif



DWORD
pSetupQueryMultiSzValueToArray(
    IN  HKEY     Root,
    IN  PCTSTR   Subkey,
    IN  PCTSTR   ValueName,
    OUT PTSTR  **Array,
    OUT PUINT    StringCount,
    IN  BOOL     FailIfDoesntExist
    )
{
    DWORD d;
    HKEY hKey;
    DWORD DataType;
    DWORD DataSizeBytes;
    PTSTR Value;
    DWORD DataSizeChars;
    INT Count,i;
    PTSTR *array;
    PTSTR p;

    //
    // Open the subkey
    //
    d = RegOpenKeyEx(Root,Subkey,0,KEY_READ,&hKey);
    if((d != NO_ERROR) && FailIfDoesntExist) {
        return(d);
    }

    if(d != NO_ERROR) {
        Value = MyMalloc(sizeof(TCHAR));
        if(!Value) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        *Value = 0;

        DataSizeChars = 1;
        Count = 0;

    } else {

        //
        // Query the value and close the subkey.
        // If the data is not multisz type, we don't know what to
        // do with it here.
        // note that QueryRegistryValue ensures that the string is
        // always correctly double-NULL terminated
        //
        d = QueryRegistryValue(hKey,ValueName,&Value,&DataType,&DataSizeBytes);

        RegCloseKey(hKey);

        if(d != NO_ERROR) {
            if(FailIfDoesntExist) {
                return(d);
            }
        } else if(!DataSizeBytes) {
            //
            // Value entry was zero bytes in length--that's OK as long as the
            // datatype is right.
            //
            if(DataType != REG_MULTI_SZ) {
                return(ERROR_INVALID_DATA);
            }
        }

        if((d != NO_ERROR) || !DataSizeBytes) {
            Value = MyMalloc(sizeof(TCHAR));
            if(!Value) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            *Value = 0;

            DataSizeChars = 1;
            Count = 0;
        } else {

            if(DataType != REG_MULTI_SZ) {
                MyFree(Value);
                return(ERROR_INVALID_DATA);
            }
            DataSizeChars = DataSizeBytes/sizeof(TCHAR);

            for(i=0,p=Value; p[0]; i++,p+=lstrlen(p)+1) {
                //
                // this will always be ok as QueryRegistryValue
                // appends two NULLS onto end of string
                //
                MYASSERT((DWORD)(p-Value) < DataSizeChars);
            }
            Count = i;
        }
    }

    //
    // Allocate an array to hold the pointers (never allocate a zero-length array!)
    //
    if(!(array = MyMalloc(Count ? (Count * sizeof(PTSTR)) : sizeof(PTSTR)))) {
        MyFree(Value);
        return(ERROR_INVALID_DATA);
    }

    //
    // Walk through the multi sz and build the string array.
    //
    for(i=0,p=Value; p[0]; i++,p+=lstrlen(p)+1) {
        MYASSERT(i<Count);

        array[i] = DuplicateString(p);
        if(array[i] == NULL) {
            for(Count=0; Count<i; Count++) {
                MyFree(array[Count]);
            }
            MyFree(array);
            MyFree(Value);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    MyFree(Value);
    *Array = array;
    *StringCount = Count;

    return(NO_ERROR);
}


DWORD
pSetupSetArrayToMultiSzValue(
    IN HKEY     Root,
    IN PCTSTR   Subkey,
    IN PCTSTR   ValueName,
    IN PTSTR   *Array,
    IN UINT     StringCount
    )
{
    UINT i;
    UINT Length;
    UINT BufferSize;
    PTCHAR Buffer;
    PTCHAR p;
    DWORD d;
    HKEY hKey;
    DWORD ActionTaken;

    //
    // Calculate the length of the buffer needed to hold the
    // multi sz value. Note that empty strings are not allowed.
    //
    BufferSize = sizeof(TCHAR);
    for(i=0; i<StringCount; i++) {

        if(Length = lstrlen(Array[i])) {
            BufferSize += (Length + 1) * sizeof(TCHAR);
        } else {
            return(ERROR_INVALID_DATA);
        }
    }

    //
    // Allocate a buffer to hold the data.
    //
    Buffer = MyMalloc(BufferSize);
    if(Buffer == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Copy the string data into the buffer, forming a multi sz.
    //
    for(p=Buffer,i=0; i<StringCount; i++,p+=Length+1) {

        Length = lstrlen(Array[i]);

        lstrcpy(p,Array[i]);
    }
    *p = 0;

    //
    // Open/create the subkey.
    //
    if(Subkey && *Subkey) {
        d = RegCreateKeyEx(
                Root,
                Subkey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE,
                NULL,
                &hKey,
                &ActionTaken
                );
    } else {
        hKey = Root;
        d = NO_ERROR;
    }
    if(d == NO_ERROR) {
        d = RegSetValueEx(
                hKey,
                ValueName,
                0,
                REG_MULTI_SZ,
                (PVOID)Buffer,
                BufferSize
                );

        if(hKey != Root) {
            RegCloseKey(hKey);
        }
    }

    MyFree(Buffer);
    return(d);
}

DWORD
pSetupAppendStringToMultiSz(
    IN HKEY   Key,
    IN PCTSTR SubKeyName,       OPTIONAL
    IN DWORD  DevInst,          OPTIONAL
    IN PCTSTR ValueName,        OPTIONAL
    IN PCTSTR String,
    IN BOOL   AllowDuplicates
    )
/*++

Routine Description:

    "Old" Exported version of pSetupAppendStringToMultiSz
    This doesn't seem to be used anywhere

--*/

{
    REGMOD_CONTEXT RegContext;

    RegContext.Flags = DevInst ? INF_PFLAG_DEVPROP : 0;
    RegContext.UserRootKey = Key;
    RegContext.DevInst = DevInst;
    return _AppendStringToMultiSz(SubKeyName,ValueName,String,AllowDuplicates,&RegContext,0);
}

DWORD
_AppendStringToMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN BOOL             AllowDuplicates,
    IN PREGMOD_CONTEXT  RegContext,         OPTIONAL
    IN UINT             Flags               OPTIONAL
    )

/*++

Routine Description:

    Append a string value to a multi_sz.

Arguments:

    RegContext->UserRootKey - supplies handle to open registry key. The key must have
        KEY_SET_VALUE access.

    SubKeyName - if specified, supplies the name of a subkey of Key
        where the value is to be stored. If not specified or if ""
        then the value is stored in Key.  If supplied and the key
        doesn't exist, the key is created.

    RegContext->DevInst - Optionally, supplies a DEVINST handle for the device
        instance corresponding to the hardware storage key specified
        by 'Key'.  If this handle is specified, and if SubKeyName is
        not specified, then the value name being appended will be
        checked to see whether it is the name of a device registry
        property.  If so, then CM APIs will be used to modify the
        the corresponding registry property, since the Key handle
        represents a separate location under Windows NT.

    ValueName - supplies the value entry name of the multi_sz.
        If not specified or "" then the unnamed entry is used.
        If the value entry does not exist it is created.

    String - supplies the string to be added in to the multi_sz.
        Must not be an empty string.

    AllowDuplicates - if TRUE, then the string is simply appended
        to the multi_sz. Otherwise the string is only appended if
        no instance of it currently exists in the multi_sz.

    RegContext - Passed in from _SetupInstallFromInfSection

    Flags      - Flags that may have been got from the INF and passed to us

Return Value:

    Handle to setup file queue. INVALID_HANDLE_VALUE if insufficient
    memory to create the queue.

--*/

{
    DWORD d;
    DWORD Disposition;
    HKEY hKey;
    PTSTR *Array;
    PVOID p;
    BOOL Append;
    UINT StringCount;
    UINT i;
    BOOL IsDevRegProp = FALSE;
    BOOL IsClassRegProp = FALSE;
    UINT_PTR CmPropertyCode;

    MYASSERT(RegContext);
    //
    // Empty strings really mess up a multi_sz.
    //
    if(!String || !(*String)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Open/create the key.
    //
    if(SubKeyName && *SubKeyName) {
        d = RegCreateKeyEx(
                RegContext->UserRootKey,
                SubKeyName,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
#ifdef _WIN64
                (( Flags & FLG_ADDREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                (( Flags & FLG_ADDREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_SET_VALUE,
                NULL,
                &hKey,
                &Disposition
                );
        if(d != NO_ERROR) {
            return(d);
        }
    } else {
        //
        // If DevInst was specified, then determine whether the specified value is a Plug&Play
        // device registry property.
        //
        if (ValueName && *ValueName) {
            if((RegContext->Flags & INF_PFLAG_CLASSPROP) &&
               (IsClassRegProp = LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a class registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                //
                //d = QueryMultiSzClassRegPropToArray(RegModContext->ClassGuid, CmPropertyCode, &Array, &StringCount);
                //
                // No class properties have MultiSz characteristics, so not implemented
                //
                d = ERROR_INVALID_DATA;

            } else if((RegContext->Flags & INF_PFLAG_DEVPROP) &&
               (IsDevRegProp = LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a device registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                //
                d = QueryMultiSzDevRegPropToArray(RegContext->DevInst, (ULONG)CmPropertyCode, &Array, &StringCount);
            }
        }

        hKey = RegContext->UserRootKey;
    }

    if(!IsDevRegProp && !IsClassRegProp) {
        //
        // Query the existing registry value.
        //
        d = pSetupQueryMultiSzValueToArray(hKey,NULL,ValueName,&Array,&StringCount,FALSE);
    }

    if(d == NO_ERROR) {
        //
        // Determine whether to append or replace.
        // If replacing, we don't need to do anything!
        //
        Append = TRUE;
        if(!AllowDuplicates) {
            for(i=0; i<StringCount; i++) {
                if(!lstrcmpi(Array[i],String)) {
                    Append = FALSE;
                    break;
                }
            }
        }

        if(Append) {
            //
            // Stick the string on the end.
            //
            if(p = MyRealloc(Array, (StringCount+1)*sizeof(PTSTR))) {
                Array = p;
                p = DuplicateString(String);
                if(p) {
                    Array[StringCount++] = p;
                } else {
                    d = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else {
                d = ERROR_NOT_ENOUGH_MEMORY;
            }

            if(IsDevRegProp) {
                d = SetArrayToMultiSzDevRegProp(RegContext->DevInst, (ULONG)CmPropertyCode, Array, StringCount);
            } else if(IsClassRegProp) {
                //
                // not implemented yet, and should return an error before getting here
                //
                MYASSERT(IsClassRegProp == FALSE);

            } else {
                d = pSetupSetArrayToMultiSzValue(hKey,NULL,ValueName,Array,StringCount);
            }
        }

        pSetupFreeStringArray(Array,StringCount);
    }

    if(hKey != RegContext->UserRootKey) {
        RegCloseKey(hKey);
    }

    return(d);
}

DWORD
_DeleteStringFromMultiSz(
    IN PCTSTR           SubKeyName,         OPTIONAL
    IN PCTSTR           ValueName,          OPTIONAL
    IN PCTSTR           String,
    IN UINT             Flags,
    IN PREGMOD_CONTEXT  RegContext          OPTIONAL
    )

/*++

Routine Description:

    Delete a string value from a multi_sz.

Arguments:

    RegContext->UserRootKey - supplies handle to open registry key. The key must have
        KEY_SET_VALUE access.

    SubKeyName - if specified, supplies the name of a subkey of Key
        where the value is to be stored. If not specified or if ""
        then the value is stored in Key.

    RegContext->DevInst - Optionally, supplies a DEVINST handle for the device
        instance corresponding to the hardware storage key specified
        by 'Key'.  If this handle is specified, and if SubKeyName is
        not specified, then the value name being appended will be
        checked to see whether it is the name of a device registry
        property.  If so, then CM APIs will be used to modify the
        the corresponding registry property, since the Key handle
        represents a separate location under Windows NT.

    ValueName - supplies the value entry name of the multi_sz.
        If not specified or "" then the unnamed entry is used.

    String - supplies the string to be added in to the multi_sz.
        Must not be an empty string.

    Flags - indicates what kind of delete operation
            FLG_DELREG_MULTI_SZ_DELSTRING - delete all occurances of string

    RegContext - Passed in from _SetupInstallFromInfSection

Return Value:

    Handle to setup file queue. INVALID_HANDLE_VALUE if insufficient
    memory to create the queue.

--*/

{
    DWORD d;
    DWORD Disposition;
    HKEY hKey;
    PTSTR *Array;
    PVOID p;
    UINT StringCount;
    UINT i;
    BOOL IsDevRegProp = FALSE;
    BOOL IsClassRegProp = FALSE;
    BOOL Modified = FALSE;
    UINT_PTR CmPropertyCode;

    MYASSERT(RegContext);
    //
    // Can't delete an empty string from multi-sz
    //
    if(!String || !(*String)) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Open the key.
    //
    if(SubKeyName && *SubKeyName) {
        d = RegOpenKeyEx(
                RegContext->UserRootKey,
                SubKeyName,
                0,
#ifdef _WIN64
                ((Flags & FLG_DELREG_32BITKEY) ? KEY_WOW64_32KEY:0) |
#else
                ((Flags & FLG_DELREG_64BITKEY) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_SET_VALUE | KEY_QUERY_VALUE,
                &hKey
                );
        if(d != NO_ERROR) {
            return(d);
        }
    } else {
        if (ValueName && *ValueName) {
            //
            // If DevInst was specified, then determine whether the specified value is a Plug&Play
            // device registry property.
            //
            if((RegContext->Flags & INF_PFLAG_CLASSPROP) &&
               (IsClassRegProp = LookUpStringInTable(InfRegValToClassRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a class registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                //
                //d = QueryMultiSzClassRegPropToArray(RegModContext->ClassGuid, CmPropertyCode, &Array, &StringCount);
                //
                // No class properties have MultiSz characteristics, so not implemented
                //
                d = ERROR_INVALID_DATA;

            } else if((RegContext->Flags & INF_PFLAG_DEVPROP) &&
               (IsDevRegProp = LookUpStringInTable(InfRegValToDevRegProp, ValueName, &CmPropertyCode))) {
                //
                // This value is a device registry property.  Retrieve the current property's data, and
                // format it into the same string array as returned by the pSetupQueryMultiSzValueToArray call
                // below.
                // fails if not multi-sz
                //
                d = QueryMultiSzDevRegPropToArray(RegContext->DevInst, (ULONG)CmPropertyCode, &Array, &StringCount);
            }
        }

        hKey = RegContext->UserRootKey;
    }

    if(!IsDevRegProp && !IsClassRegProp) {
        //
        // Query the existing registry value.
        // fails if not multi-sz
        //
        d = pSetupQueryMultiSzValueToArray(hKey,NULL,ValueName,&Array,&StringCount,FALSE);
    }

    if(d == NO_ERROR) {

        switch (Flags) {
            case FLG_DELREG_32BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
            case FLG_DELREG_64BITKEY | FLG_DELREG_MULTI_SZ_DELSTRING:
            case FLG_DELREG_MULTI_SZ_DELSTRING:
                for(i=0; i<StringCount; i++) {
                    if(lstrcmpi(Array[i],String)==0) {
                        //
                        // Need to remove this item.
                        // and re-adjust the list
                        //
                        MyFree(Array[i]);
                        StringCount--;
                        if (i<StringCount) {
                            MoveMemory(
                                &Array[i],
                                &Array[i+1],
                                (StringCount - i) * sizeof(PTSTR)
                                );
                        }
                        i--;

                        Modified = TRUE;
                    }
                }
                break;

            default:
                MYASSERT(FALSE);
                break;
        }

        if (Modified) {

            if(IsDevRegProp) {
                d = SetArrayToMultiSzDevRegProp(RegContext->DevInst, (ULONG)CmPropertyCode, Array, StringCount);
            } else if(IsClassRegProp) {
                //
                // not implemented yet, and should return an error before getting here
                //
                MYASSERT(IsClassRegProp == FALSE);

            } else {
                d = pSetupSetArrayToMultiSzValue(hKey,NULL,ValueName,Array,StringCount);
            }
        }

        pSetupFreeStringArray(Array,StringCount);
    }

    if(hKey != RegContext->UserRootKey) {
        RegCloseKey(hKey);
    }

    return(d);
}

VOID
pSetupFreeStringArray(
    IN PTSTR *Array,
    IN UINT   StringCount
    )
{
    UINT i;

    for(i=0; i<StringCount; i++) {
        MyFree(Array[i]);
    }

    MyFree(Array);
}

DWORD
QueryMultiSzDevRegPropToArray(
    IN  DEVINST  DevInst,
    IN  ULONG    CmPropertyCode,
    OUT PTSTR  **StringArray,
    OUT PUINT    StringCount
    )
/*++

Routine Description:

    This routine retrieves a multi-sz device registry property, and
    formats it into an array of strings.  The caller must free this
    string array by calling pSetupFreeStringArray().

Arguments:

    DevInst - supplies the handle to the device instance for which the
        registry property is to be retrieved.

    CmPropertyCode - specifies the property to be retrieved.  This is
        a CM_DRP value.

    StringArray - supplies the address of a variable that will be set to
        point to the newly-allocated array of strings.

    StringCount - supplies the address of a variable that will receive
        the number of strings in the string array.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an
    ERROR_* code.

--*/
{
    DWORD Err = NO_ERROR;
    CONFIGRET cr;
    ULONG PropDataType, BufferSize = 0;
    PTSTR Buffer = NULL;
    PTSTR *Array = NULL;
    UINT  Count, i;
    PTSTR CurString;

    try {
        //
        // Retrieve the device registry property.
        //
        do {

            if((cr = CM_Get_DevInst_Registry_Property(DevInst,
                                                      CmPropertyCode,
                                                      &PropDataType,
                                                      Buffer,
                                                      &BufferSize,
                                                      0)) != CR_SUCCESS) {
                switch(cr) {

                    case CR_BUFFER_SMALL :
                        //
                        // Allocate a larger buffer.
                        //
                        if(Buffer) {
                            MyFree(Buffer);
                            Buffer = NULL;
                        }
                        if(!(Buffer = MyMalloc(BufferSize))) {
                            Err = ERROR_NOT_ENOUGH_MEMORY;
                            goto clean0;
                        }
                        break;

                    case CR_NO_SUCH_VALUE :
                        //
                        // The specified property doesn't currently exist.  That's
                        // OK--we'll just return an empty string array.
                        //
                        break;

                    case CR_INVALID_DEVINST :
                        Err = ERROR_NO_SUCH_DEVINST;
                        goto clean0;

                    default :
                        Err = ERROR_INVALID_DATA;
                        goto clean0;
                }
            }

        } while(cr == CR_BUFFER_SMALL);

        //
        // By this point, we've either retrieved the property data (CR_SUCCESS), or we've
        // discovered that it doesn't presently exist (CR_NO_SUCH_VALUE).  Allocate space
        // for the array (at least one element, even if there are no strings).
        //
        Count = 0;
        if(cr == CR_SUCCESS) {

            if(PropDataType != REG_MULTI_SZ) {
                Err = ERROR_INVALID_DATA;
                goto clean0;
            }

            if (Buffer) {
                for(CurString = Buffer;
                    *CurString;
                    CurString += (lstrlen(CurString) + 1)) {

                    Count++;
                }
            }
        }

        i = 0;

        if(!(Array = MyMalloc(Count ? (Count * sizeof(PTSTR)) : sizeof(PTSTR)))) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        if(cr == CR_SUCCESS) {

            if (Buffer) {
                for(CurString = Buffer;
                    *CurString;
                    CurString += (lstrlen(CurString) + 1)) {

                    if(Array[i] = DuplicateString(CurString)) {
                        i++;
                    } else {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }
            }
        }

        *StringArray = Array;
        *StringCount = Count;

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variables here so that the compiler will respect our statement
        // ordering w.r.t. these values.  Otherwise, we can't be sure that the values are accurate
        // at the point where the exception occurred.
        //
        Buffer = Buffer;
        Array = Array;
        i = i;
    }

    if(Buffer) {
        MyFree(Buffer);
    }

    if((Err != NO_ERROR) && Array) {
        pSetupFreeStringArray(Array, i);
    }

    return Err;
}


DWORD
SetArrayToMultiSzDevRegProp(
    IN DEVINST  DevInst,
    IN ULONG    CmPropertyCode,
    IN PTSTR   *StringArray,
    IN UINT     StringCount
    )
/*++

Routine Description:

    This routine converts a string array into a multi-sz buffer, and
    sets the specified device registry property to its contents.

Arguments:

    DevInst - supplies the handle to the device instance for which the
        registry property is to be set.

    CmPropertyCode - specifies the property to be set.  This is a
        CM_DRP value.

    StringArray - supplies the string array to use in creating the
        multi-sz buffer.

    StringCount - supplies the number of strings in the array.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an
    ERROR_* code.

--*/
{
    UINT i;
    UINT Length;
    UINT BufferSize;
    PTCHAR Buffer;
    PTCHAR p;
    DWORD d;
    CONFIGRET cr;

    //
    // Calculate the length of the buffer needed to hold the
    // multi sz value. Note that empty strings are not allowed.
    //
    BufferSize = StringCount ? sizeof(TCHAR) : (2 * sizeof(TCHAR));
    for(i=0; i<StringCount; i++) {

        if(Length = lstrlen(StringArray[i])) {
            BufferSize += (Length + 1) * sizeof(TCHAR);
        } else {
            return(ERROR_INVALID_DATA);
        }
    }

    d = NO_ERROR;

    //
    // Allocate a buffer to hold the data.
    //
    if(!(Buffer = MyMalloc(BufferSize))) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    try {
        //
        // Copy the string data into the buffer, forming a multi sz.
        //
        p = Buffer;
        if(StringCount) {
            for(i=0; i<StringCount; i++, p+=Length+1) {

                Length = lstrlen(StringArray[i]);

                lstrcpy(p, StringArray[i]);
            }
        } else {
            *(p++) = TEXT('\0');
        }
        *p = TEXT('\0');

        if((cr = CM_Set_DevInst_Registry_Property(DevInst,
                                                  CmPropertyCode,
                                                  Buffer,
                                                  BufferSize,
                                                  0)) != CR_SUCCESS) {

            d = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                           : ERROR_INVALID_DATA;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        d = ERROR_INVALID_PARAMETER;
    }

    MyFree(Buffer);
    return(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\ansi\makefile.inc ===
!include ..\makefile.inc

msg.h msg00001.bin msg.rc: ..\msg.mc
        mc -a -v ..\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\ansi\precomp.h ===
#include "setupntp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\spfusion.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    spfusion.h

Abstract:

    Wrappers and functions for fusionizing SetupAPI
    without effecting 3rd party DLL's
    and without dll-load overhead

Author:

    Jamie Hunter (JamieHun) 12/4/2000

Revision History:

--*/

//
// redirect these API's to our internal implementation
// that initializes fusion if needed
//

#ifdef FUSIONAWARE

#undef CreateWindow
#undef CreateWindowEx
#undef CreateDialogParam
#undef CreateDialogIndirectParam
#undef DialogBoxParam
#undef DialogBoxIndirectParam
#undef MessageBox
#undef PropertySheet
#undef CreatePropertySheetPage
#undef DestroyPropertySheetPage
#undef ImageList_Create
#undef ImageList_Destroy
#undef ImageList_GetImageCount
#undef ImageList_SetImageCount
#undef ImageList_Add
#undef ImageList_ReplaceIcon
#undef ImageList_SetBkColor
#undef ImageList_GetBkColor
#undef ImageList_SetOverlayImage
#undef GetOpenFileName
#undef GetSaveFileName
#undef ChooseColor
#undef ChooseFont
#undef CommDlgExtendedError
#undef FindText
#undef GetFileTitle
#undef PageSetupDlg
#undef PrintDlg
#undef PrintDlgEx
#undef ReplaceText

#define CreateWindow                   spFusionCreateWindow
#define CreateWindowEx                 spFusionCreateWindowEx
#define CreateDialogParam              spFusionCreateDialogParam
#define CreateDialogIndirectParam      spFusionCreateDialogIndirectParam
#define DialogBoxParam                 spFusionDialogBoxParam
#define DialogBoxIndirectParam         spFusionDialogBoxIndirectParam
#define MessageBox                     spFusionMessageBox
#define PropertySheet                  spFusionPropertySheet
#define CreatePropertySheetPage        spFusionCreatePropertySheetPage
#define DestroyPropertySheetPage       spFusionDestroyPropertySheetPage
#define ImageList_Create               spFusionImageList_Create
#define ImageList_Destroy              spFusionImageList_Destroy
#define ImageList_GetImageCount        spFusionImageList_GetImageCount
#define ImageList_SetImageCount        spFusionImageList_SetImageCount
#define ImageList_Add                  spFusionImageList_Add
#define ImageList_ReplaceIcon          spFusionImageList_ReplaceIcon
#define ImageList_SetBkColor           spFusionImageList_SetBkColor
#define ImageList_GetBkColor           spFusionImageList_GetBkColor
#define ImageList_SetOverlayImage      spFusionImageList_SetOverlayImage
#define GetOpenFileName                spFusionGetOpenFileName


BOOL spFusionInitialize();
BOOL spFusionUninitialize(BOOL Full);

HWND spFusionCreateWindow(
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            );

HWND spFusionCreateWindowEx(
            DWORD dwExStyle,      // extended window style
            LPCTSTR lpClassName,  // registered class name
            LPCTSTR lpWindowName, // window name
            DWORD dwStyle,        // window style
            int x,                // horizontal position of window
            int y,                // vertical position of window
            int nWidth,           // window width
            int nHeight,          // window height
            HWND hWndParent,      // handle to parent or owner window
            HMENU hMenu,          // menu handle or child identifier
            HINSTANCE hInstance,  // handle to application instance
            LPVOID lpParam        // window-creation data
            );

HWND spFusionCreateDialogParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
            );

HWND spFusionCreateDialogIndirectParam(
            HINSTANCE hInstance,        // handle to module
            LPCDLGTEMPLATE lpTemplate,  // dialog box template
            HWND hWndParent,            // handle to owner window
            DLGPROC lpDialogFunc,       // dialog box procedure
            LPARAM lParamInit           // initialization value
            );

INT_PTR spFusionDialogBoxParam(
            HINSTANCE hInstance,     // handle to module
            LPCTSTR lpTemplateName,  // dialog box template
            HWND hWndParent,         // handle to owner window
            DLGPROC lpDialogFunc,    // dialog box procedure
            LPARAM dwInitParam       // initialization value
            );

INT_PTR spFusionDialogBoxIndirectParam(
            HINSTANCE hInstance,             // handle to module
            LPCDLGTEMPLATE hDialogTemplate,  // dialog box template
            HWND hWndParent,                 // handle to owner window
            DLGPROC lpDialogFunc,            // dialog box procedure
            LPARAM dwInitParam               // initialization value
            );

int spFusionMessageBox(
            IN HWND hWnd,
            IN LPCTSTR lpText,
            IN LPCTSTR lpCaption,
            IN UINT uType
            );

int spNonFusionMessageBox(
            IN HWND hWnd,
            IN LPCTSTR lpText,
            IN LPCTSTR lpCaption,
            IN UINT uType
            );

INT_PTR spFusionPropertySheet(
            LPCPROPSHEETHEADER pPropSheetHeader
            );

HPROPSHEETPAGE spFusionCreatePropertySheetPage(
            LPPROPSHEETPAGE pPropSheetPage
            );

BOOL spFusionDestroyPropertySheetPage(
            HPROPSHEETPAGE hPropSheetPage
            );

//
// from commctrl.h
//
HIMAGELIST spFusionImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
BOOL       spFusionImageList_Destroy(HIMAGELIST himl);
int        spFusionImageList_GetImageCount(HIMAGELIST himl);
BOOL       spFusionImageList_SetImageCount(HIMAGELIST himl, UINT uNewCount);
int        spFusionImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
int        spFusionImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
COLORREF   spFusionImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
COLORREF   spFusionImageList_GetBkColor(HIMAGELIST himl);
BOOL       spFusionImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);

//
// from commdlg.h
//
BOOL spFusionGetOpenFileName(LPOPENFILENAME lpofn);


//
// private stuff
//

typedef struct _SPFUSIONINSTANCE {
    BOOL      Acquired;
    ULONG_PTR Cookie;
} SPFUSIONINSTANCE, *PSPFUSIONINSTANCE;

HANDLE
spFusionContextFromModule(
    IN PCTSTR ModuleName
    );

BOOL
spFusionKillContext(
    IN HANDLE hContext
    );

BOOL
spFusionEnterContext(
    IN  HANDLE hContext,
    OUT PSPFUSIONINSTANCE pInst
    );

BOOL
spFusionLeaveContext(
    IN PSPFUSIONINSTANCE pInst
    );

#else

//
// dummy structure/API's that do nothing
//

typedef struct _SPFUSIONINSTANCE {
    BOOL      Acquired;
} SPFUSIONINSTANCE, *PSPFUSIONINSTANCE;

__inline
HANDLE
spFusionContextFromModule(
    IN PCTSTR ModuleName
    )
{
    ModuleName = ModuleName;
    return NULL;
}

__inline
BOOL
spFusionKillContext(
    IN HANDLE hContext
    )
{
    hContext = hContext;
    return TRUE;
}

__inline
BOOL
spFusionEnterContext(
    IN  HANDLE hContext,
    OUT PSPFUSIONINSTANCE pInst
    )
{
    hContext = hContext;
    pInst->Acquired = TRUE;
    return TRUE;
}

__inline
BOOL
spFusionLeaveContext(
    IN PSPFUSIONINSTANCE pInst
    )
{
    pInst->Acquired = FALSE;
    return TRUE;
}

#endif // FUSIONAWARE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\common.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    common.h

Abstract:

    Private header file for sputils

Author:

    Jamie Hunter (JamieHun) Jun-27-2000

Revision History:

--*/

//
// internally we may use some definitions from these files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <stddef.h>
#include <regstr.h>
#include <tchar.h>
#include <setupapi.h>
#include <spapip.h>
#include "strtab.h"
#include "locking.h"


//
// if a function is private to this library, we don't want to collide with functions
// in other libraries etc
// since C doesn't have namespaces, either make "static" or prefix _pSpUtils
//

#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if DBG
#ifndef MEM_DBG
#define MEM_DBG 1
#endif
#else
#ifndef MEM_DBG
#define MEM_DBG 0
#endif
#endif

VOID
_pSpUtilsAssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#if ASSERTS_ON

#define MYASSERT(x)     if(!(x)) { _pSpUtilsAssertFail(__FILE__,__LINE__,#x); }
#define MYVERIFY(x)     ((x)? TRUE : _pSpUtilsAssertFail(__FILE__,__LINE__,#x), FALSE)

#else

#define MYASSERT(x)
#define MYVERIFY(x)     ((x)? TRUE : FALSE)

#endif

#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))
#define SIZECHARS(x)    ARRAYSIZE(x)
#define CSTRLEN(x)      (SIZECHARS(x)-1)


BOOL
_pSpUtilsMemoryInitialize(
    VOID
    );

BOOL
_pSpUtilsMemoryUninitialize(
    VOID
    );

VOID
_pSpUtilsDebugPrintEx(
    DWORD Level,
    PCTSTR format,
    ...                                 OPTIONAL
    );

//
// internally turn on the extra memory debug code if requested
//
#if MEM_DBG
#undef pSetupCheckedMalloc
#undef pSetupCheckInternalHeap
#undef pSetupMallocWithTag
#define pSetupCheckedMalloc(Size) pSetupDebugMalloc(Size,__FILE__,__LINE__)
#define pSetupCheckInternalHeap() pSetupHeapCheck()
#define pSetupMallocWithTag(Size,Tag) pSetupDebugMallocWithTag(Size,__FILE__,__LINE__,Tag)
#endif

//
// internal tags
//
#ifdef UNICODE
#define MEMTAG_STATICSTRINGTABLE  (0x5353484a) // JHSS
#define MEMTAG_STRINGTABLE        (0x5453484a) // JHST
#define MEMTAG_STRINGDATA         (0x4453484a) // JHSD
#else
#define MEMTAG_STATICSTRINGTABLE  (0x7373686a) // jhss
#define MEMTAG_STRINGTABLE        (0x7473686a) // jhst
#define MEMTAG_STRINGDATA         (0x6473686a) // jhsd
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\stub.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    stub.c

Abstract:

    Dynamic loading of routines that are implemented differently on Win9x and NT.

Author:

    Jim Schmidt (jimschm) 29-Apr-1997

Revision History:

    jimschm 26-Oct-1998     Added cfgmgr32, crypt32, mscat and wintrust APIs
    lonnym  01-Apr-2000     Added VerifyVersionInfo and VerSetConditionMask

--*/

#include "precomp.h"


//
// Stub & emulation prototypes -- implemented below
//

GETFILEATTRIBUTESEXA_PROTOTYPE EmulatedGetFileAttributesExA;

//
// Function ptr declarations.  When adding, prefix the function ptr with
// Dyn_ to indicate a dynamically loaded version of an API.
//

GETFILEATTRIBUTESEXA_PROC Dyn_GetFileAttributesExA;
GETSYSTEMWINDOWSDIRECTORYA_PROC Dyn_GetSystemWindowsDirectoryA;
VERIFYVERSIONINFOA_PROC Dyn_VerifyVersionInfoA;
VERSETCONDITIONMASK_PROC Dyn_VerSetConditionMask;
//
// these functions are a little more involved, since we don't want to
// pull in SFC until we have to (delay-load)
//
SFCONNECTTOSERVER_PROC     Dyn_SfcConnectToServer = FirstLoad_SfcConnectToServer;
SFCCLOSE_PROC              Dyn_SfcClose           = FirstLoad_SfcClose;
SFCFILEEXCEPTION_PROC      Dyn_SfcFileException   = FirstLoad_SfcFileException;
SFCISFILEPROTECTED_PROC    Dyn_SfcIsFileProtected = FirstLoad_SfcIsFileProtected;

#ifdef ANSI_SETUPAPI

CM_QUERY_RESOURCE_CONFLICT_LIST Dyn_CM_Query_Resource_Conflict_List;
CM_FREE_RESOURCE_CONFLICT_HANDLE Dyn_CM_Free_Resource_Conflict_Handle;
CM_GET_RESOURCE_CONFLICT_COUNT Dyn_CM_Get_Resource_Conflict_Count;
CM_GET_RESOURCE_CONFLICT_DETAILSA Dyn_CM_Get_Resource_Conflict_DetailsA;
CM_GET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Get_Class_Registry_PropertyA;
CM_SET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Set_Class_Registry_PropertyA;
CM_GET_DEVICE_INTERFACE_ALIAS_EXA Dyn_CM_Get_Device_Interface_Alias_ExA;
CM_GET_DEVICE_INTERFACE_LIST_EXA Dyn_CM_Get_Device_Interface_List_ExA;
CM_GET_DEVICE_INTERFACE_LIST_SIZE_EXA Dyn_CM_Get_Device_Interface_List_Size_ExA;
CM_GET_LOG_CONF_PRIORITY_EX Dyn_CM_Get_Log_Conf_Priority_Ex;
CM_QUERY_AND_REMOVE_SUBTREE_EXA Dyn_CM_Query_And_Remove_SubTree_ExA;
CM_REGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Register_Device_Interface_ExA;
CM_SET_DEVNODE_PROBLEM_EX Dyn_CM_Set_DevNode_Problem_Ex;
CM_UNREGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Unregister_Device_Interface_ExA;

CRYPTCATADMINACQUIRECONTEXT Dyn_CryptCATAdminAcquireContext;
CRYPTCATADMINRELEASECONTEXT Dyn_CryptCATAdminReleaseContext;
CRYPTCATADMINRELEASECATALOGCONTEXT Dyn_CryptCATAdminReleaseCatalogContext;
CRYPTCATADMINADDCATALOG Dyn_CryptCATAdminAddCatalog;
CRYPTCATCATALOGINFOFROMCONTEXT Dyn_CryptCATCatalogInfoFromContext;
CRYPTCATADMINCALCHASHFROMFILEHANDLE Dyn_CryptCATAdminCalcHashFromFileHandle;
CRYPTCATADMINENUMCATALOGFROMHASH Dyn_CryptCATAdminEnumCatalogFromHash;
CRYPTCATADMINREMOVECATALOG Dyn_CryptCATAdminRemoveCatalog;
CRYPTCATADMINRESOLVECATALOGPATH Dyn_CryptCATAdminResolveCatalogPath;

CERTFREECERTIFICATECONTEXT CertFreeCertificateContext;

WINVERIFYTRUST WinVerifyTrust;

#endif


VOID
InitializeStubFnPtrs (
    VOID
    )

/*++

Routine Description:

    This routine tries to load the function ptr of OS-provided APIs, and if
    they aren't available, stub versions are used instead.  We do this
    for APIs that are unimplemented on a platform that setupapi will
    run on.

Arguments:

    none

Return Value:

    none

--*/

{
    //
    // no dynamic loading should be done here for WinXP etc
    // it's only done for ANSI version of setupapi.dll
    // who's sole purpose is for setup of WinXP
    // from Win9x (ie, used in context of winnt32.exe)
    //

#ifdef ANSI_SETUPAPI

    //
    // Kernel32 API's - try loading from the OS dll, and if the API
    // doesn't exist, use an emulation version
    //

    (FARPROC) Dyn_GetFileAttributesExA = ObtainFnPtr (
                                                "kernel32.dll",
                                                "GetFileAttributesExA",
                                                (FARPROC) EmulatedGetFileAttributesExA
                                                );

    (FARPROC) Dyn_GetSystemWindowsDirectoryA = ObtainFnPtr (
                                                "kernel32.dll",
                                                "GetSystemWindowsDirectoryA",
                                                (FARPROC) GetWindowsDirectoryA
                                                );

    //
    // use Win9x config manager APIs if they exist, otherwise return ERROR_CALL_NOT_IMPLEMENTED
    //
    (FARPROC) Dyn_CM_Get_Class_Registry_PropertyA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Class_Registry_PropertyA",
                                                        (FARPROC) Stub_CM_Get_Class_Registry_PropertyA
                                                        );

    (FARPROC) Dyn_CM_Set_Class_Registry_PropertyA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Set_Class_Registry_PropertyA",
                                                        (FARPROC) Stub_CM_Set_Class_Registry_PropertyA
                                                        );

    (FARPROC) Dyn_CM_Get_Device_Interface_Alias_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Device_Interface_Alias_ExA",
                                                        (FARPROC) Stub_CM_Get_Device_Interface_Alias_ExA
                                                        );

    (FARPROC) Dyn_CM_Get_Device_Interface_List_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Device_Interface_List_ExA",
                                                        (FARPROC) Stub_CM_Get_Device_Interface_List_ExA
                                                        );

    (FARPROC) Dyn_CM_Get_Device_Interface_List_Size_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Device_Interface_List_Size_ExA",
                                                        (FARPROC) Stub_CM_Get_Device_Interface_List_Size_ExA
                                                        );

    (FARPROC) Dyn_CM_Get_Log_Conf_Priority_Ex = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Log_Conf_Priority_Ex",
                                                        (FARPROC) Stub_CM_Get_Log_Conf_Priority_Ex
                                                        );

    (FARPROC) Dyn_CM_Query_And_Remove_SubTree_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Query_And_Remove_SubTree_ExA",
                                                        (FARPROC) Stub_CM_Query_And_Remove_SubTree_ExA
                                                        );

    (FARPROC) Dyn_CM_Register_Device_Interface_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Register_Device_Interface_ExA",
                                                        (FARPROC) Stub_CM_Register_Device_Interface_ExA
                                                        );

    (FARPROC) Dyn_CM_Set_DevNode_Problem_Ex = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Set_DevNode_Problem_Ex",
                                                        (FARPROC) Stub_CM_Set_DevNode_Problem_Ex
                                                        );

    (FARPROC) Dyn_CM_Unregister_Device_Interface_ExA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Unregister_Device_Interface_ExA",
                                                        (FARPROC) Stub_CM_Unregister_Device_Interface_ExA
                                                        );

    (FARPROC)Dyn_CM_Query_Resource_Conflict_List = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Query_Resource_Conflict_List",
                                                        (FARPROC) Stub_CM_Query_Resource_Conflict_List
                                                        );

    (FARPROC)Dyn_CM_Free_Resource_Conflict_Handle = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Free_Resource_Conflict_Handle",
                                                        (FARPROC) Stub_CM_Free_Resource_Conflict_Handle
                                                        );

    (FARPROC)Dyn_CM_Get_Resource_Conflict_Count = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Resource_Conflict_Count",
                                                        (FARPROC) Stub_CM_Get_Resource_Conflict_Count
                                                        );

    (FARPROC)Dyn_CM_Get_Resource_Conflict_DetailsA = ObtainFnPtr (
                                                        "cfgmgr32.dll",
                                                        "CM_Get_Resource_Conflict_DetailsA",
                                                        (FARPROC) Stub_CM_Get_Resource_Conflict_DetailsA
                                                        );

    //
    // use Win9x crypto APIs if they exist, otherwise fail with ERROR_CALL_NOT_IMPLEMENTED
    //

    (FARPROC) Dyn_CryptCATAdminAcquireContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminAcquireContext",
                                                        (FARPROC) Stub_CryptCATAdminAcquireContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminReleaseContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminReleaseContext",
                                                        (FARPROC) Stub_CryptCATAdminReleaseContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminReleaseCatalogContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminReleaseCatalogContext",
                                                        (FARPROC) Stub_CryptCATAdminReleaseCatalogContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminAddCatalog = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminAddCatalog",
                                                        (FARPROC) Stub_CryptCATAdminAddCatalog
                                                        );

    (FARPROC) Dyn_CryptCATCatalogInfoFromContext = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATCatalogInfoFromContext",
                                                        (FARPROC) Stub_CryptCATCatalogInfoFromContext
                                                        );

    (FARPROC) Dyn_CryptCATAdminCalcHashFromFileHandle = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminCalcHashFromFileHandle",
                                                        (FARPROC) Stub_CryptCATAdminCalcHashFromFileHandle
                                                        );

    (FARPROC) Dyn_CryptCATAdminEnumCatalogFromHash = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminEnumCatalogFromHash",
                                                        (FARPROC) Stub_CryptCATAdminEnumCatalogFromHash
                                                        );

    (FARPROC) Dyn_CryptCATAdminRemoveCatalog = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminRemoveCatalog",
                                                        (FARPROC) Stub_CryptCATAdminRemoveCatalog
                                                        );

    (FARPROC) Dyn_CryptCATAdminResolveCatalogPath = ObtainFnPtr (
                                                        "wintrust.dll",
                                                        "CryptCATAdminResolveCatalogPath",
                                                        (FARPROC) Stub_CryptCATAdminResolveCatalogPath
                                                        );

    (FARPROC) Dyn_CertFreeCertificateContext = ObtainFnPtr (
                                                        "crypt32.dll",
                                                        "CertFreeCertificateContext",
                                                        (FARPROC) Stub_CertFreeCertificateContext
                                                        );

    //
    // use Win9x WinVerifyTrust if it exists, otherwise return ERROR_SUCCESS
    //

    (FARPROC) Dyn_WinVerifyTrust = ObtainFnPtr (
                                        "wintrust.dll",
                                        "WinVerifyTrust",
                                        (FARPROC) Stub_WinVerifyTrust
                                        );


    //
    // Use VerifyVersionInfo and VerSetConditionMask APIs,
    // if available, otherwise fail with ERROR_CALL_NOT_IMPLEMENTED.
    //
    (FARPROC) Dyn_VerifyVersionInfoA = ObtainFnPtr(
                                           "kernel32.dll",
                                           "VerifyVersionInfoA",
                                           (FARPROC) Stub_VerifyVersionInfoA
                                          );

    (FARPROC) Dyn_VerSetConditionMask = ObtainFnPtr(
                                           "ntdll.dll",
                                           "VerSetConditionMask",
                                           (FARPROC) Stub_VerSetConditionMask
                                          );

    //
    // ***Add other dynamic loading here***
    //
#endif

}


BOOL
EmulatedGetFileAttributesExA (
    IN      PCSTR FileName,
    IN      GET_FILEEX_INFO_LEVELS InfoLevelId,
    OUT     LPVOID FileInformation
    )

/*++

Routine Description:

    Implements an emulation of the NT-specific function GetFileAttributesEx.
    Basic exception handling is implemented, but parameters are not otherwise
    validated.

Arguments:

    FileName - Specifies file to get attributes for

    InfoLevelId - Must be GetFileExInfoStandard

    FileInformation - Must be a valid pointer to WIN32_FILE_ATTRIBUTE_DATA struct

Return Value:

    TRUE for success, FALSE for failure.  GetLastError provided error code.

--*/


{
    //
    // GetFileAttributesEx does not exist on Win95, and ANSI version of setupapi.dll
    // is required for Win9x to NT 5 upgrade
    //

    HANDLE FileEnum;
    WIN32_FIND_DATAA fd;
    PCSTR p,pChar;
    TCHAR  CurChar;
    WIN32_FILE_ATTRIBUTE_DATA *FileAttribData = (WIN32_FILE_ATTRIBUTE_DATA *) FileInformation;

    __try {
        //
        // We only support GetFileExInfoStandard
        //

        if (InfoLevelId != GetFileExInfoStandard) {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        //
        // Locate file title
        // note that this is an ANSI implementation of pSetupGetFileTitle
        //

        p = pChar = FileName;
        while(CurChar = *pChar) {
            pChar = CharNextA(pChar);
            if((CurChar == '\\') || (CurChar == '/') || (CurChar == ':')) {
                p = pChar;
            }
        }

        ZeroMemory (FileAttribData, sizeof (WIN32_FILE_ATTRIBUTE_DATA));

        FileEnum = FindFirstFileA (FileName, &fd);

        //
        // Prohibit caller-supplied pattern
        //

        if (FileEnum!=INVALID_HANDLE_VALUE && lstrcmpiA (p, fd.cFileName)) {
            FindClose (FileEnum);
            FileEnum = INVALID_HANDLE_VALUE;
            SetLastError (ERROR_INVALID_PARAMETER);
        }

        //
        // If exact match found, fill in the attributes
        //

        if (FileEnum) {
            FileAttribData->dwFileAttributes = fd.dwFileAttributes;
            FileAttribData->nFileSizeHigh = fd.nFileSizeHigh;
            FileAttribData->nFileSizeLow  = fd.nFileSizeLow;

            CopyMemory (&FileAttribData->ftCreationTime, &fd.ftCreationTime, sizeof (FILETIME));
            CopyMemory (&FileAttribData->ftLastAccessTime, &fd.ftLastAccessTime, sizeof (FILETIME));
            CopyMemory (&FileAttribData->ftLastWriteTime, &fd.ftLastWriteTime, sizeof (FILETIME));

            FindClose (FileEnum);
        }

        return FileEnum != INVALID_HANDLE_VALUE;
    }

    __except (TRUE) {
        //
        // If bogus FileInformation pointer is passed, an exception is thrown.
        //

        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}


//
// DLL array structures
//

#define MAX_DLL_ARRAY   16

typedef struct {
    PCSTR DllName;
    HINSTANCE DllInst;
} DLLTABLE, *PDLLTABLE;

static INT g_ArraySize = 0;
static DLLTABLE g_DllArray[MAX_DLL_ARRAY];


//
// Attempt to get library out of System32 directory first
//

HMODULE DelayLoadLibrary(
    IN LPCSTR LibName
    )
/*++

    internal

Routine Description:

    Given an ANSI library name, prepend system32 directory and load it
    (ie, enforce our own search path)
    Don't assume anything is initialized

Arguments:

    LibName - name passed to us by pDelayLoadHook

Result:

    HMODULE from LoadLibrary, or NULL for default processing

--*/
{
    CHAR path[MAX_PATH];
    UINT swdLen;
    UINT libLen;
    HMODULE result;

    libLen = strlen(LibName);
    if(strrchr(LibName,'\\') || strrchr(LibName,'/')) {
        MYASSERT(FALSE);
        return NULL;
    }
    swdLen = GetSystemDirectoryA(path,MAX_PATH);
    if((swdLen == 0) || ((swdLen+libLen+1)>=MAX_PATH)) {
        return NULL;
    }
    if(*CharPrevA(path,path+swdLen)!=TEXT('\\')) {
        path[swdLen++] = TEXT('\\');
    }
    strcpy(path+swdLen,LibName);
    result = LoadLibraryA(path);
    if(result) {
        MYTRACE((DPFLTR_TRACE_LEVEL, TEXT("SetupAPI: delay-loaded %hs.\n"), path));
    } else {
        MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("SetupAPI: Could not delay-load %hs.\n"), path));
    }
    return result;
}


FARPROC
ObtainFnPtr (
    IN      PCSTR DllName,
    IN      PCSTR ProcName,
    IN      FARPROC Default
    )

/*++

Routine Description:

    This routine manages an array of DLL instance handles and returns the
    proc address of the caller-specified routine.  The DLL is loaded
    and remains loaded until the DLL terminates.  This array is not
    synchronized.

Arguments:

    DllName - The ANSI DLL name to load

    ProcName - The ANSI procedure name to locate

    Default - The default procedure, if the export was not found

Return Value:

    The address of the requested function, or NULL if the DLL could not
    be loaded, or the function is not implemented in the loaded DLL.

--*/

{
    INT i;
    PSTR DupBuf;
    FARPROC Address = NULL;

    //
    // Search for loaded DLL
    //

    for (i = 0 ; i < g_ArraySize ; i++) {
        if (!lstrcmpiA (DllName, g_DllArray[i].DllName)) {
            break;
        }
    }

    do {
        //
        // If necessary, load the DLL
        //

        if (i == g_ArraySize) {
            if (g_ArraySize == MAX_DLL_ARRAY) {
                // Constant limit needs to be raised
                MYASSERT (FALSE);
                break;
            }

            g_DllArray[i].DllInst = DelayLoadLibrary (DllName);
            if (!g_DllArray[i].DllInst) {
                break;
            }

            DupBuf = (PSTR) MyMalloc (lstrlenA (DllName) + 1);
            if (!DupBuf) {
                break;
            }
            lstrcpyA (DupBuf, DllName);
            g_DllArray[i].DllName = DupBuf;

            g_ArraySize++;
        }

        //
        // Now that DLL is loaded, return the proc address if it exists
        //

        Address = GetProcAddress (g_DllArray[i].DllInst, ProcName);

    } while (FALSE);

    if (!Address) {
        return Default;
    }

    return Address;
}


VOID
pCleanUpDllArray (
    VOID
    )

/*++

Routine Description:

    Cleans up the DLL array resources.

Arguments:

    none

Return Value:

    none

--*/

{
    INT i;

    for (i = 0 ; i < g_ArraySize ; i++) {
        FreeLibrary (g_DllArray[i].DllInst);
        MyFree (g_DllArray[i].DllName);
    }

    g_ArraySize = 0;
}


VOID
CleanUpStubFns (
    VOID
    )

/*++

Routine Description:

    Cleans up all resources used by emulation routines and function pointer list.

Arguments:

    none

Return Value:

    none

--*/

{
    pCleanUpDllArray();
}


BOOL
WINAPI
Stub_VerifyVersionInfoA(
    IN LPOSVERSIONINFOEXA lpVersionInformation,
    IN DWORD dwTypeMask,
    IN DWORDLONG dwlConditionMask
    )
{
    UNREFERENCED_PARAMETER(lpVersionInformation);
    UNREFERENCED_PARAMETER(dwTypeMask);
    UNREFERENCED_PARAMETER(dwlConditionMask);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

ULONGLONG
NTAPI
Stub_VerSetConditionMask(
    IN ULONGLONG ConditionMask,
    IN DWORD TypeMask,
    IN BYTE Condition
    )
{
    UNREFERENCED_PARAMETER(TypeMask);
    UNREFERENCED_PARAMETER(Condition);

    //
    // Simply return ConditionMask unaltered.  (If this API doesn't exist, we
    // don't expect VerifyVersionInfo to exist either, so that should fail.)
    //
    return ConditionMask;
}

HANDLE
WINAPI
Stub_SfcConnectToServer(
    IN LPCWSTR ServerName
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}

VOID
Stub_SfcClose(
    IN HANDLE RpcHandle
    )
{
    return;
}

DWORD
WINAPI
Stub_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

BOOL
WINAPI
Stub_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


HANDLE
WINAPI
FirstLoad_SfcConnectToServer(
    IN LPCWSTR ServerName
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcConnectToServer == FirstLoad_SfcConnectToServer) {
            (FARPROC) Dyn_SfcConnectToServer         = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        (LPCSTR)3,
                                                        (FARPROC) Stub_SfcConnectToServer
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ok) {
        return Dyn_SfcConnectToServer(ServerName);
    } else {
        return Stub_SfcConnectToServer(ServerName);
    }
}

VOID
FirstLoad_SfcClose(
    IN HANDLE RpcHandle
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcClose == FirstLoad_SfcClose) {
            (FARPROC) Dyn_SfcClose                   = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        (LPCSTR)4,
                                                        (FARPROC) Stub_SfcClose
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(ok) {
        Dyn_SfcClose(RpcHandle);
    }
    return;
}

DWORD
WINAPI
FirstLoad_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcFileException == FirstLoad_SfcFileException) {
            (FARPROC) Dyn_SfcFileException           = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        (LPCSTR)5,
                                                        (FARPROC) Stub_SfcFileException
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(ok) {
        return Dyn_SfcFileException(RpcHandle,FileName,ExpectedChangeType);
    } else {
        return Stub_SfcFileException(RpcHandle,FileName,ExpectedChangeType);
    }
}

BOOL
WINAPI
FirstLoad_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    )
{
    BOOL ok = FALSE;
    try {
        EnterCriticalSection(&InitMutex);
        if(Dyn_SfcIsFileProtected == FirstLoad_SfcIsFileProtected) {
            (FARPROC) Dyn_SfcIsFileProtected         = ObtainFnPtr (
                                                        "sfc_os.dll",
                                                        "SfcIsFileProtected",
                                                        (FARPROC) Stub_SfcIsFileProtected
                                                        );
        }
        LeaveCriticalSection(&InitMutex);
        ok = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if(ok) {
        return Dyn_SfcIsFileProtected(RpcHandle,ProtFileName);
    } else {
        return Stub_SfcIsFileProtected(RpcHandle,ProtFileName);
    }
}

#ifdef ANSI_SETUPAPI

CONFIGRET
WINAPI
Stub_CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Set_Class_Registry_PropertyA(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_Alias_ExA(
    IN     PCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    PSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_ExA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_Size_ExA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Get_Log_Conf_Priority_Ex(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Query_And_Remove_SubTree_ExA(
    IN  DEVINST        dnAncestor,
    OUT PPNP_VETO_TYPE pVetoType,
    OUT PSTR          pszVetoName,
    IN  ULONG          ulNameLength,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Register_Device_Interface_ExA(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  PCSTR    pszReference,         OPTIONAL
    OUT PSTR     pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


CONFIGRET
WINAPI
Stub_CM_Unregister_Device_Interface_ExA(
    IN PCSTR   pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    )
{
    return CR_CALL_NOT_IMPLEMENTED;
}


BOOL
WINAPI
Stub_CryptCATAdminAcquireContext (
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminReleaseContext (
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminReleaseCatalogContext (
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


HCATINFO
WINAPI
Stub_CryptCATAdminAddCatalog (
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}


BOOL
WINAPI
Stub_CryptCATCatalogInfoFromContext (
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminCalcHashFromFileHandle (
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


HCATINFO
WINAPI
Stub_CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return NULL;
}


BOOL
WINAPI
Stub_CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


BOOL
WINAPI
Stub_CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


LONG
WINAPI
Stub_WinVerifyTrust(
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    )
{
    return ERROR_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\stub.h ===
//
// Prototype and function pointer types
//

typedef BOOL (GETFILEATTRIBUTESEXA_PROTOTYPE)(LPCSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
typedef GETFILEATTRIBUTESEXA_PROTOTYPE * GETFILEATTRIBUTESEXA_PROC;

typedef UINT (GETSYSTEMWINDOWSDIRECTORYA_PROTOTYPE)(LPSTR, UINT);
typedef GETSYSTEMWINDOWSDIRECTORYA_PROTOTYPE * GETSYSTEMWINDOWSDIRECTORYA_PROC;

typedef BOOL (VERIFYVERSIONINFOA_PROTOTYPE)(LPOSVERSIONINFOEXA, DWORD, DWORDLONG);
typedef VERIFYVERSIONINFOA_PROTOTYPE * VERIFYVERSIONINFOA_PROC;

typedef ULONGLONG (VERSETCONDITIONMASK_PROTOTYPE)(ULONGLONG, DWORD, BYTE);
typedef VERSETCONDITIONMASK_PROTOTYPE * VERSETCONDITIONMASK_PROC;

typedef HANDLE (WINAPI SFCONNECTTOSERVER_PROTOTYPE)(LPCWSTR ServerName);
typedef VOID (SFCCLOSE_PROTOTYPE)(IN HANDLE RpcHandle);
typedef DWORD (WINAPI SFCFILEEXCEPTION_PROTOTYPE)(HANDLE RpcHandle,PCWSTR FileName,DWORD ExpectedChangeType);
typedef BOOL (WINAPI SFCISFILEPROTECTED_PROTOTYPE)(HANDLE RpcHandle,LPCWSTR ProtFileName);
typedef SFCONNECTTOSERVER_PROTOTYPE * SFCONNECTTOSERVER_PROC;
typedef SFCCLOSE_PROTOTYPE * SFCCLOSE_PROC;
typedef SFCFILEEXCEPTION_PROTOTYPE * SFCFILEEXCEPTION_PROC;
typedef SFCISFILEPROTECTED_PROTOTYPE * SFCISFILEPROTECTED_PROC;

#ifdef ANSI_SETUPAPI

typedef CONFIGRET (WINAPI *CM_GET_CLASS_REGISTRY_PROPERTYA)(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

typedef CONFIGRET (WINAPI *CM_SET_CLASS_REGISTRY_PROPERTYA)(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

typedef CONFIGRET (WINAPI *CM_GET_DEVICE_INTERFACE_ALIAS_EXA)(
            IN     LPCSTR   pszDeviceInterface,
            IN     LPGUID   AliasInterfaceGuid,
            OUT    LPSTR    pszAliasDeviceInterface,
            IN OUT PULONG   pulLength,
            IN     ULONG    ulFlags,
            IN     HMACHINE hMachine
            );

typedef CONFIGRET (WINAPI *CM_GET_DEVICE_INTERFACE_LIST_EXA)(
            IN  LPGUID      InterfaceClassGuid,
            IN  DEVINSTID_A pDeviceID,      OPTIONAL
            OUT PCHAR       Buffer,
            IN  ULONG       BufferLen,
            IN  ULONG       ulFlags,
            IN  HMACHINE    hMachine
            );

typedef CONFIGRET (WINAPI *CM_GET_DEVICE_INTERFACE_LIST_SIZE_EXA)(
            IN  PULONG      pulLen,
            IN  LPGUID      InterfaceClassGuid,
            IN  DEVINSTID_A pDeviceID,      OPTIONAL
            IN  ULONG       ulFlags,
            IN  HMACHINE    hMachine
            );

typedef CONFIGRET (WINAPI *CM_GET_LOG_CONF_PRIORITY_EX)(
            IN  LOG_CONF  lcLogConf,
            OUT PPRIORITY pPriority,
            IN  ULONG     ulFlags,
            IN  HMACHINE  hMachine
            );

typedef CONFIGRET (WINAPI *CM_QUERY_AND_REMOVE_SUBTREE_EXA)(
            IN  DEVINST        dnAncestor,
            OUT PPNP_VETO_TYPE pVetoType,
            OUT LPSTR          pszVetoName,
            IN  ULONG          ulNameLength,
            IN  ULONG          ulFlags,
            IN  HMACHINE       hMachine
            );

typedef CONFIGRET (WINAPI *CM_REGISTER_DEVICE_INTERFACE_EXA)(
            IN  DEVINST   dnDevInst,
            IN  LPGUID    InterfaceClassGuid,
            IN  LPCSTR    pszReference,         OPTIONAL
            OUT LPSTR     pszDeviceInterface,
            IN OUT PULONG pulLength,
            IN  ULONG     ulFlags,
            IN  HMACHINE  hMachine
            );

typedef CONFIGRET (WINAPI *CM_SET_DEVNODE_PROBLEM_EX)(
            IN DEVINST   dnDevInst,
            IN ULONG     ulProblem,
            IN  ULONG    ulFlags,
            IN  HMACHINE hMachine
            );

typedef CONFIGRET (WINAPI *CM_UNREGISTER_DEVICE_INTERFACE_EXA)(
            IN LPCSTR   pszDeviceInterface,
            IN ULONG    ulFlags,
            IN HMACHINE hMachine
            );

typedef BOOL (WINAPI *CRYPTCATADMINACQUIRECONTEXT)(
            OUT HCATADMIN *phCatAdmin,
            IN const GUID *pgSubsystem,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINRELEASECONTEXT)(
            IN HCATADMIN hCatAdmin,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINRELEASECATALOGCONTEXT)(
            IN HCATADMIN hCatAdmin,
            IN HCATINFO hCatInfo,
            IN DWORD dwFlags
            );

typedef HCATINFO (WINAPI *CRYPTCATADMINADDCATALOG)(
            IN HCATADMIN hCatAdmin,
            IN WCHAR *pwszCatalogFile,
            IN OPTIONAL WCHAR *pwszSelectBaseName,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATCATALOGINFOFROMCONTEXT)(
            IN HCATINFO hCatInfo,
            IN OUT CATALOG_INFO *psCatInfo,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINCALCHASHFROMFILEHANDLE)(
            IN HANDLE hFile,
            IN OUT DWORD *pcbHash,
            OUT OPTIONAL BYTE *pbHash,
            IN DWORD dwFlags
            );

typedef HCATINFO (WINAPI *CRYPTCATADMINENUMCATALOGFROMHASH)(
            IN HCATADMIN hCatAdmin,
            IN BYTE *pbHash,
            IN DWORD cbHash,
            IN DWORD dwFlags,
            IN OUT HCATINFO *phPrevCatInfo
            );

typedef BOOL (WINAPI *CRYPTCATADMINREMOVECATALOG)(
            IN HCATADMIN hCatAdmin,
            IN WCHAR *pwszCatalogFile,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CRYPTCATADMINRESOLVECATALOGPATH)(
            IN HCATADMIN hCatAdmin,
            IN WCHAR *pwszCatalogFile,
            IN OUT CATALOG_INFO *psCatInfo,
            IN DWORD dwFlags
            );

typedef BOOL (WINAPI *CERTFREECERTIFICATECONTEXT)(
            IN PCCERT_CONTEXT pCertContext
            );

typedef LONG (WINAPI *WINVERIFYTRUST)(
            HWND hwnd,
            GUID *pgActionID,
            LPVOID pWVTData
            );

typedef CONFIGRET (WINAPI *CM_QUERY_RESOURCE_CONFLICT_LIST)(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

typedef CONFIGRET (WINAPI *CM_FREE_RESOURCE_CONFLICT_HANDLE)(
             IN CONFLICT_LIST   clConflictList
             );

typedef CONFIGRET (WINAPI *CM_GET_RESOURCE_CONFLICT_COUNT)(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             );

typedef CONFIGRET (WINAPI *CM_GET_RESOURCE_CONFLICT_DETAILSA)(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             );

#endif

//
// Pointers declared in stub.c and initialized in InitializeStubFnPtrs
//

extern GETFILEATTRIBUTESEXA_PROC  Dyn_GetFileAttributesExA;
extern GETSYSTEMWINDOWSDIRECTORYA_PROC Dyn_GetSystemWindowsDirectoryA;
extern VERIFYVERSIONINFOA_PROC    Dyn_VerifyVersionInfoA;
extern VERSETCONDITIONMASK_PROC   Dyn_VerSetConditionMask;
extern SFCONNECTTOSERVER_PROC     Dyn_SfcConnectToServer;
extern SFCCLOSE_PROC              Dyn_SfcClose;
extern SFCFILEEXCEPTION_PROC      Dyn_SfcFileException;
extern SFCISFILEPROTECTED_PROC    Dyn_SfcIsFileProtected;

#ifdef ANSI_SETUPAPI

extern CM_QUERY_RESOURCE_CONFLICT_LIST Dyn_CM_Query_Resource_Conflict_List;
extern CM_FREE_RESOURCE_CONFLICT_HANDLE Dyn_CM_Free_Resource_Conflict_Handle;
extern CM_GET_RESOURCE_CONFLICT_COUNT Dyn_CM_Get_Resource_Conflict_Count;
extern CM_GET_RESOURCE_CONFLICT_DETAILSA Dyn_CM_Get_Resource_Conflict_DetailsA;
extern CM_GET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Get_Class_Registry_PropertyA;
extern CM_SET_CLASS_REGISTRY_PROPERTYA Dyn_CM_Set_Class_Registry_PropertyA;
extern CM_GET_DEVICE_INTERFACE_ALIAS_EXA Dyn_CM_Get_Device_Interface_Alias_ExA;
extern CM_GET_DEVICE_INTERFACE_LIST_EXA Dyn_CM_Get_Device_Interface_List_ExA;
extern CM_GET_DEVICE_INTERFACE_LIST_SIZE_EXA Dyn_CM_Get_Device_Interface_List_Size_ExA;
extern CM_GET_LOG_CONF_PRIORITY_EX Dyn_CM_Get_Log_Conf_Priority_Ex;
extern CM_QUERY_AND_REMOVE_SUBTREE_EXA Dyn_CM_Query_And_Remove_SubTree_ExA;
extern CM_REGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Register_Device_Interface_ExA;
extern CM_SET_DEVNODE_PROBLEM_EX Dyn_CM_Set_DevNode_Problem_Ex;
extern CM_UNREGISTER_DEVICE_INTERFACE_EXA Dyn_CM_Unregister_Device_Interface_ExA;

extern CRYPTCATADMINACQUIRECONTEXT Dyn_CryptCATAdminAcquireContext;
extern CRYPTCATADMINRELEASECONTEXT Dyn_CryptCATAdminReleaseContext;
extern CRYPTCATADMINRELEASECATALOGCONTEXT Dyn_CryptCATAdminReleaseCatalogContext;
extern CRYPTCATADMINADDCATALOG Dyn_CryptCATAdminAddCatalog;
extern CRYPTCATCATALOGINFOFROMCONTEXT Dyn_CryptCATCatalogInfoFromContext;
extern CRYPTCATADMINCALCHASHFROMFILEHANDLE Dyn_CryptCATAdminCalcHashFromFileHandle;
extern CRYPTCATADMINENUMCATALOGFROMHASH Dyn_CryptCATAdminEnumCatalogFromHash;
extern CRYPTCATADMINREMOVECATALOG Dyn_CryptCATAdminRemoveCatalog;
extern CRYPTCATADMINRESOLVECATALOGPATH Dyn_CryptCATAdminResolveCatalogPath;

extern CERTFREECERTIFICATECONTEXT Dyn_CertFreeCertificateContext;

extern WINVERIFYTRUST Dyn_WinVerifyTrust;

#endif

//
// "Not Implemented" Stubs
//

BOOL
WINAPI
Stub_VerifyVersionInfoA(
    IN LPOSVERSIONINFOEXA lpVersionInformation,
    IN DWORD dwTypeMask,
    IN DWORDLONG dwlConditionMask
    );

BOOL
WINAPI
Stub_VerifyVersionInfoW(
    IN LPOSVERSIONINFOEXW lpVersionInformation,
    IN DWORD dwTypeMask,
    IN DWORDLONG dwlConditionMask
    );

ULONGLONG
NTAPI
Stub_VerSetConditionMask(
    IN ULONGLONG ConditionMask,
    IN DWORD TypeMask,
    IN BYTE Condition
    );

HANDLE
WINAPI
Stub_SfcConnectToServer(
    IN LPCWSTR ServerName
    );

VOID
Stub_SfcClose(
    IN HANDLE RpcHandle
    );

DWORD
WINAPI
Stub_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    );

BOOL
WINAPI
Stub_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    );

HANDLE
WINAPI
FirstLoad_SfcConnectToServer(
    IN LPCWSTR ServerName
    );

VOID
FirstLoad_SfcClose(
    IN HANDLE RpcHandle
    );

DWORD
WINAPI
FirstLoad_SfcFileException(
    IN HANDLE RpcHandle,
    IN PCWSTR FileName,
    IN DWORD ExpectedChangeType
    );

BOOL
WINAPI
FirstLoad_SfcIsFileProtected(
    IN HANDLE RpcHandle,
    IN LPCWSTR ProtFileName
    );

#ifdef ANSI_SETUPAPI

CONFIGRET
WINAPI
Stub_CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Set_Class_Registry_PropertyA(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_Alias_ExA (
    IN     LPCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_ExA(
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    OUT PCHAR       Buffer,
    IN  ULONG       BufferLen,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Device_Interface_List_Size_ExA(
    IN  PULONG      pulLen,
    IN  LPGUID      InterfaceClassGuid,
    IN  DEVINSTID_A pDeviceID,      OPTIONAL
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Get_Log_Conf_Priority_Ex(
    IN  LOG_CONF  lcLogConf,
    OUT PPRIORITY pPriority,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Query_And_Remove_SubTree_ExA(
    IN  DEVINST        dnAncestor,
    OUT PPNP_VETO_TYPE pVetoType,
    OUT LPSTR          pszVetoName,
    IN  ULONG          ulNameLength,
    IN  ULONG          ulFlags,
    IN  HMACHINE       hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Register_Device_Interface_ExA(
    IN  DEVINST   dnDevInst,
    IN  LPGUID    InterfaceClassGuid,
    IN  LPCSTR    pszReference,         OPTIONAL
    OUT LPSTR     pszDeviceInterface,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags,
    IN  HMACHINE  hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Unregister_Device_Interface_ExA(
    IN LPCSTR   pszDeviceInterface,
    IN ULONG    ulFlags,
    IN HMACHINE hMachine
    );

CONFIGRET
WINAPI
Stub_CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CONFIGRET
WINAPI
Stub_CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             );

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             );

CONFIGRET
WINAPI
Stub_CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             );


BOOL
WINAPI
Stub_CryptCATAdminAcquireContext (
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminReleaseContext (
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminReleaseCatalogContext (
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    );

HCATINFO
WINAPI
Stub_CryptCATAdminAddCatalog (
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OPTIONAL WCHAR *pwszSelectBaseName,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATCatalogInfoFromContext (
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminCalcHashFromFileHandle (
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    );

HCATINFO
WINAPI
Stub_CryptCATAdminEnumCatalogFromHash(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    );

BOOL
WINAPI
Stub_CryptCATAdminRemoveCatalog(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CryptCATAdminResolveCatalogPath(
    IN HCATADMIN hCatAdmin,
    IN WCHAR *pwszCatalogFile,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    );

BOOL
WINAPI
Stub_CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    );

LONG
WINAPI
Stub_WinVerifyTrust(
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    );

#endif


//
// Macro repairs
//

#define SfcConnectToServer Dyn_SfcConnectToServer
#define SfcClose           Dyn_SfcClose
#define SfcFileException   Dyn_SfcFileException
#define SfcIsFileProtected Dyn_SfcIsFileProtected

#ifdef ANSI_SETUPAPI

#undef VerifyVersionInfo
#undef VerSetConditionMask
#undef GetFileAttributesEx
#undef GetSystemWindowsDirectory
#undef CM_Get_Class_Registry_Property
#undef CM_Set_Class_Registry_Property
#undef CM_Get_Device_Interface_Alias_Ex
#undef CM_Get_Device_Interface_List_Ex
#undef CM_Get_Device_Interface_List_Size_Ex
#undef CM_Query_And_Remove_SubTree_Ex
#undef CM_Register_Device_Interface_Ex
#undef CM_Unregister_Device_Interface_Ex
#undef CM_Get_Resource_Conflict_Details

#define VerifyVersionInfo  Dyn_VerifyVersionInfoA
#define VerSetConditionMask Dyn_VerSetConditionMask
#define CM_Get_Class_Registry_Property Dyn_CM_Get_Class_Registry_PropertyA
#define CM_Set_Class_Registry_Property Dyn_CM_Set_Class_Registry_PropertyA
#define CM_Get_Device_Interface_Alias_Ex Dyn_CM_Get_Device_Interface_Alias_ExA
#define CM_Get_Device_Interface_List_Ex Dyn_CM_Get_Device_Interface_List_ExA
#define CM_Get_Device_Interface_List_Size_Ex Dyn_CM_Get_Device_Interface_List_Size_ExA
#define CM_Get_Log_Conf_Priority_Ex Dyn_CM_Get_Log_Conf_Priority_Ex
#define CM_Query_And_Remove_SubTree_Ex Dyn_CM_Query_And_Remove_SubTree_ExA
#define CM_Register_Device_Interface_Ex Dyn_CM_Register_Device_Interface_ExA
#define CM_Set_DevNode_Problem_Ex Dyn_CM_Set_DevNode_Problem_Ex
#define CM_Unregister_Device_Interface_Ex Dyn_CM_Unregister_Device_Interface_ExA
#define CM_Query_Resource_Conflict_List Dyn_CM_Query_Resource_Conflict_List
#define CM_Free_Resource_Conflict_Handle Dyn_CM_Free_Resource_Conflict_Handle
#define CM_Get_Resource_Conflict_Count Dyn_CM_Get_Resource_Conflict_Count
#define CM_Get_Resource_Conflict_Details Dyn_CM_Get_Resource_Conflict_DetailsA

#define CryptCATAdminAcquireContext Dyn_CryptCATAdminAcquireContext
#define CryptCATAdminReleaseContext Dyn_CryptCATAdminReleaseContext
#define CryptCATAdminReleaseCatalogContext Dyn_CryptCATAdminReleaseCatalogContext
#define CryptCATAdminAddCatalog Dyn_CryptCATAdminAddCatalog
#define CryptCATCatalogInfoFromContext Dyn_CryptCATCatalogInfoFromContext
#define CryptCATAdminCalcHashFromFileHandle Dyn_CryptCATAdminCalcHashFromFileHandle
#define CryptCATAdminEnumCatalogFromHash Dyn_CryptCATAdminEnumCatalogFromHash
#define CryptCATAdminRemoveCatalog Dyn_CryptCATAdminRemoveCatalog
#define CryptCATAdminResolveCatalogPath Dyn_CryptCATAdminResolveCatalogPath
#define CertFreeCertificateContext Dyn_CertFreeCertificateContext

#define WinVerifyTrust Dyn_WinVerifyTrust

#define GetFileAttributesEx Dyn_GetFileAttributesExA
#define GetSystemWindowsDirectory Dyn_GetSystemWindowsDirectoryA

#endif

//
// Functions called from DllMain
//

VOID
InitializeStubFnPtrs (
    VOID
    );

VOID
CleanUpStubFns (
    VOID
    );

FARPROC
ObtainFnPtr (
    PCSTR DllName,
    PCSTR FnName,
    FARPROC Default
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\fileutil.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    fileutil.c

Abstract:

    File-related functions for SPUTILS

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (JamieHun) Jun-27-2000
            Moved various functions out of setupapi


--*/


#include "precomp.h"
#pragma hdrstop

DWORD
pSetupOpenAndMapFileForRead(
    IN  PCTSTR   FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Open and map an existing file for read access.

Arguments:

    FileName - supplies pathname to file to be mapped.

    FileSize - receives the size in bytes of the file.

    FileHandle - receives the win32 file handle for the open file.
        The file will be opened for generic read access.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.

    BaseAddress - receives the address where the file is mapped.

Return Value:

    NO_ERROR if the file was opened and mapped successfully.
        The caller must unmap the file with pSetupUnmapAndCloseFile when
        access to the file is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Open the file -- fail if it does not exist.
    //
    *FileHandle = CreateFile(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

    if(*FileHandle == INVALID_HANDLE_VALUE) {

        rc = GetLastError();

    } else if((rc = pSetupMapFileForRead(*FileHandle,
                                   FileSize,
                                   MappingHandle,
                                   BaseAddress)) != NO_ERROR) {
        CloseHandle(*FileHandle);
    }

    return(rc);
}

#ifndef SPUTILSW

DWORD
pSetupMapFileForRead(
    IN  HANDLE   FileHandle,
    OUT PDWORD   FileSize,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    )

/*++

Routine Description:

    Map an opened file for read access.

Arguments:

    FileHandle - supplies the handle of the opened file to be mapped.
        This handle must have been opened with at least read access.

    FileSize - receives the size in bytes of the file.

    MappingHandle - receives the win32 handle for the file mapping
        object.  This object will be for read access.

    BaseAddress - receives the address where the file is mapped.

Return Value:

    NO_ERROR if the file was mapped successfully.  The caller must
        unmap the file with pSetupUnmapAndCloseFile when access to the file
        is no longer desired.

    Win32 error code if the file was not successfully mapped.

--*/

{
    DWORD rc;

    //
    // Get the size of the file.
    //
    *FileSize = GetFileSize(FileHandle, NULL);
    if(*FileSize != (DWORD)(-1)) {

        //
        // Create file mapping for the whole file.
        //
        *MappingHandle = CreateFileMapping(
                            FileHandle,
                            NULL,
                            PAGE_READONLY,
                            0,
                            *FileSize,
                            NULL
                            );

        if(*MappingHandle) {

            //
            // Map the whole file.
            //
            *BaseAddress = MapViewOfFile(
                                *MappingHandle,
                                FILE_MAP_READ,
                                0,
                                0,
                                *FileSize
                                );

            if(*BaseAddress) {
                return(NO_ERROR);
            }

            rc = GetLastError();
            CloseHandle(*MappingHandle);
        } else {
            rc = GetLastError();
        }
    } else {
        rc = GetLastError();
    }

    return(rc);
}

BOOL
pSetupUnmapAndCloseFile(
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    )

/*++

Routine Description:

    Unmap and close a file.

Arguments:

    FileHandle - supplies win32 handle to open file.

    MappingHandle - supplies the win32 handle for the open file mapping
        object.

    BaseAddress - supplies the address where the file is mapped.

Return Value:

    BOOLean value indicating success or failure.

--*/

{
    BOOL b;

    b = UnmapViewOfFile(BaseAddress);

    b = b && CloseHandle(MappingHandle);

    b = b && CloseHandle(FileHandle);

    return(b);
}

#endif //!SPUTILSW


BOOL
pSetupFileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

DWORD
pSetupMakeSurePathExists(
    IN PCTSTR FullFilespec
    )

/*++

Routine Description:

    This routine ensures that a multi-level path exists by creating individual
    levels one at a time. It is assumed that the caller will pass in a *filename*
    whose path needs to exist. Some examples:

    c:\x                        - C:\ is assumes to always exist.

    c:\x\y\z                    - Ensure that c:\x\y exists.

    \x\y\z                      - \x\y on current drive

    x\y                         - x in current directory

    d:x\y                       - d:x

    \\server\share\p\file       - \\server\share\p

    \\?\GLOBALROOT\a\b\c        - other more weird scenarios
    \\?\C:\a\b\c

Arguments:

    FullFilespec - supplies the *filename* of a file that the caller wants to
        create. This routine creates the *path* to that file, in other words,
        the final component is assumed to be a filename, and is not a
        directory name. (This routine doesn't actually create this file.)
        If this is invalid, then the results are undefined (for example,
        passing \\server\share, C:\, or C:).

Return Value:

    Win32 error code indicating outcome. If FullFilespec is invalid,
    *may* return ERROR_INVALID_NAME.

--*/

{
    TCHAR Buffer[MAX_PATH+2];
    TCHAR c;
    PTSTR filename;
    PTSTR root;
    PTSTR last;
    PTSTR backtrack;
    DWORD len;
    DWORD attrib;

    //
    // normalize path
    //
    len = GetFullPathName(FullFilespec,MAX_PATH,Buffer,&filename);
    if(len >= MAX_PATH) {
        //
        // directory name is longer than we can handle
        //
        return ERROR_INVALID_NAME;
    }
    if(!len) {
        //
        // other error
        //
        return GetLastError();
    }
    if(filename == NULL || filename == Buffer) {
        //
        // looks like no path specified
        //
        return ERROR_INVALID_NAME;
    }
    //
    // chop off filename part
    //
    filename[0] = TEXT('\0');

    //
    // now do some other sanity checks
    // to determine 'root' - a point we wont try to create
    //
    if(Buffer[0] && Buffer[1] == TEXT(':')) {
        //
        // looks like "d:" format
        //
        if(Buffer[2] != TEXT('\\')) {
            return ERROR_INVALID_NAME;
        }
        root = Buffer+2;
    }

    if(Buffer[0] == TEXT('\\') &&
        Buffer[1] == TEXT('\\')) {
        //
        // UNC style (\\machine\share\path \\?\d\path \\?\GLOBALROOT\path \\.\GLOBALROOT\path etc)
        // root is 2nd slash after \\
        //
        root = _tcschr(Buffer+2,TEXT('\\')); // find first slash
        if(root) {
            root = _tcschr(root+1,TEXT('\\')); // find 2nd slash
        }
        if(!root) {
            return ERROR_INVALID_NAME;
        }
    }

    //
    // see if the directory specified exists
    // include the slash, since that helps scenarios like \\?\GLOBALROOT\Device\HarddiskVolume1\
    // and works for all the other scenarios
    // can't use findfirst/findnext though
    //
    attrib = GetFileAttributes(Buffer);
    if(attrib != (DWORD)(-1)) {
        if(attrib & FILE_ATTRIBUTE_DIRECTORY) {
            //
            // requested directory already exists
            //
            return NO_ERROR;
        }
        //
        // directory was expected
        //
        return ERROR_DIRECTORY;
    }

    //
    // now we have to step backwards until we find an existing directory
    // change all '\' to nulls as we do so
    // this will give us something like (c esc form) c:\\a\\b\\c\0d\0e\0f\0\0
    // we know the last \0 is there from when we chopped filename
    // first directory to be created is c:\\a\\b\\c
    //
    last = CharPrev(Buffer,filename); // to last slash
    if(last == root) {
        return ERROR_INVALID_NAME;
    }
    if(*last != TEXT('\\')) {
        //
        // should never be the case
        //
        return ERROR_INVALID_NAME;
    }
    while(last > root) {
        *last = TEXT('\0');
        backtrack = _tcsrchr(Buffer,TEXT('\\'));
        if(!backtrack) {
            return ERROR_INVALID_NAME;
        }
        c = backtrack[1];
        backtrack[1] = TEXT('\0');
        attrib = GetFileAttributes(Buffer); // does this part exist?
        backtrack[1] = c;                   // but character back
        if(attrib != (DWORD)(-1)) {
            if(attrib & FILE_ATTRIBUTE_DIRECTORY) {
                //
                // requested directory already exists
                // 'last' points to first NULL to replace to slash
                // Buffer contains first directory to create
                //
                break;
            }
            //
            // directory was expected
            //
            return ERROR_DIRECTORY;
        }
        //
        // keep going
        //
        last = backtrack;
    }
    if(last <= root) {
        return ERROR_INVALID_NAME;
    }

    //
    // now begin create loop
    //
    while(CreateDirectory(Buffer,NULL)) {
        if(!last[1]) {
            //
            // path created
            //
            return NO_ERROR;
        }
        last[0] = TEXT('\\');
        last += lstrlen(last);
    }
    //
    // failed for some other reason
    //
    return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\memory.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    memory.c

Abstract:

    Memory handling routines for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 11-Jan-1995

Revision History:

    Jamie Hunter (jamiehun) 13-Feb-1998

        Improved this further for debugging
        added linked list,
        alloc tracing,
        memory fills
        and memory leak detection

    jamiehun 30-April-1998

        Added some more consistancy checks
        Put try/except around access

    jimschm 27-Oct-1998

        Wrote fast allocation routines to speed up setupapi.dll on Win9x

    JamieHun Jun-26-2000

        Moved to sputils
        Changed to use a private heap

--*/


#include "precomp.h"
#pragma hdrstop

static BOOL Initialized = FALSE;
static HANDLE _pSpUtilsHeap = NULL;

#define ALLOC(x)        HeapAlloc(_pSpUtilsHeap,0,x)
#define FREE(x)         HeapFree(_pSpUtilsHeap,0,x)
#define REALLOC(x,y)    HeapReAlloc(_pSpUtilsHeap,0,x,y)
#define MEMSIZE(x)      HeapSize(_pSpUtilsHeap,0,x)
#define INITIALHEAPSIZE (0x100000)

//
// Internal debugging features
//

#if MEM_DBG

#define MEMERROR(x) _pSpUtilsAssertFail(__FILE__,__LINE__,#x)

DWORD _pSpUtilsDbgAllocNum = 0;
DWORD _pSpUtilsMemoryFlags = 0;

struct _MemHeader {
    struct _MemHeader * PrevAlloc;  // previous on chain
    struct _MemHeader * NextAlloc;  // next on chain
    DWORD MemoryTag;                // tag - to pair off Malloc/Free
    DWORD BlockSize;                // bytes of "real" data
    DWORD AllocNum;                 // number of this allocation, ie AllocCount at the time this was allocated
    PCSTR AllocFile;                // name of file that did allocation, if set
    DWORD AllocLine;                // line of this allocation
    DWORD HeadMemSig;               // head-check, stop writing before actual data
    BYTE Data[sizeof(DWORD)];       // size allows for tail-check at end of actual data
};

struct _MemStats {
    struct _MemHeader * FirstAlloc; // will be NULL if no allocations, else earliest malloc/realloc in chain
    struct _MemHeader * LastAlloc;  // last alloc/realloc goes to end of chain
    DWORD MemoryAllocated;          // bytes, excluding headers
    DWORD AllocCount;               // incremented for every alloc
    DWORD ReallocCount;             // incremented for every realloc
    DWORD FreeCount;                // incremented for every free
    BOOL DoneInitDebugMutex;
    CRITICAL_SECTION DebugMutex;    // We need a mutex to manage memstats, setupapi is MT
} _pSpUtilsMemStats = {
    NULL, NULL, 0, 0, 0, 0, FALSE, 0
};

//
// Checked builds have a block head/tail check
// and extra statistics
//
#define HEAD_MEMSIG 0x4d444554  // = MDET (MSB to LSB) or TEDM (LSB to MSB)
#define TAIL_MEMSIG 0x5445444d  // = TEDM (MSB to LSB) or MDET (LSB to MSB)
#define MEM_ALLOCCHAR 0xdd      // makes sure we fill with non-null
#define MEM_FREECHAR 0xee       // if we see this, memory has been de-allocated
#define MEM_DEADSIG 0xdeaddead
#define MEM_TOOBIG 0x80000000   // use this to pick up big allocs

#define MemMutexLock()          EnterCriticalSection(&_pSpUtilsMemStats.DebugMutex)
#define MemMutexUnlock()        LeaveCriticalSection(&_pSpUtilsMemStats.DebugMutex)

static
BOOL MemBlockCheck(
    struct _MemHeader * Mem
    )
/*++

Routine Description:

    Verify a block header is valid

Arguments:
    Mem = Header to verify

Returns:
    TRUE if valid
    FALSE if not valid

++*/
{
    if (Mem == NULL) {
        return TRUE;
    }
    if (Mem->HeadMemSig != HEAD_MEMSIG) {
        MEMERROR("Internal heap error - HeadMemSig invalid");
        return FALSE;
    }
    if (Mem->BlockSize >= MEM_TOOBIG) {
        MEMERROR("Internal heap error - BlockSize too big");
        return FALSE;
    }
    if((Mem->PrevAlloc == Mem) || (Mem->NextAlloc == Mem)) {
        //
        // we should have failed the MEMSIG, but it's ok as an extra check
        //
        MEMERROR("Internal heap error - self link");
        return FALSE;
    }
    if ((*(DWORD UNALIGNED *)(Mem->Data+Mem->BlockSize)) != TAIL_MEMSIG) {
        MEMERROR("Internal heap error - TailMemSig invalid");
        return FALSE;
    }
    return TRUE;
}

static
struct _MemHeader *
MemBlockGet(
    IN PVOID Block
    )
/*++

Routine Description:

    Verify a block is valid, and return real memory pointer

Arguments:
    Block - address the application uses

++*/
{
    struct _MemHeader * Mem;

    if((DWORD_PTR)Block < offsetof(struct _MemHeader,Data[0])) {
        MEMERROR("Internal heap error - Block address is invalid");
        return NULL;
    }

    Mem = (struct _MemHeader *)(((PBYTE)Block) - offsetof(struct _MemHeader,Data[0]));

    if (MemBlockCheck(Mem)==FALSE) {
        //
        // block fails test
        //
        return NULL;
    }

    if(Mem->PrevAlloc != NULL) {
        if(MemBlockCheck(Mem->PrevAlloc)==FALSE) {
            //
            // back link is invalid
            //
            return NULL;
        }
    } else if (_pSpUtilsMemStats.FirstAlloc != Mem) {
        //
        // _pSpUtilsMemStats.FirstAlloc is invalid wrt Mem
        //
        MEMERROR("Internal heap error - FirstAlloc invalid");
        return NULL;
    }
    if(Mem->NextAlloc != NULL) {
        if(MemBlockCheck(Mem->NextAlloc)==FALSE) {
            //
            // forward link is invalid
            //
            return NULL;
        }
    } else if (_pSpUtilsMemStats.LastAlloc != Mem) {
        //
        // _pSpUtilsMemStats.LastAlloc is invalid wrt Mem
        //
        MEMERROR("Internal heap error - LastAlloc invalid");
        return NULL;
    }

    //
    // seems pretty good
    //

    return Mem;
}

static
PVOID
MemBlockLink(
    struct _MemHeader * Mem
    )

{
    if (Mem == NULL) {
        return NULL;
    }

    Mem->PrevAlloc = _pSpUtilsMemStats.LastAlloc;
    Mem->NextAlloc = NULL;
    _pSpUtilsMemStats.LastAlloc = Mem;
    if (Mem->PrevAlloc == NULL) {
        _pSpUtilsMemStats.FirstAlloc = Mem;
    } else {
        if (MemBlockCheck(Mem->PrevAlloc)) {
            Mem->PrevAlloc->NextAlloc = Mem;
        }
    }

    Mem->HeadMemSig = HEAD_MEMSIG;
    *(DWORD UNALIGNED *)(Mem->Data+Mem->BlockSize) = TAIL_MEMSIG;

    return (PVOID)(Mem->Data);
}

static
PVOID
MemBlockUnLink(
    struct _MemHeader * Mem
    )

{
    if (Mem == NULL) {
        return NULL;
    }
    if((Mem->PrevAlloc == Mem) || (Mem->NextAlloc == Mem) || (Mem->HeadMemSig == MEM_DEADSIG)) {
        MEMERROR("Internal heap error - MemBlockUnLink");
    }

    if (Mem->PrevAlloc == NULL) {
        _pSpUtilsMemStats.FirstAlloc = Mem->NextAlloc;
    } else {
        Mem->PrevAlloc->NextAlloc = Mem->NextAlloc;
    }
    if (Mem->NextAlloc == NULL) {
        _pSpUtilsMemStats.LastAlloc = Mem->PrevAlloc;
    } else {
        Mem->NextAlloc->PrevAlloc = Mem->PrevAlloc;
    }
    Mem->PrevAlloc = Mem;  // make pointers harmless and also adds as an exta debug check
    Mem->NextAlloc = Mem;  // make pointers harmless and also adds as an exta debug check
    Mem->HeadMemSig = MEM_DEADSIG;
    *(DWORD UNALIGNED *)(Mem->Data+Mem->BlockSize) = MEM_DEADSIG;

    return Mem->Data;
}

static
BOOL
MemDebugInitialize(
    VOID
    )
{
    try {
        InitializeCriticalSection(&_pSpUtilsMemStats.DebugMutex);
        _pSpUtilsMemStats.DoneInitDebugMutex = TRUE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return _pSpUtilsMemStats.DoneInitDebugMutex;
}

static
BOOL
MemDebugUninitialize(
    VOID
    )
{
    struct _MemHeader *Mem;
    TCHAR Msg[1024];
    TCHAR Process[MAX_PATH];

    //
    // Dump the leaks
    //

    Mem = _pSpUtilsMemStats.FirstAlloc;

    GetModuleFileName( GetModuleHandle(NULL),Process, sizeof(Process)/sizeof(TCHAR));


    while (Mem) {
        wsprintf (Msg, TEXT("SPUTILS: Leak (%d bytes) at %hs line %u (allocation #%d) in process %s \r\n"), Mem->BlockSize, Mem->AllocFile, Mem->AllocLine, Mem->AllocNum, Process );
        pSetupDebugPrintEx(DPFLTR_WARNING_LEVEL, Msg);
        if (_pSpUtilsMemoryFlags != 0) {
            if (Mem->BlockSize > 1024) {
                pSetupDebugPrintEx(DPFLTR_ERROR_LEVEL, TEXT("Leak of > 1K. Calling DebugBreak.\n"));
                DebugBreak();
            }
        }

        Mem = Mem->NextAlloc;
    }

    //
    // Clean up
    //

    if(_pSpUtilsMemStats.DoneInitDebugMutex) {
        DeleteCriticalSection(&_pSpUtilsMemStats.DebugMutex);
    }

    //
    // any last minute checks
    //

    return TRUE;
}

#endif // MEM_DBG


//
// published functions
//

PVOID
pSetupDebugMallocWithTag(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line,
    IN DWORD Tag
    )
/*++

Routine Description:

    Debug version of Malloc
    Resulting allocated block has prefix/suffix and is filled with MEM_ALLOCCHAR

Arguments:

    Size - size in bytes of block to be allocated. The size may be 0.
    Filename/Line - debugging information

    Tag    - match malloc with free/realloc's

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.

--*/
{
#if MEM_DBG

    struct _MemHeader *Mem;
    PVOID Ptr = NULL;
    BOOL locked = FALSE;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    MYASSERT(Initialized);


    try {
        MemMutexLock();
        locked = TRUE;
        _pSpUtilsMemStats.AllocCount++;

        if (Size >= MEM_TOOBIG) {
            MEMERROR("pSetupDebugMalloc - requested size too big (negative?)");
            leave;
        }

        if((Mem = (struct _MemHeader*) ALLOC(Size+sizeof(struct _MemHeader))) == NULL) {
            leave;  // it failed ALLOC, but prob not due to a bug
        }

        Mem->MemoryTag = Tag;
        Mem->BlockSize = Size;
        Mem->AllocNum = _pSpUtilsMemStats.AllocCount;
        Mem->AllocFile = Filename;
        Mem->AllocLine = Line;

        // init memory we have allocated (to make sure we don't accidently get zero's)
        FillMemory(Mem->Data,Size,MEM_ALLOCCHAR);

        _pSpUtilsMemStats.MemoryAllocated += Size;

        Ptr = MemBlockLink(Mem);

        if (_pSpUtilsMemoryFlags && (_pSpUtilsDbgAllocNum == Mem->AllocNum)) {
            MEMERROR("_pSpUtilsDbgAllocNum hit");
        }

    } except(ExceptionPointers = GetExceptionInformation(),
             EXCEPTION_EXECUTE_HANDLER) {
        MEMERROR("pSetupDebugMalloc - Exception");
        Ptr = NULL;
    }

    if(locked) {
        MemMutexUnlock();
    }

    return Ptr;

#else

    return ALLOC(Size);

#endif
}

PVOID
pSetupDebugMalloc(
    IN DWORD Size,
    IN PCSTR Filename,
    IN DWORD Line
    )
/*++

Routine Description:

    Allocate a chunk of memory. The memory is not zero-initialized.

Arguments:

    Size - size in bytes of block to be allocated. The size may be 0.

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.

--*/

{
    MYASSERT(Initialized);

#if MEM_DBG

    return pSetupDebugMallocWithTag(Size, Filename , Line, 0);

#else

    return ALLOC(Size);

#endif
}

PVOID
pSetupMalloc(
    IN DWORD Size
    )

/*++

Routine Description:

    Allocate a chunk of memory. The memory is not zero-initialized.

Arguments:

    Size - size in bytes of block to be allocated. The size may be 0.

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.

--*/

{
    MYASSERT(Initialized);

#if MEM_DBG

    return pSetupDebugMallocWithTag(Size, NULL , 0, 0);

#else

    return ALLOC(Size);

#endif
}

PVOID
pSetupReallocWithTag(
    IN PVOID Block,
    IN DWORD NewSize,
    IN DWORD Tag
    )

/*++

Routine Description:

    Realloc routine Debug/Non-Debug versions

    Note that a general assumption here, is that if NewSize <= OriginalSize
    the reallocation *should* not fail

Arguments:

    Block - pointer to block to be reallocated.

    NewSize - new size in bytes of block. If the size is 0, this function
        works like pSetupFree, and the return value is NULL.

    Tag    - match realloc with malloc

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.
    In that case the original block remains unchanged.

--*/

{
#if MEM_DBG

    PVOID p;
    DWORD OldSize;
    struct _MemHeader *Mem;
    PVOID Ptr = NULL;
    BOOL locked = FALSE;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    MYASSERT(Initialized);

    try {
        MemMutexLock();
        locked = TRUE;
        _pSpUtilsMemStats.ReallocCount++;

        if (Block == NULL) {
            leave;
        }

        if (NewSize >= MEM_TOOBIG) {
            MEMERROR("pSetupRealloc - requested size too big (negative?)");
            leave;
        }

        Mem = MemBlockGet(Block);
        if (Mem == NULL) {
            leave;
        }

        if (Mem->MemoryTag != Tag) {
            MEMERROR("pSetupRealloc - Tag mismatch");
            leave;
        }

        OldSize = Mem->BlockSize;
        MemBlockUnLink(Mem);

        if (NewSize < OldSize) {
            // trash memory we're about to free
            FillMemory(Mem->Data+NewSize,OldSize-NewSize+sizeof(DWORD),MEM_FREECHAR);
        }

        if((p = REALLOC(Mem, NewSize+sizeof(struct _MemHeader))) == NULL) {
            //
            // failed to re-alloc
            //
            MemBlockLink(Mem);
            leave;
        }
        Mem = (struct _MemHeader*)p;
        Mem->BlockSize = NewSize;

        if (NewSize > OldSize) {
            // init extra memory we have allocated
            FillMemory(Mem->Data+OldSize,NewSize-OldSize,MEM_ALLOCCHAR);
        }
        _pSpUtilsMemStats.MemoryAllocated -= OldSize;
        _pSpUtilsMemStats.MemoryAllocated += NewSize;

        Ptr = MemBlockLink(Mem);

    } except(ExceptionPointers = GetExceptionInformation(),
             EXCEPTION_EXECUTE_HANDLER) {
        MEMERROR("pSetupRealloc - Exception");
        Ptr = NULL;
    }

    if(locked) {
        MemMutexUnlock();
    }

    return Ptr;

#else

    return REALLOC(Block, NewSize);

#endif
}

PVOID
pSetupRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    )

/*++

Routine Description:

    Realloc routine Debug/Non-Debug versions

    Note that a general assumption here, is that if NewSize <= OriginalSize
    the reallocation *should* not fail

Arguments:

    Block - pointer to block to be reallocated.

    NewSize - new size in bytes of block. If the size is 0, this function
        works like pSetupFree, and the return value is NULL.

Return Value:

    Pointer to block of memory, or NULL if a block could not be allocated.
    In that case the original block remains unchanged.

--*/

{
#if MEM_DBG

    return pSetupReallocWithTag(Block,NewSize,0);

#else

    return REALLOC(Block, NewSize);

#endif
}

VOID
pSetupFreeWithTag(
    IN CONST VOID *Block,
    IN DWORD Tag
    )

/*++

Routine Description:

    Free (debug/non-debug versions)

Arguments:

    Buffer - pointer to block to be freed.
    Tag    - match free with malloc

Return Value:

    None.

--*/

{
#if MEM_DBG

    DWORD OldSize;
    struct _MemHeader *Mem;
    BOOL locked = FALSE;
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    MYASSERT(Initialized);

    try {
        MemMutexLock();
        locked = TRUE;
        _pSpUtilsMemStats.FreeCount++;

        if (Block == NULL) {
            leave;
        }

        Mem = MemBlockGet((PVOID)Block);
        if (Mem == NULL) {
            leave;
        }
        if (Mem->MemoryTag != Tag) {
            MEMERROR("pSetupFree - Tag mismatch");
            leave;
        }
        OldSize = Mem->BlockSize;
        MemBlockUnLink(Mem);
        _pSpUtilsMemStats.MemoryAllocated -= OldSize;

        //
        // trash memory we're about to free, so we can immediately see it has been free'd!!!!
        // we keep head/tail stuff to have more info available when debugging
        //
        FillMemory((PVOID)Block,OldSize,MEM_FREECHAR);
        Mem->MemoryTag = (DWORD)(-1);
        FREE(Mem);
    } except(ExceptionPointers = GetExceptionInformation(),
             EXCEPTION_EXECUTE_HANDLER) {
          MEMERROR("pSetupFree - Exception");
    }

    if(locked) {
        MemMutexUnlock();
    }

#else

    FREE ((void *)Block);

#endif
}

VOID
pSetupFree(
    IN CONST VOID *Block
    )

/*++

Routine Description:

    Free (debug/non-debug versions)

Arguments:

    Buffer - pointer to block to be freed.

Return Value:

    None.

--*/
{
#if MEM_DBG

    pSetupFreeWithTag(Block,0);

#else

    FREE ((void *)Block);

#endif

}

HANDLE
pSetupGetHeap(
    VOID
    )
{
    MYASSERT(Initialized);
    return _pSpUtilsHeap;
}

//
// initialization functions
//

BOOL
_pSpUtilsMemoryInitialize(
    VOID
    )
{
#if MEM_DBG
    _pSpUtilsHeap = HeapCreate(0,INITIALHEAPSIZE,0);
    if(_pSpUtilsHeap == NULL) {
        return FALSE;
    }
    MemDebugInitialize();
#else
    _pSpUtilsHeap = GetProcessHeap();
#endif

#if MEM_DBG
#endif
    Initialized = TRUE;
    return TRUE;
}

BOOL
_pSpUtilsMemoryUninitialize(
    VOID
    )
{
    if(Initialized) {
#if MEM_DBG
        MemDebugUninitialize();

        if(_pSpUtilsHeap) {
            HeapDestroy(_pSpUtilsHeap);
            _pSpUtilsHeap = NULL;
        }
#endif
        Initialized = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\miscutil.c ===
/*++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    miscutil.c

Abstract:

    Miscellaneous utility functions for SPUTILS

Author:

    Ted Miller (tedm) 20-Jan-1995

Revision History:

    Jamie Hunter (JamieHun) Jun-27-2000
            Moved various functions out of setupapi into sputils

--*/


#include "precomp.h"
#pragma hdrstop

PTSTR
pSetupDuplicateString(
    IN PCTSTR String
    )

/*++

Routine Description:

    Create a duplicate copy of a nul-terminated string.
    If the string pointer is not valid an exception is generated.

Arguments:

    String - supplies string to be duplicated.

Return Value:

    NULL if out of memory.
    Caller can free buffer with pSetupFree().

--*/

{
    PTSTR p;

    //
    // The win32 lstrlen and lstrcpy functions are guarded with
    // try/except (at least on NT). So if we use them and the string
    // is invalid, we may end up 'laundering' it into a valid 0-length
    // string. We don't want that -- we actually want to fault
    // in that case. So use the CRT functions, which we know are
    // unguarded and will generate exceptions with invalid args.
    //
    // Also handle the case where the string is valid when we are
    // taking its length, but becomes invalid before or while we
    // are copying it. If we're not careful this could be a memory
    // leak. A try/finally does exactly what we want -- allowing us
    // to clean up and still 'pass on' the exception.
    //
    if(p = pSetupCheckedMalloc((_tcslen(String)+1)*sizeof(TCHAR))) {
        try {
            //
            // If String is or becomes invalid, this will generate
            // an exception, but before execution leaves this routine
            // we'll hit the termination handler.
            //
            _tcscpy(p,String);
        } finally {
            //
            // If a fault occurred during the copy, free the copy.
            // Execution will then pass to whatever exception handler
            // might exist in the caller, etc.
            //
            if(AbnormalTermination()) {
                pSetupFree(p);
                p = NULL;
            }
        }
    }

    return(p);
}

#ifndef SPUTILSW

PSTR
pSetupUnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if out of memory or invalid codepage.
    Caller can free buffer with pSetupFree().

--*/

{
    UINT WideCharCount;
    PSTR String;
    UINT StringBufferSize;
    UINT BytesInString;
    PSTR p;

    WideCharCount = lstrlenW(UnicodeString) + 1;

    //
    // Allocate maximally sized buffer.
    // If every unicode character is a double-byte
    // character, then the buffer needs to be the same size
    // as the unicode string. Otherwise it might be smaller,
    // as some unicode characters will translate to
    // single-byte characters.
    //
    StringBufferSize = WideCharCount * 2;
    String = pSetupCheckedMalloc(StringBufferSize);
    if(String == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    BytesInString = WideCharToMultiByte(
                        Codepage,
                        0,                      // default composite char behavior
                        UnicodeString,
                        WideCharCount,
                        String,
                        StringBufferSize,
                        NULL,
                        NULL
                        );

    if(BytesInString == 0) {
        pSetupFree(String);
        return(NULL);
    }

    //
    // Resize the string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    if(p = pSetupRealloc(String,BytesInString)) {
        String = p;
    }

    return(String);
}


PWSTR
pSetupMultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    )

/*++

Routine Description:

    Convert a string to unicode.

Arguments:

    String - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if string could not be converted (out of memory or invalid cp)
    Caller can free buffer with pSetupFree().

--*/

{
    UINT BytesIn8BitString;
    UINT CharsInUnicodeString;
    PWSTR UnicodeString;
    PWSTR p;

    BytesIn8BitString = lstrlenA(String) + 1;

    //
    // Allocate maximally sized buffer.
    // If every character is a single-byte character,
    // then the buffer needs to be twice the size
    // as the 8bit string. Otherwise it might be smaller,
    // as some characters are 2 bytes in their unicode and
    // 8bit representations.
    //
    UnicodeString = pSetupCheckedMalloc(BytesIn8BitString * sizeof(WCHAR));
    if(UnicodeString == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    CharsInUnicodeString = MultiByteToWideChar(
                                Codepage,
                                MB_PRECOMPOSED,
                                String,
                                BytesIn8BitString,
                                UnicodeString,
                                BytesIn8BitString
                                );

    if(CharsInUnicodeString == 0) {
        pSetupFree(UnicodeString);
        return(NULL);
    }

    //
    // Resize the unicode string's buffer to its correct size.
    // If the realloc fails for some reason the original
    // buffer is not freed.
    //
    if(p = pSetupRealloc(UnicodeString,CharsInUnicodeString*sizeof(WCHAR))) {
        UnicodeString = p;
    }

    return(UnicodeString);
}

#endif // ! SPUTILSW

#ifdef UNICODE

DWORD
pSetupCaptureAndConvertAnsiArg(
    IN  PCSTR   AnsiString,
    OUT PCWSTR *UnicodeString
    )

/*++

Routine Description:

    Capture an ANSI string whose validity is suspect and convert it
    into a Unicode string. The conversion is completely guarded and thus
    won't fault, leak memory in the error case, etc.

Arguments:

    AnsiString - supplies string to be converted.

    UnicodeString - if successful, receives pointer to unicode equivalent
        of AnsiString. Caller must free with pSetupFree(). If not successful,
        receives NULL. This parameter is NOT validated so be careful.

Return Value:

    Win32 error code indicating outcome.

    NO_ERROR - success, UnicodeString filled in.
    ERROR_NOT_ENOUGH_MEMORY - insufficient memory for conversion.
    ERROR_INVALID_PARAMETER - AnsiString was invalid.

--*/

{
    PSTR ansiString;
    DWORD d;

    //
    // Capture the string first. We do this because pSetupMultiByteToUnicode
    // won't fault if AnsiString were to become invalid, meaning we could
    // 'launder' a bogus argument into a valid one. Be careful not to
    // leak memory in the error case, etc (see comments in DuplicateString()).
    // Do NOT use Win32 string functions here; we rely on faults occuring
    // when pointers are invalid!
    //
    *UnicodeString = NULL;
    d = NO_ERROR;
    try {
        ansiString = pSetupCheckedMalloc(strlen(AnsiString)+1);
        if(!ansiString) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // If we get here, strlen faulted and ansiString
        // was not allocated.
        //
        d = ERROR_INVALID_PARAMETER;
    }

    if(d == NO_ERROR) {
        try {
            strcpy(ansiString,AnsiString);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
            pSetupFree(ansiString);
        }
    }

    if(d == NO_ERROR) {
        //
        // Now we have a local copy of the string; don't worry
        // about faults any more.
        //
        *UnicodeString = pSetupMultiByteToUnicode(ansiString,CP_ACP);
        if(*UnicodeString == NULL) {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }

        pSetupFree(ansiString);
    }

    return(d);
}

#else

DWORD
pSetupCaptureAndConvertAnsiArg(
    IN  PCSTR   AnsiString,
    OUT PCWSTR *UnicodeString
    )
{
    //
    // Stub so the dll will link.
    //
    UNREFERENCED_PARAMETER(AnsiString);
    UNREFERENCED_PARAMETER(UnicodeString);
    return(ERROR_CALL_NOT_IMPLEMENTED);
}

#endif


BOOL
pSetupConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize          OPTIONAL
    )

/*++

Routine Description:

    Concatenate 2 paths, ensuring that one, and only one,
    path separator character is introduced at the junction point.

Arguments:

    Target - supplies first part of path. Path is appended to this.

    Path - supplies path to be concatenated to Target.

    TargetBufferSize - supplies the size of the Target buffer,
        in characters.

    RequiredSize - if specified, receives the number of characters
        required to hold the fully concatenated path, including
        the terminating nul.

Return Value:

    TRUE if the full path fit in Target buffer. Otherwise the path
    will have been truncated.

--*/

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (*CharPrev(Target,Target+TargetLength) == TEXT('\\'))) {
        TrailingBackslash = TRUE;
        TargetLength--;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // See whether the path has a leading backshash.
    //
    if(Path[0] == TEXT('\\')) {
        LeadingBackslash = TRUE;
        PathLength--;
    } else {
        LeadingBackslash = FALSE;
    }

    //
    // Calculate the ending length, which is equal to the sum of
    // the length of the two strings modulo leading/trailing
    // backslashes, plus one path separator, plus a nul.
    //
    EndingLength = TargetLength + PathLength + 2;
    if(RequiredSize) {
        *RequiredSize = EndingLength;
    }

    if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
        Target[TargetLength++] = TEXT('\\');
    }

    if(TargetBufferSize > TargetLength) {
        lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
    }

    //
    // Make sure the buffer is nul terminated in all cases.
    //
    if (TargetBufferSize) {
        Target[TargetBufferSize-1] = 0;
    }

    return(EndingLength <= TargetBufferSize);
}

PCTSTR
pSetupGetFileTitle(
    IN PCTSTR FilePath
    )

/*++

Routine Description:

    This routine returns a pointer to the first character in the
    filename part of the supplied path.  If only a filename was given,
    then this will be a pointer to the first character in the string
    (i.e., the same as what was passed in).

    To find the filename part, the routine returns the last component of
    the string, beginning with the character immediately following the
    last '\', '/' or ':'. (NB NT treats '/' as equivalent to '\' )

Arguments:

    FilePath - Supplies the file path from which to retrieve the filename
        portion.

Return Value:

    A pointer to the beginning of the filename portion of the path.

--*/

{
    PCTSTR LastComponent = FilePath;
    TCHAR  CurChar;

    while(CurChar = *FilePath) {
        FilePath = CharNext(FilePath);
        if((CurChar == TEXT('\\')) || (CurChar == TEXT('/')) || (CurChar == TEXT(':'))) {
            LastComponent = FilePath;
        }
    }

    return LastComponent;
}

#ifndef SPUTILSW

BOOL
_pSpUtilsInitializeSynchronizedAccess(
    OUT PMYLOCK Lock
    )

/*++

Routine Description:

    Initialize a lock structure to be used with Synchronization routines.

Arguments:

    Lock - supplies structure to be initialized. This routine creates
        the locking event and mutex and places handles in this structure.

Return Value:

    TRUE if the lock structure was successfully initialized. FALSE if not.

--*/

{
    if(Lock->Handles[TABLE_DESTROYED_EVENT] = CreateEvent(NULL,TRUE,FALSE,NULL)) {
        if(Lock->Handles[TABLE_ACCESS_MUTEX] = CreateMutex(NULL,FALSE,NULL)) {
            return(TRUE);
        }
        CloseHandle(Lock->Handles[TABLE_DESTROYED_EVENT]);
    }
    return(FALSE);
}


VOID
_pSpUtilsDestroySynchronizedAccess(
    IN OUT PMYLOCK Lock
    )

/*++

Routine Description:

    Tears down a lock structure created by InitializeSynchronizedAccess.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    Lock - supplies structure to be torn down. The structure itself
        is not freed.

Return Value:

    None.

--*/

{
    HANDLE h1,h2;

    h1 = Lock->Handles[TABLE_DESTROYED_EVENT];
    h2 = Lock->Handles[TABLE_ACCESS_MUTEX];

    Lock->Handles[TABLE_DESTROYED_EVENT] = NULL;
    Lock->Handles[TABLE_ACCESS_MUTEX] = NULL;

    CloseHandle(h2);

    SetEvent(h1);
    CloseHandle(h1);
}

VOID
pSetupCenterWindowRelativeToParent(
    HWND hwnd
    )

/*++

Routine Description:

    Centers a dialog relative to its owner, taking into account
    the 'work area' of the desktop.

Arguments:

    hwnd - window handle of dialog to center

Return Value:

    None.

--*/

{
    RECT  rcFrame,
          rcWindow;
    LONG  x,
          y,
          w,
          h;
    POINT point;
    HWND Parent;

    Parent = GetWindow(hwnd,GW_OWNER);
    if(Parent == NULL) {
        return;
    }

    point.x = point.y = 0;
    ClientToScreen(Parent,&point);
    GetWindowRect(hwnd,&rcWindow);
    GetClientRect(Parent,&rcFrame);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcFrame.right  - rcFrame.left + 1 - w) / 2);
    y = point.y + ((rcFrame.bottom - rcFrame.top  + 1 - h) / 2);

    //
    // Get the work area for the current desktop (i.e., the area that
    // the tray doesn't occupy).
    //
    if(!SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&rcFrame, 0)) {
        //
        // For some reason SPI failed, so use the full screen.
        //
        rcFrame.top = rcFrame.left = 0;
        rcFrame.right = GetSystemMetrics(SM_CXSCREEN);
        rcFrame.bottom = GetSystemMetrics(SM_CYSCREEN);
    }

    if(x + w > rcFrame.right) {
        x = rcFrame.right - w;
    } else if(x < rcFrame.left) {
        x = rcFrame.left;
    }
    if(y + h > rcFrame.bottom) {
        y = rcFrame.bottom - h;
    } else if(y < rcFrame.top) {
        y = rcFrame.top;
    }

    MoveWindow(hwnd,x,y,w,h,FALSE);
}

#endif // !SPUTILSW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\registry.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Registry interface routines for Windows NT Setup API Dll.

Author:

    Ted Miller (tedm) 6-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

static
BOOL
_RegistryDelnodeWorker(
    IN  HKEY   ParentKeyHandle,
    IN  PCTSTR KeyName,
    IN  DWORD Flags,
    OUT PDWORD ErrorCode
    )

/*++

Routine Description:

    Delete all subkeys of a key whose name and parent's handle was passed as
    parameter.
    The algorithm used in this function guarantees that the maximum number  of
    descendent keys will be deleted.

Arguments:


    ParentKeyHandle - Handle to the parent of the key that is currently being
        examined.

    KeyName - Name of the key that is currently being examined. This name can
        be an empty string (but not a NULL pointer), and in this case
        ParentKeyHandle refers to the key that is being examined.

    ErrorCode - Pointer to a variable that will contain an Win32 error code if
        the function fails.

Return Value:

    BOOL - Returns TRUE if the opearation succeeds.


--*/

{
    HKEY     CurrentKeyTraverseAccess;
    DWORD    iSubKey;
    TCHAR    SubKeyName[MAX_PATH+1];
    DWORD    SubKeyNameLength;
    FILETIME ftLastWriteTime;
    LONG     Status;
    LONG     StatusEnum;
    LONG     SavedStatus;


    //
    //  Do not accept NULL pointer for ErrorCode
    //
    if(ErrorCode == NULL) {
        return(FALSE);
    }
    //
    //  Do not accept NULL pointer for KeyName.
    //
    if(KeyName == NULL) {
        *ErrorCode = ERROR_INVALID_PARAMETER;
        return(FALSE);
    }

    //
    // Open a handle to the key whose subkeys are to be deleted.
    // Since we need to delete its subkeys, the handle must have
    // KEY_ENUMERATE_SUB_KEYS access.
    //
    Status = RegOpenKeyEx(
                ParentKeyHandle,
                KeyName,
                0,
#ifdef _WIN64
                (( Flags & FLG_DELREG_32BITKEY ) ? KEY_WOW64_32KEY:0) |
#else
                (( Flags & FLG_DELREG_64BITKEY ) ? KEY_WOW64_64KEY:0) |
#endif
                KEY_ENUMERATE_SUB_KEYS | DELETE,
                &CurrentKeyTraverseAccess
                );

    if(Status != ERROR_SUCCESS) {
        //
        //  If unable to enumerate the subkeys, return error.
        //
        *ErrorCode = Status;
        return(FALSE);
    }

    //
    //  Traverse the key
    //
    iSubKey = 0;
    SavedStatus = ERROR_SUCCESS;
    do {
        //
        // Get the name of a subkey
        //
        SubKeyNameLength = sizeof(SubKeyName) / sizeof(TCHAR);
        StatusEnum = RegEnumKeyEx(
                        CurrentKeyTraverseAccess,
                        iSubKey,
                        SubKeyName,
                        &SubKeyNameLength,
                        NULL,
                        NULL,
                        NULL,
                        &ftLastWriteTime
                        );

        if(StatusEnum == ERROR_SUCCESS) {
            //
            // Delete all children of the subkey.
            // Just assume that the children will be deleted, and don't check
            // for failure.
            //
            _RegistryDelnodeWorker(CurrentKeyTraverseAccess,SubKeyName,0,&Status);
            //
            // Now delete the subkey, and check for failure.
            //
            Status = RegDeleteKey(CurrentKeyTraverseAccess,SubKeyName);
            //
            // If unable to delete the subkey, then save the error code.
            // Note that the subkey index is incremented only if the subkey
            // was not deleted.
            //
            if(Status != ERROR_SUCCESS) {
                iSubKey++;
                SavedStatus = Status;
            }
        } else {
            //
            // If unable to get a subkey name due to ERROR_NO_MORE_ITEMS,
            // then the key doesn't have subkeys, or all subkeys were already
            // enumerated. Otherwise, an error has occurred, so just save
            // the error code.
            //
            if(StatusEnum != ERROR_NO_MORE_ITEMS) {
                SavedStatus = StatusEnum;
            }
        }
        //if((StatusEnum != ERROR_SUCCESS ) && (StatusEnum != ERROR_NO_MORE_ITEMS)) {
        //    printf( "RegEnumKeyEx() failed, Key Name = %ls, Status = %d, iSubKey = %d \n",KeyName,StatusEnum,iSubKey);
        //}
    } while(StatusEnum == ERROR_SUCCESS);

    //
    // Close the handle to the key whose subkeys were deleted, and return
    // the result of the operation.
    //
    RegCloseKey(CurrentKeyTraverseAccess);

    if(SavedStatus != ERROR_SUCCESS) {
        *ErrorCode = SavedStatus;
        return(FALSE);
    }
    return(TRUE);
}

DWORD
pSetupRegistryDelnodeEx(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName,
    IN  DWORD  ExtraFlags
    )
/*++

Routine Description:

    This routine deletes a registry key and gets rid of everything under it recursively.

Arguments:

    RootKey - Supplies handle to open registry key..ex. HKLM etc.

    SubKeyName - Name of the SubKey that we wish to recursively delete.

    ExtraFlags - Flags that are specified in the DelReg section of the INF.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is an error code.

--*/
{
    DWORD d,err,Status;
    HKEY hKey;
    PTSTR p;
    PTSTR TempKey = NULL;


    d = _RegistryDelnodeWorker(RootKey,SubKeyName,ExtraFlags,&err) ? NO_ERROR : err;

    if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
        d = NO_ERROR;
    }

    if(d == NO_ERROR) {
        //
        // Delete top-level key
        //


#ifdef _WIN64
        if( ExtraFlags & FLG_DELREG_32BITKEY ) {
#else
        if( ExtraFlags & FLG_DELREG_64BITKEY ) {
#endif

            //
            // For handling the WOW64 case:
            // deleting RootKey\SubKeyName by itself won't work
            // split subkeyname into parent\final
            // open parent for 32-bit access, and delete final
            //

            if( TempKey = (PTSTR)pSetupCheckedMalloc( (lstrlen(SubKeyName)+2) * sizeof(TCHAR))){

                lstrcpy( TempKey, SubKeyName );
                p = _tcsrchr(TempKey, TEXT('\\'));
                if(p){
                    *p++ = TEXT('\0');

                    d = RegOpenKeyEx(
                            RootKey,
                            TempKey,
                            0,
#ifdef _WIN64
                            KEY_WOW64_32KEY |
#else
                            KEY_WOW64_64KEY |
#endif
                            DELETE,
                            &hKey
                            );

                    d = RegDeleteKey(hKey, p);

                }else{

                   d = NO_ERROR;

                }
                pSetupFree( TempKey );

            }else{
                d = ERROR_NOT_ENOUGH_MEMORY;
            }
        }else{
            //
            // native case
            //
            d = RegDeleteKey(RootKey, SubKeyName);
        }

        if((d == ERROR_FILE_NOT_FOUND) || (d == ERROR_PATH_NOT_FOUND)) {
            //
            // at a verbose level, log that this key wasn't found
            //
            d = NO_ERROR;
        }
    }

    return(d);
}

DWORD
pSetupRegistryDelnode(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName
    )
{
    // Calls into Ex Function

    return pSetupRegistryDelnodeEx( RootKey, SubKeyName, 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\locking.h ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    locking.h

Abstract:

    Private header file for locking/synchronization functions
    within SPUTILS

Author:

    Ted Miller (tedm) 31-Mar-1995

Revision History:

    Jamie Hunter (JamieHun) Jun-27-2000
                Moved out of SetupAPI

--*/


//
// Locking functions. These functions are used to make various parts of
// the DLL multithread-safe. The basic idea is to have a mutex and an event.
// The mutex is used to synchronize access to the structure being guarded.
// The event is only signalled when the structure being guarded is destroyed.
// To gain access to the guarded structure, a routine waits on both the mutex
// and the event. If the event gets signalled, then the structure was destroyed.
// If the mutex gets signalled, then the thread has access to the structure.
//
typedef struct _MYLOCK {
    HANDLE Handles[2];
} MYLOCK, *PMYLOCK;

//
// Indices into Locks array in string table structure.
//
#define TABLE_DESTROYED_EVENT 0
#define TABLE_ACCESS_MUTEX    1

BOOL
__inline
BeginSynchronizedAccess(
    IN PMYLOCK Lock
    )
{
    DWORD d = WaitForMultipleObjects(2,Lock->Handles,FALSE,INFINITE);
    //
    // Success if the mutex object satisfied the wait;
    // Failure if the table destroyed event satisified the wait, or
    // the mutex was abandoned, etc.
    //
    return((d - WAIT_OBJECT_0) == TABLE_ACCESS_MUTEX);
}

VOID
__inline
EndSynchronizedAccess(
    IN PMYLOCK Lock
    )
{
    ReleaseMutex(Lock->Handles[TABLE_ACCESS_MUTEX]);
}

BOOL
_pSpUtilsInitializeSynchronizedAccess(
    OUT PMYLOCK Lock
    );

VOID
_pSpUtilsDestroySynchronizedAccess(
    IN OUT PMYLOCK Lock
    );

#define InitializeSynchronizedAccess    _pSpUtilsInitializeSynchronizedAccess
#define DestroySynchronizedAccess       _pSpUtilsDestroySynchronizedAccess
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\security.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Routines to deal with security-related stuff.

    Externally exposed routines:

        pSetupIsUserAdmin
        pSetupDoesUserHavePrivilege
        pSetupEnablePrivilege

Author:

    Ted Miller (tedm) 14-Jun-1995

Revision History:

    Jamie Hunter (jamiehun) Jun-27-2000
                Moved functions to sputils

--*/

#include "precomp.h"
#include <lmaccess.h>
#pragma hdrstop


#ifndef SPUTILSW

BOOL
pSetupIsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has admin privs

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

    Though we could use CheckTokenMembership
    this function may be expected to work on older platforms...

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrator privs.

    FALSE - Caller does not have Administrator privs.

--*/

{
    BOOL fAdmin = FALSE;
    HANDLE  hToken = NULL;
    DWORD dwStatus;
    DWORD dwACLSize;
    DWORD cbps = sizeof(PRIVILEGE_SET);
    PACL pACL = NULL;
    PSID psidAdmin = NULL;
    PSECURITY_DESCRIPTOR psdAdmin = NULL;
    PRIVILEGE_SET ps;
    GENERIC_MAPPING gm;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;

    //
    // Prepare some memory
    //
    ZeroMemory(&ps, sizeof(ps));
    ZeroMemory(&gm, sizeof(gm));

    //
    // Get the Administrators SID
    //
    if (AllocateAndInitializeSid(&sia, 2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0, &psidAdmin) ) {
        //
        // Get the Asministrators Security Descriptor (SD)
        //
        psdAdmin = pSetupCheckedMalloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (psdAdmin) {
            if(InitializeSecurityDescriptor(psdAdmin,SECURITY_DESCRIPTOR_REVISION)) {
                //
                // Compute size needed for the ACL then allocate the
                // memory for it
                //
                dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
                            GetLengthSid(psidAdmin) - sizeof(DWORD);
                pACL = (PACL)pSetupCheckedMalloc(dwACLSize);
                if(pACL) {
                    //
                    // Initialize the new ACL
                    //
                    if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2)) {
                        //
                        // Add the access-allowed ACE to the DACL
                        //
                        if(AddAccessAllowedAce(pACL,ACL_REVISION2,
                                             (ACCESS_READ | ACCESS_WRITE),psidAdmin)) {
                            //
                            // Set our DACL to the Administrator's SD
                            //
                            if (SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE)) {
                                //
                                // AccessCheck is downright picky about what is in the SD,
                                // so set the group and owner
                                //
                                SetSecurityDescriptorGroup(psdAdmin,psidAdmin,FALSE);
                                SetSecurityDescriptorOwner(psdAdmin,psidAdmin,FALSE);

                                //
                                // Initialize GenericMapping structure even though we
                                // won't be using generic rights
                                //
                                gm.GenericRead = ACCESS_READ;
                                gm.GenericWrite = ACCESS_WRITE;
                                gm.GenericExecute = 0;
                                gm.GenericAll = ACCESS_READ | ACCESS_WRITE;

                                //
                                // AccessCheck requires an impersonation token, so lets
                                // indulge it
                                //
                                ImpersonateSelf(SecurityImpersonation);

                                if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

                                    if (!AccessCheck(psdAdmin, hToken, ACCESS_READ, &gm,
                                                    &ps,&cbps,&dwStatus,&fAdmin)) {

                                        fAdmin = FALSE;
                                    }
                                    CloseHandle(hToken);
                                }
                            }
                        }
                    }
                    pSetupFree(pACL);
                }
            }
            pSetupFree(psdAdmin);
        }
        FreeSid(psidAdmin);
    }

    RevertToSelf();

    return(fAdmin);
}

#endif // !SPUTILSW

BOOL
pSetupDoesUserHavePrivilege(
    PCTSTR PrivilegeName
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    Privilege - the name form of privilege ID (such as
        SE_SECURITY_NAME).

Return Value:

    TRUE - Caller has the specified privilege.

    FALSE - Caller does not have the specified privilege.

--*/

{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Privileges = NULL;

    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = pSetupCheckedMalloc(BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {

        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {

            if((Luid.LowPart  == Privileges->Privileges[i].Luid.LowPart)
            && (Luid.HighPart == Privileges->Privileges[i].Luid.HighPart)) {

                b = TRUE;
                break;
            }
        }
    }

    //
    // Clean up and return.
    //

    if(Privileges) {
        pSetupFree(Privileges);
    }

    CloseHandle(Token);

    return(b);
}


BOOL
pSetupEnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    )

/*++

Routine Description:

    Enable or disable a given named privilege.

Arguments:

    PrivilegeName - supplies the name of a system privilege.

    Enable - flag indicating whether to enable or disable the privilege.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\sputils.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sputils.c

Abstract:

    Core sputils library file

Author:

    Jamie Hunter (JamieHun) Jun-27-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef ULONG (__cdecl *PFNDbgPrintEx)(IN ULONG ComponentId,IN ULONG Level,IN PCH Format, ...);
static PFNDbgPrintEx pfnDbgPrintEx = NULL;
static BOOL fInitDebug = FALSE;

static LONG RefCount = 0;                    // when this falls back to zero, release all resources
static BOOL SucceededInit = FALSE;

#define COUNTING 1

#if COUNTING
static DWORD pSpCheckHead = 0xaabbccdd;
static LONG pSpFailCount = 0;
static LONG pSpInitCount = 0;
static LONG pSpUninitCount = 0;
static LONG pSpConflictCount = 0;
static BOOL pSpDoneInit = FALSE;
static BOOL pSpFailedInit = FALSE;
static DWORD pSpCheckTail = 0xddccbbaa;
#endif

//
// At some point, a thread, process or module will call  pSetupInitializeUtils,
// and follow by a call to pSetupUninitializeUtils when done (cleanup)
//
// prior to this point, there's been no initialization other than static
// constants (above) pSetupInitializeUtils and pSetupUninitializeUtils must be
// mut-ex with each other and themselves
// thread A may call pSetupInitializeUtils while thread B is calling
// pSetupUninitializeUtils, the init in this case must succeed
// we can't use a single mutex or event object, since it must be cleaned up
// when pSetupUninitializeUtils succeeds
// we can't use a simple user-mode spin-lock, since priorities may be different,
// and it's just plain ugly using Sleep(0)
// so we have the _AcquireInitMutex and _ReleaseInitMutex implementations below
// it's guarenteed that when _AcquireInitMutex returns, it is not using any
// resources to hold the lock
// it will hold an event object if the thread is blocked, per blocked thread.
// This is ok since the number of blocked threads at any time will be few.
//
// It works as follows:
//
// a linked list of requests is maintained, with head at pWaitHead
// The head is interlocked, and when an item is inserted at pWaitHead
// it's entries must be valid, and can no longer be touched until
// the mutex is acquired.
//
// if the request is the very first, it need not block, will not block,
// as (at worst) the other thread has just removed it's request from the head
// and is about to return. The thread that inserts the first request into the
// list automatically owns the mutex.
//
// if the request is anything but the first, it will have an event object
// that will eventually be signalled, and at that point owns the mutex.
//
// the Thread that owns the mutex may modify anything on the wait-list,
// including pWaitHead.
//
// If the thread that owns the mutex is pWaitHead at the point it's releasing
// mutex, it does not need to signal anyone. This is protected by
// InterlockedCompareExchangePointer. If it finds itself in this state, the next
// pSetupInitializeUtils will automatically obtain the mutex, also protected
// by InterlockedCompareExchangePointer.
//
// If there are waiting entries in the list, then the tail-most waiting entry is
// signalled, at which point the related thread now owns the mutex.
//

#ifdef UNICODE

typedef struct _LinkWaitList {
    HANDLE hEvent; // for this item
    struct _LinkWaitList *pNext; // from Head to Tail
    struct _LinkWaitList *pPrev; // from Tail to Head
} LinkWaitList;

static LinkWaitList * pWaitHead = NULL;      // insert new wait items here

static
BOOL
_AcquireInitMutex(
    OUT LinkWaitList *pEntry
    )
/*++

Routine Description:

    Atomically acquire process mutex
    with no pre-requisite initialization other than
    static globals.
    Each blocked call will require an event to be created.

    Requests cannot be nested per thread (deadlock will occur)

Arguments:

    pEntry - structure to hold mutex information. This structure
                must persist until call to _ReleaseInitMutex.

    Global:pWaitHead - atomic linked list of mutex requests

Return Value:

    TRUE if mutex acquired.
    FALSE on failure (no resources)

--*/
{
    LinkWaitList *pTop;
    DWORD res;
    pEntry->pPrev = NULL;
    pEntry->pNext = NULL;
    pEntry->hEvent = NULL;
    //
    // fast lock, this will only succeed if we're the first and we have no reason to wait
    // this saves us needlessly creating an event
    //
    if(!InterlockedCompareExchangePointer(&pWaitHead,pEntry,NULL)) {
        return TRUE;
    }

#if COUNTING
    InterlockedIncrement(&pSpConflictCount);
#endif
    //
    // someone has (or, at least a moment ago, had) the lock, so we need an event
    //
    pEntry->hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if(!pEntry->hEvent) {
        return FALSE;
    }
    //
    // once pEntry is added to list, it cannot be touched until
    // WaitSingleObject is satisfied (unless we were the first)
    // if pWaitHead changes in the middle of the loop, we'll repeat again
    //
    do {
        pTop = pWaitHead;
        pEntry->pNext = pTop;
    } while (pTop != InterlockedCompareExchangePointer(&pWaitHead,pEntry,pTop));
    if(pTop) {
        //
        // we're not the first on the list
        // the owner of pTop will signal our event, wait for it.
        //
        res = WaitForSingleObject(pEntry->hEvent,INFINITE);
        pEntry->hEvent = NULL;
    }
    //
    // don't need event any more, the fact we've been signalled indicates we've now got the lock
    //
    CloseHandle(pEntry->hEvent);
    if(res != WAIT_OBJECT_0) {
        MYASSERT(res == WAIT_OBJECT_0);
        return FALSE;
    }
    return TRUE;
}

static
VOID
_ReleaseInitMutex(
    IN LinkWaitList *pEntry
    )
/*++

Routine Description:

    release process mutex previously acquired by _AcquireInitMutex
    thread must own the mutex
    no resources required for this action.
    This call may only be done once for each _AcquireInitMutex

Arguments:

    pEntry - holding mutex information. This structure
                must have been initialized by _AcquireInitMutex.

    Global:pWaitHead - atomic linked list of mutex requests

Return Value:

    none.

--*/
{
    LinkWaitList *pHead;
    LinkWaitList *pWalk;
    LinkWaitList *pPrev;

    MYASSERT(!pEntry->pNext);
    pHead = InterlockedCompareExchangePointer(&pWaitHead,NULL,pEntry);
    if(pHead == pEntry) {
        //
        // we were at head of list as well as at tail of list
        // list has now been reset to NULL
        // and may even already contain an entry due to a pLock call
        return;
    }
    if(!pEntry->pPrev) {
        //
        // we need to walk down list from pHead to pEntry
        // at the same time, remember back links
        // so we don't need to do this every time
        // note, we will never get here if pHead==pEntry
        //
        MYASSERT(pHead);
        MYASSERT(!pHead->pPrev);
        for(pWalk = pHead;pWalk != pEntry;pWalk = pWalk->pNext) {
            MYASSERT(pWalk->pNext);
            MYASSERT(!pWalk->pNext->pPrev);
            pWalk->pNext->pPrev = pWalk;
        }
    }
    pPrev = pEntry->pPrev;
    pPrev->pNext = NULL; // aids debugging, even in free build.
    SetEvent(pPrev->hEvent);
    return;
}

#else
//
// ANSI functions *MUST* work on Win95
// to support install of Whistler
// InterlockedCompareExchange(Pointer)
// is not supported
// so we'll use something simple/functional instead
// that uses the supported InterlockedExchange
//
static LONG SimpleCritSec = FALSE;
typedef PVOID LinkWaitList;

static
BOOL
_AcquireInitMutex(
    OUT LinkWaitList *pEntry
    )
{
    while(InterlockedExchange(&SimpleCritSec,TRUE) == TRUE) {
        //
        // release our timeslice
        // we should rarely be spinning here
        // starvation can occur in some circumstances
        // if initializing threads are of different priorities
        //
        Sleep(0);
    }
    return TRUE;
}

static
VOID
_ReleaseInitMutex(
    IN LinkWaitList *pEntry
    )
{
    if(InterlockedExchange(&SimpleCritSec,FALSE) == FALSE) {
        MYASSERT(0 && SimpleCritSec);
    }
}

#endif

BOOL
pSetupInitializeUtils(
    VOID
    )
/*++

Routine Description:

    Initialize this library
    balance each successful call to this function with
    equal number of calls to pSetupUninitializeUtils

Arguments:

    none

Return Value:

    TRUE if init succeeded, FALSE otherwise

--*/
{
    LinkWaitList Lock;

    if(!_AcquireInitMutex(&Lock)) {
#if COUNTING
        InterlockedIncrement(&pSpFailCount);
#endif
        return FALSE;
    }
#if COUNTING
    InterlockedIncrement(&pSpInitCount);
#endif
    RefCount++;
    if(RefCount==1) {
        pSpDoneInit = TRUE;
        SucceededInit = _pSpUtilsMemoryInitialize();
        if(!SucceededInit) {
            pSpFailedInit = TRUE;
            _pSpUtilsMemoryUninitialize();
        }
    }
    _ReleaseInitMutex(&Lock);
    return SucceededInit;
}

BOOL
pSetupUninitializeUtils(
    VOID
    )
/*++

Routine Description:

    Uninitialize this library
    This should be called for each successful call to
    pSetupInitializeUtils

Arguments:

    none

Return Value:

    TRUE if cleanup succeeded, FALSE otherwise

--*/
{
    LinkWaitList Lock;
#if COUNTING
    InterlockedIncrement(&pSpUninitCount);
#endif
    if(!SucceededInit) {
        return FALSE;
    }
    if(!_AcquireInitMutex(&Lock)) {
        return FALSE;
    }
    RefCount--;
    if(RefCount == 0) {
        _pSpUtilsMemoryUninitialize();
        SucceededInit = FALSE;
    }
    _ReleaseInitMutex(&Lock);
    return TRUE;
}

VOID
_pSpUtilsAssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    LPSTR Msg;
    DWORD msglen;
    DWORD sz;

    //
    // obtain module name
    //
    sz = GetModuleFileNameA(NULL,Name,MAX_PATH);
    if((sz == 0) || (sz > MAX_PATH)) {
        strcpy(Name,"?");
    }
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }
    msglen = strlen(p)+strlen(FileName)+strlen(Condition)+128;
    //
    // assert might be out of memory condition
    // stack alloc is more likely to succeed than memory alloc
    //
    try {
        Msg = (LPSTR)_alloca(msglen);
        wsprintfA(
            Msg,
            "SPUTILS: Assertion failure at line %u in file %s!%s: %s\r\n",
            LineNumber,
            p,
            FileName,
            Condition
            );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Msg = "SpUTILS ASSERT!!!! (out of stack)\r\n";
    }

    OutputDebugStringA(Msg);
    DebugBreak();
}

VOID
pSetupDebugPrintEx(
    DWORD Level,
    PCTSTR format,
    ...                                 OPTIONAL
    )

/*++

Routine Description:

    Send a formatted string to the debugger.
    Note that this is expected to work cross-platform, but use preferred debugger

Arguments:

    format - standard printf format string.

Return Value:

    NONE.

--*/

{
    TCHAR buf[1026];    // bigger than max size
    va_list arglist;

    if (!fInitDebug) {
        pfnDbgPrintEx = (PFNDbgPrintEx)GetProcAddress(GetModuleHandle(TEXT("NTDLL")), "DbgPrintEx");
        fInitDebug = TRUE;
    }

    va_start(arglist, format);
    wvsprintf(buf, format, arglist);

    if (pfnDbgPrintEx) {
#ifdef UNICODE
        (*pfnDbgPrintEx)(DPFLTR_SETUP_ID, Level, "%ls",buf);
#else
        (*pfnDbgPrintEx)(DPFLTR_SETUP_ID, Level, "%s",buf);
#endif
    } else {
        OutputDebugString(buf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\sources.inc ===
MAJORCOMP=setup

TARGETPATH=obj
TARGETTYPE=LIBRARY

!include $(PROJECT_ROOT)\prerelease.inc

!if $(PRERELEASE)
C_DEFINES=$(C_DEFINES) -DMEM_DBG=1 -DASSERTS_ON=1
# C_DEFINES=$(C_DEFINES) -DMEM_DBG=1
!endif

USE_NOLIBS=1

INCLUDES=\
    ..;                  \
    $(ADMIN_INC_PATH);   \
    $(WINDOWS_INC_PATH)

C_DEFINES=$(C_DEFINES)

SOURCES=\
    ..\fileutil.c  \
    ..\memory.c    \
    ..\miscutil.c  \
    ..\registry.c  \
    ..\security.c  \
    ..\sputils.c   \
    ..\strtab.c

# PRECOMPILED_INCLUDE=precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\extended\precomp.h ===
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\unicode\precomp.h ===
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\unicode\precomp.h ===
#include "setupntp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\strtab.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    strtab.c

Abstract:

    String table functions for Windows NT Setup API dll

    A string table is a block of memory that contains a bunch of strings.
    Hashing is used, and each hash table entry points to a linked list
    of strings within the string table. Strings within each linked list
    are sorted in ascending order. A node in the linked list consists of
    a pointer to the next node, followed by the string itself. Nodes
    are manually aligned to start on DWORD boundaries so we don't have to
    resort to using unaligned pointers.

Author:

    Ted Miller (tedm) Jan-11-1995

Revision History:

    Jamie Hunter (JamieHun) Jan-15-1997 fixed minor bug regarding use of STRTAB_NEW_EXTRADATA
    Jamie Hunter (JamieHun) Feb-8-2000  improved string table growth algorithm
    Jamie Hunter (JamieHun) Jun-27-2000 moved to sputils static library

--*/

#include "precomp.h"
#pragma hdrstop


//
// Values used for the initial and growth size
// of the string table data area
//
// We start out with 6K, but remember that this includes the hash buckets.
// After you subtract their part of the buffer, you're left with ~4K bytes.
// STRING_TABLE_NEW_SIZE_ADJUST - determines approximate increase
// STRING_TABLE_NEW_SIZE - will increase oldsize by at least STRING_TABLE_GROWTH_SIZE
// and a multiple of STRING_TABLE_GROWTH_SIZE
// if string table gets very big, we limit growth to STRING_TABLE_GROWTH_CAP bytes.
//
#define STRING_TABLE_INITIAL_SIZE   6144
#define STRING_TABLE_GROWTH_SIZE    2048
#define STRING_TABLE_GROWTH_CAP     0x100000
#define STRING_TABLE_NEW_SIZE_ADJUST(oldsize) ((oldsize)/3*2)
#define STRING_TABLE_NEW_SIZE(oldsize) \
            (oldsize+min((((DWORD)(STRING_TABLE_NEW_SIZE_ADJUST(oldsize)/STRING_TABLE_GROWTH_SIZE)+1)*STRING_TABLE_GROWTH_SIZE),STRING_TABLE_GROWTH_CAP))


//
// WARNING:
//
// Don't change this structure, various file formats depend upon it
//
#include "pshpack1.h"

#ifdef SPUTILSW
//
// name mangling so the names don't conflict with any in sputilsa.lib
//
#define _STRING_NODE                     _STRING_NODE_W
#define STRING_NODE                      STRING_NODE_W
#define PSTRING_NODE                     PSTRING_NODE_W
#define _STRING_TABLE                    _STRING_TABLE_W
#define STRING_TABLE                     STRING_TABLE_W
#define PSTRING_TABLE                    PSTRING_TABLE_W
#endif // SPUTILSW

typedef struct _STRING_NODE {
    //
    // This is stored as an offset instead of a pointer
    // because the table can move as it's built
    // The offset is from the beginning of the table
    //
    LONG NextOffset;
    //
    // This field must be last
    //
    TCHAR String[ANYSIZE_ARRAY];
} STRING_NODE, *PSTRING_NODE;

#include "poppack.h"

//
// in-memory details about the string table
//
typedef struct _STRING_TABLE {
    PUCHAR Data;    // First HASH_BUCKET_COUNT DWORDS are StringNodeOffset array.
    DWORD DataSize;
    DWORD BufferSize;
    MYLOCK Lock;
    UINT ExtraDataSize;
    LCID Locale;
} STRING_TABLE, *PSTRING_TABLE;

#define LockTable(table)    BeginSynchronizedAccess(&((table)->Lock))
#define UnlockTable(table)  EndSynchronizedAccess(&((table)->Lock))


#ifdef UNICODE

#define FixedCompareString      CompareString

#else

#include <locale.h>
#include <mbctype.h>

static
INT
FixedCompareString (
    IN      LCID Locale,
    IN      DWORD Flags,
    IN      PCSTR FirstString,
    IN      INT Count1,
    IN      PCSTR SecondString,
    IN      INT Count2
    )
{
    LCID OldLocale;
    INT Result = 0;

    //
    // This routine uses the C runtime to compare the strings, because
    // the Win32 APIs are broken on some versions of Win95
    //

    OldLocale = GetThreadLocale();

    if (OldLocale != Locale) {
        SetThreadLocale (Locale);
        setlocale(LC_ALL,"");
    }

    __try {
        if (Count1 == -1) {
            Count1 = strlen (FirstString);
        }

        if (Count2 == -1) {
            Count2 = strlen (SecondString);
        }

        //
        // The C runtime compares strings differently than the CompareString
        // API.  Most importantly, the C runtime considers uppercase to be
        // less than lowercase; the CompareString API is the opposite.
        //

        if (Flags & NORM_IGNORECASE) {
            Result = _mbsnbicmp (FirstString, SecondString, min (Count1, Count2));
        } else {
            Result = _mbsnbcmp (FirstString, SecondString, min (Count1, Count2));
        }

        //
        // We now convert the C runtime result into the CompareString result.
        // This means making the comparison a Z to A ordering, with lowercase
        // coming before uppercase. The length comparison does not get reversed.
        //

        if(Result == _NLSCMPERROR) {

            Result = 0;                         // zero returned if _mbsnbicmp could not compare

        } else if (Result < 0) {

            Result = CSTR_GREATER_THAN;

        } else if (Result == 0) {

            if (Count1 < Count2) {
                Result = CSTR_LESS_THAN;         // first string shorter than second
            } else if (Count1 > Count2) {
                Result = CSTR_GREATER_THAN;      // first string longer than second
            } else {
                Result = CSTR_EQUAL;
            }

        } else {
            Result = CSTR_LESS_THAN;
        }
    }
    __except (TRUE) {
        Result = 0;
    }

    if (OldLocale != Locale) {
        SetThreadLocale (OldLocale);
        setlocale(LC_ALL,"");
    }

    return Result;
}

#endif

static
DWORD
_StringTableCheckFlags(
    IN DWORD FlagsIn
    )
/*++

Routine Description:

    Pre-process flags, called by exported routines we want to handle the
    combination of CASE_INSENSITIVE, CASE_SENSITIVE and BUFFER_WRITEABLE
    and keep all other flags as is.

Arguments:

    FlagsIn - flags as supplied

Return Value:

    Flags out

--*/

{
    DWORD FlagsOut;
    DWORD FlagsSpecial;

    //
    // we're just interested in these flags for the switch
    //
    FlagsSpecial = FlagsIn & (STRTAB_CASE_SENSITIVE | STRTAB_BUFFER_WRITEABLE);

    //
    // strip these off FlagsIn to create initial FlagsOut
    //
    FlagsOut = FlagsIn ^ FlagsSpecial;

    switch (FlagsSpecial) {

    case STRTAB_CASE_INSENSITIVE :
    case STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE :
        //
        // these cases ok
        //
        FlagsOut |= FlagsSpecial;
        break;

    default :
        //
        // any other combination is treated as STRTAB_CASE_SENSITIVE (and so
        // WRITEABLE doesn't matter)
        //
        FlagsOut |= STRTAB_CASE_SENSITIVE;
    }

    return FlagsOut;
}

static
VOID
_ComputeHashValue(
    IN  PTSTR  String,
    OUT PDWORD StringLength,
    IN  DWORD  Flags,
    OUT PDWORD HashValue
    )

/*++

Routine Description:

    Compute a hash value for a given string.

    The algorithm simply adds up the unicode values for each
    character in the string and then takes the result mod the
    number of hash buckets.

Arguments:

    String - supplies the string for which a hash value is desired.

    StringLength - receives the number of characters in the string,
        not including the terminating nul.

    Flags - supplies flags controlling how the hashing is to be done.  May be
        a combination of the following values (all other bits ignored):

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    HashValue - receives the hash value.

Return Value:

    None.

--*/

{
    DWORD Length;
    DWORD Value = 0;
    PCTSTR p, q;
    DWORD Char;

    try {

        if((Flags & (STRTAB_BUFFER_WRITEABLE | STRTAB_ALREADY_LOWERCASE)) == STRTAB_BUFFER_WRITEABLE) {
            //
            // Then the buffer is writeable, but isn't yet lower-case.  Take care of that right now.
            //

#ifndef UNICODE
            _mbslwr (String);
#else
            CharLower(String);
#endif

            Flags |= STRTAB_ALREADY_LOWERCASE;
        }

//
// Define a macro to ensure we don't get sign-extension when adding up character values.
//
#ifdef UNICODE
    #define DWORD_FROM_TCHAR(x)   ((DWORD)((WCHAR)(x)))
#else
    #define DWORD_FROM_TCHAR(x)   ((DWORD)((UCHAR)(x)))
#endif

        p = String;

        if(Flags & STRTAB_ALREADY_LOWERCASE) {

            while (*p) {
                Value += DWORD_FROM_TCHAR (*p);
                p++;
            }

        } else {
            //
            // Make sure we don't get sign-extension on extended chars
            // in String -- otherwise we get values like 0xffffffe4 passed
            // to CharLower(), which thinks it's a pointer and faults.
            //

#ifdef UNICODE
            //
            // The WCHAR case is trivial
            //

            while (*p) {
                Value += DWORD_FROM_TCHAR(CharLower((PWSTR)(WORD) (*p)));
                p++;
            }

#else
            //
            // The DBCS case is a mess because of the possibility of CharLower
            // altering a two-byte character
            // Standardize to use _mbslwr as that is used elsewhere
            // ie, if we did _mbslwr, & called this function with
            // flag set to say "already lower", vs we called function
            // with buffer writable, vs calling with neither
            // we should ensure we get same hash in each case
            // it may fail, but at least it will fail *universally* and
            // generate the same hash
            //
            PTSTR copy = pSetupDuplicateString(String);
            if(copy) {
                //
                // do conversion on copied string
                //
                _mbslwr(copy);
                p = copy;
                while (*p) {
                    Value += DWORD_FROM_TCHAR (*p);
                    p++;
                }
                pSetupFree(copy);
                p = String+lstrlen(String);
            } else {
                //
                // we had a memory failure
                //
                *HashValue = 0;
                *StringLength = 0;
                leave;
            }
#endif

        }

        *HashValue = Value % HASH_BUCKET_COUNT;
        *StringLength = (DWORD)(p - String);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Inbound string was bogus
        //

        *HashValue = 0;
        *StringLength = 0;
        MYASSERT(FALSE);
    }
}


BOOL
_pSpUtilsStringTableLock(
    IN PVOID StringTable
    )

/*++

Routine Description:

    This routine acquires the lock for the specified string table (it's
    implemented as a function call for uses in setupapi where locking needs to
    be explicitly controlled).

Arguments:

    StringTable - supplies handle to string table to be locked.

Return Value:

    If the lock was successfully acquired, the return value is TRUE.
    Otherwise, the return value is FALSE.

--*/

{
    return LockTable((PSTRING_TABLE)StringTable);
}


VOID
_pSpUtilsStringTableUnlock(
    IN PVOID StringTable
    )

/*++

Routine Description:

    This routine releases the lock (previously acquired via
    _pSpUtilsStringTableLock) for the specified string table.

Arguments:

    StringTable - supplies handle to string table to be unlocked.

Return Value:

    None.

--*/

{
    UnlockTable((PSTRING_TABLE)StringTable);
}


LONG
_pSpUtilsStringTableLookUpString(
    IN     PVOID   StringTable,
    IN OUT PTSTR   String,
    OUT    PDWORD  StringLength,
    OUT    PDWORD  HashValue,           OPTIONAL
    OUT    PVOID  *FindContext,         OPTIONAL
    IN     DWORD   Flags,
    OUT    PVOID   ExtraData,           OPTIONAL
    IN     UINT    ExtraDataBufferSize  OPTIONAL
    )

/*++

Routine Description:

    Locates a string in the string table, if present.
    If the string is not present, this routine may optionally tell its
    caller where the search stopped. This is useful for maintaining a
    sorted order for the strings.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be looked up

    StringLength - receives number of characters in the string, not
        including the terminating nul.

    HashValue - Optionally, receives hash value for the string.

    FindContext - Optionally, receives the context at which the search was
        terminated.

        (NOTE: This is actually a PSTRING_NODE pointer, that is used
        during new string addition.  Since this routine has wider exposure
        than just internal string table usage, this parameter is made into
        a PVOID, so no one else has to have access to string table-internal
        structures.

        On return, this variable receives a pointer to the string node of
        the node where the search stopped. If the string was found, then
        this is a pointer to the string's node. If the string was not found,
        then this is a pointer to the last string node whose string is
        'less' (based on lstrcmpi) than the string we're looking for.
        Note that this value may be NULL.)

    Flags - supplies flags controlling how the string is to be located.  May be
        a combination of the following values:

        STRTAB_CASE_INSENSITIVE  - Search for the string case-insensitively.

        STRTAB_CASE_SENSITIVE    - Search for the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if specified, receives extra data associated with the string
        if the string is found.

    ExtraDataBufferSize - if ExtraData is specified, then this parameter
        specifies the size of the buffer, in bytes. As much extra data as will fit
        is stored here.

Return Value:

    The return value is a value that uniquely identifies the string
    within the string table, namely the offset of the string node
    within the string table.

    If the string could not be found the value is -1.

--*/

{
    PSTRING_NODE node,prev;
    int i;
    PSTRING_TABLE stringTable = StringTable;
    DWORD hashValue;
    PSTRING_NODE FinalNode;
    LONG rc = -1;
    LCID Locale;
    DWORD CompareFlags;
    BOOL CollateEnded = FALSE;

    //
    // If this is a case-sensitive lookup, then we want to reset the STRTAB_BUFFER_WRITEABLE
    // flag, if present, since otherwise the string will get replaced with its all-lowercase
    // counterpart.
    //
    if(Flags & STRTAB_CASE_SENSITIVE) {
        Flags &= ~STRTAB_BUFFER_WRITEABLE;
    }

    //
    // Compute hash value
    //
    _ComputeHashValue(String,StringLength,Flags,&hashValue);

    if(((PLONG)(stringTable->Data))[hashValue] == -1) {
        //
        // The string table contains no strings at the computed hash value.
        //
        FinalNode = NULL;
        goto clean0;
    }

    //
    // We know there's at least one string in the table with the computed
    // hash value, so go find it. There's no previous node yet.
    //
    node = (PSTRING_NODE)(stringTable->Data + ((PLONG)(stringTable->Data))[hashValue]);
    prev = NULL;

    //
    // Go looking through the string nodes for that hash value,
    // looking through the string.
    //
    Locale = stringTable->Locale;

    CompareFlags = (Flags & STRTAB_CASE_SENSITIVE) ? 0 : NORM_IGNORECASE;

    while(1) {

        if(i = FixedCompareString(Locale,CompareFlags,String,-1,node->String,-1)) {
            i -= 2;
        } else {
            //
            // Failure, try system default locale
            //
            if(i = FixedCompareString(LOCALE_SYSTEM_DEFAULT,CompareFlags,String,-1,node->String,-1)) {
                i -= 2;
            } else {
                //
                // Failure, just use CRTs
                //
                // This could give wrong collation?? If it does, we're stuck with it now.
                //
                i = (Flags & STRTAB_CASE_SENSITIVE)
                  ? _tcscmp(String,node->String)
                  : _tcsicmp(String,node->String);
            }
        }

        if(i == 0) {
            FinalNode = node;
            rc = (LONG)((PUCHAR)node - stringTable->Data);
            break;
        }

        //
        // If the string we are looking for is 'less' than the current
        // string, mark it's position so we can insert a new string before here
        // (ANSI) but keep searching (UNICODE) we can abort - old behaviour
        //
        if((i < 0) && !CollateEnded) {
            CollateEnded = TRUE;
            FinalNode = prev;
#if UNICODE
            break;
#endif
        }

        //
        // The string we are looking for is 'greater' than the current string.
        // Keep looking, unless we've reached the end of the table.
        //
        if(node->NextOffset == -1) {
            if(!CollateEnded)
            {
                //
                // unless we found a more ideal position
                // return the end of the list
                //
                FinalNode = node;
            }
            break;
        } else {
            prev = node;
            node = (PSTRING_NODE)(stringTable->Data + node->NextOffset);
        }
    }

clean0:

    if((rc != -1) && ExtraData) {
        //
        // Extra data is stored immediately following the string.
        //
        CopyMemory(
            ExtraData,
            FinalNode->String + *StringLength + 1,
            min(ExtraDataBufferSize,stringTable->ExtraDataSize)
            );
    }

    if(HashValue) {
        *HashValue = hashValue;
    }
    if(FindContext) {
        *FindContext = FinalNode;
    }

    return rc;
}


LONG
pSetupStringTableLookUpString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags
    )

/*++

Routine Description:

    Locates a string in the string table, if present.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be looked up.  If STRTAB_BUFFER_WRITEABLE is
        specified and a case-insensitive lookup is requested, then this buffer
        will be all lower-case upon return.

    Flags - supplies flags controlling how the string is to be located.  May be
        a combination of the following values:

        STRTAB_CASE_INSENSITIVE  - Search for the string case-insensitively.

        STRTAB_CASE_SENSITIVE    - Search for the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

Return Value:

    The return value is a value that uniquely identifies the string
    within the string table.

    If the string could not be found the value is -1.

--*/

{
    DWORD StringLength, PrivateFlags, AlreadyLcFlag;
    LONG rc = -1;
    BOOL locked = FALSE;

    try {
        if (!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableLookUpString(
                                     StringTable,
                                     String,
                                     &StringLength,
                                     NULL,
                                     NULL,
                                     PrivateFlags,
                                     NULL,
                                     0
                                     );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return (rc);
}


LONG
pSetupStringTableLookUpStringEx(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
       OUT PVOID ExtraData,             OPTIONAL
    IN     UINT  ExtraDataBufferSize    OPTIONAL
    )

/*++

Routine Description:

    Locates a string in the string table, if present.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be looked up.  If STRTAB_BUFFER_WRITEABLE is
        specified and a case-insensitive lookup is requested, then this buffer
        will be all lower-case upon return.

    Flags - supplies flags controlling how the string is to be located.  May be
        a combination of the following values:

        STRTAB_CASE_INSENSITIVE  - Search for the string case-insensitively.

        STRTAB_CASE_SENSITIVE    - Search for the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string look-up.  Specifying this flag improves the
                                   performance of this API for case-insensitive string
                                   additions.  This flag is ignored for case-sensitive
                                   string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if specified, receives extra data associated with the string
        if the string is found.

    ExtraDataBufferSize - if ExtraData is specified, then this parameter
        specifies the size of the buffer, in bytes. As much extra data as will fit
        is stored here.

Return Value:

    The return value is a value that uniquely identifies the string
    within the string table.

    If the string could not be found the value is -1.

--*/

{
    DWORD StringLength, PrivateFlags, AlreadyLcFlag;
    LONG rc = -1;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableLookUpString(
                                     StringTable,
                                     String,
                                     &StringLength,
                                     NULL,
                                     NULL,
                                     PrivateFlags,
                                     ExtraData,
                                     ExtraDataBufferSize
                                     );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return (rc);
}


BOOL
pSetupStringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    )

/*++

Routine Description:

    Get arbitrary data associated with a string table entry.

Arguments:

    StringTable - supplies handle to string table containing the string
        whose associated data is to be returned.

    String - supplies the id of the string whose associated data is to be returned.

    ExtraData - receives the data associated with the string. Data is truncated
        to fit, if necessary.

    ExtraDataBufferSize - supplies the size in bytes of the buffer specified
        by ExtraData. If this value is smaller than the extra data size for
        the string table, data is truncated to fit.

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL b = FALSE;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        b = _pSpUtilsStringTableGetExtraData(StringTable,StringId,ExtraData,ExtraDataBufferSize);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return(b);
}


BOOL
_pSpUtilsStringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    )

/*++

Routine Description:

    Get arbitrary data associated with a string table entry.
    THIS ROUTINE DOES NOT DO LOCKING and IT DOES NOT HANDLE EXCEPTIONS!

Arguments:

    StringTable - supplies handle to string table containing the string
        whose associated data is to be returned.

    String - supplies the id of the string whose associated data is to be returned.

    ExtraData - receives the data associated with the string. Data is truncated
        to fit, if necessary.

    ExtraDataBufferSize - supplies the size in bytes of the buffer specified
        by ExtraData. If this value is smaller than the extra data size for
        the string table, data is truncated to fit.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PSTRING_TABLE stringTable = StringTable;
    PSTRING_NODE stringNode;
    PVOID p;

    stringNode = (PSTRING_NODE)(stringTable->Data + StringId);
    p = stringNode->String + lstrlen(stringNode->String) + 1;

    CopyMemory(ExtraData,p,min(ExtraDataBufferSize,stringTable->ExtraDataSize));

    return(TRUE);
}


BOOL
pSetupStringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    )

/*++

Routine Description:

    Associate arbitrary data with a string table entry.

Arguments:

    StringTable - supplies handle to string table containing the string
        with which the data is to be associated.

    String - supplies the id of the string with which the data is to be associated.

    ExtraData - supplies the data to be associated with the string.

    ExtraDataSize - specifies the size in bytes of the data. If the data is
        larger than the extra data size for this string table, then the routine fails.

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL b = FALSE;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        b = _pSpUtilsStringTableSetExtraData(StringTable,StringId,ExtraData,ExtraDataSize);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return(b);
}


BOOL
_pSpUtilsStringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    )

/*++

Routine Description:

    Associate arbitrary data with a string table entry.

Arguments:

    StringTable - supplies handle to string table containing the string
        with which the data is to be associated.

    String - supplies the id of the string with which the data is to be associated.

    ExtraData - supplies the data to be associated with the string.

    ExtraDataSize - specifies the size in bytes of the data. If the data is
        larger than the extra data size for this string table, then the routine fails.

Return Value:

    Boolean value indicating outcome.

--*/

{
    PSTRING_TABLE stringTable = StringTable;
    PSTRING_NODE stringNode;
    BOOL b;
    PVOID p;

    if(ExtraDataSize <= stringTable->ExtraDataSize) {

        stringNode = (PSTRING_NODE)(stringTable->Data + StringId);

        p = stringNode->String + lstrlen(stringNode->String) + 1;

        ZeroMemory(p,stringTable->ExtraDataSize);
        CopyMemory(p,ExtraData,ExtraDataSize);

        b = TRUE;

    } else {
        b = FALSE;
    }

    return(b);
}


LONG
_pSpUtilsStringTableAddString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
    IN     PVOID ExtraData,     OPTIONAL
    IN     UINT  ExtraDataSize  OPTIONAL
    )

/*++

Routine Description:

    Adds a string to the string table if the string is not already
    in the string table.  (Does not do locking!)

    If the string is to be added case-insensitively, then it is
    lower-cased, and added case-sensitively.  Since lower-case characters
    are 'less than' lower case ones (according to lstrcmp), this ensures that
    a case-insensitive string will always appear in front of any of its
    case-sensitive counterparts.  This ensures that we always find the correct
    string ID for things like section names.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be added

    Flags - supplies flags controlling how the string is to be added, and
        whether the caller-supplied buffer may be modified.  May be a combination
        of the following values:

        STRTAB_CASE_INSENSITIVE  - Add the string case-insensitively.  The
                                   specified string will be added to the string
                                   table as all lower-case.  This flag is overridden
                                   if STRTAB_CASE_SENSITIVE is specified.

        STRTAB_CASE_SENSITIVE    - Add the string case-sensitively.  This flag
                                   overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE  - The caller-supplied buffer may be written to during
                                   the string-addition process.  Specifying this flag
                                   improves the performance of this API for case-
                                   insensitive string additions.  This flag is ignored
                                   for case-sensitive string additions.

        STRTAB_NEW_EXTRADATA     - if the string already exists in the table
                                   and ExtraData is specified (see below) then
                                   the new ExtraData overwrites any existing extra data.
                                   Otherwise any existing extra data is left alone.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if supplied, specifies extra data to be associated with the string
        in the string table. If the string already exists in the table, the Flags
        field controls whether the new data overwrites existing data already
        associated with the string.

    ExtraDataSize - if ExtraData is supplied, then this value supplies the size
        in bytes of the buffer pointed to by ExtraData. If the data is larger than
        the extra data size for the string table, the routine fails.

Return Value:

    The return value uniquely identifes the string within the string table.
    It is -1 if the string was not in the string table but could not be added
    (out of memory).

--*/

{
    LONG rc;
    PSTRING_TABLE stringTable = StringTable;
    DWORD StringLength;
    DWORD HashValue;
    PSTRING_NODE PreviousNode,NewNode;
    DWORD SpaceRequired;
    PTSTR TempString = String;
    BOOL FreeTempString = FALSE;
    PVOID p;
    DWORD sz;

    if (!(Flags & STRTAB_CASE_SENSITIVE)) {
        //
        // not case sensitive ( = insensitive)
        //
        if (!(Flags & STRTAB_ALREADY_LOWERCASE)) {
            //
            // not already lowercase
            //
            if (!(Flags & STRTAB_BUFFER_WRITEABLE)) {
                //
                // not writable
                //
                //
                // Then the string is to be added case-insensitively, but the caller
                // doesn't want us to write to their buffer.  Allocate one of our own.
                //
                if (TempString = pSetupDuplicateString(String)) {
                    FreeTempString = TRUE;
                } else {
                    //
                    // We couldn't allocate space for our duplicated string.  Since we'll
                    // only consider exact matches (where the strings are all lower-case),
                    // we're stuck, since we can't lower-case the buffer in place.
                    //
                    return -1;
                }
            }
            //
            // Lower-case the buffer.
            //
#ifndef UNICODE
            _mbslwr (TempString);
#else
            CharLower(TempString);
#endif
        }

        //
        // we know that the string is now lower-case
        // we no longer need "Writable" flag
        // searches will be case sensitive
        //
        Flags &= ~ (STRTAB_BUFFER_WRITEABLE | STRTAB_CASE_INSENSITIVE);
        Flags |= STRTAB_CASE_SENSITIVE | STRTAB_ALREADY_LOWERCASE;
    }

    try {
        if (ExtraData && (ExtraDataSize > stringTable->ExtraDataSize)) {
            //
            // Force us into the exception handler -- sort of a non-local goto.
            //
            RaiseException(0,0,0,NULL);
        }

        //
        // The string might already be in there.
        //
        rc = _pSpUtilsStringTableLookUpString(
                                     StringTable,
                                     TempString,
                                     &StringLength,
                                     &HashValue,
                                     &PreviousNode,
                                     Flags,
                                     NULL,
                                     0
                                     );

        if (rc != -1) {
            if (ExtraData && (Flags & STRTAB_NEW_EXTRADATA)) {
                //
                // Overwrite extra data. We know the data is small enough to fit
                // because we checked for this above.
                //
                p = PreviousNode->String + StringLength + 1;

                ZeroMemory(p,stringTable->ExtraDataSize);
                CopyMemory(p,ExtraData,ExtraDataSize);
            }

            if (FreeTempString) {
                pSetupFree(TempString);
            }
            return (rc);
        }

        //
        // Figure out how much space is required to hold this entry.
        // This is the size of a STRING_NODE plus the length of the string
        // plus space for extra per-element data.
        //
        SpaceRequired = offsetof(STRING_NODE,String)
                        + ((StringLength+1)*sizeof(TCHAR))
                        + stringTable->ExtraDataSize;

        //
        // Make sure things stay aligned within the table
        //
        if (SpaceRequired % sizeof(DWORD)) {
            SpaceRequired += sizeof(DWORD) - (SpaceRequired % sizeof(DWORD));
        }

        while(stringTable->DataSize + SpaceRequired > stringTable->BufferSize) {
            //
            // Grow the string table.
            // do this exponentially so that tables with a lot of items
            // added won't cause lots of reallocs
            //
            sz = STRING_TABLE_NEW_SIZE(stringTable->BufferSize);
            if (sz < stringTable->BufferSize) {
                sz = stringTable->DataSize + SpaceRequired;
            }
            p = pSetupReallocWithTag(stringTable->Data,sz,MEMTAG_STRINGDATA);
            if (!p) {
                //
                // we've run out of room, this could be because we asked
                // for too big of a re-alloc
                // if we're in this state, we're probably going to
                // have problems later anyway, but for now, let's
                // try and proceed with exactly what we need
                //
                sz = stringTable->DataSize + SpaceRequired;
                p = pSetupReallocWithTag(stringTable->Data,sz,MEMTAG_STRINGDATA);
                if (!p) {
                    //
                    // nope, this didn't help
                    //
                    if (FreeTempString) {
                        pSetupFree(TempString);
                    }
                    return (-1);
                }
            }
            //
            // Adjust previous node pointer.
            //
            if (PreviousNode) {
                PreviousNode = (PSTRING_NODE)((PUCHAR)p + ((PUCHAR)PreviousNode-(PUCHAR)stringTable->Data));
            }
            stringTable->Data = p;
            stringTable->BufferSize = sz;
        }
        //
        // Stick the string and extra data, if any, in the string table buffer.
        //
        NewNode = (PSTRING_NODE)(stringTable->Data + stringTable->DataSize);

        if (PreviousNode) {
            NewNode->NextOffset = PreviousNode->NextOffset;
            PreviousNode->NextOffset = (LONG)((LONG_PTR)NewNode - (LONG_PTR)stringTable->Data);
        } else {
            NewNode->NextOffset = ((PLONG)(stringTable->Data))[HashValue];
            ((PLONG)(stringTable->Data))[HashValue] = (LONG)((LONG_PTR)NewNode - (LONG_PTR)stringTable->Data);
        }

        lstrcpy(NewNode->String,TempString);

        p = NewNode->String + StringLength + 1;

        ZeroMemory(p,stringTable->ExtraDataSize);
        if (ExtraData) {
            CopyMemory(p,ExtraData,ExtraDataSize);
        }

        stringTable->DataSize += SpaceRequired;

        rc = (LONG)((LONG_PTR)NewNode - (LONG_PTR)stringTable->Data);

    }except(EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }

    if (FreeTempString) {
        pSetupFree(TempString);
    }

    return rc;
}


LONG
pSetupStringTableAddString(
    IN PVOID StringTable,
    IN PTSTR String,
    IN DWORD Flags
    )

/*++

Routine Description:

    Adds a string to the string table if the string is not already
    in the string table.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be added

    Flags - supplies flags controlling how the string is to be added, and
        whether the caller-supplied buffer may be modified.  May be a combination
        of the following values:

        STRTAB_CASE_INSENSITIVE - Add the string case-insensitively.  The
                                  specified string will be added to the string
                                  table as all lower-case.  This flag is overridden
                                  if STRTAB_CASE_SENSITIVE is specified.

        STRTAB_CASE_SENSITIVE   - Add the string case-sensitively.  This flag
                                  overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE - The caller-supplied buffer may be written to during
                                  the string-addition process.  Specifying this flag
                                  improves the performance of this API for case-
                                  insensitive string additions.  This flag is ignored
                                  for case-sensitive string additions.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

Return Value:

    The return value uniquely identifes the string within the string table.
    It is -1 if the string was not in the string table but could not be added
    (out of memory).

--*/

{
    LONG rc = -1;
    BOOL locked = FALSE;
    DWORD PrivateFlags;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableAddString(StringTable, String, PrivateFlags, NULL, 0);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return(rc);
}


LONG
pSetupStringTableAddStringEx(
    IN PVOID StringTable,
    IN PTSTR String,
    IN DWORD Flags,
    IN PVOID ExtraData,     OPTIONAL
    IN UINT  ExtraDataSize  OPTIONAL
    )

/*++

Routine Description:

    Adds a string to the string table if the string is not already
    in the string table.

Arguments:

    StringTable - supplies handle to string table to be searched
        for the string

    String - supplies the string to be added

    Flags - supplies flags controlling how the string is to be added, and
        whether the caller-supplied buffer may be modified.  May be a combination
        of the following values:

        STRTAB_CASE_INSENSITIVE - Add the string case-insensitively.  The
                                  specified string will be added to the string
                                  table as all lower-case.  This flag is overridden
                                  if STRTAB_CASE_SENSITIVE is specified.

        STRTAB_CASE_SENSITIVE   - Add the string case-sensitively.  This flag
                                  overrides the STRTAB_CASE_INSENSITIVE flag.

        STRTAB_BUFFER_WRITEABLE - The caller-supplied buffer may be written to during
                                  the string-addition process.  Specifying this flag
                                  improves the performance of this API for case-
                                  insensitive string additions.  This flag is ignored
                                  for case-sensitive string additions.

        STRTAB_NEW_EXTRADATA    - If the string already exists in the table
                                  and ExtraData is specified (see below) then
                                  the new ExtraData overwrites any existing extra data.
                                  Otherwise any existing extra data is left alone.

        In addition to the above public flags, the following private flag is also
        allowed:

        STRTAB_ALREADY_LOWERCASE - The supplied string has already been converted to
                                   all lower-case (e.g., by calling CharLower), and
                                   therefore doesn't need to be lower-cased in the
                                   hashing routine.  If this flag is supplied, then
                                   STRTAB_BUFFER_WRITEABLE is ignored, since modifying
                                   the caller's buffer is not required.

    ExtraData - if supplied, specifies extra data to be associated with the string
        in the string table. If the string already exists in the table, the Flags
        field controls whether the new data overwrites existing data already
        associated with the string.

    ExtraDataSize - if ExtraData is supplied, then this value supplies the size
        in bytes of the buffer pointed to by ExtraData. If the data is larger than
        the extra data size for the string table, the routine fails.

Return Value:

    The return value uniquely identifes the string within the string table.
    It is -1 if the string was not in the string table but could not be added
    (out of memory).

--*/

{
    LONG rc = -1;
    BOOL locked = FALSE;
    DWORD PrivateFlags;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        PrivateFlags = _StringTableCheckFlags(Flags);

        rc = _pSpUtilsStringTableAddString(StringTable, String, PrivateFlags, ExtraData, ExtraDataSize);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        rc = -1;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }
    return (rc);
}


BOOL
pSetupStringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    )

/*++

Routine Description:

    For every string in a string table, inform a callback routine of
    the stirng's id, it's value, and any associated data.

Arguments:

    StringTable - supplies a pointer to the string table to be enumerated.

    ExtraDataBuffer - supplies the address of a buffer to be passed to
        the callback routine for each string, which will be filled in
        with the associated data of each string.

    ExtraDataBufferSize - if ExtraDataBuffer is specified then this
        supplies the size of that buffer in bytes. If this value is
        smaller than the size of the extra data for the string table,
        the enumeration fails.

    Callback - supplies the routine to be notified of each string.

    lParam - supplies an optional parameter meaningful to the caller
        which is passed on to the callback unchanged.

Return Value:

    Boolean value indicating outcome. TRUE unless ExtraDataBufferSize
    is too small.

--*/

{
    BOOL b = FALSE;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        b = _pSpUtilsStringTableEnum(StringTable,ExtraDataBuffer,ExtraDataBufferSize,Callback,lParam);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    return(b);
}


BOOL
_pSpUtilsStringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    )

/*++

Routine Description:

    For every string in a string table, inform a callback routine of
    the stirng's id, its value, and any associated data.

    THIS ROUTINE DOES NOT DO LOCKING.

Arguments:

    StringTable - supplies a pointer to the string table to be enumerated.

    ExtraDataBuffer - supplies the address of a buffer to be passed to
        the callback routine for each string, which will be filled in
        with the associated data of each string.

    ExtraDataBufferSize - if ExtraDataBuffer is specified then this
        supplies the size of that buffer in bytes. If this value is
        smaller than the size of the extra data for the string table,
        the enumeration fails.

    Callback - supplies the routine to be notified of each string.

    lParam - supplies an optional parameter meaningful to the caller
        which is passed on to the callback unchanged.

Return Value:

    Boolean value indicating outcome. TRUE unless ExtraDataBufferSize
    is too small.

--*/

{
    UINT u;
    PSTRING_TABLE stringTable = StringTable;
    PSTRING_NODE stringNode;
    LONG FirstOffset;
    BOOL b;

    //
    // Validate buffer size.
    //
    if(ExtraDataBuffer && (ExtraDataBufferSize < stringTable->ExtraDataSize)) {
        return(FALSE);
    }

    for(b=TRUE,u=0; b && (u<HASH_BUCKET_COUNT); u++) {

        FirstOffset = ((PLONG)stringTable->Data)[u];

        if(FirstOffset == -1) {
            continue;
        }

        stringNode = (PSTRING_NODE)(stringTable->Data + FirstOffset);

        do {

            if(ExtraDataBuffer) {
                CopyMemory(
                    ExtraDataBuffer,
                    stringNode->String + lstrlen(stringNode->String) + 1,
                    stringTable->ExtraDataSize
                    );
            }

            b = Callback(
                    StringTable,
                    (LONG)((PUCHAR)stringNode - stringTable->Data),
                    stringNode->String,
                    ExtraDataBuffer,
                    ExtraDataBuffer ? stringTable->ExtraDataSize : 0,
                    lParam
                    );

            stringNode = (stringNode->NextOffset == -1)
                       ? NULL
                       : (PSTRING_NODE)(stringTable->Data + stringNode->NextOffset);

        } while(b && stringNode);
    }

    return(TRUE);
}


PTSTR
_pSpUtilsStringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    )

/*++

Routine Description:

    Given a string ID returned when a string was added or looked up,
    return a pointer to the actual string.  (This is exactly the same
    as pSetupStringTableStringFromId, except that it doesn't do locking.)

Arguments:

    StringTable - supplies a pointer to the string table containing the
        string to be retrieved.

    StringId - supplies a string id returned from pSetupStringTableAddString
        or pSetupStringTableLookUpString.

Return Value:

    Pointer to string data. The caller must not write into or otherwise
    alter the string.

--*/

{
    return ((PSTRING_NODE)(((PSTRING_TABLE)StringTable)->Data + StringId))->String;
}


PTSTR
pSetupStringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    )

/*++

Routine Description:

    Given a string ID returned when a string was added or looked up,
    return a pointer to the actual string.

Arguments:

    StringTable - supplies a pointer to the string table containing the
        string to be retrieved.

    StringId - supplies a string id returned from pSetupStringTableAddString
        or pSetupStringTableLookUpString.

Return Value:

    Pointer to string data. The caller must not write into or otherwise
    alter the string.

    This function is fundamentally not thread-safe
    since the ptr we return could be modified by another thread
    if string table is accessed by more than one thread
    Hence new API below pSetupStringTableStringFromIdEx

--*/

{
    PTSTR p = NULL;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        p = ((PSTRING_NODE)(((PSTRING_TABLE)StringTable)->Data + StringId))->String;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        p = NULL;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        locked = locked;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    return(p);
}


BOOL
pSetupStringTableStringFromIdEx(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN OUT PTSTR pBuffer,
    IN OUT PULONG pBufSize
    )

/*++

Routine Description:

    Given a string ID returned when a string was added or looked up,
    return a pointer to the actual string.

Arguments:

    StringTable - supplies a pointer to the string table containing the
        string to be retrieved.

    StringId - supplies a string id returned from pSetupStringTableAddString
        or pSetupStringTableLookUpString.

    pBuffer - points to a buffer that will be filled out with the string
        to be retrieved

    pBufSize - supplies a pointer to an input/output parameter that contains
        the size of the buffer on entry, and the number of chars. written on
        exit.

Return Value:

    TRUE if the string was written. pBufSize contains the length of the string
    FALSE if the buffer was invalid, or the string ID was invalid, or the buffer
          wasn't big enough. If pBufSize non-zero, then it is the required bufsize.
          currently caller can tell the difference between invalid param and buffer
          size by checking pBufSize

--*/

{
    PTSTR p;
    ULONG len;
    PSTRING_TABLE stringTable = (PSTRING_TABLE)StringTable;
    DWORD status = ERROR_INVALID_DATA;
    BOOL locked = FALSE;

    try {
        if  (!pBufSize) {
            status = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(!LockTable(stringTable)) {
            if (pBuffer != NULL && *pBufSize > 0) {
                pBuffer[0]=0;
            }
            *pBufSize = 0;
            status = ERROR_INVALID_HANDLE;
            leave;
        }
        locked = TRUE;

        //
        // CFGMGR calls this with an ID passed by it's caller
        // we have to check bounds here (while table is locked)
        // the check has to do:
        //
        // (1) StringId must be > 0 (0 is hash-bucket 0)
        // (2) StringId must be < size of string table
        // This should catch common errors but isn't perfect.
        //
        // the check is here since Id validity requires access to Opaque pointer
        //
        if(StringId <= 0 || StringId >= (LONG)(stringTable->DataSize)) {
            if (pBuffer != NULL && *pBufSize > 0) {
                pBuffer[0]=0;
            }
            *pBufSize = 0;
            status = ERROR_INVALID_PARAMETER;
            leave;
        }

        len = lstrlen( ((PSTRING_NODE)(stringTable->Data + StringId))->String);
        len ++; // account for terminating NULL

        if (len > *pBufSize || pBuffer == NULL) {
            if (pBuffer != NULL && *pBufSize > 0) {
                pBuffer[0]=0;
            }
            *pBufSize = len;
            status = ERROR_INSUFFICIENT_BUFFER;
            leave;

        }
        lstrcpy (pBuffer,((PSTRING_NODE)(stringTable->Data + StringId))->String);

        *pBufSize = len;

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = ERROR_INVALID_DATA;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    if(status == NO_ERROR) {
        //
        // if success, return TRUE without modifying error code
        //
        return TRUE;
    }
    //
    // if error, we may be interested in cause
    //
    // SetLastError(status); // left disabled till I know this is safe to do
    return FALSE;
}

VOID
_pSpUtilsStringTableTrim(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Free any memory currently allocated for the string table
    but not currently used.

    This is useful after all strings have been added to a string table
    because the string table grows by a fixed block size as it's being built.

    THIS ROUTINE DOES NOT DO LOCKING!

Arguments:

    StringTable - supplies a string table handle returned from
        a call to pSetupStringTableInitialize().

Return Value:

    None.

--*/

{
    PSTRING_TABLE stringTable = StringTable;
    PVOID p;

    //
    // If the realloc failed the original block is not freed,
    // so we don't really care.
    //

    if(p = pSetupReallocWithTag(stringTable->Data, stringTable->DataSize, MEMTAG_STRINGDATA)) {
        stringTable->Data = p;
        stringTable->BufferSize = stringTable->DataSize;
    }
}


PVOID
pSetupStringTableInitialize(
    VOID
    )

/*++

Routine Description:

    Create and initialize a string table.

Arguments:

    None.

Return Value:

    NULL if the string table could not be created (out of memory).
    Otherwise returns an opaque value that references the string
    table in other StringTable calls.

Remarks:

    This routine returns a string table with synchronization locks
    required by all public StringTable APIs.  If the string table
    is to be enclosed in a structure that has its own locking
    (e.g., HINF, HDEVINFO), then the private version of this API
    may be called, which will not create locks for the string table.

--*/

{
    PSTRING_TABLE StringTable;

    if(StringTable = (PSTRING_TABLE)_pSpUtilsStringTableInitialize(0)) {

        if(InitializeSynchronizedAccess(&StringTable->Lock)) {
            return StringTable;
        }

        _pSpUtilsStringTableDestroy(StringTable);
    }

    return NULL;
}


PVOID
pSetupStringTableInitializeEx(
    IN UINT ExtraDataSize,  OPTIONAL
    IN UINT Reserved
    )

/*++

Routine Description:

    Create and initialize a string table, where each string can have
    some arbitrary data associated with it.

Arguments:

    ExtraDataSize - supplies maximum size of arbitrary data that can be
        associated with strings in the string table that will be created.

    Reserved - unused, must be 0.

Return Value:

    NULL if the string table could not be created (out of memory).
    Otherwise returns an opaque value that references the string
    table in other StringTable calls.

Remarks:

    This routine returns a string table with synchronization locks
    required by all public StringTable APIs.  If the string table
    is to be enclosed in a structure that has its own locking
    (e.g., HINF, HDEVINFO), then the private version of this API
    may be called, which will not create locks for the string table.

--*/

{
    PSTRING_TABLE StringTable;

    if(Reserved) {
        return(NULL);
    }

    if(StringTable = (PSTRING_TABLE)_pSpUtilsStringTableInitialize(ExtraDataSize)) {

        if(InitializeSynchronizedAccess(&StringTable->Lock)) {
            return StringTable;
        }

        _pSpUtilsStringTableDestroy(StringTable);
    }

    return NULL;
}


PVOID
_pSpUtilsStringTableInitialize(
    IN UINT ExtraDataSize   OPTIONAL
    )

/*++

Routine Description:

    Create and initialize a string table. Each string can optionally have
    some arbitrary data associated with it.

    THIS ROUTINE DOES NOT INITIALIZE STRING TABLE SYNCHRONIZATION LOCKS!

Arguments:

    ExtraDataSize - supplies maximum size of arbitrary data that can be
        associated with strings in the string table that will be created.

Return Value:

    NULL if the string table could not be created (out of memory).
    Otherwise returns an opaque value that references the string
    table in other StringTable calls.

Remarks:

    The string table returned from this API may not be used as-is with the
    public StringTable APIs--it must have its synchronization locks initialized
    by the public form of this API.

--*/

{
    UINT u;
    PSTRING_TABLE stringTable;
    LCID locale;

    //
    // Allocate a string table
    //
    if(stringTable = pSetupMallocWithTag(sizeof(STRING_TABLE),MEMTAG_STRINGTABLE)) {

        ZeroMemory(stringTable,sizeof(STRING_TABLE));

        stringTable->ExtraDataSize = ExtraDataSize;
        locale = GetThreadLocale();
        //
        // changes here may need to be reflected in _pSpUtilsStringTableInitializeFromMemoryMappedFile
        //
        if(PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_TURKISH) {
            //
            // Turkish has a problem with i and dotted i's.
            // Do comparison in English (default sort)
            //
            stringTable->Locale = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);
        } else {
            //
            // string tables always use default sorting algorithm
            //
            stringTable->Locale = MAKELCID(LANGIDFROMLCID(locale),SORT_DEFAULT);
        }

        //
        // Allocate space for the string table data.
        //
        if(stringTable->Data = pSetupMallocWithTag(STRING_TABLE_INITIAL_SIZE,MEMTAG_STRINGDATA)) {

            stringTable->BufferSize = STRING_TABLE_INITIAL_SIZE;

            //
            // Initialize the hash table
            //
            for(u=0; u<HASH_BUCKET_COUNT; u++) {
                ((PLONG)(stringTable->Data))[u] = -1;
            }

            //
            // Set the DataSize to the size of the StringNodeOffset list, so
            // we'll start adding new strings after it.
            //
            stringTable->DataSize = HASH_BUCKET_COUNT * sizeof(LONG);

            return(stringTable);
        }

        pSetupFreeWithTag(stringTable,MEMTAG_STRINGTABLE);
    }

    return(NULL);
}


VOID
pSetupStringTableDestroy(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Destroy a string table, freeing all resources it uses.

Arguments:

    StringTable - supplies a string table handle returned from
        a call to pSetupStringTableInitialize().

Return Value:

    None.

--*/

{
    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }

        DestroySynchronizedAccess(&(((PSTRING_TABLE)StringTable)->Lock));

        _pSpUtilsStringTableDestroy(StringTable);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
    }
}


VOID
_pSpUtilsStringTableDestroy(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Destroy a string table, freeing all resources it uses.
    THIS ROUTINE DOES NOT DO LOCKING!

Arguments:

    StringTable - supplies a string table handle returned from
        a call to pSetupStringTableInitialize() or _pSpUtilsStringTableInitializeFromMemoryMappedFile

Return Value:

    None.

--*/

{
    if (((PSTRING_TABLE)StringTable)->BufferSize) {
        pSetupFreeWithTag(((PSTRING_TABLE)StringTable)->Data,MEMTAG_STRINGDATA);
        pSetupFreeWithTag(StringTable,MEMTAG_STRINGTABLE);
    } else {
        pSetupFreeWithTag(StringTable,MEMTAG_STATICSTRINGTABLE);
    }
}


PVOID
pSetupStringTableDuplicate(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Create an independent duplicate of a string table.

Arguments:

    StringTable - supplies a string table handle of string table to duplicate.

Return Value:

    Handle for new string table, NULL if out of memory.

--*/

{
    PSTRING_TABLE New = NULL;
    BOOL locked = FALSE;

    try {
        if(!LockTable((PSTRING_TABLE)StringTable)) {
            leave;
        }
        locked = TRUE;

        if(New = (PSTRING_TABLE)_pSpUtilsStringTableDuplicate(StringTable)) {

            if(!InitializeSynchronizedAccess(&New->Lock)) {
                _pSpUtilsStringTableDestroy(New);
                New = NULL;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        New = NULL;
    }
    if (locked) {
        UnlockTable((PSTRING_TABLE)StringTable);
    }

    return New;
}


PVOID
_pSpUtilsStringTableDuplicate(
    IN PVOID StringTable
    )

/*++

Routine Description:

    Create an independent duplicate of a string table.
    THIS ROUTINE DOES NOT DO LOCKING!

Arguments:

    StringTable - supplies a string table handle of string table to duplicate.

Return Value:

    Handle for new string table, NULL if out of memory or buffer copy failure.

Remarks:

    This routine does not initialize synchronization locks for the duplicate--these
    fields are initialized to NULL.

--*/

{
    PSTRING_TABLE New;
    PSTRING_TABLE stringTable = StringTable;
    BOOL Success;

    if(New = pSetupMallocWithTag(sizeof(STRING_TABLE),MEMTAG_STRINGTABLE)) {

        CopyMemory(New,StringTable,sizeof(STRING_TABLE));

        //
        // Allocate space for the string table data.
        //
        if(New->Data = pSetupMallocWithTag(stringTable->DataSize,MEMTAG_STRINGDATA)) {
            //
            // Surround memory copy in try/except, since we may be dealing with
            // a string table contained in a PNF, in which case the buffer is
            // in a memory-mapped file.
            //
            Success = TRUE; // assume success unless we get an inpage error...
            try {
                CopyMemory(New->Data, stringTable->Data, stringTable->DataSize);
            } except(EXCEPTION_EXECUTE_HANDLER) {
                Success = FALSE;
            }

            if(Success) {
                New->BufferSize = New->DataSize;
                ZeroMemory(&New->Lock, sizeof(MYLOCK));
                return New;
            }

            pSetupFreeWithTag(New->Data,MEMTAG_STRINGDATA);
        }

        pSetupFreeWithTag(New,MEMTAG_STRINGTABLE);
    }

    return NULL;
}

PVOID
_pSpUtilsStringTableInitializeFromMemoryMappedFile(
    IN PVOID DataBlock,
    IN DWORD DataBlockSize,
    IN LCID  Locale,
    IN UINT ExtraDataSize
    )
{
    PSTRING_TABLE StringTable;
    BOOL WasLoaded = TRUE;

    //
    // Allocate a string table
    //
    if(!(StringTable = pSetupMallocWithTag(sizeof(STRING_TABLE),MEMTAG_STATICSTRINGTABLE))) {
        return NULL;
    }

    try {
        StringTable->Data = (PUCHAR)DataBlock;
        StringTable->DataSize = DataBlockSize;
        StringTable->BufferSize = 0; // no allocated buffer
        //
        // Clear the Lock structure, because mem-mapped string tables can only be accessed
        // internally
        //
        StringTable->Lock.Handles[0] = StringTable->Lock.Handles[1] = NULL;
        StringTable->ExtraDataSize = ExtraDataSize;

        if(PRIMARYLANGID(LANGIDFROMLCID(Locale)) == LANG_TURKISH) {
            //
            // Turkish has a problem with i and dotted i's.
            // Do comparison in English.
            //
            StringTable->Locale = MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT);
        } else {
            StringTable->Locale = MAKELCID(LANGIDFROMLCID(Locale),SORT_DEFAULT);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        WasLoaded = FALSE;
    }

    if(WasLoaded) {
        return StringTable;
    } else {
        pSetupFreeWithTag(StringTable,MEMTAG_STATICSTRINGTABLE);
        return NULL;
    }
}

DWORD
_pSpUtilsStringTableGetDataBlock(
    IN  PVOID  StringTable,
    OUT PVOID *StringTableBlock
    )
{
    *StringTableBlock = (PVOID)(((PSTRING_TABLE)StringTable)->Data);

    return ((PSTRING_TABLE)StringTable)->DataSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\ansi\precomp.h ===
#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\sputils\strtab.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    strtab.h

Abstract:

    String table functions in sputils that setupapi needs to know about
    but nobody else does

Author:

    Jamie Hunter (JamieHun) Jun-27-2000

Revision History:

--*/

#ifdef SPUTILSW
//
// name mangling so the names don't conflict with any in sputilsa.lib
//
#define _pSpUtilsStringTableLookUpString _pSpUtilsStringTableLookUpStringW
#define _pSpUtilsStringTableGetExtraData _pSpUtilsStringTableGetExtraDataW
#define _pSpUtilsStringTableSetExtraData _pSpUtilsStringTableSetExtraDataW
#define _pSpUtilsStringTableAddString    _pSpUtilsStringTableAddStringW
#define _pSpUtilsStringTableEnum         _pSpUtilsStringTableEnumW
#define _pSpUtilsStringTableStringFromId _pSpUtilsStringTableStringFromIdW
#define _pSpUtilsStringTableTrim         _pSpUtilsStringTableTrimW
#define _pSpUtilsStringTableInitialize   _pSpUtilsStringTableInitializeW
#define _pSpUtilsStringTableDestroy      _pSpUtilsStringTableDestroyW
#define _pSpUtilsStringTableDuplicate    _pSpUtilsStringTableDuplicateW
#define _pSpUtilsStringTableInitializeFromMemoryMappedFile _pSpUtilsStringTableInitializeFromMemoryMappedFileW
#define _pSpUtilsStringTableGetDataBlock _pSpUtilsStringTableGetDataBlockW
#define _pSpUtilsStringTableLock         _pSpUtilsStringTableLockW
#define _pSpUtilsStringTableUnlock       _pSpUtilsStringTableUnlockW
#endif // SPUTILSW

//
// Define an additional private flag for the pStringTable APIs.
// Private flags are added from MSB down; public flags are added
// from LSB up.
//
#define STRTAB_ALREADY_LOWERCASE 0x80000000

//
// Don't change this in a hurry - it requires all INF files to be recompiled
// There might even be other dependencies
//
#define HASH_BUCKET_COUNT 509

//
// Private string table functions that don't do locking.  These are
// to be used for optimization purposes by components that already have
// a locking mechanism (e.g., HINF, HDEVINFO).
//
LONG
_pSpUtilsStringTableLookUpString(
    IN     PVOID   StringTable,
    IN OUT PTSTR   String,
    OUT    PDWORD  StringLength,
    OUT    PDWORD  HashValue,           OPTIONAL
    OUT    PVOID  *FindContext,         OPTIONAL
    IN     DWORD   Flags,
    OUT    PVOID   ExtraData,           OPTIONAL
    IN     UINT    ExtraDataBufferSize  OPTIONAL
    );

LONG
_pSpUtilsStringTableAddString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
    IN     PVOID ExtraData,     OPTIONAL
    IN     UINT  ExtraDataSize  OPTIONAL
    );

BOOL
_pSpUtilsStringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    );

BOOL
_pSpUtilsStringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    );

BOOL
_pSpUtilsStringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    );

PTSTR
_pSpUtilsStringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    );

PVOID
_pSpUtilsStringTableDuplicate(
    IN PVOID StringTable
    );

VOID
_pSpUtilsStringTableDestroy(
    IN PVOID StringTable
    );

VOID
_pSpUtilsStringTableTrim(
    IN PVOID StringTable
    );

PVOID
_pSpUtilsStringTableInitialize(
    IN UINT ExtraDataSize   OPTIONAL
    );

DWORD
_pSpUtilsStringTableGetDataBlock(
    IN  PVOID  StringTable,
    OUT PVOID *StringTableBlock
    );

BOOL
_pSpUtilsStringTableLock(
    IN PVOID StringTable
    );

VOID
_pSpUtilsStringTableUnlock(
    IN PVOID StringTable
    );


//
// PNF String table routines
//
PVOID
_pSpUtilsStringTableInitializeFromMemoryMappedFile(
    IN PVOID DataBlock,
    IN DWORD DataBlockSize,
    IN LCID  Locale,
    IN UINT ExtraDataSize
    );

//
// names expected by setupapi (we use the munged names above to stop accidental link errors)
//
#define pStringTableLookUpString        _pSpUtilsStringTableLookUpString
#define pStringTableAddString           _pSpUtilsStringTableAddString
#define pStringTableGetExtraData        _pSpUtilsStringTableGetExtraData
#define pStringTableSetExtraData        _pSpUtilsStringTableSetExtraData
#define pStringTableEnum                _pSpUtilsStringTableEnum
#define pStringTableStringFromId        _pSpUtilsStringTableStringFromId
#define pStringTableDuplicate           _pSpUtilsStringTableDuplicate
#define pStringTableDestroy             _pSpUtilsStringTableDestroy
#define pStringTableTrim                _pSpUtilsStringTableTrim
#define pStringTableInitialize          _pSpUtilsStringTableInitialize
#define pStringTableGetDataBlock        _pSpUtilsStringTableGetDataBlock
#define InitializeStringTableFromMemoryMappedFile _pSpUtilsStringTableInitializeFromMemoryMappedFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\tools\cabprep\cabprep.h ===
#include <stdio.h>
#include <windows.h>
#include <conio.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <io.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\unicode\makefile.inc ===
!include ..\makefile.inc

PRIVLIB= $(O)\spapip.lib

$(O)\setupapi.lib: $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\spapip.def $(LIBRARY_OBJS)
    -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\spapip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\spapip.def: ..\setupapi.def
	$(C_PREPROCESSOR) ..\setupapi.def -DSPAPIP > $@

msg.h msg00001.bin msg.rc: ..\msg.mc
	mc -v ..\msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\tools\cabprep\cabprep.c ===
/*
    Utility to do some processing in generation of the driver cab file
    This tool takes a sorted list of files and checks and strips duplicates.
    In addition, given a set of destination directories it will strip out files that don't exist in
    any one of these directories. The preference is specified in the order that they are listed.


    Author:

    Vijesh Shetty (vijeshs) 29-Sep-1998

    Revision History:


*/
#include "cabprep.h"


#define MAX_LOCATIONS 10
#define MAX_SETS 10

int _cdecl main ( int argc, char *argv[] );

int _cdecl main ( int argc, char *argv[] )
{
    PTCHAR i,c;
    TCHAR PreviousFile[MAX_PATH], FileNam[MAX_PATH], Path[MAX_SETS][MAX_LOCATIONS][MAX_PATH], DriverList[MAX_SETS][MAX_PATH];
    TCHAR CompressedPath[MAX_PATH], Buffer[512], Section[MAX_SETS][MAX_PATH];
    TCHAR CompPrependStr[MAX_PATH];
    FILE *Read_File, *Error_File, *Index_File, *Write_File, *Make_File;
    TCHAR Ddf_name[MAX_PATH];
    struct _tfinddata_t c_file;
    intptr_t h;
    int StrLen,rem,e,count,Found,num_path[MAX_SETS],num_sets=0,count2;



    if (argc < 2){
        _tprintf( TEXT("CABPREP /s:SortedFile,CabName,[SourceLocation1],[SourceLocation2..] /s:[..]\n"));
        _tprintf( TEXT("\n\nUtility to do some processing in generation of driver cab files.\n"));
        _tprintf( TEXT("This tool takes a sorted list of files and checks and strips duplicates.\n"));
        _tprintf( TEXT("In addition, given a set of destination directories it will strip out files\n"));
        _tprintf( TEXT("that don't exist in any one of these directories. The Source location preference follows\n"));
        _tprintf( TEXT("the order that they are specified in. Th tool checks for compressed files first\n"));
        _tprintf( TEXT("and then the real name. Errors reported in cabprep.err and the index file\n"));
        _tprintf( TEXT("created is drvindex.inf. Multiple sets can be given to create a single inf for many cabs.\n"));
        _tprintf( TEXT("Don't use any spaces between parameters for a given set.\n"));

        return 0;
    }

    if( argc >= 2 ){

        num_sets = argc - 1;
        for( count=0; count<num_sets; count++){
            num_path[count] = 0;

#ifdef UNICODE


            StrLen = MultiByteToWideChar(CP_ACP,
                                 MB_PRECOMPOSED,
                                 argv[count+1],
                                 -1,
                                 Buffer,
                                 sizeof(Buffer)/sizeof(WCHAR)
                                 );

            if( !StrLen ){
                _tprintf( TEXT("ERROR: Invalid Argument"));
                return -1;
            }

#else // !UNICODE

            lstrcpy( Buffer, argv[count+1] );

#endif //UNICODE


            Buffer[2] = L'\0';

            if( lstrcmpi( Buffer, TEXT("/S"))){
                _tprintf( TEXT("ERROR: Invalid Argument"));
                return -1;
            }
            else{

                i = Buffer + 3;
                StrLen = lstrlen(i);
                for( count2=0; count2 < StrLen; count2++ ){
                    if( i[count2] == L',' ){

                        i[count2] = L'\0';
                        num_path[count]++;
                    }
                }
                num_path[count] = num_path[count] - 1;

                lstrcpy( DriverList[count], i );
                if( !DriverList[count] ){
                    _tprintf( TEXT("ERROR: Invalid Source File"));
                    return -1;
                }
                i = i + lstrlen( i ) + 1;
                lstrcpy( Section[count], i );
                if( !Section[count] ){
                    _tprintf( TEXT("ERROR: Invalid Section Name"));
                    return -1;
                }
                i = i + lstrlen( i ) + 1;

                if( num_path[count] > (MAX_LOCATIONS) ){
                    _tprintf( TEXT("ERROR: Exceeded maximum no. of paths"));
                    return( -1 );
                }

                for( count2=0;count2 < num_path[count]; count2++ ){
                    lstrcpy( Path[count][count2], i );
                    if( !Path[count][count2] ){
                        _tprintf( TEXT("ERROR: Invalid Path"));
                        return -1;
                    }
                    i = i + lstrlen( i ) + 1;
                }

            }

        }

    }



    Index_File = _tfopen( TEXT("drvindex.inf"), TEXT("w") );
    Make_File = _tfopen( TEXT("makefil0"), TEXT("w") );

    _ftprintf( Index_File, TEXT("[Version]\n"));
    _ftprintf( Index_File, TEXT("signature=\"$Windows NT$\"\n"));
    _ftprintf( Index_File, TEXT("CabFiles=%s"), Section[0]);
    _ftprintf( Make_File, TEXT("#*****Automatically generated file by cabprep.exe for the build proces************\n\n\n") );
    _ftprintf( Make_File, TEXT("all: %s%s.cab"), Path[0][0], Section[0] );
    for( count=1; count < num_sets; count++ ){
        _ftprintf( Index_File, TEXT(",%s"), Section[count]);
        _ftprintf( Make_File, TEXT(" disk1\\%s.cab"), Section[count] );
    }

    _ftprintf( Make_File, TEXT("\n\n\n") );


    Error_File = _tfopen( TEXT("cabprep.err"), TEXT("w") );
    

    
    
    
    for( count2=0; count2 < num_sets; count2++ ){

        if( num_sets > 1)
            wsprintf( Ddf_name, TEXT("Out%d.ddf"), count2);  //use postfix digit for more than one cab
        else
            lstrcpy( Ddf_name, TEXT("Out.ddf") );

        Write_File = _tfopen( Ddf_name, TEXT("w") );
        _ftprintf( Write_File, TEXT(";*****Automatically generated file by cabprep.exe for Diamond************\n\n\n") );
        
        _ftprintf( Index_File, TEXT("\n\n\n[%s]\n"), Section[count2]);
        _ftprintf( Make_File, TEXT("\n%s%s.cab:  "), Path[count2][0], Section[count2] );



        _ftprintf( Write_File, TEXT(".New Cabinet\n") );
        _ftprintf( Write_File, TEXT(".Set CabinetName%d=%s.cab\n"), (count2+1), Section[count2] );
        _ftprintf( Write_File, TEXT(".Set MaxDiskSize=CDROM\n") );
        _ftprintf( Write_File, TEXT(".Set CompressionType=LZX\n") );
        _ftprintf( Write_File, TEXT(".Set CompressionMemory=21\n") );
        _ftprintf( Write_File, TEXT(".Set CompressionLevel=1\n") );
        _ftprintf( Write_File, TEXT(".Set Compress=ON\n") );
        _ftprintf( Write_File, TEXT(".Set Cabinet=ON\n") );
        _ftprintf( Write_File, TEXT(".Set UniqueFiles=ON\n") );
        _ftprintf( Write_File, TEXT(".Set FolderSizeThreshold=1000000\n") );
        _ftprintf( Write_File, TEXT(".Set MaxErrors=300\n\n\n\n") );



        Read_File = _tfopen( DriverList[count2], TEXT("r") );

        lstrcpy( PreviousFile, TEXT("$$$.#$$") );


        if (Read_File) {

            while( 1 ){

                // HAck because of bug that doesn't allow the use of _TEOF. Bcoz of the bug
                // fscanf returns EOF but fwscanf returns 0 when it should return 0xffff. So _TEOF
                // is useless and causes us to loop.

    #ifdef UNICODE
                if( (_ftscanf( Read_File, TEXT("%s"), FileNam )) == 0 )
    #else  //UNICODE
                if( (_ftscanf( Read_File, TEXT("%s"), FileNam )) == _TEOF )
    #endif //UNICODE
                    break;

                for( i = FileNam; i < FileNam + lstrlen( FileNam ); i++ )   {
                    *i = (TCHAR)towlower( *i );
                }



                if( lstrcmp( PreviousFile, FileNam )){

                    if(!num_path[count2]){
                       _ftprintf( Write_File, TEXT("%s\n"), FileNam );
                       _ftprintf( Make_File, TEXT("\\\n\t%s  "), FileNam );
                       _ftprintf( Index_File, TEXT("%s\n"), FileNam );

                    }else{

                       //
                       //Do the cross checking only if we specify source paths. Otherwise ignore Path information.
                       //
                    
                       Found = 0;
   
                       // Try for each path that was given to us first with the compressed name and then uncompressed
                        
                       for( count=0; count<num_path[count2]; count++){
   
                           //
                           //Construct the compressed full pathname
                           //
   
                           lstrcpy( CompPrependStr, Path[count2][count] );
                           lstrcat( CompPrependStr, FileNam );
                           c = _tcsrchr( CompPrependStr, L'.' );
                           e = lstrlen(CompPrependStr);
                           rem = (int)(CompPrependStr + e - c - 1);
                           if( rem < 3 ){
                               CompPrependStr[e] = '_';
                               CompPrependStr[e+1] = '\0';
                           }
                           else
                               CompPrependStr[e-1] = '_';
   
                           //Look for the compressed file
   
                           h=_tfindfirst(CompPrependStr,&c_file);
                           if(h != -1){
                               _ftprintf( Write_File, TEXT("%s\n"), CompPrependStr );
                               _ftprintf( Make_File, TEXT("\\\n\t%s  "), CompPrependStr );
                               _ftprintf( Index_File, TEXT("%s\n"), FileNam );
                               _findclose(h);
                               Found=1;
                               break;
                           }
                           else{
   
                               // Then the uncompressed path
   
                               _ftprintf( Error_File, TEXT("%s not found in %s \n"), CompPrependStr, Path[count2][count] );
                               lstrcpy( CompPrependStr, Path[count2][count] );
                               lstrcat( CompPrependStr, FileNam );
                               h=_tfindfirst(CompPrependStr,&c_file);
                               if(h != -1){
                                   Found = 1;
                                   _ftprintf( Write_File, TEXT("%s\n"), CompPrependStr );
                                   _ftprintf( Make_File, TEXT("\\\n\t%s  "), CompPrependStr );
                                   _ftprintf( Index_File, TEXT("%s\n"), FileNam );
                                   _findclose(h);
                               break;
                               }
                               _ftprintf( Error_File, TEXT("%s not found in %s \n"), CompPrependStr, Path[count2][count] );
                           }
   
                       }
   
                       if( !Found )
                           _ftprintf( Error_File, TEXT("%s missing from all locations \n"), CompPrependStr );
                    }

                }
                else
                    _ftprintf( Error_File, TEXT("Duplicate found - Removing %s\n"), FileNam );

                lstrcpy( PreviousFile, FileNam );

            }

        }
        clearerr(Read_File);
        fflush(Read_File);
        fclose(Read_File);
        _ftprintf( Write_File, TEXT("\n\n\n\n") );
        fclose(Write_File);
        // The line below will try to run recab to find timestamp diffs only for the first sourcepath
        _ftprintf( Make_File, TEXT("\n\trecab .\\drvindex.inf %s.cab %s delta.lst"),Section[count2], Path[count2][0] );
        _ftprintf( Make_File, TEXT("\n\n"));

        // Below lines are not needed with incremental cabs being available. Build process takes care of it

        /*_ftprintf( Make_File, TEXT("\n\tdiamond /f %s"), Ddf_name );
        _ftprintf( Make_File, TEXT("\n\tcopy /y disk1\\%s.cab %s%s.cab"),Section[count2], Path[count2][0], Section[count2] );
        _ftprintf( Make_File, TEXT("\n\tdel /q disk1\\%s.cab\n\n\n\n"),Section[count2] );*/

        


    }//For (count2)

    _ftprintf( Index_File, TEXT("\n\n\n[Cabs]\n"));
    for( count=0; count < num_sets; count++ ){
        _ftprintf( Index_File, TEXT("%s=%s.cab\n"), Section[count],Section[count]);

    }

    _flushall();
    _fcloseall();





    return 0;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\wowreg32\rc_ids.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rc_ids.h

Abstract:

    Header for wowreg32 resources

Author:

    Jamie Hunter 31/10/2000

--*/




#define     IDS_WRONGUSE         1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\test\class.c ===
/**------------------------------------------------------------------
   class.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include "cmtest.h"

//
// Private Prototypes
//

BOOL
FillClassListBox(
   HWND hDlg
   );

BOOL
GetSelectedClass(
   HWND   hDlg,
   LPTSTR szClassGuid
   );

REGSAM
GetAccessMask(
   HWND    hDlg
   );

//
// Globals
//
extern HINSTANCE hInst;
extern TCHAR     szDebug[MAX_PATH];
extern TCHAR     szAppName[MAX_PATH];
extern HMACHINE  hMachine;



/**----------------------------------------------------------------------**/
LRESULT CALLBACK
ClassDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status;
   ULONG       Size;
   LONG        Index;
   TCHAR       szClassGuid[MAX_GUID_STRING_LEN];
   TCHAR       szClassName[MAX_CLASS_NAME_LEN];


   switch (message) {
      case WM_INITDIALOG:
         if (!FillClassListBox(hDlg)) {
            EndDialog(hDlg, FALSE);
         }
         return TRUE;

   case WM_COMMAND:
      switch(LOWORD(wParam)) {

         case IDOK:
            EndDialog(hDlg, TRUE);
            return TRUE;

         case ID_LB_CLASSES:
            if (HIWORD(wParam) != LBN_DBLCLK) {
               break;
            }
            // if DBLCK, fall through to getting the classname

         case ID_BT_CLASSNAME:
            /*
            if (!GetSelectedClass(hDlg, szClassName)) {
               break;
            }

            Size = MAX_CLASS_NAME_LEN;
            Status = CM_Get_Class_Name_Ex(
                  &ClassGuid, szClassName, &Size, 0, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug,
                     TEXT("CM_Get_Class_Name failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               EndDialog(hDlg, FALSE);
            }

            SetDlgItemText(hDlg, ID_ST_CLASSNAME, szClassName);
            */
            break;

         case ID_BT_CLASSKEY:
            if (!GetSelectedClass(hDlg, szClassName)) {
               break;
            }

            DialogBoxParam(hInst, MAKEINTRESOURCE(CLASSKEY_DIALOG), hDlg,
                     (DLGPROC)ClassKeyDlgProc, (LPARAM)(LPCTSTR)szClassName);
            break;

         default:
            break;
      }

   }
   return FALSE;

} // ClassDlgProc



/**----------------------------------------------------------------------**/
LRESULT CALLBACK
ClassKeyDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status;
   REGSAM      rsAccess;
   ULONG       ulDisp, ulSize;
   TCHAR       szClassGuid[MAX_PATH];
   TCHAR       szValueName[MAX_PATH];
   TCHAR       szValueData[MAX_PATH];
   LONG        RegStatus;
   HKEY        hKey;
   GUID        ClassGuid;


   switch (message) {
      case WM_INITDIALOG:
         SetDlgItemText(hDlg, ID_ST_CLASSGUID, (LPCTSTR)lParam);
         return TRUE;

   case WM_COMMAND:
      switch(LOWORD(wParam)) {

         case IDOK:
            EndDialog(hDlg, TRUE);
            return TRUE;

         case ID_BT_QUERYVALUE:
            GetDlgItemText(hDlg, ID_ST_CLASSGUID, szClassGuid, MAX_PATH);
            rsAccess = GetAccessMask(hDlg);
            if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE)) {
               ulDisp = RegDisposition_OpenAlways;
            }
            else {
               ulDisp = RegDisposition_OpenExisting;
            }

            Status = CM_Open_Class_Key_Ex(
                     &ClassGuid, NULL, rsAccess, ulDisp, &hKey, 0, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug,
                     TEXT("CM_Open_Class_Key failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               EndDialog(hDlg, FALSE);
            }

            GetDlgItemText(hDlg, ID_ED_VALUENAME, szValueName, MAX_PATH);
            RegStatus = RegQueryValueEx(hKey, szValueName, NULL, NULL,
                     (LPBYTE)szValueData, &ulSize);
            if (RegStatus == ERROR_SUCCESS) {
               SetDlgItemText(hDlg, ID_ED_VALUEDATA, szValueData);
            }
            else {
               MessageBeep(0);
            }
            RegCloseKey(hKey);
            break;

         case ID_BT_SETVALUE:
            GetDlgItemText(hDlg, ID_ST_CLASSGUID, szClassGuid, MAX_PATH);
            rsAccess = GetAccessMask(hDlg);
            if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE)) {
               ulDisp = RegDisposition_OpenAlways;
            }
            else {
               ulDisp = RegDisposition_OpenExisting;
            }

            Status = CM_Open_Class_Key_Ex(
                     &ClassGuid, NULL, rsAccess, ulDisp, &hKey, 0, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug,
                     TEXT("CM_Open_Class_Key failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               EndDialog(hDlg, FALSE);
            }

            GetDlgItemText(hDlg, ID_ED_VALUENAME, szValueName, MAX_PATH);
            GetDlgItemText(hDlg, ID_ED_VALUEDATA, szValueData, MAX_PATH);
            RegStatus = RegSetValueEx(hKey, szValueName, 0, REG_SZ,
                     (LPBYTE)szValueData,
                     (lstrlen(szValueData)+1) * sizeof(TCHAR));
            if (RegStatus != ERROR_SUCCESS) {
               MessageBeep(0);
            }
            RegCloseKey(hKey);
            break;

         default:
            break;
      }
   }
   return FALSE;

} // ClassKeyDlgProc


/**----------------------------------------------------------------------**/
BOOL
FillClassListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       ulIndex, Size;
   GUID        ClassGuid;
   TCHAR       szClassGuid[MAX_CLASS_NAME_LEN];

   SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_RESETCONTENT, 0, 0);

   SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_ADDSTRING, 0,
         (LPARAM)(LPCTSTR)TEXT("(Root)"));

   ulIndex = 0;
   Status = CR_SUCCESS;

   while (Status == CR_SUCCESS) {

      Status = CM_Enumerate_Classes_Ex(
            ulIndex, &ClassGuid, 0, hMachine);

      if (Status == CR_NO_SUCH_VALUE) {
         // no more classes, break out of the look
         break;
      }

      if (Status != CR_SUCCESS) {
         wsprintf(szDebug, TEXT("CM_Enumerate_Classes failed (%xh)"), Status);
         MessageBox(hDlg, szDebug, szAppName, MB_OK);
         return FALSE;
      }

      Size = MAX_CLASS_NAME_LEN;
      Status = CM_Get_Class_Name_Ex(
            &ClassGuid, szClassGuid, &Size, 0, hMachine);

      if (Status != CR_SUCCESS) {
         wsprintf(szDebug, TEXT("CM_Get_Class_Name failed (%xh)"), Status);
         MessageBox(hDlg, szDebug, szAppName, MB_OK);
         return FALSE;
      }

      SendDlgItemMessage(
            hDlg, ID_LB_CLASSES, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)szClassGuid);

      ulIndex++;
   }

   return TRUE;

} // FillClassListBox


/**----------------------------------------------------------------------**/
BOOL
GetSelectedClass(
   HWND   hDlg,
   LPTSTR szClassName
   )
{
   LONG  Index;

   Index = SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR || Index == 0) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_CLASSES, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szClassName);

   if (lstrcmpi(szClassName, TEXT("Root")) == 0) {
      *szClassName = '\0';    // if Root selected, then no class specified
   }
   return TRUE;

} // GetSeletectedClass


/**----------------------------------------------------------------------**/
REGSAM
GetAccessMask(
   HWND    hDlg
   )
{
   REGSAM rsAccess = 0;

   if (IsDlgButtonChecked(hDlg, ID_CHK_ALL_ACCESS)) {
      rsAccess |= KEY_ALL_ACCESS;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE_LINK)) {
      rsAccess |= KEY_CREATE_LINK;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE_SUB_KEY)) {
      rsAccess |= KEY_CREATE_SUB_KEY;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_ENUMERATE_SUB_KEYS)) {
      rsAccess |= KEY_ENUMERATE_SUB_KEYS;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_EXECUTE)) {
      rsAccess |= KEY_EXECUTE;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_NOTIFY)) {
      rsAccess |= KEY_NOTIFY;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_QUERY_VALUE)) {
      rsAccess |= KEY_QUERY_VALUE;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_READ)) {
      rsAccess |= KEY_READ;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_SET_VALUE)) {
      rsAccess |= KEY_SET_VALUE;
   }
   if (IsDlgButtonChecked(hDlg, ID_CHK_WRITE)) {
      rsAccess |= KEY_WRITE;
   }

   return rsAccess;

} // GetAccessMask
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\setupapi\wowreg32\wowreg.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wowreg.c

Abstract:

    This is the surragate process for registration of 32 dlls from a 64 bit process.
    And vice-versa.

    The parent process passes relevent IPC data on the cmdline, and the surragate
    process then coordinates the registration of this data with the parent process.

Author:

    Andrew Ritz (andrewr) 3-Feb-2000

Revision History:

    Andrew Ritz (andrewr) 3-Feb-2000 - Created It

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <shellapi.h>
#include <tchar.h>
#include <stdio.h>
#include <setupapi.h>
#include <spapip.h>
#include <ole2.h>
#include <rc_ids.h>

#ifndef UNICODE
#error UNICODE assumed
#endif

#ifndef _WIN64
#include <wow64t.h>
#endif

#include "..\unicode\msg.h"
#include "memory.h"
#include "..\sputils\locking.h"
#include "childreg.h"
#include "cntxtlog.h"


#define DLLINSTALL      "DllInstall"
#define DLLREGISTER     "DllRegisterServer"
#define DLLUNREGISTER   "DllUnregisterServer"

typedef struct _OLE_CONTROL_DATA {
    LPTSTR              FullPath;
    UINT                RegType;
    PVOID               LogContext;

    BOOL                Register; // or unregister

    LPCTSTR             Argument;

} OLE_CONTROL_DATA, *POLE_CONTROL_DATA;

#if DBG

VOID
WowRegAssertFailed(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    LPSTR Msg;
    DWORD MsgLen;
    DWORD GlobalSetupFlags = pSetupGetGlobalFlags();

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    MsgLen = strlen(p)+strlen(FileName)+strlen(Condition)+128;
    try {

        Msg = _alloca(MsgLen);

        wsprintfA(
            Msg,
            "Assertion failure at line %u in file %s!%s: %s%s",
            LineNumber,
            p,
            FileName,
            Condition,
            (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? "\r\n" : "\n\nCall DebugBreak()?"
            );

        OutputDebugStringA(Msg);

        if(GlobalSetupFlags & PSPGF_NONINTERACTIVE) {
            i = IDYES;
        } else {
            i = MessageBoxA(
                    NULL,
                    Msg,
                    p,
                    MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                    );
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        OutputDebugStringA("WOWREG32 ASSERT!!!! (out of stack)\r\n");
        i=IDYES;
    }
    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { WowRegAssertFailed(__FILE__,__LINE__,#x); }

#else
#define MYASSERT(x)
#endif

VOID
DebugPrintEx(
    DWORD Level,
    PCTSTR format,
    ...                                 OPTIONAL
    )

/*++

Routine Description:

    Send a formatted string to the debugger.

Arguments:

    format - standard printf format string.

Return Value:

    NONE.

--*/

{
    TCHAR buf[1026];    // bigger than max size
    va_list arglist;

    va_start(arglist, format);
    wvsprintf(buf, format, arglist);
    DbgPrintEx(DPFLTR_SETUP_ID, Level, (PCH)"%ws",buf);
}

BOOL
RegisterUnregisterControl(
    PWOW_IPC_REGION_TOSURRAGATE pControlDataFromRegion,
    PDWORD FailureCode);


#define IDLE_TIMER                    1000*60  // 60 seconds
//
// Keep statistics...
//
INT    RegisteredControls = 0;

PWSTR  RegionName;
PWSTR  SignalReadyEvent;
PWSTR  SignalCompleteEvent;
PWSTR  ThisProgramName;
#ifndef _WIN64
BOOL   Wow64 = FALSE;
#endif


BOOL
ParseArgs(
    IN int   argc,
    IN PWSTR *argv
    )
{
    int i;

    ThisProgramName = argv[0];


    if(argc != 7) { // program name plus 3 required switches and their input
        return(FALSE);
    }

    for (i = 0; i < argc; i++) {
        if (0 == _wcsicmp(argv[i],SURRAGATE_REGIONNAME_SWITCH)) {
            RegionName = argv[i+1];
        }

        if (0 == _wcsicmp(argv[i],SURRAGATE_SIGNALREADY_SWITCH)) {
            SignalReadyEvent = argv[i+1];
        }

        if (0 == _wcsicmp(argv[i],SURRAGATE_SIGNALCOMPLETE_SWITCH)) {
            SignalCompleteEvent = argv[i+1];
        }
    }

    if (!SignalCompleteEvent || !SignalReadyEvent || !RegionName) {
        return(FALSE);
    }

    return(TRUE);

}

void
Usage(
    VOID
    )
{
    TCHAR Buffer[2048];
    if(LoadString(GetModuleHandle(NULL),IDS_WRONGUSE,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {
        _ftprintf( stderr,TEXT("%s\n"),Buffer);
    }
}

int
__cdecl
main(
    IN int   argc,
    IN char *argvA[]
    )
{
    BOOL b;
    PWSTR *argv;
    HANDLE hReady = NULL;
    HANDLE hComplete = NULL;
    HANDLE hFileMap = NULL;
    PVOID  Region = NULL;
    PWOW_IPC_REGION_TOSURRAGATE pInput;
    PWOW_IPC_REGION_FROMSURRAGATE pOutput;
    HANDLE hEvent[1];
    DWORD WaitResult, FailureCode;

#ifndef _WIN64
    {
        ULONG_PTR       ul = 0;
        NTSTATUS        st;
        st = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessWow64Information,
                                       &ul,
                                       sizeof(ul),
                                       NULL);

        if (NT_SUCCESS(st) && (0 != ul)) {
            // 32-bit code running on Win64
            Wow64 = TRUE;
        }
    }
#endif

    //
    // Assume failure.
    //
    b = FALSE;

    argv = CommandLineToArgvW(GetCommandLine(), &argc);
    if (!argv) {
        //
        // out of memory ?
        //
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: Low Memory\n");
        goto exit;
    }


    if(!ParseArgs(argc,argv)) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: Invalid Usage\n");
        Usage();
        goto exit;
    }


    //
    // open the region and the named events
    //

    hFileMap = OpenFileMapping(
          FILE_MAP_READ| FILE_MAP_WRITE,
          FALSE,
          RegionName
          );
    if (!hFileMap) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: OpenFileMapping (%s) failed, ec = %x\n", RegionName, GetLastError());
        goto exit;
    }

    Region = MapViewOfFile(
                  hFileMap,
                  FILE_MAP_READ | FILE_MAP_WRITE,
                  0,
                  0,
                  0
                  );
    if (!Region) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: MapViewOfFile failed, ec = %x\n", GetLastError());
        goto exit;
    }

    hReady = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,FALSE, SignalReadyEvent);
    if (!hReady) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: OpenEvent (%s) failed, ec = %x\n", SignalReadyEvent, GetLastError());
        goto exit;
    }

    hComplete = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE,FALSE, SignalCompleteEvent);
    if (!hComplete) {
        DebugPrintEx(
            DPFLTR_ERROR_LEVEL,
            L"WOWREG32: OpenEvent (%s) failed, ec = %x\n", SignalCompleteEvent, GetLastError());
        goto exit;
    }

    pInput  = (PWOW_IPC_REGION_TOSURRAGATE)   Region;
    pOutput = (PWOW_IPC_REGION_FROMSURRAGATE) Region;

    //
    // the process is now initialized.  we now wait for either our event to be
    // signalled or for our idle timer to fire, in which case we will exit the
    // program
    //
    hEvent[0] = hReady;

    while (1) {

        do {
            WaitResult = MsgWaitForMultipleObjectsEx(
                                                1,
                                                &hEvent[0],
                                                IDLE_TIMER,
                                                QS_ALLINPUT,
                                                MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);

            if (WaitResult == WAIT_OBJECT_0 + 1) {
                MSG msg;

                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        } while(WaitResult != WAIT_TIMEOUT &&
                WaitResult != WAIT_OBJECT_0 &&
                WaitResult != WAIT_FAILED);


        if (WaitResult == WAIT_TIMEOUT) {
            //
            // we hit the idle timer, so let the process unwind and go away now.
            //
            //
            // it doesn't matter too much, but make the return code "false" if the
            // process has gone away without ever registering any controls.
            //
            b = (RegisteredControls != 0);

            break;

        }

        MYASSERT(WaitResult == WAIT_OBJECT_0);

        //
        // reset our event so we only process each control one time
        //
        ResetEvent(hReady);

        //
        // register the control
        //
        b = RegisterUnregisterControl(pInput,&FailureCode);
#ifdef PRERELEASE
        if (!b) {
            DebugPrintEx(
                DPFLTR_ERROR_LEVEL,
                L"First call to register control failed, trying again.\n"
                L"If you have a debugger attached to this process, it will"
                L" now call DebugBreak() so that you can debug this registration failure\n" );
            if (IsDebuggerPresent()) {
                DebugBreak();
            }
            b = RegisterUnregisterControl(pInput,&FailureCode);
        }
#endif

        //
        // write an output status.  Note that you cannot access pInput after
        // this point because pOutput and pInput are overloaded views of the
        // same memory region.
        //
        pOutput->Win32Error = b ? ERROR_SUCCESS : GetLastError();
        pOutput->FailureCode= b ? SPREG_SUCCESS : FailureCode;

        //
        // set an event to tell the parent process to read our status and give
        // us the next control to register.
        //
        SetEvent(hComplete);

        if (b) {
            RegisteredControls += 1;
        }


    }

    fprintf( stdout,"Registered %d controls\n", RegisteredControls );

    DebugPrintEx(
            DPFLTR_INFO_LEVEL,
            L"WOWREG32: registered %d controls\n", RegisteredControls);

exit:
    if (Region) {
        UnmapViewOfFile( Region );
    }

    if (hFileMap) {
        CloseHandle(hFileMap);
    }

    if (hReady) {
        CloseHandle(hReady);
    }

    if (hComplete) {
        CloseHandle(hComplete);
    }


    return(b);
}


DWORD
pSetupRegisterDllInstall(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllInstall" entrypoint for the specified dll

Arguments:

    OleControlData - pointer to the OLE_CONTROL_DATA structure for the dll
                     to be registered

    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives updated SPREG_* flag indicating outcome


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *InstallRoutine) (BOOL bInstall, LPCTSTR pszCmdLine);
    HRESULT InstallStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        *ExtendedStatus = SPREG_UNKNOWN;
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get function pointer to "DllInstall" entrypoint
    //
    InstallRoutine = NULL; // shut up PreFast
    try {
        (FARPROC)InstallRoutine = GetProcAddress(
            ControlDll, DLLINSTALL );
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {
        //
        // something went wrong...record an error
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in GetProcAddress handled\n");

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(InstallRoutine) {
        //
        // now call the function
        //
        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: installing...\n");

        *ExtendedStatus = SPREG_DLLINSTALL;
        try {

            InstallStatus = InstallRoutine(OleControlData->Register, OleControlData->Argument);

            if(FAILED(InstallStatus)) {

                d = InstallStatus;

                WriteLogEntry(
                    OleControlData->LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_OLE_CONTROL_API_FAILED,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL)
                    );
                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);

            } else if(InstallStatus) {
                WriteLogEntry(OleControlData->LogContext,
                    SETUP_LOG_WARNING,
                    MSG_LOG_OLE_CONTROL_API_WARN,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL),
                    InstallStatus 
                    );
            } else {
                WriteLogEntry(
                    OleControlData->LogContext,
                    SETUP_LOG_VERBOSE,
                    MSG_LOG_OLE_CONTROL_API_OK,
                    NULL,
                    OleControlData->FullPath,
                    TEXT(DLLINSTALL)
                    );
            }
        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                TEXT(DLLINSTALL)
                );

            DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in DllInstall handled\n");

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...installed\n");
    } else {
        *ExtendedStatus = SPREG_GETPROCADDR;
    }

    return d;

}

DWORD
pSetupRegisterDllRegister(
    IN POLE_CONTROL_DATA OleControlData,
    IN HMODULE ControlDll,
    IN PDWORD ExtendedStatus
    )
/*++

Routine Description:

    call the "DllRegisterServer" or "DllUnregisterServer" entrypoint for the
    specified dll

Arguments:

    OleControlData - contains data about dll to be registered
    ControlDll - module handle to the dll to be registered

    ExtendedStatus - receives an extended status depending on the outcome of
                     this operation


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HRESULT (__stdcall *RegisterRoutine) (VOID);
    HRESULT RegisterStatus;

    DWORD d = NO_ERROR;

    //
    // parameter validation
    //
    if (!ControlDll) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get the function pointer to the actual routine we want to call
    //
    RegisterRoutine = NULL; // shut up preFast
    try {
        (FARPROC)RegisterRoutine = GetProcAddress(
            ControlDll, OleControlData->Register ? DLLREGISTER : DLLUNREGISTER);
    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }
    if(ExceptionPointers) {

        //
        // something went wrong, horribly wrong
        //
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_INTERNAL_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in GetProcAddress handled\n");

        *ExtendedStatus = SPREG_GETPROCADDR;

    } else if(RegisterRoutine) {

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: registering...\n");
        *ExtendedStatus = SPREG_REGSVR;
        try {

            RegisterStatus = RegisterRoutine();

            if(FAILED(RegisterStatus)) {

                d = RegisterStatus;

                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_OLE_CONTROL_API_FAILED,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );

                WriteLogError(OleControlData->LogContext,
                              SETUP_LOG_ERROR,
                              d);
            } else if(RegisterStatus) {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_WARNING,
                              MSG_LOG_OLE_CONTROL_API_WARN,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER),
                              RegisterStatus 
                              );
            } else {
                WriteLogEntry(OleControlData->LogContext,
                              SETUP_LOG_VERBOSE,
                              MSG_LOG_OLE_CONTROL_API_OK,
                              NULL,
                              OleControlData->FullPath,
                              OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                              );
            }

        } except (
            ExceptionPointers = GetExceptionInformation(),
            EXCEPTION_EXECUTE_HANDLER) {

            d = ExceptionPointers->ExceptionRecord->ExceptionCode;

            WriteLogEntry(
                OleControlData->LogContext,
                SETUP_LOG_ERROR,
                MSG_LOG_OLE_CONTROL_API_EXCEPTION,
                NULL,
                OleControlData->FullPath,
                OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                );
            DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in DllRegisterServer handled\n");

        }

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...registered\n");

    } else {

        d = GetLastError();

        WriteLogEntry(OleControlData->LogContext,
                      SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                      MSG_LOG_OLE_CONTROL_NOT_REGISTERED_GETPROC_FAILED,
                      NULL,
                      OleControlData->FullPath,
                      OleControlData->Register ? TEXT(DLLREGISTER) : TEXT(DLLUNREGISTER)
                      );

        WriteLogError(OleControlData->LogContext,
                      SETUP_LOG_ERROR,
                      d);


        *ExtendedStatus = SPREG_GETPROCADDR;

    }

    return d;
}

DWORD
pSetupRegisterLoadDll(
    IN  POLE_CONTROL_DATA OleControlData,
    OUT HMODULE *ControlDll
    )
/*++

Routine Description:

    get the module handle to the specified dll

Arguments:

    OleControlData - contains path to dll to be loaded

    ControlDll - module handle for the dll


Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;

    DWORD d = NO_ERROR;

    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: loading dll...\n");

#ifndef _WIN64
    if(Wow64) {
        //
        // don't remap directory the directory that the caller provided
        //
        Wow64DisableFilesystemRedirector(OleControlData->FullPath);
    }
#endif

    try {

        *ControlDll = LoadLibrary(OleControlData->FullPath);

    } except (
        ExceptionPointers = GetExceptionInformation(),
        EXCEPTION_EXECUTE_HANDLER) {
    }

#ifndef _WIN64
    if(Wow64) {
        //
        // re-enable the redirection on this file
        //
        Wow64EnableFilesystemRedirector();
    }
#endif

    if(ExceptionPointers) {

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_EXCEPTION,
            NULL,
            OleControlData->FullPath
            );

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...exception in LoadLibrary handled\n");
        d = ExceptionPointers->ExceptionRecord->ExceptionCode;

    } else if (!*ControlDll) {
        d = GetLastError();

        //
        // LoadLibrary failed.
        // File not found is not an error. We want to know about
        // other errors though.
        //

        d = GetLastError();

        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...dll not loaded (%u)\n",d);

        WriteLogEntry(
            OleControlData->LogContext,
            SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
            MSG_LOG_OLE_CONTROL_LOADLIBRARY_FAILED,
            NULL,
            OleControlData->FullPath
            );
        WriteLogError(
            OleControlData->LogContext,
            SETUP_LOG_ERROR,
            d
            );

    } else {
        DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: ...dll loaded\n");
    }

    return d;

}

BOOL
RegisterUnregisterControl(
    PWOW_IPC_REGION_TOSURRAGATE RegistrationData,
    PDWORD  FailureCode
    )
/*++

Routine Description:

    main registration routine for registering a dll.

Arguments:

    RegistrationData - pointer to WOW_IPC_REGION_TOSURRAGATE structure indicating
                       file to be processed
    FailureCode      - SPREG_* code indicating outcome of operation.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    LPEXCEPTION_POINTERS ExceptionPointers = NULL;
    HMODULE ControlDll = NULL;
    PTSTR Extension;
    DWORD d = NO_ERROR;
    DWORD Count;
    OLE_CONTROL_DATA OleControlData;
    WCHAR Path[MAX_PATH];
    PWSTR p;

    //
    // could use CoInitializeEx as an optimization as OleInitialize is
    // probably overkill...but this is probably just a perf hit at
    // worst
    //
    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: calling OleInitialize\n");

    OleControlData.FullPath = RegistrationData->FullPath;
    OleControlData.Argument = RegistrationData->Argument;
    OleControlData.LogContext = NULL;
    OleControlData.Register = RegistrationData->Register;
    OleControlData.RegType = RegistrationData->RegType;

    wcscpy(Path,RegistrationData->FullPath);
    p = wcsrchr(Path,'\\');
    if (p) {
       *p = L'\0';
    }

    SetCurrentDirectory( Path );

    d = (DWORD)OleInitialize(NULL);
    if (d != NO_ERROR) {
        *FailureCode = SPREG_UNKNOWN;
        DebugPrintEx(DPFLTR_ERROR_LEVEL,L"WOWREG32: OleInitialize failed, ec = 0x%08x\n", d);
        goto clean0;
    }



    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: back from OleInitialize\n");

        try {
            //
            // protect everything in TRY-EXCEPT, we're calling unknown code (DLL's)
            //
            d = pSetupRegisterLoadDll( &OleControlData, &ControlDll );

            if (d == NO_ERROR) {

                //
                // We successfully loaded it.  Now call the appropriate routines.
                //
                //
                // On register, do DLLREGISTER, then DLLINSTALL
                // On unregister, do DLLINSTALL, then DLLREGISTER
                //
                if (OleControlData.Register) {

                    if (OleControlData.RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllRegister(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );

                    }

                    if (OleControlData.RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllInstall(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );
                    }

                } else {

                    if (OleControlData.RegType & FLG_REGSVR_DLLINSTALL && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllInstall(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );
                    }

                    if (OleControlData.RegType & FLG_REGSVR_DLLREGISTER && (d == NO_ERROR) ) {

                        d = pSetupRegisterDllRegister(
                                            &OleControlData,
                                            ControlDll,
                                            FailureCode );

                    }


                }

            } else {
                ControlDll = NULL;
                *FailureCode = SPREG_LOADLIBRARY;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // If our exception was an AV, then use Win32 invalid param error, otherwise, assume it was
            // an inpage error dealing with a mapped-in file.
            //
            d = ERROR_INVALID_DATA;
            *FailureCode = SPREG_UNKNOWN;
        }

        if (ControlDll) {
            FreeLibrary(ControlDll);
        }

    OleUninitialize();

    DebugPrintEx(DPFLTR_TRACE_LEVEL,L"WOWREG32: back from OleUninitialize, exit RegisterUnregisterDll\n");

clean0:

    if (d == NO_ERROR) {
        *FailureCode = SPREG_SUCCESS;
    }

    SetLastError(d);

    return (d == NO_ERROR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\test\cmtest.h ===
//
// Menu defines
//
#define IDM_CONNECT_TEST      1000
#define IDM_DEVICE_LIST       1001
#define IDM_SERVICE_LIST      1002
#define IDM_RELATIONS_LIST    1003
#define IDM_DEVICE_OPS        1004
#define IDM_DEVNODE_KEY       1005
#define IDM_CLASS_LIST        1006
#define IDM_REGRESSION        1007
#define IDM_EXIT              1008

#define IDM_INIT_DETECTION    1100
#define IDM_REPORTLOGON       1101
#define IDM_PNPISA_DETECT     1102
#define IDM_DEVINSTALL        1103
#define IDM_SET_ASSOCIATIONS  1104
#define IDM_CLEAR_ASSOCIATIONS 1105
#define IDM_GET_PROPERTIES    1106
#define IDM_REGISTER_NOTIFY   1107
#define IDM_UNREGISTER_NOTIFY 1108

//
// CONNECT_DIALOG IDs
//
#define CONNECT_DIALOG                 2000
#define ID_RAD_LOCAL                   2001
#define ID_RAD_REMOTE                  2002
#define ID_ED_MACHINE                  2003

//
// DEVLIST_DIALOG IDs
//
#define DEVLIST_DIALOG                 2100
#define ID_LB_ENUMERATORS              2101
#define ID_LB_DEVICES                  2102
#define ID_LB_INSTANCES                2103

//
// DEVICE_DIALOG IDs
//
#define DEVICE_DIALOG                  2200
#define ID_LB_DEVICEIDS                2202
#define ID_BT_PARENT                   2203
#define ID_BT_CHILD                    2204
#define ID_BT_SIBLING                  2205
#define ID_ST_RELATED                  2206
#define ID_BT_REGPROP                  2207
#define ID_BT_SOFTWAREKEY              2208
#define ID_BT_DISABLE                  2209
#define ID_BT_ENABLE                   2210
#define ID_BT_MOVETO                   2211
#define ID_BT_SETUP                    2212
#define ID_BT_QUERY_REMOVE             2213
#define ID_BT_REMOVE                   2214
#define ID_BT_REENUMERATE              2215
#define ID_BT_HWPROFFLAG               2216
#define ID_BT_GETSTATUS                2217
#define ID_BT_SETPROBLEM               2218
#define ID_ST_STATUS                   2219
#define ID_ST_PROBLEM                  2220
#define ID_BT_RESOURCEPICKER           2221
#define ID_BT_CREATE                   2222

//
// CLASS_DIALOG IDs
//
#define CLASS_DIALOG                   2300
#define ID_LB_CLASSES                  2301
#define ID_BT_CLASSNAME                2302
#define ID_BT_CLASSKEY                 2303
#define ID_ST_CLASSNAME                2304

//
// CLASSKEY_DIALOG IDs
//
#define CLASSKEY_DIALOG                2400
#define ID_CHK_ALL_ACCESS              2401
#define ID_CHK_CREATE_LINK             2402
#define ID_CHK_CREATE_SUB_KEY          2403
#define ID_CHK_ENUMERATE_SUB_KEYS      2404
#define ID_CHK_EXECUTE                 2405
#define ID_CHK_NOTIFY                  2406
#define ID_CHK_QUERY_VALUE             2407
#define ID_CHK_READ                    2408
#define ID_CHK_SET_VALUE               2409
#define ID_CHK_WRITE                   2410
#define ID_CHK_CREATE                  2411
#define ID_ED_VALUENAME                2412
#define ID_ED_VALUEDATA                2413
#define ID_BT_QUERYVALUE               2414
#define ID_BT_SETVALUE                 2415
#define ID_ST_CLASSGUID                2416

//
// SOFTWAREKEY_DIALOG IDs
//
#define SOFTWAREKEY_DIALOG             2500
#define ID_ED_SUBKEY                   2501
#define ID_RAD_MACHINE                 2502
#define ID_RAD_USER                    2503
#define ID_RAD_CONFIG                  2504
#define ID_ED_PROFILE                  2505
#define ID_BT_CLEAR                    2506

//
// DEVNODEKEY_DIALOG IDs
//
#define DEVNODEKEY_DIALOG              2600
#define ID_RD_HW                       2601
#define ID_RD_SW                       2602
#define ID_RD_USER                     2603
#define ID_RD_CONFIG                   2604
#define ID_RD_NEITHER                  2605
#define ID_BT_OPENDEVKEY               2606
#define ID_BT_DELDEVKEY                2607
#define ID_ED_DEVICEID                 2608

//
// CREATE_DIALOG IDs
//
#define CREATE_DIALOG                  2700
#define ID_RD_NORMAL                   2701
#define ID_RD_NOWAIT                   2702
#define ID_CHK_PHANTOM                 2703
#define ID_ST_PARENT                   2704
#define ID_CHK_GENERATEID              2705

//
// SERVICES_DIALOG IDs
//
#define SERVICE_DIALOG                 2800
#define ID_ED_SERVICE                  2801
#define ID_LB_SERVICE                  2802
#define ID_BT_SERVICE                  2803

//
// REGRESSION_DIALOG IDs
//
#define REGRESSION_DIALOG              2900
#define ID_LB_REGRESSION               2901
#define ID_CHK_RANGE                   2902
#define ID_CHK_CLASS                   2903
#define ID_CHK_TRAVERSE                2904
#define ID_CHK_HWPROF                  2905
#define ID_CHK_DEVLIST                 2906
#define ID_CHK_LOGCONF                 2907
#define ID_BT_START                    2908
#define ID_CHK_PROPERTIES              2909
#define ID_CHK_DEVCLASS                2910

//
// RELATIONS_DIALOG IDs
//
#define RELATIONS_DIALOG               3000
#define ID_LB_TARGETS                  3001
#define ID_LB_RELATIONS                3002
#define ID_BT_BUS                      3003
#define ID_BT_REMOVAL                  3004
#define ID_BT_EJECTION                 3005
#define ID_BT_POWER                    3006

//
// Prototypes
//

BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ConnectDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK DeviceListDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK DeviceDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ClassDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ClassKeyDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK SoftwareKeyDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK DevKeyDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK CreateDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ServiceListDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK RelationsListDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK RegressionDlgProc(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\test\cmtest.c ===
/**------------------------------------------------------------------
   cmtest.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <setupapi.h>
#include "cmtest.h"
#include "pnptest.h"
#include <objbase.h>
#include <initguid.h>
#include <winioctl.h>
#include <dbt.h>
#include <pnpmgr.h>

//
// external prototypes
//
CONFIGRET
CMP_Init_Detection(
    IN ULONG    ulPrivateID
    );

CONFIGRET
CMP_Report_LogOn(
    IN ULONG    ulPrivateID,
    IN ULONG    ProccesID
    );

VOID
ConnectTest(
    HWND hWnd
    );

VOID
CallPnPIsaDetect(
    HWND   hDlg,
    LPTSTR pszDevice
    );

VOID
DumpDeviceChangeData(
    HWND   hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Private Prototypes
//


//
// Globals
//
HINSTANCE hInst;
TCHAR     szAppName[] = TEXT("CMTest");
TCHAR     szDebug[MAX_PATH];
TCHAR     szMachineName[MAX_PATH];
HMACHINE  hMachine = NULL;

DEFINE_GUID(FunctionClassGuid1, 0xAAAAAAA1L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0x01);
typedef BOOL (WINAPI *FP_DEVINSTALL)(HWND, LPCWSTR, BOOL, PDWORD);

//
// FROM NTOS\DD\WDM\DDK\INC\HIDCLASS.H
//
DEFINE_GUID( GUID_CLASS_INPUT, 0x4D1E55B2L, 0xF16F, 0x11CF, 0x88, 0xCB, 0x00, \
             0x11, 0x11, 0x00, 0x00, 0x30);

#define GUID_CLASS_INPUT_STR    TEXT("4D1E55B2-F16F-11CF-88CB-001111000030")


/**----------------------------------------------------------------------**/
int APIENTRY
WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR lpCmdLine,
   int nCmdShow
   )
{
   MSG msg;

   if (!InitApplication(hInstance)) {
         return FALSE;
   }

   if (!InitInstance(hInstance, nCmdShow)) {
      return FALSE;
   }

   while (GetMessage(&msg, NULL, 0, 0)) {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
   }

   return msg.wParam;

} // WinMain


/**----------------------------------------------------------------------**/
BOOL
InitApplication(
   HINSTANCE hInstance
   )
{
   WNDCLASS  wc;

   wc.style         = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc   = MainWndProc;
   wc.cbClsExtra    = 0;
   wc.cbWndExtra    = 0;
   wc.hInstance     = hInstance;
   wc.hIcon         = LoadIcon (hInstance, szAppName);
   wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
   wc.lpszMenuName  = szAppName;
   wc.lpszClassName = szAppName;

   return RegisterClass(&wc);

} // InitApplication


/**----------------------------------------------------------------------**/
BOOL
InitInstance(
   HINSTANCE hInstance,
   int nCmdShow
   )
{
   HWND  hWnd;
   WORD  CMVersion;
   ULONG CMState = 0;
   TCHAR szTitle[MAX_PATH];

   hInst = hInstance;

   CMVersion = CM_Get_Version();

   if (CM_Get_Global_State(&CMState, 0) != CR_SUCCESS) {
      MessageBeep(0);
   }

   wsprintf(szTitle, TEXT("CM API Test Harness - CM State = %x, CM Version %d.%d"),
            CMState, HIBYTE(CMVersion), LOBYTE(CMVersion));

   hWnd = CreateWindow(
      szAppName,
      szTitle,
      WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
      NULL,
      NULL,
      hInstance,
      NULL);

   if (!hWnd) {
      return FALSE;
   }

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;

} // InitInstance


/**----------------------------------------------------------------------**/
LRESULT CALLBACK
MainWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HANDLE hTestFile = NULL;
    DWORD size = 0;
    ULONG status, ulType, i;
    HDEVNOTIFY hDevNotify;
    HDEVNOTIFY hNotify[64];
    HDEVNOTIFY hNotifyDevNode = NULL;
    HANDLE hFile[64];
    DEV_BROADCAST_DEVICEINTERFACE FilterData;
    DEV_BROADCAST_HANDLE HandleData;
    BOOL bStatus = TRUE;
    FP_DEVINSTALL fpDevInstall = NULL;
    HMODULE       hModule = NULL;
    BOOL          bReboot = FALSE;
    GUID InterfaceGuid;
    LPTSTR pBuffer, p;
    TCHAR szDeviceId[MAX_PATH];
    DEVNODE dnDevNode;
    LPBYTE buffer;
    static ULONG count = 0;

    switch (message) {
        case WM_CREATE:
            DialogBox(hInst, MAKEINTRESOURCE(CONNECT_DIALOG), hWnd,
                      (DLGPROC)ConnectDlgProc);
            break;


        case WM_DEVICECHANGE:
            MessageBeep(0);
            DumpDeviceChangeData(hWnd, wParam, lParam);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {

                case IDM_CONNECT_TEST:
                    ConnectTest(hWnd);
                    break;

                case IDM_DEVICE_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(DEVLIST_DIALOG), hWnd,
                              (DLGPROC)DeviceListDlgProc);
                    break;

                case IDM_SERVICE_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(SERVICE_DIALOG), hWnd,
                              (DLGPROC)ServiceListDlgProc);
                    break;

                case IDM_RELATIONS_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(RELATIONS_DIALOG), hWnd,
                              (DLGPROC)RelationsListDlgProc);
                    break;
            
                case IDM_DEVICE_OPS:
                    DialogBox(hInst, MAKEINTRESOURCE(DEVICE_DIALOG), hWnd,
                              (DLGPROC)DeviceDlgProc);
                    break;

                case IDM_DEVNODE_KEY:
                    DialogBox(hInst, MAKEINTRESOURCE(DEVNODEKEY_DIALOG), hWnd,
                              (DLGPROC)DevKeyDlgProc);
                    break;

                case IDM_CLASS_LIST:
                    DialogBox(hInst, MAKEINTRESOURCE(CLASS_DIALOG), hWnd,
                              (DLGPROC)ClassDlgProc);
                    break;

                case IDM_REGRESSION:
                    DialogBox(hInst, MAKEINTRESOURCE(REGRESSION_DIALOG), hWnd,
                              (DLGPROC)RegressionDlgProc);
                    break;

                case IDM_EXIT:
                    DestroyWindow(hWnd);
                    break;

                case IDM_INIT_DETECTION:
                    CMP_Init_Detection(0x07020420);
                    break;

                case IDM_REPORTLOGON:
                    CMP_Report_LogOn(0x07020420, GetCurrentProcessId());
                    break;

                case IDM_PNPISA_DETECT:
                    CallPnPIsaDetect(hWnd, TEXT("Root\\Device001\\0000"));
                    break;

                case IDM_DEVINSTALL:
                    hModule = LoadLibrary(TEXT("newdev.cpl"));
                    if (hModule == NULL) {
                        OutputDebugString(TEXT("LoadLibrary of newdev.cpl failed\n"));
                        break;
                    }
         
                    if (!(fpDevInstall = (FP_DEVINSTALL)GetProcAddress(hModule, "InstallDevInst"))) {
                        OutputDebugString(TEXT("GetProcAddress failed\n"));
                        break;;
                    }
         
                    if (!(fpDevInstall)(NULL, L"PnPTest\\Pdo0\\Root&LEGACY_PNPTEST&0000&1111", FALSE, &bReboot)) {
                        OutputDebugString(TEXT("InstallDevInst failed\n"));
                    }
                    FreeLibrary(hModule);
                    break;


                //-----------------------------------------------------------
                // Notification
                //-----------------------------------------------------------

                case IDM_REGISTER_NOTIFY:
                
                    //
                    // Register for notification on pnptest interface devices
                    //
                    #if 0
                    wsprintf(szDebug, TEXT("CMTEST: Registering window %d for pnptest interface notification\n"), hWnd);
                    OutputDebugString(szDebug);

                    FilterData.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
                    FilterData.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
                    FilterData.dbcc_reserved = 0;
                    memcpy(&FilterData.dbcc_classguid, &FunctionClassGuid1, sizeof(GUID));
                    FilterData.dbcc_name[0] = 0x0;

                    hDevNotify = RegisterDeviceNotification(hWnd,
                                                            &FilterData,
                                                            DEVICE_NOTIFY_WINDOW_HANDLE);
                    #endif

                    //
                    // Register for notification on HID target devices
                    //
                
                    wsprintf(szDebug, TEXT("CMTEST: Registering window %d for hid target notification\n"), hWnd);
                    OutputDebugString(szDebug);

                    count = 0;
                    pBuffer = malloc(2048 * sizeof(TCHAR));
                    CM_Get_Device_Interface_List((LPGUID)&GUID_CLASS_INPUT, NULL, pBuffer, 2048,
                                                 CM_GET_DEVICE_INTERFACE_LIST_PRESENT);
                                
                    for (p = pBuffer; *p; p += lstrlen(p) + 1) {
                    
                        hFile[count] = CreateFile(p, GENERIC_READ | GENERIC_WRITE,
                                                  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    
                        if (hFile[count] != INVALID_HANDLE_VALUE) {
                        
                            wsprintf(szDebug, TEXT("    %s\n"), p);
                            OutputDebugString(szDebug);
    
                            HandleData.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                            HandleData.dbch_devicetype = DBT_DEVTYP_HANDLE;
                            HandleData.dbch_reserved = 0;
                            HandleData.dbch_handle = hFile[count];
                        
                            hNotify[count] = RegisterDeviceNotification(hWnd,
                                                                        &HandleData,
                                                                        DEVICE_NOTIFY_WINDOW_HANDLE);
                            count++;
                        } else {
                            status = GetLastError();
                        }
                    }
                    free(pBuffer);

                    //
                    // Register for notification on storage target devices
                    //
                
                    wsprintf(szDebug, TEXT("CMTEST: Registering window %d for storage target notification\n"), hWnd);
                    OutputDebugString(szDebug);

                    pBuffer = malloc(2048 * sizeof(TCHAR));
                    CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid, NULL, pBuffer, 2048,
                                                 CM_GET_DEVICE_INTERFACE_LIST_PRESENT);
                                
                    for (p = pBuffer; *p; p += lstrlen(p) + 1) {
                    
                        hFile[count] = CreateFile(p, GENERIC_READ | GENERIC_WRITE,
                                                  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                                  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    
                        if (hFile[count] != INVALID_HANDLE_VALUE) {
                        
                            wsprintf(szDebug, TEXT("    %s\n"), p);
                            OutputDebugString(szDebug);
    
                            HandleData.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
                            HandleData.dbch_devicetype = DBT_DEVTYP_HANDLE;
                            HandleData.dbch_reserved = 0;
                            HandleData.dbch_handle = hFile[count];
                        
                            hNotify[count] = RegisterDeviceNotification(hWnd,
                                                                        &HandleData,
                                                                        DEVICE_NOTIFY_WINDOW_HANDLE);
                            count++;
                        } else {
                            status = GetLastError();
                        }
                    }
                    break;

                case IDM_UNREGISTER_NOTIFY:
                    #if 0
                    bStatus = UnregisterDeviceNotification(hDevNotify);
                    #endif

                    for (i = 0; i < count; i++) {
                        if (hNotify[i]) {
                            bStatus = UnregisterDeviceNotification(hNotify[i]);
                        }
                        if (hFile[i]) {
                            CloseHandle(hFile[i]);
                        }
                    }
                    break;

                case IDM_SET_ASSOCIATIONS:
                    hTestFile = CreateFile(L"\\\\.\\PnPTest", GENERIC_READ | GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hTestFile == INVALID_HANDLE_VALUE) {
                        status = GetLastError();
                    }
                    DeviceIoControl(hTestFile, (DWORD)IOCTL_SET, NULL, 0, NULL, 0, &size, NULL);
                    CloseHandle(hTestFile);
                    break;

                case IDM_CLEAR_ASSOCIATIONS:
                    hTestFile = CreateFile(L"\\\\.\\PnPTest", GENERIC_READ | GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    DeviceIoControl(hTestFile, (DWORD)IOCTL_CLEAR, NULL, 0, NULL, 0, &size, NULL);
                    CloseHandle(hTestFile);
                    break;

                case IDM_GET_PROPERTIES:
                    lstrcpy(szDeviceId, TEXT("Root\\LEGACY_PNPTEST\\0000"));
                    UuidFromString(TEXT("aaaaaaa2-e3f0-101b-8488-00aa003e5601"), &InterfaceGuid);
                    pBuffer = malloc(1024);
                    CM_Get_Device_Interface_List(&InterfaceGuid, szDeviceId, pBuffer, 512,
                                                 CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

                    // use first returned interface device of that class
                    hTestFile = CreateFile(pBuffer, GENERIC_READ | GENERIC_WRITE,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hTestFile == INVALID_HANDLE_VALUE) {
                        status = GetLastError();
                    }
                    DeviceIoControl(hTestFile, (DWORD)IOCTL_GET_PROP, NULL, 0, NULL, 0, &size, NULL);
                    CloseHandle(hTestFile);
                
                    CM_Locate_DevNode(&dnDevNode, TEXT("Root\\LEGACY_PNPTEST\\0000"), CM_LOCATE_DEVNODE_NORMAL);
                
                    buffer = malloc(1024);
                    size = 1024;
                    status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_BUSTYPEGUID,
                                                              &ulType, buffer, &size, 0);            
                    size = 1024;
                    status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_LEGACYBUSTYPE,
                                                              &ulType, buffer, &size, 0);                
                    size = 1024;
                    status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_BUSNUMBER,
                                                              &ulType, buffer, &size, 0);
                    free(pBuffer);
                    free(buffer);
                    break;
            
                default:
                    return DefWindowProc(hWnd, message, wParam, lParam);
            }
            break;

        case WM_DESTROY:
            if (hMachine != NULL) {
                CM_Disconnect_Machine(hMachine);
            }
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;

} // MainWndProc



/**----------------------------------------------------------------------**/
LRESULT CALLBACK
ConnectDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status;
   WORD        CMLocalVersion, CMRemoteVersion;
   ULONG       CMState = 0;
   TCHAR       szTitle[MAX_PATH];


   switch (message) {
      case WM_INITDIALOG:
         CheckRadioButton(hDlg, ID_RAD_LOCAL, ID_RAD_REMOTE, ID_RAD_LOCAL);
         return TRUE;

   case WM_COMMAND:
      switch(LOWORD(wParam)) {

         case ID_RAD_LOCAL:
         case ID_RAD_REMOTE:
            CheckRadioButton(hDlg, ID_RAD_LOCAL, ID_RAD_REMOTE, LOWORD(wParam));
            break;

         case IDOK:
            if (IsDlgButtonChecked(hDlg, ID_RAD_LOCAL)) {
               hMachine = NULL;
            }
            else {
               // a NULL machine name just returns local machine handle
               GetDlgItemText(hDlg, ID_ED_MACHINE, szMachineName, MAX_PATH);
               Status = CM_Connect_Machine(szMachineName, &hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Connect_Machine failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  hMachine = NULL;
                  EndDialog(hDlg, FALSE);
                  return TRUE;
               }

               CMLocalVersion = CM_Get_Version();
               CMRemoteVersion = CM_Get_Version_Ex(hMachine);

               Status = CM_Get_Global_State(&CMState, 0);
               if (Status != CR_SUCCESS) {
                  MessageBeep(0);
               }

               wsprintf(szTitle,
                     TEXT("CM API Test Harness - CM State = %x, CM Version Local %d.%d, Remote %d.%d"),
                     CMState,
                     HIBYTE(CMLocalVersion), LOBYTE(CMLocalVersion),
                     HIBYTE(CMRemoteVersion), LOBYTE(CMRemoteVersion));

               SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)(LPSTR)szTitle);

            }
            EndDialog(hDlg, TRUE);
            return TRUE;

         default:
            break;
      }

   }
   return FALSE;

} // ConnectDlgProc


VOID
ConnectTest(
    HWND hWnd
    )
{
    CONFIGRET Status = CR_SUCCESS;
    TCHAR     szDeviceID[MAX_DEVICE_ID_LEN], szComputerName[MAX_PATH];
    ULONG     ulSize = 0;
    DEVINST   dnDevNode;
    HMACHINE  hMachine;


    //---------------------------------------------------------------
    // 1. Text implicit local machine call
    //---------------------------------------------------------------

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"),
          CM_LOCATE_DEVNODE_NORMAL);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN, 0);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }


    //---------------------------------------------------------------
    // 2. Test implicit local machine call using _Ex routines
    //---------------------------------------------------------------

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
          CM_LOCATE_DEVNODE_NORMAL, NULL);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN, 0, NULL);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }


    //---------------------------------------------------------------
    // 3. Test connecting to NULL (local) machine
    //---------------------------------------------------------------

    Status = CM_Connect_Machine(NULL, &hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
                                  CM_LOCATE_DEVNODE_NORMAL, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN,
                                 0, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }

    Status = CM_Disconnect_Machine(hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    //---------------------------------------------------------------
    // 4. Test explicit local machine call
    //---------------------------------------------------------------

    ulSize = MAX_PATH;
    GetComputerName(szComputerName, &ulSize);

    if (szComputerName[0] != TEXT('\\')) {

        TCHAR szTemp[MAX_PATH];

        lstrcpy(szTemp, szComputerName);
        lstrcpy(szComputerName, TEXT("\\\\"));
        lstrcat(szComputerName, szTemp);
    }

    Status = CM_Connect_Machine(szComputerName, &hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
                                  CM_LOCATE_DEVNODE_NORMAL, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN,
                                 0, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }

    Status = CM_Disconnect_Machine(hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }


    //---------------------------------------------------------------
    // 5. Test remote machine call
    //---------------------------------------------------------------

    Status = CM_Connect_Machine(TEXT("\\\\PAULAT_PPC1X"), &hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    szDeviceID[0] = 0x0;

    Status = CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"),
                                  CM_LOCATE_DEVNODE_NORMAL, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    Status = CM_Get_Device_ID_Ex(dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN,
                                 0, hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }

    if (lstrcmpi(szDeviceID, TEXT("Root\\Device001\\0000")) != 0) {
        goto Clean0;
    }

    Status = CM_Disconnect_Machine(hMachine);
    if (Status != CR_SUCCESS) {
       goto Clean0;
    }



    Clean0:

    if (Status == CR_SUCCESS) {
        MessageBox(hWnd, TEXT("Connect Test Passed"), TEXT("Connect Test"), MB_OK);
    } else {
        MessageBox(hWnd, TEXT("Connect Test Failed"), TEXT("Connect Test"), MB_OK);
    }

    return;

} // ConnectTest



BOOL
CALLBACK
AddPropSheetPageProc(
    IN HPROPSHEETPAGE hpage,
    IN LPARAM lParam
   )
{
    *((HPROPSHEETPAGE *)lParam) = hpage;
    return TRUE;
}



VOID
CallPnPIsaDetect(
    HWND hDlg,
    LPTSTR pszDevice
    )
{
    HMODULE         hLib = NULL;
    SP_DEVINFO_DATA DeviceInfoData;
    HDEVINFO        hDevInfo;
    FARPROC         PropSheetExtProc;
    PROPSHEETHEADER PropHeader;
    HPROPSHEETPAGE  hPages[2];

    SP_PROPSHEETPAGE_REQUEST PropParams;

    #if 0
    hLib = LoadLibrary(TEXT("setupapi.dll"));
    fproc = GetProcAddress(hLib, TEXT("DbgSelectDeviceResources"));
    Status = (fproc)(pszDevice);
    FreeLibrary(hLib);
    #endif

    //
    // Create a device info element and device info data set.
    //
    hDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (hDevInfo == INVALID_HANDLE_VALUE) {
        goto Clean0;
    }

    DeviceInfoData.cbSize  = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiOpenDeviceInfo(hDevInfo,
                               pszDevice,
                               NULL,
                               0,
                               &DeviceInfoData)) {
        goto Clean0;
    }

    //
    // Now get the resource selection page from setupapi.dll
    //
    if(!(hLib = GetModuleHandle(TEXT("setupapi.dll"))) ||
       !(PropSheetExtProc = GetProcAddress(hLib, "ExtensionPropSheetPageProc"))) {

        goto Clean0;
    }

    PropParams.cbSize = sizeof(SP_PROPSHEETPAGE_REQUEST);
    PropParams.PageRequested  = SPPSR_SELECT_DEVICE_RESOURCES;
    PropParams.DeviceInfoSet  = hDevInfo;
    PropParams.DeviceInfoData = &DeviceInfoData;

    if(!PropSheetExtProc(&PropParams, AddPropSheetPageProc, &hPages[0])) {
        goto Clean0;
    }

    //
    // create the property sheet
    //
    PropHeader.dwSize      = sizeof(PROPSHEETHEADER);
    PropHeader.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    PropHeader.hwndParent  = NULL;
    PropHeader.hInstance   = hInst;
    PropHeader.pszIcon     = NULL;
    PropHeader.pszCaption  = L"Device";
    PropHeader.nPages      = 1;
    PropHeader.phpage      = hPages;
    PropHeader.nStartPage  = 0;
    PropHeader.pfnCallback = NULL;

    PropertySheet(&PropHeader);

    SetupDiDestroyDeviceInfoList(hDevInfo);

    Clean0:
        ;

    return;

} // CallPnPIsaDetect


VOID
DumpDeviceChangeData(
    HWND   hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR szDbg[MAX_PATH];

    OutputDebugString(TEXT("CMTEST: WM_DEVICECHANGE message received\n"));

    switch (wParam) {
        case DBT_DEVICEARRIVAL:
            OutputDebugString(TEXT("   DBT_DEVICEARRIVAL event\n"));
            break;

        case DBT_DEVICEREMOVECOMPLETE:
            OutputDebugString(TEXT("   DBT_DEVICEREMOVECOMPLETE event\n"));
            break;

        case DBT_DEVICEQUERYREMOVE:
            OutputDebugString(TEXT("   DBT_DEVICEQUERYREMOVE event\n"));
            break;

        case DBT_DEVICEQUERYREMOVEFAILED:
            OutputDebugString(TEXT("   DBT_DEVICEQUERYREMOVEFAILED event\n"));
            break;

        case DBT_DEVICEREMOVEPENDING:
            OutputDebugString(TEXT("   DBT_DEVICEREMOVEPENDING event\n"));
            break;

        case DBT_DEVICETYPESPECIFIC:
            OutputDebugString(TEXT("   DBT_DEVICETYPESPECIFIC event\n"));
            break;

        case DBT_CUSTOMEVENT:
            OutputDebugString(TEXT("   DBT_CUSTOMEVENT event\n"));
            break;

        default:
            break;

    }

    switch (((PDEV_BROADCAST_HDR)lParam)->dbch_devicetype) {
        case DBT_DEVTYP_DEVICEINTERFACE:  {
            PDEV_BROADCAST_DEVICEINTERFACE p = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
            LPTSTR pString;
            OutputDebugString(TEXT("   DBT_DEVTYP_DEVICEINTERFACE\n"));
            wsprintf(szDbg,   TEXT("   %s\n"), p->dbcc_name);
            OutputDebugString(szDbg);
            UuidToString(&p->dbcc_classguid, &pString);
            wsprintf(szDbg,   TEXT("   %s\n"), pString);
            OutputDebugString(szDbg);
            break;
        }
        case DBT_DEVTYP_HANDLE:
            OutputDebugString(TEXT("         DBT_DEVTYP_HANDLE\n"));
            break;

        default:
            break;
    }

    wsprintf(szDbg,   TEXT("        wParam = %d\n"));
    OutputDebugString(szDbg);

} // DumpDeviceChangeData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\test\devinst.c ===
/**------------------------------------------------------------------
   devinst.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <malloc.h>

#include "cmtest.h"

//
// Private Prototypes
//

FillRelationsListBox(
    HWND  hDlg,
    ULONG RelationType
    );

BOOL
FillEnumeratorListBox(
   HWND hDlg
   );

BOOL
FillDeviceListBox(
   HWND hDlg
   );
BOOL
FillInstanceListBox(
   HWND hDlg
   );

BOOL
FillDeviceInstanceListBox(
   HWND hDlg
   );

BOOL
GetSelectedEnumerator(
   HWND   hDlg,
   LPTSTR szDevice
   );

BOOL
GetSelectedDevice(
   HWND   hDlg,
   LPTSTR szDevice
   );

BOOL
GetSelectedDevNode(
   HWND     hDlg,
   PDEVNODE pdnDevNode
   );

VOID
CallPnPIsaDetect(
    HWND   hDlg,
    LPTSTR pszDevice
    );

//
// Globals
//
extern HINSTANCE hInst;
extern TCHAR     szDebug[MAX_PATH];
extern TCHAR     szAppName[MAX_PATH];
extern HMACHINE  hMachine;


/**----------------------------------------------------------------------**/
LRESULT CALLBACK
DeviceListDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN+1];
   DEVNODE     dnDevNode;
   ULONG       ulStatus, ulProblem;

   switch (message) {
      case WM_SHOWWINDOW:
         FillEnumeratorListBox(hDlg);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_LB_ENUMERATORS:
               if (HIWORD(wParam) == LBN_SELCHANGE) {
                  FillDeviceListBox(hDlg);
               }
               break;

         case ID_LB_DEVICES:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
               FillInstanceListBox(hDlg);
            }
            break;


      }
      break;
   }
   return (FALSE);

} // DeviceListDlgProc


/**----------------------------------------------------------------------**/
LRESULT CALLBACK
ServiceListDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szService[MAX_PATH];
   LPTSTR      pBuffer, p;
   ULONG       ulSize;

   switch (message) {

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_BT_SERVICE:
               GetDlgItemText(hDlg, ID_ED_SERVICE, szService, MAX_PATH);

               //
               // get device list size for this service
               //
               Status = CM_Get_Device_ID_List_Size_Ex(&ulSize, szService,
                        CM_GETIDLIST_FILTER_SERVICE, hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               pBuffer = (PTSTR)LocalAlloc(LPTR, ulSize * sizeof(TCHAR));
               if (pBuffer == NULL) {
                  MessageBeep(0);
                  return FALSE;
               }

               //
               // to verify the null terminators are correct, fill with 1's
               //
               memset(pBuffer, 1, ulSize * sizeof(TCHAR));

               //
               // get device list for this service
               //
               Status = CM_Get_Device_ID_List_Ex(szService, pBuffer, ulSize,
                        CM_GETIDLIST_FILTER_SERVICE, hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               SendDlgItemMessage(
                     hDlg, ID_LB_SERVICE, LB_RESETCONTENT, 0, 0);

               p = (LPTSTR)pBuffer;
               while (*p != '\0') {

                  SendDlgItemMessage(
                        hDlg, ID_LB_SERVICE, LB_ADDSTRING, 0,
                        (LPARAM)(LPCTSTR)p);

                  while (*p != '\0') {
                     p++;               // skip to next substring
                  }
                  p++;                 // skip over null terminator
               }

               SendDlgItemMessage(hDlg, ID_LB_SERVICE, LB_SETSEL, TRUE, 0);
               LocalFree(pBuffer);
               break;
      }

      break;
   }
   return (FALSE);

} // ServiceListDlgProc



/**----------------------------------------------------------------------**/
LRESULT CALLBACK
RelationsListDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    TCHAR       szDevice[MAX_DEVICE_ID_LEN];
    LPTSTR      pBuffer, p;
    ULONG       Size;
    LONG        Index;

    switch (message) {

        case WM_INITDIALOG:
            //
            // Fill list box with all known device instances so user can just
            // point at the device instance they want to query relations for.
            //
            SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_RESETCONTENT, 0, 0);

            Status = CM_Get_Device_ID_List_Size_Ex(&Size, NULL,
                                                   CM_GETIDLIST_FILTER_NONE, hMachine);
            if (Status != CR_SUCCESS) {
                return FALSE;
            }
       
            pBuffer = (PTSTR)malloc(Size * sizeof(TCHAR));
            if (pBuffer == NULL) {
                return FALSE;
            }
       
            Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, Size,
                                              CM_GETIDLIST_FILTER_NONE, hMachine);       
            if (Status != CR_SUCCESS) {
                return FALSE;
            }
       
            for (p = pBuffer; *p; p += lstrlen(p) + 1) {
                SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_ADDSTRING, 0,
                                   (LPARAM)(LPCTSTR)p);
            }
       
            SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_SETSEL, TRUE, 0);
            free(pBuffer);
            return TRUE;
       

        case WM_COMMAND:
            switch(LOWORD(wParam)) {

                case IDOK:
                    EndDialog(hDlg, TRUE);
                    return TRUE;

                case ID_BT_BUS:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_BUSRELATIONS);
                    break;

                case ID_BT_POWER:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_POWERRELATIONS);
                    break;

                case ID_BT_REMOVAL:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_REMOVALRELATIONS);
                    break;

                case ID_BT_EJECTION:
                    FillRelationsListBox(hDlg, CM_GETIDLIST_FILTER_EJECTRELATIONS);
                    break;
            }
            break;
    }
    return (FALSE);

} // RelationsListDlgProc



FillRelationsListBox(
    HWND  hDlg,
    ULONG RelationType
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    TCHAR       szDevice[MAX_DEVICE_ID_LEN];
    LPTSTR      pBuffer, p;
    ULONG       Size;
    LONG        Index;
    
    SendDlgItemMessage(hDlg, ID_LB_RELATIONS, LB_RESETCONTENT, 0, 0);
            
    //
    // Which device instance was selected
    //
    Index = SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_GETCURSEL, 0, 0);
    if (Index == LB_ERR || Index == 0) {
        return FALSE;
    }
         
    SendDlgItemMessage(hDlg, ID_LB_TARGETS, LB_GETTEXT, (WPARAM)Index,
                       (LPARAM)(LPCTSTR)szDevice);
         
    //
    // How big a buffer to hold the relations list?
    //
    Status = CM_Get_Device_ID_List_Size_Ex(&Size, szDevice, RelationType, hMachine);
    if (Status != CR_SUCCESS) {
        wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
        MessageBox(hDlg, szDebug, szAppName, MB_OK);
        return FALSE;
    }

    pBuffer = (PTSTR)malloc(Size * sizeof(TCHAR));
    if (pBuffer == NULL) {
        return FALSE;
    }

    //
    // to verify the null terminators are correct, fill with 1's
    //
    memset(pBuffer, 1, Size * sizeof(TCHAR));

    //
    // Retrieve and display the relations list
    //
    Status = CM_Get_Device_ID_List_Ex(szDevice, pBuffer, Size, RelationType, hMachine);
    if (Status != CR_SUCCESS) {
        wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
        MessageBox(hDlg, szDebug, szAppName, MB_OK);
        return FALSE;
    }

    for (p = pBuffer; *p; p += lstrlen(p) + 1) {
        SendDlgItemMessage(hDlg, ID_LB_RELATIONS, LB_ADDSTRING, 0,
                           (LPARAM)(LPCTSTR)p);
    }

    free(pBuffer);
    return TRUE;

} // FillRelationsListBox


/**----------------------------------------------------------------------**/
LRESULT CALLBACK
DeviceDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN+1];
   DEVNODE     dnDevNode;
   ULONG       ulStatus, ulProblem;
   ULONG       err;

   switch (message) {
      case WM_SHOWWINDOW:
         FillDeviceInstanceListBox(hDlg);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_BT_SOFTWAREKEY:
               DialogBox(hInst, MAKEINTRESOURCE(SOFTWAREKEY_DIALOG), hDlg,
                     (DLGPROC)SoftwareKeyDlgProc);
               break;

            case ID_BT_ENABLE:
               if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                  MessageBeep(0);
                  break;
               }

               Status = CM_Enable_DevNode_Ex(dnDevNode, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Enable_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  break;
               }
               break;


            case ID_BT_DISABLE:
               if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                  MessageBeep(0);
                  break;
               }

               Status = CM_Disable_DevNode_Ex(dnDevNode, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Disable_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  break;
               }
               break;

            case ID_BT_CREATE:
               GetSelectedDevice(hDlg, szDevice);
               DialogBoxParam(hInst, MAKEINTRESOURCE(CREATE_DIALOG), hDlg,
                        (DLGPROC)CreateDlgProc, (LPARAM)(LPCTSTR)szDevice);
               break;

            case ID_BT_GETSTATUS:
               if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                  MessageBeep(0);
                  break;
               }

               Status = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                     dnDevNode, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Get_DevNode_Status failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  break;
               }

               wsprintf(szDebug, TEXT("%08xh"), ulStatus);
               SetDlgItemText(hDlg, ID_ST_STATUS, szDebug);
               wsprintf(szDebug, TEXT("%08xh"), ulProblem);
               SetDlgItemText(hDlg, ID_ST_PROBLEM, szDebug);
               break;

            case ID_BT_SETPROBLEM:
                if (!GetSelectedDevNode(hDlg, &dnDevNode)) {
                    MessageBeep(0);
                    break;
                }

                ulProblem = GetDlgItemInt(hDlg, ID_ST_PROBLEM, &err, FALSE);
                Status = CM_Set_DevNode_Problem_Ex(dnDevNode, ulProblem, 0, hMachine);
                if (Status != CR_SUCCESS) {
                    wsprintf(szDebug, TEXT("CM_Get_DevNode_Status failed (%xh)"), Status);
                    MessageBox(hDlg, szDebug, szAppName, MB_OK);
                }
                break;
            
            case ID_BT_QUERY_REMOVE:
                GetSelectedDevNode(hDlg, &dnDevNode);
                Status = CM_Query_Remove_SubTree(dnDevNode, CM_QUERY_REMOVE_UI_OK);
                if (Status != CR_SUCCESS) {
                   wsprintf(szDebug, TEXT("CM_Get_Query_Remove_SubTree failed (%xh)"), Status);
                   MessageBox(hDlg, szDebug, szAppName, MB_OK);
                   break;
                }                
                break;

            case ID_BT_REMOVE:
                GetSelectedDevNode(hDlg, &dnDevNode);
                Status = CM_Remove_SubTree(dnDevNode, CM_REMOVE_UI_OK);
                if (Status != CR_SUCCESS) {
                   wsprintf(szDebug, TEXT("CM_Get_Query_Remove_SubTree failed (%xh)"), Status);
                   MessageBox(hDlg, szDebug, szAppName, MB_OK);
                   break;
                }                
                break;

            case ID_BT_RESOURCEPICKER:
                GetSelectedDevice(hDlg, szDevice);
                CallPnPIsaDetect(hDlg, szDevice);
                break;
      }
      break;
   }
   return (FALSE);

} // DeviceDlgProc


/**----------------------------------------------------------------------**/
LRESULT CALLBACK
DevKeyDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDeviceID[MAX_DEVICE_ID_LEN];
   DEVNODE     dnDevNode;
   ULONG       ulFlags, ulProfile, ulValue;
   HKEY        hKey = NULL;

   switch (message) {
      case WM_INITDIALOG:
         CheckDlgButton(hDlg, ID_RD_HW, 1);
         CheckDlgButton(hDlg, ID_RD_USER, 1);
         SetDlgItemInt(hDlg, ID_ED_PROFILE, 0xFFFFFFFF, FALSE);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {

            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;


            case ID_BT_OPENDEVKEY:
               GetDlgItemText(hDlg, ID_ED_DEVICEID, szDeviceID, MAX_DEVICE_ID_LEN);

               Status = CM_Locate_DevNode_Ex(&dnDevNode, szDeviceID, 0, hMachine);
               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               ulFlags = 0;

               if (IsDlgButtonChecked(hDlg, ID_RD_HW)) {
                  ulFlags |= CM_REGISTRY_HARDWARE;
               } else {
                  ulFlags |= CM_REGISTRY_SOFTWARE;
               }

               if (IsDlgButtonChecked(hDlg, ID_RD_USER)) {
                  ulFlags |= CM_REGISTRY_USER;
               }
               else if (IsDlgButtonChecked(hDlg, ID_RD_CONFIG)) {
                  ulFlags |= CM_REGISTRY_CONFIG;
                  ulProfile = (ULONG)GetDlgItemInt(hDlg, ID_ED_PROFILE, NULL, TRUE);
               }

               Status = CM_Open_DevNode_Key_Ex(
                     dnDevNode, KEY_READ | KEY_WRITE, ulProfile,
                     RegDisposition_OpenAlways, &hKey, ulFlags, hMachine);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Open_DevNode_Key failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               ulValue = 13;
               RegSetValueEx(hKey, TEXT("CustomValue"), 0, REG_DWORD,
                     (LPBYTE)&ulValue, 4);
               RegCloseKey(hKey);
               break;

         case ID_BT_DELDEVKEY:
            GetDlgItemText(hDlg, ID_ED_DEVICEID, szDeviceID, MAX_DEVICE_ID_LEN);

            Status = CM_Locate_DevNode_Ex(&dnDevNode, szDeviceID, 0, hMachine);
            if (Status != CR_SUCCESS) {
               wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               return FALSE;
            }

            ulFlags = 0;

            if (IsDlgButtonChecked(hDlg, ID_RD_HW)) {
               ulFlags |= CM_REGISTRY_HARDWARE;
            } else {
               ulFlags |= CM_REGISTRY_SOFTWARE;
            }

            if (IsDlgButtonChecked(hDlg, ID_RD_USER)) {
               ulFlags |= CM_REGISTRY_USER;
            }
            else if (IsDlgButtonChecked(hDlg, ID_RD_CONFIG)) {
               ulFlags |= CM_REGISTRY_CONFIG;
               ulProfile = (ULONG)GetDlgItemInt(hDlg, ID_ED_PROFILE, NULL, TRUE);
            }

            Status = CM_Delete_DevNode_Key_Ex(
                  dnDevNode, ulProfile, ulFlags, hMachine);

            if (Status != CR_SUCCESS) {
               wsprintf(szDebug, TEXT("CM_Delete_DevNode_Key failed (%xh)"), Status);
               MessageBox(hDlg, szDebug, szAppName, MB_OK);
               return FALSE;
            }
      }
      break;
   }
   return (FALSE);

} // DevKeyDlgProc


/**----------------------------------------------------------------------**/
BOOL
FillEnumeratorListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       ulIndex, Size;
   TCHAR       szEnumerator[MAX_PATH];

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_RESETCONTENT, 0, 0);

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_ADDSTRING, 0,
         (LPARAM)(LPCTSTR)TEXT("(All)"));

   ulIndex = 0;
   Status = CR_SUCCESS;

   while (Status == CR_SUCCESS) {

      Size = MAX_PATH;
      Status = CM_Enumerate_Enumerators_Ex(
            ulIndex, szEnumerator, &Size, 0, hMachine);

      if (Status == CR_NO_SUCH_VALUE) {
         // no more enumerators, break out of the loop
         break;
      }

      if (Status != CR_SUCCESS) {
         wsprintf(szDebug, TEXT("CM_Enumerate_Enumerators failed (%xh)"), Status);
         MessageBox(hDlg, szDebug, szAppName, MB_OK);
         return FALSE;
      }

      SendDlgItemMessage(
            hDlg, ID_LB_ENUMERATORS, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)szEnumerator);

      ulIndex++;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_SETSEL, TRUE, 0);

   return TRUE;

} // FillEnumeratorListBox


/**----------------------------------------------------------------------**/
BOOL
FillDeviceListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       Size, i;
   TCHAR       szEnumerator[MAX_PATH];
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];
   PTSTR       pBuffer, p;

   if (!GetSelectedEnumerator(hDlg, szEnumerator)) {
      MessageBeep(0);
      return FALSE;
   }

   if (*szEnumerator == '\0') {
      Status = CM_Get_Device_ID_List_Size_Ex(&Size, NULL,
                                CM_GETIDLIST_FILTER_NONE, hMachine);
   }
   else {
      Status = CM_Get_Device_ID_List_Size_Ex(&Size, szEnumerator,
                                CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);
   }

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   i = Size * sizeof(TCHAR);

   pBuffer = (PTSTR)malloc(i);
   if (pBuffer == NULL) {
      MessageBeep(0);
      return FALSE;
   }

   if (*szEnumerator == '\0') {
      Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, Size,
                                CM_GETIDLIST_FILTER_NONE, hMachine);
   }
   else {
      Status = CM_Get_Device_ID_List_Ex(szEnumerator, pBuffer, Size,
                                CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);
   }

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_RESETCONTENT, 0, 0);

   for (p = pBuffer; *p; p += lstrlen(p) + 1) {

       SendDlgItemMessage(
             hDlg, ID_LB_DEVICES, LB_ADDSTRING, 0,
             (LPARAM)(LPCTSTR)p);
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_SETSEL, TRUE, 0);

   free(pBuffer);

   return TRUE;

} // FillDeviceListBox


/**----------------------------------------------------------------------**/
BOOL
FillInstanceListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       Size;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];
   PTSTR       pBuffer, p;
   LONG        Index;


   Index = SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICES, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szDevice);

   // truncate the instance part
   p = szDevice;
   while (*p != '\\') p++;
   p++;
   while (*p != '\\') p++;
   *p = '\0';

   Status = CM_Get_Device_ID_List_Size_Ex(&Size, szDevice,
                             CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   pBuffer = (PTSTR)LocalAlloc(LPTR, Size * sizeof(TCHAR));
   if (pBuffer == NULL) {
      MessageBeep(0);
      return FALSE;
   }

   Status = CM_Get_Device_ID_List_Ex(szDevice, pBuffer, Size,
                             CM_GETIDLIST_FILTER_ENUMERATOR, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_INSTANCES, LB_RESETCONTENT, 0, 0);

   p = (LPTSTR)pBuffer;
   while (*p != '\0') {

      SendDlgItemMessage(
            hDlg, ID_LB_INSTANCES, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)p);

      while (*p != '\0') {
         p++;               // skip to next substring
      }
      p++;                 // skip over null terminator
   }

   SendDlgItemMessage(
         hDlg, ID_LB_INSTANCES, LB_SETSEL, TRUE, 0);

   LocalFree(pBuffer);

   return TRUE;

} // FillInstanceListBox


/**----------------------------------------------------------------------**/
BOOL
FillDeviceInstanceListBox(
   HWND hDlg
   )
{
   CONFIGRET   Status;
   ULONG       Size;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];
   PTSTR       pBuffer, p;

   //
   // get device list size for all enumerators
   //
   Status = CM_Get_Device_ID_List_Size_Ex(&Size, NULL,
                        CM_GETIDLIST_FILTER_NONE, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List_Size failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   pBuffer = (PTSTR)LocalAlloc(LPTR, Size * sizeof(TCHAR));
   if (pBuffer == NULL) {
      MessageBeep(0);
      return FALSE;
   }

   //
   // to verify the null terminators are correct, fill with 1's
   //
   memset(pBuffer, 1, Size * sizeof(TCHAR));

   //
   // get device list for all enumerators
   //
   Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, Size,
                        CM_GETIDLIST_FILTER_NONE, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Get_Device_ID_List failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICEIDS, LB_RESETCONTENT, 0, 0);

   p = (LPTSTR)pBuffer;
   while (*p != '\0') {

      SendDlgItemMessage(
            hDlg, ID_LB_DEVICEIDS, LB_ADDSTRING, 0,
            (LPARAM)(LPCTSTR)p);

      while (*p != '\0') {
         p++;               // skip to next substring
      }
      p++;                 // skip over null terminator
   }

   SendDlgItemMessage(hDlg, ID_LB_DEVICEIDS, LB_SETSEL, TRUE, 0);
   LocalFree(pBuffer);
   return TRUE;

} // FillDeviceInstanceListBox


/**----------------------------------------------------------------------**/
BOOL
GetSelectedEnumerator(
   HWND   hDlg,
   LPTSTR szEnumerator
   )
{
   LONG  Index;

   Index = SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_ENUMERATORS, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szEnumerator);

   if (lstrcmpi(szEnumerator, TEXT("(All)")) == 0) {
      *szEnumerator = '\0';    // if All selected, then no Enumerator specified
   }
   return TRUE;

} // GetSeletectedEnumerator


/**----------------------------------------------------------------------**/
BOOL
GetSelectedDevice(
   HWND   hDlg,
   LPTSTR szDevice
   )
{
   LONG  Index;

   Index = SendDlgItemMessage(
         hDlg, ID_LB_DEVICEIDS, LB_GETCURSEL, 0, 0);
   if (Index == LB_ERR || Index == 0) {
      MessageBeep(0);
      return FALSE;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_DEVICEIDS, LB_GETTEXT, (WPARAM)Index,
         (LPARAM)(LPCTSTR)szDevice);

   return TRUE;

} // GetSeletectedDevice


/**----------------------------------------------------------------------**/
BOOL
GetSelectedDevNode(
   HWND     hDlg,
   PDEVNODE pdnDevNode
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDevice[MAX_DEVICE_ID_LEN];

   if (!GetSelectedDevice(hDlg, szDevice)) {
      return FALSE;
   }

   Status = CM_Locate_DevNode_Ex(pdnDevNode, szDevice, 0, hMachine);

   if (Status != CR_SUCCESS) {
      wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
      MessageBox(hDlg, szDebug, szAppName, MB_OK);
      return FALSE;
   }

   return TRUE;

} // GetSelectedDevNode



/**----------------------------------------------------------------------**/
LRESULT CALLBACK
SoftwareKeyDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;

   switch (message) {
      case WM_INITDIALOG:
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {
            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            default:
               break;
         }
   }
   return (FALSE);

} // SoftwareKeyDlgProc



/**----------------------------------------------------------------------**/
LRESULT CALLBACK
CreateDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDeviceID[MAX_DEVICE_ID_LEN];
   TCHAR       szParentID[MAX_DEVICE_ID_LEN];
   DEVNODE     dnDevNode, dnParentDevNode;
   ULONG       ulFlags;

   switch (message) {

      case WM_INITDIALOG:
         SetDlgItemText(hDlg, ID_ST_PARENT, (LPCTSTR)lParam);
         CheckDlgButton(hDlg, ID_RD_NORMAL, 1);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {

            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;


            case ID_BT_CREATE:
               SetDlgItemText(hDlg, ID_ST_STATUS, TEXT(""));
               GetDlgItemText(hDlg, ID_ED_DEVICEID, szDeviceID, MAX_DEVICE_ID_LEN);
               GetDlgItemText(hDlg, ID_ST_PARENT, szParentID, MAX_DEVICE_ID_LEN);

               ulFlags = CM_CREATE_DEVNODE_NORMAL;

               if (IsDlgButtonChecked(hDlg, ID_CHK_GENERATEID)) {
                  ulFlags |= CM_CREATE_DEVNODE_GENERATE_ID;
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_PHANTOM)) {
                  ulFlags |= CM_CREATE_DEVNODE_PHANTOM;
               }

               Status = CM_Locate_DevNode(
                  &dnParentDevNode, szParentID, 0);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Locate_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               Status = CM_Create_DevNode(
                   &dnDevNode, szDeviceID, dnParentDevNode, ulFlags);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Create_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               memset(szDeviceID, 0, MAX_DEVICE_ID_LEN * sizeof(TCHAR));

               Status = CM_Get_Device_ID(
                  dnDevNode, szDeviceID, MAX_DEVICE_ID_LEN, 0);

               if (Status != CR_SUCCESS) {
                  wsprintf(szDebug, TEXT("CM_Create_DevNode failed (%xh)"), Status);
                  MessageBox(hDlg, szDebug, szAppName, MB_OK);
                  return FALSE;
               }

               wsprintf(szDebug, TEXT("%s created"),
                  szDeviceID);
               SetDlgItemText(hDlg, ID_ST_STATUS, szDebug);
               break;
      }
      break;
   }
   return (FALSE);

} // CreateDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\test\regress.c ===
/**------------------------------------------------------------------
   regress.c
------------------------------------------------------------------**/


//
// Includes
//
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <malloc.h>
#include <regstr.h>
#include "cmtest.h"

//
// Private Prototypes
//
VOID
RegressionTest_Range(
    HWND  hDlg
    );

VOID
RegressionTest_Class(
    HWND  hDlg
    );

VOID
RegressionTest_Traverse(
    HWND  hDlg
    );

VOID
RegressionTest_HardwareProfile(
    HWND  hDlg
    );

VOID
RegressionTest_DeviceList(
    HWND  hDlg
    );

VOID
RegressionTest_LogConf(
    HWND  hDlg
    );

VOID
RegressionTest_CreateDevNode(
    HWND  hDlg
    );

VOID
RegressionTest_Properties(
    HWND  hDlg
    );

VOID
RegressionTest_DeviceClass(
    HWND  hDlg
    );

BOOL
DisplayRange(
    IN HWND  hDlg,
    IN RANGE_LIST rlh
    );

BOOL
TraverseAndCheckParents (
    DEVNODE dnParent
    );


//
// Globals
//

TCHAR szPresentDeviceID[] =         TEXT("Test\\Present\\0000");
TCHAR szNonExistantDeviceID[] =     TEXT("Test\\XXX\\0000");
TCHAR szInvalidDeviceID[] =         TEXT("Test\\0000");
TCHAR szNotFoundDeviceID[] =        TEXT("Test\\NotFound\\0000");
TCHAR szMovedDeviceID[] =           TEXT("Test\\Moved\\0000");
TCHAR szNoBaseDeviceID[] =          TEXT("Test\\NoBaseDevice\\0000");
TCHAR szMissingParentDeviceID[] =   TEXT("Test\\ParentMissing\\0000");
TCHAR szNotFoundParentDeviceID[] =  TEXT("Test\\ParentNotFound\\0000");
TCHAR szMovedParentDeviceID[] =     TEXT("Test\\ParentMoved\\0000");
TCHAR szNoAttachedDeviceID[] =      TEXT("Test\\NoAttachedComponents\\0000");
TCHAR szMissingChildDeviceID[] =    TEXT("Test\\ChildMissing\\0000");
TCHAR szNotFoundChildDeviceID[] =   TEXT("Test\\ChildNotFound\\0000");
TCHAR szMovedChildDeviceID[] =      TEXT("Test\\ChildMoved\\0000");
TCHAR szValid2ndChildDeviceID[] =   TEXT("Test\\Valid2ndChild\\0000");
TCHAR szMissingSiblingDeviceID[] =  TEXT("Test\\SiblingMissing\\0000");
TCHAR szNotFoundSiblingDeviceID[] = TEXT("Test\\SiblingNotFound\\0000");
TCHAR szMovedSiblingDeviceID[] =    TEXT("Test\\SiblingMoved\\0000");
TCHAR szValid3rdChildDeviceID[] =   TEXT("Test\\Valid3rdChild\\0000");
TCHAR szEnabledDeviceID[] =         TEXT("Test\\Enabled\\0000");
TCHAR szDisabledDeviceID[] =        TEXT("Test\\Disabled\\0000");
TCHAR szCreateDeviceID[] =          TEXT("Test\\Create\\0000");
TCHAR szDoNotCreateDeviceID[] =     TEXT("Test\\DoNotCreate\\0000");
TCHAR szPhantomDeviceID[] =         TEXT("Test\\Phantom\\0000");
TCHAR szRemoveDeviceID[] =          TEXT("Test\\Remove\\0000");
TCHAR szClassGuid_0[] =             TEXT("{00000000-0000-0000-0000-000000000000}");
TCHAR szClassGuid_None[] =          TEXT("{99999999-9999-9999-9999-999999999999}");

TCHAR szDev_MovedTo[] =             TEXT("TEST\\MovedTo\\0000");
TCHAR szDev_MovedFrom[] =           TEXT("TEXT\\MovedFrom\\0000");

extern HMACHINE  hMachine;


/**----------------------------------------------------------------------**/
LRESULT CALLBACK
RegressionDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   TCHAR       szDeviceID[MAX_DEVICE_ID_LEN];
   TCHAR       szParentID[MAX_DEVICE_ID_LEN];
   DEVNODE     dnDevNode, dnParentDevNode;
   ULONG       ulFlags;

   switch (message) {

      case WM_INITDIALOG:
         SetDlgItemText(hDlg, ID_ST_PARENT, (LPCTSTR)lParam);
         CheckDlgButton(hDlg, ID_RD_NORMAL, 1);
         return TRUE;

      case WM_COMMAND:
         switch(LOWORD(wParam)) {

            case IDOK:
               EndDialog(hDlg, TRUE);
               return TRUE;

            case ID_BT_CLEAR:
               SendDlgItemMessage(
                     hDlg, ID_LB_REGRESSION, LB_RESETCONTENT, 0, 0);
               break;

            case ID_BT_START:
               if (IsDlgButtonChecked(hDlg, ID_CHK_RANGE)) {
                  RegressionTest_Range(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_CLASS)) {
                  RegressionTest_Class(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_TRAVERSE)) {
                  RegressionTest_Traverse(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_HWPROF)) {
                  RegressionTest_HardwareProfile(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_DEVLIST)) {
                  RegressionTest_DeviceList(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_LOGCONF)) {
                  RegressionTest_LogConf(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_CREATE)) {
                  RegressionTest_CreateDevNode(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_PROPERTIES)) {
                  RegressionTest_Properties(hDlg);
               }

               if (IsDlgButtonChecked(hDlg, ID_CHK_DEVCLASS)) {
                  RegressionTest_DeviceClass(hDlg);
               }
         }
         break;
   }
   return FALSE;

} // RegressionDlgProc


//-----------------------------------------------------------------------------
VOID
RegressionTest_Range(
      HWND  hDlg
      )
{
   CONFIGRET      Status = CR_SUCCESS;
   RANGE_LIST     rlh1, rlh2, rlh3;
   RANGE_ELEMENT  rElement;
   DWORDLONG      ullStart, ullEnd;
   TCHAR          szMsg[MAX_PATH], szMsg1[MAX_PATH];


   lstrcpy(szMsg, TEXT("1. Create Range List: "));
   Status = CM_Create_Range_List(&rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }

   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //------------------------------------------------------
   // Add range test
   //------------------------------------------------------

   lstrcpy(szMsg, TEXT("2. Add Ranges: "));
   Status = CM_Add_Range(12, 15, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(12,15) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   Status = CM_Add_Range(7, 9, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(7,9) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   Status = CM_Add_Range(21, 25, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(21,25) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // A1
   Status = CM_Add_Range(4, 5, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(4,5) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // A2
   Status = CM_Add_Range(11, 13, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(11,13) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // A3
   Status = CM_Add_Range(20, 26, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(20,26) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // B1
   Status = CM_Add_Range(6, 8, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(6,8) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // B2
   Status = CM_Add_Range(14, 16, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(14,16) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // special cases
   Status = CM_Add_Range(10, 14, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("(10,14) Failed (%xh)"), Status);
      goto DoneAddingRanges;
   }
   DisplayRange(hDlg, rlh1);

   // add "join" cases
   DoneAddingRanges:

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   // conflict cases
   Status = CM_Add_Range(2, 4, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(2,4) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(20, 22, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(20,22) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(10, 12, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(10,12) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(26, 28, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(26,28) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Add_Range(18, 30, rlh1, CM_ADD_RANGE_DONOTADDIFCONFLICT);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("(18,30) Should've Failed due to conflict"));
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }


   //------------------------------------------------------
   // Duplicate range list test
   //------------------------------------------------------

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("_____Duplicate Range List Test__________"));

   Status = CM_Create_Range_List(&rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Create_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg1);
      return;
   }

   // new range is empty
   Status = CM_Dup_Range_List(rlh1, rlh2, 0);
   if (Status != CR_SUCCESS) {
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Dup failed to empty range list"));
      return;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Original Range:"));
   DisplayRange(hDlg, rlh1);

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Duplicated Range:"));
   DisplayRange(hDlg, rlh2);


   // new range is not empty
   Status = CM_Dup_Range_List(rlh1, rlh2, 0);
   if (Status != CR_SUCCESS) {
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Dup failed to non-empty range list"));
      return;
   }

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Original Range:"));
   DisplayRange(hDlg, rlh1);

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Duplicated Range:"));
   DisplayRange(hDlg, rlh2);



   //------------------------------------------------------
   // Delete range list test
   //------------------------------------------------------

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("_____Delete Range Test__________"));


   Status = CM_Delete_Range(1,3, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (1,3)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(17,19, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (17,19)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(27,30, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (27,30)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(3,6, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (3,6)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(13,16, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (13,16)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(8,10, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (8,10)"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(9,21, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (9,21)"));
   DisplayRange(hDlg, rlh2);


   // special cases

   Status = CM_Delete_Range(0,DWORD_MAX, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (0,DWORD_MAX)"));
   DisplayRange(hDlg, rlh2);

   // re-dup range list 2 again, it's currently empty

   CM_Dup_Range_List(rlh1, rlh2, 0);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Resetting range list to:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Delete_Range(0,DWORDLONG_MAX, rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Delete_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Deleting (0,DWORDLONG_MAX)"));
   DisplayRange(hDlg, rlh2);



   //------------------------------------------------------
   // Test range available
   //------------------------------------------------------

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("______Test Range Available____________"));
   DisplayRange(hDlg, rlh1);


   Status = CM_Test_Range_Available(0, 2, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (0,2) is available (expected)"));
   } else {
      wsprintf(szMsg, TEXT("Range (0,2) not available (%d)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(17, 19, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (17,19) is available (expected)"));
   } else {
      wsprintf(szMsg, TEXT("Range (17,19) not available (%d)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(30, 40, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (30,40) is available (expected)"));
   } else {
      wsprintf(szMsg, TEXT("Range (30,40) not available (%d)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(3, 4, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (3,4) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (3,4) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(26, 50, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (26,50) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (26,50) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(16, 20, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (16,20) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (16,20) not available, %d (epxected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(3, 21, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (3,21) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (3,21) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(5, 24, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (5,24) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (5,24) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Test_Range_Available(24, 25, rlh1, 0);
   if (Status == CR_SUCCESS) {
      lstrcpy(szMsg, TEXT("Range (24,25) is available"));
   } else {
      wsprintf(szMsg, TEXT("Range (24,25) not available, %d (expected)"), Status);
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //------------------------------------------------------
   // Invert Range test
   //------------------------------------------------------


   Status = CM_Create_Range_List(&rlh3, 0);

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Original range to invert:"));
   DisplayRange(hDlg, rlh1);


   Status = CM_Invert_Range_List(rlh1, rlh2, 100, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting into empty range:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Invert_Range_List(rlh1, rlh2, 25, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting into non-empty range, MAX=25:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Invert_Range_List(rlh1, rlh2, 50, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting into non-empty range, MAX=50:"));
   DisplayRange(hDlg, rlh2);


   Status = CM_Invert_Range_List(rlh3, rlh2, 1000, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Invert_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Inverting from empty range, MAX = 1000:"));
   DisplayRange(hDlg, rlh2);



   //------------------------------------------------------
   // Free range list test
   //------------------------------------------------------

   Status = CM_Free_Range_List(rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Free_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Free_Range_List(rlh2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Free_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Free_Range_List(rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Free_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   Status = CM_Free_Range_List(rlh3, 0);
   if (Status != CR_INVALID_RANGE_LIST) {
       lstrcpy(szMsg, TEXT("Error: freeing already free list should have failed"));
   } else {
       lstrcpy(szMsg, TEXT("Freeing a freed list caused expected error"));
   }

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)szMsg);



   //------------------------------------------------------
   // Intersection test
   //------------------------------------------------------

   CM_Create_Range_List(&rlh1, 0);
   CM_Add_Range(1, 3, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(13, 18, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(25, 27, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(30, 36, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(42, 45, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(48, 52, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   DisplayRange(hDlg, rlh1);

   CM_Create_Range_List(&rlh2, 0);
   CM_Add_Range(8, 9, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(12, 14, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(17, 19, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(32, 34, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(40, 50, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   DisplayRange(hDlg, rlh2);

   CM_Create_Range_List(&rlh3, 0);

   Status = CM_Intersect_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Intersect_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected intersection: (13,14)(17,18)(32,34)(42,45)(48,50):"));
   DisplayRange(hDlg, rlh3);


   //------------------------------------------------------
   // Merge (union) test
   //------------------------------------------------------

   // use same rlh1 and rlh2 from the intersection test, non-emptry rlh3
   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: (1,3)(8,9)(12,19)(25,27)(30,36)(40,52)"));
   DisplayRange(hDlg, rlh3);


   // both ranges empty
   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh2, 0);
   CM_Create_Range_List(&rlh1, 0);
   CM_Create_Range_List(&rlh2, 0);

   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: none"));
   DisplayRange(hDlg, rlh3);


   // first range empty
   CM_Add_Range(8, 9, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(12, 14, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(17, 19, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(32, 34, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(40, 50, rlh2, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: (8,9)(12,14)(17,19)(32,34)(40,50)"));
   DisplayRange(hDlg, rlh3);


   // second range empty
   CM_Free_Range_List(rlh2, 0);
   CM_Create_Range_List(&rlh2, 0);

   CM_Add_Range(1, 3, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(13, 18, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(25, 27, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(30, 36, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(42, 45, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_Add_Range(48, 52, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Merge_Range_List(rlh1, rlh2, rlh3, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Merge_Range_List Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Expected union: (1,3)(13,18)(25,27)(30,36)(42,45)(48,52)"));
   DisplayRange(hDlg, rlh3);


   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh2, 0);
   CM_Free_Range_List(rlh3, 0);


   //------------------------------------------------------
   // Find Range test
   //------------------------------------------------------


   CM_Create_Range_List(&rlh1, 0);

   // should be a hit on the first try

   CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Find_Range(&ullStart, 256, 512, 0xFFFFFFFFFFFFFFF0, 1024, rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Test_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   wsprintf(szMsg, TEXT("Found Range at %d (expecting 256)"), (DWORD)ullStart);
   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   // should find it but after skipping one range

   CM_Add_Range(300, 320, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Find_Range(&ullStart, 256, 512, 0xFFFFFFFFFFFFFFF0, 1024, rlh1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Test_Range Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   wsprintf(szMsg, TEXT("Found Range at %d (expecting 336)"), (DWORD)ullStart);
   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   // should fail the find

   CM_Add_Range(500, 600, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);

   Status = CM_Find_Range(&ullStart, 256, 512, 0xFFFFFFFFFFFFFFF0, 1024, rlh1, 0);
   if (Status != CR_FAILURE) {
      wsprintf(szMsg, TEXT("CM_Test_Range should have Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }
   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Test range failed as expected"));



   CM_Free_Range_List(rlh1, 0);


   //---------------------------------------------------------------------
   // Special Test 1 - error condition found by LeslieF
   //---------------------------------------------------------------------

   CM_Create_Range_List(&rlh1, 0);      // Create range list.
   CM_Add_Range(0, 50, rlh1, CM_ADD_RANGE_ADDIFCONFLICT); // Add range [0-50].
   CM_Delete_Range(0, 9, rlh1, 0);      // Delete the range [0-9].
   CM_Delete_Range(21, 29, rlh1, 0);        // Delete the range [21-29].
   CM_Delete_Range(41, 50, rlh1, 0);        // Delete the range [41-50].

   // There should be two ranges left [10-20] and [30-40].
   CM_First_Range(rlh1, &ullStart, &ullEnd, &rElement, 0);
   CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);

   SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)TEXT("Special Test 1, expected (10,20),(30,40)"));
   DisplayRange(hDlg, rlh1);
   CM_Free_Range_List(rlh1, 0);

   //---------------------------------------------------------------------
   // Special Test 2 - error condition found by LeslieF
   //---------------------------------------------------------------------

   Status = CM_Dup_Range_List(0, 0,0);
   if (Status == CR_INVALID_RANGE_LIST) {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 2 - passed"));
   } else {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 2 - failed"));
   }

   //---------------------------------------------------------------------
   // Special Test 3 - error condition found by LeslieF
   //---------------------------------------------------------------------

   Status = CM_Find_Range(NULL, 0, 0, 0, 0, 0, 0);
   if (Status == CR_INVALID_RANGE_LIST) {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 3 - passed"));
   } else {
      SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
             (LPARAM)(LPTSTR)TEXT("Special Test 3 - failed"));
   }

   //---------------------------------------------------------------------
   // Special Test 4 - error condition found by LeslieF
   //---------------------------------------------------------------------

   CM_Create_Range_List(&rlh1, 0);
   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh1, 0);

   //---------------------------------------------------------------------
   // Special Test 5 - error condition found by LeslieF
   //---------------------------------------------------------------------

   CM_Intersect_Range_List(0, 0, 0, 0);
   CM_Invert_Range_List(0, 0, 0, 0);
   CM_Merge_Range_List(0, 0, 0, 0);


   //---------------------------------------------------------------------
   // Special Test 6 - error condition found by LeslieF
   //---------------------------------------------------------------------

    CM_Create_Range_List(&rlh1, 0);
    CM_Create_Range_List(&rlh2, 0);
    // Add range [10-20].
    CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    // Add range [30-40].
    CM_Add_Range(30, 40, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    // Duplicate range list.
    CM_Dup_Range_List(rlh1, rlh2, 0);
    // There should be two ranges in rlh2, [10-20] and [30-40].
    // Get the first.
    CM_First_Range(rlh2, &ullStart, &ullEnd, &rElement, 0);
    // Get the next.
    CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);  // *** Returns CR_FAILURE *** Should return CR_SUCCESS
    // Free the range lists.
    CM_Free_Range_List(rlh1, 0);
    CM_Free_Range_List(rlh2, 0);


    // Example2:
    CM_Create_Range_List(&rlh1, 0);
    CM_Create_Range_List(&rlh2, 0);
    // Add range [10-20][30-40].
    CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    CM_Add_Range(30, 40, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    // Invert range list.
    CM_Invert_Range_List(rlh1, rlh2, 40, 0);
    // There should be two ranges [0-9] and [21-29].
    // Get the first.
    CM_First_Range(rlh2, &ullStart, &ullEnd, &rElement, 0);
    // Get the next.
    CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);  // *** Returns CR_FAILURE *** Should return CR_SUCCESS
    // Free the range lists.
    CM_Free_Range_List(rlh1, 0);
    CM_Free_Range_List(rlh2, 0);


   //---------------------------------------------------------------------
   // Special Test 7 - error condition found by LeslieF
   //---------------------------------------------------------------------

    CM_Create_Range_List(&rlh1, 0);
    CM_Add_Range(10, 20, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    CM_Add_Range(30, 40, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
    Status = CM_Test_Range_Available(9, 21, rlh1, 0);
    if (Status != CR_FAILURE) {
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
               (LPARAM)(LPTSTR)TEXT("Special Test 7 - failed"));
    }
    CM_Free_Range_List(rlh1, 0);


   //---------------------------------------------------------------------
   // Special Test 8 - error condition found by Bogdan
   //---------------------------------------------------------------------


   CM_Create_Range_List(&rlh1, 0);
   CM_Create_Range_List(&rlh2, 0);

   CM_Add_Range(0, 10, rlh1, CM_ADD_RANGE_ADDIFCONFLICT);
   CM_First_Range(rlh1, &ullStart, &ullEnd, &rElement, 0);

   if (ullStart != 0 || ullEnd != 10) {
       SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)TEXT("Special Test 8 - failure 1"));
   }
   // As expected, ullStart = 0 and ullEnd = 10

   CM_Invert_Range_List(rlh1, rlh2, 20, 0);
   CM_First_Range(rlh2, &ullStart, &ullEnd, &rElement, 0);
// Expected ullStart = 11, ullEnd = 20, but ullStart = 0 and ullEnd = 0xFFFFFFFFFFFFFFFFF
// The next range is correct one [11, 20]

   //CM_Next_Range(&rElement, &ullStart, &ullEnd, 0);


   CM_Free_Range_List(rlh1, 0);
   CM_Free_Range_List(rlh2, 0);
   CM_Free_Range_List(rlh2, 0); // test deleting already deleted range list


   return;

} // RegressionTest_Range



//-----------------------------------------------------------------------------
VOID
RegressionTest_Class(
      HWND  hDlg
      )
{
    CONFIGRET   Status = CR_SUCCESS;
    GUID        ClassGuid;
    UUID        ClassUuid;
    TCHAR       szClass[MAX_CLASS_NAME_LEN];
    DEVNODE     dnDevNode;
    TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH];
    ULONG       ulStatus=0, ulProblem=0, ulLength = 0, ulSize = 0, i = 0;
    PTSTR       pBuffer = NULL;
    HKEY        hKey = NULL, hKey1 = NULL;


    #if 0
    i = 0;
    while (Status == CR_SUCCESS) {

        Status = CM_Enumerate_Classes_Ex(i, &ClassGuid, 0, hMachine);

        if (Status == CR_SUCCESS) {

            ulLength = MAX_CLASS_NAME_LEN;

            Status = CM_Get_Class_Name(&ClassGuid, szClass, &ulLength, 0);

            if (Status == CR_SUCCESS) {

                wsprintf(szMsg, TEXT("Class %d, Name: %s"), i, szClass);
                SendDlgItemMessage(
                     hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                     (LPARAM)(LPTSTR)szMsg);
            }
        }
        i++;
    }

    return;




   Status = CM_Locate_DevNode(&dnDevNode, NULL, 0);
   if (Status != CR_SUCCESS) {
      MessageBox(hDlg, TEXT("Locate Root failed"), TEXT("Test"), MB_OK);
      return;
   }

   Status = CM_Reenumerate_DevNode(dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      MessageBox(hDlg, TEXT("Reenumeration of Root Failed"), TEXT("Test"), MB_OK);
   }



   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Test\\A1\\0000"), 0);
   if (Status != CR_SUCCESS) {
      return;
   }


   lstrcpy(szMsg, TEXT("1. Reenumerate Test\\A1\\0000: "));
   Status = CM_Reenumerate_DevNode(dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Test\\A2\\0001"), 0);
   if (Status != CR_SUCCESS) {
      return;
   }


   lstrcpy(szMsg, TEXT("2. QueryRemove SubTree Test\\A2\\0001: "));
   Status = CM_Query_Remove_SubTree(dnDevNode, CM_QUERY_REMOVE_UI_OK);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Remove SubTree Test\\A2\\0001: "));
   Status = CM_Remove_SubTree(dnDevNode, CM_REMOVE_UI_OK);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   #endif

   lstrcpy(szMsg, TEXT("Test Delete Class Key only, no other keys exist"));

   UuidFromString(TEXT("00000000-0000-0000-0000-000000000000"), &ClassGuid);


   Status = CM_Open_Class_Key(&ClassGuid, TEXT("Madeup class"), KEY_ALL_ACCESS,
                              RegDisposition_OpenAlways, &hKey, 0);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Open_Class_Key Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("CM_Open_Class_Key Passed"));

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg1);
   RegCloseKey(hKey);



   Status = CM_Delete_Class_Key(&ClassGuid, CM_DELETE_CLASS_ONLY);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test Delete Class Key only, subkeys exist"));

   UuidFromString(TEXT("00000000-0000-0000-0000-000000000001"), &ClassGuid);

   Status = CM_Delete_Class_Key(&ClassGuid, CM_DELETE_CLASS_ONLY);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test Delete Class Key, subkeys too"));

   UuidFromString(TEXT("00000000-0000-0000-0000-000000000002"), &ClassGuid);

   Status = CM_Open_Class_Key(&ClassGuid, NULL, KEY_ALL_ACCESS,
                              RegDisposition_OpenAlways, &hKey, 0);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Open_Class_Key Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("CM_Open_Class_Key Passed"));

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg1);

   RegCreateKeyEx(hKey, TEXT("Subkey1"), 0, NULL, REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS, NULL, &hKey1, NULL);

   MessageBox(NULL, TEXT("Does 0000...0002\\SubKey1 exist?"), TEXT("Test"), MB_OK);
   RegCloseKey(hKey);
   RegCloseKey(hKey1);



   Status = CM_Delete_Class_Key(&ClassGuid, CM_DELETE_CLASS_SUBKEYS);

   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"), 0);
   if (Status != CR_SUCCESS) {
      return;
   }


   lstrcpy(szMsg, TEXT("4. Get Status for Test\\A2\\0001: "));
   Status = CM_Get_DevNode_Status(&ulStatus, &ulProblem, dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Status=%xh, Problem=%xh"), ulStatus, ulProblem);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);
   return;

} // RegressionTest_Class



//-----------------------------------------------------------------------------
VOID
RegressionTest_Traverse(
      HWND  hDlg
      )
{
   CONFIGRET Status = CR_SUCCESS;
   TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
   DEVNODE   dnDevNode, dnRootDevNode, dnChildDevNode, dnParentDevNode;
   TCHAR     Buffer[512];
   ULONG     ulDepth;


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____TRAVERSE REGRESSION TEST_____"));

   /*
   lstrcpy(szMsg, TEXT("1. Get parent of invalid devnode: "));
   Status = CM_Get_Parent(&dnDevNode, 1, 0);
   if (Status != CR_INVALID_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("2. Get parent of root: "));
   CM_Locate_DevNode(&dnRootDevNode, NULL, 0);
   Status = CM_Get_Parent(&dnDevNode, dnRootDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Get parent with no BaseDevicePath value: "));
   CM_Locate_DevNode(&dnDevNode, szNoBaseDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("4. Get parent that doesn't exist in registry: "));
   CM_Locate_DevNode(&dnDevNode, szMissingParentDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("5. Get parent that isn't marked as found: "));
   CM_Locate_DevNode(&dnDevNode, szNotFoundParentDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   wsprintf(szMsg, TEXT("6. Get parent that has been moved: "));
   CM_Locate_DevNode(&dnDevNode, szMovedParentDeviceID, 0);
   Status = CM_Get_Parent(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("7. Get valid parent: "));
   Status = CM_Locate_DevNode(&dnDevNode, szPresentDeviceID, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed Locate (%xh)"), Status);
   }
   else {
      Status = CM_Get_Parent(&dnParentDevNode, dnDevNode, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed (DevNode=%xh)"), dnDevNode);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("8. Get child of invalid devnode: "));
   Status = CM_Get_Child(&dnDevNode, 1, 0);
   if (Status != CR_INVALID_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("9. Get child with no AttachedComponents: "));
   CM_Locate_DevNode(&dnDevNode, szNoAttachedDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("10. Get child that doesn't exist in registry: "));
   CM_Locate_DevNode(&dnDevNode, szMissingChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("11. Get child that isn't marked as found: "));
   CM_Locate_DevNode(&dnDevNode, szNotFoundChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("12. Get child that has been moved: "));
   CM_Locate_DevNode(&dnDevNode, szMovedChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("13. First child isn't valid: "));
   CM_Locate_DevNode(&dnDevNode, szValid2ndChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("14. Get valid child: "));
   Status = CM_Get_Child(&dnChildDevNode, dnParentDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("15. Get sibling of invalid devnode: "));
   Status = CM_Get_Sibling(&dnDevNode, 1, 0);
   if (Status != CR_INVALID_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("16. Get sibling of Root: "));
   Status = CM_Get_Sibling(&dnDevNode, dnRootDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("17. Get sibling with no AttachedComponents: "));
   CM_Locate_DevNode(&dnDevNode, szNoAttachedDeviceID, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("18. Get sibling that doesn't exist in registry: "));
   CM_Locate_DevNode(&dnDevNode, szMissingSiblingDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("19. Get sibling that isn't marked as found: "));
   CM_Locate_DevNode(&dnDevNode, szNotFoundSiblingDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("20. Get sibling that has been moved: "));
   CM_Locate_DevNode(&dnDevNode, szMovedSiblingDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
   if (Status != CR_NO_SUCH_DEVNODE) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   wsprintf(szMsg, TEXT("21. First sibling isn't valid: "));
   CM_Locate_DevNode(&dnDevNode, szValid3rdChildDeviceID, 0);
   Status = CM_Get_Child(&dnDevNode, dnDevNode, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Get Child Failed (%xh)"), Status);
   } else {
      Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);
   */

   wsprintf(szMsg, TEXT("Finding all children of %s:"), szPresentDeviceID);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   CM_Locate_DevNode(&dnDevNode, szPresentDeviceID, 0);
   CM_Get_Child(&dnDevNode, dnDevNode, 0);
   CM_Get_Device_ID(dnDevNode, Buffer, MAX_PATH, 0);
   wsprintf(szMsg, TEXT("   Child DeviceID = %s (DevNode = %d)"),
         Buffer, dnDevNode);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   while (Status == CR_SUCCESS) {
      Status = CM_Get_Sibling(&dnDevNode, dnDevNode, 0);

      if (Status == CR_SUCCESS) {
         CM_Get_Device_ID(dnDevNode, Buffer, MAX_PATH, 0);
         wsprintf(szMsg, TEXT("   Sibling DeviceID = %s (DevNode = %d)"),
               Buffer, dnDevNode);

         SendDlgItemMessage(
               hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
               (LPARAM)(LPTSTR)szMsg);
      }
   }

   if (Status != CR_NO_SUCH_DEVINST) {
      wsprintf(szMsg, TEXT("CM_Get_Sibling failed (%xh)"), Status);

      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
   }


   //----------------------------------------------------------------
   // Do recursive traversal test
   //----------------------------------------------------------------


    // Create a new node.
    Status = CM_Locate_DevNode_Ex(&dnRootDevNode, NULL, 0, hMachine);
    if (Status == CR_SUCCESS) {
        if (TraverseAndCheckParents(dnRootDevNode)) {

            SendDlgItemMessage(
                  hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                  (LPARAM)(LPTSTR)TEXT("Recursive Traversal Test: PASSED"));

        } else {

            SendDlgItemMessage(
                  hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                  (LPARAM)(LPTSTR)TEXT("Recursive Traversal Test: FAILED"));
        }

    } else {
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)TEXT("Locate Root DevNode: FAILED"));
    }



   //----------------------------------------------------------------
   // Get Depth Test
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Get Depth of Root: "));
   CM_Locate_DevNode_Ex(&dnDevNode, NULL, 0, hMachine);
   Status = CM_Get_Depth_Ex(&ulDepth, dnDevNode, 0, hMachine);
   if (Status != CR_SUCCESS  || ulDepth != 0) {
      wsprintf(szMsg1, TEXT("Failed, Depth = %d (%xh)"), ulDepth, Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Depth = %d (%xh)"), ulDepth, Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Get Depth of 1st Level Node: "));
   CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device001\\0000"), 0, hMachine);
   Status = CM_Get_Depth_Ex(&ulDepth, dnDevNode, 0, hMachine);
   if (Status != CR_SUCCESS  || ulDepth != 1) {
      wsprintf(szMsg1, TEXT("Failed, Depth = %d (%xh)"), ulDepth, Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Depth = %d (%xh)"), ulDepth, Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Get Depth of 2nd Level Node: "));
   CM_Locate_DevNode_Ex(&dnDevNode, TEXT("Root\\Device002\\0000"), 0, hMachine);
   Status = CM_Get_Depth_Ex(&ulDepth, dnDevNode, 0, hMachine);
   if (Status != CR_SUCCESS  || ulDepth != 2) {
      wsprintf(szMsg1, TEXT("Failed, Depth = %d (%xh)"), ulDepth, Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, Depth = %d (%xh)"), ulDepth, Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   return;

} // RegressionTest_Traverse



//-----------------------------------------------------------------------------
VOID
RegressionTest_HardwareProfile(
    HWND  hDlg
    )
{
    CONFIGRET Status;
    TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
    DEVNODE   dnDevNode;
    TCHAR     Buffer[512];
    HWPROFILEINFO     HWProfileInfo;
    ULONG     ulValue = 0, Index =0;
    ULONG   C0 = CSCONFIGFLAG_DO_NOT_CREATE;
    ULONG   C1 = CSCONFIGFLAG_DO_NOT_START;
    ULONG   C2 = CSCONFIGFLAG_DISABLED;


    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____HARDWARE PROFILES REGRESSION TEST_____"));


    /*
    lstrcpy(szMsg, TEXT("Get HwProf Flags for Missing Device ID: "));
    Status = CM_Get_HW_Prof_Flags(szNonExistantDeviceID, 0, &ulValue, 0);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for invalid config: "));
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 13, &ulValue, 0);
    if (Status != CR_REGISTRY_ERROR) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);



    //---------------------------------------------------------------
    // Profile 1
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Set HwProf Flags for config 1: "));
    Status = CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 1, C1, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, C1);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, C1);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for config 1: "));
    ulValue = 0;
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 1, &ulValue, 0);
    if (Status != CR_SUCCESS || C1 != ulValue) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, ulValue);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);



    //---------------------------------------------------------------
    // Profile 2
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Set HwProf Flags for config 2: "));
    Status = CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 2, C2, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, C2);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, C2);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for config 2: "));
    ulValue = 0;
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 2, &ulValue, 0);
    if (Status != CR_SUCCESS || C2 != ulValue) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, ulValue);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    //---------------------------------------------------------------
    // Current Profile
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Set HwProf Flags for current config: "));
    Status = CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 0, C0, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, C0);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, C0);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Get Hw Profile for current config: "));
    ulValue = 0;
    Status = CM_Get_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 0, &ulValue, 0);
    if (Status != CR_SUCCESS || C0 != ulValue) {
        wsprintf(szMsg1, TEXT("Failed (%xh), Flags = %xh"), Status, ulValue);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh), Flags = %xh"), Status, ulValue);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);

    */

    //---------------------------------------------------------------
    // Test CM_Get_HW_Prof_Info
    //---------------------------------------------------------------

    lstrcpy(szMsg, TEXT("Get HwProf Info test:"));

    Status = CM_Get_Hardware_Profile_Info_Ex(0xFFFFFFFF, &HWProfileInfo, 0, hMachine);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

    wsprintf(szMsg, TEXT("   Current (%u) HW Profile: %s, Flags=%xh"),
            HWProfileInfo.HWPI_ulHWProfile,
            HWProfileInfo.HWPI_szFriendlyName,
            HWProfileInfo.HWPI_dwFlags);

    SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);


    Index = 0;
    Status = CR_SUCCESS;

    while (Status == CR_SUCCESS) {

        Status = CM_Get_Hardware_Profile_Info(Index, &HWProfileInfo, 0);

        if (Status == CR_SUCCESS) {

            wsprintf(szMsg, TEXT("   HW Profile %u: %s, Flags=%xh"),
                HWProfileInfo.HWPI_ulHWProfile,
                HWProfileInfo.HWPI_szFriendlyName,
                HWProfileInfo.HWPI_dwFlags);

            SendDlgItemMessage(
                hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                (LPARAM)(LPTSTR)szMsg);
        }
        Index++;
    }


   // reset to pre-test conditions
   CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 0, 0, 0);
   CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 1, 0, 0);
   CM_Set_HW_Prof_Flags(TEXT("Root\\Device001\\0000"), 2, 0, 0);

   return;

} // RegressionTest_HardwareProfile



//-----------------------------------------------------------------------------
VOID
RegressionTest_DeviceList(
      HWND  hDlg
      )
{
    CONFIGRET   Status = CR_SUCCESS;
    PTSTR       pBuffer = NULL, p = NULL;
    ULONG       ulSize = 0;
    TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH];
    TCHAR       pDeviceID[MAX_PATH];
    GUID        InterfaceGuid;
    TCHAR       szAlias[MAX_PATH];


    lstrcpy(szMsg, TEXT("Test Device ID List Size:"));

    Status = CM_Get_Device_ID_List_Size_Ex(&ulSize, NULL,
                             CM_GETIDLIST_FILTER_NONE, hMachine);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test Device ID List:"));

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, ulSize,
                              CM_GETIDLIST_FILTER_NONE, hMachine);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Device ID List (small buffer):"));

    Status = CM_Get_Device_ID_List_Ex(NULL, pBuffer, ulSize/2,
                              CM_GETIDLIST_FILTER_NONE, NULL);

    if (Status != CR_BUFFER_SMALL) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

    free(pBuffer);


    // initialize device instance and interface guid for tests

    lstrcpy(pDeviceID, TEXT("Root\\PnPTest\\0000"));
    UuidFromString(TEXT("aaaaaaa2-e3f0-101b-8488-00aa003e5601"), &InterfaceGuid);

    // Test 1.  No DevNode, Get Present

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 1 - No Devnode, Get-present"));
/*
    Status = CM_Get_Interface_Device_List_Size(&ulSize, &InterfaceGuid, 0,
                        CM_GET_INTERFACE_DEVICE_LIST_PRESENT);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);
*/
ulSize = 0x53;

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, 0, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {

        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    free(pBuffer);


    // Test 2. Devnode specified, Get Present

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 2 - Devnode, Get-present"));

    Status = CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, pDeviceID,
                        CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, pDeviceID, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_PRESENT);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    free(pBuffer);


    // Test 3. No Devnode, Get All

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 3 - No Devnode, Get-all"));

    Status = CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, 0,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, 0, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);

            ulSize = MAX_PATH; 
            Status = CM_Get_Device_Interface_Alias(p, &InterfaceGuid, szAlias, &ulSize, 0);
            if (Status == CR_SUCCESS) {
                wsprintf(szMsg, TEXT("Alias: %s"), szAlias);
                SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                       (LPARAM)(LPTSTR)szMsg);
            } else {
                wsprintf(szMsg, TEXT("Error getting alias, %d"), Status);
                SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                       (LPARAM)(LPTSTR)szMsg);
            }
        }
    }

    free(pBuffer);


    // Test 4. Devnode specified, Get All

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 4 - Devnode, Get-all"));

    Status = CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, pDeviceID,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status == CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Size = %d"), ulSize);
    } else {
        wsprintf(szMsg, TEXT("Error getting size, %d"), Status);
    }
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    Status = CM_Get_Device_Interface_List(&InterfaceGuid, pDeviceID, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Status = %d"), Status);

        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {

            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    free(pBuffer);


    // Test 5. Get aliases

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)TEXT("Test 5 - Get aliases"));
    
    CM_Get_Device_Interface_List_Size(&ulSize, &InterfaceGuid, pDeviceID,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    pBuffer = malloc(ulSize * sizeof(TCHAR));

    CM_Get_Device_Interface_List(&InterfaceGuid, pDeviceID, pBuffer, ulSize,
                        CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES);

    for (p = pBuffer; *p; p += lstrlen(pBuffer) + 1) {
        ulSize = MAX_PATH; 
        Status = CM_Get_Device_Interface_Alias(p, &InterfaceGuid, szAlias, &ulSize, 0);
        if (Status == CR_SUCCESS) {        
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                   (LPARAM)(LPTSTR)szAlias);
        } else {
            wsprintf(szMsg, TEXT("Error getting alias, %d"), Status);
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                                   (LPARAM)(LPTSTR)szMsg);
        }
    }

    free(pBuffer);

    return;

} // RegressionTest_DeviceList



//-----------------------------------------------------------------------------
VOID
RegressionTest_CreateDevNode(
      HWND  hDlg
      )
{
   CONFIGRET   Status = CR_SUCCESS;
   DEVNODE     dnDevNode, dnParent, dnDevNode1, dnTemp;
   TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH], szTemp[MAX_PATH];
   ULONG       ulSize = 0;


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____CreateDevNode REGRESSION TEST_____"));


   lstrcpy(szMsg, TEXT("1. Locate Root DevNode: "));
   Status = CM_Locate_DevNode(&dnParent, NULL, CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("2. Create Root\\CreateTest\\0000: "));
   Status = CM_Create_DevNode(&dnDevNode, TEXT("Root\\CreateTest\\0000"),
         dnParent, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Locate Root\\CreateTest\\0000: "));
   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\CreateTest\\0000"),
         CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("4. Test generate id with bad device: "));
   Status = CM_Create_DevNode(&dnTemp, TEXT("Create\\Test"),
         dnParent, CM_CREATE_DEVNODE_GENERATE_ID);
   if (Status != CR_INVALID_DEVICE_ID) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("5. Create based on CreateTest1: "));
   Status = CM_Create_DevNode(&dnDevNode1, TEXT("CreateTest1"),
         dnParent, CM_CREATE_DEVNODE_GENERATE_ID);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("6. Create Phantom Root\\CreateTest2\\0000: "));
   Status = CM_Create_DevNode(&dnTemp, TEXT("Root\\CreateTest2\\0000"),
         dnParent, CM_CREATE_DEVNODE_PHANTOM);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("7. Uninstall phantom Root\\CreateTest2\\0000: "));
   Status = CM_Uninstall_DevNode(dnTemp, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("8. Uninstall real Root\\CreateTest1\\0000: "));
   Status = CM_Uninstall_DevNode(dnDevNode1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("8. Cancel remove or real Root\\CreateTest1\\0000: "));
   Status = CM_Locate_DevNode(&dnDevNode1, TEXT("Root\\CreateTest1\\0000"), CM_LOCATE_DEVNODE_CANCELREMOVE);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("9. Register device driver for Root\\Device001\\0000: "));
   Status = CM_Locate_DevNode(&dnDevNode1, TEXT("Root\\Device001\\0000"), CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
       Status = CM_Register_Device_Driver(dnDevNode1,
                            CM_REGISTER_DEVICE_DRIVER_DISABLEABLE | CM_REGISTER_DEVICE_DRIVER_REMOVABLE);
       if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
       } else {
           wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
       }
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("REG1. test devnode handle consistency: "));

   // create device id with generated instance
   CM_Create_DevNode(&dnDevNode, TEXT("GenerateID"), dnParent,
                     CM_CREATE_DEVNODE_NORMAL | CM_CREATE_DEVNODE_GENERATE_ID);

  // Get back the device id
  CM_Get_Device_ID(dnDevNode, szTemp, MAX_PATH - 1, 0);

  wsprintf(szMsg, TEXT("   Generated device instance: %s"), szTemp);
  SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

  CM_Locate_DevNode(&dnDevNode1, szTemp, 0);

  if (dnDevNode != dnDevNode1) {

      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Created and located devnode handles don't match (error)"));
  } else {

      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)TEXT("Created and located devnode handles match (expected)"));
  }


    // if not generating an instance, the devinst must be a full valid devinst
    // with the three component parts.

    lstrcpy(szMsg, TEXT("REG2. Invalid device instance, no generate: "));

    Status = CM_Create_DevNode(&dnDevNode, TEXT("BadDevInst"), dnParent,
                               CM_CREATE_DEVNODE_NORMAL);

    if (Status == CR_INVALID_DEVINST) {
        lstrcat(szMsg, TEXT("Failed (expected)"));
    } else {
        lstrcat(szMsg, TEXT("Error: should've failed"));
    }

    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);



   /*
   lstrcpy(szMsg, TEXT("9. Move CreateTest\\0000 to CreateTest1\\0000: "));
   Status = CM_Move_DevNode(dnDevNode, dnDevNode1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);
   */

   return;

} // RegressionTest_CreateDevNode


//-----------------------------------------------------------------------------
VOID
RegressionTest_Properties(
      HWND  hDlg
      )
{
   CONFIGRET   Status = CR_SUCCESS;
   DEVNODE     dnDevNode;
   TCHAR       szMsg[MAX_PATH], szMsg1[MAX_PATH], pszString[MAX_PATH];
   LPTSTR      p = NULL;
   ULONG       ulValue = 0, ulSize = 0, ulType = 0;
   TCHAR       pData[1024];


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____Properties REGRESSION TEST_____"));

   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"),
         CM_LOCATE_DEVNODE_NORMAL);
   if (Status != CR_SUCCESS) {
      return;
   }


   CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_FRIENDLYNAME, NULL, 0, 0);

   lstrcpy(szMsg, TEXT("Set/Get CM_DRP_FRIENDLYNAME: "));

   lstrcpy(pszString, TEXT("FriendlyName"));
   ulSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);

   Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_FRIENDLYNAME,
        pszString, ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      pszString[0] = '\0';
      Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_FRIENDLYNAME,
            &ulType, pszString, &ulSize, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_DEVICEDESC, NULL, 0, 0);

   lstrcpy(szMsg, TEXT("Set/Get DeviceDesc: "));

   lstrcpy(pszString, TEXT("DeviceDesc"));
   ulSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);

   Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_DEVICEDESC,
        pszString, ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      pszString[0] = '\0';
      Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_DEVICEDESC,
            &ulType, pszString, &ulSize, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_CONFIGFLAGS, NULL, 0, 0);

   lstrcpy(szMsg, TEXT("Set/Get CM_DRP_CONFIGFLAGS: "));

   ulValue = 0x0008;
   ulSize = sizeof(DWORD);

   Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_CONFIGFLAGS,
        &ulValue, ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      ulValue = 0;
      Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_CONFIGFLAGS,
            &ulType, &ulValue, &ulSize, 0);
      if (Status != CR_SUCCESS) {
         wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
      }
      else wsprintf(szMsg1, TEXT("Passed, %d, %d"), ulValue, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


    //
    // CM_DRP_LOCATION_INFORMATION
    //
    lstrcpy(szMsg, TEXT("CM_DRP_LOCATION_INFORMATION: "));

    lstrcpy(pszString, TEXT("Madeup location"));
    ulSize = (lstrlen(pszString) + 1) * sizeof(TCHAR);

    Status = CM_Set_DevNode_Registry_Property(dnDevNode, CM_DRP_LOCATION_INFORMATION,
                                              pszString, ulSize, 0);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        pszString[0] = '\0';
        Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_LOCATION_INFORMATION,
                                                  &ulType, pszString, &ulSize, 0);
        if (Status != CR_SUCCESS) {
            wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        } else {
            wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
        }
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    //
    // CM_DRP_UPPER_FILTERS
    //
    lstrcpy(szMsg, TEXT("CM_DRP_LOWERFILTERS: "));

    ulSize = MAX_PATH/sizeof(WCHAR);
    pszString[0] = '\0';
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_LOWERFILTERS,
                                                  &ulType, pszString, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        wsprintf(szMsg1, TEXT("Passed, %d"), ulType);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);

        for (p = pszString; *p; p += lstrlen(p) + 1) {
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }

    //
    // CM_DRP_UPPER_FILTERS
    //
    lstrcpy(szMsg, TEXT("CM_DRP_UPPERFILTERS: "));

    ulSize = MAX_PATH/sizeof(WCHAR);
    pszString[0] = '\0';
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_UPPERFILTERS,
                                                  &ulType, pszString, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    } else {
        wsprintf(szMsg1, TEXT("Passed, %d"), ulType);

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);

        for (p = pszString; *p; p += lstrlen(p) + 1) {
            SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                               (LPARAM)(LPTSTR)p);
        }
    }


    //
    // CM_DRP_CAPABILITIES
    //
    lstrcpy(szMsg, TEXT("CM_DRP_CAPABILITIES: "));

    ulSize = sizeof(DWORD);
    ulValue = 0;
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_CAPABILITIES,
                                              &ulType, &ulValue, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        wsprintf(szMsg1, TEXT("Passed, value = %d, %d"), ulValue, ulType);
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    //
    // CM_DRP_UI_NUMBER
    //
    lstrcpy(szMsg, TEXT("CM_DRP_UI_NUMBER: "));

    ulSize = sizeof(DWORD);
    ulValue = 0;
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_UI_NUMBER,
                                              &ulType, &ulValue, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        wsprintf(szMsg1, TEXT("Passed, value = %d, %d"), ulValue, ulType);
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);

    //
    // Another special test, go to a real devnode made by pnptest for this property
    // since it's not in the registry: CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
    //
    Status = CM_Locate_DevNode(&dnDevNode, TEXT("PnPTest\\Pdo0\\Root&LEGACY_PNPTEST&0000&1111"),
          CM_LOCATE_DEVNODE_NORMAL);
    if (Status != CR_SUCCESS) {
       return;
    }

    lstrcpy(szMsg, TEXT("CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME: "));

    ulSize = MAX_PATH/sizeof(WCHAR);
    pszString[0] = '\0';
    Status = CM_Get_DevNode_Registry_Property(dnDevNode, CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                                  &ulType, pszString, &ulSize, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    } else {
        wsprintf(szMsg1, TEXT("Passed, %s, %d"), pszString, ulType);
    }

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                       (LPARAM)(LPTSTR)szMsg);




   //----------------------------------------------------------------
   // Add_ID test
   //----------------------------------------------------------------


   // clear hardware id property
   CM_Set_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_HARDWAREID, NULL,
                                       0, 0, hMachine);

   lstrcpy(szMsg, TEXT("Add Hardware ID (SomeHardwareID\\0001): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("SomeHardwareID\\0001"),
                         CM_ADD_ID_HARDWARE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Add Hardware ID (AnotherHardwareID\\0002): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("AnotherHardwareID\\0002"),
                         CM_ADD_ID_HARDWARE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   ulSize = 1024;
   Status = CM_Get_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_HARDWAREID,
         &ulType, pData, &ulSize, 0, hMachine);

   lstrcpy(szMsg, TEXT("Current HardwareID: "));
   for (p = pData; *p; p += lstrlen(p) + 1) {
       lstrcat(szMsg, p);
       lstrcat(szMsg, TEXT(" "));
   }

   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



      // clear compatible id property
   CM_Set_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_COMPATIBLEIDS, NULL,
                                       0, 0, hMachine);

   lstrcpy(szMsg, TEXT("Add Compatible ID (SomeCompatibleID\\0001): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("SomeCompatibleID\\0001"),
                         CM_ADD_ID_COMPATIBLE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Add Compatible ID (AnotherCompatibleID\\0002): "));

   Status = CM_Add_ID_Ex(dnDevNode, TEXT("AnotherCompatibleID\\0002"),
                         CM_ADD_ID_COMPATIBLE, hMachine);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed (%xh)"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);


   ulSize = 1024;
   Status = CM_Get_DevNode_Registry_Property_Ex(dnDevNode, CM_DRP_COMPATIBLEIDS,
         &ulType, pData, &ulSize, 0, hMachine);

   lstrcpy(szMsg, TEXT("Current CompatibleID: "));
   for (p = pData; *p; p += lstrlen(p) + 1) {
       lstrcat(szMsg, p);
       lstrcat(szMsg, TEXT(" "));
   }

   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



   /*
   lstrcpy(szMsg, TEXT("Read CM_DRP_DEVICEDESC: "));
   ulSize = MAX_PATH;
   Status = CM_Get_DevNode_Registry_Property(
         dnDevNode, CM_DRP_DEVICEDESC, &ulType, pszString, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed, %s %d"), pszString, ulType);

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("2. Read CM_DRP_HARDWAREID: "));
   ulSize = MAX_PATH;
   Status = CM_Get_DevNode_Registry_Property(
         dnDevNode, CM_DRP_HARDWAREID, &ulType, pszString, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed, %d, "), ulType);
      for (p = pszString; *p; p += lstrlen(p)+1) {
         lstrcat(szMsg1, p);
      }
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("3. Read CM_DRP_COMPATIBLEIDS: "));
   ulSize = MAX_PATH;
   Status = CM_Get_DevNode_Registry_Property(
         dnDevNode, CM_DRP_COMPATIBLEIDS, &ulType, pszString, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed, %d, "), ulType);
      for (p = pszString; *p; p += lstrlen(p)+1) {
         lstrcat(szMsg1, p);
      }
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("4. Read CM_DRP_CONFIGFLAGS: "));
   ulSize = sizeof(ULONG);
   Status = CM_Get_DevNode_Registry_Property(
        dnDevNode, CM_DRP_CONFIGFLAGS, &ulType, &ulValue, &ulSize, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else {
      wsprintf(szMsg1, TEXT("Passed, %d %d"), ulValue, ulType);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

   */


   return;

} // RegressionTest_Properties


//-----------------------------------------------------------------------------
VOID
RegressionTest_DeviceClass(
    HWND  hDlg
    )
{
    CONFIGRET Status;
    TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
    TCHAR     szDevice[MAX_PATH], szReference[MAX_PATH], szInterfaceDevice[MAX_PATH];
    DEVNODE   dnDevNode;
    TCHAR     Buffer[512];
    PTSTR     pBuffer = NULL;
    GUID      InterfaceGuid;
    ULONG     ulSize;

    lstrcpy(szDevice, TEXT("PnPTest\\Pdo0\\Root&LEGACY_PNPTEST&0000&1111"));
    //UuidFromString(TEXT("aaaaaaa2-e3f0-101b-8488-00aa003e5601"), &InterfaceGuid);
    UuidFromString(TEXT("11111111-2222-3333-4444-555555555555"), &InterfaceGuid);

    SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____DEVICE CLASS REGRESSION TEST_____"));

    //
    // get a devinst handle for this device instance
    //

    Status = CM_Locate_DevNode(&dnDevNode, szDevice, CM_LOCATE_DEVNODE_NORMAL);
    if (Status != CR_SUCCESS) {
       return;
    }

    //
    // Register a device class assocation with a ref string
    //

    lstrcpy(szReference, TEXT("RefStringA"));
    ulSize = MAX_PATH;
    Status = CM_Register_Device_Interface(dnDevNode, &InterfaceGuid,
                                                   szReference, szInterfaceDevice,
                                                   &ulSize, 0);

    if (Status == CR_SUCCESS) {
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szInterfaceDevice);
    } else {
        wsprintf(szMsg, TEXT("Error registering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }

    //
    // Unregister the device class association
    //

    Status = CM_Unregister_Device_Interface(szInterfaceDevice, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Error unregistering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }

    //
    // Register a device class association without a ref string
    //

    ulSize = MAX_PATH;
    Status = CM_Register_Device_Interface(dnDevNode, &InterfaceGuid,
                                                   NULL, szInterfaceDevice,
                                                   &ulSize, 0);

    if (Status == CR_SUCCESS) {
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szInterfaceDevice);
    } else {
        wsprintf(szMsg, TEXT("Error registering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }

    //
    // Unregister the device class association
    //

    Status = CM_Unregister_Device_Interface(szInterfaceDevice, 0);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg, TEXT("Error unregistering dev class association, %d"), Status);
        SendDlgItemMessage(hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
                           (LPARAM)(LPTSTR)szMsg);
    }


    return;

} // RegressionTest_DeviceClass



BOOL
DisplayRange(
   IN HWND  hDlg,
   IN RANGE_LIST rlh
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   DWORDLONG   ulStart = 0, ulEnd = 0;
   TCHAR       szMsg[MAX_PATH], szTemp[MAX_PATH];
   RANGE_LIST  rlh1;
   RANGE_ELEMENT rlElement;


   Status = CM_First_Range(rlh, &ulStart, &ulEnd, &rlElement, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_First_Range failed (%xh)"), Status);
      goto Clean0;
   }

   wsprintf(szMsg, TEXT("(%d,%d)"), (DWORD)ulStart, (DWORD)ulEnd);


   while (Status == CR_SUCCESS) {
      Status = CM_Next_Range(&rlElement, &ulStart, &ulEnd, 0);
      if (Status == CR_SUCCESS) {
         wsprintf(szTemp, TEXT(",(%d,%d)"), (DWORD)ulStart, (DWORD)ulEnd);
         lstrcat(szMsg, szTemp);
      }
   }

   Clean0:

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   return TRUE;

} // DisplayRange




BOOL
TraverseAndCheckParents (
    DEVNODE dnParent
    )
{
    CONFIGRET configRet;
    DEVNODE   dnChild, dnDevNode;

    // Get first child.
    configRet = CM_Get_Child_Ex(&dnChild, dnParent, 0, hMachine);

    if ((configRet != CR_SUCCESS) && (configRet != CR_NO_SUCH_DEVNODE)) {
        MessageBox(NULL, TEXT("CM_Get_Child failed"), TEXT("Traversal Test"), MB_OK);
        return FALSE;
    }

    // Check to see that the parent is correct and iterate thru the siblings.
    while (configRet == CR_SUCCESS) {
        configRet = CM_Get_Parent_Ex(&dnDevNode, dnChild, 0, hMachine);
        if (configRet == CR_SUCCESS) {
            if (dnDevNode != dnParent) {
                // No parent, or not the correct parent.
                MessageBox(NULL, TEXT("Not correct parent"), TEXT("Traversal Test"), MB_OK);
                return FALSE;
            }
        } else {
            MessageBox(NULL, TEXT("CM_Get_Parent failed"), TEXT("Traversal Test"), MB_OK);
            return FALSE;
        }

        // Recursively traverse the hardware tree.
        if (!TraverseAndCheckParents(dnChild)) {
            return FALSE;
        }

        // Iterate thru the siblings.
        configRet = CM_Get_Sibling_Ex(&dnChild, dnChild, 0, hMachine);

        if ((configRet != CR_SUCCESS) && (configRet != CR_NO_SUCH_DEVNODE)) {
            MessageBox(NULL, TEXT("CM_Get_Sibling failed"), TEXT("Traversal Test"), MB_OK);
            return FALSE;
        }
    }

    return TRUE;

} // TraverseAndCheckParents
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\test\pnptest\pnptest.h ===
#define PNPTEST_IOCTL_INDEX  0x950

#define IOCTL_SET       CTL_CODE(FILE_DEVICE_CONTROLLER,    \
                                 PNPTEST_IOCTL_INDEX,       \
                                 METHOD_BUFFERED,           \
                                 FILE_ANY_ACCESS)

#define IOCTL_CLEAR     CTL_CODE(FILE_DEVICE_CONTROLLER,    \
                                 PNPTEST_IOCTL_INDEX+1,     \
                                 METHOD_BUFFERED,           \
                                 FILE_ANY_ACCESS)

#define IOCTL_GET_PROP  CTL_CODE(FILE_DEVICE_CONTROLLER,    \
                                 PNPTEST_IOCTL_INDEX+2,     \
                                 METHOD_BUFFERED,           \
                                 FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\chnghal\chnghal.h ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include <initguid.h>
#include <devguid.h>
#include <regstr.h>
#include <cfgmgr32.h>
#include <setupapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\test\tlogconf.c ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <malloc.h>
#include "cmtest.h"



VOID 
SpecialCase_LogConf(
    DEVNODE dnDevNode
    );


//-----------------------------------------------------------------------------
VOID
RegressionTest_LogConf(
      HWND  hDlg
      )
{
   CONFIGRET Status;
   TCHAR     szMsg[MAX_PATH], szMsg1[MAX_PATH];
   DEVNODE   dnDevNode;
   LOG_CONF  TempLC, BootLC1, BootLC2, BootLC3;
   LOG_CONF  BasicLC1, BasicLC2, BasicLC3;
   RES_DES   ResDes, ResDes1, ResDes2, ResDes3;
   PCS_DES   pResourceData;
   ULONG     ulSize = 0;
   BYTE      i;
   PMEM_RESOURCE pMemRes = NULL;
   PIO_RESOURCE  pIoRes = NULL;
   PCS_RESOURCE  pCs1Res = NULL, pCs2Res = NULL;
   PIRQ_RESOURCE pIrqRes = NULL;
   PDMA_RESOURCE pDmaRes = NULL;
   BYTE       LegacyData[512];
   RESOURCEID ResType;
   LPBYTE    pBuffer = NULL, pData = NULL;
   PRIORITY Priority = 0;

   //
   // free, free handle, modify, get size, get data
   //

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("____LOGCONF-RESDES REGRESSION TEST_____"));

   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)TEXT("Testing Device ID: Root\\Device001\\0000"));

   Status = CM_Locate_DevNode(&dnDevNode, TEXT("Root\\Device001\\0000"), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg, TEXT("CM_Locate_DevNode Failed (%xh)"), Status);
      SendDlgItemMessage(
            hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
            (LPARAM)(LPTSTR)szMsg);
      return;
   }


    SpecialCase_LogConf(dnDevNode);
    return;


   //------------------------------------------------------
   // Add/Get Boot Configs
   //------------------------------------------------------


   lstrcpy(szMsg, TEXT("Test empty boot 1 config: "));
   Status = CM_Add_Empty_Log_Conf(&BootLC1, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add empty boot 2 config: "));
   Status = CM_Add_Empty_Log_Conf(&BootLC2, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   Status = CM_Free_Log_Conf_Handle(BootLC1);
   Status = CM_Free_Log_Conf_Handle(BootLC2);


   lstrcpy(szMsg, TEXT("Test get first boot config: "));
   Status = CM_Get_First_Log_Conf(&BootLC1, dnDevNode, BOOT_LOG_CONF);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Get_First_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next boot config: "));
   Status = CM_Get_Next_Log_Conf(&BootLC2, BootLC1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next (nonexistent) boot config: "));
   Status = CM_Get_Next_Log_Conf(&TempLC, BootLC2, 0);
   if (Status != CR_NO_MORE_LOG_CONF) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get priority of boot config: "));
   Status = CM_Get_Log_Conf_Priority(BootLC1, &Priority, 0);
   if (Status != CR_INVALID_LOG_CONF) {
       wsprintf(szMsg1, TEXT("Passed, should have failed! (%d)\n"), Status);
   } else {
       wsprintf(szMsg1, TEXT("Failed as expected (%d)\n"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //------------------------------------------------------
   // Add/Get Basic Configs
   //------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test empty basic 1 config: "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC1, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add empty basic 2 config: "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC2, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   Status = CM_Free_Log_Conf_Handle(BasicLC1);
   Status = CM_Free_Log_Conf_Handle(BasicLC2);


   lstrcpy(szMsg, TEXT("Test get first basic config: "));
   Status = CM_Get_First_Log_Conf(&BasicLC1, dnDevNode, BASIC_LOG_CONF);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Get_First_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next basic config: "));
   Status = CM_Get_Next_Log_Conf(&BasicLC2, BasicLC1, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get next (nonexistent) basic config: "));
   Status = CM_Get_Next_Log_Conf(&TempLC, BasicLC3, 0);
   if (Status != CR_NO_MORE_LOG_CONF) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Test get priority of basic config: "));
   Status = CM_Get_Log_Conf_Priority(BasicLC2, &Priority, 0);
   if (Status == CR_SUCCESS) {
       if (Priority == LCPRI_NORMAL) {
          wsprintf(szMsg1, TEXT("Passed\n"));
       } else {
           wsprintf(szMsg1, TEXT("Failed, priority should be %x (%x)\n"), LCPRI_NORMAL, Priority);
       }
   } else {
       wsprintf(szMsg1, TEXT("Failed (%d)\n"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //----------------------------------------------------------
   // Test adding res des 's
   //----------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add MEMORY res des to LC1: "));

   pMemRes = malloc(sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE));

   pMemRes->MEM_Header.MD_Count      = 2;
   pMemRes->MEM_Header.MD_Type       = MType_Range;
   pMemRes->MEM_Header.MD_Alloc_Base = (DWORDLONG)0xD8000;
   pMemRes->MEM_Header.MD_Alloc_End  = (DWORDLONG)0xD9000;
   pMemRes->MEM_Header.MD_Flags      = fMD_ROM | fMD_32 | fMD_ReadAllowed;
   pMemRes->MEM_Header.MD_Reserved   = 0;

   pMemRes->MEM_Data[0].MR_Align     = 8; //?
   pMemRes->MEM_Data[0].MR_nBytes    = 4096;
   pMemRes->MEM_Data[0].MR_Min       = (DWORDLONG)0xD8000;
   pMemRes->MEM_Data[0].MR_Max       = (DWORDLONG)0xDC000;
   pMemRes->MEM_Data[0].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
   pMemRes->MEM_Data[0].MR_Reserved  = 0;

   pMemRes->MEM_Data[1].MR_Align     = 8; //?
   pMemRes->MEM_Data[1].MR_nBytes    = 4096;
   pMemRes->MEM_Data[1].MR_Min       = (DWORDLONG)0xE0000;
   pMemRes->MEM_Data[1].MR_Max       = (DWORDLONG)0xE4000;
   pMemRes->MEM_Data[1].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
   pMemRes->MEM_Data[1].MR_Reserved  = 0;

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_Mem, pMemRes,
                           sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Add_Res_Des(&ResDes, BasicLC1, ResType_Mem, pMemRes,
                           sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   lstrcpy(szMsg, TEXT("Test add CS res des to LC2: "));

   pCs2Res = malloc(sizeof(CS_RESOURCE) + 47);       //48-1

   pCs2Res->CS_Header.CSD_SignatureLength  = 16;
   pCs2Res->CS_Header.CSD_LegacyDataOffset = 16;
   pCs2Res->CS_Header.CSD_LegacyDataSize   = 32;
   pCs2Res->CS_Header.CSD_Flags            = 0;

   CM_Enumerate_Classes(0, &(pCs2Res->CS_Header.CSD_ClassGuid), 0);

   for (i = 0; i < 16; i++) {
       pCs2Res->CS_Header.CSD_Signature[i] = i;
   }

   for (i = 0; i < 32; i++) {
       LegacyData[i] = 50;
   }

   memcpy(pCs2Res->CS_Header.CSD_Signature + pCs2Res->CS_Header.CSD_SignatureLength,
          LegacyData, 32);

   Status = CM_Add_Res_Des(&ResDes, BootLC2, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add PORT res des to LC2: "));

   pIoRes = malloc(sizeof(IO_RESOURCE) + sizeof(IO_RANGE));

   pIoRes->IO_Header.IOD_Count        = 2;
   pIoRes->IO_Header.IOD_Type         = IOType_Range;
   pIoRes->IO_Header.IOD_Alloc_Base   = (DWORDLONG)0x300;
   pIoRes->IO_Header.IOD_Alloc_End    = (DWORDLONG)0x330;
   pIoRes->IO_Header.IOD_DesFlags     = 0;

   pIoRes->IO_Data[0].IOR_Align      = 8; //?
   pIoRes->IO_Data[0].IOR_nPorts     = 0x30;
   pIoRes->IO_Data[0].IOR_Min        = (DWORDLONG)0x300;
   pIoRes->IO_Data[0].IOR_Max        = (DWORDLONG)0x430;
   pIoRes->IO_Data[0].IOR_RangeFlags = 0;
   pIoRes->IO_Data[0].IOR_Alias      = 0;

   pIoRes->IO_Data[1].IOR_Align      = 8; //?
   pIoRes->IO_Data[1].IOR_nPorts     = 0x30;
   pIoRes->IO_Data[1].IOR_Min        = (DWORDLONG)0x200;
   pIoRes->IO_Data[1].IOR_Max        = (DWORDLONG)0x300;
   pIoRes->IO_Data[1].IOR_RangeFlags = 0;
   pIoRes->IO_Data[1].IOR_Alias      = 0;

   Status = CM_Add_Res_Des(&ResDes, BootLC2, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Add_Res_Des(&ResDes, BasicLC2, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   lstrcpy(szMsg, TEXT("Test add CS res des to LC1: "));

   pCs1Res = malloc(sizeof(CS_RESOURCE) + 15);       //16-1

   pCs1Res->CS_Header.CSD_SignatureLength  = 16;
   pCs1Res->CS_Header.CSD_LegacyDataOffset = 0;
   pCs1Res->CS_Header.CSD_LegacyDataSize   = 0;
   pCs1Res->CS_Header.CSD_Flags            = 0;

   CM_Enumerate_Classes(0, &(pCs1Res->CS_Header.CSD_ClassGuid), 0);

   for (i = 0; i < 16; i++) {
       pCs1Res->CS_Header.CSD_Signature[i] = i;
   }

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, pCs1Res,
                           sizeof(CS_RESOURCE) + 15, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test add second CS res des to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BootLC2, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_INVALID_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   //----------------------------------------------------------------
   // Add 3rd empty configs - priority last
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add 3rd empty boot config: "));
   Status = CM_Add_Empty_Log_Conf(&BootLC3, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_LAST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   lstrcpy(szMsg, TEXT("Test add 3rd empty basic config: "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC3, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_LAST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Test get priority of 3rd boot config: "));
   Status = CM_Get_Log_Conf_Priority(BootLC3, &Priority, 0);
   if (Status == CR_SUCCESS) {
       if (Priority == LCPRI_BOOTCONFIG) {
          wsprintf(szMsg1, TEXT("Passed\n"));
       } else {
           wsprintf(szMsg1, TEXT("Failed, priority should be %x (%x)\n"), LCPRI_BOOTCONFIG, Priority);
       }
   } else {
       wsprintf(szMsg1, TEXT("Failed (%d)\n"), Status);
   }

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //----------------------------------------------------------------
   // Add DMA resource to LC3
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add DMA res des to LC3: "));

   pDmaRes = malloc(sizeof(DMA_RESOURCE));

   pDmaRes->DMA_Header.DD_Count      = 1;
   pDmaRes->DMA_Header.DD_Type       = DType_Range;
   pDmaRes->DMA_Header.DD_Flags      = fDD_DWORD;
   pDmaRes->DMA_Header.DD_Alloc_Chan = (DWORDLONG)0x3;

   pDmaRes->DMA_Data[0].DR_Min       = 1;
   pDmaRes->DMA_Data[0].DR_Max       = 3;
   pDmaRes->DMA_Data[0].DR_Flags     = fDD_DWORD;


   Status = CM_Add_Res_Des(&ResDes, BootLC3, ResType_DMA, pDmaRes,
                           sizeof(DMA_RESOURCE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   Status = CM_Add_Res_Des(&ResDes, BasicLC3, ResType_DMA, pDmaRes,
                           sizeof(DMA_RESOURCE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   //----------------------------------------------------------------
   // Add IRQ resource to LC3
   //----------------------------------------------------------------

   lstrcpy(szMsg, TEXT("Test add IRQ res des to LC3: "));

   pIrqRes = malloc(sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2);

   pIrqRes->IRQ_Header.IRQD_Count      = 3;
   pIrqRes->IRQ_Header.IRQD_Type       = IRQType_Range;
   pIrqRes->IRQ_Header.IRQD_Flags      = fDD_DWORD;
   pIrqRes->IRQ_Header.IRQD_Alloc_Num  = (DWORDLONG)11;
   pIrqRes->IRQ_Header.IRQD_Affinity   = 0;

   pIrqRes->IRQ_Data[0].IRQR_Min       = 1;
   pIrqRes->IRQ_Data[0].IRQR_Max       = 3;
   pIrqRes->IRQ_Data[0].IRQR_Flags     = fIRQD_Exclusive | fIRQD_Level;

   pIrqRes->IRQ_Data[1].IRQR_Min       = 5;
   pIrqRes->IRQ_Data[1].IRQR_Max       = 7;
   pIrqRes->IRQ_Data[1].IRQR_Flags     = fIRQD_Exclusive | fIRQD_Level;

   pIrqRes->IRQ_Data[2].IRQR_Min       = 9;
   pIrqRes->IRQ_Data[2].IRQR_Max       = 11;
   pIrqRes->IRQ_Data[2].IRQR_Flags     = fIRQD_Exclusive | fIRQD_Level;


   Status = CM_Add_Res_Des(&ResDes, BootLC3, ResType_IRQ, pIrqRes,
                           sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   Status = CM_Add_Res_Des(&ResDes, BasicLC3, ResType_IRQ, pIrqRes,
                           sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

   //----------------------------------------------------------------
   // Delete an lc that still has rd's in it (then recreate it)
   //----------------------------------------------------------------


   lstrcpy(szMsg, TEXT("Test free Boot Config LC2: "));
   Status = CM_Free_Log_Conf(BootLC2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   CM_Free_Log_Conf_Handle(BootLC1);

   lstrcpy(szMsg, TEXT("Recreate Boot LC2 (will be first): "));
   Status = CM_Add_Empty_Log_Conf(&BootLC1, dnDevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Re-add CS to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Re-add IO to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BootLC1, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   // free handles and retreive them again in order
   CM_Free_Log_Conf_Handle(BootLC1);
   CM_Free_Log_Conf_Handle(BootLC2);
   CM_Free_Log_Conf_Handle(BootLC3);

   CM_Get_First_Log_Conf(&BootLC1, dnDevNode, BOOT_LOG_CONF);
   CM_Get_Next_Log_Conf(&BootLC2, BootLC1, 0);
   CM_Get_Next_Log_Conf(&BootLC3, BootLC2, 0);



   lstrcpy(szMsg, TEXT("Test free Basic Config LC2: "));
   Status = CM_Free_Log_Conf(BasicLC2, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   CM_Free_Log_Conf_Handle(BasicLC1);

   lstrcpy(szMsg, TEXT("Recreate LC2 (will be first): "));
   Status = CM_Add_Empty_Log_Conf(&BasicLC1, dnDevNode, LCPRI_NORMAL,
            BASIC_LOG_CONF | PRIORITY_EQUAL_FIRST);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("CM_Add_Empty_Log_Conf Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Attempt adding a CS: "));

   Status = CM_Add_Res_Des(&ResDes, BasicLC1, ResType_ClassSpecific, pCs2Res,
                           sizeof(CS_RESOURCE) + 47, 0);
   if (Status != CR_INVALID_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Re-add IO to LC2: "));

   Status = CM_Add_Res_Des(&ResDes, BasicLC1, ResType_IO, pIoRes,
                           sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   // free handles and retreive them again in order
   CM_Free_Log_Conf_Handle(BasicLC1);
   CM_Free_Log_Conf_Handle(BasicLC2);
   CM_Free_Log_Conf_Handle(BasicLC3);

   CM_Get_First_Log_Conf(&BasicLC1, dnDevNode, BASIC_LOG_CONF);
   CM_Get_Next_Log_Conf(&BasicLC2, BasicLC1, 0);
   CM_Get_Next_Log_Conf(&BasicLC3, BasicLC2, 0);



MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

   //----------------------------------------------------------------
   // Get-next test
   //----------------------------------------------------------------


   lstrcpy(szMsg, TEXT("Get first res des from Boot LC1: "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BootLC1, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC1 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC1 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes3, ResDes2, ResType_All, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC2 (ClassSpecific): "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BootLC2, ResType_ClassSpecific,
                    &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Boot LC2 (DMA): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_DMA, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);




   lstrcpy(szMsg, TEXT("Get first res des from Basic LC3: "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BasicLC3, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Basic LC3 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);

   SendDlgItemMessage(
      hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
      (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Basic LC3 (all): "));

   Status = CM_Get_Next_Res_Des(&ResDes3, ResDes2, ResType_All, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get first res des from Basic LC3 (IRQ): "));

   Status = CM_Get_Next_Res_Des(&ResDes1, BasicLC3, ResType_IRQ,
                    &ResType, 0);
   if (Status != CR_SUCCESS) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);


   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   lstrcpy(szMsg, TEXT("Get next res des from Basic LC1 (IRQ): "));

   Status = CM_Get_Next_Res_Des(&ResDes2, BasicLC1, ResType_IRQ, &ResType, 0);
   if (Status != CR_NO_MORE_RES_DES) {
      wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
   }
   else wsprintf(szMsg1, TEXT("Passed"));

   lstrcat(szMsg, szMsg1);
   SendDlgItemMessage(
         hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
         (LPARAM)(LPTSTR)szMsg);



   //----------------------------------------------------------------
   // Get data size and data for all
   //----------------------------------------------------------------

    // reset some fields for comparison
    pMemRes->MEM_Header.MD_Count      = 0;
    pMemRes->MEM_Data[0].MR_Align     = 0;
    pMemRes->MEM_Data[0].MR_nBytes    = 0;
    pMemRes->MEM_Data[0].MR_Min       = 0;
    pMemRes->MEM_Data[0].MR_Max       = 0;
    pMemRes->MEM_Data[0].MR_Flags     = 0;
    pMemRes->MEM_Data[0].MR_Reserved  = 0;


    CM_Get_Next_Res_Des(&ResDes1, BootLC2, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pMemRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pMemRes->MEM_Header.MD_Count      = 2;
    pMemRes->MEM_Data[0].MR_Align     = 8; //?
    pMemRes->MEM_Data[0].MR_nBytes    = 4096;
    pMemRes->MEM_Data[0].MR_Min       = (DWORDLONG)0xD8000;
    pMemRes->MEM_Data[0].MR_Max       = (DWORDLONG)0xDC000;
    pMemRes->MEM_Data[0].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Data[0].MR_Reserved  = 0;



    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (memcmp(pData, pCs1Res, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



    // reset some fields for comparison
    pIoRes->IO_Header.IOD_Count       = 0;
    pIoRes->IO_Data[0].IOR_Align      = 0;
    pIoRes->IO_Data[0].IOR_nPorts     = 0;
    pIoRes->IO_Data[0].IOR_Min        = 0;
    pIoRes->IO_Data[0].IOR_Max        = 0;
    pIoRes->IO_Data[0].IOR_RangeFlags = 0;
    pIoRes->IO_Data[0].IOR_Alias      = 0;

    CM_Get_Next_Res_Des(&ResDes1, BootLC1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC1-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC1-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pIoRes->IO_Header.IOD_Count       = 2;
    pIoRes->IO_Data[0].IOR_Align      = 8; //?
    pIoRes->IO_Data[0].IOR_nPorts     = 0x30;
    pIoRes->IO_Data[0].IOR_Min        = (DWORDLONG)0x300;
    pIoRes->IO_Data[0].IOR_Max        = (DWORDLONG)0x430;
    pIoRes->IO_Data[0].IOR_RangeFlags = 0;
    pIoRes->IO_Data[0].IOR_Alias      = 0;



    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != (sizeof(CS_RESOURCE) + 47) ||
            memcmp(pData, pCs2Res, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC1-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC1-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



    // reset some fields for comparison
    pDmaRes->DMA_Header.DD_Count  = 0;
    pDmaRes->DMA_Data[0].DR_Min   = 0;
    pDmaRes->DMA_Data[0].DR_Max   = 0;
    pDmaRes->DMA_Data[0].DR_Flags = 0;

    CM_Get_Next_Res_Des(&ResDes1, BootLC3, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pDmaRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC3-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC3-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pDmaRes->DMA_Header.DD_Count  = 1;
    pDmaRes->DMA_Data[0].DR_Min   = 1;
    pDmaRes->DMA_Data[0].DR_Max   = 3;
    pDmaRes->DMA_Data[0].DR_Flags = fDD_DWORD;



    // reset some fields for comparison
    pIrqRes->IRQ_Header.IRQD_Count  = 0;
    pIrqRes->IRQ_Data[0].IRQR_Min   = 0;
    pIrqRes->IRQ_Data[0].IRQR_Max   = 0;
    pIrqRes->IRQ_Data[0].IRQR_Flags = 0;

    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset fields back to original values
    pIrqRes->IRQ_Header.IRQD_Count  = 3;
    pIrqRes->IRQ_Data[0].IRQR_Min   = 1;
    pIrqRes->IRQ_Data[0].IRQR_Max   = 3;
    pIrqRes->IRQ_Data[0].IRQR_Flags = fIRQD_Exclusive | fIRQD_Level;




    // null out header for comparison
    pMemRes->MEM_Header.MD_Alloc_Base = 0;
    pMemRes->MEM_Header.MD_Alloc_End  = 0;
    pMemRes->MEM_Header.MD_Flags      = 0;
    pMemRes->MEM_Header.MD_Reserved   = 0;

    CM_Get_Next_Res_Des(&ResDes1, BasicLC2, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (ulSize != (sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE)) ||
            memcmp(pData, pMemRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pMemRes->MEM_Header.MD_Alloc_Base = (DWORDLONG)0xD8000;
    pMemRes->MEM_Header.MD_Alloc_End  = (DWORDLONG)0xD9000;
    pMemRes->MEM_Header.MD_Flags      = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Header.MD_Reserved   = 0;



    // null out header for comparison
    pIoRes->IO_Header.IOD_Alloc_Base   = 0;
    pIoRes->IO_Header.IOD_Alloc_End    = 0;
    pIoRes->IO_Header.IOD_DesFlags     = 0;

    CM_Get_Next_Res_Des(&ResDes1, BasicLC1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (ulSize != (sizeof(IO_RESOURCE) + sizeof(IO_RANGE)) ||
            memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC1-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC1-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIoRes->IO_Header.IOD_Alloc_Base   = (DWORDLONG)0x300;
    pIoRes->IO_Header.IOD_Alloc_End    = (DWORDLONG)0x330;
    pIoRes->IO_Header.IOD_DesFlags     = 0;



    // null out header for comparison
    pDmaRes->DMA_Header.DD_Flags      = 0;
    pDmaRes->DMA_Header.DD_Alloc_Chan = 0;

    CM_Get_Next_Res_Des(&ResDes1, BasicLC3, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (ulSize != sizeof(DMA_RESOURCE) ||
            memcmp(pData, pDmaRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC3-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC3-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pDmaRes->DMA_Header.DD_Flags      = fDD_DWORD;
    pDmaRes->DMA_Header.DD_Alloc_Chan = (DWORDLONG)0x3;



    // null out header for comparison
    pIrqRes->IRQ_Header.IRQD_Flags      = 0;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num  = 0;
    pIrqRes->IRQ_Header.IRQD_Affinity   = 0;

    CM_Get_Next_Res_Des(&ResDes2, ResDes1, ResType_All, &ResType, 0);
    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2 ||
            memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIrqRes->IRQ_Header.IRQD_Flags     = fDD_DWORD;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num = (DWORDLONG)11;
    pIrqRes->IRQ_Header.IRQD_Affinity  = 0;


    //---------------------------------------------------------------
    // Modify data test
    //---------------------------------------------------------------


    wsprintf(szMsg, TEXT("Modify Boot LC3-RD2 (shrink): "));

    CM_Get_Next_Res_Des(&ResDes2, BootLC3, ResType_IRQ, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes2, ResDes2, ResType_IO, pIoRes,
                               sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);




    wsprintf(szMsg, TEXT("Modify Basic LC3-RD2 (shrink): "));

    CM_Get_Next_Res_Des(&ResDes2, BasicLC3, ResType_IRQ, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes2, ResDes2, ResType_IO, pIoRes,
                               sizeof(IO_RESOURCE) + sizeof(IO_RANGE), 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    // null out header for comparison
    pIoRes->IO_Header.IOD_Alloc_Base   = 0;
    pIoRes->IO_Header.IOD_Alloc_End    = 0;
    pIoRes->IO_Header.IOD_DesFlags     = 0;

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != sizeof(IO_RESOURCE) + sizeof(IO_RANGE)) {
        wsprintf(szMsg, TEXT("LC3-RD2 Data size is NOT correct"));
    } else if (memcmp(pData, pIoRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("LC3-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("LC3-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIoRes->IO_Header.IOD_Alloc_Base   = (DWORDLONG)0x300;
    pIoRes->IO_Header.IOD_Alloc_End    = (DWORDLONG)0x330;
    pIoRes->IO_Header.IOD_DesFlags     = 0;




    wsprintf(szMsg, TEXT("Modify Boot LC1-RD1 (grow): "));

    CM_Get_Next_Res_Des(&ResDes1, BootLC1, ResType_All, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes1, ResDes1, ResType_IRQ, pIrqRes,
                               sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



    wsprintf(szMsg, TEXT("Modify Basic LC1-RD1 (grow): "));

    CM_Get_Next_Res_Des(&ResDes1, BasicLC1, ResType_All, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes1, ResDes1, ResType_IRQ, pIrqRes,
                               sizeof(IRQ_RESOURCE) + sizeof(IRQ_RANGE) * 2, 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    // null out header for comparison
    pIrqRes->IRQ_Header.IRQD_Flags      = 0;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num  = 0;

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes1, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes1, pData, ulSize, 0);
    if (memcmp(pData, pIrqRes, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BASIC LC2-RD1 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);

    // reset header back
    pIrqRes->IRQ_Header.IRQD_Flags     = fDD_DWORD;
    pIrqRes->IRQ_Header.IRQD_Alloc_Num = (DWORDLONG)11;



    wsprintf(szMsg, TEXT("Modify Boot LC2-RD2 (shrink CS): "));

    CM_Get_Next_Res_Des(&ResDes2, BootLC2, ResType_ClassSpecific, &ResType, 0);

    Status = CM_Modify_Res_Des(&ResDes2, ResDes2, ResType_ClassSpecific, pCs1Res,
                               sizeof(CS_RESOURCE) + 15, 0);

    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else wsprintf(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);

    CM_Get_Res_Des_Data_Size(&ulSize, ResDes2, 0);
    pData = malloc(ulSize);
    CM_Get_Res_Des_Data(ResDes2, pData, ulSize, 0);
    if (ulSize != sizeof(CS_RESOURCE) + 15 ||
            memcmp(pData, pCs1Res, ulSize) != 0) {
        wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is NOT correct"));
    }
    else wsprintf(szMsg, TEXT("BOOT LC2-RD2 Data is correct"));
    free(pData);
    SendDlgItemMessage(
        hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szMsg);



MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

    //---------------------------------------------------------------
    // Free res des test
    //---------------------------------------------------------------

    // delete rd2 and rd1 from lc2
    CM_Get_Next_Res_Des(&ResDes2, BootLC2, ResType_ClassSpecific, &ResType, 0);
    CM_Free_Res_Des(&ResDes1, ResDes2, 0);
    CM_Free_Res_Des(&BootLC2, ResDes1, 0);

    // delete rd1 from lc3
    CM_Get_Next_Res_Des(&ResDes1, BootLC3, ResType_All, &ResType, 0);
    CM_Free_Res_Des(&BootLC3, ResDes1, 0);

    // delete rd2 from lc3
    CM_Get_Next_Res_Des(&ResDes1, BootLC3, ResType_All, &ResType, 0);
    CM_Free_Res_Des(&BootLC3, ResDes1, 0);

    // delete rd2 and rd1 from lc1
    CM_Get_Next_Res_Des(&ResDes2, BootLC1, ResType_ClassSpecific, &ResType, 0);
    CM_Free_Res_Des(&ResDes1, ResDes2, 0);
    CM_Free_Res_Des(&BootLC1, ResDes1, 0);


MessageBox(hDlg, TEXT("Check registry contents"), TEXT("CMTEST"), MB_OK);

    //---------------------------------------------------------------
    // Free LC Test
    //---------------------------------------------------------------

    if (MessageBox(hDlg,
        TEXT("Free all the log confs that were just created?"),
        TEXT("CMTest"), MB_YESNO) == IDYES) {


        lstrcpy(szMsg, TEXT("Test free Boot Config LC2: "));
        Status = CM_Free_Log_Conf(BootLC2, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Boot Config LC3: "));
        Status = CM_Free_Log_Conf(BootLC3, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Boot Config LC1: "));
        Status = CM_Free_Log_Conf(BootLC1, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);



        lstrcpy(szMsg, TEXT("Test free Basic Config LC2: "));
        Status = CM_Free_Log_Conf(BasicLC2, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Basic Config LC3: "));
        Status = CM_Free_Log_Conf(BasicLC3, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);


        lstrcpy(szMsg, TEXT("Test free Basic Config LC1: "));
        Status = CM_Free_Log_Conf(BasicLC1, 0);
        if (Status != CR_SUCCESS) {
           wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
        }
        else wsprintf(szMsg1, TEXT("Passed"));

        lstrcat(szMsg, szMsg1);
        SendDlgItemMessage(
              hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
              (LPARAM)(LPTSTR)szMsg);
    }



   //----------------------------------------------------------------
   // Free Log config handles
   //----------------------------------------------------------------


    lstrcpy(szMsg, TEXT("Test free handle LC1: "));

    Status = CM_Free_Log_Conf_Handle(BootLC1);
    if (Status != CR_SUCCESS) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
           hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
           (LPARAM)(LPTSTR)szMsg);



    lstrcpy(szMsg, TEXT("Test free handle LC2: "));

    Status = CM_Free_Log_Conf_Handle(BootLC2);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test free handle LC3: "));

    Status = CM_Free_Log_Conf_Handle(BootLC3);
    if (Status != CR_SUCCESS) {
       wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
          hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
          (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test freeing already freed handle: "));

    Status = CM_Free_Log_Conf_Handle(BootLC2);
    if (Status != CR_INVALID_LOG_CONF) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
           hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
           (LPARAM)(LPTSTR)szMsg);


    lstrcpy(szMsg, TEXT("Test freeing invalid config handle: "));

    BootLC2 = 1;

    Status = CM_Free_Log_Conf_Handle(BootLC2);
    if (Status != CR_FAILURE) {
        wsprintf(szMsg1, TEXT("Failed (%xh)"), Status);
    }
    else lstrcpy(szMsg1, TEXT("Passed"));

    lstrcat(szMsg, szMsg1);
    SendDlgItemMessage(
           hDlg, ID_LB_REGRESSION, LB_ADDSTRING, 0,
           (LPARAM)(LPTSTR)szMsg);



   if (pMemRes != NULL) free(pMemRes);
   if (pIoRes != NULL) free(pIoRes);
   if (pCs1Res != NULL) free(pCs1Res);
   if (pCs2Res != NULL) free(pCs2Res);
   if (pDmaRes != NULL) free(pDmaRes);
   if (pIrqRes != NULL) free(pIrqRes);

   return;

} // RegressionTest_LogConf



VOID 
SpecialCase_LogConf(
    DEVNODE dnDevNode
    )
{
    CONFIGRET Status;
    LOG_CONF  BootLC1, BasicLC1;
    RES_DES   ResDes;
    PCS_DES   pResourceData;
    ULONG     ulSize = 0;
    BYTE      i;
    PMEM_RESOURCE pMemRes = NULL;
    PCS_RESOURCE  pCs1Res = NULL;
    RESOURCEID ResourceID;
    LPBYTE    pBuffer = NULL, pData = NULL;

    //
    // fill out an arbitrary class specific structure
    //

    pCs1Res = malloc(sizeof(CS_RESOURCE) + 15);       //16-1
 
    pCs1Res->CS_Header.CSD_SignatureLength  = 16;
    pCs1Res->CS_Header.CSD_LegacyDataOffset = 0;
    pCs1Res->CS_Header.CSD_LegacyDataSize   = 0;
    pCs1Res->CS_Header.CSD_Flags            = 0;
 
    CM_Enumerate_Classes(0, &(pCs1Res->CS_Header.CSD_ClassGuid), 0);
 
    for (i = 0; i < 16; i++) {
        pCs1Res->CS_Header.CSD_Signature[i] = i;
    }
 

    CM_Add_Empty_Log_Conf(&BootLC1, dnDevNode, LCPRI_BOOTCONFIG, BOOT_LOG_CONF);

    CM_Add_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, pCs1Res, sizeof(CS_RESOURCE)+15, 0);
    CM_Free_Res_Des(NULL, ResDes, 0);

    // This last one returns CR_INVALID_RES_DES.

    CM_Get_Next_Res_Des(&ResDes, BootLC1, ResType_ClassSpecific, NULL, 0);
    CM_Free_Res_Des( NULL, ResDes, 0);
    // This last one returns CR_INVALID_RES_DES.
 

    //Paula, once we're here: is it OK that now for the last resource freed the result will be CR_SUCESS instead CR_NO_MORE_RES_DES ?   

    /*
1. If you try to free the first res des in a BASIC (FILTERED, OVERRIDE) log conf, this will 
succees with CR_SUCCESS every time, even it's the only res des added (a subsequent 
CM_Get_Next_Res_Des(..., lcLogConf, ...) will return CR_NO_MORE_RES_DES).

2. If there are two res des for the same log conf (I tried with two identical memory 
res des, each with MD_Count == 1, BASIC log conf) and you free the first one, when you 
try to retrieve the remaining one (with CM_Get_Next_Res_Des(...,lcLogConf,...) the 
resource type field (pResourceId) is set to 0, causing the next free to fail. More precisely:
*/


    pMemRes = malloc(sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE));
 
    pMemRes->MEM_Header.MD_Count      = 2;
    pMemRes->MEM_Header.MD_Type       = MType_Range;
    pMemRes->MEM_Header.MD_Alloc_Base = (DWORDLONG)0xD8000;
    pMemRes->MEM_Header.MD_Alloc_End  = (DWORDLONG)0xD9000;
    pMemRes->MEM_Header.MD_Flags      = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Header.MD_Reserved   = 0;
 
    pMemRes->MEM_Data[0].MR_Align     = 8; //?
    pMemRes->MEM_Data[0].MR_nBytes    = 4096;
    pMemRes->MEM_Data[0].MR_Min       = (DWORDLONG)0xD8000;
    pMemRes->MEM_Data[0].MR_Max       = (DWORDLONG)0xDC000;
    pMemRes->MEM_Data[0].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Data[0].MR_Reserved  = 0;
 
    pMemRes->MEM_Data[1].MR_Align     = 8; //?
    pMemRes->MEM_Data[1].MR_nBytes    = 4096;
    pMemRes->MEM_Data[1].MR_Min       = (DWORDLONG)0xE0000;
    pMemRes->MEM_Data[1].MR_Max       = (DWORDLONG)0xE4000;
    pMemRes->MEM_Data[1].MR_Flags     = fMD_ROM | fMD_32 | fMD_ReadAllowed;
    pMemRes->MEM_Data[1].MR_Reserved  = 0;
 
    CM_Add_Empty_Log_Conf(&BasicLC1, dnDevNode, LCPRI_NORMAL, BASIC_LOG_CONF);

    CM_Add_Res_Des(&ResDes, BasicLC1, ResType_Mem, pMemRes, sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
    CM_Free_Res_Des_Handle(ResDes);
    
    CM_Add_Res_Des(&ResDes, BasicLC1, ResType_Mem, pMemRes, sizeof(MEM_RESOURCE) + sizeof(MEM_RANGE), 0);
    CM_Free_Res_Des_Handle(ResDes);
    
    CM_Get_Next_Res_Des(&ResDes,  BasicLC1, ResType_All,  &ResourceID, 0);
    //
    //  returns CR_SUCCESS, ridRseourceID is 1 (memory)
    //
    CM_Free_Res_Des(&ResDes, ResDes, 0);

    //
    // returns CR_SUCCESS
    //

    CM_Get_Next_Res_Des(&ResDes,  BasicLC1, ResType_All,  &ResourceID, 0);
    //
    // This one returns CR_SUCCESS, but ridResourceID is 0, so the next free will fail
    //
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\chnghal\precomp.h ===
#include "chnghal.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\chnghal\chnghal.c ===
#include "precomp.h"
#pragma hdrstop

typedef enum {
    ACPIAPIC_UP,
    MPS_UP,
    HAL_TYPE_OTHER
} HalType;
               

typedef BOOL (WINAPI *UPDATE_DRIVER_FOR_PLUG_AND_PLAY_DEVICES_PROC) (
    HWND hwndParent,
    LPCTSTR HardwareId,
    LPCTSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired
    );


DWORD
GetCurrentlyInstalledHal(
    HDEVINFO hDeviceInfo,
    PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine will determine if the currently installed HAL on this machine.
    
Arguments:

    hDeviceInfo - handle to the device information set that contains the HAL for
                  this machine.
    
    DeviceInfoData - pointer to the SP_DEVINFO_DATA structure that contains the 
                     specific HAL devnode for this machine.

Return Value:

    The return value will be one of the HalType enums:
        ACPIAPIC_UP
        MPS_UP
        HAL_TYPE_OTHER
        
    We only care about the ACPIAPIC_UP and the MPS_UP case since those are the only
    ones we can currently update to MP Hals.        

--*/
{
    DWORD CurrentlyInstalledHalType = HAL_TYPE_OTHER;
    HKEY hKey = INVALID_HANDLE_VALUE;
    TCHAR InfSection[LINE_LEN];
    DWORD RegDataType, RegDataLength;

    //
    // The "InfSection" is stored in the devnodes driver key
    //
    hKey = SetupDiOpenDevRegKey(hDeviceInfo,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ
                                );

    if (hKey != INVALID_HANDLE_VALUE) {
    
        RegDataLength = sizeof(InfSection);
        if (RegQueryValueEx(hKey,
                            REGSTR_VAL_INFSECTION,
                            NULL,
                            &RegDataType,
                            (PBYTE)InfSection,
                            &RegDataLength
                            ) == ERROR_SUCCESS) {
    
            printf("Current HAL is using InfSection %ws\n", InfSection);
    
            //
            // Compare the InfSection to see if it is one of the two that 
            // we can change from UP to MP.
            //
            if (!lstrcmpi(InfSection, TEXT("ACPIAPIC_UP_HAL"))) {

                CurrentlyInstalledHalType = ACPIAPIC_UP;
            }
            
            if (!lstrcmpi(InfSection, TEXT("MPS_UP_HAL"))) {

                CurrentlyInstalledHalType = MPS_UP;
            }
        }

        RegCloseKey(hKey);
    }

    return CurrentlyInstalledHalType;
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    HDEVINFO hDeviceInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD CurrentlyInstalledHalType = HAL_TYPE_OTHER;
    TCHAR HardwareId[MAX_DEVICE_ID_LEN];
    TCHAR FullInfPath[MAX_PATH];
    HMODULE hNewDev;
    UPDATE_DRIVER_FOR_PLUG_AND_PLAY_DEVICES_PROC pfnUpdateDriverForPlugAndPlayDevices;

    //
    // Ask setupapi to build up a list of all the COMPUTER class devnodes
    // on this machine.
    //
    hDeviceInfo = SetupDiGetClassDevs(&GUID_DEVCLASS_COMPUTER,
                                      NULL,
                                      NULL,
                                      DIGCF_PRESENT
                                      );

    if (hDeviceInfo == INVALID_HANDLE_VALUE) {

        printf("ERROR could not find a HAL devnode on this machine!\n");
        return 0;
    }

    //
    // There is only one HAL per machine, so we will just grab the 1st device
    // information data element in the list.
    //
    DeviceInfoData.cbSize = sizeof(DeviceInfoData);
    if (!SetupDiEnumDeviceInfo(hDeviceInfo,
                               0,
                               &DeviceInfoData
                               )) {

        goto clean0;
    }

    //
    // Get the currently installed Hal Type.
    // The currently installed Hal must be ACPIAPIC_UP or MPS_UP in order for us
    // to upgrade it to an MP Hal.
    //
    CurrentlyInstalledHalType = GetCurrentlyInstalledHal(hDeviceInfo, &DeviceInfoData);

    if (CurrentlyInstalledHalType == HAL_TYPE_OTHER) {

        printf("The currently installed HAL is not upgradable to MP!\n");
        
        goto clean0;
    }

    //
    // At this point we know what the currently installed Hal is and we know that it
    // has a corresponding MP Hal that it can be upgraded to.  In order to upgrade
    // the Hal we will replace the Hals Hardware Id registry key with the appropriate
    // MP Hardware Id and then call the newdev.dll API UpdateDriverForPlugAndPlayDevices
    // which will do the rest of the work.
    //
    memset(HardwareId, 0, sizeof(HardwareId));

    if (CurrentlyInstalledHalType == ACPIAPIC_UP) {
        
        lstrcpy(HardwareId, TEXT("ACPIAPIC_MP"));
    
    } else {

        lstrcpy(HardwareId, TEXT("MPS_MP"));
    }

    if (SetupDiSetDeviceRegistryProperty(hDeviceInfo,
                                         &DeviceInfoData,
                                         SPDRP_HARDWAREID,
                                         (CONST BYTE*)HardwareId,
                                         (sizeof(HardwareId) + 2) * sizeof(TCHAR)
                                         )) {
        //
        // The Hardware Id has now been changed so call UpdateDriverForPlugAndPlayDevices
        // to upate the driver on this device.
        //
        // UpdateDriverForPlugAndPlayDevices needs to have a full path to the INF file.
        // For this sample code we will always be using the hal.inf in the %windir%\inf
        // directory.
        // 
        if (GetWindowsDirectory(FullInfPath, sizeof(FullInfPath)/sizeof(TCHAR))) {

            lstrcat(FullInfPath, TEXT("\\INF\\HAL.INF"));

            hNewDev = LoadLibrary(TEXT("newdev.dll"));

            if (hNewDev) {

                pfnUpdateDriverForPlugAndPlayDevices = (UPDATE_DRIVER_FOR_PLUG_AND_PLAY_DEVICES_PROC)GetProcAddress(hNewDev,
                                                                                                                    "UpdateDriverForPlugAndPlayDevicesW"
                                                                                                                    );

                if (pfnUpdateDriverForPlugAndPlayDevices) {
                
                    BOOL bRet;

                    //
                    // Call UpdateDriverForPlugAndPlayDevices with the appropriate HardwareId and
                    // FullInfPath.  We will pass in 0 for the flags and NULL for the bRebootRequired
                    // pointer.  By passing in NULL for bRebootRequired this will tell newdev.dll to
                    // prompt for a reboot if one is needed.  Since we are replacing a Hal a reboot
                    // will always be needed.  If the caller of this program wants to handle the reboot
                    // logic themselves then just pass a PBOOL as the last parameter to 
                    // UpdateDriverForPlugAndPlayDevices and then handle the reboot yourself
                    // if this value is TRUE.
                    //
                    bRet = pfnUpdateDriverForPlugAndPlayDevices(NULL,
                                                         HardwareId,
                                                         FullInfPath,
                                                         0,
                                                         NULL
                                                         );

                    printf("UpdateDriverForPlugAndPlayDevices(%ws, %ws) returned 0x%X, 0x%X\n",
                           HardwareId, FullInfPath, bRet, GetLastError());
                }
                
                else {
                    printf("ERROR GetProcAddress() failed with 0x%X\n", GetLastError());
                }
            
                FreeLibrary(hNewDev);
            }
        }
    }


clean0:
    if (hDeviceInfo != INVALID_HANDLE_VALUE) {

        SetupDiDestroyDeviceInfoList(hDeviceInfo);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon\rc_ids.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rc_ids.h

Abstract:

    Header for devcon resources

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter 11/30/2000

@@END_DDKSPLIT
--*/

#define IDS_ENABLED         3000
#define IDS_ENABLED_REBOOT  3001
#define IDS_ENABLE_FAILED   3002
#define IDS_DISABLED        3003
#define IDS_DISABLED_REBOOT 3004
#define IDS_DISABLE_FAILED  3005
#define IDS_RESTARTED       3006
#define IDS_REQUIRES_REBOOT 3007
#define IDS_RESTART_FAILED  3008
#define IDS_REMOVED         3009
#define IDS_REMOVED_REBOOT  3010
#define IDS_REMOVE_FAILED   3011
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon\dump.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    dump.cpp

Abstract:

    Device Console
    dump information out about a particular device

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include "devcon.h"

BOOL DumpDeviceWithInfo(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,LPCTSTR Info)
/*++

Routine Description:

    Write device instance & info to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    TCHAR devID[MAX_DEVICE_ID_LEN];
    LPTSTR desc;
    BOOL b = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        lstrcpy(devID,TEXT("?"));
        b = FALSE;
    }

    if(Info) {
        _tprintf(TEXT("%-60s: %s\n"),devID,Info);
    } else {
        _tprintf(TEXT("%s\n"),devID);
    }
    return b;
}

BOOL DumpDevice(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR desc;
    BOOL b;

    desc = GetDeviceDescription(Devs,DevInfo);
    b = DumpDeviceWithInfo(Devs,DevInfo,desc);
    if(desc) {
        delete [] desc;
    }
    return b;
}

BOOL DumpDeviceDescr(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device description to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR desc;
    BOOL b;

    desc = GetDeviceDescription(Devs,DevInfo);
    if(!desc) {
        return FALSE;
    }
    Padding(1);
    FormatToStream(stdout,MSG_DUMP_DESCRIPTION,desc);
    delete [] desc;
    return TRUE;
}

BOOL DumpDeviceClass(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device class information to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR cls;
    LPTSTR guid;

    Padding(1);
    cls = GetDeviceStringProperty(Devs,DevInfo,SPDRP_CLASS);
    guid = GetDeviceStringProperty(Devs,DevInfo,SPDRP_CLASSGUID);
    if(!cls && !guid) {
        FormatToStream(stdout,
                        MSG_DUMP_NOSETUPCLASS
                        );
    } else {
        FormatToStream(stdout,
                        MSG_DUMP_SETUPCLASS,
                        guid ? guid : TEXT("{}"),
                        cls ? cls : TEXT("(?)")
                        );
    }

    if(cls) {
        delete [] cls;
    }
    if(guid) {
        delete [] guid;
    }

    return TRUE;
}

BOOL DumpDeviceStatus(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device status to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    ULONG status = 0;
    ULONG problem = 0;
    BOOL hasInfo = FALSE;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        return FALSE;
    }
    //
    // handle off the status/problem codes
    //
    if((status & DN_HAS_PROBLEM) && problem == CM_PROB_DISABLED) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DISABLED);
        return TRUE;
    }
    if(status & DN_HAS_PROBLEM) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_PROBLEM,problem);
    }
    if(status & DN_PRIVATE_PROBLEM) {
        hasInfo = TRUE;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_PRIVATE_PROBLEM);
    }
    if(status & DN_STARTED) {
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_STARTED);
    } else if (!hasInfo) {
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_NOTSTARTED);
    }
    return TRUE;
}

BOOL DumpDeviceResourcesOfType(DEVINST DevInst,HMACHINE MachineHandle,LOG_CONF Config,RESOURCEID ReqResId)
{
    RES_DES prevResDes = (RES_DES)Config;
    RES_DES resDes = 0;
    RESOURCEID resId = ReqResId;
    ULONG dataSize;
    PBYTE resDesData;
    while(CM_Get_Next_Res_Des_Ex(&resDes,prevResDes,ReqResId,&resId,0,MachineHandle)==CR_SUCCESS) {
        if(prevResDes != Config) {
            CM_Free_Res_Des_Handle(prevResDes);
        }
        prevResDes = resDes;
        if(CM_Get_Res_Des_Data_Size_Ex(&dataSize,resDes,0,MachineHandle)!=CR_SUCCESS) {
            continue;
        }
        resDesData = new BYTE[dataSize];
        if(!resDesData) {
            continue;
        }
        if(CM_Get_Res_Des_Data_Ex(resDes,resDesData,dataSize,0,MachineHandle)!=CR_SUCCESS) {
            delete [] resDesData;
            continue;
        }
        switch(resId) {
            case ResType_Mem: {

                PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)resDesData;
                if(pMemData->MEM_Header.MD_Alloc_End-pMemData->MEM_Header.MD_Alloc_Base+1) {
                    Padding(2);
                    _tprintf(TEXT("MEM : %08I64x-%08I64x\n"),pMemData->MEM_Header.MD_Alloc_Base,pMemData->MEM_Header.MD_Alloc_End);
                }
                break;
            }

            case ResType_IO: {

                PIO_RESOURCE   pIoData = (PIO_RESOURCE)resDesData;
                if(pIoData->IO_Header.IOD_Alloc_End-pIoData->IO_Header.IOD_Alloc_Base+1) {
                    Padding(2);
                    _tprintf(TEXT("IO  : %04I64x-%04I64x\n"),pIoData->IO_Header.IOD_Alloc_Base,pIoData->IO_Header.IOD_Alloc_End);
                }
                break;
            }

            case ResType_DMA: {

                PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)resDesData;
                Padding(2);
                _tprintf(TEXT("DMA : %u\n"),pDmaData->DMA_Header.DD_Alloc_Chan);
                break;
            }

            case ResType_IRQ: {

                PIRQ_RESOURCE  pIrqData = (PIRQ_RESOURCE)resDesData;

                Padding(2);
                _tprintf(TEXT("IRQ : %u\n"),pIrqData->IRQ_Header.IRQD_Alloc_Num);
                break;
            }
        }
        delete [] resDesData;
    }
    if(prevResDes != Config) {
        CM_Free_Res_Des_Handle(prevResDes);
    }
    return TRUE;
}

BOOL DumpDeviceResources(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Dump Resources to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    ULONG status = 0;
    ULONG problem = 0;
    LOG_CONF config = 0;
    BOOL haveConfig = FALSE;

    //
    // see what state the device is in
    //
    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_DevNode_Status_Ex(&status,&problem,DevInfo->DevInst,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        return FALSE;
    }

    //
    // see if the device is running and what resources it might be using
    //
    if(!(status & DN_HAS_PROBLEM)) {
        //
        // If this device is running, does this devinst have a ALLOC log config?
        //
        if (CM_Get_First_Log_Conf_Ex(&config,
                                     DevInfo->DevInst,
                                     ALLOC_LOG_CONF,
                                     devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
            haveConfig = TRUE;
        }
    }
    if(!haveConfig) {
        //
        // If no config so far, does it have a FORCED log config?
        // (note that technically these resources might be used by another device
        // but is useful info to show)
        //
        if (CM_Get_First_Log_Conf_Ex(&config,
                                     DevInfo->DevInst,
                                     FORCED_LOG_CONF,
                                     devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
            haveConfig = TRUE;
        }
    }

    if(!haveConfig) {
        //
        // if there's a hardware-disabled problem, boot-config isn't valid
        // otherwise use this if we don't have anything else
        //
        if(!(status & DN_HAS_PROBLEM) || (problem != CM_PROB_HARDWARE_DISABLED)) {
            //
            // Does it have a BOOT log config?
            //
            if (CM_Get_First_Log_Conf_Ex(&config,
                                         DevInfo->DevInst,
                                         BOOT_LOG_CONF,
                                         devInfoListDetail.RemoteMachineHandle) == CR_SUCCESS) {
                haveConfig = TRUE;
            }
        }
    }

    if(!haveConfig) {
        //
        // if we don't have any configuration, display an apropriate message
        //
        Padding(1);
        FormatToStream(stdout,(status & DN_STARTED) ? MSG_DUMP_NO_RESOURCES : MSG_DUMP_NO_RESERVED_RESOURCES );
        return TRUE;
    }
    Padding(1);
    FormatToStream(stdout,(status & DN_STARTED) ? MSG_DUMP_RESOURCES : MSG_DUMP_RESERVED_RESOURCES );

    //
    // dump resources
    //
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_Mem);
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_IO);
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_DMA);
    DumpDeviceResourcesOfType(DevInfo->DevInst,devInfoListDetail.RemoteMachineHandle,config,ResType_IRQ);

    //
    // release handle
    //
    CM_Free_Log_Conf_Handle(config);

    return TRUE;
}


UINT DumpDeviceDriversCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2)
/*++

Routine Description:

    if Context provided, Simply count
    otherwise dump files indented 2

Arguments:

    Context      - DWORD Count
    Notification - SPFILENOTIFY_QUEUESCAN
    Param1       - scan

Return Value:

    none

--*/
{
    LPDWORD count = (LPDWORD)Context;
    LPTSTR file = (LPTSTR)Param1;
    if(count) {
        count[0]++;
    } else {
        Padding(2);
        _tprintf(TEXT("%s\n"),file);
    }

    return NO_ERROR;
}

BOOL FindCurrentDriver(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,PSP_DRVINFO_DATA DriverInfoData)
/*++

Routine Description:

    Find the driver that is associated with the current device
    We can do this either the quick way (available in WinXP)
    or the long way that works in Win2k.

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if we managed to determine and select current driver

--*/
{
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    WCHAR SectionName[LINE_LEN];
    WCHAR DrvDescription[LINE_LEN];
    WCHAR MfgName[LINE_LEN];
    WCHAR ProviderName[LINE_LEN];
    HKEY hKey = NULL;
    DWORD RegDataLength;
    DWORD RegDataType;
    DWORD c;
    BOOL match = FALSE;
    long regerr;

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

#ifdef DI_FLAGSEX_INSTALLEDDRIVER
    //
    // Set the flags that tell SetupDiBuildDriverInfoList to just put the
    // currently installed driver node in the list, and that it should allow
    // excluded drivers. This flag introduced in WinXP.
    //
    deviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

    if(SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        //
        // we were able to specify this flag, so proceed the easy way
        // we should get a list of no more than 1 driver
        //
        if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_CLASSDRIVER)) {
            return FALSE;
        }
        if (!SetupDiEnumDriverInfo(Devs, DevInfo, SPDIT_CLASSDRIVER,
                                   0, DriverInfoData)) {
            return FALSE;
        }
        //
        // we've selected the current driver
        //
        return TRUE;
    }
    deviceInstallParams.FlagsEx &= ~(DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);
#endif
    //
    // The following method works in Win2k, but it's slow and painful.
    //
    // First, get driver key - if it doesn't exist, no driver
    //
    hKey = SetupDiOpenDevRegKey(Devs,
                                DevInfo,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ
                               );

    if(hKey == INVALID_HANDLE_VALUE) {
        //
        // no such value exists, so there can't be an associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain path of INF - we'll do a search on this specific INF
    //
    RegDataLength = sizeof(deviceInstallParams.DriverPath); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_INFPATH,
                             NULL,
                             &RegDataType,
                             (PBYTE)deviceInstallParams.DriverPath,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so no associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain name of Provider to fill into DriverInfoData
    //
    RegDataLength = sizeof(ProviderName); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_PROVIDER_NAME,
                             NULL,
                             &RegDataType,
                             (PBYTE)ProviderName,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // obtain name of section - for final verification
    //
    RegDataLength = sizeof(SectionName); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_INFSECTION,
                             NULL,
                             &RegDataType,
                             (PBYTE)SectionName,
                             &RegDataLength
                             );

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        RegCloseKey(hKey);
        return FALSE;
    }

    //
    // driver description (need not be same as device description)
    // - for final verification
    //
    RegDataLength = sizeof(DrvDescription); // bytes!!!
    regerr = RegQueryValueEx(hKey,
                             REGSTR_VAL_DRVDESC,
                             NULL,
                             &RegDataType,
                             (PBYTE)DrvDescription,
                             &RegDataLength
                             );

    RegCloseKey(hKey);

    if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        return FALSE;
    }

    //
    // Manufacturer (via SPDRP_MFG, don't access registry directly!)
    //

    if(!SetupDiGetDeviceRegistryProperty(Devs,
                                        DevInfo,
                                        SPDRP_MFG,
                                        NULL,      // datatype is guaranteed to always be REG_SZ.
                                        (PBYTE)MfgName,
                                        sizeof(MfgName), // bytes!!!
                                        NULL)) {
        //
        // no such value exists, so we don't have a valid associated driver
        //
        return FALSE;
    }

    //
    // now search for drivers listed in the INF
    //
    //
    deviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    deviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }
    if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_CLASSDRIVER)) {
        return FALSE;
    }

    //
    // find the entry in the INF that was used to install the driver for
    // this device
    //
    for(c=0;SetupDiEnumDriverInfo(Devs,DevInfo,SPDIT_CLASSDRIVER,c,DriverInfoData);c++) {
        if((lstrcmp(DriverInfoData->MfgName,MfgName)==0)
            &&(lstrcmp(DriverInfoData->ProviderName,ProviderName)==0)) {
            //
            // these two fields match, try more detailed info
            // to ensure we have the exact driver entry used
            //
            SP_DRVINFO_DETAIL_DATA detail;
            detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
            if(!SetupDiGetDriverInfoDetail(Devs,DevInfo,DriverInfoData,&detail,sizeof(detail),NULL)
                    && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
                continue;
            }
            if((lstrcmp(detail.SectionName,SectionName)==0) &&
                (lstrcmp(detail.DrvDescription,DrvDescription)==0)) {
                match = TRUE;
                break;
            }
        }
    }
    if(!match) {
        SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_CLASSDRIVER);
    }
    return match;
}

BOOL DumpDeviceDriverFiles(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Dump information about what files were installed for driver package
    <tab>Installed using OEM123.INF section [abc.NT]
    <tab><tab>file...

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    //
    // do this by 'searching' for the current driver
    // mimmicing a copy-only install to our own file queue
    // and then parsing that file queue
    //
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetail;
    HSPFILEQ queueHandle = INVALID_HANDLE_VALUE;
    DWORD count;
    DWORD scanResult;
    BOOL success = FALSE;

    ZeroMemory(&driverInfoData,sizeof(driverInfoData));
    driverInfoData.cbSize = sizeof(driverInfoData);

    if(!FindCurrentDriver(Devs,DevInfo,&driverInfoData)) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVER);
        return FALSE;
    }

    //
    // get useful driver information
    //
    driverInfoDetail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if(!SetupDiGetDriverInfoDetail(Devs,DevInfo,&driverInfoData,&driverInfoDetail,sizeof(SP_DRVINFO_DETAIL_DATA),NULL) &&
       GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        //
        // no information about driver or section
        //
        goto final;
    }
    if(!driverInfoDetail.InfFileName[0] || !driverInfoDetail.SectionName[0]) {
        goto final;
    }

    //
    // pretend to do the file-copy part of a driver install
    // to determine what files are used
    // the specified driver must be selected as the active driver
    //
    if(!SetupDiSetSelectedDriver(Devs, DevInfo, &driverInfoData)) {
        goto final;
    }

    //
    // create a file queue so we can look at this queue later
    //
    queueHandle = SetupOpenFileQueue();

    if ( queueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        goto final;
    }

    //
    // modify flags to indicate we're providing our own queue
    //
    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams) ) {
        goto final;
    }

    //
    // we want to add the files to the file queue, not install them!
    //
    deviceInstallParams.FileQueue = queueHandle;
    deviceInstallParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams) ) {
        goto final;
    }

    //
    // now fill queue with files that are to be installed
    // this involves all class/co-installers
    //
    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, Devs, DevInfo) ) {
        goto final;
    }

    //
    // we now have a list of delete/rename/copy files
    // iterate the copy queue twice - 1st time to get # of files
    // 2nd time to get files
    // (WinXP has API to get # of files, but we want this to work
    // on Win2k too)
    //

    count = 0;
    scanResult = 0;
    //
    // call once to count
    //
    SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,DumpDeviceDriversCallback,&count,&scanResult);
    Padding(1);
    FormatToStream(stdout, count ? MSG_DUMP_DRIVER_FILES : MSG_DUMP_NO_DRIVER_FILES, count, driverInfoDetail.InfFileName, driverInfoDetail.SectionName);
    //
    // call again to dump the files
    //
    SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,DumpDeviceDriversCallback,NULL,&scanResult);

    success = TRUE;

final:

    SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_CLASSDRIVER);

    if ( queueHandle != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        SetupCloseFileQueue(queueHandle);
    }

    if(!success) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVER);
    }

    return success;

}

BOOL DumpArray(int pad,LPTSTR * IDs)
/*++

Routine Description:

    Iterate array and dump entries to screen

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    if(!IDs || !IDs[0]) {
        return FALSE;
    }
    while(IDs[0]) {
        Padding(pad);
        _tprintf(TEXT("%s\n"),IDs[0]);
        IDs++;
    }
    return TRUE;
}

BOOL DumpDeviceHwIds(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout
    <tab>Hardware ID's
    <tab><tab>ID
    ...
    <tab>Compatible ID's
    <tab><tab>ID
    ...
    or
    <tab>No Hardware ID's for device

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    LPTSTR * hwIdArray = GetDevMultiSz(Devs,DevInfo,SPDRP_HARDWAREID);
    LPTSTR * compatIdArray = GetDevMultiSz(Devs,DevInfo,SPDRP_COMPATIBLEIDS);
    BOOL displayed = FALSE;

    if(hwIdArray && hwIdArray[0]) {
        displayed = TRUE;
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_HWIDS);
        DumpArray(2,hwIdArray);
    }
    if(compatIdArray && compatIdArray[0]) {
        displayed = TRUE;
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_COMPATIDS);
        DumpArray(2,compatIdArray);
    }
    if(!displayed) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_HWIDS);
    }

    DelMultiSz(hwIdArray);
    DelMultiSz(compatIdArray);

    return TRUE;
}

BOOL DumpDeviceDriverNodes(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write device instance & description to stdout
    <tab>Installed using OEM123.INF section [abc.NT]
    <tab><tab>file...

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    none

--*/
{
    BOOL success = FALSE;
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    SP_DRVINFO_DATA driverInfoData;
    SP_DRVINFO_DETAIL_DATA driverInfoDetail;
    SP_DRVINSTALL_PARAMS driverInstallParams;
    DWORD index;
    SYSTEMTIME SystemTime;
    ULARGE_INTEGER Version;
    TCHAR Buffer[MAX_PATH];

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    ZeroMemory(&driverInfoData, sizeof(driverInfoData));

    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

    //
    // Set the flags that tell SetupDiBuildDriverInfoList to allow excluded drivers.
    //
    deviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    if(!SetupDiSetDeviceInstallParams(Devs, DevInfo, &deviceInstallParams)) {
        return FALSE;
    }

    //
    // Now build a class driver list.
    //
    if(!SetupDiBuildDriverInfoList(Devs, DevInfo, SPDIT_COMPATDRIVER)) {
        goto final2;
    }

    //
    // Enumerate all of the drivernodes.
    //
    index = 0;
    while(SetupDiEnumDriverInfo(Devs, DevInfo, SPDIT_COMPATDRIVER,
                                index, &driverInfoData)) {

        success = TRUE;

        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_HEADER,index);

        //
        // get useful driver information
        //
        driverInfoDetail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(SetupDiGetDriverInfoDetail(Devs,DevInfo,&driverInfoData,&driverInfoDetail,sizeof(SP_DRVINFO_DETAIL_DATA),NULL) ||
           GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_INF,driverInfoDetail.InfFileName);
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_SECTION,driverInfoDetail.SectionName);
        }

        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DESCRIPTION,driverInfoData.Description);
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_MFGNAME,driverInfoData.MfgName);
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_PROVIDERNAME,driverInfoData.ProviderName);

        if (FileTimeToSystemTime(&driverInfoData.DriverDate, &SystemTime)) {
            if (GetDateFormat(LOCALE_USER_DEFAULT,
                              DATE_SHORTDATE,
                              &SystemTime,
                              NULL,
                              Buffer,
                              sizeof(Buffer)/sizeof(TCHAR)
                              ) != 0) {
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DRIVERDATE,Buffer);
            }
        }

        Version.QuadPart = driverInfoData.DriverVersion;
        Padding(1);
        FormatToStream(stdout,MSG_DUMP_DRIVERNODE_DRIVERVERSION,
                       HIWORD(Version.HighPart),
                       LOWORD(Version.HighPart),
                       HIWORD(Version.LowPart),
                       LOWORD(Version.LowPart)
                       );

        driverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if(SetupDiGetDriverInstallParams(Devs,DevInfo,&driverInfoData,&driverInstallParams)) {
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_RANK,driverInstallParams.Rank);
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS,driverInstallParams.Flags);

            //
            // Interesting flags to dump
            //
            if (driverInstallParams.Flags & DNF_OLD_INET_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_OLD_INET_DRIVER);
            }
            if (driverInstallParams.Flags & DNF_BAD_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_BAD_DRIVER);
            }
#if defined(DNF_INF_IS_SIGNED)
            //
            // DNF_INF_IS_SIGNED is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_INF_IS_SIGNED) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_INF_IS_SIGNED);
            }
#endif
#if defined(DNF_OEM_F6_INF)
            //
            // DNF_OEM_F6_INF is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_OEM_F6_INF) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_OEM_F6_INF);
            }
#endif
#if defined(DNF_BASIC_DRIVER)
            //
            // DNF_BASIC_DRIVER is only available since WinXP
            //
            if (driverInstallParams.Flags & DNF_BASIC_DRIVER) {
                Padding(2);
                FormatToStream(stdout,MSG_DUMP_DRIVERNODE_FLAGS_BASIC_DRIVER);
            }
#endif
        }

        index++;
    }

    SetupDiDestroyDriverInfoList(Devs,DevInfo,SPDIT_COMPATDRIVER);

final2:

    if(!success) {
        Padding(1);
        FormatToStream(stdout, MSG_DUMP_NO_DRIVERNODES);
    }

    return success;

}

BOOL DumpDeviceStack(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Write expected stack information to stdout

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    TRUE if success

--*/
{
    LPTSTR * filters;
    LPTSTR service;
    HKEY hClassKey = (HKEY)INVALID_HANDLE_VALUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    //
    // we need machine information
    //
    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) {
        return FALSE;
    }

    //
    // we need device setup class, we can use the GUID in DevInfo
    // note that this GUID is a snapshot, but works fine
    // if DevInfo isn't old
    //

    //
    // class upper/lower filters are in class registry
    //
    hClassKey = SetupDiOpenClassRegKeyEx(&DevInfo->ClassGuid,
                                         KEY_READ,
                                         DIOCR_INSTALLER,
                                         devInfoListDetail.RemoteMachineName[0] ? devInfoListDetail.RemoteMachineName : NULL,
                                         NULL);

    if(hClassKey != INVALID_HANDLE_VALUE) {
        //
        // dump upper class filters if available
        //
        filters = GetRegMultiSz(hClassKey,REGSTR_VAL_UPPERFILTERS);
        if(filters) {
            if(filters[0]) {
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DEVICESTACK_UPPERCLASSFILTERS);
                DumpArray(2,filters);
            }
            DelMultiSz(filters);
        }
    }
    filters = GetDevMultiSz(Devs,DevInfo,SPDRP_UPPERFILTERS);
    if(filters) {
        if(filters[0]) {
            //
            // dump upper device filters
            //
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DEVICESTACK_UPPERFILTERS);
            DumpArray(2,filters);
        }
        DelMultiSz(filters);
    }
    service = GetDeviceStringProperty(Devs,DevInfo,SPDRP_SERVICE);
    Padding(1);
    FormatToStream(stdout,MSG_DUMP_DEVICESTACK_SERVICE);
    if(service && service[0]) {
        //
        // dump service
        //
        Padding(2);
        _tprintf(TEXT("%s\n"),service);
    } else {
        //
        // dump the fact that there's no service
        //
        Padding(2);
        FormatToStream(stdout,MSG_DUMP_DEVICESTACK_NOSERVICE);
    }
    if(service) {
        delete [] service;
    }
    if(hClassKey != INVALID_HANDLE_VALUE) {
        filters = GetRegMultiSz(hClassKey,REGSTR_VAL_LOWERFILTERS);
        if(filters) {
            if(filters[0]) {
                //
                // lower class filters
                //
                Padding(1);
                FormatToStream(stdout,MSG_DUMP_DEVICESTACK_LOWERCLASSFILTERS);
                DumpArray(2,filters);
            }
            DelMultiSz(filters);
        }
        RegCloseKey(hClassKey);
    }
    filters = GetDevMultiSz(Devs,DevInfo,SPDRP_LOWERFILTERS);
    if(filters) {
        if(filters[0]) {
            //
            // lower device filters
            //
            Padding(1);
            FormatToStream(stdout,MSG_DUMP_DEVICESTACK_LOWERFILTERS);
            DumpArray(2,filters);
        }
        DelMultiSz(filters);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\device.cpp ===
// Device.cpp : Implementation of CDevice
#include "stdafx.h"
#include "DevCon2.h"
#include "Device.h"
#include "xStrings.h"
#include "Driver.h"
#include "Drivers.h"
#include "DrvSearchSet.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CDevice

CDevice::~CDevice()
{
    //
    // when this is destroyed, yank the entry out of HDEVINFO
    //
    if(DevInfoData.cbSize) {
        HDEVINFO hDevInfo = GetDevInfoSet();
        if(hDevInfo != INVALID_HANDLE_VALUE) {
            SetupDiDeleteDeviceInfo(hDevInfo,&DevInfoData);
        }
    }
}

HRESULT CDevice::Init(IDevInfoSet *pDevInfoSet, LPCWSTR pInstance,IDeviceConsole *pDevCon)
{
    //
    // init a new device (DeviceConsole/DevInfoSet are smart pointers)
    //
    DevInfoSet = pDevInfoSet;
    HDEVINFO hDevInfo = GetDevInfoSet();
    HRESULT hr;
    DWORD err;

    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    DeviceConsole = pDevCon;
    DevInfoData.cbSize = sizeof(DevInfoData);
    if(SetupDiOpenDeviceInfo(hDevInfo,pInstance,NULL,0,&DevInfoData)) {
        return S_OK;
    }
    err = GetLastError();
    hr = HRESULT_FROM_SETUPAPI(err);
    DevInfoData.cbSize = 0;
    return hr;
}

HRESULT CDevice::Init(IDevInfoSet *pDevInfoSet, PSP_DEVINFO_DATA pData,IDeviceConsole *pDevCon)
{
    //
    // init an existing device (DeviceConsole/DevInfoSet are smart pointers)
    //
    DevInfoSet = pDevInfoSet;
    DevInfoData = *pData;
    DeviceConsole = pDevCon;
    return S_OK;
}

HDEVINFO CDevice::GetDevInfoSet()
{
    ULONGLONG h;
    HRESULT hr;

    if(!DevInfoSet) {
        return (HDEVINFO)INVALID_HANDLE_VALUE;
    }
    hr = DevInfoSet->get_Handle(&h);
    if(FAILED(hr)) {
        return (HDEVINFO)INVALID_HANDLE_VALUE;
    }
    return (HDEVINFO)h;
}

STDMETHODIMP CDevice::get_InstanceId(BSTR *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_UNEXPECTED;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    //
    // get instance string given hDevInfo and DevInfoData
    //
    WCHAR devID[MAX_DEVICE_ID_LEN];
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfoData.DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        return E_UNEXPECTED;
    }
    *pVal = SysAllocString(devID);
    if(!*pVal) {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

BOOL CDevice::SameAs(CDevice *pOther)
{
    //
    // only works if pOther is in same set as us
    //
    if(pOther == this) {
        return TRUE;
    }
    if(!pOther) {
        return FALSE;
    }
    if(DevInfoData.cbSize != pOther->DevInfoData.cbSize) {
        return FALSE;
    }
    if(DevInfoData.DevInst != pOther->DevInfoData.DevInst) {
        return FALSE;
    }
    return TRUE;
}

STDMETHODIMP CDevice::Delete()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_REMOVEDEVICE_PARAMS rmdParams;

    ZeroMemory(&rmdParams,sizeof(rmdParams));
    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;

    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&rmdParams.ClassInstallHeader,sizeof(rmdParams))
        || !SetupDiCallClassInstaller(DIF_REMOVE,hDevInfo,&DevInfoData)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Enable()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;
    VARIANT_BOOL NeedReboot;
    VARIANT_BOOL NowNeedReboot;
    HRESULT hr;


    //
    // remember current reboot status
    //
    hr = get_RebootRequired(&NeedReboot);
    if(FAILED(hr)) {
        return hr;
    }

    //
    // attempt to enable globally
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_ENABLE;
    pcp.Scope = DICS_FLAG_GLOBAL;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    hr = get_RebootRequired(&NowNeedReboot);
    if(FAILED(hr)) {
        return hr;
    }
    if(!(NeedReboot || NowNeedReboot)) {
        //
        // reboot not required, we must have enabled the device
        //
        return S_OK;
    }
    if(!NeedReboot) {
        //
        // reset reboot status back to how it was originally
        //
        put_RebootRequired(VARIANT_FALSE);
    }
    //
    // also do config specific enable
    //
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_ENABLE;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp))
        && SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // succeeded to invoke config-specific
        //
        if(NeedReboot) {
            //
            // set back original status if reboot was required
            //
            put_RebootRequired(VARIANT_TRUE);
        }
        return CheckNoReboot();
    }
    //
    // if this failed, just imply reboot (our first result)
    //
    put_RebootRequired(VARIANT_TRUE);
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Disable()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to disable globally
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_DISABLE;
    pcp.Scope = DICS_FLAG_GLOBAL;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Start()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to start (can only be for this config)
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_ENABLE;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Stop()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to start (can only be for this config)
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_STOP;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

STDMETHODIMP CDevice::Restart()
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_PROPCHANGE_PARAMS pcp;

    //
    // attempt to stop then start (restart) (can only be for this config)
    //
    ZeroMemory(&pcp,sizeof(pcp));
    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = DICS_PROPCHANGE;
    pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
    pcp.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(hDevInfo,&DevInfoData,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,hDevInfo,&DevInfoData)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    return CheckNoReboot();
}

HRESULT CDevice::CheckNoReboot()
{
    VARIANT_BOOL NeedReboot;
    HRESULT hr = get_RebootRequired(&NeedReboot);
    if(FAILED(hr)) {
        return hr;
    }
    if(NeedReboot) {
        if(DeviceConsole) {
            //
            // set reboot required in device console too
            //
            DeviceConsole->put_RebootRequired(VARIANT_TRUE);
        }
        return S_FALSE;
    }
    return S_OK;
}

STDMETHODIMP CDevice::get_RebootRequired(VARIANT_BOOL *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_DEVINSTALL_PARAMS devParams;
    ZeroMemory(&devParams,sizeof(devParams));

    devParams.cbSize = sizeof(devParams);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,&DevInfoData,&devParams)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    *pVal = (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT)) ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

STDMETHODIMP CDevice::put_RebootRequired(VARIANT_BOOL newVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    BOOL changed = FALSE;
    SP_DEVINSTALL_PARAMS devParams;
    ZeroMemory(&devParams,sizeof(devParams));

    devParams.cbSize = sizeof(devParams);
    if(!SetupDiGetDeviceInstallParams(hDevInfo,&DevInfoData,&devParams)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    if(newVal) {
        if((devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT)) == 0) {
            devParams.Flags |= DI_NEEDREBOOT|DI_NEEDRESTART;
            changed = TRUE;
            if(DeviceConsole) {
                //
                // set reboot required in device console too
                //
                DeviceConsole->put_RebootRequired(VARIANT_TRUE);
            }
        }
    } else {
        if((devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT)) != 0) {
            devParams.Flags &= ~DI_NEEDREBOOT|DI_NEEDRESTART;
            changed = TRUE;
        }
    }
    if(changed) {
        if(!SetupDiSetDeviceInstallParams(hDevInfo,&DevInfoData,&devParams)) {
            DWORD Err = GetLastError();
            return HRESULT_FROM_SETUPAPI(Err);
        }
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_Description(BSTR *pVal)
{
    //
    // obtain a description for the device
    //
    HRESULT hr;
    CComVariant v;
    VARIANT final;
    VariantInit(&final);

    hr = GetDeviceProperty(SPDRP_FRIENDLYNAME,&v);
    if(SUCCEEDED(hr)) {
        hr = v.ChangeType(VT_BSTR);
        if(SUCCEEDED(hr)) {
            if(V_BSTR(&v)!=NULL && V_BSTR(&v)[0]) {
                v.Detach(&final);
                *pVal = V_BSTR(&final);
                return S_OK;
            }
        }
    }
    v.Clear();
    hr = GetDeviceProperty(SPDRP_DEVICEDESC,&v);
    if(SUCCEEDED(hr)) {
        hr = v.ChangeType(VT_BSTR);
        if(SUCCEEDED(hr)) {
            if(V_BSTR(&v)!=NULL && V_BSTR(&v)[0]) {
                v.Detach(&final);
                *pVal = V_BSTR(&final);
                return S_OK;
            }
        }
    }
    v.Clear();
    *pVal = SysAllocString(L"");
    if(!*pVal) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

STDMETHODIMP CDevice::get_HardwareIds(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_HARDWAREID,pVal);
}

STDMETHODIMP CDevice::put_HardwareIds(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_HARDWAREID,&newVal);
}

STDMETHODIMP CDevice::get_CompatibleIds(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_COMPATIBLEIDS,pVal);
}

STDMETHODIMP CDevice::put_CompatibleIds(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_COMPATIBLEIDS,&newVal);
}

STDMETHODIMP CDevice::get_ServiceName(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_SERVICE,pVal);
}

STDMETHODIMP CDevice::get_Class(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_CLASS,pVal);
}

STDMETHODIMP CDevice::get_Manufacturer(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_MFG,pVal);
}

STDMETHODIMP CDevice::get_FriendlyName(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_FRIENDLYNAME,pVal);
}

STDMETHODIMP CDevice::put_FriendlyName(VARIANT newVal)
{
    return PutDevicePropertyString(SPDRP_FRIENDLYNAME,&newVal);
}

STDMETHODIMP CDevice::get_LocationInformation(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_LOCATION_INFORMATION,pVal);
}

STDMETHODIMP CDevice::put_LocationInformation(VARIANT newVal)
{
    return PutDevicePropertyString(SPDRP_LOCATION_INFORMATION,&newVal);
}

STDMETHODIMP CDevice::get_UpperFilters(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_UPPERFILTERS,pVal);
}

STDMETHODIMP CDevice::put_UpperFilters(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_UPPERFILTERS,&newVal);
}

STDMETHODIMP CDevice::get_LowerFilters(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_LOWERFILTERS,pVal);
}

STDMETHODIMP CDevice::put_LowerFilters(VARIANT newVal)
{
    return PutDevicePropertyMultiSz(SPDRP_LOWERFILTERS,&newVal);
}

STDMETHODIMP CDevice::get_EnumeratorName(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_ENUMERATOR_NAME,pVal);
}

STDMETHODIMP CDevice::get_Security(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_SECURITY_SDS,pVal);
}

STDMETHODIMP CDevice::put_Security(VARIANT newVal)
{
    return PutDevicePropertyString(SPDRP_SECURITY_SDS,&newVal);
}

STDMETHODIMP CDevice::get_DeviceTypeOverride(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_DEVTYPE,pVal);
}

STDMETHODIMP CDevice::put_DeviceTypeOverride(VARIANT newVal)
{
    return PutDevicePropertyDword(SPDRP_DEVTYPE,&newVal);
}

STDMETHODIMP CDevice::get_ForceExclusive(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_EXCLUSIVE,pVal);
}

STDMETHODIMP CDevice::put_ForceExclusive(VARIANT newVal)
{
    return PutDevicePropertyDword(SPDRP_EXCLUSIVE,&newVal);
}

STDMETHODIMP CDevice::get_CharacteristicsOverride(VARIANT *pVal)
{
    return GetDeviceProperty(SPDRP_CHARACTERISTICS,pVal);
}

STDMETHODIMP CDevice::put_CharacteristicsOverride(VARIANT newVal)
{
    return PutDevicePropertyDword(SPDRP_CHARACTERISTICS,&newVal);
}

HRESULT CDevice::GetDeviceProperty(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    //
    // first obtain raw registry data
    //
    LPBYTE buffer = NULL;
    DWORD size = 1024;
    DWORD bufsize;
    DWORD reqSize;
    DWORD dataType;
    HRESULT hr;

    for(;;) {
        if(buffer) {
            delete [] buffer;
        }
        bufsize = size + sizeof(WCHAR)*2;
        buffer = new BYTE[bufsize];
        if(!buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiGetDeviceRegistryProperty(hDevInfo,&DevInfoData,prop,&dataType,buffer,size,&reqSize)) {
            break;
        }
        DWORD Err = GetLastError();
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            delete [] buffer;
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
    }

    //
    // now determine how to parcel it to caller
    //
    switch(dataType) {
    case REG_DWORD: {
            //
            // package value as a long
            //
            if(size != sizeof(DWORD)) {
                hr = E_INVALIDARG;
            } else {
                VariantClear(pVal);
                V_VT(pVal) = VT_I4;
                V_I4(pVal) = (long)*((DWORD*)buffer);
                hr = S_OK;
            }
        }
        break;

    case REG_SZ: {
            //
            // package value as string
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR));
            BSTR pString = SysAllocString((LPWSTR)buffer);
            if(!pString) {
                hr = E_OUTOFMEMORY;
            } else {
                V_VT(pVal) = VT_BSTR;
                V_BSTR(pVal) = pString;
                hr = S_OK;
            }
        }
        break;

    case REG_MULTI_SZ: {
            //
            // package as string-list
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR)*2);
            CComObject<CStrings> *strings;
            hr = CComObject<CStrings>::CreateInstance(&strings);
            if(FAILED(hr)) {
                break;
            }
            CComPtr<IStrings> stringsPtr = strings;
            LPWSTR p;
            UINT len = 0;
            for(p = (LPWSTR)buffer;*p;p+=len+1) {
                len = wcslen(p);
                hr = strings->InternalAdd(p,len);
                if(FAILED(hr)) {
                    break;
                }
            }
            V_VT(pVal) = VT_DISPATCH;
            V_DISPATCH(pVal) = stringsPtr.Detach();
            hr = S_OK;
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }
    delete [] buffer;
    return hr;

}

HRESULT CDevice::PutDevicePropertyString(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    CComVariant v;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = (SysStringLen(V_BSTR(&v))+1)*sizeof(WCHAR);
        data = (PBYTE)V_BSTR(&v);
    }

    if(SetupDiSetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        prop,
                                        data,
                                        len)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);
}

HRESULT CDevice::PutDevicePropertyDword(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    CComVariant v;
    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_I4,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = sizeof(V_I4(&v));
        data = (PBYTE)&V_I4(&v);
    }

    if(SetupDiSetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        prop,
                                        data,
                                        len)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);

}

HRESULT CDevice::PutDevicePropertyMultiSz(DWORD prop, VARIANT *pVal)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    //
    // build a CStrings collection
    //
    HRESULT hr;
    CComObject<CStrings> *strings = NULL;
    CComPtr<IStrings> stringsPtr;
    DWORD len = 0;
    PBYTE data = NULL;
    LPWSTR multisz;
    if(!IsBlank(pVal)) {
        hr = CComObject<CStrings>::CreateInstance(&strings);
        if(FAILED(hr)) {
            return hr;
        }
        stringsPtr = strings; // handle ref-counting
        hr = strings->Add(*pVal);
        if(FAILED(hr)) {
            return hr;
        }
        //
        // now obtain multisz from the collection
        //
        hr = strings->GetMultiSz(&multisz,&len);
        if(FAILED(hr)) {
            return hr;
        }
        //
        // now write the multi-sz value to device registry
        //
        len *= sizeof(WCHAR);
        data = (PBYTE)multisz;
    }
    if(SetupDiSetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        prop,
                                        (PBYTE)multisz,
                                        len)) {
        if(multisz) {
            delete [] multisz;
        }
        return S_OK;
    }
    DWORD Err = GetLastError();
    if(multisz) {
        delete [] multisz;
    }
    return HRESULT_FROM_SETUPAPI(Err);
}



HRESULT CDevice::GetRemoteMachine(HANDLE *hMachine)
{
    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    *hMachine = devInfoListDetail.RemoteMachineHandle;
    return S_OK;
}

STDMETHODIMP CDevice::get_IsRunning(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_STARTED) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsDisabled(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_HAS_PROBLEM) {
        if((problem == CM_PROB_DISABLED) || (problem == CM_PROB_HARDWARE_DISABLED)) {
            *pVal = VARIANT_TRUE;
            return S_OK;
        }
    }
    *pVal = VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDevice::get_HasProblem(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & (DN_HAS_PROBLEM|DN_PRIVATE_PROBLEM)) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_ProblemCode(long *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_HAS_PROBLEM) {
        *pVal = (long)problem;
    } else {
        *pVal = 0;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_HasPrivateProblem(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_PRIVATE_PROBLEM) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsRootEnumerated(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_ROOT_ENUMERATED) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsDisableable(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_DISABLEABLE) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get_IsRemovable(VARIANT_BOOL *pVal)
{
    HANDLE hMachine;
    ULONG status = 0;
    ULONG problem = 0;
    HRESULT hr = GetRemoteMachine(&hMachine);
    if(FAILED(hr)) {
        return hr;
    }
    if(CM_Get_DevNode_Status_Ex(&status,&problem,DevInfoData.DevInst,0,hMachine)!=CR_SUCCESS) {
        return E_UNEXPECTED;
    }
    if(status & DN_REMOVABLE) {
        *pVal = VARIANT_TRUE;
    } else {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}

BOOL CDevice::SameAs(LPWSTR str)
{
    BSTR pThisStr;
    HRESULT hr = get_InstanceId(&pThisStr);
    if(FAILED(hr)) {
        return FALSE;
    }
    BOOL f = _wcsicmp(str,pThisStr)==0;
    SysFreeString(pThisStr);
    return f;
}

STDMETHODIMP CDevice::RegRead(BSTR key,VARIANT * pValue)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR val;
    LPWSTR subkey;
    LONG regerr;
    DWORD regType;
    DWORD regSize;
    LPBYTE pByte;

    if(!pValue) {
        return E_INVALIDARG;
    }
    VariantInit(pValue);

    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&val,FALSE);
    if(FAILED(hr)) {
        return hr;
    }
    //
    // now work out and marshell data
    //
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_READ,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regSize = 0;
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,NULL,&regSize);
    if(regerr != NO_ERROR) {
        RegCloseKey(hKey);
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    pByte = new BYTE[regSize+sizeof(WCHAR)*2];
    if(!pByte) {
        RegCloseKey(hKey);
        return E_OUTOFMEMORY;
    }
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,pByte,&regSize);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    switch(regType) {
    case REG_DWORD:
        if(regSize != 4) {
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }

        V_VT(pValue) = VT_UI4;
        V_UI4(pValue) = *(DWORD*)pByte;
        break;

    case REG_BINARY:
        switch(regSize) {
        case 1:
            V_VT(pValue) = VT_UI1;
            V_UI1(pValue) = *((BYTE*)pByte);
            break;
        case 2:
            V_VT(pValue) = VT_UI2;
            V_UI2(pValue) = *((WORD*)pByte);
            break;
        case 4:
            V_VT(pValue) = VT_UI4;
            V_UI4(pValue) = *((DWORD*)pByte);
            break;
        default:
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        V_VT(pValue) = VT_BSTR;
        V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    case REG_MULTI_SZ: {
            ZeroMemory(pByte+regSize,sizeof(WCHAR)*2);
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                delete [] pByte;
                return hr;
            }
            CComPtr<IStrings> stringTempPtr = pStringTemp; // handle ref-counting
            hr = pStringTemp->FromMultiSz((LPWSTR)pByte);
            if(FAILED(hr)) {
                delete [] pByte;
                return hr;
            }
            V_VT(pValue) = VT_DISPATCH;
            V_DISPATCH(pValue) = stringTempPtr.Detach();
        }
        break;


    case REG_EXPAND_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,0);
        if(regSize == 0) {
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        } else {
            LPWSTR pExp = new WCHAR[regSize+1];
            if(!pExp) {
                delete [] pByte;
                return E_OUTOFMEMORY;
            }
            regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,regSize);
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString(pExp);
            delete [] pExp;
        }
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    default:
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    delete [] pByte;
    return S_OK;
}

STDMETHODIMP CDevice::RegWrite(BSTR key, VARIANT val, VARIANT strType)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    CComVariant strType_v;
    CComVariant val_v;
    LPCWSTR pType;
    HRESULT hr;
    DWORD dwType;
    BOOL DetermineType = FALSE;
    LPBYTE pData = NULL;
    LPWSTR pString = NULL;
    DWORD DataSize = 0;
    BYTE SimpleData[4];
    LPVARIANT pVal = &val;

    while(V_VT(pVal) == (VT_BYREF|VT_VARIANT)) {
        pVal = V_VARIANTREF(pVal);
    }

    //
    // validate strType
    //

    hr = GetOptionalString(&strType,strType_v,&pType);
    if(FAILED(hr)) {
        return hr;
    }

    if((pType == NULL) || !pType[0]) {
        //
        // determine type of variant
        //
        if(IsNumericVariant(pVal)) {
            dwType = REG_DWORD;
        } else if(IsMultiValueVariant(pVal)) {
            dwType = REG_MULTI_SZ;
        } else {
            dwType = REG_SZ;
        }
    } else if(_wcsicmp(pType,L"REG_DWORD")==0) {
        dwType = REG_DWORD;
    } else if(_wcsicmp(pType,L"REG_SZ")==0) {
        dwType = REG_SZ;
    } else if(_wcsicmp(pType,L"REG_EXPAND_SZ")==0) {
        dwType = REG_EXPAND_SZ;
    } else if(_wcsicmp(pType,L"REG_MULTI_SZ")==0) {
        dwType = REG_MULTI_SZ;
    } else if(_wcsicmp(pType,L"REG_BINARY")==0) {
        dwType = REG_BINARY;
    } else {
        return DISP_E_TYPEMISMATCH;
    }

    //
    // build up value data
    //
    switch(dwType) {
    case REG_BINARY:
        pData = SimpleData;
        switch V_VT(pVal) {
        case VT_I1:
        case VT_UI1:
            *(LPBYTE)pData = V_UI1(pVal);
            DataSize = 1;
            break;
        case VT_I1|VT_BYREF:
        case VT_UI1|VT_BYREF:
            *(LPBYTE)pData = *V_UI1REF(pVal);
            DataSize = 1;
            break;
        case VT_I2:
        case VT_UI2:
            *(LPWORD)pData = V_UI2(pVal);
            DataSize = 2;
            break;
        case VT_I2|VT_BYREF:
        case VT_UI2|VT_BYREF:
            *(LPWORD)pData = *V_UI2REF(pVal);
            DataSize = 2;
            break;
        case VT_I4:
        case VT_UI4:
            *(LPDWORD)pData = V_UI4(pVal);
            DataSize = 4;
            break;
        case VT_I4|VT_BYREF:
        case VT_UI4|VT_BYREF:
            *(LPDWORD)pData = *V_UI4REF(pVal);
            DataSize = 4;
            break;
        default:
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_DWORD:
        pData = SimpleData;
        hr = val_v.ChangeType(VT_UI4,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }
        *(LPDWORD)pData = V_UI4(pVal);
        DataSize = 4;
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
        hr = val_v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }

        DataSize = (SysStringLen(V_BSTR(&val_v))+1);
        pString = new WCHAR[DataSize];
        if(!pString) {
            return E_OUTOFMEMORY;
        }
        pData = (LPBYTE)pString;
        DataSize *= sizeof(WCHAR);
        memcpy(pData,V_BSTR(&val_v),DataSize);
        break;

    case REG_MULTI_SZ: {
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                return hr;
            }
            CComPtr<IStrings> pStringTempPtr = pStringTemp; // for ref-counting
            hr = pStringTemp->InternalInsert(0,pVal);
            if(FAILED(hr)) {
                return hr;
            }
            hr = pStringTemp->GetMultiSz(&pString,&DataSize);
            if(FAILED(hr)) {
                return hr;
            }
            pData = (LPBYTE)pString;
            DataSize *= sizeof(WCHAR);
        }
        break;
    default:
        return DISP_E_TYPEMISMATCH;
    }

    hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        if(pString) {
            delete [] pString;
        }
        return hr;
    }
    if(subkey) {
        regerr = RegCreateKeyEx(hParentKey,subkey,0,NULL,0,KEY_WRITE,NULL,&hKey,NULL);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            if(pString) {
                delete [] pString;
            }
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }

    regerr = RegSetValueEx(hKey,valname,0,dwType,pData,DataSize);
    if(pString) {
        delete [] pString;
    }
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }

    return S_OK;
}

STDMETHODIMP CDevice::RegDelete(BSTR key)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        return hr;
    }
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_WRITE,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regerr = RegDeleteValue(hKey,valname);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    return S_OK;
}

HRESULT CDevice::SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *pKeyVal,BOOL writeable)
{
    //
    // first 3 chars of subkey can be "SW\" or "HW\"
    //
    LPCWSTR partkey;
    DWORD Scope = DICS_FLAG_GLOBAL;
    DWORD HwProfile = 0;
    DWORD KeyType;
    HKEY hParentKey;
    LPWSTR keyname;
    LPCWSTR keyval;
    size_t len;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    if((subkey[0] == L'S' || subkey[0] == L's')
        &&(subkey[1] == L'W' || subkey[1] == L'w')
        &&(subkey[2] == L'\\')) {
        partkey = subkey+3;
        KeyType = DIREG_DRV;
    } else if((subkey[0] == L'H' || subkey[0] == L'h')
        &&(subkey[1] == L'W' || subkey[1] == L'w')
        &&(subkey[2] == L'\\')) {
        partkey = subkey+3;
        KeyType = DIREG_DEV;
    } else {
        return E_INVALIDARG;
    }
    hParentKey = SetupDiOpenDevRegKey(hDevInfo,
                                    &DevInfoData,
                                    Scope,
                                    HwProfile,
                                    KeyType,
                                    writeable ? KEY_WRITE: KEY_READ
                                    );
    if((hParentKey == NULL) || (hParentKey == INVALID_HANDLE_VALUE)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    //
    // determine value part of key
    //
    keyval = wcsrchr(partkey,L'\\');
    if(!keyval) {
        *hKey = hParentKey;
        *pKeyVal = partkey[0] ? partkey : NULL;
        *pSubKey = NULL;
        return S_OK;
    }
    len = keyval-partkey+1;
    keyname = new WCHAR[len];
    if(!keyname) {
        RegCloseKey(hParentKey);
        return E_OUTOFMEMORY;
    }
    wcsncpy(keyname,partkey,len);
    keyname[len-1] = 0;
    keyval++;
    if(!keyval[0]) {
        keyval = NULL;
    }
    *hKey = hParentKey;
    *pSubKey = keyname;
    *pKeyVal = keyval;
    return S_OK;
}

STDMETHODIMP CDevice::CurrentDriverPackage(LPDISPATCH *pDriver)
{
    *pDriver = NULL;
    //
    // create a search set for finding current driver
    //
    HRESULT hr;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    HANDLE remote;
    if(SUCCEEDED(GetRemoteMachine(&remote)) && remote) {

        //
        // remote driver search not implemented
        //
        return E_NOTIMPL;
    }

    CComObject<CDrvSearchSet> *pSet = NULL;

    hr = CComObject<CDrvSearchSet>::CreateInstance(&pSet);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IDrvSearchSet> pSetPtr = pSet; // for ref-counting
    hr = pSet->Init(this,SPDIT_CLASSDRIVER);
    if(FAILED(hr)) {
        return hr;
    }

    //
    // use temporary device information
    //
    HDEVINFO SetDevInfo = pSet->GetDevInfoSet();
    PSP_DEVINFO_DATA SetDevInfoData = pSet->GetDevInfoData();

    //
    // WinXP has a nice feature for obtaining current driver
    //
    DWORD Err;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;

    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if(!SetupDiGetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // Set the flags that tell SetupDiBuildDriverInfoList to just put the currently installed
    // driver node in the list, and that it should allow excluded drivers.
    //
    DeviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

    if(SetupDiSetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)
        && SetupDiBuildDriverInfoList(SetDevInfo, SetDevInfoData, SPDIT_CLASSDRIVER)) {
        if(!SetupDiEnumDriverInfo(SetDevInfo,SetDevInfoData,SPDIT_CLASSDRIVER,0,&DriverInfoData)) {
            //
            // flag recognized, but no driver
            //
            return S_OK;
        }
        //
        // DriverInfoData contains driver
        //
    } else {

        //
        // get information about a driver to do a full search
        //
        WCHAR SectionName[LINE_LEN];
        WCHAR DrvDescription[LINE_LEN];
        HKEY hKey = NULL;
        DWORD RegDataLength;
        DWORD RegDataType;
        long regerr;

        //
        // get driver key - if it doesn't exist, no driver
        //
        hKey = SetupDiOpenDevRegKey(SetDevInfo,
                                    SetDevInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DRV,
                                    KEY_READ
                                   );

        if(hKey == INVALID_HANDLE_VALUE) {
            //
            // no such value exists, so we haven't an associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }

        //
        // obtain path of INF
        //
        RegDataLength = sizeof(DeviceInstallParams.DriverPath); // want in bytes, not chars
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_INFPATH,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)DeviceInstallParams.DriverPath,
                                 &RegDataLength
                                 );

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we haven't an associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }


        RegDataLength = sizeof(DriverInfoData.ProviderName);
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_PROVIDER_NAME,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)DriverInfoData.ProviderName,
                                 &RegDataLength
                                 );

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }

        RegDataLength = sizeof(SectionName);
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_INFSECTION,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)SectionName,
                                 &RegDataLength
                                 );

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            RegCloseKey(hKey);
            return S_OK;
        }

        //
        // driver description is usually same as original device description
        // but sometimes obtained from strings section
        //
        RegDataLength = sizeof(DrvDescription);
        regerr = RegQueryValueEx(hKey,
                                 REGSTR_VAL_DRVDESC,
                                 NULL,
                                 &RegDataType,
                                 (PBYTE)DrvDescription,
                                 &RegDataLength
                                 );

        RegCloseKey(hKey);

        if((regerr != ERROR_SUCCESS) || (RegDataType != REG_SZ)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            return S_OK;
        }

        //
        // Manufacturer
        //

        if(!SetupDiGetDeviceRegistryProperty(SetDevInfo,
                                            SetDevInfoData,
                                            SPDRP_MFG,
                                            NULL,      // datatype is guaranteed to always be REG_SZ.
                                            (PBYTE)DriverInfoData.MfgName,
                                            sizeof(DriverInfoData.MfgName),
                                            NULL)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            return S_OK;
        }

        //
        // Description
        //

        if(!SetupDiGetDeviceRegistryProperty(SetDevInfo,
                                            SetDevInfoData,
                                            SPDRP_DEVICEDESC,
                                            NULL,      // datatype is guaranteed to always be REG_SZ.
                                            (PBYTE)DriverInfoData.Description,
                                            sizeof(DriverInfoData.Description),
                                            NULL)) {
            //
            // no such value exists, so we don't have a valid associated driver
            //
            return S_OK;
        }


        //
        // now search for drivers listed in the INF
        //
        //
        DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;
        DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_INSTALLEDDRIVER;
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

        if(!SetupDiSetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
            Err = GetLastError();
            return HRESULT_FROM_SETUPAPI(Err);
        }
        if(!SetupDiBuildDriverInfoList(SetDevInfo, SetDevInfoData, SPDIT_CLASSDRIVER)) {
            return S_OK;
        }

        //
        // enumerate drivers to find a good match
        //
        SP_DRVINFO_DATA ThisDriverInfoData;
        ZeroMemory(&ThisDriverInfoData, sizeof(ThisDriverInfoData));
        ThisDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

        DWORD c;
        BOOL match = FALSE;
        for(c=0;SetupDiEnumDriverInfo(SetDevInfo,SetDevInfoData,SPDIT_CLASSDRIVER,c,&ThisDriverInfoData);c++) {
            if((_wcsicmp(DriverInfoData.MfgName,ThisDriverInfoData.MfgName)==0)
                &&(_wcsicmp(DriverInfoData.ProviderName,ThisDriverInfoData.ProviderName)==0)) {
                //
                // these two fields match, try more detailed info
                //
                SP_DRVINFO_DETAIL_DATA detail;
                detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                if(!SetupDiGetDriverInfoDetail(SetDevInfo,SetDevInfoData,&ThisDriverInfoData,&detail,sizeof(detail),NULL)) {
                    Err = GetLastError();
                    if((Err != NO_ERROR) && (Err != ERROR_INSUFFICIENT_BUFFER)) {
                        continue;
                    }
                }
                if((_wcsicmp(SectionName,detail.SectionName)==0) &&
                    (_wcsicmp(DrvDescription,detail.DrvDescription)==0)) {
                    DriverInfoData = ThisDriverInfoData;
                    match = TRUE;
                    break;
                }
            }
        }
        if(!match) {
            return S_OK;
        }
    }

    //
    // create the driver object
    //
    CComObject<CDriverPackage> *driver = NULL;
    hr = CComObject<CDriverPackage>::CreateInstance(&driver);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IDriverPackage> driverPtr = driver; // for ref-counting
    hr = driver->Init(pSet,&DriverInfoData);
    if(FAILED(hr)) {
        return hr;
    }
    *pDriver = driverPtr.Detach();
    return S_OK;
}


STDMETHODIMP CDevice::FindDriverPackages(VARIANT ScriptPath, LPDISPATCH *pDriversOut)
{
    *pDriversOut = NULL;

    //
    // Treat variant as a multi-sz array if it exists
    //

    CComObject<CStrings> *pStrings = NULL;
    CComPtr<IStrings> pStringsPtr;
    CComObject<CDrvSearchSet> *pSet = NULL;
    CComPtr<IDrvSearchSet> pSetPtr;
    CComObject<CDriverPackages> *pDrivers = NULL;
    CComPtr<IDriverPackages> pDriversPtr;
    CComObject<CDriverPackage> *pDriver = NULL;
    CComPtr<IDriverPackage> pDriverPtr;
    HRESULT hr;

    if(!IsNoArg(&ScriptPath)) {
        hr = CComObject<CStrings>::CreateInstance(&pStrings);
        if(FAILED(hr)) {
            return hr;
        }
        pStringsPtr = pStrings;

        hr = pStrings->InternalInsert(0,&ScriptPath);
        if(FAILED(hr)) {
            return hr;
        }
    }

    //
    // create context for driver search
    //

    hr = CComObject<CDrvSearchSet>::CreateInstance(&pSet);
    if(FAILED(hr)) {
        return hr;
    }
    pSetPtr = pSet;
    hr = pSet->Init(this,SPDIT_COMPATDRIVER);
    if(FAILED(hr)) {
        return hr;
    }

    //
    // use temporary device information
    //
    HDEVINFO SetDevInfo = pSet->GetDevInfoSet();
    PSP_DEVINFO_DATA SetDevInfoData = pSet->GetDevInfoData();
    DWORD Err;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;
    DWORD c;

    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    if(!SetupDiGetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // Do a search in standard directories.
    //
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;

    BOOL done_wild = FALSE;
    BSTR str;

    for(c=0,str=NULL;(pStrings==NULL) || (pStrings->InternalEnum(c,&str));c++) {

        if(str && str[0] && ((str[0] != '*') || str[1])) {
            DWORD attr = GetFileAttributes(str);
            if(attr == (DWORD)(-1)) {
                continue;
            }
            DWORD sz = GetFullPathName(str,MAX_PATH,DeviceInstallParams.DriverPath,NULL);
            if(sz >= MAX_PATH) {
                DeviceInstallParams.DriverPath[0] = '\0';
                continue;
            }
            if(!(attr & FILE_ATTRIBUTE_DIRECTORY)) {
                DeviceInstallParams.FlagsEx |= DI_ENUMSINGLEINF;
            }
        } else if(done_wild) {
            continue;
        } else {
            done_wild = TRUE;
        }

        if(!SetupDiSetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams)) {
            Err = GetLastError();
            hr = HRESULT_FROM_SETUPAPI(Err);
            goto final;
        }


        if(!SetupDiBuildDriverInfoList(SetDevInfo, SetDevInfoData, SPDIT_COMPATDRIVER)) {
            Err = GetLastError();
            hr = HRESULT_FROM_SETUPAPI(Err);
            goto final;
        }

        SetupDiGetDeviceInstallParams(SetDevInfo, SetDevInfoData, &DeviceInstallParams);
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_APPENDDRIVERLIST;
        DeviceInstallParams.FlagsEx &= ~DI_ENUMSINGLEINF;
        DeviceInstallParams.DriverPath[0] = '\0';
    }

    //
    // now create the collection to hold search results
    //

    hr = CComObject<CDriverPackages>::CreateInstance(&pDrivers);
    if(FAILED(hr)) {
        pDrivers = NULL;
        goto final;
    }
    pDriversPtr = pDrivers;
    hr = pDrivers->Init(pSet);
    if(FAILED(hr)) {
        goto final;
    }

    for(c=0;SetupDiEnumDriverInfo(SetDevInfo,SetDevInfoData,SPDIT_COMPATDRIVER,c,&DriverInfoData);c++) {

        //
        // create the driver object
        //
        hr = CComObject<CDriverPackage>::CreateInstance(&pDriver);
        if(FAILED(hr)) {
            goto final;
        }
        pDriverPtr = pDriver;
        hr = pDriver->Init(pSet,&DriverInfoData);
        if(FAILED(hr)) {
            goto final;
        }
        hr = pDrivers->InternalAdd(pDriver);
        if(FAILED(hr)) {
            goto final;
        }
    }

final:

    if(FAILED(hr)) {
        return hr;
    }
    *pDriversOut = pDriversPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDevice::HasInterface(BSTR Interface, VARIANT_BOOL *pFlag)
{
    //
    // create a search set for finding current driver
    //
    HRESULT hr;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }

    GUID guid;
    hr = CLSIDFromString(Interface,&guid);
    if(FAILED(hr)) {
        return hr;
    }
    SP_DEVICE_INTERFACE_DATA data;
    ZeroMemory(&data,sizeof(data));
    data.cbSize = sizeof(data);
    BOOL f = SetupDiEnumDeviceInterfaces(hDevInfo,&DevInfoData,&guid,0,&data);
    DWORD Err = GetLastError();

    *pFlag = f? VARIANT_TRUE: VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDevice::get_Machine(BSTR *pVal)
{
    *pVal = NULL;

    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    if((devInfoListDetail.RemoteMachineHandle == NULL) || !devInfoListDetail.RemoteMachineName[0]) {
        *pVal = SysAllocString(L"");
        if(*pVal) {
            return S_FALSE;
        }
    } else {
        *pVal = SysAllocString(devInfoListDetail.RemoteMachineName);
        if(*pVal) {
            return S_OK;
        }
    }
    return E_OUTOFMEMORY;
}

STDMETHODIMP CDevice::get__ClassGuid(GUID *pVal)
{
    WCHAR ClassGuid[40];
    HRESULT hr;

    if(!DevInfoData.cbSize) {
        return E_INVALIDARG;
    }
    HDEVINFO hDevInfo = GetDevInfoSet();
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_UNEXPECTED;
    }
    DWORD reqSize;
    if(!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                        &DevInfoData,
                                        SPDRP_CLASSGUID,
                                        NULL,
                                        (LPBYTE)ClassGuid,
                                        sizeof(ClassGuid),
                                        &reqSize)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    hr = CLSIDFromString(ClassGuid,pVal);
    if(FAILED(hr)) {
        return hr;
    }

    return S_OK;
}

STDMETHODIMP CDevice::get__Machine(BSTR *pVal)
{
    return get_Machine(pVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon\devcon.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.h

Abstract:

    Device Console header

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <setupapi.h>
#include <regstr.h>
#include <cfgmgr32.h>
#include <string.h>
#include <malloc.h>
#include <newdev.h>

#include "msg.h"
#include "rc_ids.h"

typedef int (*DispatchFunc)(LPCTSTR BaseName,LPCTSTR Machine,int argc,LPTSTR argv[]);
typedef int (*CallbackFunc)(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context);

typedef struct {
    LPCTSTR         cmd;
    DispatchFunc    func;
    DWORD           shortHelp;
    DWORD           longHelp;
} DispatchEntry;

extern DispatchEntry DispatchTable[];

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#define INSTANCEID_PREFIX_CHAR TEXT('@') // character used to prefix instance ID's
#define CLASS_PREFIX_CHAR      TEXT('=') // character used to prefix class name
#define WILD_CHAR              TEXT('*') // wild character
#define QUOTE_PREFIX_CHAR      TEXT('\'') // prefix character to ignore wild characters

void FormatToStream(FILE * stream,DWORD fmt,...);
void Padding(int pad);
int EnumerateDevices(LPCTSTR BaseName,LPCTSTR Machine,DWORD Flags,int argc,LPTSTR argv[],CallbackFunc Callback,LPVOID Context);
LPTSTR GetDeviceStringProperty(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop);
LPTSTR GetDeviceDescription(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
LPTSTR * GetDevMultiSz(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop);
LPTSTR * GetRegMultiSz(HKEY hKey,LPCTSTR Val);
void DelMultiSz(LPTSTR * Array);

BOOL DumpDevice(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceClass(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDescr(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceStatus(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceResources(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDriverFiles(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceDriverNodes(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceHwIds(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL DumpDeviceWithInfo(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,LPCTSTR Info);
BOOL DumpDeviceStack(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo);
BOOL Reboot();


//
// UpdateDriverForPlugAndPlayDevices
//
typedef BOOL (WINAPI *UpdateDriverForPlugAndPlayDevicesProto)(HWND hwndParent,
                                                         LPCTSTR HardwareId,
                                                         LPCTSTR FullInfPath,
                                                         DWORD InstallFlags,
                                                         PBOOL bRebootRequired OPTIONAL
                                                         );

#ifdef _UNICODE
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesW"
#else
#define UPDATEDRIVERFORPLUGANDPLAYDEVICES "UpdateDriverForPlugAndPlayDevicesA"
#endif


//
// exit codes
//
#define EXIT_OK      (0)
#define EXIT_REBOOT  (1)
#define EXIT_FAIL    (2)
#define EXIT_USAGE   (3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon\cmds.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.cpp

Abstract:

    Device Console
    command-line interface for managing devices

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include "devcon.h"

int cmdHelp(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    HELP command
    allow HELP or HELP <command>

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine (ignored)
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    DWORD helptext = 0;
    int dispIndex;
    LPCTSTR cmd = NULL;
    BOOL unknown = FALSE;

    if(argc) {
        //
        // user passed in a command for help on... long help
        //
        for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
            if(lstrcmpi(argv[0],DispatchTable[dispIndex].cmd)==0) {
                cmd = DispatchTable[dispIndex].cmd;
                helptext = DispatchTable[dispIndex].longHelp;
                break;
            }
        }
        if(!cmd) {
            unknown = TRUE;
        }
    }

    if(helptext) {
        //
        // long help
        //
        FormatToStream(stdout,helptext,BaseName,cmd);
    } else {
        //
        // help help
        //
        FormatToStream(stdout,unknown ? MSG_HELP_OTHER : MSG_HELP_LONG,BaseName);
        //
        // enumerate through each command and display short help for each
        //
        for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
            if(DispatchTable[dispIndex].shortHelp) {
                FormatToStream(stdout,DispatchTable[dispIndex].shortHelp,DispatchTable[dispIndex].cmd);
            }
        }
    }
    return EXIT_OK;
}

int cmdClasses(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    CLASSES command
    lists classes on (optionally) specified machine
    format as <name>: <destination>

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - ignored

Return Value:

    EXIT_xxxx

--*/
{
    DWORD reqGuids = 128;
    DWORD numGuids;
    LPGUID guids = NULL;
    DWORD index;
    int failcode = EXIT_FAIL;

    guids = new GUID[reqGuids];
    if(!guids) {
        goto final;
    }
    if(!SetupDiBuildClassInfoListEx(0,guids,reqGuids,&numGuids,Machine,NULL)) {
        do {
            if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto final;
            }
            delete [] guids;
            reqGuids = numGuids;
            guids = new GUID[reqGuids];
            if(!guids) {
                goto final;
            }
        } while(!SetupDiBuildClassInfoListEx(0,guids,reqGuids,&numGuids,Machine,NULL));
    }
    FormatToStream(stdout,Machine?MSG_CLASSES_HEADER:MSG_CLASSES_HEADER_LOCAL,numGuids,Machine);
    for(index=0;index<numGuids;index++) {
        TCHAR className[MAX_CLASS_NAME_LEN];
        TCHAR classDesc[LINE_LEN];
        if(!SetupDiClassNameFromGuidEx(&guids[index],className,MAX_CLASS_NAME_LEN,NULL,Machine,NULL)) {
            lstrcpyn(className,TEXT("?"),MAX_CLASS_NAME_LEN);
        }
        if(!SetupDiGetClassDescriptionEx(&guids[index],classDesc,LINE_LEN,NULL,Machine,NULL)) {
            lstrcpyn(classDesc,className,LINE_LEN);
        }
        _tprintf(TEXT("%-20s: %s\n"),className,classDesc);
    }

    failcode = EXIT_OK;

final:

    delete [] guids;
    return failcode;
}

int cmdListClass(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    LISTCLASS <name>....
    lists all devices for each specified class
    there can be more than one physical class for a class name (shouldn't be
    though) in such cases, list each class
    if machine given, list devices for that machine

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - list of class names

Return Value:

    EXIT_xxxx

--*/
{
    BOOL classListed = FALSE;
    BOOL devListed = FALSE;
    DWORD reqGuids = 16;
    int argIndex;
    int failcode = EXIT_FAIL;
    LPGUID guids = NULL;
    HDEVINFO devs = INVALID_HANDLE_VALUE;

    if(!argc) {
        return EXIT_USAGE;
    }

    guids = new GUID[reqGuids];
    if(!guids) {
        goto final;
    }

    for(argIndex = 0;argIndex<argc;argIndex++) {
        DWORD numGuids;
        DWORD index;

        if(!(argv[argIndex] && argv[argIndex][0])) {
            continue;
        }

        //
        // there could be one to many name to GUID mapping
        //
        while(!SetupDiClassGuidsFromNameEx(argv[argIndex],guids,reqGuids,&numGuids,Machine,NULL)) {
            if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                goto final;
            }
            delete [] guids;
            reqGuids = numGuids;
            guids = new GUID[reqGuids];
            if(!guids) {
                goto final;
            }
        }
        if(numGuids == 0) {
            FormatToStream(stdout,Machine?MSG_LISTCLASS_NOCLASS:MSG_LISTCLASS_NOCLASS_LOCAL,argv[argIndex],Machine);
            continue;
        }
        for(index = 0;index<numGuids;index++) {
            TCHAR className[MAX_CLASS_NAME_LEN];
            TCHAR classDesc[LINE_LEN];
            DWORD devCount = 0;
            SP_DEVINFO_DATA devInfo;
            DWORD devIndex;

            devs = SetupDiGetClassDevsEx(&guids[index],NULL,NULL,DIGCF_PRESENT,NULL,Machine,NULL);
            if(devs != INVALID_HANDLE_VALUE) {
                //
                // count number of devices
                //
                devInfo.cbSize = sizeof(devInfo);
                while(SetupDiEnumDeviceInfo(devs,devCount,&devInfo)) {
                    devCount++;
                }
            }

            if(!SetupDiClassNameFromGuidEx(&guids[index],className,MAX_CLASS_NAME_LEN,NULL,Machine,NULL)) {
                lstrcpyn(className,TEXT("?"),MAX_CLASS_NAME_LEN);
            }
            if(!SetupDiGetClassDescriptionEx(&guids[index],classDesc,LINE_LEN,NULL,Machine,NULL)) {
                lstrcpyn(classDesc,className,LINE_LEN);
            }

            //
            // how many devices?
            //
            if (!devCount) {
                FormatToStream(stdout,Machine?MSG_LISTCLASS_HEADER_NONE:MSG_LISTCLASS_HEADER_NONE_LOCAL,className,classDesc,Machine);
            } else {
                FormatToStream(stdout,Machine?MSG_LISTCLASS_HEADER:MSG_LISTCLASS_HEADER_LOCAL,devCount,className,classDesc,Machine);
                for(devIndex=0;SetupDiEnumDeviceInfo(devs,devIndex,&devInfo);devIndex++) {
                    DumpDevice(devs,&devInfo);
                }
            }
            if(devs != INVALID_HANDLE_VALUE) {
                SetupDiDestroyDeviceInfoList(devs);
                devs = INVALID_HANDLE_VALUE;
            }
        }
    }

    failcode = 0;

final:

    delete [] guids;

    if(devs != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(devs);
    }

    return failcode;
}

typedef struct {
    DWORD count;
    DWORD control;
    BOOL  reboot;
    LPCTSTR strSuccess;
    LPCTSTR strReboot;
    LPCTSTR strFail;
}
GenericContext;

#define FIND_DEVICE         0x00000001 // display device
#define FIND_STATUS         0x00000002 // display status of device
#define FIND_RESOURCES      0x00000004 // display resources of device
#define FIND_DRIVERFILES    0x00000008 // display drivers used by device
#define FIND_HWIDS          0x00000010 // display hw/compat id's used by device
#define FIND_DRIVERNODES    0x00000020 // display driver nodes for a device.
#define FIND_CLASS          0x00000040 // display device's setup class
#define FIND_STACK          0x00000080 // display device's driver-stack

int FindCallback(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context)
/*++

Routine Description:

    Callback for use by Find/FindAll
    just simply display the device

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext *pFindContext = (GenericContext*)Context;

    if(!pFindContext->control) {
        DumpDevice(Devs,DevInfo);
        pFindContext->count++;
        return EXIT_OK;
    }
    if(!DumpDeviceWithInfo(Devs,DevInfo,NULL)) {
        return EXIT_OK;
    }
    if(pFindContext->control&FIND_DEVICE) {
        DumpDeviceDescr(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_CLASS) {
        DumpDeviceClass(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_STATUS) {
        DumpDeviceStatus(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_RESOURCES) {
        DumpDeviceResources(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_DRIVERFILES) {
        DumpDeviceDriverFiles(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_STACK) {
        DumpDeviceStack(Devs,DevInfo);
    }
    if(pFindContext->control&FIND_HWIDS) {
        DumpDeviceHwIds(Devs,DevInfo);
    }
    if (pFindContext->control&FIND_DRIVERNODES) {
        DumpDeviceDriverNodes(Devs,DevInfo);
    }
    pFindContext->count++;
    return EXIT_OK;
}

int cmdFind(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    FIND <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = 0;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdFindAll(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    FINDALL <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump to stdout
    like find, but also show not-present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = 0;
    failcode = EnumerateDevices(BaseName,Machine,0,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdStatus(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump status to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_STATUS;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}


int cmdResources(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    RESOURCES <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump resources to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_RESOURCES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}


int cmdDriverFiles(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump driver files to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers (FIND_DRIVERFILES)
        //
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_DRIVERFILES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdDriverNodes(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STATUS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump drivernodes to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers (FIND_DRIVERNODES)
        //
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_DRIVERNODES;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdHwIds(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    HWIDS <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump hw/compat id's to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_HWIDS;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}

int cmdStack(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    STACK <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, dump device class and stack to stdout
    note that we only enumerate present devices

Arguments:

    BaseName  - name of executable
    Machine   - if non-NULL, remote machine
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    int failcode;

    if(!argc) {
        return EXIT_USAGE;
    }

    context.count = 0;
    context.control = FIND_DEVICE | FIND_CLASS | FIND_STACK;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,FindCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL_NONE:MSG_FIND_TAIL_NONE_LOCAL,Machine);
        } else {
            FormatToStream(stdout,Machine?MSG_FIND_TAIL:MSG_FIND_TAIL_LOCAL,context.count,Machine);
        }
    }
    return failcode;
}




int ControlCallback(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context)
/*++

Routine Description:

    Callback for use by Enable/Disable/Restart
    Invokes DIF_PROPERTYCHANGE with correct parameters
    uses SetupDiCallClassInstaller so cannot be done for remote devices
    Don't use CM_xxx API's, they bypass class/co-installers and this is bad.

    In Enable case, we try global first, and if still disabled, enable local

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_PROPCHANGE_PARAMS pcp;
    GenericContext *pControlContext = (GenericContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;

    switch(pControlContext->control) {
        case DICS_ENABLE:
            //
            // enable both on global and config-specific profile
            // do global first and see if that succeeded in enabling the device
            // (global enable doesn't mark reboot required if device is still
            // disabled on current config whereas vice-versa isn't true)
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_GLOBAL;
            pcp.HwProfile = 0;
            //
            // don't worry if this fails, we'll get an error when we try config-
            // specific.
            if(SetupDiSetClassInstallParams(Devs,DevInfo,&pcp.ClassInstallHeader,sizeof(pcp))) {
               SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,Devs,DevInfo);
            }
            //
            // now enable on config-specific
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = 0;
            break;

        default:
            //
            // operate on config-specific profile
            //
            pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            pcp.StateChange = pControlContext->control;
            pcp.Scope = DICS_FLAG_CONFIGSPECIFIC;
            pcp.HwProfile = 0;
            break;

    }

    if(!SetupDiSetClassInstallParams(Devs,DevInfo,&pcp.ClassInstallHeader,sizeof(pcp)) ||
       !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,Devs,DevInfo)) {
        //
        // failed to invoke DIF_PROPERTYCHANGE
        //
        DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strFail);
    } else {
        //
        // see if device needs reboot
        //
        devParams.cbSize = sizeof(devParams);
        if(SetupDiGetDeviceInstallParams(Devs,DevInfo,&devParams) && (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT))) {
                DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strReboot);
                pControlContext->reboot = TRUE;
        } else {
            //
            // appears to have succeeded
            //
            DumpDeviceWithInfo(Devs,DevInfo,pControlContext->strSuccess);
        }
        pControlContext->count++;
    }
    return EXIT_OK;
}

int cmdEnable(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    ENABLE <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to enable global, and if needed, config specific

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strEnable[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_ENABLED,strEnable,ARRAYSIZE(strEnable))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_ENABLED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_ENABLE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_ENABLE; // DICS_PROPCHANGE DICS_ENABLE DICS_DISABLE
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strEnable;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_ENABLE_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_ENABLE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_ENABLE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdDisable(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    DISABLE <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to disable global

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strDisable[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_DISABLED,strDisable,ARRAYSIZE(strDisable))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_DISABLED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_DISABLE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_DISABLE; // DICS_PROPCHANGE DICS_ENABLE DICS_DISABLE
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strDisable;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_DISABLE_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_DISABLE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_DISABLE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdRestart(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    RESTART <id> ...
    use EnumerateDevices to do hardwareID matching
    for each match, attempt to restart by issueing a PROPCHANGE

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - passed into EnumerateDevices

Return Value:

    EXIT_xxxx (EXIT_REBOOT if reboot is required)

--*/
{
    GenericContext context;
    TCHAR strRestarted[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_RESTARTED,strRestarted,ARRAYSIZE(strRestarted))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REQUIRES_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_RESTART_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.control = DICS_PROPCHANGE;
    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRestarted;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,ControlCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_RESTART_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_RESTART_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_RESTART_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdReboot(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    REBOOT
    reboot local machine

Arguments:

    BaseName  - name of executable
    Machine   - must be NULL (local machine only)
    argc/argv - remaining parameters - ignored

Return Value:

    EXIT_xxxx

--*/
{
    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    FormatToStream(stdout,MSG_REBOOT);
    return Reboot() ? EXIT_OK : EXIT_FAIL;
}


int cmdUpdate(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:
    UPDATE
    update driver for existing device(s)

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    HMODULE newdevMod = NULL;
    int failcode = EXIT_FAIL;
    UpdateDriverForPlugAndPlayDevicesProto UpdateFn;
    BOOL reboot = FALSE;
    LPCTSTR hwid = NULL;
    LPCTSTR inf = NULL;
    DWORD flags = 0;
    TCHAR InfPath[MAX_PATH];

    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    if(argc<2) {
        //
        // at least HWID required
        //
        return EXIT_USAGE;
    }
    inf = argv[0];
    if(!inf[0]) {
        return EXIT_USAGE;
    }

    hwid = argv[1];
    if(!hwid[0]) {
        return EXIT_USAGE;
    }
    //
    // Inf must be a full pathname
    //
    if(GetFullPathName(inf,MAX_PATH,InfPath,NULL) >= MAX_PATH) {
        //
        // inf pathname too long
        //
        return EXIT_FAIL;
    }
    inf = InfPath;
    flags |= INSTALLFLAG_FORCE;

    //
    // make use of UpdateDriverForPlugAndPlayDevices
    //
    newdevMod = LoadLibrary(TEXT("newdev.dll"));
    if(!newdevMod) {
        goto final;
    }
    UpdateFn = (UpdateDriverForPlugAndPlayDevicesProto)GetProcAddress(newdevMod,UPDATEDRIVERFORPLUGANDPLAYDEVICES);
    if(!UpdateFn)
    {
        goto final;
    }

    FormatToStream(stdout,inf ? MSG_UPDATE_INF : MSG_UPDATE,hwid,inf);

    if(!UpdateFn(NULL,hwid,inf,flags,&reboot)) {
        goto final;
    }

    failcode = reboot ? EXIT_REBOOT : EXIT_OK;

final:

    if(newdevMod) {
        FreeLibrary(newdevMod);
    }

    return EXIT_OK;
}

int cmdInstall(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    INSTALL
    install a device manually

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    HDEVINFO DeviceInfoSet = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DeviceInfoData;
    GUID ClassGUID;
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    TCHAR hwIdList[LINE_LEN+4];
    TCHAR InfPath[MAX_PATH];
    DWORD err;
    int failcode = EXIT_FAIL;
    BOOL reboot = FALSE;
    LPCTSTR hwid = NULL;
    LPCTSTR inf = NULL;
    DWORD flags = 0;
    DWORD len;

    if(Machine) {
        //
        // must be local machine
        //
        return EXIT_USAGE;
    }
    if(argc<2) {
        //
        // at least HWID required
        //
        return EXIT_USAGE;
    }
    inf = argv[0];
    if(!inf[0]) {
        return EXIT_USAGE;
    }

    hwid = argv[1];
    if(!hwid[0]) {
        return EXIT_USAGE;
    }

    //
    // Inf must be a full pathname
    //
    if(GetFullPathName(inf,MAX_PATH,InfPath,NULL) >= MAX_PATH) {
        //
        // inf pathname too long
        //
        return EXIT_FAIL;
    }

    //
    // List of hardware ID's must be double zero-terminated
    //
    ZeroMemory(hwIdList,sizeof(hwIdList));
    lstrcpyn(hwIdList,hwid,LINE_LEN);

    //
    // Use the INF File to extract the Class GUID.
    //
    if (!SetupDiGetINFClass(InfPath,&ClassGUID,ClassName,sizeof(ClassName),0))
    {
        goto final;
    }

    //
    // Create the container for the to-be-created Device Information Element.
    //
    DeviceInfoSet = SetupDiCreateDeviceInfoList(&ClassGUID,0);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        goto final;
    }

    //
    // Now create the element.
    // Use the Class GUID and Name from the INF file.
    //
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiCreateDeviceInfo(DeviceInfoSet,
        ClassName,
        &ClassGUID,
        NULL,
        0,
        DICD_GENERATE_ID,
        &DeviceInfoData))
    {
        goto final;
    }

    //
    // Add the HardwareID to the Device's HardwareID property.
    //
    if(!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
        &DeviceInfoData,
        SPDRP_HARDWAREID,
        (LPBYTE)hwIdList,
        (lstrlen(hwIdList)+1+1)*sizeof(TCHAR)))
    {
        goto final;
    }

    //
    // Transform the registry element into an actual devnode
    // in the PnP HW tree.
    //
    if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
        DeviceInfoSet,
        &DeviceInfoData))
    {
        goto final;
    }

    //
    // update the driver for the device we just created
    //
    failcode = cmdUpdate(BaseName,Machine,argc,argv);

final:

    if (DeviceInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }

    return failcode;
}

int RemoveCallback(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Index,LPVOID Context)
/*++

Routine Description:

    Callback for use by Remove
    Invokes DIF_REMOVE
    uses SetupDiCallClassInstaller so cannot be done for remote devices
    Don't use CM_xxx API's, they bypass class/co-installers and this is bad.

Arguments:

    Devs    )_ uniquely identify the device
    DevInfo )
    Index    - index of device
    Context  - GenericContext

Return Value:

    EXIT_xxxx

--*/
{
    SP_REMOVEDEVICE_PARAMS rmdParams;
    GenericContext *pControlContext = (GenericContext*)Context;
    SP_DEVINSTALL_PARAMS devParams;
    LPCTSTR action = NULL;

    //
    // need hardware ID before trying to remove, as we wont have it after
    //
    TCHAR devID[MAX_DEVICE_ID_LEN];
    LPTSTR desc;
    BOOL b = TRUE;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if((!SetupDiGetDeviceInfoListDetail(Devs,&devInfoListDetail)) ||
            (CM_Get_Device_ID_Ex(DevInfo->DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS)) {
        //
        // skip this
        //
        return NO_ERROR;
    }

    rmdParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    rmdParams.ClassInstallHeader.InstallFunction = DIF_REMOVE;
    rmdParams.Scope = DI_REMOVEDEVICE_GLOBAL;
    rmdParams.HwProfile = 0;
    if(!SetupDiSetClassInstallParams(Devs,DevInfo,&rmdParams.ClassInstallHeader,sizeof(rmdParams)) ||
       !SetupDiCallClassInstaller(DIF_REMOVE,Devs,DevInfo)) {
        //
        // failed to invoke DIF_REMOVE
        //
        action = pControlContext->strFail;
    } else {
        //
        // see if device needs reboot
        //
        devParams.cbSize = sizeof(devParams);
        if(SetupDiGetDeviceInstallParams(Devs,DevInfo,&devParams) && (devParams.Flags & (DI_NEEDRESTART|DI_NEEDREBOOT))) {
            //
            // reboot required
            //
            action = pControlContext->strReboot;
            pControlContext->reboot = TRUE;
        } else {
            //
            // appears to have succeeded
            //
            action = pControlContext->strSuccess;
        }
        pControlContext->count++;
    }
    _tprintf(TEXT("%-60s: %s\n"),devID,action);

    return EXIT_OK;
}

int cmdRemove(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    REMOVE
    remove devices

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{
    GenericContext context;
    TCHAR strRemove[80];
    TCHAR strReboot[80];
    TCHAR strFail[80];
    int failcode = EXIT_FAIL;

    if(!argc) {
        //
        // arguments required
        //
        return EXIT_USAGE;
    }
    if(Machine) {
        //
        // must be local machine as we need to involve class/co installers
        //
        return EXIT_USAGE;
    }
    if(!LoadString(NULL,IDS_REMOVED,strRemove,ARRAYSIZE(strRemove))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REMOVED_REBOOT,strReboot,ARRAYSIZE(strReboot))) {
        return EXIT_FAIL;
    }
    if(!LoadString(NULL,IDS_REMOVE_FAILED,strFail,ARRAYSIZE(strFail))) {
        return EXIT_FAIL;
    }

    context.reboot = FALSE;
    context.count = 0;
    context.strReboot = strReboot;
    context.strSuccess = strRemove;
    context.strFail = strFail;
    failcode = EnumerateDevices(BaseName,Machine,DIGCF_PRESENT,argc,argv,RemoveCallback,&context);

    if(failcode == EXIT_OK) {

        if(!context.count) {
            FormatToStream(stdout,MSG_REMOVE_TAIL_NONE);
        } else if(!context.reboot) {
            FormatToStream(stdout,MSG_REMOVE_TAIL,context.count);
        } else {
            FormatToStream(stdout,MSG_REMOVE_TAIL_REBOOT,context.count);
            failcode = EXIT_REBOOT;
        }
    }
    return failcode;
}

int cmdRescan(LPCTSTR BaseName,LPCTSTR Machine,int argc,TCHAR* argv[])
/*++

Routine Description:

    RESCAN
    rescan for new devices

Arguments:

    BaseName  - name of executable
    Machine   - machine name, must be NULL
    argc/argv - remaining parameters

Return Value:

    EXIT_xxxx

--*/
{

    //
    // reenumerate from the root of the devnode tree
    // totally CM based
    //
    int failcode = EXIT_FAIL;
    HMACHINE machineHandle = NULL;
    DEVINST devRoot;

    if(Machine) {
        if(CM_Connect_Machine(Machine,&machineHandle) != CR_SUCCESS) {
            return failcode;
        }
    }

    if(CM_Locate_DevNode_Ex(&devRoot,NULL,CM_LOCATE_DEVNODE_NORMAL,machineHandle) != CR_SUCCESS) {
        goto final;
    }

    FormatToStream(stdout,Machine ? MSG_RESCAN : MSG_RESCAN_LOCAL);

    if(CM_Reenumerate_DevNode_Ex(devRoot, 0, machineHandle) != CR_SUCCESS) {
        goto final;
    }

    failcode = EXIT_OK;

final:
    if(machineHandle) {
        CM_Disconnect_Machine(machineHandle);
    }

    return failcode;
}





DispatchEntry DispatchTable[] = {
    { TEXT("classes"),      cmdClasses,     MSG_CLASSES_SHORT,     MSG_CLASSES_LONG },
    { TEXT("disable"),      cmdDisable,     MSG_DISABLE_SHORT,     MSG_DISABLE_LONG },
    { TEXT("driverfiles"),  cmdDriverFiles, MSG_DRIVERFILES_SHORT, MSG_DRIVERFILES_LONG },
    { TEXT("drivernodes"),  cmdDriverNodes, MSG_DRIVERNODES_SHORT, MSG_DRIVERNODES_LONG },
    { TEXT("enable"),       cmdEnable,      MSG_ENABLE_SHORT,      MSG_ENABLE_LONG },
    { TEXT("find"),         cmdFind,        MSG_FIND_SHORT,        MSG_FIND_LONG },
    { TEXT("findall"),      cmdFindAll,     MSG_FINDALL_SHORT,     MSG_FINDALL_LONG },
    { TEXT("help"),         cmdHelp,        MSG_HELP_SHORT,        0 },
    { TEXT("hwids"),        cmdHwIds,       MSG_HWIDS_SHORT,       MSG_HWIDS_LONG },
    { TEXT("install"),      cmdInstall,     MSG_INSTALL_SHORT,     MSG_INSTALL_LONG },
    { TEXT("listclass"),    cmdListClass,   MSG_LISTCLASS_SHORT,   MSG_LISTCLASS_LONG },
    { TEXT("reboot"),       cmdReboot,      MSG_REBOOT_SHORT,      MSG_REBOOT_LONG },
    { TEXT("remove"),       cmdRemove,      MSG_REMOVE_SHORT,      MSG_REMOVE_LONG },
    { TEXT("rescan"),       cmdRescan,      MSG_RESCAN_SHORT,      MSG_RESCAN_LONG },
    { TEXT("resources"),    cmdResources,   MSG_RESOURCES_SHORT,   MSG_RESOURCES_LONG },
    { TEXT("restart"),      cmdRestart,     MSG_RESTART_SHORT,     MSG_RESTART_LONG },
    { TEXT("stack"),        cmdStack,       MSG_STACK_SHORT,       MSG_STACK_LONG },
    { TEXT("status"),       cmdStatus,      MSG_STATUS_SHORT,      MSG_STATUS_LONG },
    { TEXT("update"),       cmdUpdate,      MSG_UPDATE_SHORT,      MSG_UPDATE_LONG },
    { TEXT("?"),            cmdHelp,        0,                     0 },
    { NULL,NULL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon\devcon.cpp ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devcon.cpp

Abstract:

    Device Console
    command-line interface for managing devices

@@BEGIN_DDKSPLIT
Author:

    Jamie Hunter (JamieHun) Nov-30-2000

Revision History:

@@END_DDKSPLIT
--*/

#include "devcon.h"

struct IdEntry {
    LPCTSTR String;     // string looking for
    LPCTSTR Wild;       // first wild character if any
    BOOL    InstanceId;
};

void FormatToStream(FILE * stream,DWORD fmt,...)
/*++

Routine Description:

    Format text to stream using a particular msg-id fmt
    Used for displaying localizable messages

Arguments:

    stream              - file stream to output to, stdout or stderr
    fmt                 - message id
    ...                 - parameters %1...

Return Value:

    none

--*/
{
    va_list arglist;
    LPTSTR locbuffer = NULL;
    DWORD count;

    va_start(arglist, fmt);
    count = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                          NULL,
                          fmt,
                          0,              // LANGID
                          (LPTSTR) &locbuffer,
                          0,              // minimum size of buffer
                          &arglist);

    if(locbuffer) {
        if(count) {
            _fputts(locbuffer,stream);
        }
        LocalFree(locbuffer);
    }
}

void Padding(int pad)
/*++

Routine Description:

    Insert padding into line before text

Arguments:

    pad - number of padding tabs to insert

Return Value:

    none

--*/
{
    int c;

    for(c=0;c<pad;c++) {
        fputs("    ",stdout);
    }
}


void Usage(LPCTSTR BaseName)
/*++

Routine Description:

    Display simple usage text

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_USAGE,BaseName);
}

void CommandUsage(LPCTSTR BaseName,LPCTSTR Cmd)
/*++

Routine Description:

    Invalid command usage
    Display how to get help on command

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_COMMAND_USAGE,BaseName,Cmd);
}

void Failure(LPCTSTR BaseName,LPCTSTR Cmd)
/*++

Routine Description:

    Display simple error text for general failure

Arguments:

    BaseName            - name of executable

Return Value:

    none

--*/
{
    FormatToStream(stderr,MSG_FAILURE,BaseName,Cmd);
}

BOOL Reboot()
/*++

Routine Description:

    Attempt to reboot computer

Arguments:

    none

Return Value:

    TRUE if API suceeded

--*/
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // we need to "turn on" reboot privilege
    // if any of this fails, try reboot anyway
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        goto final;
    }

    if(!LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&Luid)) {
        CloseHandle(Token);
        goto final;
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

final:

    //
    // attempt reboot - inform system that this is planned hardware install
    //
    return ExitWindowsEx(EWX_REBOOT, REASON_PLANNED_FLAG|REASON_HWINSTALL);
}

LPTSTR GetDeviceStringProperty(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop)
/*++

Routine Description:

    Return a string property for a device, otherwise NULL

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )
    Prop     - string property to obtain

Return Value:

    string containing description

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    DWORD szChars;

    size = 1024; // initial guess
    buffer = new TCHAR[(size/sizeof(TCHAR))+1];
    if(!buffer) {
        return NULL;
    }
    while(!SetupDiGetDeviceRegistryProperty(Devs,DevInfo,Prop,&dataType,(LPBYTE)buffer,size,&reqSize)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto failed;
        }
        if(dataType != REG_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+1];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    return buffer;

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

LPTSTR GetDeviceDescription(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo)
/*++

Routine Description:

    Return a string containing a description of the device, otherwise NULL
    Always try friendly name first

Arguments:

    Devs    )_ uniquely identify device
    DevInfo )

Return Value:

    string containing description

--*/
{
    LPTSTR desc;
    desc = GetDeviceStringProperty(Devs,DevInfo,SPDRP_FRIENDLYNAME);
    if(!desc) {
        desc = GetDeviceStringProperty(Devs,DevInfo,SPDRP_DEVICEDESC);
    }
    return desc;
}

IdEntry GetIdType(LPCTSTR Id)
/*++

Routine Description:

    Determine if this is instance id or hardware id and if there's any wildcards
    instance ID is prefixed by '@'
    wildcards are '*'


Arguments:

    Id - ptr to string to check

Return Value:

    IdEntry

--*/
{
    IdEntry Entry;

    Entry.InstanceId = FALSE;
    Entry.Wild = NULL;
    Entry.String = Id;

    if(Entry.String[0] == INSTANCEID_PREFIX_CHAR) {
        Entry.InstanceId = TRUE;
        Entry.String = CharNext(Entry.String);
    }
    if(Entry.String[0] == QUOTE_PREFIX_CHAR) {
        //
        // prefix to treat rest of string literally
        //
        Entry.String = CharNext(Entry.String);
    } else {
        //
        // see if any wild characters exist
        //
        Entry.Wild = _tcschr(Entry.String,WILD_CHAR);
    }
    return Entry;
}

LPTSTR * GetMultiSzIndexArray(LPTSTR MultiSz)
/*++

Routine Description:

    Get an index array pointing to the MultiSz passed in

Arguments:

    MultiSz - well formed multi-sz string

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR scan;
    LPTSTR * array;
    int elements;

    for(scan = MultiSz, elements = 0; scan[0] ;elements++) {
        scan += lstrlen(scan)+1;
    }
    array = new LPTSTR[elements+2];
    if(!array) {
        return NULL;
    }
    array[0] = MultiSz;
    array++;
    if(elements) {
        for(scan = MultiSz, elements = 0; scan[0]; elements++) {
            array[elements] = scan;
            scan += lstrlen(scan)+1;
        }
    }
    array[elements] = NULL;
    return array;
}

void DelMultiSz(LPTSTR * Array)
/*++

Routine Description:

    Deletes the string array allocated by GetDevMultiSz/GetRegMultiSz/GetMultiSzIndexArray

Arguments:

    Array - pointer returned by GetMultiSzIndexArray

Return Value:

    None

--*/
{
    if(Array) {
        Array--;
        if(Array[0]) {
            delete [] Array[0];
        }
        delete [] Array;
    }
}

LPTSTR * GetDevMultiSz(HDEVINFO Devs,PSP_DEVINFO_DATA DevInfo,DWORD Prop)
/*++

Routine Description:

    Get a multi-sz device property
    and return as an array of strings

Arguments:

    Devs    - HDEVINFO containing DevInfo
    DevInfo - Specific device
    Prop    - SPDRP_HARDWAREID or SPDRP_COMPATIBLEIDS

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    LPTSTR * array;
    DWORD szChars;

    size = 8192; // initial guess, nothing magic about this
    buffer = new TCHAR[(size/sizeof(TCHAR))+2];
    if(!buffer) {
        return NULL;
    }
    while(!SetupDiGetDeviceRegistryProperty(Devs,DevInfo,Prop,&dataType,(LPBYTE)buffer,size,&reqSize)) {
        if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto failed;
        }
        if(dataType != REG_MULTI_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+2];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    buffer[szChars+1] = TEXT('\0');
    array = GetMultiSzIndexArray(buffer);
    if(array) {
        return array;
    }

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

LPTSTR * GetRegMultiSz(HKEY hKey,LPCTSTR Val)
/*++

Routine Description:

    Get a multi-sz from registry
    and return as an array of strings

Arguments:

    hKey    - Registry Key
    Val     - Value to query

Return Value:

    array of strings. last entry+1 of array contains NULL
    returns NULL on failure

--*/
{
    LPTSTR buffer;
    DWORD size;
    DWORD reqSize;
    DWORD dataType;
    LPTSTR * array;
    DWORD szChars;
    LONG regErr;

    size = 8192; // initial guess, nothing magic about this
    buffer = new TCHAR[(size/sizeof(TCHAR))+2];
    if(!buffer) {
        return NULL;
    }
    reqSize = size;
    while((regErr = RegQueryValueEx(hKey,Val,NULL,&dataType,(PBYTE)buffer,&reqSize) != NO_ERROR)) {
        if(GetLastError() != ERROR_MORE_DATA) {
            goto failed;
        }
        if(dataType != REG_MULTI_SZ) {
            goto failed;
        }
        size = reqSize;
        delete [] buffer;
        buffer = new TCHAR[(size/sizeof(TCHAR))+2];
        if(!buffer) {
            goto failed;
        }
    }
    szChars = reqSize/sizeof(TCHAR);
    buffer[szChars] = TEXT('\0');
    buffer[szChars+1] = TEXT('\0');

    array = GetMultiSzIndexArray(buffer);
    if(array) {
        return array;
    }

failed:
    if(buffer) {
        delete [] buffer;
    }
    return NULL;
}

BOOL WildCardMatch(LPCTSTR Item,const IdEntry & MatchEntry)
/*++

Routine Description:

    Compare a single item against wildcard
    I'm sure there's better ways of implementing this
    Other than a command-line management tools
    it's a bad idea to use wildcards as it implies
    assumptions about the hardware/instance ID
    eg, it might be tempting to enumerate root\* to
    find all root devices, however there is a CfgMgr
    API to query status and determine if a device is
    root enumerated, which doesn't rely on implementation
    details.

Arguments:

    Item - item to find match for eg a\abcd\c
    MatchEntry - eg *\*bc*\*

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    LPCTSTR scanItem;
    LPCTSTR wildMark;
    LPCTSTR nextWild;
    size_t matchlen;

    //
    // before attempting anything else
    // try and compare everything up to first wild
    //
    if(!MatchEntry.Wild) {
        return _tcsicmp(Item,MatchEntry.String) ? FALSE : TRUE;
    }
    if(_tcsnicmp(Item,MatchEntry.String,MatchEntry.Wild-MatchEntry.String) != 0) {
        return FALSE;
    }
    wildMark = MatchEntry.Wild;
    scanItem = Item + (MatchEntry.Wild-MatchEntry.String);

    for(;wildMark[0];) {
        //
        // if we get here, we're either at or past a wildcard
        //
        if(wildMark[0] == WILD_CHAR) {
            //
            // so skip wild chars
            //
            wildMark = CharNext(wildMark);
            continue;
        }
        //
        // find next wild-card
        //
        nextWild = _tcschr(wildMark,WILD_CHAR);
        if(nextWild) {
            //
            // substring
            //
            matchlen = nextWild-wildMark;
        } else {
            //
            // last portion of match
            //
            size_t scanlen = lstrlen(scanItem);
            matchlen = lstrlen(wildMark);
            if(scanlen < matchlen) {
                return FALSE;
            }
            return _tcsicmp(scanItem+scanlen-matchlen,wildMark) ? FALSE : TRUE;
        }
        if(_istalpha(wildMark[0])) {
            //
            // scan for either lower or uppercase version of first character
            //
            TCHAR u = _totupper(wildMark[0]);
            TCHAR l = _totlower(wildMark[0]);
            while(scanItem[0] && scanItem[0]!=u && scanItem[0]!=l) {
                scanItem = CharNext(scanItem);
            }
            if(!scanItem[0]) {
                //
                // ran out of string
                //
                return FALSE;
            }
        } else {
            //
            // scan for first character (no case)
            //
            scanItem = _tcschr(scanItem,wildMark[0]);
            if(!scanItem) {
                //
                // ran out of string
                //
                return FALSE;
            }
        }
        //
        // try and match the sub-string at wildMark against scanItem
        //
        if(_tcsnicmp(scanItem,wildMark,matchlen)!=0) {
            //
            // nope, try again
            //
            scanItem = CharNext(scanItem);
            continue;
        }
        //
        // substring matched
        //
        scanItem += matchlen;
        wildMark += matchlen;
    }
    return (wildMark[0] ? FALSE : TRUE);
}

BOOL WildCompareHwIds(LPTSTR * Array,const IdEntry & MatchEntry)
/*++

Routine Description:

    Compares all strings in Array against Id
    Use WildCardMatch to do real compare

Arguments:

    Array - pointer returned by GetDevMultiSz
    MatchEntry - string to compare against

Return Value:

    TRUE if any match, otherwise FALSE

--*/
{
    if(Array) {
        while(Array[0]) {
            if(WildCardMatch(Array[0],MatchEntry)) {
                return TRUE;
            }
            Array++;
        }
    }
    return FALSE;
}

int EnumerateDevices(LPCTSTR BaseName,LPCTSTR Machine,DWORD Flags,int argc,LPTSTR argv[],CallbackFunc Callback,LPVOID Context)
/*++

Routine Description:

    Generic enumerator for devices that will be passed the following arguments:
    <id> [<id>...]
    =<class> [<id>...]
    where <id> can either be @instance-id, or hardware-id and may contain wildcards
    <class> is a class name

Arguments:

    BaseName - name of executable
    Machine  - name of machine to enumerate
    Flags    - extra enumeration flags (eg DIGCF_PRESENT)
    argc/argv - remaining arguments on command line
    Callback - function to call for each hit
    Context  - data to pass function for each hit

Return Value:

    EXIT_xxxx

--*/
{
    HDEVINFO devs = INVALID_HANDLE_VALUE;
    IdEntry * templ = NULL;
    DWORD err;
    int failcode = EXIT_FAIL;
    int retcode;
    int argIndex;
    DWORD devIndex;
    SP_DEVINFO_DATA devInfo;
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
    BOOL doSearch = FALSE;
    BOOL match;
    BOOL all = FALSE;
    GUID cls;
    DWORD numClass = 0;
    int skip = 0;


    if(!argc) {
        return EXIT_USAGE;
    }

    templ = new IdEntry[argc];
    if(!templ) {
        goto final;
    }

    //
    // determine if a class is specified
    //
    if(argc>skip && argv[skip][0]==CLASS_PREFIX_CHAR && argv[skip][1]) {
        if(!SetupDiClassGuidsFromNameEx(argv[skip]+1,&cls,1,&numClass,Machine,NULL) &&
            GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            goto final;
        }
        if(!numClass) {
            failcode = EXIT_OK;
            goto final;
        }
        skip++;
    }
    if(argc>skip && argv[skip][0]==WILD_CHAR && !argv[skip][1]) {
        //
        // catch convinient case of specifying a single argument '*'
        //
        all = TRUE;
        skip++;
    } else if(argc<=skip) {
        //
        // at least one parameter, but no <id>'s
        //
        all = TRUE;
    }

    //
    // determine if any instance id's were specified
    //
    // note, if =<class> was specified with no id's
    // we'll mark it as not doSearch
    // but will go ahead and add them all
    //
    for(argIndex=skip;argIndex<argc;argIndex++) {
        templ[argIndex] = GetIdType(argv[argIndex]);
        if(templ[argIndex].Wild || !templ[argIndex].InstanceId) {
            //
            // anything other than simple InstanceId's require a search
            //
            doSearch = TRUE;
        }
    }
    if(doSearch || all) {
        //
        // add all id's to list
        // if there's a class, filter on specified class
        //
        devs = SetupDiGetClassDevsEx(numClass ? &cls : NULL,
                                     NULL,
                                     NULL,
                                     (numClass ? 0 : DIGCF_ALLCLASSES) | Flags,
                                     NULL,
                                     Machine,
                                     NULL);

    } else {
        //
        // blank list, we'll add instance id's by hand
        //
        devs = SetupDiCreateDeviceInfoListEx(numClass ? &cls : NULL,
                                             NULL,
                                             Machine,
                                             NULL);
    }
    if(devs == INVALID_HANDLE_VALUE) {
        goto final;
    }
    for(argIndex=skip;argIndex<argc;argIndex++) {
        //
        // add explicit instances to list (even if enumerated all,
        // this gets around DIGCF_PRESENT)
        // do this even if wildcards appear to be detected since they
        // might actually be part of the instance ID of a non-present device
        //
        if(templ[argIndex].InstanceId) {
            SetupDiOpenDeviceInfo(devs,templ[argIndex].String,NULL,0,NULL);
        }
    }

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(devs,&devInfoListDetail)) {
        goto final;
    }

    //
    // now enumerate them
    //
    if(all) {
        doSearch = FALSE;
    }

    devInfo.cbSize = sizeof(devInfo);
    for(devIndex=0;SetupDiEnumDeviceInfo(devs,devIndex,&devInfo);devIndex++) {

        if(doSearch) {
            for(argIndex=skip,match=FALSE;(argIndex<argc) && !match;argIndex++) {
                TCHAR devID[MAX_DEVICE_ID_LEN];
                LPTSTR *hwIds = NULL;
                LPTSTR *compatIds = NULL;
                //
                // determine instance ID
                //
                if(CM_Get_Device_ID_Ex(devInfo.DevInst,devID,MAX_DEVICE_ID_LEN,0,devInfoListDetail.RemoteMachineHandle)!=CR_SUCCESS) {
                    devID[0] = TEXT('\0');
                }

                if(templ[argIndex].InstanceId) {
                    //
                    // match on the instance ID
                    //
                    if(WildCardMatch(devID,templ[argIndex])) {
                        match = TRUE;
                    }
                } else {
                    //
                    // determine hardware ID's
                    // and search for matches
                    //
                    hwIds = GetDevMultiSz(devs,&devInfo,SPDRP_HARDWAREID);
                    compatIds = GetDevMultiSz(devs,&devInfo,SPDRP_COMPATIBLEIDS);

                    if(WildCompareHwIds(hwIds,templ[argIndex]) ||
                        WildCompareHwIds(compatIds,templ[argIndex])) {
                        match = TRUE;
                    }
                }
                DelMultiSz(hwIds);
                DelMultiSz(compatIds);
            }
        } else {
            match = TRUE;
        }
        if(match) {
            retcode = Callback(devs,&devInfo,devIndex,Context);
            if(retcode) {
                failcode = retcode;
                goto final;
            }
        }
    }

    failcode = EXIT_OK;

final:
    if(templ) {
        delete [] templ;
    }
    if(devs != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(devs);
    }
    return failcode;

}

int
__cdecl
_tmain(int argc, LPTSTR argv[])
/*++

Routine Description:

    Main entry point
    interpret -m:<machine>
    and hand off execution to command

Arguments:

    argc/argv - parameters passed to executable

Return Value:

    EXIT_xxxx

--*/
{
    LPCTSTR cmd;
    LPCTSTR baseName;
    LPCTSTR machine = NULL;
    int dispIndex;
    int firstArg = 1;
    int retval = EXIT_USAGE;
    BOOL autoReboot = FALSE;

    //
    // syntax:
    //
    // [options] [-]command [<arg> [<arg>]]
    //
    // options:
    // -m:<machine>  - remote
    // -r            - auto reboot
    //
    baseName = _tcsrchr(argv[0],TEXT('\\'));
    if(!baseName) {
        baseName = argv[0];
    } else {
        baseName = CharNext(baseName);
    }
    while((argc > firstArg) && ((argv[firstArg][0] == TEXT('-')) || (argv[firstArg][0] == TEXT('/')))) {
        if((argv[firstArg][1]==TEXT('m')) || (argv[firstArg][1]==TEXT('M'))) {
            if((argv[firstArg][2]!=TEXT(':')) || (argv[firstArg][3]==TEXT('\0'))) {
                //
                // don't recognize this switch
                //
                break;
            }
            machine = argv[firstArg]+3;
        } else if((argv[firstArg][1]==TEXT('r')) || (argv[firstArg][1]==TEXT('R'))) {
            if((argv[firstArg][2]!=TEXT('\0')) ) {
                //
                // don't recognize this switch
                //
                break;
            } else {
                autoReboot = TRUE;
            }
        } else {
            //
            // don't recognize this switch
            //
            break;
        }
        firstArg++;
    }

    if((argc-firstArg) < 1) {
        //
        // after switches, must at least be command
        //
        Usage(baseName);
        return EXIT_USAGE;
    }
    cmd = argv[firstArg];
    if((cmd[0]==TEXT('-')) || (cmd[0]==TEXT('/'))) {
        //
        // command may begin '-' or '/'
        // eg, people might do devcon -help
        //
        cmd = CharNext(cmd);
    }
    firstArg++;
    for(dispIndex = 0;DispatchTable[dispIndex].cmd;dispIndex++) {
        if(lstrcmpi(cmd,DispatchTable[dispIndex].cmd)==0) {
            retval = DispatchTable[dispIndex].func(baseName,machine,argc-firstArg,argv+firstArg);
            switch(retval) {
                case EXIT_USAGE:
                    CommandUsage(baseName,DispatchTable[dispIndex].cmd);
                    break;
                case EXIT_REBOOT:
                    if(autoReboot) {
                        Reboot();
                    }
                    break;
                case EXIT_OK:
                    break;
                default:
                    Failure(baseName,DispatchTable[dispIndex].cmd);
                    break;
            }
            return retval;
        }
    }
    Usage(baseName);
    return EXIT_USAGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\device.h ===
// Device.h : Declaration of the CDevice

#ifndef __DEVICE_H_
#define __DEVICE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevice
class ATL_NO_VTABLE CDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDevice, &IID_IDevice, &LIBID_DEVCON2Lib>,
	public IDeviceInternal,
	public ISetupClassInternal
{
public:
	CComPtr<IDevInfoSet> DevInfoSet;
	CComPtr<IDeviceConsole> DeviceConsole;
	SP_DEVINFO_DATA DevInfoData;

public:
	CDevice()
	{
		ZeroMemory(&DevInfoData,sizeof(DevInfoData));
	}
	~CDevice();
	HRESULT Init(IDevInfoSet *pDevInfoSet,LPCWSTR pInstance,IDeviceConsole *pDevCon);
	HRESULT Init(IDevInfoSet *pDevInfoSet, PSP_DEVINFO_DATA pData,IDeviceConsole *pDevCon);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDevice)
	COM_INTERFACE_ENTRY(IDevice)
	COM_INTERFACE_ENTRY(IDeviceInternal)
	COM_INTERFACE_ENTRY(ISetupClassInternal)  // because class can be determined from device
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDevice
public:
	STDMETHOD(get__Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get__ClassGuid)(/*[out, retval]*/ GUID *pVal);
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(HasInterface)(/*[in]*/ BSTR Interface,/*[out,retval]*/ VARIANT_BOOL *pFlag);
	STDMETHOD(FindDriverPackages)(/*[in]*/VARIANT ScriptPath,/*[out,retval]*/ LPDISPATCH *pDrivers);
	STDMETHOD(CurrentDriverPackage)(/*[out,retval]*/ LPDISPATCH *pDriver);
	STDMETHOD(RegDelete)(/*[in]*/ BSTR key);
	STDMETHOD(RegWrite)(/*[in]*/ BSTR key,/*[in]*/ VARIANT val,/*[in,optional]*/ VARIANT strType);
	STDMETHOD(RegRead)(/*[in]*/ BSTR key,VARIANT * pValue);
	STDMETHOD(get_IsRemovable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsDisableable)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsRootEnumerated)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_HasPrivateProblem)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get